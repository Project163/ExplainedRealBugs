diff --git a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/alias/ClearJoinHintWithInvalidPropagationShuttle.java b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/alias/ClearJoinHintWithInvalidPropagationShuttle.java
index 426ea68fee2..a37ad91496b 100644
--- a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/alias/ClearJoinHintWithInvalidPropagationShuttle.java
+++ b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/alias/ClearJoinHintWithInvalidPropagationShuttle.java
@@ -21,9 +21,12 @@ package org.apache.flink.table.planner.alias;
 import org.apache.flink.table.planner.hint.FlinkHints;
 import org.apache.flink.table.planner.hint.JoinStrategy;
 
+import org.apache.calcite.rel.BiRel;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelShuttleImpl;
+import org.apache.calcite.rel.hint.Hintable;
 import org.apache.calcite.rel.hint.RelHint;
+import org.apache.calcite.rel.logical.LogicalCorrelate;
 import org.apache.calcite.rel.logical.LogicalJoin;
 
 import java.util.ArrayDeque;
@@ -49,14 +52,23 @@ public class ClearJoinHintWithInvalidPropagationShuttle extends RelShuttleImpl {
 
     @Override
     public RelNode visit(LogicalJoin join) {
-        List<RelHint> hints = join.getHints();
+        return visitBiRel(join);
+    }
+
+    @Override
+    public RelNode visit(LogicalCorrelate correlate) {
+        return visitBiRel(correlate);
+    }
+
+    private RelNode visitBiRel(BiRel biRel) {
+        List<RelHint> hints = ((Hintable) biRel).getHints();
 
         Set<String> allHintNames =
                 hints.stream().map(hint -> hint.hintName).collect(Collectors.toSet());
 
-        // there are no join hints on this Join node
+        // there are no join hints on this Join/Correlate node
         if (allHintNames.stream().noneMatch(JoinStrategy::isJoinStrategy)) {
-            return super.visit(join);
+            return super.visit(biRel);
         }
 
         Optional<RelHint> firstAliasHint =
@@ -64,9 +76,9 @@ public class ClearJoinHintWithInvalidPropagationShuttle extends RelShuttleImpl {
                         .filter(hint -> FlinkHints.HINT_ALIAS.equals(hint.hintName))
                         .findFirst();
 
-        // there are no alias hints on this Join node
+        // there are no alias hints on this Join/Correlate node
         if (!firstAliasHint.isPresent()) {
-            return super.visit(join);
+            return super.visit(biRel);
         }
 
         List<RelHint> joinHintsFromOuterQueryBlock =
@@ -82,10 +94,10 @@ public class ClearJoinHintWithInvalidPropagationShuttle extends RelShuttleImpl {
                         .collect(Collectors.toList());
 
         if (joinHintsFromOuterQueryBlock.isEmpty()) {
-            return super.visit(join);
+            return super.visit(biRel);
         }
 
-        RelNode newJoin = join;
+        RelNode newJoin = biRel;
         ClearOuterJoinHintShuttle clearOuterJoinHintShuttle;
 
         for (RelHint outerJoinHint : joinHintsFromOuterQueryBlock) {
@@ -121,18 +133,28 @@ public class ClearJoinHintWithInvalidPropagationShuttle extends RelShuttleImpl {
             return newNode;
         }
 
+        @Override
+        public RelNode visit(LogicalCorrelate correlate) {
+            return visitBiRel(correlate);
+        }
+
         @Override
         public RelNode visit(LogicalJoin join) {
-            List<RelHint> hints = new ArrayList<>(join.getHints());
+            return visitBiRel(join);
+        }
+
+        private RelNode visitBiRel(BiRel biRel) {
+            Hintable hBiRel = (Hintable) biRel;
+            List<RelHint> hints = new ArrayList<>(hBiRel.getHints());
             Optional<RelHint> invalidJoinHint = getInvalidJoinHint(hints);
 
             // if this join node contains the join hint that needs to be removed
             if (invalidJoinHint.isPresent()) {
                 hints.remove(invalidJoinHint.get());
-                return super.visit(join.withHints(hints));
+                return super.visit(hBiRel.withHints(hints));
             }
 
-            return super.visit(join);
+            return super.visit(biRel);
         }
 
         /**
diff --git a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/FlinkHintStrategies.java b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/FlinkHintStrategies.java
index 8a2b285d1e8..b21472b61bf 100644
--- a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/FlinkHintStrategies.java
+++ b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/FlinkHintStrategies.java
@@ -62,8 +62,10 @@ public abstract class FlinkHintStrategies {
                 // internal join hint used for alias
                 .hintStrategy(
                         FlinkHints.HINT_ALIAS,
-                        // currently, only join hints care about query block alias
-                        HintStrategy.builder(HintPredicates.JOIN)
+                        // currently, only correlate&join hints care about query block alias
+                        HintStrategy.builder(
+                                        HintPredicates.or(
+                                                HintPredicates.CORRELATE, HintPredicates.JOIN))
                                 .optionChecker(fixedSizeListOptionChecker(1))
                                 .build())
                 // TODO semi/anti join with CORRELATE is not supported
diff --git a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/FlinkHints.java b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/FlinkHints.java
index 4e8ce7a7fcb..d49cdad635e 100644
--- a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/FlinkHints.java
+++ b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/FlinkHints.java
@@ -23,10 +23,12 @@ import org.apache.flink.table.planner.plan.rules.logical.WrapJsonAggFunctionArgu
 import org.apache.flink.table.planner.plan.schema.FlinkPreparingTableBase;
 
 import org.apache.calcite.plan.RelOptTable;
+import org.apache.calcite.rel.BiRel;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.RelShuttleImpl;
 import org.apache.calcite.rel.hint.Hintable;
 import org.apache.calcite.rel.hint.RelHint;
+import org.apache.calcite.rel.logical.LogicalCorrelate;
 import org.apache.calcite.rel.logical.LogicalFilter;
 import org.apache.calcite.rel.logical.LogicalJoin;
 import org.apache.calcite.rel.logical.LogicalProject;
@@ -188,18 +190,33 @@ public abstract class FlinkHints {
 
     private static class CapitalizeJoinHintShuttle extends RelShuttleImpl {
 
+        @Override
+        public RelNode visit(LogicalCorrelate correlate) {
+            return visitBiRel(correlate);
+        }
+
         @Override
         public RelNode visit(LogicalJoin join) {
-            List<RelHint> hints = join.getHints();
+            return visitBiRel(join);
+        }
+
+        private RelNode visitBiRel(BiRel biRel) {
+            Hintable hBiRel = (Hintable) biRel;
             AtomicBoolean changed = new AtomicBoolean(false);
             List<RelHint> hintsWithCapitalJoinHints =
-                    hints.stream()
+                    hBiRel.getHints().stream()
                             .map(
                                     hint -> {
                                         String capitalHintName =
                                                 hint.hintName.toUpperCase(Locale.ROOT);
                                         if (JoinStrategy.isJoinStrategy(capitalHintName)) {
                                             changed.set(true);
+                                            if (JoinStrategy.isLookupHint(hint.hintName)) {
+                                                return RelHint.builder(capitalHintName)
+                                                        .hintOptions(hint.kvOptions)
+                                                        .inheritPath(hint.inheritPath)
+                                                        .build();
+                                            }
                                             return RelHint.builder(capitalHintName)
                                                     .hintOptions(hint.listOptions)
                                                     .inheritPath(hint.inheritPath)
@@ -211,9 +228,9 @@ public abstract class FlinkHints {
                             .collect(Collectors.toList());
 
             if (changed.get()) {
-                return super.visit(join.withHints(hintsWithCapitalJoinHints));
+                return super.visit(hBiRel.withHints(hintsWithCapitalJoinHints));
             } else {
-                return super.visit(join);
+                return super.visit(biRel);
             }
         }
     }
diff --git a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/JoinStrategy.java b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/JoinStrategy.java
index 87795fda231..f48c281168c 100644
--- a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/JoinStrategy.java
+++ b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/hint/JoinStrategy.java
@@ -19,6 +19,7 @@
 package org.apache.flink.table.planner.hint;
 
 import java.util.List;
+import java.util.Locale;
 
 /** Currently available join strategies and corresponding join hint names. */
 public enum JoinStrategy {
@@ -61,7 +62,7 @@ public enum JoinStrategy {
 
     public static boolean isJoinStrategy(String hintName) {
         try {
-            JoinStrategy.valueOf(hintName);
+            JoinStrategy.valueOf(hintName.toUpperCase(Locale.ROOT));
             return true;
         } catch (Exception e) {
             return false;
@@ -91,6 +92,8 @@ public enum JoinStrategy {
     }
 
     public static boolean isLookupHint(String hintName) {
-        return isJoinStrategy(hintName) && JoinStrategy.valueOf(hintName) == LOOKUP;
+        String formalizedHintName = hintName.toUpperCase(Locale.ROOT);
+        return isJoinStrategy(formalizedHintName)
+                && JoinStrategy.valueOf(formalizedHintName) == LOOKUP;
     }
 }
diff --git a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/alias/ClearJoinHintWithCapitalizeJoinHintShuttleTest.java b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/alias/ClearJoinHintWithCapitalizeJoinHintShuttleTest.java
new file mode 100644
index 00000000000..210cc122c7d
--- /dev/null
+++ b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/alias/ClearJoinHintWithCapitalizeJoinHintShuttleTest.java
@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.table.planner.alias;
+
+import org.apache.flink.table.api.TableConfig;
+import org.apache.flink.table.planner.functions.sql.FlinkSqlOperatorTable;
+import org.apache.flink.table.planner.hint.FlinkHints;
+import org.apache.flink.table.planner.plan.nodes.exec.spec.LookupJoinHintTestUtil;
+import org.apache.flink.table.planner.utils.TableTestUtil;
+
+import org.apache.calcite.plan.RelOptUtil;
+import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rel.core.CorrelationId;
+import org.apache.calcite.rel.core.JoinRelType;
+import org.apache.calcite.rel.hint.RelHint;
+import org.apache.calcite.rel.type.RelDataType;
+import org.apache.calcite.sql.type.SqlTypeName;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Collections;
+
+/** Tests clearing lookup join hint case-insensitive in stream. */
+public class ClearJoinHintWithCapitalizeJoinHintShuttleTest
+        extends ClearJoinHintWithInvalidPropagationShuttleTestBase {
+
+    @Override
+    TableTestUtil getTableTestUtil() {
+        return streamTestUtil(TableConfig.getDefault());
+    }
+
+    @Override
+    boolean isBatchMode() {
+        return false;
+    }
+
+    @Before
+    public void before() throws Exception {
+        super.before();
+
+        util.tableEnv()
+                .executeSql(
+                        "CREATE TABLE src (\n"
+                                + "  a BIGINT,"
+                                + "  pts AS PROCTIME()\n"
+                                + ") WITH (\n"
+                                + " 'connector' = 'values'\n"
+                                + ")");
+        util.tableEnv()
+                .executeSql(
+                        "CREATE TABLE lookup (\n"
+                                + "  a BIGINT\n"
+                                + ") WITH (\n"
+                                + " 'connector' = 'values'\n"
+                                + ")");
+    }
+
+    @Test
+    public void testClearCaseInsensitiveLookupHint() {
+        // SELECT /*+ lookUp('table'='lookup', 'retry-predicate'='lookup_miss',
+        // 'retry-strategy'='fixed_delay', 'fixed-delay'='155 ms', 'max-attempts'='10',
+        // 'async'='true', 'output-mode'='allow_unordered','capacity'='1000', 'time-out'='300 s')
+        // */ s.a
+        // FROM src s
+        // JOIN lookup FOR SYSTEM_TIME AS OF s.pts AS d
+        // ON s.a=d.a
+        CorrelationId cid = builder.getCluster().createCorrel();
+        RelDataType aType =
+                builder.getTypeFactory()
+                        .createStructType(
+                                Collections.singletonList(
+                                        builder.getTypeFactory().createSqlType(SqlTypeName.BIGINT)),
+                                Collections.singletonList("a"));
+        RelDataType ptsType =
+                builder.getTypeFactory()
+                        .createStructType(
+                                Collections.singletonList(
+                                        builder.getTypeFactory()
+                                                .createProctimeIndicatorType(false)),
+                                Collections.singletonList("pts"));
+        RelNode root =
+                FlinkHints.capitalizeJoinHints(
+                        builder.scan("src")
+                                .scan("lookup")
+                                .snapshot(
+                                        builder.getRexBuilder()
+                                                .makeCall(FlinkSqlOperatorTable.PROCTIME))
+                                .filter(
+                                        builder.equals(
+                                                builder.field(
+                                                        builder.getRexBuilder()
+                                                                .makeCorrel(aType, cid),
+                                                        "a"),
+                                                builder.getRexBuilder().makeInputRef(aType, 0)))
+                                .correlate(
+                                        JoinRelType.INNER,
+                                        cid,
+                                        builder.getRexBuilder().makeInputRef(aType, 0),
+                                        builder.getRexBuilder().makeInputRef(ptsType, 1))
+                                .project(builder.field(1, 0, "a"))
+                                .hints(
+                                        RelHint.builder(FlinkHints.HINT_ALIAS)
+                                                .hintOption("t1")
+                                                .build())
+                                .hints(
+                                        RelHint.builder("lookUp")
+                                                .hintOptions(
+                                                        LookupJoinHintTestUtil
+                                                                .getLookupJoinHintOptions(
+                                                                        "d", true, false))
+                                                .build())
+                                .build());
+        verifyRelPlan(root);
+    }
+
+    @Override
+    public void verifyRelPlan(RelNode node) {
+        String plan = buildRelPlanWithQueryBlockAlias(node);
+        util.assertEqualsOrExpand("beforePropagatingHints", plan, true);
+
+        RelNode rootAfterHintPropagation = RelOptUtil.propagateRelHints(node, false);
+        plan = buildRelPlanWithQueryBlockAlias(rootAfterHintPropagation);
+        util.assertEqualsOrExpand("afterPropagatingHints", plan, true);
+
+        RelNode rootAfterHintCapitalize = FlinkHints.capitalizeJoinHints(rootAfterHintPropagation);
+        plan = buildRelPlanWithQueryBlockAlias(rootAfterHintCapitalize);
+        util.assertEqualsOrExpand("afterCapitalizeJoinHints", plan, true);
+
+        RelNode rootAfterClearingJoinHintWithInvalidPropagation =
+                rootAfterHintCapitalize.accept(new ClearJoinHintWithInvalidPropagationShuttle());
+        plan = buildRelPlanWithQueryBlockAlias(rootAfterClearingJoinHintWithInvalidPropagation);
+        util.assertEqualsOrExpand("afterClearingJoinHints", plan, false);
+    }
+}
diff --git a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/alias/ClearLookupJoinHintWithInvalidPropagationShuttleTest.java b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/alias/ClearLookupJoinHintWithInvalidPropagationShuttleTest.java
index a261f514452..13c8f7e6eb5 100644
--- a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/alias/ClearLookupJoinHintWithInvalidPropagationShuttleTest.java
+++ b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/alias/ClearLookupJoinHintWithInvalidPropagationShuttleTest.java
@@ -18,18 +18,31 @@
 
 package org.apache.flink.table.planner.alias;
 
+import org.apache.flink.table.annotation.DataTypeHint;
+import org.apache.flink.table.annotation.FunctionHint;
 import org.apache.flink.table.api.TableConfig;
+import org.apache.flink.table.functions.TableFunction;
 import org.apache.flink.table.planner.functions.sql.FlinkSqlOperatorTable;
 import org.apache.flink.table.planner.hint.FlinkHints;
 import org.apache.flink.table.planner.plan.nodes.exec.spec.LookupJoinHintTestUtil;
 import org.apache.flink.table.planner.utils.TableTestUtil;
 
+import org.apache.calcite.plan.RelOptCluster;
 import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rel.core.CorrelationId;
 import org.apache.calcite.rel.core.JoinRelType;
 import org.apache.calcite.rel.hint.RelHint;
+import org.apache.calcite.rel.logical.LogicalValues;
+import org.apache.calcite.rel.type.RelDataType;
+import org.apache.calcite.sql.SqlOperatorBinding;
+import org.apache.calcite.sql.fun.SqlCollectionTableOperator;
+import org.apache.calcite.sql.type.SqlTypeName;
+import org.apache.calcite.sql.validate.SqlModality;
 import org.junit.Before;
 import org.junit.Test;
 
+import java.util.Collections;
+
 /** Tests clearing lookup join hint with invalid propagation in stream. */
 public class ClearLookupJoinHintWithInvalidPropagationShuttleTest
         extends ClearJoinHintWithInvalidPropagationShuttleTestBase {
@@ -50,7 +63,9 @@ public class ClearLookupJoinHintWithInvalidPropagationShuttleTest
         util.tableEnv()
                 .executeSql(
                         "CREATE TABLE src (\n"
-                                + "  a BIGINT\n"
+                                + "  a BIGINT,"
+                                + "  ds ARRAY<BIGINT>,"
+                                + "  pts AS PROCTIME()\n"
                                 + ") WITH (\n"
                                 + " 'connector' = 'values'\n"
                                 + ")");
@@ -61,89 +76,196 @@ public class ClearLookupJoinHintWithInvalidPropagationShuttleTest
                                 + ") WITH (\n"
                                 + " 'connector' = 'values'\n"
                                 + ")");
+        util.tableEnv()
+                .createTemporarySystemFunction(
+                        "MockOffset",
+                        new ClearLookupJoinHintWithInvalidPropagationShuttleTest
+                                .MockOffsetTableFunction());
     }
 
     @Test
     public void testNoNeedToClearLookupHint() {
         // SELECT /*+ LOOKUP('table'='lookup', 'retry-predicate'='lookup_miss',
-        // 'retry-strategy'='fixed_delay', 'fixed-delay'='155 ms', 'max-attempts'='10') ) */ *
-        //  FROM src
-        //  JOIN lookup FOR SYSTEM_TIME AS OF T.proctime AS D
-        //      ON T.a = D.a
+        // 'retry-strategy'='fixed_delay', 'fixed-delay'='155 ms', 'max-attempts'='10',
+        // 'async'='true', 'output-mode'='allow_unordered','capacity'='1000', 'time-out'='300 s')
+        // */ s.a
+        // FROM src s
+        // JOIN lookup FOR SYSTEM_TIME AS OF s.pts AS d
+        // ON s.a=d.a
+        CorrelationId cid = builder.getCluster().createCorrel();
+        RelDataType aType =
+                builder.getTypeFactory()
+                        .createStructType(
+                                Collections.singletonList(
+                                        builder.getTypeFactory().createSqlType(SqlTypeName.BIGINT)),
+                                Collections.singletonList("a"));
+        RelDataType ptsType =
+                builder.getTypeFactory()
+                        .createStructType(
+                                Collections.singletonList(
+                                        builder.getTypeFactory()
+                                                .createProctimeIndicatorType(false)),
+                                Collections.singletonList("pts"));
         RelNode root =
                 builder.scan("src")
                         .scan("lookup")
                         .snapshot(builder.getRexBuilder().makeCall(FlinkSqlOperatorTable.PROCTIME))
-                        .join(
+                        .filter(
+                                builder.equals(
+                                        builder.field(
+                                                builder.getRexBuilder().makeCorrel(aType, cid),
+                                                "a"),
+                                        builder.getRexBuilder().makeInputRef(aType, 0)))
+                        .correlate(
                                 JoinRelType.INNER,
-                                builder.equals(builder.field(2, 0, "a"), builder.field(2, 1, "a")))
+                                cid,
+                                builder.getRexBuilder().makeInputRef(aType, 0),
+                                builder.getRexBuilder().makeInputRef(ptsType, 1))
                         .project(builder.field(1, 0, "a"))
-                        .hints(LookupJoinHintTestUtil.getLookupJoinHint("lookup", false, true))
+                        .hints(RelHint.builder(FlinkHints.HINT_ALIAS).hintOption("t1").build())
+                        .hints(LookupJoinHintTestUtil.getLookupJoinHint("d", true, false))
                         .build();
         verifyRelPlan(root);
     }
 
     @Test
-    public void testClearLookupHintWithInvalidPropagationToViewWhileViewHasLookupHints() {
-        // SELECT /*+ LOOKUP('table'='lookup', 'retry-predicate'='lookup_miss',
-        // 'retry-strategy'='fixed_delay', 'fixed-delay'='155 ms', 'max-attempts'='10') ) */ *
-        //   FROM (
-        //     SELECT /*+ LOOKUP('table'='lookup', 'async'='true', 'output-mode'='allow_unordered',
-        // 'capacity'='1000', 'time-out'='300 s'
-        //       src.a, src.proctime
-        //     FROM src
-        //       JOIN lookup FOR SYSTEM_TIME AS OF T.proctime AS D
-        //         ON T.a = D.id
-        //     ) t1 JOIN lookup FOR SYSTEM_TIME AS OF t1.proctime AS t2 ON t1.a = t2.a
+    public void testClearLookupHintWithInvalidPropagationToSubQuery() {
+        // SELECT /*+ LOOKUP('table'='src', 'retry-predicate'='lookup_miss',
+        // 'retry-strategy'='fixed_delay', 'fixed-delay'='155 ms', 'max-attempts'='10',
+        // 'async'='true', 'output-mode'='allow_unordered','capacity'='1000', 'time-out'='300 s')
+        // */ t1.a
+        //  FROM (
+        //      SELECT s.a
+        //      FROM src s
+        //      JOIN lookup FOR SYSTEM_TIME AS OF s.pts AS d
+        //      ON s.a=d.a
+        //  ) t1
+        //  JOIN src t2
+        //  ON t1.a=t2.a
+
+        CorrelationId cid = builder.getCluster().createCorrel();
+        RelDataType aType =
+                builder.getTypeFactory()
+                        .createStructType(
+                                Collections.singletonList(
+                                        builder.getTypeFactory().createSqlType(SqlTypeName.BIGINT)),
+                                Collections.singletonList("a"));
+        RelDataType ptsType =
+                builder.getTypeFactory()
+                        .createStructType(
+                                Collections.singletonList(
+                                        builder.getTypeFactory()
+                                                .createProctimeIndicatorType(false)),
+                                Collections.singletonList("pts"));
         RelNode root =
                 builder.scan("src")
                         .scan("lookup")
                         .snapshot(builder.getRexBuilder().makeCall(FlinkSqlOperatorTable.PROCTIME))
-                        .join(
+                        .filter(
+                                builder.equals(
+                                        builder.field(
+                                                builder.getRexBuilder().makeCorrel(aType, cid),
+                                                "a"),
+                                        builder.getRexBuilder().makeInputRef(aType, 0)))
+                        .correlate(
                                 JoinRelType.INNER,
-                                builder.equals(builder.field(2, 0, "a"), builder.field(2, 1, "a")))
+                                cid,
+                                builder.getRexBuilder().makeInputRef(aType, 0),
+                                builder.getRexBuilder().makeInputRef(ptsType, 1))
                         .project(builder.field(1, 0, "a"))
-                        .hints(LookupJoinHintTestUtil.getLookupJoinHint("lookup", false, true))
                         .hints(RelHint.builder(FlinkHints.HINT_ALIAS).hintOption("t1").build())
+                        .hints(LookupJoinHintTestUtil.getLookupJoinHint("d", true, false))
                         .scan("src")
-                        .snapshot(builder.getRexBuilder().makeCall(FlinkSqlOperatorTable.PROCTIME))
+                        .hints(RelHint.builder(FlinkHints.HINT_ALIAS).hintOption("t2").build())
                         .join(
                                 JoinRelType.INNER,
                                 builder.equals(builder.field(2, 0, "a"), builder.field(2, 1, "a")))
                         .project(builder.field(1, 0, "a"))
-                        .hints(LookupJoinHintTestUtil.getLookupJoinHint("lookup", true, false))
+                        .hints(LookupJoinHintTestUtil.getLookupJoinHint("src", true, true))
                         .build();
         verifyRelPlan(root);
     }
 
     @Test
-    public void testClearLookupHintWithInvalidPropagationToSubQuery() {
-        // SELECT /*+ LOOKUP('table'='lookup', 'retry-predicate'='lookup_miss',
-        // 'retry-strategy'='fixed_delay', 'fixed-delay'='155 ms', 'max-attempts'='10',
-        // 'async'='true', 'output-mode'='allow_unordered','capacity'='1000', 'time-out'='300 s' */*
-        //   FROM (
-        //     SELECT src.a
-        //     FROM src
-        //     JOIN lookup FOR SYSTEM_TIME AS OF T.proctime AS D
-        //       ON T.a = D.id
-        //   ) t1 JOIN src t2 ON t1.a = t2.a
+    public void testNoNeedToClearLookupHintWhileJoinWithUnnest() {
+        //  SELECT /*+ LOOKUP('table'='d', 'retry-predicate'='lookup_miss',
+        //  'retry-strategy'='fixed_delay', 'fixed-delay'='155 ms', 'max-attempts'='10',
+        //  'async'='true', 'output-mode'='allow_unordered','capacity'='1000', 'time-out'='300 s')
+        //  */ s.a
+        //  FROM src s
+        //  CROSS JOIN UNNEST(s.ds) AS d(a)
+
+        CorrelationId cid = builder.getCluster().createCorrel();
+        RelDataType dsType =
+                builder.getTypeFactory()
+                        .createStructType(
+                                Collections.singletonList(
+                                        builder.getTypeFactory()
+                                                .createArrayType(
+                                                        builder.getTypeFactory()
+                                                                .createSqlType(SqlTypeName.BIGINT),
+                                                        -1L)),
+                                Collections.singletonList("ds"));
+        RelOptCluster cluster = util.getPlanner().plannerContext().getCluster();
         RelNode root =
                 builder.scan("src")
-                        .scan("lookup")
-                        .snapshot(builder.getRexBuilder().makeCall(FlinkSqlOperatorTable.PROCTIME))
-                        .join(
-                                JoinRelType.INNER,
-                                builder.equals(builder.field(2, 0, "a"), builder.field(2, 1, "a")))
                         .project(builder.field(1, 0, "a"))
-                        .hints(RelHint.builder(FlinkHints.HINT_ALIAS).hintOption("t1").build())
-                        .scan("src")
-                        .hints(RelHint.builder(FlinkHints.HINT_ALIAS).hintOption("t2").build())
-                        .join(
-                                JoinRelType.INNER,
-                                builder.equals(builder.field(2, 0, "a"), builder.field(2, 1, "a")))
+                        .push(LogicalValues.createOneRow(cluster))
+                        .project(
+                                builder.field(
+                                        builder.getRexBuilder().makeCorrel(dsType, cid), "ds"))
+                        .uncollect(Collections.singletonList("a"), false)
+                        .project(builder.field(1, 0, "a"))
+                        .correlate(JoinRelType.INNER, cid)
                         .project(builder.field(1, 0, "a"))
-                        .hints(LookupJoinHintTestUtil.getLookupJoinHint("lookup", true, true))
+                        .hints(LookupJoinHintTestUtil.getLookupJoinHint("d", true, false))
                         .build();
         verifyRelPlan(root);
     }
+
+    @Test
+    public void testNoNeedToClearLookupHintWhileJoinWithUDTF() {
+        //  SELECT /*+ LOOKUP('table'='d', 'retry-predicate'='lookup_miss',
+        //  'retry-strategy'='fixed_delay', 'fixed-delay'='155 ms', 'max-attempts'='10',
+        //  'async'='true', 'output-mode'='allow_unordered','capacity'='1000', 'time-out'='300 s')
+        //  */ s.a
+        //  FROM src s
+        //  CROSS JOIN LATERAL TABLE(MockOffset(a)) AS d(b)
+
+        CorrelationId cid = builder.getCluster().createCorrel();
+        RelDataType bType =
+                builder.getTypeFactory()
+                        .createStructType(
+                                Collections.singletonList(
+                                        builder.getTypeFactory().createSqlType(SqlTypeName.BIGINT)),
+                                Collections.singletonList("b"));
+        RelNode root =
+                builder.scan("src")
+                        .project(builder.field(1, 0, "a"))
+                        .functionScan(
+                                new SqlCollectionTableOperator("TABLE", SqlModality.RELATION) {
+                                    @Override
+                                    public RelDataType inferReturnType(
+                                            SqlOperatorBinding opBinding) {
+                                        return bType;
+                                    }
+                                },
+                                0,
+                                builder.getRexBuilder()
+                                        .makeFieldAccess(
+                                                builder.getRexBuilder().makeCorrel(bType, cid), 0))
+                        .correlate(JoinRelType.INNER, cid)
+                        .project(builder.field(1, 0, "a"))
+                        .hints(LookupJoinHintTestUtil.getLookupJoinHint("d", true, false))
+                        .build();
+        verifyRelPlan(root);
+    }
+
+    /** Mock UDTF, used for JOIN LATERAL TABLE test. */
+    @FunctionHint(output = @DataTypeHint("ROW< b BIGINT >"))
+    public static class MockOffsetTableFunction extends TableFunction<Long> {
+        public void eval(Long arg) {
+            collect(arg + 10L);
+        }
+    }
 }
diff --git a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/spec/LookupJoinHintTestUtil.java b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/spec/LookupJoinHintTestUtil.java
index 9dc113c560a..15070d2eb0d 100644
--- a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/spec/LookupJoinHintTestUtil.java
+++ b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/nodes/exec/spec/LookupJoinHintTestUtil.java
@@ -34,6 +34,18 @@ public class LookupJoinHintTestUtil {
     public static RelHint lookupHintWithTableOnly = getLookupJoinHint(false, false);
 
     public static RelHint getLookupJoinHint(String table, boolean withAsync, boolean withRetry) {
+        Map<String, String> kvOptions = getLookupJoinHintOptions(table, withAsync, withRetry);
+        return RelHint.builder(JoinStrategy.LOOKUP.getJoinHintName())
+                .hintOptions(kvOptions)
+                .build();
+    }
+
+    public static RelHint getLookupJoinHint(boolean withAsync, boolean withRetry) {
+        return getLookupJoinHint("TestTable", withAsync, withRetry);
+    }
+
+    public static Map<String, String> getLookupJoinHintOptions(
+            String table, boolean withAsync, boolean withRetry) {
         Map<String, String> kvOptions = new HashMap<>();
         kvOptions.put(LookupJoinHintOptions.LOOKUP_TABLE.key(), table);
         if (withAsync) {
@@ -42,23 +54,17 @@ public class LookupJoinHintTestUtil {
         if (withRetry) {
             addRetryOptions(kvOptions);
         }
-        return RelHint.builder(JoinStrategy.LOOKUP.getJoinHintName())
-                .hintOptions(kvOptions)
-                .build();
-    }
-
-    public static RelHint getLookupJoinHint(boolean withAsync, boolean withRetry) {
-        return getLookupJoinHint("TestTable", withAsync, withRetry);
+        return kvOptions;
     }
 
-    private static void addAsyncOptions(Map<String, String> kvOptions) {
+    public static void addAsyncOptions(Map<String, String> kvOptions) {
         kvOptions.put(LookupJoinHintOptions.ASYNC_LOOKUP.key(), "true");
         kvOptions.put(LookupJoinHintOptions.ASYNC_CAPACITY.key(), "1000");
         kvOptions.put(LookupJoinHintOptions.ASYNC_OUTPUT_MODE.key(), "allow_unordered");
         kvOptions.put(LookupJoinHintOptions.ASYNC_TIMEOUT.key(), "300 s");
     }
 
-    private static void addRetryOptions(Map<String, String> kvOptions) {
+    public static void addRetryOptions(Map<String, String> kvOptions) {
         kvOptions.put(LookupJoinHintOptions.RETRY_PREDICATE.key(), "lookup_miss");
         kvOptions.put(LookupJoinHintOptions.RETRY_STRATEGY.key(), "fixed_delay");
         kvOptions.put(LookupJoinHintOptions.FIXED_DELAY.key(), "155 ms");
diff --git a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/alias/ClearJoinHintWithCapitalizeJoinHintShuttleTest.xml b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/alias/ClearJoinHintWithCapitalizeJoinHintShuttleTest.xml
new file mode 100644
index 00000000000..64dd53cb732
--- /dev/null
+++ b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/alias/ClearJoinHintWithCapitalizeJoinHintShuttleTest.xml
@@ -0,0 +1,65 @@
+<?xml version="1.0" ?>
+<!--
+Licensed to the Apache Software Foundation (ASF) under one or more
+contributor license agreements.  See the NOTICE file distributed with
+this work for additional information regarding copyright ownership.
+The ASF licenses this file to you under the Apache License, Version 2.0
+(the "License"); you may not use this file except in compliance with
+the License.  You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+-->
+<Root>
+  <TestCase name="testClearCaseInsensitiveLookupHint">
+    <Resource name="beforePropagatingHints">
+      <![CDATA[
+LogicalProject(a=[$0], hints=[[[ALIAS options:[t1]]]]), rowType=[RecordType(BIGINT a)]
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 1}]), rowType=[RecordType(BIGINT a, TIMESTAMP_LTZ(3) *PROCTIME* pts, BIGINT a0)]
+   :- LogicalProject(a=[$0], pts=[PROCTIME()]), rowType=[RecordType(BIGINT a, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
+   :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
+   +- LogicalFilter(condition=[=($cor0.a, $0)]), rowType=[RecordType(BIGINT a)]
+      +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
+         +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
+]]>
+    </Resource>
+    <Resource name="afterPropagatingHints">
+      <![CDATA[
+LogicalProject(a=[$0], hints=[[[ALIAS options:[t1]]]]), rowType=[RecordType(BIGINT a)]
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 1}], joinHints=[[[lookUp inheritPath:[0] options:{async=true, output-mode=allow_unordered, table=d, timeout=300 s, capacity=1000}]]], hints=[[[ALIAS inheritPath:[0] options:[t1]]]]), rowType=[RecordType(BIGINT a, TIMESTAMP_LTZ(3) *PROCTIME* pts, BIGINT a0)]
+   :- LogicalProject(a=[$0], pts=[PROCTIME()]), rowType=[RecordType(BIGINT a, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
+   :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
+   +- LogicalFilter(condition=[=($cor0.a, $0)]), rowType=[RecordType(BIGINT a)]
+      +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
+         +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
+]]>
+    </Resource>
+    <Resource name="afterCapitalizeJoinHints">
+      <![CDATA[
+LogicalProject(a=[$0], hints=[[[ALIAS options:[t1]]]]), rowType=[RecordType(BIGINT a)]
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 1}], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, output-mode=allow_unordered, table=d, timeout=300 s, capacity=1000}]]], hints=[[[ALIAS inheritPath:[0] options:[t1]]]]), rowType=[RecordType(BIGINT a, TIMESTAMP_LTZ(3) *PROCTIME* pts, BIGINT a0)]
+   :- LogicalProject(a=[$0], pts=[PROCTIME()]), rowType=[RecordType(BIGINT a, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
+   :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
+   +- LogicalFilter(condition=[=($cor0.a, $0)]), rowType=[RecordType(BIGINT a)]
+      +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
+         +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
+]]>
+    </Resource>
+    <Resource name="afterClearingJoinHints">
+      <![CDATA[
+LogicalProject(a=[$0], hints=[[[ALIAS options:[t1]]]]), rowType=[RecordType(BIGINT a)]
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 1}], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, output-mode=allow_unordered, table=d, timeout=300 s, capacity=1000}]]], hints=[[[ALIAS inheritPath:[0] options:[t1]]]]), rowType=[RecordType(BIGINT a, TIMESTAMP_LTZ(3) *PROCTIME* pts, BIGINT a0)]
+   :- LogicalProject(a=[$0], pts=[PROCTIME()]), rowType=[RecordType(BIGINT a, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
+   :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
+   +- LogicalFilter(condition=[=($cor0.a, $0)]), rowType=[RecordType(BIGINT a)]
+      +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
+         +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
+]]>
+    </Resource>
+  </TestCase>
+</Root>
diff --git a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/alias/ClearLookupJoinHintWithInvalidPropagationShuttleTest.xml b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/alias/ClearLookupJoinHintWithInvalidPropagationShuttleTest.xml
index f6823b468d6..5a2a11c24cb 100644
--- a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/alias/ClearLookupJoinHintWithInvalidPropagationShuttleTest.xml
+++ b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/alias/ClearLookupJoinHintWithInvalidPropagationShuttleTest.xml
@@ -19,29 +19,35 @@ limitations under the License.
   <TestCase name="testNoNeedToClearLookupHint">
     <Resource name="beforePropagatingHints">
       <![CDATA[
-LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
-+- LogicalJoin(condition=[=($0, $1)], joinType=[inner]), rowType=[RecordType(BIGINT a, BIGINT a0)]
-   :- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
-   +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
-      +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
+LogicalProject(a=[$0], hints=[[[ALIAS options:[t1]]]]), rowType=[RecordType(BIGINT a)]
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 1}]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts, BIGINT a0)]
+   :- LogicalProject(a=[$0], ds=[$1], pts=[PROCTIME()]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
+   :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
+   +- LogicalFilter(condition=[=($cor0.a, $0)]), rowType=[RecordType(BIGINT a)]
+      +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
+         +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
 ]]>
     </Resource>
     <Resource name="afterPropagatingHints">
       <![CDATA[
-LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
-+- LogicalJoin(condition=[=($0, $1)], joinType=[inner], joinHints=[[[LOOKUP inheritPath:[0] options:{retry-strategy=fixed_delay, max-attempts=10, fixed-delay=155 ms, retry-predicate=lookup_miss, table=lookup}]]]), rowType=[RecordType(BIGINT a, BIGINT a0)]
-   :- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
-   +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
-      +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
+LogicalProject(a=[$0], hints=[[[ALIAS options:[t1]]]]), rowType=[RecordType(BIGINT a)]
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 1}], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, output-mode=allow_unordered, table=d, timeout=300 s, capacity=1000}]]], hints=[[[ALIAS inheritPath:[0] options:[t1]]]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts, BIGINT a0)]
+   :- LogicalProject(a=[$0], ds=[$1], pts=[PROCTIME()]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
+   :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
+   +- LogicalFilter(condition=[=($cor0.a, $0)]), rowType=[RecordType(BIGINT a)]
+      +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
+         +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
 ]]>
     </Resource>
     <Resource name="afterClearingJoinHints">
       <![CDATA[
-LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
-+- LogicalJoin(condition=[=($0, $1)], joinType=[inner], joinHints=[[[LOOKUP inheritPath:[0] options:{retry-strategy=fixed_delay, max-attempts=10, fixed-delay=155 ms, retry-predicate=lookup_miss, table=lookup}]]]), rowType=[RecordType(BIGINT a, BIGINT a0)]
-   :- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
-   +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
-      +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
+LogicalProject(a=[$0], hints=[[[ALIAS options:[t1]]]]), rowType=[RecordType(BIGINT a)]
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 1}], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, output-mode=allow_unordered, table=d, timeout=300 s, capacity=1000}]]], hints=[[[ALIAS inheritPath:[0] options:[t1]]]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts, BIGINT a0)]
+   :- LogicalProject(a=[$0], ds=[$1], pts=[PROCTIME()]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
+   :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
+   +- LogicalFilter(condition=[=($cor0.a, $0)]), rowType=[RecordType(BIGINT a)]
+      +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
+         +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
 ]]>
     </Resource>
   </TestCase>
@@ -49,78 +55,110 @@ LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
     <Resource name="beforePropagatingHints">
       <![CDATA[
 LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
-+- LogicalJoin(condition=[=($0, $1)], joinType=[inner]), rowType=[RecordType(BIGINT a, BIGINT a0)]
++- LogicalJoin(condition=[=($0, $1)], joinType=[inner]), rowType=[RecordType(BIGINT a, BIGINT a0, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
    :- LogicalProject(a=[$0], hints=[[[ALIAS options:[t1]]]]), rowType=[RecordType(BIGINT a)]
-   :  +- LogicalJoin(condition=[=($0, $1)], joinType=[inner]), rowType=[RecordType(BIGINT a, BIGINT a0)]
-   :     :- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
-   :     +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
-   :        +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
-   +- LogicalTableScan(table=[[builtin, default, src]], hints=[[[ALIAS inheritPath:[] options:[t2]]]]), rowType=[RecordType(BIGINT a)]
+   :  +- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 1}]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts, BIGINT a0)]
+   :     :- LogicalProject(a=[$0], ds=[$1], pts=[PROCTIME()]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
+   :     :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
+   :     +- LogicalFilter(condition=[=($cor0.a, $0)]), rowType=[RecordType(BIGINT a)]
+   :        +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
+   :           +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
+   +- LogicalProject(a=[$0], ds=[$1], pts=[PROCTIME()], hints=[[[ALIAS options:[t2]]]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
+      +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
 ]]>
     </Resource>
     <Resource name="afterPropagatingHints">
       <![CDATA[
 LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
-+- LogicalJoin(condition=[=($0, $1)], joinType=[inner], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, retry-strategy=fixed_delay, max-attempts=10, output-mode=allow_unordered, fixed-delay=155 ms, retry-predicate=lookup_miss, table=lookup, timeout=300 s, capacity=1000}]]]), rowType=[RecordType(BIGINT a, BIGINT a0)]
++- LogicalJoin(condition=[=($0, $1)], joinType=[inner], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, retry-strategy=fixed_delay, max-attempts=10, output-mode=allow_unordered, fixed-delay=155 ms, retry-predicate=lookup_miss, table=src, timeout=300 s, capacity=1000}]]]), rowType=[RecordType(BIGINT a, BIGINT a0, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
    :- LogicalProject(a=[$0], hints=[[[ALIAS options:[t1]]]]), rowType=[RecordType(BIGINT a)]
-   :  +- LogicalJoin(condition=[=($0, $1)], joinType=[inner], joinHints=[[[LOOKUP inheritPath:[0, 0, 0] options:{async=true, retry-strategy=fixed_delay, max-attempts=10, output-mode=allow_unordered, fixed-delay=155 ms, retry-predicate=lookup_miss, table=lookup, timeout=300 s, capacity=1000}]]], hints=[[[ALIAS inheritPath:[0] options:[t1]]]]), rowType=[RecordType(BIGINT a, BIGINT a0)]
-   :     :- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
-   :     +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
-   :        +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
-   +- LogicalTableScan(table=[[builtin, default, src]], hints=[[[ALIAS inheritPath:[] options:[t2]]]]), rowType=[RecordType(BIGINT a)]
+   :  +- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 1}], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, output-mode=allow_unordered, table=d, timeout=300 s, capacity=1000}][LOOKUP inheritPath:[0, 0, 0] options:{async=true, retry-strategy=fixed_delay, max-attempts=10, output-mode=allow_unordered, fixed-delay=155 ms, retry-predicate=lookup_miss, table=src, timeout=300 s, capacity=1000}]]], hints=[[[ALIAS inheritPath:[0] options:[t1]]]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts, BIGINT a0)]
+   :     :- LogicalProject(a=[$0], ds=[$1], pts=[PROCTIME()]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
+   :     :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
+   :     +- LogicalFilter(condition=[=($cor0.a, $0)]), rowType=[RecordType(BIGINT a)]
+   :        +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
+   :           +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
+   +- LogicalProject(a=[$0], ds=[$1], pts=[PROCTIME()], hints=[[[ALIAS options:[t2]]]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
+      +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
 ]]>
     </Resource>
     <Resource name="afterClearingJoinHints">
       <![CDATA[
 LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
-+- LogicalJoin(condition=[=($0, $1)], joinType=[inner], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, retry-strategy=fixed_delay, max-attempts=10, output-mode=allow_unordered, fixed-delay=155 ms, retry-predicate=lookup_miss, table=lookup, timeout=300 s, capacity=1000}]]]), rowType=[RecordType(BIGINT a, BIGINT a0)]
++- LogicalJoin(condition=[=($0, $1)], joinType=[inner], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, retry-strategy=fixed_delay, max-attempts=10, output-mode=allow_unordered, fixed-delay=155 ms, retry-predicate=lookup_miss, table=src, timeout=300 s, capacity=1000}]]]), rowType=[RecordType(BIGINT a, BIGINT a0, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
    :- LogicalProject(a=[$0], hints=[[[ALIAS options:[t1]]]]), rowType=[RecordType(BIGINT a)]
-   :  +- LogicalJoin(condition=[=($0, $1)], joinType=[inner], hints=[[[ALIAS inheritPath:[0] options:[t1]]]]), rowType=[RecordType(BIGINT a, BIGINT a0)]
-   :     :- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
-   :     +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
-   :        +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
-   +- LogicalTableScan(table=[[builtin, default, src]], hints=[[[ALIAS inheritPath:[] options:[t2]]]]), rowType=[RecordType(BIGINT a)]
+   :  +- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 1}], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, output-mode=allow_unordered, table=d, timeout=300 s, capacity=1000}]]], hints=[[[ALIAS inheritPath:[0] options:[t1]]]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts, BIGINT a0)]
+   :     :- LogicalProject(a=[$0], ds=[$1], pts=[PROCTIME()]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
+   :     :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
+   :     +- LogicalFilter(condition=[=($cor0.a, $0)]), rowType=[RecordType(BIGINT a)]
+   :        +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
+   :           +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
+   +- LogicalProject(a=[$0], ds=[$1], pts=[PROCTIME()], hints=[[[ALIAS options:[t2]]]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds, TIMESTAMP_LTZ(3) *PROCTIME* pts)]
+      +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
 ]]>
     </Resource>
   </TestCase>
-  <TestCase name="testClearLookupHintWithInvalidPropagationToViewWhileViewHasLookupHints">
+  <TestCase name="testNoNeedToClearLookupHintWhileJoinWithUnnest">
     <Resource name="beforePropagatingHints">
       <![CDATA[
 LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
-+- LogicalJoin(condition=[=($0, $1)], joinType=[inner]), rowType=[RecordType(BIGINT a, BIGINT a0)]
-   :- LogicalProject(a=[$0], hints=[[[ALIAS options:[t1]]]]), rowType=[RecordType(BIGINT a)]
-   :  +- LogicalJoin(condition=[=($0, $1)], joinType=[inner]), rowType=[RecordType(BIGINT a, BIGINT a0)]
-   :     :- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
-   :     +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
-   :        +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
-   +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
-      +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{}]), rowType=[RecordType(BIGINT a, BIGINT a0)]
+   :- LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
+   :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
+   +- Uncollect, rowType=[RecordType(BIGINT a)]
+      +- LogicalProject($f0=[$cor0.ds]), rowType=[RecordType(BIGINT ARRAY $f0)]
+         +- LogicalValues(tuples=[[{ 0 }]]), rowType=[RecordType(INTEGER ZERO)]
 ]]>
     </Resource>
     <Resource name="afterPropagatingHints">
       <![CDATA[
 LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
-+- LogicalJoin(condition=[=($0, $1)], joinType=[inner], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, output-mode=allow_unordered, table=lookup, timeout=300 s, capacity=1000}]]]), rowType=[RecordType(BIGINT a, BIGINT a0)]
-   :- LogicalProject(a=[$0], hints=[[[ALIAS options:[t1]]]]), rowType=[RecordType(BIGINT a)]
-   :  +- LogicalJoin(condition=[=($0, $1)], joinType=[inner], joinHints=[[[LOOKUP inheritPath:[0] options:{retry-strategy=fixed_delay, max-attempts=10, fixed-delay=155 ms, retry-predicate=lookup_miss, table=lookup}][LOOKUP inheritPath:[0, 0, 0] options:{async=true, output-mode=allow_unordered, table=lookup, timeout=300 s, capacity=1000}]]], hints=[[[ALIAS inheritPath:[0] options:[t1]]]]), rowType=[RecordType(BIGINT a, BIGINT a0)]
-   :     :- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
-   :     +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
-   :        +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
-   +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
-      +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{}], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, output-mode=allow_unordered, table=d, timeout=300 s, capacity=1000}]]]), rowType=[RecordType(BIGINT a, BIGINT a0)]
+   :- LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
+   :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
+   +- Uncollect, rowType=[RecordType(BIGINT a)]
+      +- LogicalProject($f0=[$cor0.ds]), rowType=[RecordType(BIGINT ARRAY $f0)]
+         +- LogicalValues(tuples=[[{ 0 }]]), rowType=[RecordType(INTEGER ZERO)]
 ]]>
     </Resource>
     <Resource name="afterClearingJoinHints">
       <![CDATA[
 LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
-+- LogicalJoin(condition=[=($0, $1)], joinType=[inner], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, output-mode=allow_unordered, table=lookup, timeout=300 s, capacity=1000}]]]), rowType=[RecordType(BIGINT a, BIGINT a0)]
-   :- LogicalProject(a=[$0], hints=[[[ALIAS options:[t1]]]]), rowType=[RecordType(BIGINT a)]
-   :  +- LogicalJoin(condition=[=($0, $1)], joinType=[inner], joinHints=[[[LOOKUP inheritPath:[0] options:{retry-strategy=fixed_delay, max-attempts=10, fixed-delay=155 ms, retry-predicate=lookup_miss, table=lookup}]]], hints=[[[ALIAS inheritPath:[0] options:[t1]]]]), rowType=[RecordType(BIGINT a, BIGINT a0)]
-   :     :- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
-   :     +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
-   :        +- LogicalTableScan(table=[[builtin, default, lookup]]), rowType=[RecordType(BIGINT a)]
-   +- LogicalSnapshot(period=[PROCTIME()]), rowType=[RecordType(BIGINT a)]
-      +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a)]
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{}], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, output-mode=allow_unordered, table=d, timeout=300 s, capacity=1000}]]]), rowType=[RecordType(BIGINT a, BIGINT a0)]
+   :- LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
+   :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
+   +- Uncollect, rowType=[RecordType(BIGINT a)]
+      +- LogicalProject($f0=[$cor0.ds]), rowType=[RecordType(BIGINT ARRAY $f0)]
+         +- LogicalValues(tuples=[[{ 0 }]]), rowType=[RecordType(INTEGER ZERO)]
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testNoNeedToClearLookupHintWhileJoinWithUDTF">
+    <Resource name="beforePropagatingHints">
+      <![CDATA[
+LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{}]), rowType=[RecordType(BIGINT a, BIGINT b)]
+   :- LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
+   :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
+   +- LogicalTableFunctionScan(invocation=[TABLE($cor0.b)], rowType=[RecordType(BIGINT b)]), rowType=[RecordType(BIGINT b)]
+]]>
+    </Resource>
+    <Resource name="afterPropagatingHints">
+      <![CDATA[
+LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{}], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, output-mode=allow_unordered, table=d, timeout=300 s, capacity=1000}]]]), rowType=[RecordType(BIGINT a, BIGINT b)]
+   :- LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
+   :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
+   +- LogicalTableFunctionScan(invocation=[TABLE($cor0.b)], rowType=[RecordType(BIGINT b)]), rowType=[RecordType(BIGINT b)]
+]]>
+    </Resource>
+    <Resource name="afterClearingJoinHints">
+      <![CDATA[
+LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{}], joinHints=[[[LOOKUP inheritPath:[0] options:{async=true, output-mode=allow_unordered, table=d, timeout=300 s, capacity=1000}]]]), rowType=[RecordType(BIGINT a, BIGINT b)]
+   :- LogicalProject(a=[$0]), rowType=[RecordType(BIGINT a)]
+   :  +- LogicalTableScan(table=[[builtin, default, src]]), rowType=[RecordType(BIGINT a, BIGINT ARRAY ds)]
+   +- LogicalTableFunctionScan(invocation=[TABLE($cor0.b)], rowType=[RecordType(BIGINT b)]), rowType=[RecordType(BIGINT b)]
 ]]>
     </Resource>
   </TestCase>
diff --git a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/UnnestTest.xml b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/UnnestTest.xml
index f266ab21419..7a2d7e866c9 100644
--- a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/UnnestTest.xml
+++ b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/UnnestTest.xml
@@ -36,42 +36,6 @@ LogicalProject(a=[$0], s=[$3])
 Calc(select=[a, f0 AS s])
 +- Correlate(invocation=[$UNNEST_ROWS$1($cor0.c)], correlate=[table($UNNEST_ROWS$1($cor0.c))], select=[a,b,c,f0], rowType=[RecordType(INTEGER a, BIGINT b, VARCHAR(2147483647) ARRAY c, VARCHAR(2147483647) f0)], joinType=[INNER])
    +- LegacyTableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c)]]], fields=[a, b, c])
-]]>
-    </Resource>
-  </TestCase>
-  <TestCase name="testTumbleWindowAggregateWithCollectUnnest">
-    <Resource name="sql">
-      <![CDATA[
-WITH T AS (SELECT b, COLLECT(b) as `set`
-    FROM MyTable
-    GROUP BY b, TUMBLE(rowtime, INTERVAL '3' SECOND)
-)
-SELECT b, s FROM T, UNNEST(T.`set`) AS A(s) where b < 3
-      ]]>
-    </Resource>
-    <Resource name="ast">
-      <![CDATA[
-LogicalProject(b=[$0], s=[$2])
-+- LogicalFilter(condition=[<($0, 3)])
-   +- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{1}])
-      :- LogicalProject(b=[$0], set=[$2])
-      :  +- LogicalAggregate(group=[{0, 1}], set=[COLLECT($0)])
-      :     +- LogicalProject(b=[$1], $f1=[$TUMBLE($3, 3000:INTERVAL SECOND)])
-      :        +- LogicalTableScan(table=[[default_catalog, default_database, MyTable]])
-      +- LogicalProject(s=[$0])
-         +- Uncollect
-            +- LogicalProject(set=[$cor0.set])
-               +- LogicalValues(tuples=[[{ 0 }]])
-]]>
-    </Resource>
-    <Resource name="optimized exec plan">
-      <![CDATA[
-Calc(select=[b, f0 AS s])
-+- Correlate(invocation=[$UNNEST_ROWS$1($cor0.set)], correlate=[table($UNNEST_ROWS$1($cor0.set))], select=[b,set,f0], rowType=[RecordType(BIGINT b, BIGINT MULTISET set, BIGINT f0)], joinType=[INNER])
-   +- GroupWindowAggregate(groupBy=[b], window=[TumblingGroupWindow('w$, rowtime, 3000)], select=[b, COLLECT(b) AS set])
-      +- Exchange(distribution=[hash[b]])
-         +- Calc(select=[b, rowtime], where=[(b < 3)])
-            +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, rowtime])
 ]]>
     </Resource>
   </TestCase>
@@ -159,6 +123,69 @@ Calc(select=[a, f0 AS s])
       +- Exchange(distribution=[hash[a]])
          +- Calc(select=[a, b], where=[(a < 5)])
             +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testUnnestWithInvalidLookupJoinHint">
+    <Resource name="sql">
+      <![CDATA[
+SELECT /*+ LOOKUP('table'='D', 'retry-predicate'='lookup_miss','retry-strategy'='fixed_delay', 
+         'fixed-delay'='155 ms', 'max-attempts'='10') */ T2.a
+FROM T2 CROSS JOIN UNNEST(T2.b) AS D(c)
+]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(a=[$0])
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{1}], joinHints=[[[LOOKUP inheritPath:[0] options:{retry-strategy=fixed_delay, max-attempts=10, fixed-delay=155 ms, retry-predicate=lookup_miss, table=D}]]])
+   :- LogicalTableScan(table=[[default_catalog, default_database, T2, source: [TestTableSource(a, b)]]], hints=[[[ALIAS inheritPath:[] options:[T2]]]])
+   +- LogicalProject(c=[$0])
+      +- Uncollect
+         +- LogicalProject(b=[$cor0.b])
+            +- LogicalValues(tuples=[[{ 0 }]])
+]]>
+    </Resource>
+    <Resource name="optimized exec plan">
+      <![CDATA[
+Calc(select=[a])
++- Correlate(invocation=[$UNNEST_ROWS$1($cor0.b)], correlate=[table($UNNEST_ROWS$1($cor0.b))], select=[a,b,f0], rowType=[RecordType(INTEGER a, INTEGER ARRAY b, INTEGER f0)], joinType=[INNER])
+   +- LegacyTableSourceScan(table=[[default_catalog, default_database, T2, source: [TestTableSource(a, b)]]], fields=[a, b])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testTumbleWindowAggregateWithCollectUnnest">
+    <Resource name="sql">
+      <![CDATA[
+WITH T AS (SELECT b, COLLECT(b) as `set`
+    FROM MyTable
+    GROUP BY b, TUMBLE(rowtime, INTERVAL '3' SECOND)
+)
+SELECT b, s FROM T, UNNEST(T.`set`) AS A(s) where b < 3
+      ]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(b=[$0], s=[$2])
++- LogicalFilter(condition=[<($0, 3)])
+   +- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{1}])
+      :- LogicalProject(b=[$0], set=[$2])
+      :  +- LogicalAggregate(group=[{0, 1}], set=[COLLECT($0)])
+      :     +- LogicalProject(b=[$1], $f1=[$TUMBLE($3, 3000:INTERVAL SECOND)])
+      :        +- LogicalTableScan(table=[[default_catalog, default_database, MyTable]])
+      +- LogicalProject(s=[$0])
+         +- Uncollect
+            +- LogicalProject(set=[$cor0.set])
+               +- LogicalValues(tuples=[[{ 0 }]])
+]]>
+    </Resource>
+    <Resource name="optimized exec plan">
+      <![CDATA[
+Calc(select=[b, f0 AS s])
++- Correlate(invocation=[$UNNEST_ROWS$1($cor0.set)], correlate=[table($UNNEST_ROWS$1($cor0.set))], select=[b,set,f0], rowType=[RecordType(BIGINT b, BIGINT MULTISET set, BIGINT f0)], joinType=[INNER])
+   +- GroupWindowAggregate(groupBy=[b], window=[TumblingGroupWindow('w$, rowtime, 3000)], select=[b, COLLECT(b) AS set])
+      +- Exchange(distribution=[hash[b]])
+         +- Calc(select=[b, rowtime], where=[(b < 3)])
+            +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, rowtime])
 ]]>
     </Resource>
   </TestCase>
@@ -214,6 +241,28 @@ Calc(select=[b, _1 AS id, _2 AS point])
       +- Exchange(distribution=[hash[b]])
          +- Calc(select=[b, c], where=[(b < 3)])
             +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testUnnestObjectArrayWithoutAlias">
+    <Resource name="sql">
+      <![CDATA[SELECT a, b, A._1, A._2 FROM MyTable, UNNEST(MyTable.b) AS A where A._1 > 1]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], _1=[$2], _2=[$3])
++- LogicalFilter(condition=[>($2, 1)])
+   +- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{1}])
+      :- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b)]]])
+      +- Uncollect
+         +- LogicalProject(b=[$cor0.b])
+            +- LogicalValues(tuples=[[{ 0 }]])
+]]>
+    </Resource>
+    <Resource name="optimized exec plan">
+      <![CDATA[
+Correlate(invocation=[$UNNEST_ROWS$1($cor0.b)], correlate=[table($UNNEST_ROWS$1($cor0.b))], select=[a,b,_1,_2], rowType=[RecordType(INTEGER a, RecordType:peek_no_expand(INTEGER _1, VARCHAR(2147483647) _2) ARRAY b, INTEGER _1, VARCHAR(2147483647) _2)], joinType=[INNER], condition=[>($0, 1)])
++- LegacyTableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b)]]], fields=[a, b])
 ]]>
     </Resource>
   </TestCase>
@@ -260,28 +309,6 @@ LogicalProject(a=[$0], b=[$1], s=[$2], t=[$3])
       <![CDATA[
 Correlate(invocation=[$UNNEST_ROWS$1($cor0.b)], correlate=[table($UNNEST_ROWS$1($cor0.b))], select=[a,b,_1,_2], rowType=[RecordType(INTEGER a, RecordType:peek_no_expand(INTEGER _1, VARCHAR(2147483647) _2) ARRAY b, INTEGER _1, VARCHAR(2147483647) _2)], joinType=[INNER], condition=[>($0, 13)])
 +- LegacyTableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b)]]], fields=[a, b])
-]]>
-    </Resource>
-  </TestCase>
-  <TestCase name="testUnnestObjectArrayWithoutAlias">
-    <Resource name="sql">
-      <![CDATA[SELECT a, b, A._1, A._2 FROM MyTable, UNNEST(MyTable.b) AS A where A._1 > 1]]>
-    </Resource>
-    <Resource name="ast">
-      <![CDATA[
-LogicalProject(a=[$0], b=[$1], _1=[$2], _2=[$3])
-+- LogicalFilter(condition=[>($2, 1)])
-   +- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{1}])
-      :- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b)]]])
-      +- Uncollect
-         +- LogicalProject(b=[$cor0.b])
-            +- LogicalValues(tuples=[[{ 0 }]])
-]]>
-    </Resource>
-    <Resource name="optimized exec plan">
-      <![CDATA[
-Correlate(invocation=[$UNNEST_ROWS$1($cor0.b)], correlate=[table($UNNEST_ROWS$1($cor0.b))], select=[a,b,_1,_2], rowType=[RecordType(INTEGER a, RecordType:peek_no_expand(INTEGER _1, VARCHAR(2147483647) _2) ARRAY b, INTEGER _1, VARCHAR(2147483647) _2)], joinType=[INNER], condition=[>($0, 1)])
-+- LegacyTableSourceScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b)]]], fields=[a, b])
 ]]>
     </Resource>
   </TestCase>
diff --git a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.xml b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.xml
index 90ab534634e..1ca9c2545c2 100644
--- a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.xml
+++ b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.xml
@@ -619,6 +619,86 @@ LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], rowtime=[$4], id=[$5], nam
 Calc(select=[a, b, c, PROCTIME_MATERIALIZE(proctime) AS proctime, rowtime, id, name, age])
 +- LookupJoin(table=[default_catalog.default_database.AsyncLookupTable], joinType=[InnerJoin], lookup=[id=a], select=[a, b, c, proctime, rowtime, id, name, age], async=[ORDERED, 180000ms, 100])
    +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testJoinHintWithNoPropagatingToSubQuery[LegacyTableSource=false]">
+    <Resource name="sql">
+      <![CDATA[
+SELECT /*+ LOOKUP('table'='D', 'output-mode'='ordered','capacity'='200') */ T1.a
+FROM (
+   SELECT /*+ LOOKUP('table'='D', 'output-mode'='allow_unordered', 'capacity'='1000') */
+     T.a a, T.proctime
+   FROM MyTable AS T JOIN AsyncLookupTable FOR SYSTEM_TIME AS OF T.proctime AS D
+     ON T.a = D.id
+) T1
+JOIN AsyncLookupTable FOR SYSTEM_TIME AS OF T1.proctime AS D
+ON T1.a=D.id
+]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(a=[$0])
++- LogicalCorrelate(correlation=[$cor1], joinType=[inner], requiredColumns=[{0, 1}], joinHints=[[[LOOKUP inheritPath:[0] options:{output-mode=ordered, table=D, capacity=200}]]])
+   :- LogicalProject(a=[$0], proctime=[$3])
+   :  +- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 3}], joinHints=[[[LOOKUP inheritPath:[0] options:{output-mode=allow_unordered, table=D, capacity=1000}]]])
+   :     :- LogicalTableScan(table=[[default_catalog, default_database, MyTable]], hints=[[[ALIAS inheritPath:[] options:[T]]]])
+   :     +- LogicalFilter(condition=[=($cor0.a, $0)])
+   :        +- LogicalSnapshot(period=[$cor0.proctime])
+   :           +- LogicalTableScan(table=[[default_catalog, default_database, AsyncLookupTable]])
+   +- LogicalFilter(condition=[=($cor1.a, $0)])
+      +- LogicalSnapshot(period=[$cor1.proctime])
+         +- LogicalTableScan(table=[[default_catalog, default_database, AsyncLookupTable]])
+]]>
+    </Resource>
+    <Resource name="optimized exec plan">
+      <![CDATA[
+Calc(select=[a])
++- LookupJoin(table=[default_catalog.default_database.AsyncLookupTable], joinType=[InnerJoin], lookup=[id=a], select=[a, id], async=[ORDERED, 180000ms, 200])
+   +- Calc(select=[a])
+      +- LookupJoin(table=[default_catalog.default_database.AsyncLookupTable], joinType=[InnerJoin], lookup=[id=a], select=[a, id], async=[UNORDERED, 180000ms, 1000])
+         +- Calc(select=[a])
+            +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testJoinHintWithNoPropagatingToSubQuery[LegacyTableSource=true]">
+    <Resource name="sql">
+      <![CDATA[
+SELECT /*+ LOOKUP('table'='D', 'output-mode'='ordered','capacity'='200') */ T1.a
+FROM (
+   SELECT /*+ LOOKUP('table'='D', 'output-mode'='allow_unordered', 'capacity'='1000') */
+     T.a a, T.proctime
+   FROM MyTable AS T JOIN AsyncLookupTable FOR SYSTEM_TIME AS OF T.proctime AS D
+     ON T.a = D.id
+) T1
+JOIN AsyncLookupTable FOR SYSTEM_TIME AS OF T1.proctime AS D
+ON T1.a=D.id
+]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(a=[$0])
++- LogicalCorrelate(correlation=[$cor1], joinType=[inner], requiredColumns=[{0, 1}], joinHints=[[[LOOKUP inheritPath:[0] options:{output-mode=ordered, table=D, capacity=200}]]])
+   :- LogicalProject(a=[$0], proctime=[$3])
+   :  +- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 3}], joinHints=[[[LOOKUP inheritPath:[0] options:{output-mode=allow_unordered, table=D, capacity=1000}]]])
+   :     :- LogicalTableScan(table=[[default_catalog, default_database, MyTable]], hints=[[[ALIAS inheritPath:[] options:[T]]]])
+   :     +- LogicalFilter(condition=[=($cor0.a, $0)])
+   :        +- LogicalSnapshot(period=[$cor0.proctime])
+   :           +- LogicalTableScan(table=[[default_catalog, default_database, AsyncLookupTable, source: [TestTemporalTable(id, name, age)]]])
+   +- LogicalFilter(condition=[=($cor1.a, $0)])
+      +- LogicalSnapshot(period=[$cor1.proctime])
+         +- LogicalTableScan(table=[[default_catalog, default_database, AsyncLookupTable, source: [TestTemporalTable(id, name, age)]]])
+]]>
+    </Resource>
+    <Resource name="optimized exec plan">
+      <![CDATA[
+Calc(select=[a])
++- LookupJoin(table=[default_catalog.default_database.AsyncLookupTable], joinType=[InnerJoin], lookup=[id=a], select=[a, id], async=[ORDERED, 180000ms, 200])
+   +- Calc(select=[a])
+      +- LookupJoin(table=[default_catalog.default_database.AsyncLookupTable], joinType=[InnerJoin], lookup=[id=a], select=[a, id], async=[UNORDERED, 180000ms, 1000])
+         +- Calc(select=[a])
+            +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
 ]]>
     </Resource>
   </TestCase>
@@ -1830,6 +1910,70 @@ Sink(table=[default_catalog.default_database.Sink1], fields=[a, name, age])
 }]]>
     </Resource>
   </TestCase>
+  <TestCase name="testJoinWithMixedCaseJoinHint[LegacyTableSource=false]">
+    <Resource name="sql">
+      <![CDATA[
+SELECT /*+ LookuP('table'='D', 'retry-predicate'='lookup_miss',
+'retry-strategy'='fixed_delay', 'fixed-delay'='155 ms', 'max-attempts'='10',
+'async'='true', 'output-mode'='allow_unordered','capacity'='1000', 'time-out'='300 s')
+*/
+T.a
+FROM MyTable AS T
+JOIN LookupTable FOR SYSTEM_TIME AS OF T.proctime AS D
+ON T.a = D.id
+]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(a=[$0])
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 3}], joinHints=[[[LOOKUP inheritPath:[0] options:{retry-strategy=fixed_delay, async=true, time-out=300 s, max-attempts=10, output-mode=allow_unordered, fixed-delay=155 ms, retry-predicate=lookup_miss, table=D, capacity=1000}]]])
+   :- LogicalTableScan(table=[[default_catalog, default_database, MyTable]], hints=[[[ALIAS inheritPath:[] options:[T]]]])
+   +- LogicalFilter(condition=[=($cor0.a, $0)])
+      +- LogicalSnapshot(period=[$cor0.proctime])
+         +- LogicalTableScan(table=[[default_catalog, default_database, LookupTable]])
+]]>
+    </Resource>
+    <Resource name="optimized exec plan">
+      <![CDATA[
+Calc(select=[a])
++- LookupJoin(table=[default_catalog.default_database.LookupTable], joinType=[InnerJoin], lookup=[id=a], select=[a, id], retry=[lookup_miss, FIXED_DELAY, 155ms, 10])
+   +- Calc(select=[a])
+      +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testJoinWithMixedCaseJoinHint[LegacyTableSource=true]">
+    <Resource name="sql">
+      <![CDATA[
+SELECT /*+ LookuP('table'='D', 'retry-predicate'='lookup_miss',
+'retry-strategy'='fixed_delay', 'fixed-delay'='155 ms', 'max-attempts'='10',
+'async'='true', 'output-mode'='allow_unordered','capacity'='1000', 'time-out'='300 s')
+*/
+T.a
+FROM MyTable AS T
+JOIN LookupTable FOR SYSTEM_TIME AS OF T.proctime AS D
+ON T.a = D.id
+]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(a=[$0])
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 3}], joinHints=[[[LOOKUP inheritPath:[0] options:{retry-strategy=fixed_delay, async=true, time-out=300 s, max-attempts=10, output-mode=allow_unordered, fixed-delay=155 ms, retry-predicate=lookup_miss, table=D, capacity=1000}]]])
+   :- LogicalTableScan(table=[[default_catalog, default_database, MyTable]], hints=[[[ALIAS inheritPath:[] options:[T]]]])
+   +- LogicalFilter(condition=[=($cor0.a, $0)])
+      +- LogicalSnapshot(period=[$cor0.proctime])
+         +- LogicalTableScan(table=[[default_catalog, default_database, LookupTable, source: [TestTemporalTable(id, name, age)]]])
+]]>
+    </Resource>
+    <Resource name="optimized exec plan">
+      <![CDATA[
+Calc(select=[a])
++- LookupJoin(table=[default_catalog.default_database.LookupTable], joinType=[InnerJoin], lookup=[id=a], select=[a, id], retry=[lookup_miss, FIXED_DELAY, 155ms, 10])
+   +- Calc(select=[a])
+      +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
+]]>
+    </Resource>
+  </TestCase>
   <TestCase name="testJoinWithRetryHint[LegacyTableSource=false]">
     <Resource name="explain">
       <![CDATA[== Abstract Syntax Tree ==
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/common/UnnestTestBase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/common/UnnestTestBase.scala
index c7d76a4c8da..c119dca0884 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/common/UnnestTestBase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/common/UnnestTestBase.scala
@@ -138,7 +138,7 @@ abstract class UnnestTestBase(withExecPlan: Boolean) extends TableTestBase {
     verifyPlan(sqlQuery)
   }
 
-  private def verifyPlan(sql: String): Unit = {
+  def verifyPlan(sql: String): Unit = {
     if (withExecPlan) {
       util.verifyExecPlan(sql)
     } else {
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/UnnestTest.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/UnnestTest.scala
index cb4b28e007a..fd1e4ff3d21 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/UnnestTest.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/UnnestTest.scala
@@ -17,10 +17,25 @@
  */
 package org.apache.flink.table.planner.plan.stream.sql
 
+import org.apache.flink.api.scala._
+import org.apache.flink.table.api._
 import org.apache.flink.table.planner.plan.common.UnnestTestBase
 import org.apache.flink.table.planner.utils.TableTestUtil
 
+import org.junit.Test
+
 class UnnestTest extends UnnestTestBase(true) {
 
   override def getTableTestUtil: TableTestUtil = streamTestUtil()
+
+  @Test
+  def testUnnestWithInvalidLookupJoinHint(): Unit = {
+    util.addTableSource[(Int, Array[Int])]("T2", 'a, 'b)
+    verifyPlan(
+      """
+        |SELECT /*+ LOOKUP('table'='D', 'retry-predicate'='lookup_miss','retry-strategy'='fixed_delay', 
+        |         'fixed-delay'='155 ms', 'max-attempts'='10') */ T2.a
+        |FROM T2 CROSS JOIN UNNEST(T2.b) AS D(c)
+        |""".stripMargin)
+  }
 }
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/JoinTest.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/JoinTest.scala
index fd275f22911..37e6dc4372a 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/JoinTest.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/JoinTest.scala
@@ -19,7 +19,7 @@ package org.apache.flink.table.planner.plan.stream.sql.join
 
 import org.apache.flink.api.scala._
 import org.apache.flink.table.api._
-import org.apache.flink.table.planner.utils.{StreamTableTestUtil, TableTestBase}
+import org.apache.flink.table.planner.utils.{StreamTableTestUtil, TableFunc1, TableTestBase}
 
 import org.junit.Test
 
@@ -571,4 +571,14 @@ class JoinTest extends TableTestBase {
                           |""".stripMargin)
   }
 
+  @Test
+  def testJoinUDTFWithInvalidJoinHint(): Unit = {
+    // TODO the error message should be improved after we support extracting alias from table func
+    util.addTemporarySystemFunction("TableFunc1", new TableFunc1)
+    util.verifyExpectdException(
+      "SELECT /*+ LOOKUP('table'='D') */ T.a FROM t AS T CROSS JOIN LATERAL TABLE(TableFunc1(c)) AS D(c1)",
+      "The options of following hints cannot match the name of input tables or views: \n" +
+        "`D` in `LOOKUP`"
+    )
+  }
 }
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.scala
index ac72487ad98..7043dbae109 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.scala
@@ -951,6 +951,39 @@ class LookupJoinTest(legacyTableSource: Boolean) extends TableTestBase with Seri
     util.verifyExplain(stmt, ExplainDetail.JSON_EXECUTION_PLAN)
   }
 
+  @Test
+  def testJoinWithMixedCaseJoinHint(): Unit = {
+    util.verifyExecPlan(
+      """
+        |SELECT /*+ LookuP('table'='D', 'retry-predicate'='lookup_miss',
+        |'retry-strategy'='fixed_delay', 'fixed-delay'='155 ms', 'max-attempts'='10',
+        |'async'='true', 'output-mode'='allow_unordered','capacity'='1000', 'time-out'='300 s')
+        |*/
+        |T.a
+        |FROM MyTable AS T
+        |JOIN LookupTable FOR SYSTEM_TIME AS OF T.proctime AS D
+        |ON T.a = D.id
+        |""".stripMargin
+    )
+  }
+
+  @Test
+  def testJoinHintWithNoPropagatingToSubQuery(): Unit = {
+    util.verifyExecPlan(
+      """
+        |SELECT /*+ LOOKUP('table'='D', 'output-mode'='ordered','capacity'='200') */ T1.a
+        |FROM (
+        |   SELECT /*+ LOOKUP('table'='D', 'output-mode'='allow_unordered', 'capacity'='1000') */
+        |     T.a a, T.proctime
+        |   FROM MyTable AS T JOIN AsyncLookupTable FOR SYSTEM_TIME AS OF T.proctime AS D
+        |     ON T.a = D.id
+        |) T1
+        |JOIN AsyncLookupTable FOR SYSTEM_TIME AS OF T1.proctime AS D
+        |ON T1.a=D.id
+        |""".stripMargin
+    )
+  }
+
   // ==========================================================================================
 
   private def createLookupTable(tableName: String, lookupFunction: UserDefinedFunction): Unit = {
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/utils/lookupFunctions.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/utils/lookupFunctions.scala
index 3a48d3b0166..faff96a156f 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/utils/lookupFunctions.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/utils/lookupFunctions.scala
@@ -18,6 +18,7 @@
 package org.apache.flink.table.planner.plan.utils
 
 import org.apache.flink.streaming.api.functions.async.ResultFuture
+import org.apache.flink.table.annotation.{DataTypeHint, FunctionHint}
 import org.apache.flink.table.data.{RowData, StringData}
 import org.apache.flink.table.functions.{AsyncTableFunction, TableFunction}
 import org.apache.flink.types.Row
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/utils/TableTestBase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/utils/TableTestBase.scala
index bca3fd2c37c..0615b66b671 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/utils/TableTestBase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/utils/TableTestBase.scala
@@ -21,6 +21,7 @@ import org.apache.flink.api.common.typeinfo.{AtomicType, TypeInformation}
 import org.apache.flink.api.java.typeutils.{PojoTypeInfo, RowTypeInfo, TupleTypeInfo}
 import org.apache.flink.api.scala.typeutils.CaseClassTypeInfo
 import org.apache.flink.configuration.BatchExecutionOptions
+import org.apache.flink.core.testutils.FlinkMatchers.containsMessage
 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode
 import org.apache.flink.streaming.api.{environment, TimeCharacteristic}
 import org.apache.flink.streaming.api.datastream.DataStream
@@ -76,7 +77,7 @@ import org.apache.calcite.avatica.util.TimeUnit
 import org.apache.calcite.rel.RelNode
 import org.apache.calcite.sql.{SqlExplainLevel, SqlIntervalQualifier}
 import org.apache.calcite.sql.parser.SqlParserPos
-import org.junit.Assert.{assertEquals, assertTrue, fail}
+import org.junit.Assert.{assertEquals, assertThat, assertTrue, fail}
 import org.junit.Rule
 import org.junit.rules.{ExpectedException, TemporaryFolder, TestName}
 
@@ -744,6 +745,21 @@ abstract class TableTestUtilBase(test: TableTestBase, isStreamingMode: Boolean)
     doVerifyExplain(table.explain(extraDetails: _*), extraDetails: _*)
   }
 
+  /** Verify the expected exception for the given sql with the given message and exception class. */
+  def verifyExpectdException(
+      sql: String,
+      message: String,
+      clazz: Class[_ <: Throwable] = classOf[ValidationException]): Unit = {
+    try {
+      verifyExplain(sql)
+      fail(s"Expected a $clazz, but no exception is thrown.")
+    } catch {
+      case e: Throwable =>
+        assertTrue(clazz.isAssignableFrom(e.getClass))
+        assertThat(e, containsMessage(message))
+    }
+  }
+
   /**
    * Verify the explain result for the given [[Table]] with the given sink table name. See more
    * about [[StatementSet#explain()]].
