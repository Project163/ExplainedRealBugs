diff --git a/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/runtime/utils/FailingCollectionSource.java b/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/runtime/utils/FailingCollectionSource.java
index df3a5689f86..1f4a0681853 100644
--- a/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/runtime/utils/FailingCollectionSource.java
+++ b/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/runtime/utils/FailingCollectionSource.java
@@ -167,9 +167,9 @@ public class FailingCollectionSource<T>
 			if (!failedBefore) {
 				// delay a bit, if we have not failed before
 				Thread.sleep(1);
-				if (numSuccessfulCheckpoints >= 1 && lastCheckpointedEmittedNum >= failureAfterNumElements) {
-					// cause a failure if we have not failed before and have reached
-					// enough completed checkpoints and elements
+				if (numSuccessfulCheckpoints >= 1 && lastCheckpointedEmittedNum >= 1) {
+					// cause a failure if we have not failed before and have a completed checkpoint
+					// and have processed at least one element
 					failedBefore = true;
 					throw new Exception("Artificial Failure");
 				}
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/rank/AppendOnlyTopNFunction.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/rank/AppendOnlyTopNFunction.java
index c86ad035969..6a3cf5acd81 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/rank/AppendOnlyTopNFunction.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/rank/AppendOnlyTopNFunction.java
@@ -113,7 +113,10 @@ public class AppendOnlyTopNFunction extends AbstractTopNFunction {
 			buffer.put(sortKey, inputRowSer.copy(input));
 			Collection<RowData> inputs = buffer.get(sortKey);
 			// update data state
-			dataState.put(sortKey, (List<RowData>) inputs);
+			// copy a new collection to avoid mutating state values, see CopyOnWriteStateMap,
+			// otherwise, the result might be corrupt.
+			// don't need to perform a deep copy, because RowData elements will not be updated
+			dataState.put(sortKey, new ArrayList<>(inputs));
 			if (outputRankNumber || hasOffset()) {
 				// the without-number-algorithm can't handle topN with offset,
 				// so use the with-number-algorithm to handle offset
