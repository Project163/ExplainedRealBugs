diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java
index 768b3f9e6ec..c0998ec9dab 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java
@@ -39,14 +39,12 @@ import static org.apache.flink.util.Preconditions.checkState;
 @NotThreadSafe
 final class ChannelStatePersister {
 	protected final InputChannelInfo channelInfo;
-	private static final long CHECKPOINT_COMPLETED = -1;
 
-	private static final long BARRIER_RECEIVED = -2;
+	private enum CheckpointStatus {COMPLETED, BARRIER_PENDING, BARRIER_RECEIVED}
 
-	/**
-	 * All started checkpoints where a barrier has not been received yet.
-	 */
-	private long pendingCheckpointBarrierId = CHECKPOINT_COMPLETED;
+	private CheckpointStatus checkpointStatus = CheckpointStatus.COMPLETED;
+
+	private long lastSeenBarrier = -1L;
 
 	/**
 	 * Writer must be initialized before usage. {@link #startPersisting(long, List)} enforces this invariant.
@@ -62,8 +60,9 @@ final class ChannelStatePersister {
 	protected void startPersisting(long barrierId, List<Buffer> knownBuffers) {
 		checkState(isInitialized(), "Channel state writer not injected");
 
-		if (pendingCheckpointBarrierId != BARRIER_RECEIVED) {
-			pendingCheckpointBarrierId = barrierId;
+		if (checkpointStatus != CheckpointStatus.BARRIER_RECEIVED && lastSeenBarrier < barrierId) {
+			checkpointStatus = CheckpointStatus.BARRIER_PENDING;
+			lastSeenBarrier = barrierId;
 		}
 		if (knownBuffers.size() > 0) {
 			channelStateWriter.addInputData(
@@ -78,14 +77,17 @@ final class ChannelStatePersister {
 		return channelStateWriter != null;
 	}
 
-	protected void stopPersisting() {
-		pendingCheckpointBarrierId = CHECKPOINT_COMPLETED;
+	protected void stopPersisting(long id) {
+		if (id >= lastSeenBarrier) {
+			checkpointStatus = CheckpointStatus.COMPLETED;
+			lastSeenBarrier = id;
+		}
 	}
 
 	protected void maybePersist(Buffer buffer) {
-		if (pendingCheckpointBarrierId >= 0 && buffer.isBuffer()) {
+		if (checkpointStatus == CheckpointStatus.BARRIER_PENDING && buffer.isBuffer()) {
 			channelStateWriter.addInputData(
-				pendingCheckpointBarrierId,
+				lastSeenBarrier,
 				channelInfo,
 				ChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,
 				CloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));
@@ -95,8 +97,11 @@ final class ChannelStatePersister {
 	protected boolean checkForBarrier(Buffer buffer) throws IOException {
 		final AbstractEvent priorityEvent = parsePriorityEvent(buffer);
 		if (priorityEvent instanceof CheckpointBarrier) {
-			pendingCheckpointBarrierId = BARRIER_RECEIVED;
-			return true;
+			if (((CheckpointBarrier) priorityEvent).getId() >= lastSeenBarrier) {
+				checkpointStatus = CheckpointStatus.BARRIER_RECEIVED;
+				lastSeenBarrier = ((CheckpointBarrier) priorityEvent).getId();
+				return true;
+			}
 		}
 		return false;
 	}
@@ -119,6 +124,6 @@ final class ChannelStatePersister {
 	}
 
 	protected boolean hasBarrierReceived() {
-		return pendingCheckpointBarrierId == BARRIER_RECEIVED;
+		return checkpointStatus == CheckpointStatus.BARRIER_RECEIVED;
 	}
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java
index 5ef393e7142..cc652bafd82 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java
@@ -116,7 +116,7 @@ public class LocalInputChannel extends InputChannel implements BufferAvailabilit
 	}
 
 	public void checkpointStopped(long checkpointId) {
-		channelStatePersister.stopPersisting();
+		channelStatePersister.stopPersisting(checkpointId);
 	}
 
 	@Override
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java
index dd184910645..614af48d439 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java
@@ -512,7 +512,7 @@ public class RemoteInputChannel extends InputChannel implements ChannelStateHold
 
 	public void checkpointStopped(long checkpointId) {
 		synchronized (receivedBuffers) {
-			channelStatePersister.stopPersisting();
+			channelStatePersister.stopPersisting(checkpointId);
 			numBuffersOvertaken = ALL;
 		}
 	}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersisterTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersisterTest.java
new file mode 100644
index 00000000000..1a2144a69c9
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersisterTest.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.io.network.partition.consumer;
+
+import org.apache.flink.runtime.checkpoint.CheckpointOptions;
+import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;
+import org.apache.flink.runtime.checkpoint.channel.InputChannelInfo;
+import org.apache.flink.runtime.io.network.api.CheckpointBarrier;
+import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;
+import org.apache.flink.runtime.io.network.buffer.Buffer;
+
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.Collections;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * {@link ChannelStatePersister} test.
+ */
+public class ChannelStatePersisterTest {
+
+	@Test
+	public void testNewBarrierNotOverwrittenByStopPersisting() throws IOException {
+		ChannelStatePersister persister = new ChannelStatePersister(ChannelStateWriter.NO_OP, new InputChannelInfo(0, 0));
+
+		persister.checkForBarrier(barrier(1L));
+		persister.startPersisting(1L, Collections.emptyList());
+
+		// meanwhile, checkpoint coordinator timed out the 1st checkpoint and started the 2nd
+		// now task thread is picking up the barrier and aborts the 1st:
+		persister.checkForBarrier(barrier(2L));
+		persister.stopPersisting(1L);
+
+		assertTrue(persister.hasBarrierReceived());
+	}
+
+	@Test
+	public void testNewBarrierNotOverwrittenByCheckForBarrier() throws IOException {
+		ChannelStatePersister persister = new ChannelStatePersister(ChannelStateWriter.NO_OP, new InputChannelInfo(0, 0));
+
+		persister.startPersisting(1L, Collections.emptyList());
+		persister.startPersisting(2L, Collections.emptyList());
+
+		assertFalse(persister.checkForBarrier(barrier(1L)));
+
+		assertFalse(persister.hasBarrierReceived());
+	}
+
+	private static Buffer barrier(long id) throws IOException {
+		return EventSerializer.toBuffer(
+			new CheckpointBarrier(id, 1L, CheckpointOptions.forCheckpointWithDefaultLocation()),
+			true
+		);
+	}
+}
