diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/watermarkstatus/StatusWatermarkValve.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/watermarkstatus/StatusWatermarkValve.java
index 96cf0968af2..867bb51db9f 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/watermarkstatus/StatusWatermarkValve.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/watermarkstatus/StatusWatermarkValve.java
@@ -26,6 +26,7 @@ import org.apache.flink.streaming.runtime.watermarkstatus.HeapPriorityQueue.Heap
 import org.apache.flink.util.Preconditions;
 
 import static org.apache.flink.util.Preconditions.checkArgument;
+import static org.apache.flink.util.Preconditions.checkState;
 
 /**
  * A {@code StatusWatermarkValve} embodies the logic of how {@link Watermark} and {@link
@@ -207,8 +208,10 @@ public class StatusWatermarkValve {
      * @param inputChannelStatus the input channel status to be marked
      */
     private void markWatermarkAligned(InputChannelStatus inputChannelStatus) {
-        inputChannelStatus.isWatermarkAligned = true;
-        inputChannelStatus.addTo(alignedChannelStatuses);
+        if (!inputChannelStatus.isWatermarkAligned) {
+            inputChannelStatus.isWatermarkAligned = true;
+            inputChannelStatus.addTo(alignedChannelStatuses);
+        }
     }
 
     /**
@@ -218,8 +221,10 @@ public class StatusWatermarkValve {
      * @param inputChannelStatus the input channel status to be marked
      */
     private void markWatermarkUnaligned(InputChannelStatus inputChannelStatus) {
-        inputChannelStatus.isWatermarkAligned = false;
-        inputChannelStatus.removeFrom(alignedChannelStatuses);
+        if (inputChannelStatus.isWatermarkAligned) {
+            inputChannelStatus.isWatermarkAligned = false;
+            inputChannelStatus.removeFrom(alignedChannelStatuses);
+        }
     }
 
     /**
@@ -297,15 +302,14 @@ public class StatusWatermarkValve {
         }
 
         private void removeFrom(HeapPriorityQueue<InputChannelStatus> queue) {
+            checkState(heapIndex != HeapPriorityQueueElement.NOT_CONTAINED);
             queue.remove(this);
             setInternalIndex(HeapPriorityQueueElement.NOT_CONTAINED);
         }
 
         private void addTo(HeapPriorityQueue<InputChannelStatus> queue) {
-            // Check the heap index to avoid the same object being added repeatedly
-            if (heapIndex == HeapPriorityQueueElement.NOT_CONTAINED) {
-                queue.add(this);
-            }
+            checkState(heapIndex == HeapPriorityQueueElement.NOT_CONTAINED);
+            queue.add(this);
         }
     }
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/watermarkstatus/StatusWatermarkValveTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/watermarkstatus/StatusWatermarkValveTest.java
index 9ea87093eea..0db7b04e6c4 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/watermarkstatus/StatusWatermarkValveTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/watermarkstatus/StatusWatermarkValveTest.java
@@ -405,6 +405,30 @@ class StatusWatermarkValveTest {
         assertThat(valveOutput.popLastSeenOutput()).isNull();
     }
 
+    @Test
+    void testUnalignedActiveChannelBecomesIdle() throws Exception {
+        StatusWatermarkOutput valveOutput = new StatusWatermarkOutput();
+        StatusWatermarkValve valve = new StatusWatermarkValve(2);
+
+        valve.inputWatermark(new Watermark(7), 0, valveOutput);
+        valve.inputWatermark(new Watermark(10), 1, valveOutput);
+        assertThat(valveOutput.popLastSeenOutput()).isEqualTo(new Watermark(7));
+
+        // make channel 0 idle, it becomes unaligned
+        valve.inputWatermarkStatus(WatermarkStatus.IDLE, 0, valveOutput);
+        assertThat(valveOutput.popLastSeenOutput()).isEqualTo(new Watermark(10));
+
+        // make channel 0 active, but it is still unaligned because it's watermark < last output
+        // watermark
+        valve.inputWatermarkStatus(WatermarkStatus.ACTIVE, 0, valveOutput);
+        valve.inputWatermark(new Watermark(9), 0, valveOutput);
+        assertThat(valveOutput.popLastSeenOutput()).isNull();
+
+        // make channel 0 idle again
+        valve.inputWatermarkStatus(WatermarkStatus.IDLE, 0, valveOutput);
+        assertThat(valveOutput.popLastSeenOutput()).isNull();
+    }
+
     private static class StatusWatermarkOutput implements PushingAsyncDataInput.DataOutput {
 
         private BlockingQueue<StreamElement> allOutputs = new LinkedBlockingQueue<>();
