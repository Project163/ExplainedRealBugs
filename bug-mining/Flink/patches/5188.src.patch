diff --git a/flink-core/src/main/java/org/apache/flink/api/connector/source/SplitEnumeratorContext.java b/flink-core/src/main/java/org/apache/flink/api/connector/source/SplitEnumeratorContext.java
index bef166674ee..66b3ef4c28e 100644
--- a/flink-core/src/main/java/org/apache/flink/api/connector/source/SplitEnumeratorContext.java
+++ b/flink-core/src/main/java/org/apache/flink/api/connector/source/SplitEnumeratorContext.java
@@ -110,7 +110,7 @@ public interface SplitEnumeratorContext<SplitT extends SourceSplit> {
     /**
      * Invoke the given callable periodically and handover the return value to the handler which
      * will be executed by the source coordinator. When this method is invoked multiple times, The
-     * <code>Coallble</code>s may be executed in a thread pool concurrently.
+     * <code>Callable</code>s may be executed in a thread pool concurrently.
      *
      * <p>It is important to make sure that the callable does not modify any shared state,
      * especially the states that will be a part of the {@link SplitEnumerator#snapshotState()}.
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java b/flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java
index a2628075ccb..6c0dcd9b4fe 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java
@@ -19,6 +19,7 @@ limitations under the License.
 package org.apache.flink.runtime.source.coordinator;
 
 import org.apache.flink.annotation.Internal;
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.connector.source.ReaderInfo;
 import org.apache.flink.api.connector.source.SourceEvent;
 import org.apache.flink.api.connector.source.SourceSplit;
@@ -54,6 +55,7 @@ import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.function.BiConsumer;
 
@@ -94,6 +96,7 @@ public class SourceCoordinatorContext<SplitT extends SourceSplit>
     private final SourceCoordinatorProvider.CoordinatorExecutorThreadFactory
             coordinatorThreadFactory;
     private final String coordinatorThreadName;
+    private volatile boolean closed;
 
     public SourceCoordinatorContext(
             ExecutorService coordinatorExecutor,
@@ -103,18 +106,22 @@ public class SourceCoordinatorContext<SplitT extends SourceSplit>
             SimpleVersionedSerializer<SplitT> splitSerializer) {
         this(
                 coordinatorExecutor,
+                Executors.newScheduledThreadPool(
+                        numWorkerThreads,
+                        new ExecutorThreadFactory(
+                                coordinatorThreadFactory.getCoordinatorThreadName() + "-worker")),
                 coordinatorThreadFactory,
-                numWorkerThreads,
                 operatorCoordinatorContext,
                 splitSerializer,
                 new SplitAssignmentTracker<>());
     }
 
     // Package private method for unit test.
+    @VisibleForTesting
     SourceCoordinatorContext(
             ExecutorService coordinatorExecutor,
+            ScheduledExecutorService workerExecutor,
             SourceCoordinatorProvider.CoordinatorExecutorThreadFactory coordinatorThreadFactory,
-            int numWorkerThreads,
             OperatorCoordinator.Context operatorCoordinatorContext,
             SimpleVersionedSerializer<SplitT> splitSerializer,
             SplitAssignmentTracker<SplitT> splitAssignmentTracker) {
@@ -132,12 +139,7 @@ public class SourceCoordinatorContext<SplitT extends SourceSplit>
                                 new ThrowableCatchingRunnable(
                                         this::handleUncaughtExceptionFromAsyncCall, runnable));
 
-        this.notifier =
-                new ExecutorNotifier(
-                        Executors.newScheduledThreadPool(
-                                numWorkerThreads,
-                                new ExecutorThreadFactory(coordinatorThreadName + "-worker")),
-                        errorHandlingCoordinatorExecutor);
+        this.notifier = new ExecutorNotifier(workerExecutor, errorHandlingCoordinatorExecutor);
     }
 
     @Override
@@ -250,6 +252,7 @@ public class SourceCoordinatorContext<SplitT extends SourceSplit>
 
     @Override
     public void close() throws InterruptedException {
+        closed = true;
         notifier.close();
         coordinatorExecutor.shutdown();
         coordinatorExecutor.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
@@ -267,6 +270,10 @@ public class SourceCoordinatorContext<SplitT extends SourceSplit>
     }
 
     void handleUncaughtExceptionFromAsyncCall(Throwable t) {
+        if (closed) {
+            return;
+        }
+
         ExceptionUtils.rethrowIfFatalErrorOrOOM(t);
         LOG.error(
                 "Exception while handling result from async call in {}. Triggering job failover.",
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContextTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContextTest.java
index 389a6b94164..d610e423b15 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContextTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContextTest.java
@@ -23,8 +23,10 @@ import org.apache.flink.api.connector.source.SplitsAssignment;
 import org.apache.flink.api.connector.source.mocks.MockSourceSplit;
 import org.apache.flink.api.connector.source.mocks.MockSourceSplitSerializer;
 import org.apache.flink.core.memory.DataOutputViewStreamWrapper;
+import org.apache.flink.core.testutils.ManuallyTriggeredScheduledExecutorService;
 import org.apache.flink.runtime.operators.coordination.OperatorEvent;
 import org.apache.flink.runtime.source.event.AddSplitEvent;
+import org.apache.flink.runtime.util.ExecutorThreadFactory;
 
 import org.junit.Test;
 
@@ -34,11 +36,14 @@ import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
 
 import static org.apache.flink.runtime.source.coordinator.CoordinatorTestUtils.getSplitsAssignment;
 import static org.apache.flink.runtime.source.coordinator.CoordinatorTestUtils.verifyAssignment;
 import static org.apache.flink.runtime.source.coordinator.CoordinatorTestUtils.verifyException;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
@@ -165,8 +170,12 @@ public class SourceCoordinatorContextTest extends SourceCoordinatorTestBase {
             restoredContext =
                     new SourceCoordinatorContext<>(
                             coordinatorExecutor,
+                            Executors.newScheduledThreadPool(
+                                    1,
+                                    new ExecutorThreadFactory(
+                                            coordinatorThreadFactory.getCoordinatorThreadName()
+                                                    + "-worker")),
                             coordinatorThreadFactory,
-                            1,
                             operatorCoordinatorContext,
                             new MockSourceSplitSerializer(),
                             restoredTracker);
@@ -182,6 +191,44 @@ public class SourceCoordinatorContextTest extends SourceCoordinatorTestBase {
                 restoredTracker.assignmentsByCheckpointId());
     }
 
+    @Test
+    public void testCallableInterruptedDuringShutdownDoNotFailJob() throws InterruptedException {
+        AtomicReference<Throwable> expectedError = new AtomicReference<>(null);
+
+        ManuallyTriggeredScheduledExecutorService manualWorkerExecutor =
+                new ManuallyTriggeredScheduledExecutorService();
+        ManuallyTriggeredScheduledExecutorService manualCoordinatorExecutor =
+                new ManuallyTriggeredScheduledExecutorService();
+
+        SourceCoordinatorContext<MockSourceSplit> testingContext =
+                new SourceCoordinatorContext<>(
+                        manualCoordinatorExecutor,
+                        manualWorkerExecutor,
+                        new SourceCoordinatorProvider.CoordinatorExecutorThreadFactory(
+                                TEST_OPERATOR_ID.toHexString(), getClass().getClassLoader()),
+                        operatorCoordinatorContext,
+                        new MockSourceSplitSerializer(),
+                        splitSplitAssignmentTracker);
+
+        testingContext.callAsync(
+                () -> {
+                    throw new InterruptedException();
+                },
+                (ignored, e) -> {
+                    if (e != null) {
+                        expectedError.set(e);
+                        throw new RuntimeException(e);
+                    }
+                });
+
+        manualWorkerExecutor.triggerAll();
+        testingContext.close();
+        manualCoordinatorExecutor.triggerAll();
+
+        assertTrue(expectedError.get() instanceof InterruptedException);
+        assertFalse(operatorCoordinatorContext.isJobFailed());
+    }
+
     // ------------------------
 
     private List<ReaderInfo> registerReaders() {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorTestBase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorTestBase.java
index 818c19d09d7..0a471be025f 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorTestBase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorTestBase.java
@@ -26,6 +26,7 @@ import org.apache.flink.api.connector.source.mocks.MockSourceSplitSerializer;
 import org.apache.flink.api.connector.source.mocks.MockSplitEnumerator;
 import org.apache.flink.runtime.jobgraph.OperatorID;
 import org.apache.flink.runtime.operators.coordination.MockOperatorCoordinatorContext;
+import org.apache.flink.runtime.util.ExecutorThreadFactory;
 
 import org.junit.After;
 import org.junit.Before;
@@ -65,8 +66,12 @@ public abstract class SourceCoordinatorTestBase {
         context =
                 new SourceCoordinatorContext<>(
                         coordinatorExecutor,
+                        Executors.newScheduledThreadPool(
+                                1,
+                                new ExecutorThreadFactory(
+                                        coordinatorThreadFactory.getCoordinatorThreadName()
+                                                + "-worker")),
                         coordinatorThreadFactory,
-                        1,
                         operatorCoordinatorContext,
                         new MockSourceSplitSerializer(),
                         splitSplitAssignmentTracker);
