diff --git a/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java b/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java
index 2ab034e023f..e8a449897f8 100644
--- a/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java
+++ b/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.util.concurrent;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.common.time.Deadline;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.FatalExitExceptionHandler;
@@ -1176,12 +1177,34 @@ public class FutureUtils {
     public static void handleUncaughtException(
             CompletableFuture<?> completableFuture,
             Thread.UncaughtExceptionHandler uncaughtExceptionHandler) {
+        handleUncaughtException(
+                completableFuture, uncaughtExceptionHandler, FatalExitExceptionHandler.INSTANCE);
+    }
+
+    @VisibleForTesting
+    static void handleUncaughtException(
+            CompletableFuture<?> completableFuture,
+            Thread.UncaughtExceptionHandler uncaughtExceptionHandler,
+            Thread.UncaughtExceptionHandler fatalErrorHandler) {
         checkNotNull(completableFuture)
                 .whenComplete(
                         (ignored, throwable) -> {
                             if (throwable != null) {
-                                uncaughtExceptionHandler.uncaughtException(
-                                        Thread.currentThread(), throwable);
+                                final Thread currentThread = Thread.currentThread();
+                                try {
+                                    uncaughtExceptionHandler.uncaughtException(
+                                            currentThread, throwable);
+                                } catch (Throwable t) {
+                                    final RuntimeException errorHandlerException =
+                                            new IllegalStateException(
+                                                    "An error occurred while executing the error handling for a "
+                                                            + throwable.getClass().getSimpleName()
+                                                            + ".",
+                                                    t);
+                                    errorHandlerException.addSuppressed(throwable);
+                                    fatalErrorHandler.uncaughtException(
+                                            currentThread, errorHandlerException);
+                                }
                             }
                         });
     }
diff --git a/flink-core/src/test/java/org/apache/flink/util/concurrent/FutureUtilsTest.java b/flink-core/src/test/java/org/apache/flink/util/concurrent/FutureUtilsTest.java
index df96ef3b482..46be06f9f93 100644
--- a/flink-core/src/test/java/org/apache/flink/util/concurrent/FutureUtilsTest.java
+++ b/flink-core/src/test/java/org/apache/flink/util/concurrent/FutureUtilsTest.java
@@ -768,6 +768,47 @@ class FutureUtilsTest {
         assertThat(uncaughtExceptionHandler.hasBeenCalled()).isTrue();
     }
 
+    /**
+     * Tests the behavior of {@link FutureUtils#handleUncaughtException(CompletableFuture,
+     * Thread.UncaughtExceptionHandler)} with a custom fallback exception handler to avoid
+     * triggering {@code System.exit}.
+     */
+    @Test
+    void testHandleUncaughtExceptionWithBuggyErrorHandlingCode() {
+        final Exception actualProductionCodeError =
+                new Exception(
+                        "Actual production code error that should be caught by the error handler.");
+
+        final RuntimeException errorHandlingException =
+                new RuntimeException("Expected test error in error handling code.");
+        final Thread.UncaughtExceptionHandler buggyActualExceptionHandler =
+                (thread, ignoredActualException) -> {
+                    throw errorHandlingException;
+                };
+
+        final AtomicReference<Throwable> caughtErrorHandlingException = new AtomicReference<>();
+        final Thread.UncaughtExceptionHandler fallbackExceptionHandler =
+                (thread, errorHandlingEx) -> caughtErrorHandlingException.set(errorHandlingEx);
+
+        FutureUtils.handleUncaughtException(
+                FutureUtils.completedExceptionally(actualProductionCodeError),
+                buggyActualExceptionHandler,
+                fallbackExceptionHandler);
+
+        assertThat(caughtErrorHandlingException)
+                .hasValueSatisfying(
+                        actualError -> {
+                            assertThat(actualError)
+                                    .isInstanceOf(IllegalStateException.class)
+                                    .hasRootCause(errorHandlingException)
+                                    .satisfies(
+                                            cause ->
+                                                    assertThat(cause.getSuppressed())
+                                                            .containsExactly(
+                                                                    actualProductionCodeError));
+                        });
+    }
+
     private static class TestingUncaughtExceptionHandler
             implements Thread.UncaughtExceptionHandler {
 
