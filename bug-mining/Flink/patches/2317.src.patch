diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SingleLogicalSlot.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SingleLogicalSlot.java
index 9bd559bc166..0736b5684ab 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SingleLogicalSlot.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SingleLogicalSlot.java
@@ -19,13 +19,13 @@
 package org.apache.flink.runtime.jobmaster.slotpool;
 
 import org.apache.flink.runtime.clusterframework.types.AllocationID;
+import org.apache.flink.runtime.instance.SlotSharingGroupId;
+import org.apache.flink.runtime.jobmanager.scheduler.Locality;
+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;
 import org.apache.flink.runtime.jobmaster.LogicalSlot;
 import org.apache.flink.runtime.jobmaster.SlotContext;
 import org.apache.flink.runtime.jobmaster.SlotOwner;
 import org.apache.flink.runtime.jobmaster.SlotRequestId;
-import org.apache.flink.runtime.instance.SlotSharingGroupId;
-import org.apache.flink.runtime.jobmanager.scheduler.Locality;
-import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;
 import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
 import org.apache.flink.util.Preconditions;
 
@@ -33,7 +33,6 @@ import javax.annotation.Nullable;
 
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import java.util.function.Function;
 
 /**
  * Implementation of the {@link LogicalSlot} which is used by the {@link SlotPool}.
@@ -127,8 +126,7 @@ public class SingleLogicalSlot implements LogicalSlot, AllocatedSlot.Payload {
 
 		// Wait until the payload has been terminated. Only then, we return the slot to its rightful owner
 		return payload.getTerminalStateFuture()
-			.handle((Object ignored, Throwable throwable) -> slotOwner.returnAllocatedSlot(this))
-			.thenApply(Function.identity());
+			.whenComplete((Object ignored, Throwable throwable) -> slotOwner.returnAllocatedSlot(this));
 	}
 
 	@Override
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java
index 3e8b7882395..6040b418336 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java
@@ -1041,6 +1041,7 @@ public class SlotPool extends RpcEndpoint implements SlotPoolGateway, AllocatedS
 	 */
 	@Override
 	public CompletableFuture<Acknowledge> registerTaskManager(final ResourceID resourceID) {
+		log.debug("Register new TaskExecutor {}.", resourceID);
 		registeredTaskManagers.add(resourceID);
 
 		return CompletableFuture.completedFuture(Acknowledge.get());
@@ -1119,8 +1120,15 @@ public class SlotPool extends RpcEndpoint implements SlotPoolGateway, AllocatedS
 				freeSlotFuture.whenCompleteAsync(
 					(Acknowledge ignored, Throwable throwable) -> {
 						if (throwable != null) {
-							log.info("Releasing idle slot {} failed.", allocationID, throwable);
-							tryFulfillSlotRequestOrMakeAvailable(expiredSlot);
+							if (registeredTaskManagers.contains(expiredSlot.getTaskManagerId())) {
+								log.debug("Releasing slot {} of registered TaskExecutor {} failed. " +
+									"Trying to fulfill a different slot request.", allocationID, expiredSlot.getTaskManagerId(),
+									throwable);
+								tryFulfillSlotRequestOrMakeAvailable(expiredSlot);
+							} else {
+								log.debug("Releasing slot {} failed and owning TaskExecutor {} is no " +
+									"longer registered. Discarding slot.", allocationID, expiredSlot.getTaskManagerId());
+							}
 						}
 					},
 					getMainThreadExecutor());
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/utils/SimpleAckingTaskManagerGateway.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/utils/SimpleAckingTaskManagerGateway.java
index 628f0041371..5c62a737096 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/utils/SimpleAckingTaskManagerGateway.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/utils/SimpleAckingTaskManagerGateway.java
@@ -20,7 +20,6 @@ package org.apache.flink.runtime.executiongraph.utils;
 
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.time.Time;
-import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.blob.TransientBlobKey;
 import org.apache.flink.runtime.checkpoint.CheckpointOptions;
 import org.apache.flink.runtime.clusterframework.ApplicationStatus;
@@ -38,6 +37,7 @@ import org.apache.flink.runtime.messages.StackTraceSampleResponse;
 import java.util.Optional;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
+import java.util.function.BiFunction;
 import java.util.function.Consumer;
 
 /**
@@ -52,7 +52,7 @@ public class SimpleAckingTaskManagerGateway implements TaskManagerGateway {
 
 	private Optional<Consumer<ExecutionAttemptID>> optCancelConsumer;
 
-	private volatile Consumer<Tuple2<AllocationID, Throwable>> freeSlotConsumer;
+	private volatile BiFunction<AllocationID, Throwable, CompletableFuture<Acknowledge>> freeSlotFunction;
 
 	public SimpleAckingTaskManagerGateway() {
 		optSubmitConsumer = Optional.empty();
@@ -67,8 +67,8 @@ public class SimpleAckingTaskManagerGateway implements TaskManagerGateway {
 		optCancelConsumer = Optional.of(predicate);
 	}
 
-	public void setFreeSlotConsumer(Consumer<Tuple2<AllocationID, Throwable>> consumer) {
-		freeSlotConsumer = consumer;
+	public void setFreeSlotFunction(BiFunction<AllocationID, Throwable, CompletableFuture<Acknowledge>> freeSlotFunction) {
+		this.freeSlotFunction = freeSlotFunction;
 	}
 
 	@Override
@@ -150,12 +150,12 @@ public class SimpleAckingTaskManagerGateway implements TaskManagerGateway {
 
 	@Override
 	public CompletableFuture<Acknowledge> freeSlot(AllocationID allocationId, Throwable cause, Time timeout) {
-		final Consumer<Tuple2<AllocationID, Throwable>> currentFreeSlotConsumer = freeSlotConsumer;
+		final BiFunction<AllocationID, Throwable, CompletableFuture<Acknowledge>> currentFreeSlotFunction = freeSlotFunction;
 
-		if (currentFreeSlotConsumer != null) {
-			currentFreeSlotConsumer.accept(Tuple2.of(allocationId, cause));
+		if (currentFreeSlotFunction != null) {
+			return currentFreeSlotFunction.apply(allocationId, cause);
+		} else {
+			return CompletableFuture.completedFuture(Acknowledge.get());
 		}
-
-		return CompletableFuture.completedFuture(Acknowledge.get());
 	}
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolTest.java
index c3819747595..502b076e571 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolTest.java
@@ -23,6 +23,7 @@ import org.apache.flink.api.common.time.Time;
 import org.apache.flink.runtime.clusterframework.types.AllocationID;
 import org.apache.flink.runtime.clusterframework.types.ResourceProfile;
 import org.apache.flink.runtime.clusterframework.types.SlotProfile;
+import org.apache.flink.runtime.concurrent.FutureUtils;
 import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;
 import org.apache.flink.runtime.instance.SlotSharingGroupId;
 import org.apache.flink.runtime.jobgraph.JobVertexID;
@@ -38,6 +39,7 @@ import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGate
 import org.apache.flink.runtime.rpc.RpcService;
 import org.apache.flink.runtime.rpc.RpcUtils;
 import org.apache.flink.runtime.rpc.TestingRpcService;
+import org.apache.flink.runtime.taskexecutor.TaskExecutor;
 import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;
 import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;
 import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
@@ -58,6 +60,7 @@ import org.slf4j.LoggerFactory;
 
 import javax.annotation.Nullable;
 
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -67,6 +70,7 @@ import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 
 import static org.apache.flink.runtime.jobmaster.slotpool.AvailableSlotsTest.DEFAULT_TESTING_PROFILE;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -559,9 +563,15 @@ public class SlotPoolTest extends TestLogger {
 
 			final ArrayBlockingQueue<AllocationID> freedSlotQueue = new ArrayBlockingQueue<>(numSlotOffers);
 
-			taskManagerGateway.setFreeSlotConsumer(tuple -> {
-				while(!freedSlotQueue.offer(tuple.f0)) {}
-			});
+			taskManagerGateway.setFreeSlotFunction(
+				(AllocationID allocationID, Throwable cause) -> {
+					try {
+						freedSlotQueue.put(allocationID);
+						return CompletableFuture.completedFuture(Acknowledge.get());
+					} catch (InterruptedException e) {
+						return FutureUtils.completedExceptionally(e);
+					}
+				});
 
 			final CompletableFuture<Collection<SlotOffer>> acceptedSlotOffersFuture = slotPoolGateway.offerSlots(taskManagerLocation, taskManagerGateway, slotOffers);
 
@@ -598,7 +608,16 @@ public class SlotPoolTest extends TestLogger {
 
 		try {
 			final BlockingQueue<AllocationID> freedSlots = new ArrayBlockingQueue<>(1);
-			taskManagerGateway.setFreeSlotConsumer((tuple) -> freedSlots.offer(tuple.f0));
+			taskManagerGateway.setFreeSlotFunction(
+				(AllocationID allocationId, Throwable cause) ->
+				{
+					try {
+						freedSlots.put(allocationId);
+						return CompletableFuture.completedFuture(Acknowledge.get());
+					} catch (InterruptedException e) {
+						return FutureUtils.completedExceptionally(e);
+					}
+				});
 
 			final SlotPoolGateway slotPoolGateway = setupSlotPool(slotPool, resourceManagerGateway);
 
@@ -634,6 +653,99 @@ public class SlotPoolTest extends TestLogger {
 		}
 	}
 
+	/**
+	 * Tests that idle slots which cannot be released are only recycled if the owning {@link TaskExecutor}
+	 * is still registered at the {@link SlotPool}. See FLINK-9047.
+	 */
+	@Test
+	public void testReleasingIdleSlotFailed() throws Exception {
+		final ManualClock clock = new ManualClock();
+		final SlotPool slotPool = new SlotPool(
+			rpcService,
+			jobId,
+			clock,
+			TestingUtils.infiniteTime(),
+			timeout);
+
+		try {
+			final SlotPoolGateway slotPoolGateway = setupSlotPool(slotPool, resourceManagerGateway);
+
+			final AllocationID expiredAllocationId = new AllocationID();
+			final SlotOffer slotToExpire = new SlotOffer(expiredAllocationId, 0, ResourceProfile.UNKNOWN);
+
+			final ArrayDeque<CompletableFuture<Acknowledge>> responseQueue = new ArrayDeque<>(2);
+			taskManagerGateway.setFreeSlotFunction((AllocationID allocationId, Throwable cause) -> {
+				if (responseQueue.isEmpty()) {
+					return CompletableFuture.completedFuture(Acknowledge.get());
+				} else {
+					return responseQueue.pop();
+				}
+			});
+
+			responseQueue.add(FutureUtils.completedExceptionally(new FlinkException("Test failure")));
+
+			final CompletableFuture<Acknowledge> responseFuture = new CompletableFuture<>();
+			responseQueue.add(responseFuture);
+
+			assertThat(
+				slotPoolGateway.registerTaskManager(taskManagerLocation.getResourceID()).get(),
+				Matchers.is(Acknowledge.get()));
+
+			assertThat(
+				slotPoolGateway.offerSlot(taskManagerLocation, taskManagerGateway, slotToExpire).get(),
+				Matchers.is(true));
+
+			clock.advanceTime(timeout.toMilliseconds(), TimeUnit.MILLISECONDS);
+
+			slotPool.triggerCheckIdleSlot();
+
+			CompletableFuture<LogicalSlot> allocatedSlotFuture = slotPoolGateway.allocateSlot(
+				new SlotRequestId(),
+				new DummyScheduledUnit(),
+				SlotProfile.noRequirements(),
+				true,
+				timeout);
+
+			// wait until the slot has been fulfilled with the previously idling slot
+			final LogicalSlot logicalSlot = allocatedSlotFuture.get();
+			assertThat(logicalSlot.getAllocationId(), Matchers.is(expiredAllocationId));
+
+			// return the slot
+			slotPool.getSlotOwner().returnAllocatedSlot(logicalSlot).get();
+
+			// advance the time so that the returned slot is now idling
+			clock.advanceTime(timeout.toMilliseconds(), TimeUnit.MILLISECONDS);
+
+			slotPool.triggerCheckIdleSlot();
+
+			// request a new slot after the idling slot has been released
+			allocatedSlotFuture = slotPoolGateway.allocateSlot(
+				new SlotRequestId(),
+				new DummyScheduledUnit(),
+				SlotProfile.noRequirements(),
+				true,
+				timeout);
+
+			// release the TaskExecutor before we get a response from the slot releasing
+			slotPoolGateway.releaseTaskManager(taskManagerLocation.getResourceID()).get();
+
+			// let the slot releasing fail --> since the owning TaskExecutor is no longer registered
+			// the slot should be discarded
+			responseFuture.completeExceptionally(new FlinkException("Second test exception"));
+
+			try {
+				// since the slot must have been discarded, we cannot fulfill the slot request
+				allocatedSlotFuture.get(10L, TimeUnit.MILLISECONDS);
+				fail("Expected to fail with a timeout.");
+			} catch (TimeoutException ignored) {
+				// expected
+			}
+
+		} finally {
+			RpcUtils.terminateRpcEndpoint(slotPool, timeout);
+		}
+	}
+
 	private static SlotPoolGateway setupSlotPool(
 			SlotPool slotPool,
 			ResourceManagerGateway resourceManagerGateway) throws Exception {
