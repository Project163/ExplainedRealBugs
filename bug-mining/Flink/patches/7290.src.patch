diff --git a/flink-test-utils-parent/flink-test-utils-junit/src/main/java/org/apache/flink/testutils/junit/extensions/retry/RetryTestExecutionExtension.java b/flink-test-utils-parent/flink-test-utils-junit/src/main/java/org/apache/flink/testutils/junit/extensions/retry/RetryTestExecutionExtension.java
index 8126c74015a..74e56db5944 100644
--- a/flink-test-utils-parent/flink-test-utils-junit/src/main/java/org/apache/flink/testutils/junit/extensions/retry/RetryTestExecutionExtension.java
+++ b/flink-test-utils-parent/flink-test-utils-junit/src/main/java/org/apache/flink/testutils/junit/extensions/retry/RetryTestExecutionExtension.java
@@ -51,7 +51,7 @@ public class RetryTestExecutionExtension
         RetryStrategy retryStrategy = getRetryStrategyInStore(context);
         String method = getTestMethodKey(context);
         if (!retryStrategy.hasNextAttempt()) {
-            return ConditionEvaluationResult.disabled(method + "has already passed or failed.");
+            return ConditionEvaluationResult.disabled(method + " has already passed or failed.");
         }
         return ConditionEvaluationResult.enabled(
                 String.format("Test %s[%d/%d]", method, retryIndex, totalTimes));
diff --git a/flink-test-utils-parent/flink-test-utils-junit/src/test/java/org/apache/flink/testutils/junit/RetryOnExceptionExtensionTest.java b/flink-test-utils-parent/flink-test-utils-junit/src/test/java/org/apache/flink/testutils/junit/RetryOnExceptionExtensionTest.java
index d1186a489f5..3ff0d64bc40 100644
--- a/flink-test-utils-parent/flink-test-utils-junit/src/test/java/org/apache/flink/testutils/junit/RetryOnExceptionExtensionTest.java
+++ b/flink-test-utils-parent/flink-test-utils-junit/src/test/java/org/apache/flink/testutils/junit/RetryOnExceptionExtensionTest.java
@@ -22,12 +22,17 @@ import org.apache.flink.testutils.junit.extensions.retry.RetryExtension;
 import org.apache.flink.testutils.junit.extensions.retry.strategy.RetryOnExceptionStrategy;
 
 import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.TestInfo;
 import org.junit.jupiter.api.TestTemplate;
 import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
 import org.opentest4j.TestAbortedException;
 
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Consumer;
 import java.util.stream.Stream;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -37,53 +42,77 @@ import static org.assertj.core.api.Assertions.assertThatThrownBy;
 @ExtendWith(RetryExtension.class)
 class RetryOnExceptionExtensionTest {
 
-    private static final int NUMBER_OF_RUNS = 3;
+    private static final int NUMBER_OF_RETRIES = 3;
 
-    private static int runsForSuccessfulTest = 0;
+    private static final Map<String, Integer> methodRunCount = new HashMap<>();
 
-    private static int runsForTestWithMatchingException = 0;
+    private static final Map<String, Runnable> verificationCallbackRegistry = new HashMap<>();
 
-    private static int runsForTestWithSubclassException = 0;
+    @BeforeEach
+    void incrementMethodRunCount(TestInfo testInfo) {
+        // Set or increment the run count for the unit test method, by the method short name.
+        // This starts at 1 and is incremented before the test starts.
+        testInfo.getTestMethod()
+                .ifPresent(
+                        method ->
+                                methodRunCount.compute(
+                                        method.getName(), (k, v) -> (v == null) ? 1 : v + 1));
+    }
+
+    private static int assertAndReturnRunCount(TestInfo testInfo) {
+        return methodRunCount.get(assertAndReturnTestMethodName(testInfo));
+    }
 
-    private static int runsForPassAfterOneFailure = 0;
+    private static void registerCallbackForTest(TestInfo testInfo, Consumer<Integer> verification) {
+        verificationCallbackRegistry.putIfAbsent(
+                assertAndReturnTestMethodName(testInfo),
+                () -> verification.accept(assertAndReturnRunCount(testInfo)));
+    }
+
+    private static String assertAndReturnTestMethodName(TestInfo testInfo) {
+        return testInfo.getTestMethod()
+                .orElseThrow(() -> new AssertionError("No test method is provided."))
+                .getName();
+    }
 
     @AfterAll
     static void verify() {
-        assertThat(runsForTestWithMatchingException).isEqualTo(NUMBER_OF_RUNS + 1);
-        assertThat(runsForTestWithSubclassException).isEqualTo(NUMBER_OF_RUNS + 1);
-        assertThat(runsForSuccessfulTest).isOne();
-        assertThat(runsForPassAfterOneFailure).isEqualTo(2);
+        for (Runnable verificationCallback : verificationCallbackRegistry.values()) {
+            verificationCallback.run();
+        }
     }
 
     @TestTemplate
-    @RetryOnException(times = NUMBER_OF_RUNS, exception = IllegalArgumentException.class)
-    void testSuccessfulTest() {
-        runsForSuccessfulTest++;
+    @RetryOnException(times = NUMBER_OF_RETRIES, exception = IllegalArgumentException.class)
+    void testSuccessfulTest(TestInfo testInfo) {
+        registerCallbackForTest(testInfo, total -> assertThat(total).isOne());
     }
 
     @TestTemplate
-    @RetryOnException(times = NUMBER_OF_RUNS, exception = IllegalArgumentException.class)
-    void testMatchingException() {
-        runsForTestWithMatchingException++;
-        if (runsForTestWithMatchingException <= NUMBER_OF_RUNS) {
+    @RetryOnException(times = NUMBER_OF_RETRIES, exception = IllegalArgumentException.class)
+    void testMatchingException(TestInfo testInfo) {
+        registerCallbackForTest(
+                testInfo, total -> assertThat(total).isEqualTo(NUMBER_OF_RETRIES + 1));
+        if (assertAndReturnRunCount(testInfo) <= NUMBER_OF_RETRIES) {
             throw new IllegalArgumentException();
         }
     }
 
     @TestTemplate
-    @RetryOnException(times = NUMBER_OF_RUNS, exception = RuntimeException.class)
-    void testSubclassException() {
-        runsForTestWithSubclassException++;
-        if (runsForTestWithSubclassException <= NUMBER_OF_RUNS) {
+    @RetryOnException(times = NUMBER_OF_RETRIES, exception = RuntimeException.class)
+    void testSubclassException(TestInfo testInfo) {
+        registerCallbackForTest(
+                testInfo, total -> assertThat(total).isEqualTo(NUMBER_OF_RETRIES + 1));
+        if (assertAndReturnRunCount(testInfo) <= NUMBER_OF_RETRIES) {
             throw new IllegalArgumentException();
         }
     }
 
     @TestTemplate
-    @RetryOnException(times = NUMBER_OF_RUNS, exception = IllegalArgumentException.class)
-    void testPassAfterOneFailure() {
-        runsForPassAfterOneFailure++;
-        if (runsForPassAfterOneFailure == 1) {
+    @RetryOnException(times = NUMBER_OF_RETRIES, exception = IllegalArgumentException.class)
+    void testPassAfterOneFailure(TestInfo testInfo) {
+        registerCallbackForTest(testInfo, total -> assertThat(total).isEqualTo(2));
+        if (assertAndReturnRunCount(testInfo) == 1) {
             throw new IllegalArgumentException();
         }
     }
diff --git a/flink-test-utils-parent/flink-test-utils-junit/src/test/java/org/apache/flink/testutils/junit/RetryOnFailureExtensionTest.java b/flink-test-utils-parent/flink-test-utils-junit/src/test/java/org/apache/flink/testutils/junit/RetryOnFailureExtensionTest.java
index 703c035ca00..eb31d229285 100644
--- a/flink-test-utils-parent/flink-test-utils-junit/src/test/java/org/apache/flink/testutils/junit/RetryOnFailureExtensionTest.java
+++ b/flink-test-utils-parent/flink-test-utils-junit/src/test/java/org/apache/flink/testutils/junit/RetryOnFailureExtensionTest.java
@@ -21,56 +21,85 @@ package org.apache.flink.testutils.junit;
 import org.apache.flink.testutils.junit.extensions.retry.RetryExtension;
 
 import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.TestInfo;
 import org.junit.jupiter.api.TestTemplate;
 import org.junit.jupiter.api.extension.ExtendWith;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Consumer;
+
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for the {@link RetryOnFailure} annotation on JUnit5 {@link RetryExtension}. */
 @ExtendWith(RetryExtension.class)
 class RetryOnFailureExtensionTest {
 
-    private static final int NUMBER_OF_RUNS = 5;
+    private static final int NUMBER_OF_RETRIES = 5;
+
+    private static final Map<String, Integer> methodRunCount = new HashMap<>();
+
+    private static final Map<String, Runnable> verificationCallbackRegistry = new HashMap<>();
+
+    @BeforeEach
+    void incrementMethodRunCount(TestInfo testInfo) {
+        // Set or increment the run count for the unit test method, by the method short name.
+        // This starts at 1 and is incremented before the test starts.
+        testInfo.getTestMethod()
+                .ifPresent(
+                        method ->
+                                methodRunCount.compute(
+                                        method.getName(), (k, v) -> (v == null) ? 1 : v + 1));
+    }
 
-    private static int numberOfFailedRuns;
+    private static int assertAndReturnRunCount(TestInfo testInfo) {
+        return methodRunCount.get(assertAndReturnTestMethodName(testInfo));
+    }
 
-    private static int numberOfSuccessfulRuns;
+    private static void registerCallbackForTest(TestInfo testInfo, Consumer<Integer> verification) {
+        verificationCallbackRegistry.putIfAbsent(
+                assertAndReturnTestMethodName(testInfo),
+                () -> verification.accept(assertAndReturnRunCount(testInfo)));
+    }
 
-    private static boolean firstRun = true;
+    private static String assertAndReturnTestMethodName(TestInfo testInfo) {
+        return testInfo.getTestMethod()
+                .orElseThrow(() -> new AssertionError("No test method is provided."))
+                .getName();
+    }
 
     @AfterAll
     static void verify() {
-        assertEquals(NUMBER_OF_RUNS + 1, numberOfFailedRuns);
-        assertEquals(3, numberOfSuccessfulRuns);
+        for (Runnable verificationCallback : verificationCallbackRegistry.values()) {
+            verificationCallback.run();
+        }
     }
 
     @TestTemplate
-    @RetryOnFailure(times = NUMBER_OF_RUNS)
-    void testRetryOnFailure() {
+    @RetryOnFailure(times = NUMBER_OF_RETRIES)
+    void testRetryOnFailure(TestInfo testInfo) {
+        registerCallbackForTest(
+                testInfo, total -> assertThat(total).isEqualTo(NUMBER_OF_RETRIES + 1));
+
         // All but the (expected) last run should be successful
-        if (numberOfFailedRuns < NUMBER_OF_RUNS) {
-            numberOfFailedRuns++;
+        if (assertAndReturnRunCount(testInfo) <= NUMBER_OF_RETRIES) {
             throw new RuntimeException("Expected test exception");
-        } else {
-            numberOfSuccessfulRuns++;
         }
     }
 
     @TestTemplate
-    @RetryOnFailure(times = NUMBER_OF_RUNS)
-    void testRetryOnceOnFailure() {
-        if (firstRun) {
-            numberOfFailedRuns++;
-            firstRun = false;
+    @RetryOnFailure(times = NUMBER_OF_RETRIES)
+    void testRetryOnceOnFailure(TestInfo testInfo) {
+        registerCallbackForTest(testInfo, total -> assertThat(total).isEqualTo(2));
+        if (assertAndReturnRunCount(testInfo) == 1) {
             throw new RuntimeException("Expected test exception");
-        } else {
-            numberOfSuccessfulRuns++;
         }
     }
 
     @TestTemplate
-    @RetryOnFailure(times = NUMBER_OF_RUNS)
-    void testNotRetryOnSuccess() {
-        numberOfSuccessfulRuns++;
+    @RetryOnFailure(times = NUMBER_OF_RETRIES)
+    void testNotRetryOnSuccess(TestInfo testInfo) {
+        registerCallbackForTest(testInfo, total -> assertThat(total).isOne());
     }
 }
