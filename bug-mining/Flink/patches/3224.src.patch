diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/AsynchronousException.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/AsynchronousException.java
index 1af81d009fb..a187aadde6c 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/AsynchronousException.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/AsynchronousException.java
@@ -35,9 +35,4 @@ public class AsynchronousException extends Exception {
 	public AsynchronousException(String message, Throwable cause) {
 		super(message, cause);
 	}
-
-	@Override
-	public String toString() {
-		return "AsynchronousException{" + getCause() + "}";
-	}
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
index 105168f6aab..e1fb19bad0d 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
@@ -934,7 +934,7 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>
 	public void handleAsyncException(String message, Throwable exception) {
 		if (isRunning) {
 			// only fail if the task is still running
-			getEnvironment().failExternally(exception);
+			getEnvironment().failExternally(new AsynchronousException(message, exception));
 		}
 	}
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
index f28cf6e5025..df8e1d8b986 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
@@ -132,11 +132,7 @@ import org.mockito.stubbing.Answer;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.ObjectInputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
@@ -183,6 +179,50 @@ public class StreamTaskTest extends TestLogger {
 	@Rule
 	public final Timeout timeoutPerTest = Timeout.seconds(30);
 
+	/**
+	 * This test checks the async exceptions handling wraps the message and cause as an AsynchronousException
+	 * and propagates this to the environment.
+	 */
+	@Test
+	public void handleAsyncException() throws Throwable {
+		MockEnvironment e = MockEnvironment.builder().build();
+		RuntimeException expectedException = new RuntimeException("RUNTIME EXCEPTION");
+
+		BlockingCloseStreamOperator.resetLatches();
+		Configuration taskConfiguration = new Configuration();
+		StreamConfig streamConfig = new StreamConfig(taskConfiguration);
+		streamConfig.setStreamOperator(new BlockingCloseStreamOperator());
+		streamConfig.setOperatorID(new OperatorID());
+
+		try (MockEnvironment mockEnvironment =
+				 new MockEnvironmentBuilder()
+					 .setTaskName("Test Task")
+					 .setMemorySize(32L * 1024L)
+					 .setInputSplitProvider(new MockInputSplitProvider())
+					 .setBufferSize(1)
+					 .setTaskConfiguration(taskConfiguration)
+					 .build()) {
+
+			RunningTask<StreamTask<Void, BlockingCloseStreamOperator>> task = runTask(() -> new NoOpStreamTask<>(mockEnvironment));
+
+			BlockingCloseStreamOperator.inClose.await();
+
+			// check that the StreamTask is not yet in isRunning == false
+			assertTrue(task.streamTask.isRunning());
+
+
+			// generate an error report and expect it to be caught by the Environment
+			mockEnvironment.setExpectedExternalFailureCause(Throwable.class);
+			task.streamTask.handleAsyncException("EXPECTED_ERROR MESSAGE", expectedException);
+
+			// expect an AsynchronousException containing the supplied error details
+			Optional<Throwable> actualExternalFailureCause = mockEnvironment.getActualExternalFailureCause();
+			AsynchronousException cause = (AsynchronousException)actualExternalFailureCause.get();
+			assertEquals(cause.getMessage(), "EXPECTED_ERROR MESSAGE");
+			assertEquals(cause.getCause(), expectedException);
+		}
+	}
+
 	/**
 	 * This test checks that cancel calls that are issued before the operator is
 	 * instantiated still lead to proper canceling.
diff --git a/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/StreamTaskTimerITCase.java b/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/StreamTaskTimerITCase.java
index b87f486d0db..c6da16ccbfb 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/StreamTaskTimerITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/StreamTaskTimerITCase.java
@@ -33,6 +33,7 @@ import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
 import org.apache.flink.streaming.runtime.tasks.TimerException;
 import org.apache.flink.test.util.AbstractTestBase;
+import org.apache.flink.util.ExceptionUtils;
 
 import org.junit.Assert;
 import org.junit.Test;
@@ -41,8 +42,11 @@ import org.junit.runners.Parameterized;
 
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Optional;
 import java.util.concurrent.Semaphore;
 
+import static org.junit.Assert.assertTrue;
+
 /**
  * Tests for the timer service of {@code StreamTask}.
  *
@@ -73,27 +77,26 @@ public class StreamTaskTimerITCase extends AbstractTestBase {
 
 		source.transform("Custom Operator", BasicTypeInfo.STRING_TYPE_INFO, new TimerOperator(ChainingStrategy.ALWAYS));
 
-		boolean testSuccess = false;
 		try {
 			env.execute("Timer test");
 		} catch (JobExecutionException e) {
-			if (e.getCause() instanceof TimerException) {
-				TimerException te = (TimerException) e.getCause();
-				if (te.getCause() instanceof RuntimeException) {
-					RuntimeException re = (RuntimeException) te.getCause();
-					if (re.getMessage().equals("TEST SUCCESS")) {
-						testSuccess = true;
-					} else {
-						throw e;
-					}
-				} else {
-					throw e;
-				}
-			} else {
+			verifyJobExecutionException(e);
+		}
+	}
+
+	private void verifyJobExecutionException(JobExecutionException e) throws JobExecutionException {
+		final Optional<TimerException> optionalTimerException = ExceptionUtils.findThrowable(e, TimerException.class);
+		assertTrue(optionalTimerException.isPresent());
+
+		TimerException te = optionalTimerException.get();
+		if (te.getCause() instanceof RuntimeException) {
+			RuntimeException re = (RuntimeException) te.getCause();
+			if (!re.getMessage().equals("TEST SUCCESS")) {
 				throw e;
 			}
+		} else {
+			throw e;
 		}
-		Assert.assertTrue(testSuccess);
 	}
 
 	/**
@@ -110,27 +113,11 @@ public class StreamTaskTimerITCase extends AbstractTestBase {
 
 		source.transform("Custom Operator", BasicTypeInfo.STRING_TYPE_INFO, new TimerOperator(ChainingStrategy.NEVER));
 
-		boolean testSuccess = false;
 		try {
 			env.execute("Timer test");
 		} catch (JobExecutionException e) {
-			if (e.getCause() instanceof TimerException) {
-				TimerException te = (TimerException) e.getCause();
-				if (te.getCause() instanceof RuntimeException) {
-					RuntimeException re = (RuntimeException) te.getCause();
-					if (re.getMessage().equals("TEST SUCCESS")) {
-						testSuccess = true;
-					} else {
-						throw e;
-					}
-				} else {
-					throw e;
-				}
-			} else {
-				throw e;
-			}
+			verifyJobExecutionException(e);
 		}
-		Assert.assertTrue(testSuccess);
 	}
 
 	@Test
@@ -146,27 +133,11 @@ public class StreamTaskTimerITCase extends AbstractTestBase {
 				BasicTypeInfo.STRING_TYPE_INFO,
 				new TwoInputTimerOperator(ChainingStrategy.NEVER));
 
-		boolean testSuccess = false;
 		try {
 			env.execute("Timer test");
 		} catch (JobExecutionException e) {
-			if (e.getCause() instanceof TimerException) {
-				TimerException te = (TimerException) e.getCause();
-				if (te.getCause() instanceof RuntimeException) {
-					RuntimeException re = (RuntimeException) te.getCause();
-					if (re.getMessage().equals("TEST SUCCESS")) {
-						testSuccess = true;
-					} else {
-						throw e;
-					}
-				} else {
-					throw e;
-				}
-			} else {
-				throw e;
-			}
+			verifyJobExecutionException(e);
 		}
-		Assert.assertTrue(testSuccess);
 	}
 
 	private static class TimerOperator extends AbstractStreamOperator<String> implements OneInputStreamOperator<String, String>, ProcessingTimeCallback {
