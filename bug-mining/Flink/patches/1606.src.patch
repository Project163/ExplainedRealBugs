diff --git a/flink-connectors/flink-jdbc/src/main/java/org/apache/flink/api/java/io/jdbc/split/NumericBetweenParametersProvider.java b/flink-connectors/flink-jdbc/src/main/java/org/apache/flink/api/java/io/jdbc/split/NumericBetweenParametersProvider.java
index ac56b98c483..44201723a44 100644
--- a/flink-connectors/flink-jdbc/src/main/java/org/apache/flink/api/java/io/jdbc/split/NumericBetweenParametersProvider.java
+++ b/flink-connectors/flink-jdbc/src/main/java/org/apache/flink/api/java/io/jdbc/split/NumericBetweenParametersProvider.java
@@ -17,48 +17,58 @@
  */
 package org.apache.flink.api.java.io.jdbc.split;
 
+import static org.apache.flink.util.Preconditions.checkArgument;
+
 import java.io.Serializable;
 
 /** 
  * 
- * This query generator assumes that the query to parameterize contains a BETWEEN constraint on a numeric column.
- * The generated query set will be of size equal to the configured fetchSize (apart the last one range),
- * ranging from the min value up to the max.
+ * This query parameters generator is an helper class to parameterize from/to queries on a numeric column.
+ * The generated array of from/to values will be equally sized to fetchSize (apart from the last one),
+ * ranging from minVal up to maxVal.
  * 
  * For example, if there's a table <CODE>BOOKS</CODE> with a numeric PK <CODE>id</CODE>, using a query like:
  * <PRE>
  *   SELECT * FROM BOOKS WHERE id BETWEEN ? AND ?
  * </PRE>
  *
- * you can use this class to automatically generate the parameters of the BETWEEN clause,
+ * you can take advantage of this class to automatically generate the parameters of the BETWEEN clause,
  * based on the passed constructor parameters.
  * 
  * */
 public class NumericBetweenParametersProvider implements ParameterValuesProvider {
 
-	private long fetchSize;
-	private final long min;
-	private final long max;
+	private final long fetchSize;
+	private final long minVal;
+	private final long maxVal;
 	
-	public NumericBetweenParametersProvider(long fetchSize, long min, long max) {
+	/**
+	 * NumericBetweenParametersProvider constructor.
+	 * 
+	 * @param fetchSize the max distance between the produced from/to pairs
+	 * @param minVal the lower bound of the produced "from" values
+	 * @param maxVal the upper bound of the produced "to" values
+	 */
+	public NumericBetweenParametersProvider(long fetchSize, long minVal, long maxVal) {
+		checkArgument(fetchSize > 0, "Fetch size must be greater than 0.");
+		checkArgument(minVal <= maxVal, "Min value cannot be greater than max value.");
 		this.fetchSize = fetchSize;
-		this.min = min;
-		this.max = max;
+		this.minVal = minVal;
+		this.maxVal = maxVal;
 	}
 
 	@Override
-	public Serializable[][] getParameterValues(){
-		double maxElemCount = (max - min) + 1;
-		int size = new Double(Math.ceil(maxElemCount / fetchSize)).intValue();
-		Serializable[][] parameters = new Serializable[size][2];
-		int count = 0;
-		for (long i = min; i < max; i += fetchSize, count++) {
-			long currentLimit = i + fetchSize - 1;
-			parameters[count] = new Long[]{i,currentLimit};
-			if (currentLimit + 1 + fetchSize > max) {
-				parameters[count + 1] = new Long[]{currentLimit + 1, max};
-				break;
+	public Serializable[][] getParameterValues() {
+		double maxElemCount = (maxVal - minVal) + 1;
+		int numBatches = new Double(Math.ceil(maxElemCount / fetchSize)).intValue();
+		Serializable[][] parameters = new Serializable[numBatches][2];
+		int batchIndex = 0;
+		for (long start = minVal; start <= maxVal; start += fetchSize, batchIndex++) {
+			long end = start + fetchSize - 1;
+			if (end > maxVal) {
+				end = maxVal;
 			}
+			parameters[batchIndex] = new Long[]{start, end};
 		}
 		return parameters;
 	}
diff --git a/flink-connectors/flink-jdbc/src/test/java/org/apache/flink/api/java/io/jdbc/JDBCInputFormatTest.java b/flink-connectors/flink-jdbc/src/test/java/org/apache/flink/api/java/io/jdbc/JDBCInputFormatTest.java
index b08aa3abc03..bee3d251a98 100644
--- a/flink-connectors/flink-jdbc/src/test/java/org/apache/flink/api/java/io/jdbc/JDBCInputFormatTest.java
+++ b/flink-connectors/flink-jdbc/src/test/java/org/apache/flink/api/java/io/jdbc/JDBCInputFormatTest.java
@@ -18,19 +18,19 @@
 
 package org.apache.flink.api.java.io.jdbc;
 
-import java.io.IOException;
-import java.io.Serializable;
-import java.sql.ResultSet;
-
 import org.apache.flink.api.java.io.jdbc.split.GenericParameterValuesProvider;
 import org.apache.flink.api.java.io.jdbc.split.NumericBetweenParametersProvider;
 import org.apache.flink.api.java.io.jdbc.split.ParameterValuesProvider;
-import org.apache.flink.types.Row;
 import org.apache.flink.core.io.InputSplit;
+import org.apache.flink.types.Row;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Test;
 
+import java.io.IOException;
+import java.io.Serializable;
+import java.sql.ResultSet;
+
 public class JDBCInputFormatTest extends JDBCTestBase {
 
 	private JDBCInputFormat jdbcInputFormat;
@@ -116,11 +116,21 @@ public class JDBCInputFormatTest extends JDBCTestBase {
 				break;
 			}
 			
-			if(next.getField(0)!=null) { Assert.assertEquals("Field 0 should be int", Integer.class, next.getField(0).getClass());}
-			if(next.getField(1)!=null) { Assert.assertEquals("Field 1 should be String", String.class, next.getField(1).getClass());}
-			if(next.getField(2)!=null) { Assert.assertEquals("Field 2 should be String", String.class, next.getField(2).getClass());}
-			if(next.getField(3)!=null) { Assert.assertEquals("Field 3 should be float", Double.class, next.getField(3).getClass());}
-			if(next.getField(4)!=null) { Assert.assertEquals("Field 4 should be int", Integer.class, next.getField(4).getClass());}
+			if (next.getField(0) != null) {
+				Assert.assertEquals("Field 0 should be int", Integer.class, next.getField(0).getClass());
+			}
+			if (next.getField(1) != null) {
+				Assert.assertEquals("Field 1 should be String", String.class, next.getField(1).getClass());
+			}
+			if (next.getField(2) != null) {
+				Assert.assertEquals("Field 2 should be String", String.class, next.getField(2).getClass());
+			}
+			if (next.getField(3) != null) {
+				Assert.assertEquals("Field 3 should be float", Double.class, next.getField(3).getClass());
+			}
+			if (next.getField(4) != null) {
+				Assert.assertEquals("Field 4 should be int", Integer.class, next.getField(4).getClass());
+			}
 
 			for (int x = 0; x < 5; x++) {
 				if(testData[recordCount][x]!=null) {
@@ -162,11 +172,78 @@ public class JDBCInputFormatTest extends JDBCTestBase {
 				if (next == null) {
 					break;
 				}
-				if(next.getField(0)!=null) { Assert.assertEquals("Field 0 should be int", Integer.class, next.getField(0).getClass());}
-				if(next.getField(1)!=null) { Assert.assertEquals("Field 1 should be String", String.class, next.getField(1).getClass());}
-				if(next.getField(2)!=null) { Assert.assertEquals("Field 2 should be String", String.class, next.getField(2).getClass());}
-				if(next.getField(3)!=null) { Assert.assertEquals("Field 3 should be float", Double.class, next.getField(3).getClass());}
-				if(next.getField(4)!=null) { Assert.assertEquals("Field 4 should be int", Integer.class, next.getField(4).getClass());}
+				if (next.getField(0) != null) {
+					Assert.assertEquals("Field 0 should be int", Integer.class, next.getField(0).getClass());
+				}
+				if (next.getField(1) != null) {
+					Assert.assertEquals("Field 1 should be String", String.class, next.getField(1).getClass());
+				}
+				if (next.getField(2) != null) {
+					Assert.assertEquals("Field 2 should be String", String.class, next.getField(2).getClass());
+				}
+				if (next.getField(3) != null) {
+					Assert.assertEquals("Field 3 should be float", Double.class, next.getField(3).getClass());
+				}
+				if (next.getField(4) != null) {
+					Assert.assertEquals("Field 4 should be int", Integer.class, next.getField(4).getClass());
+				}
+
+				for (int x = 0; x < 5; x++) {
+					if(testData[recordCount][x]!=null) {
+						Assert.assertEquals(testData[recordCount][x], next.getField(x));
+					}
+				}
+				recordCount++;
+			}
+			jdbcInputFormat.close();
+		}
+		jdbcInputFormat.closeInputFormat();
+		Assert.assertEquals(testData.length, recordCount);
+	}
+
+	@Test
+	public void testJDBCInputFormatWithoutParallelismAndNumericColumnSplitting() throws IOException, InstantiationException, IllegalAccessException {
+		final Long min = new Long(JDBCTestBase.testData[0][0] + "");
+		final Long max = new Long(JDBCTestBase.testData[JDBCTestBase.testData.length - 1][0] + "");
+		final long fetchSize = max + 1;//generate a single split
+		ParameterValuesProvider pramProvider = new NumericBetweenParametersProvider(fetchSize, min, max);
+		jdbcInputFormat = JDBCInputFormat.buildJDBCInputFormat()
+				.setDrivername(DRIVER_CLASS)
+				.setDBUrl(DB_URL)
+				.setQuery(JDBCTestBase.SELECT_ALL_BOOKS_SPLIT_BY_ID)
+				.setRowTypeInfo(rowTypeInfo)
+				.setParametersProvider(pramProvider)
+				.setResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE)
+				.finish();
+
+		jdbcInputFormat.openInputFormat();
+		InputSplit[] splits = jdbcInputFormat.createInputSplits(1);
+		//assert that a single split was generated
+		Assert.assertEquals(1, splits.length);
+		int recordCount = 0;
+		Row row =  new Row(5);
+		for (int i = 0; i < splits.length; i++) {
+			jdbcInputFormat.open(splits[i]);
+			while (!jdbcInputFormat.reachedEnd()) {
+				Row next = jdbcInputFormat.nextRecord(row);
+				if (next == null) {
+					break;
+				}
+				if (next.getField(0) != null) {
+					Assert.assertEquals("Field 0 should be int", Integer.class, next.getField(0).getClass());
+				}
+				if (next.getField(1) != null) {
+					Assert.assertEquals("Field 1 should be String", String.class, next.getField(1).getClass());
+				}
+				if (next.getField(2) != null) {
+					Assert.assertEquals("Field 2 should be String", String.class, next.getField(2).getClass());
+				}
+				if (next.getField(3) != null) {
+					Assert.assertEquals("Field 3 should be float", Double.class, next.getField(3).getClass());
+				}
+				if (next.getField(4) != null) {
+					Assert.assertEquals("Field 4 should be int", Integer.class, next.getField(4).getClass());
+				}
 
 				for (int x = 0; x < 5; x++) {
 					if(testData[recordCount][x]!=null) {
@@ -208,11 +285,21 @@ public class JDBCInputFormatTest extends JDBCTestBase {
 				if (next == null) {
 					break;
 				}
-				if(next.getField(0)!=null) { Assert.assertEquals("Field 0 should be int", Integer.class, next.getField(0).getClass());}
-				if(next.getField(1)!=null) { Assert.assertEquals("Field 1 should be String", String.class, next.getField(1).getClass());}
-				if(next.getField(2)!=null) { Assert.assertEquals("Field 2 should be String", String.class, next.getField(2).getClass());}
-				if(next.getField(3)!=null) { Assert.assertEquals("Field 3 should be float", Double.class, next.getField(3).getClass());}
-				if(next.getField(4)!=null) { Assert.assertEquals("Field 4 should be int", Integer.class, next.getField(4).getClass());}
+				if (next.getField(0) != null) {
+					Assert.assertEquals("Field 0 should be int", Integer.class, next.getField(0).getClass());
+				}
+				if (next.getField(1) != null) {
+					Assert.assertEquals("Field 1 should be String", String.class, next.getField(1).getClass());
+				}
+				if (next.getField(2) != null) {
+					Assert.assertEquals("Field 2 should be String", String.class, next.getField(2).getClass());
+				}
+				if (next.getField(3) != null) {
+					Assert.assertEquals("Field 3 should be float", Double.class, next.getField(3).getClass());
+				}
+				if (next.getField(4) != null) {
+					Assert.assertEquals("Field 4 should be int", Integer.class, next.getField(4).getClass());
+				}
 
 				recordCount++;
 			}
