diff --git a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/processors/utils/InputOrderCalculator.java b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/processors/utils/InputOrderCalculator.java
index b9ef67cbaa6..ff2b685f4cb 100644
--- a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/processors/utils/InputOrderCalculator.java
+++ b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/processors/utils/InputOrderCalculator.java
@@ -19,6 +19,8 @@
 package org.apache.flink.table.planner.plan.processors.utils;
 
 import org.apache.flink.annotation.Internal;
+import org.apache.flink.annotation.VisibleForTesting;
+import org.apache.flink.table.planner.plan.nodes.exec.AbstractExecNodeExactlyOnceVisitor;
 import org.apache.flink.table.planner.plan.nodes.exec.ExecEdge;
 import org.apache.flink.table.planner.plan.nodes.exec.ExecNode;
 
@@ -59,6 +61,11 @@ public class InputOrderCalculator extends InputPriorityGraphGenerator {
 
 	public Map<ExecNode<?, ?>, Integer> calculate() {
 		createTopologyGraph();
+
+		// some boundaries node may be connected from the outside of the sub-graph,
+		// which we cannot deduce by the above process,
+		// so we need to check each pair of boundaries and see if they're related
+		dealWithPossiblyRelatedBoundaries();
 		Map<ExecNode<?, ?>, Integer> distances = graph.calculateMaximumDistance();
 
 		// extract only the distances of the boundaries and renumbering the distances
@@ -78,6 +85,86 @@ public class InputOrderCalculator extends InputPriorityGraphGenerator {
 		return results;
 	}
 
+	private void dealWithPossiblyRelatedBoundaries() {
+		List<ExecNode<?, ?>> boundaries = new ArrayList<>(this.boundaries);
+		for (int i = 0; i < boundaries.size(); i++) {
+			ExecNode<?, ?> boundaryA = boundaries.get(i);
+			for (int j = i + 1; j < boundaries.size(); j++) {
+				ExecNode<?, ?> boundaryB = boundaries.get(j);
+				// if boundaries are already comparable in the topology graph
+				// we do not need to check them
+				if (graph.canReach(boundaryA, boundaryB) || graph.canReach(boundaryB, boundaryA)) {
+					continue;
+				}
+				dealWithPossiblyRelatedBoundaries(boundaryA, boundaryB);
+			}
+		}
+	}
+
+	private void dealWithPossiblyRelatedBoundaries(ExecNode<?, ?> boundaryA, ExecNode<?, ?> boundaryB) {
+		Set<ExecNode<?, ?>> ancestorsA = calculateAllAncestors(boundaryA);
+		Set<ExecNode<?, ?>> ancestorsB = calculateAllAncestors(boundaryB);
+		if (checkPipelinedPath(boundaryA, ancestorsB)) {
+			// boundary A and B are related, and there exists a path
+			// which only goes through PIPELINED edges from their public ancestor to boundary A.
+			// this means that the priority of boundary B should be at least as low as A
+			graph.makeAsFarAs(boundaryB, boundaryA);
+		}
+		if (checkPipelinedPath(boundaryB, ancestorsA)) {
+			// similar situation with above
+			graph.makeAsFarAs(boundaryA, boundaryB);
+		}
+	}
+
+	private static Set<ExecNode<?, ?>> calculateAllAncestors(ExecNode<?, ?> node) {
+		Set<ExecNode<?, ?>> ret = new HashSet<>();
+		AbstractExecNodeExactlyOnceVisitor visitor = new AbstractExecNodeExactlyOnceVisitor() {
+			@Override
+			protected void visitNode(ExecNode<?, ?> node) {
+				ret.add(node);
+				visitInputs(node);
+			}
+		};
+		node.accept(visitor);
+		return ret;
+	}
+
+	@VisibleForTesting
+	static boolean checkPipelinedPath(ExecNode<?, ?> node, Set<ExecNode<?, ?>> goals) {
+		PipelinedPathChecker checker = new PipelinedPathChecker(goals);
+		node.accept(checker);
+		return checker.res;
+	}
+
+	private static class PipelinedPathChecker extends AbstractExecNodeExactlyOnceVisitor {
+		private final Set<ExecNode<?, ?>> goals;
+		private boolean res;
+
+		private PipelinedPathChecker(Set<ExecNode<?, ?>> goals) {
+			this.goals = goals;
+			this.res = false;
+		}
+
+		@Override
+		protected void visitNode(ExecNode<?, ?> node) {
+			if (goals.contains(node)) {
+				res = true;
+				return;
+			}
+
+			List<ExecEdge> inputEdges = node.getInputEdges();
+			for (int i = 0; i < inputEdges.size(); i++) {
+				if (inputEdges.get(i).getDamBehavior().stricterOrEqual(ExecEdge.DamBehavior.END_INPUT)) {
+					continue;
+				}
+				visit(node.getInputNodes().get(i));
+				if (res) {
+					return;
+				}
+			}
+		}
+	}
+
 	@Override
 	protected void resolveInputPriorityConflict(ExecNode<?, ?> node, int higherInput, int lowerInput) {
 		throw new IllegalStateException("A conflict is detected. This is unexpected.");
diff --git a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/processors/utils/TopologyGraph.java b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/processors/utils/TopologyGraph.java
index 40727f06ad4..6be70604b56 100644
--- a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/processors/utils/TopologyGraph.java
+++ b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/processors/utils/TopologyGraph.java
@@ -139,6 +139,19 @@ class TopologyGraph {
 		return result;
 	}
 
+	/**
+	 * Make the distance of node A at least as far as node B by adding edges
+	 * from all inputs of node B to node A.
+	 */
+	void makeAsFarAs(ExecNode<?, ?> a, ExecNode<?, ?> b) {
+		TopologyNode nodeA = getOrCreateTopologyNode(a);
+		TopologyNode nodeB = getOrCreateTopologyNode(b);
+
+		for (TopologyNode input : nodeB.inputs) {
+			link(input.execNode, nodeA.execNode);
+		}
+	}
+
 	@VisibleForTesting
 	boolean canReach(ExecNode<?, ?> from, ExecNode<?, ?> to) {
 		TopologyNode fromNode = getOrCreateTopologyNode(from);
diff --git a/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/plan/processors/utils/InputOrderCalculatorTest.java b/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/plan/processors/utils/InputOrderCalculatorTest.java
index c9cbcf7dbef..01acaa92b48 100644
--- a/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/plan/processors/utils/InputOrderCalculatorTest.java
+++ b/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/plan/processors/utils/InputOrderCalculatorTest.java
@@ -35,18 +35,46 @@ import java.util.Map;
  */
 public class InputOrderCalculatorTest {
 
+	@Test
+	public void testCheckPipelinedPath() {
+		// P = ExecEdge.DamBehavior.PIPELINED, E = ExecEdge.DamBehavior.END_INPUT B = ExecEdge.DamBehavior.BLOCKING
+		//
+		// 0 -P-> 1 ----E----\
+		//         \-P-\      \
+		// 2 ----E----> 3 -P-> 4
+		// 5 -P-> 6 -B-/
+		TestingBatchExecNode[] nodes = new TestingBatchExecNode[7];
+		for (int i = 0; i < nodes.length; i++) {
+			nodes[i] = new TestingBatchExecNode();
+		}
+		nodes[1].addInput(nodes[0]);
+		nodes[3].addInput(nodes[1]);
+		nodes[3].addInput(nodes[2], ExecEdge.builder().damBehavior(ExecEdge.DamBehavior.END_INPUT).build());
+		nodes[3].addInput(nodes[6], ExecEdge.builder().damBehavior(ExecEdge.DamBehavior.BLOCKING).build());
+		nodes[4].addInput(nodes[1], ExecEdge.builder().damBehavior(ExecEdge.DamBehavior.END_INPUT).build());
+		nodes[4].addInput(nodes[3]);
+		nodes[6].addInput(nodes[5]);
+
+		Assert.assertFalse(
+			InputOrderCalculator.checkPipelinedPath(nodes[4], new HashSet<>(
+				Arrays.asList(nodes[2], nodes[5], nodes[6]))));
+		Assert.assertTrue(
+			InputOrderCalculator.checkPipelinedPath(nodes[4], new HashSet<>(
+				Arrays.asList(nodes[0], nodes[2]))));
+	}
+
 	@Test
 	public void testCalculateInputOrder() {
 		// P = ExecEdge.DamBehavior.PIPELINED, B = ExecEdge.DamBehavior.BLOCKING
 		// P1 = PIPELINED + priority 1
 		//
-		// 0 -(P0)-> 3 -(B0)-\
+		// 0 -(P1)-> 3 -(B0)-\
 		//                    6 -(B0)-\
 		//            /-(P1)-/         \
-		// 1 -(P0)-> 4                  8
+		// 1 -(P1)-> 4                  8
 		//            \-(B0)-\         /
 		//                    7 -(P1)-/
-		// 2 -(P0)-> 5 -(P1)-/
+		// 2 -(P1)-> 5 -(P1)-/
 		TestingBatchExecNode[] nodes = new TestingBatchExecNode[9];
 		for (int i = 0; i < nodes.length; i++) {
 			nodes[i] = new TestingBatchExecNode();
@@ -72,6 +100,73 @@ public class InputOrderCalculatorTest {
 		Assert.assertEquals(2, result.get(nodes[5]).intValue());
 	}
 
+	@Test
+	public void testCalculateInputOrderWithRelatedBoundaries() {
+		// P = ExecEdge.DamBehavior.PIPELINED, B = ExecEdge.DamBehavior.BLOCKING
+		// P1 = PIPELINED + priority 1
+		//
+		// /------------(P0)------------\
+		// 0 -(P0)-> 1 -(B0)-> 2 -(P0)-> 4 -(P1)-> 5
+		//           3 -(P1)-/           6 -(B0)-/
+		TestingBatchExecNode[] nodes = new TestingBatchExecNode[7];
+		for (int i = 0; i < nodes.length; i++) {
+			nodes[i] = new TestingBatchExecNode();
+		}
+		nodes[1].addInput(nodes[0]);
+		nodes[2].addInput(nodes[1], ExecEdge.builder().damBehavior(ExecEdge.DamBehavior.BLOCKING).build());
+		nodes[2].addInput(nodes[3], ExecEdge.builder().priority(1).build());
+		nodes[4].addInput(nodes[0]);
+		nodes[4].addInput(nodes[2]);
+		nodes[5].addInput(nodes[4], ExecEdge.builder().priority(1).build());
+		nodes[5].addInput(nodes[6], ExecEdge.builder().damBehavior(ExecEdge.DamBehavior.BLOCKING).build());
+
+		InputOrderCalculator calculator = new InputOrderCalculator(
+			nodes[5],
+			new HashSet<>(Arrays.asList(nodes[0], nodes[1], nodes[3], nodes[6])),
+			ExecEdge.DamBehavior.BLOCKING);
+		Map<ExecNode<?, ?>, Integer> result = calculator.calculate();
+		Assert.assertEquals(4, result.size());
+		Assert.assertEquals(1, result.get(nodes[0]).intValue());
+		Assert.assertEquals(1, result.get(nodes[1]).intValue());
+		Assert.assertEquals(2, result.get(nodes[3]).intValue());
+		Assert.assertEquals(0, result.get(nodes[6]).intValue());
+	}
+
+	@Test
+	public void testCalculateInputOrderWithUnaffectedRelatedBoundaries() {
+		// P = ExecEdge.DamBehavior.PIPELINED, B = ExecEdge.DamBehavior.BLOCKING
+		// P1 = PIPELINED + priority 1
+		//
+		// 0 --(P0)-> 1 -------(B0)-----> 2 -(P0)-\
+		//  \          \--(B0)-> 3 -(P1)-/         4
+		//   \-(B0)-> 5 -------(P1)-----> 6 -(P0)-/
+		//                     7 --(B0)--/
+		TestingBatchExecNode[] nodes = new TestingBatchExecNode[8];
+		for (int i = 0; i < nodes.length; i++) {
+			nodes[i] = new TestingBatchExecNode();
+		}
+		nodes[1].addInput(nodes[0]);
+		nodes[2].addInput(nodes[1], ExecEdge.builder().damBehavior(ExecEdge.DamBehavior.BLOCKING).build());
+		nodes[2].addInput(nodes[3], ExecEdge.builder().priority(1).build());
+		nodes[3].addInput(nodes[1], ExecEdge.builder().damBehavior(ExecEdge.DamBehavior.BLOCKING).build());
+		nodes[4].addInput(nodes[2]);
+		nodes[4].addInput(nodes[6]);
+		nodes[5].addInput(nodes[0], ExecEdge.builder().damBehavior(ExecEdge.DamBehavior.BLOCKING).build());
+		nodes[6].addInput(nodes[5], ExecEdge.builder().priority(1).build());
+		nodes[6].addInput(nodes[7], ExecEdge.builder().damBehavior(ExecEdge.DamBehavior.BLOCKING).build());
+
+		InputOrderCalculator calculator = new InputOrderCalculator(
+			nodes[4],
+			new HashSet<>(Arrays.asList(nodes[1], nodes[3], nodes[5], nodes[7])),
+			ExecEdge.DamBehavior.BLOCKING);
+		Map<ExecNode<?, ?>, Integer> result = calculator.calculate();
+		Assert.assertEquals(4, result.size());
+		Assert.assertEquals(0, result.get(nodes[1]).intValue());
+		Assert.assertEquals(1, result.get(nodes[3]).intValue());
+		Assert.assertEquals(1, result.get(nodes[5]).intValue());
+		Assert.assertEquals(0, result.get(nodes[7]).intValue());
+	}
+
 	@Test(expected = IllegalStateException.class)
 	public void testCalculateInputOrderWithLoop() {
 		TestingBatchExecNode a = new TestingBatchExecNode();
diff --git a/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/plan/processors/utils/TopologyGraphTest.java b/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/plan/processors/utils/TopologyGraphTest.java
index 5180a65daf8..ca948fe9810 100644
--- a/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/plan/processors/utils/TopologyGraphTest.java
+++ b/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/plan/processors/utils/TopologyGraphTest.java
@@ -157,4 +157,16 @@ public class TopologyGraphTest {
 		Assert.assertEquals(2, result.get(nodes[5]).intValue());
 		Assert.assertEquals(2, result.get(nodes[7]).intValue());
 	}
+
+	@Test
+	public void testMakeAsFarAs() {
+		Tuple2<TopologyGraph, TestingBatchExecNode[]> tuple2 = buildTopologyGraph();
+		TopologyGraph graph = tuple2.f0;
+		TestingBatchExecNode[] nodes = tuple2.f1;
+
+		graph.makeAsFarAs(nodes[4], nodes[7]);
+		Map<ExecNode<?, ?>, Integer> distances = graph.calculateMaximumDistance();
+		Assert.assertEquals(4, distances.get(nodes[7]).intValue());
+		Assert.assertEquals(4, distances.get(nodes[4]).intValue());
+	}
 }
diff --git a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/batch/sql/MultipleInputCreationTest.xml b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/batch/sql/MultipleInputCreationTest.xml
index 85bcb081b40..cc8d5b929db 100644
--- a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/batch/sql/MultipleInputCreationTest.xml
+++ b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/batch/sql/MultipleInputCreationTest.xml
@@ -16,7 +16,7 @@ See the License for the specific language governing permissions and
 limitations under the License.
 -->
 <Root>
-  <TestCase name="testAvoidIncludingCalcAfterNonChainableSource">
+  <TestCase name="testAvoidIncludingCalcAfterNonChainableSource[shuffleMode: ALL_EDGES_BLOCKING]">
     <Resource name="sql">
       <![CDATA[
 SELECT * FROM x
@@ -48,7 +48,39 @@ MultipleInputNode(readOrder=[0,1,0], members=[\nNestedLoopJoin(joinType=[LeftOut
 ]]>
     </Resource>
   </TestCase>
-  <TestCase name="testIncludeCalcForChainableSource">
+  <TestCase name="testAvoidIncludingCalcAfterNonChainableSource[shuffleMode: ALL_EDGES_PIPELINED]">
+    <Resource name="sql">
+      <![CDATA[
+SELECT * FROM x
+  LEFT JOIN y ON x.a = y.d
+  LEFT JOIN t ON x.a = t.a
+  WHERE x.b > 10
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], c=[$2], nx=[$3], d=[$4], e=[$5], f=[$6], ny=[$7], a0=[$8], b0=[$9], c0=[$10])
++- LogicalFilter(condition=[>($1, 10)])
+   +- LogicalJoin(condition=[=($0, $8)], joinType=[left])
+      :- LogicalJoin(condition=[=($0, $4)], joinType=[left])
+      :  :- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+      :  +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+      +- LogicalTableScan(table=[[default_catalog, default_database, t]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+MultipleInputNode(readOrder=[0,1,0], members=[\nNestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, a0)], select=[a, b, c, nx, d, e, f, ny, a0, b0, c0], build=[right])\n:- NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, d)], select=[a, b, c, nx, d, e, f, ny], build=[right])\n:  :- [#2] Calc(select=[a, b, c, nx], where=[>(b, 10)])\n:  +- [#3] Exchange(distribution=[broadcast])\n+- [#1] Exchange(distribution=[broadcast])\n])
+:- Exchange(distribution=[broadcast])
+:  +- BoundedStreamScan(table=[[default_catalog, default_database, t]], fields=[a, b, c])
+:- Calc(select=[a, b, c, nx], where=[>(b, 10)])
+:  +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]], fields=[a, b, c, nx])
++- Exchange(distribution=[broadcast])
+   +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testIncludeCalcForChainableSource[shuffleMode: ALL_EDGES_BLOCKING]">
     <Resource name="sql">
       <![CDATA[
 SELECT * FROM chainable
@@ -79,7 +111,53 @@ MultipleInputNode(readOrder=[0,0,1], members=[\nNestedLoopJoin(joinType=[LeftOut
 ]]>
     </Resource>
   </TestCase>
-  <TestCase name="testAvoidIncludingSingleton">
+  <TestCase name="testAvoidIncludingSingleton[shuffleMode: ALL_EDGES_BLOCKING]">
+    <Resource name="sql">
+      <![CDATA[
+WITH T1 AS (SELECT COUNT(*) AS cnt FROM z)
+SELECT * FROM
+  (SELECT a FROM x INNER JOIN y ON x.a = y.d)
+  UNION ALL
+  (SELECT a FROM t FULL JOIN T1 ON t.a > T1.cnt)
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalUnion(all=[true])
+:- LogicalProject(a=[$0])
+:  +- LogicalJoin(condition=[=($0, $4)], joinType=[inner])
+:     :- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+:     +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
++- LogicalProject(a=[$0])
+   +- LogicalJoin(condition=[>($0, $3)], joinType=[full])
+      :- LogicalTableScan(table=[[default_catalog, default_database, t]])
+      +- LogicalAggregate(group=[{}], cnt=[COUNT()])
+         +- LogicalProject($f0=[0])
+            +- LogicalTableScan(table=[[default_catalog, default_database, z, source: [TestTableSource(g, h, i, nz)]]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+MultipleInputNode(readOrder=[0,0,1], members=[\nUnion(all=[true], union=[a])\n:- Calc(select=[a])\n:  +- NestedLoopJoin(joinType=[InnerJoin], where=[=(a, d)], select=[a, d], build=[left])\n:     :- [#2] Exchange(distribution=[broadcast])\n:     +- [#3] Calc(select=[d])\n+- [#1] Calc(select=[a])\n])
+:- Calc(select=[a])
+:  +- NestedLoopJoin(joinType=[FullOuterJoin], where=[>(a, cnt)], select=[a, cnt], build=[right], singleRowJoin=[true])
+:     :- Exchange(distribution=[single])
+:     :  +- Calc(select=[a])
+:     :     +- BoundedStreamScan(table=[[default_catalog, default_database, t]], fields=[a, b, c])
+:     +- SortAggregate(isMerge=[true], select=[Final_COUNT(count1$0) AS cnt])
+:        +- Exchange(distribution=[single])
+:           +- LocalSortAggregate(select=[Partial_COUNT(*) AS count1$0])
+:              +- Calc(select=[0 AS $f0])
+:                 +- LegacyTableSourceScan(table=[[default_catalog, default_database, z, source: [TestTableSource(g, h, i, nz)]]], fields=[g, h, i, nz])
+:- Exchange(distribution=[broadcast])
+:  +- Calc(select=[a])
+:     +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]], fields=[a, b, c, nx])
++- Calc(select=[d])
+   +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testAvoidIncludingSingleton[shuffleMode: ALL_EDGES_PIPELINED]">
     <Resource name="sql">
       <![CDATA[
 WITH T1 AS (SELECT COUNT(*) AS cnt FROM z)
@@ -125,7 +203,7 @@ MultipleInputNode(readOrder=[0,0,1], members=[\nUnion(all=[true], union=[a])\n:-
 ]]>
     </Resource>
   </TestCase>
-  <TestCase name="testAvoidIncludingUnionFromInputSide">
+  <TestCase name="testAvoidIncludingUnionFromInputSide[shuffleMode: ALL_EDGES_BLOCKING]">
     <Resource name="sql">
       <![CDATA[
 SELECT * FROM
@@ -158,7 +236,40 @@ NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, d)], select=[a, d, e, f, ny
 ]]>
     </Resource>
   </TestCase>
-  <TestCase name="testBasicMultipleInput">
+  <TestCase name="testAvoidIncludingUnionFromInputSide[shuffleMode: ALL_EDGES_PIPELINED]">
+    <Resource name="sql">
+      <![CDATA[
+SELECT * FROM
+  (SELECT a FROM (SELECT a FROM x) UNION ALL (SELECT a FROM t)) T1
+  LEFT JOIN y ON T1.a = y.d
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], d=[$1], e=[$2], f=[$3], ny=[$4])
++- LogicalJoin(condition=[=($0, $1)], joinType=[left])
+   :- LogicalUnion(all=[true])
+   :  :- LogicalProject(a=[$0])
+   :  :  +- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+   :  +- LogicalProject(a=[$0])
+   :     +- LogicalTableScan(table=[[default_catalog, default_database, t]])
+   +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, d)], select=[a, d, e, f, ny], build=[right])
+:- Union(all=[true], union=[a])
+:  :- Calc(select=[a])
+:  :  +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]], fields=[a, b, c, nx])
+:  +- Calc(select=[a])
+:     +- BoundedStreamScan(table=[[default_catalog, default_database, t]], fields=[a, b, c])
++- Exchange(distribution=[broadcast])
+   +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testBasicMultipleInput[shuffleMode: ALL_EDGES_PIPELINED]">
     <Resource name="sql">
       <![CDATA[
 SELECT * FROM
@@ -198,7 +309,108 @@ MultipleInputNode(readOrder=[2,1,1,0], members=[\nHashJoin(joinType=[InnerJoin],
 ]]>
     </Resource>
   </TestCase>
-  <TestCase name="testIncludeUnionForChainableSource">
+  <TestCase name="testNoPriorityConstraint[shuffleMode: ALL_EDGES_BLOCKING]">
+    <Resource name="sql">
+      <![CDATA[
+SELECT * FROM x
+  INNER JOIN y ON x.a = y.d
+  INNER JOIN t ON x.a = t.a
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], c=[$2], nx=[$3], d=[$4], e=[$5], f=[$6], ny=[$7], a0=[$8], b0=[$9], c0=[$10])
++- LogicalJoin(condition=[=($0, $8)], joinType=[inner])
+   :- LogicalJoin(condition=[=($0, $4)], joinType=[inner])
+   :  :- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+   :  +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+   +- LogicalTableScan(table=[[default_catalog, default_database, t]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+MultipleInputNode(members=[\nSortMergeJoin(joinType=[InnerJoin], where=[=(a, a0)], select=[a, b, c, nx, d, e, f, ny, a0, b0, c0])\n:- SortMergeJoin(joinType=[InnerJoin], where=[=(a, d)], select=[a, b, c, nx, d, e, f, ny])\n:  :- [#2] Exchange(distribution=[hash[a]])\n:  +- [#3] Exchange(distribution=[hash[d]])\n+- [#1] Exchange(distribution=[hash[a]])\n])
+:- Exchange(distribution=[hash[a]])
+:  +- BoundedStreamScan(table=[[default_catalog, default_database, t]], fields=[a, b, c])
+:- Exchange(distribution=[hash[a]])
+:  +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]], fields=[a, b, c, nx])
++- Exchange(distribution=[hash[d]])
+   +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testBasicMultipleInput[shuffleMode: ALL_EDGES_BLOCKING]">
+    <Resource name="sql">
+      <![CDATA[
+SELECT * FROM
+  (SELECT a FROM x INNER JOIN y ON x.a = y.d) T1
+  INNER JOIN
+  (SELECT d FROM y INNER JOIN t ON y.d = t.a) T2
+  ON T1.a = T2.d
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], d=[$1])
++- LogicalJoin(condition=[=($0, $1)], joinType=[inner])
+   :- LogicalProject(a=[$0])
+   :  +- LogicalJoin(condition=[=($0, $4)], joinType=[inner])
+   :     :- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+   :     +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+   +- LogicalProject(d=[$0])
+      +- LogicalJoin(condition=[=($0, $4)], joinType=[inner])
+         :- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+         +- LogicalTableScan(table=[[default_catalog, default_database, t]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+MultipleInputNode(readOrder=[2,1,1,0], members=[\nHashJoin(joinType=[InnerJoin], where=[=(a, d)], select=[a, d], build=[right])\n:- Calc(select=[a])\n:  +- HashJoin(joinType=[InnerJoin], where=[=(a, d)], select=[a, d], build=[right])\n:     :- [#1] Exchange(distribution=[hash[a]])\n:     +- [#2] Exchange(distribution=[hash[d]])\n+- Calc(select=[d])\n   +- HashJoin(joinType=[InnerJoin], where=[=(d, a)], select=[d, a], build=[right])\n      :- [#2] Exchange(distribution=[hash[d]])\n      +- [#4] Exchange(distribution=[hash[a]])\n])
+:- Exchange(distribution=[hash[a]])
+:  +- Calc(select=[a])
+:     +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]], fields=[a, b, c, nx])
+:- Exchange(distribution=[hash[d]], reuse_id=[1])
+:  +- Calc(select=[d])
+:     +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
+:- Reused(reference_id=[1])
++- Exchange(distribution=[hash[a]])
+   +- Calc(select=[a])
+      +- BoundedStreamScan(table=[[default_catalog, default_database, t]], fields=[a, b, c])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testIncludeCalcForChainableSource[shuffleMode: ALL_EDGES_PIPELINED]">
+    <Resource name="sql">
+      <![CDATA[
+SELECT * FROM chainable
+  LEFT JOIN y ON chainable.a = y.d
+  LEFT JOIN t ON chainable.a = t.a
+  WHERE chainable.a > 10
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], d=[$1], e=[$2], f=[$3], ny=[$4], a0=[$5], b=[$6], c=[$7])
++- LogicalFilter(condition=[>($0, 10)])
+   +- LogicalJoin(condition=[=($0, $5)], joinType=[left])
+      :- LogicalJoin(condition=[=($0, $1)], joinType=[left])
+      :  :- LogicalTableScan(table=[[default_catalog, default_database, chainable]])
+      :  +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+      +- LogicalTableScan(table=[[default_catalog, default_database, t]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+MultipleInputNode(readOrder=[0,0,1], members=[\nNestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, a0)], select=[a, d, e, f, ny, a0, b, c], build=[right])\n:- NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, d)], select=[a, d, e, f, ny], build=[right])\n:  :- Calc(select=[a], where=[>(a, 10)])\n:  :  +- [#3] BoundedStreamScan(table=[[default_catalog, default_database, chainable]], fields=[a])\n:  +- [#2] Exchange(distribution=[broadcast])\n+- [#1] Exchange(distribution=[broadcast])\n])
+:- Exchange(distribution=[broadcast])
+:  +- BoundedStreamScan(table=[[default_catalog, default_database, t]], fields=[a, b, c])
+:- Exchange(distribution=[broadcast])
+:  +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
++- BoundedStreamScan(table=[[default_catalog, default_database, chainable]], fields=[a])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testIncludeUnionForChainableSource[shuffleMode: ALL_EDGES_PIPELINED]">
     <Resource name="sql">
       <![CDATA[
 SELECT * FROM
@@ -229,7 +441,52 @@ MultipleInputNode(readOrder=[0,1,1], members=[\nNestedLoopJoin(joinType=[LeftOut
 ]]>
     </Resource>
   </TestCase>
-  <TestCase name="testJoinWithAggAsProbe">
+  <TestCase name="testJoinWithAggAsProbe[shuffleMode: ALL_EDGES_BLOCKING]">
+    <Resource name="sql">
+      <![CDATA[
+WITH T AS (SELECT a, d FROM x INNER JOIN y ON x.a = y.d)
+SELECT * FROM
+  (SELECT a, COUNT(*) AS cnt FROM T GROUP BY a) T1
+  LEFT JOIN
+  (SELECT d, SUM(a) AS sm FROM T GROUP BY d) T2
+  ON T1.a = T2.d
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], cnt=[$1], d=[$2], sm=[$3])
++- LogicalJoin(condition=[=($0, $2)], joinType=[left])
+   :- LogicalAggregate(group=[{0}], cnt=[COUNT()])
+   :  +- LogicalProject(a=[$0])
+   :     +- LogicalJoin(condition=[=($0, $4)], joinType=[inner])
+   :        :- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+   :        +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+   +- LogicalAggregate(group=[{0}], sm=[SUM($1)])
+      +- LogicalProject(d=[$4], a=[$0])
+         +- LogicalJoin(condition=[=($0, $4)], joinType=[inner])
+            :- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+            +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+HashJoin(joinType=[LeftOuterJoin], where=[=(a, d)], select=[a, cnt, d, sm], build=[right])
+:- Exchange(distribution=[hash[a]])
+:  +- HashAggregate(isMerge=[false], groupBy=[a], select=[a, COUNT(*) AS cnt])
+:     +- Calc(select=[a])
+:        +- HashJoin(joinType=[InnerJoin], where=[=(a, d)], select=[a, d], build=[right], reuse_id=[1])
+:           :- Exchange(distribution=[hash[a]])
+:           :  +- Calc(select=[a])
+:           :     +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]], fields=[a, b, c, nx])
+:           +- Exchange(distribution=[hash[d]])
+:              +- Calc(select=[d])
+:                 +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
++- HashAggregate(isMerge=[false], groupBy=[d], select=[d, SUM(a) AS sm])
+   +- Reused(reference_id=[1])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testJoinWithAggAsProbe[shuffleMode: ALL_EDGES_PIPELINED]">
     <Resource name="sql">
       <![CDATA[
 WITH T AS (SELECT a, d FROM x INNER JOIN y ON x.a = y.d)
@@ -274,7 +531,7 @@ HashJoin(joinType=[LeftOuterJoin], where=[=(a, d)], select=[a, cnt, d, sm], buil
 ]]>
     </Resource>
   </TestCase>
-  <TestCase name="testKeepMultipleInputWithOneMemberForChainableSource">
+  <TestCase name="testKeepMultipleInputWithOneMemberForChainableSource[shuffleMode: ALL_EDGES_BLOCKING]">
     <Resource name="sql">
       <![CDATA[SELECT * FROM chainable LEFT JOIN x ON chainable.a = x.a]]>
     </Resource>
@@ -295,7 +552,28 @@ MultipleInputNode(readOrder=[1,0], members=[\nNestedLoopJoin(joinType=[LeftOuter
 ]]>
     </Resource>
   </TestCase>
-  <TestCase name="testManyMultipleInputs">
+  <TestCase name="testKeepMultipleInputWithOneMemberForChainableSource[shuffleMode: ALL_EDGES_PIPELINED]">
+    <Resource name="sql">
+      <![CDATA[SELECT * FROM chainable LEFT JOIN x ON chainable.a = x.a]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], a0=[$1], b=[$2], c=[$3], nx=[$4])
++- LogicalJoin(condition=[=($0, $1)], joinType=[left])
+   :- LogicalTableScan(table=[[default_catalog, default_database, chainable]])
+   +- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+MultipleInputNode(readOrder=[1,0], members=[\nNestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, a0)], select=[a, a0, b, c, nx], build=[right])\n:- [#1] BoundedStreamScan(table=[[default_catalog, default_database, chainable]], fields=[a])\n+- [#2] Exchange(distribution=[broadcast])\n])
+:- BoundedStreamScan(table=[[default_catalog, default_database, chainable]], fields=[a])
++- Exchange(distribution=[broadcast])
+   +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]], fields=[a, b, c, nx])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testManyMultipleInputs[shuffleMode: ALL_EDGES_BLOCKING]">
     <Resource name="sql">
       <![CDATA[
 WITH
@@ -389,6 +667,346 @@ MultipleInputNode(readOrder=[0,0,1,1], members=[\nUnion(all=[true], union=[b, sd
             :- Reused(reference_id=[2])
             :- Reused(reference_id=[3])
             +- Reused(reference_id=[4])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testManyMultipleInputs[shuffleMode: ALL_EDGES_PIPELINED]">
+    <Resource name="sql">
+      <![CDATA[
+WITH
+  T1 AS (
+    SELECT a, ny, nz FROM x
+      LEFT JOIN y ON x.a = y.ny
+      LEFT JOIN z ON x.a = z.nz),
+  T2 AS (
+    SELECT T1.a AS a, t.b AS b, d, T1.ny AS ny, nz FROM T1
+      LEFT JOIN t ON T1.a = t.a
+      INNER JOIN y ON T1.a = y.d),
+  T3 AS (
+    SELECT T1.a AS a, t.b AS b, d, T1.ny AS ny, nz FROM T1
+      LEFT JOIN y ON T1.a = y.d
+      INNER JOIN t ON T1.a = t.a),
+  T4 AS (SELECT b, SUM(d) AS sd, SUM(ny) AS sy, SUM(nz) AS sz FROM T2 GROUP BY b),
+  T5 AS (SELECT b, SUM(d) AS sd, SUM(ny) AS sy, SUM(nz) AS sz FROM T3 GROUP BY b)
+SELECT * FROM
+  (SELECT t.b, sd, sy, sz FROM T4 LEFT JOIN t ON T4.b = t.b)
+  UNION ALL
+  (SELECT y.e, sd, sy, sz FROM T5 LEFT JOIN y ON T5.b = y.e)
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalUnion(all=[true])
+:- LogicalProject(b=[$5], sd=[$1], sy=[$2], sz=[$3])
+:  +- LogicalJoin(condition=[=($0, $5)], joinType=[left])
+:     :- LogicalAggregate(group=[{0}], sd=[SUM($1)], sy=[SUM($2)], sz=[SUM($3)])
+:     :  +- LogicalProject(b=[$4], d=[$6], ny=[$1], nz=[$2])
+:     :     +- LogicalJoin(condition=[=($0, $6)], joinType=[inner])
+:     :        :- LogicalJoin(condition=[=($0, $3)], joinType=[left])
+:     :        :  :- LogicalProject(a=[$0], ny=[$7], nz=[$11])
+:     :        :  :  +- LogicalJoin(condition=[=($0, $11)], joinType=[left])
+:     :        :  :     :- LogicalJoin(condition=[=($0, $7)], joinType=[left])
+:     :        :  :     :  :- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+:     :        :  :     :  +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+:     :        :  :     +- LogicalTableScan(table=[[default_catalog, default_database, z, source: [TestTableSource(g, h, i, nz)]]])
+:     :        :  +- LogicalTableScan(table=[[default_catalog, default_database, t]])
+:     :        +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+:     +- LogicalTableScan(table=[[default_catalog, default_database, t]])
++- LogicalProject(e=[$5], sd=[$1], sy=[$2], sz=[$3])
+   +- LogicalJoin(condition=[=($0, $5)], joinType=[left])
+      :- LogicalAggregate(group=[{0}], sd=[SUM($1)], sy=[SUM($2)], sz=[SUM($3)])
+      :  +- LogicalProject(b=[$8], d=[$3], ny=[$1], nz=[$2])
+      :     +- LogicalJoin(condition=[=($0, $7)], joinType=[inner])
+      :        :- LogicalJoin(condition=[=($0, $3)], joinType=[left])
+      :        :  :- LogicalProject(a=[$0], ny=[$7], nz=[$11])
+      :        :  :  +- LogicalJoin(condition=[=($0, $11)], joinType=[left])
+      :        :  :     :- LogicalJoin(condition=[=($0, $7)], joinType=[left])
+      :        :  :     :  :- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+      :        :  :     :  +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+      :        :  :     +- LogicalTableScan(table=[[default_catalog, default_database, z, source: [TestTableSource(g, h, i, nz)]]])
+      :        :  +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+      :        +- LogicalTableScan(table=[[default_catalog, default_database, t]])
+      +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+MultipleInputNode(readOrder=[0,0,1,1], members=[\nUnion(all=[true], union=[b, sd, sy, sz])\n:- Calc(select=[b0 AS b, sd, sy, sz])\n:  +- NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(b, b0)], select=[b, sd, sy, sz, b0], build=[right])\n:     :- HashAggregate(isMerge=[true], groupBy=[b], select=[b, Final_SUM(sum$0) AS sd, Final_SUM(sum$1) AS sy, Final_SUM(sum$2) AS sz])\n:     :  +- [#3] Exchange(distribution=[hash[b]])\n:     +- [#1] Exchange(distribution=[broadcast])\n+- Calc(select=[e, sd, sy, sz])\n   +- NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(b, e)], select=[b, sd, sy, sz, e], build=[right])\n      :- HashAggregate(isMerge=[true], groupBy=[b], select=[b, Final_SUM(sum$0) AS sd, Final_SUM(sum$1) AS sy, Final_SUM(sum$2) AS sz])\n      :  +- [#4] Exchange(distribution=[hash[b]])\n      +- [#2] Exchange(distribution=[broadcast])\n])
+:- Exchange(distribution=[broadcast])
+:  +- Calc(select=[b])
+:     +- BoundedStreamScan(table=[[default_catalog, default_database, t]], fields=[a, b, c], reuse_id=[1])
+:- Exchange(distribution=[broadcast])
+:  +- Calc(select=[e])
+:     +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
+:- Exchange(distribution=[hash[b]])
+:  +- LocalHashAggregate(groupBy=[b], select=[b, Partial_SUM(d) AS sum$0, Partial_SUM(ny) AS sum$1, Partial_SUM(nz) AS sum$2])
+:     +- Calc(select=[b, d, ny, nz])
+:        +- MultipleInputNode(readOrder=[0,1,0], members=[\nNestedLoopJoin(joinType=[InnerJoin], where=[=(a, d)], select=[a, ny, nz, b, d], build=[right])\n:- Calc(select=[a, ny, nz, b])\n:  +- NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, a0)], select=[a, ny, nz, a0, b], build=[right])\n:     :- [#2] MultipleInputNode(readOrder=[0,1,0], members=[\nNestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, nz)], select=[a, ny, nz], build=[right])\n:- NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, ny)], select=[a, ny], build=[right])\n:  :- [#2] Calc(select=[a])\n:  +- [#3] Exchange(distribution=[broadcast])\n+- [#1] Exchange(distribution=[broadcast])\n])\n:     +- [#3] Exchange(distribution=[broadcast])\n+- [#1] Exchange(distribution=[broadcast])\n])
+:           :- Exchange(distribution=[broadcast], reuse_id=[4])
+:           :  +- Calc(select=[d])
+:           :     +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
+:           :- MultipleInputNode(readOrder=[0,1,0], members=[\nNestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, nz)], select=[a, ny, nz], build=[right])\n:- NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, ny)], select=[a, ny], build=[right])\n:  :- [#2] Calc(select=[a])\n:  +- [#3] Exchange(distribution=[broadcast])\n+- [#1] Exchange(distribution=[broadcast])\n], reuse_id=[3])
+:           :  :- Exchange(distribution=[broadcast])
+:           :  :  +- Calc(select=[nz])
+:           :  :     +- LegacyTableSourceScan(table=[[default_catalog, default_database, z, source: [TestTableSource(g, h, i, nz)]]], fields=[g, h, i, nz])
+:           :  :- Calc(select=[a])
+:           :  :  +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]], fields=[a, b, c, nx])
+:           :  +- Exchange(distribution=[broadcast])
+:           :     +- Calc(select=[ny])
+:           :        +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
+:           +- Exchange(distribution=[broadcast], reuse_id=[2])
+:              +- Calc(select=[a, b])
+:                 +- Reused(reference_id=[1])
++- Exchange(distribution=[hash[b]])
+   +- LocalHashAggregate(groupBy=[b], select=[b, Partial_SUM(d) AS sum$0, Partial_SUM(ny) AS sum$1, Partial_SUM(nz) AS sum$2])
+      +- Calc(select=[b, d, ny, nz])
+         +- MultipleInputNode(readOrder=[0,1,0], members=[\nNestedLoopJoin(joinType=[InnerJoin], where=[=(a, a0)], select=[a, ny, nz, d, a0, b], build=[right])\n:- NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, d)], select=[a, ny, nz, d], build=[right])\n:  :- [#2] MultipleInputNode(readOrder=[0,1,0], members=[\nNestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, nz)], select=[a, ny, nz], build=[right])\n:- NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, ny)], select=[a, ny], build=[right])\n:  :- [#2] Calc(select=[a])\n:  +- [#3] Exchange(distribution=[broadcast])\n+- [#1] Exchange(distribution=[broadcast])\n])\n:  +- [#3] Exchange(distribution=[broadcast])\n+- [#1] Exchange(distribution=[broadcast])\n])
+            :- Reused(reference_id=[2])
+            :- Reused(reference_id=[3])
+            +- Reused(reference_id=[4])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testRelatedInputsWithAgg[shuffleMode: ALL_EDGES_BLOCKING]">
+    <Resource name="sql">
+      <![CDATA[
+WITH
+  T1 AS (SELECT x.a AS a, y.d AS b FROM y LEFT JOIN x ON y.d = x.a),
+  T2 AS (
+    SELECT a, b FROM
+      (SELECT a, b FROM T1)
+      UNION ALL
+      (SELECT COUNT(x.a) AS a, x.b AS b FROM x GROUP BY x.b))
+SELECT * FROM T2 LEFT JOIN t ON T2.a = t.a
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], a0=[$2], b0=[$3], c=[$4])
++- LogicalJoin(condition=[=($0, $5)], joinType=[left])
+   :- LogicalUnion(all=[true])
+   :  :- LogicalProject(a=[$4], b=[$0])
+   :  :  +- LogicalJoin(condition=[=($0, $4)], joinType=[left])
+   :  :     :- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+   :  :     +- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+   :  +- LogicalProject(a=[$1], b=[$0])
+   :     +- LogicalAggregate(group=[{0}], a=[COUNT($1)])
+   :        +- LogicalProject(b=[$1], a=[$0])
+   :           +- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+   +- LogicalProject(a=[$0], b=[$1], c=[$2], a0=[CAST($0):BIGINT])
+      +- LogicalTableScan(table=[[default_catalog, default_database, t]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+Calc(select=[a, b, a0, b0, c])
++- MultipleInputNode(readOrder=[0,1,0,1], members=[\nNestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, a00)], select=[a, b, a0, b0, c, a00], build=[right])\n:- Union(all=[true], union=[a, b])\n:  :- Calc(select=[CAST(a) AS a, CAST(d) AS b])\n:  :  +- NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(d, a)], select=[d, a], build=[right])\n:  :     :- [#2] Calc(select=[d])\n:  :     +- [#3] Exchange(distribution=[broadcast])\n:  +- Calc(select=[CAST(a) AS a, b])\n:     +- HashAggregate(isMerge=[true], groupBy=[b], select=[b, Final_COUNT(count$0) AS a])\n:        +- [#4] Exchange(distribution=[hash[b]])\n+- [#1] Exchange(distribution=[broadcast])\n])
+   :- Exchange(distribution=[broadcast])
+   :  +- Calc(select=[a, b, c, CAST(a) AS a0])
+   :     +- BoundedStreamScan(table=[[default_catalog, default_database, t]], fields=[a, b, c])
+   :- Calc(select=[d])
+   :  +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
+   :- Exchange(distribution=[broadcast])
+   :  +- Calc(select=[a])
+   :     +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]], fields=[a, b, c, nx], reuse_id=[1])
+   +- Exchange(distribution=[hash[b]])
+      +- LocalHashAggregate(groupBy=[b], select=[b, Partial_COUNT(a) AS count$0])
+         +- Calc(select=[b, a])
+            +- Reused(reference_id=[1])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testIncludeUnionForChainableSource[shuffleMode: ALL_EDGES_BLOCKING]">
+    <Resource name="sql">
+      <![CDATA[
+SELECT * FROM
+  (SELECT a FROM (SELECT a FROM chainable) UNION ALL (SELECT a FROM t)) T1
+  LEFT JOIN y ON T1.a = y.d
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], d=[$1], e=[$2], f=[$3], ny=[$4])
++- LogicalJoin(condition=[=($0, $1)], joinType=[left])
+   :- LogicalUnion(all=[true])
+   :  :- LogicalProject(a=[$0])
+   :  :  +- LogicalTableScan(table=[[default_catalog, default_database, chainable]])
+   :  +- LogicalProject(a=[$0])
+   :     +- LogicalTableScan(table=[[default_catalog, default_database, t]])
+   +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+MultipleInputNode(readOrder=[0,1,1], members=[\nNestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, d)], select=[a, d, e, f, ny], build=[right])\n:- Union(all=[true], union=[a])\n:  :- [#2] BoundedStreamScan(table=[[default_catalog, default_database, chainable]], fields=[a])\n:  +- [#3] Calc(select=[a])\n+- [#1] Exchange(distribution=[broadcast])\n])
+:- Exchange(distribution=[broadcast])
+:  +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
+:- BoundedStreamScan(table=[[default_catalog, default_database, chainable]], fields=[a])
++- Calc(select=[a])
+   +- BoundedStreamScan(table=[[default_catalog, default_database, t]], fields=[a, b, c])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testRelatedInputs[shuffleMode: ALL_EDGES_BLOCKING]">
+    <Resource name="sql">
+      <![CDATA[
+WITH
+  T1 AS (SELECT x.a AS a, y.d AS b FROM y LEFT JOIN x ON y.d = x.a),
+  T2 AS (
+    SELECT a, b FROM
+      (SELECT a, b FROM T1)
+      UNION ALL
+      (SELECT x.a AS a, x.b AS b FROM x))
+SELECT * FROM T2 LEFT JOIN t ON T2.a = t.a
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], a0=[$2], b0=[$3], c=[$4])
++- LogicalJoin(condition=[=($0, $2)], joinType=[left])
+   :- LogicalUnion(all=[true])
+   :  :- LogicalProject(a=[$4], b=[$0])
+   :  :  +- LogicalJoin(condition=[=($0, $4)], joinType=[left])
+   :  :     :- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+   :  :     +- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+   :  +- LogicalProject(a=[$0], b=[$1])
+   :     +- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+   +- LogicalTableScan(table=[[default_catalog, default_database, t]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+MultipleInputNode(readOrder=[0,1,2,1], members=[\nNestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, a0)], select=[a, b, a0, b0, c], build=[right])\n:- Union(all=[true], union=[a, b])\n:  :- Calc(select=[a, CAST(d) AS b])\n:  :  +- NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(d, a)], select=[d, a], build=[right])\n:  :     :- [#3] Calc(select=[d])\n:  :     +- [#4] Exchange(distribution=[broadcast])\n:  +- [#2] Calc(select=[a, b])\n+- [#1] Exchange(distribution=[broadcast])\n])
+:- Exchange(distribution=[broadcast])
+:  +- BoundedStreamScan(table=[[default_catalog, default_database, t]], fields=[a, b, c])
+:- Calc(select=[a, b])
+:  +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]], fields=[a, b, c, nx], reuse_id=[1])
+:- Calc(select=[d])
+:  +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
++- Exchange(distribution=[broadcast])
+   +- Calc(select=[a])
+      +- Reused(reference_id=[1])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testNoPriorityConstraint[shuffleMode: ALL_EDGES_PIPELINED]">
+    <Resource name="sql">
+      <![CDATA[
+SELECT * FROM x
+  INNER JOIN y ON x.a = y.d
+  INNER JOIN t ON x.a = t.a
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], c=[$2], nx=[$3], d=[$4], e=[$5], f=[$6], ny=[$7], a0=[$8], b0=[$9], c0=[$10])
++- LogicalJoin(condition=[=($0, $8)], joinType=[inner])
+   :- LogicalJoin(condition=[=($0, $4)], joinType=[inner])
+   :  :- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+   :  +- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+   +- LogicalTableScan(table=[[default_catalog, default_database, t]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+MultipleInputNode(members=[\nSortMergeJoin(joinType=[InnerJoin], where=[=(a, a0)], select=[a, b, c, nx, d, e, f, ny, a0, b0, c0])\n:- SortMergeJoin(joinType=[InnerJoin], where=[=(a, d)], select=[a, b, c, nx, d, e, f, ny])\n:  :- [#2] Exchange(distribution=[hash[a]])\n:  +- [#3] Exchange(distribution=[hash[d]])\n+- [#1] Exchange(distribution=[hash[a]])\n])
+:- Exchange(distribution=[hash[a]])
+:  +- BoundedStreamScan(table=[[default_catalog, default_database, t]], fields=[a, b, c])
+:- Exchange(distribution=[hash[a]])
+:  +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]], fields=[a, b, c, nx])
++- Exchange(distribution=[hash[d]])
+   +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testRelatedInputsWithAgg[shuffleMode: ALL_EDGES_PIPELINED]">
+    <Resource name="sql">
+      <![CDATA[
+WITH
+  T1 AS (SELECT x.a AS a, y.d AS b FROM y LEFT JOIN x ON y.d = x.a),
+  T2 AS (
+    SELECT a, b FROM
+      (SELECT a, b FROM T1)
+      UNION ALL
+      (SELECT COUNT(x.a) AS a, x.b AS b FROM x GROUP BY x.b))
+SELECT * FROM T2 LEFT JOIN t ON T2.a = t.a
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], a0=[$2], b0=[$3], c=[$4])
++- LogicalJoin(condition=[=($0, $5)], joinType=[left])
+   :- LogicalUnion(all=[true])
+   :  :- LogicalProject(a=[$4], b=[$0])
+   :  :  +- LogicalJoin(condition=[=($0, $4)], joinType=[left])
+   :  :     :- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+   :  :     +- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+   :  +- LogicalProject(a=[$1], b=[$0])
+   :     +- LogicalAggregate(group=[{0}], a=[COUNT($1)])
+   :        +- LogicalProject(b=[$1], a=[$0])
+   :           +- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+   +- LogicalProject(a=[$0], b=[$1], c=[$2], a0=[CAST($0):BIGINT])
+      +- LogicalTableScan(table=[[default_catalog, default_database, t]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+Calc(select=[a, b, a0, b0, c])
++- MultipleInputNode(readOrder=[0,2,1,1], members=[\nNestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, a00)], select=[a, b, a0, b0, c, a00], build=[right])\n:- Union(all=[true], union=[a, b])\n:  :- Calc(select=[CAST(a) AS a, CAST(d) AS b])\n:  :  +- NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(d, a)], select=[d, a], build=[right])\n:  :     :- [#2] Calc(select=[d])\n:  :     +- [#3] Exchange(distribution=[broadcast])\n:  +- Calc(select=[CAST(a) AS a, b])\n:     +- HashAggregate(isMerge=[true], groupBy=[b], select=[b, Final_COUNT(count$0) AS a])\n:        +- [#4] Exchange(distribution=[hash[b]])\n+- [#1] Exchange(distribution=[broadcast])\n])
+   :- Exchange(distribution=[broadcast])
+   :  +- Calc(select=[a, b, c, CAST(a) AS a0])
+   :     +- BoundedStreamScan(table=[[default_catalog, default_database, t]], fields=[a, b, c])
+   :- Calc(select=[d])
+   :  +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
+   :- Exchange(distribution=[broadcast])
+   :  +- Calc(select=[a])
+   :     +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]], fields=[a, b, c, nx], reuse_id=[1])
+   +- Exchange(distribution=[hash[b]])
+      +- LocalHashAggregate(groupBy=[b], select=[b, Partial_COUNT(a) AS count$0])
+         +- Calc(select=[b, a])
+            +- Reused(reference_id=[1])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testRelatedInputs[shuffleMode: ALL_EDGES_PIPELINED]">
+    <Resource name="sql">
+      <![CDATA[
+WITH
+  T1 AS (SELECT x.a AS a, y.d AS b FROM y LEFT JOIN x ON y.d = x.a),
+  T2 AS (
+    SELECT a, b FROM
+      (SELECT a, b FROM T1)
+      UNION ALL
+      (SELECT x.a AS a, x.b AS b FROM x))
+SELECT * FROM T2 LEFT JOIN t ON T2.a = t.a
+]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], a0=[$2], b0=[$3], c=[$4])
++- LogicalJoin(condition=[=($0, $2)], joinType=[left])
+   :- LogicalUnion(all=[true])
+   :  :- LogicalProject(a=[$4], b=[$0])
+   :  :  +- LogicalJoin(condition=[=($0, $4)], joinType=[left])
+   :  :     :- LogicalTableScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]])
+   :  :     +- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+   :  +- LogicalProject(a=[$0], b=[$1])
+   :     +- LogicalTableScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]])
+   +- LogicalTableScan(table=[[default_catalog, default_database, t]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+MultipleInputNode(readOrder=[0,1,2,1], members=[\nNestedLoopJoin(joinType=[LeftOuterJoin], where=[=(a, a0)], select=[a, b, a0, b0, c], build=[right])\n:- Union(all=[true], union=[a, b])\n:  :- Calc(select=[a, CAST(d) AS b])\n:  :  +- NestedLoopJoin(joinType=[LeftOuterJoin], where=[=(d, a)], select=[d, a], build=[right])\n:  :     :- [#3] Calc(select=[d])\n:  :     +- [#4] Exchange(distribution=[broadcast])\n:  +- [#2] Calc(select=[a, b])\n+- [#1] Exchange(distribution=[broadcast])\n])
+:- Exchange(distribution=[broadcast])
+:  +- BoundedStreamScan(table=[[default_catalog, default_database, t]], fields=[a, b, c])
+:- Calc(select=[a, b])
+:  +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c, nx)]]], fields=[a, b, c, nx], reuse_id=[1])
+:- Calc(select=[d])
+:  +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f, ny)]]], fields=[d, e, f, ny])
++- Exchange(distribution=[broadcast])
+   +- Calc(select=[a])
+      +- Reused(reference_id=[1])
 ]]>
     </Resource>
   </TestCase>
diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/batch/sql/MultipleInputCreationTest.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/batch/sql/MultipleInputCreationTest.scala
index 789bb0218e2..e24c00db4dd 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/batch/sql/MultipleInputCreationTest.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/batch/sql/MultipleInputCreationTest.scala
@@ -28,9 +28,13 @@ import org.apache.flink.table.api._
 import org.apache.flink.table.api.config.{ExecutionConfigOptions, OptimizerConfigOptions}
 import org.apache.flink.table.planner.utils.{TableTestBase, TableTestUtil}
 
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+import org.junit.runners.Parameterized.Parameters
 import org.junit.{Before, Test}
 
-class MultipleInputCreationTest extends TableTestBase {
+@RunWith(classOf[Parameterized])
+class MultipleInputCreationTest(shuffleMode: String) extends TableTestBase {
 
   private val util = batchTestUtil()
 
@@ -40,6 +44,8 @@ class MultipleInputCreationTest extends TableTestBase {
     util.addTableSource[(Int, Long, String, Int)]("y", 'd, 'e, 'f, 'ny)
     util.addTableSource[(Int, Long, String, Int)]("z", 'g, 'h, 'i, 'nz)
     util.addDataStream[(Int, Long, String)]("t", 'a, 'b, 'c)
+    util.tableConfig.getConfiguration.setString(
+      ExecutionConfigOptions.TABLE_EXEC_SHUFFLE_MODE, shuffleMode)
     util.tableConfig.getConfiguration.setBoolean(
       OptimizerConfigOptions.TABLE_OPTIMIZER_MULTIPLE_INPUT_ENABLED, true)
   }
@@ -193,6 +199,55 @@ class MultipleInputCreationTest extends TableTestBase {
     util.verifyPlan(sql)
   }
 
+  @Test
+  def testNoPriorityConstraint(): Unit = {
+    util.tableEnv.getConfig.getConfiguration.setString(
+      ExecutionConfigOptions.TABLE_EXEC_DISABLED_OPERATORS, "HashJoin,NestedLoopJoin")
+    val sql =
+      """
+        |SELECT * FROM x
+        |  INNER JOIN y ON x.a = y.d
+        |  INNER JOIN t ON x.a = t.a
+        |""".stripMargin
+    util.verifyPlan(sql)
+  }
+
+  @Test
+  def testRelatedInputs(): Unit = {
+    util.tableEnv.getConfig.getConfiguration.setString(
+      ExecutionConfigOptions.TABLE_EXEC_DISABLED_OPERATORS, "HashJoin,SortMergeJoin")
+    val sql =
+      """
+        |WITH
+        |  T1 AS (SELECT x.a AS a, y.d AS b FROM y LEFT JOIN x ON y.d = x.a),
+        |  T2 AS (
+        |    SELECT a, b FROM
+        |      (SELECT a, b FROM T1)
+        |      UNION ALL
+        |      (SELECT x.a AS a, x.b AS b FROM x))
+        |SELECT * FROM T2 LEFT JOIN t ON T2.a = t.a
+        |""".stripMargin
+    util.verifyPlan(sql)
+  }
+
+  @Test
+  def testRelatedInputsWithAgg(): Unit = {
+    util.tableEnv.getConfig.getConfiguration.setString(
+      ExecutionConfigOptions.TABLE_EXEC_DISABLED_OPERATORS, "HashJoin,SortMergeJoin,SortAgg")
+    val sql =
+      """
+        |WITH
+        |  T1 AS (SELECT x.a AS a, y.d AS b FROM y LEFT JOIN x ON y.d = x.a),
+        |  T2 AS (
+        |    SELECT a, b FROM
+        |      (SELECT a, b FROM T1)
+        |      UNION ALL
+        |      (SELECT COUNT(x.a) AS a, x.b AS b FROM x GROUP BY x.b))
+        |SELECT * FROM T2 LEFT JOIN t ON T2.a = t.a
+        |""".stripMargin
+    util.verifyPlan(sql)
+  }
+
   def createChainableTableSource(): Unit = {
     val env = new StreamExecutionEnvironment(new LocalStreamEnvironment())
     val dataStream = env.fromSource(
@@ -203,3 +258,9 @@ class MultipleInputCreationTest extends TableTestBase {
     TableTestUtil.createTemporaryView[Integer](tableEnv, "chainable", dataStream, Some(Array('a)))
   }
 }
+
+object MultipleInputCreationTest {
+
+  @Parameters(name = "shuffleMode: {0}")
+  def parameters: Array[String] = Array("ALL_EDGES_BLOCKING", "ALL_EDGES_PIPELINED")
+}
