diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/flip1/RestartPipelinedRegionFailoverStrategy.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/flip1/RestartPipelinedRegionFailoverStrategy.java
index 39d7fe72547..08ab5b2ba66 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/flip1/RestartPipelinedRegionFailoverStrategy.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/flip1/RestartPipelinedRegionFailoverStrategy.java
@@ -20,6 +20,7 @@ package org.apache.flink.runtime.executiongraph.failover.flip1;
 import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.runtime.execution.ExecutionState;
 import org.apache.flink.runtime.io.network.partition.PartitionException;
+import org.apache.flink.runtime.io.network.partition.ResultPartitionType;
 import org.apache.flink.runtime.jobgraph.IntermediateResultPartitionID;
 import org.apache.flink.runtime.scheduler.strategy.ConsumedPartitionGroup;
 import org.apache.flink.runtime.scheduler.strategy.ConsumerVertexGroup;
@@ -83,7 +84,10 @@ public class RestartPipelinedRegionFailoverStrategy implements FailoverStrategy
         this.topology = checkNotNull(topology);
         this.resultPartitionAvailabilityChecker =
                 new RegionFailoverResultPartitionAvailabilityChecker(
-                        resultPartitionAvailabilityChecker);
+                        resultPartitionAvailabilityChecker,
+                        (intermediateResultPartitionID ->
+                                topology.getResultPartition(intermediateResultPartitionID)
+                                        .getResultType()));
     }
 
     // ------------------------------------------------------------------------
@@ -270,16 +274,27 @@ public class RestartPipelinedRegionFailoverStrategy implements FailoverStrategy
         /** Records partitions which has caused {@link PartitionException}. */
         private final HashSet<IntermediateResultPartitionID> failedPartitions;
 
+        /** Retrieve {@link ResultPartitionType} by {@link IntermediateResultPartitionID}. */
+        private final Function<IntermediateResultPartitionID, ResultPartitionType>
+                resultPartitionTypeRetriever;
+
         RegionFailoverResultPartitionAvailabilityChecker(
-                ResultPartitionAvailabilityChecker checker) {
+                ResultPartitionAvailabilityChecker checker,
+                Function<IntermediateResultPartitionID, ResultPartitionType>
+                        resultPartitionTypeRetriever) {
             this.resultPartitionAvailabilityChecker = checkNotNull(checker);
             this.failedPartitions = new HashSet<>();
+            this.resultPartitionTypeRetriever = checkNotNull(resultPartitionTypeRetriever);
         }
 
         @Override
         public boolean isAvailable(IntermediateResultPartitionID resultPartitionID) {
             return !failedPartitions.contains(resultPartitionID)
-                    && resultPartitionAvailabilityChecker.isAvailable(resultPartitionID);
+                    && resultPartitionAvailabilityChecker.isAvailable(resultPartitionID)
+                    // If the result partition is available in the partition tracker and does not
+                    // fail, it will be available if it can be re-consumption, and it may also be
+                    // available for PIPELINED_APPROXIMATE type.
+                    && isResultPartitionIsReConsumableOrPipelinedApproximate(resultPartitionID);
         }
 
         public void markResultPartitionFailed(IntermediateResultPartitionID resultPartitionID) {
@@ -290,6 +305,14 @@ public class RestartPipelinedRegionFailoverStrategy implements FailoverStrategy
                 IntermediateResultPartitionID resultPartitionID) {
             failedPartitions.remove(resultPartitionID);
         }
+
+        private boolean isResultPartitionIsReConsumableOrPipelinedApproximate(
+                IntermediateResultPartitionID resultPartitionID) {
+            ResultPartitionType resultPartitionType =
+                    resultPartitionTypeRetriever.apply(resultPartitionID);
+            return resultPartitionType.isReconsumable()
+                    || resultPartitionType == ResultPartitionType.PIPELINED_APPROXIMATE;
+        }
     }
 
     /** The factory to instantiate {@link RestartPipelinedRegionFailoverStrategy}. */
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/failover/flip1/RestartPipelinedRegionFailoverStrategyTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/failover/flip1/RestartPipelinedRegionFailoverStrategyTest.java
index d237016d6e9..da3014b1359 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/failover/flip1/RestartPipelinedRegionFailoverStrategyTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/failover/flip1/RestartPipelinedRegionFailoverStrategyTest.java
@@ -23,6 +23,7 @@ import org.apache.flink.runtime.io.network.partition.ResultPartitionID;
 import org.apache.flink.runtime.io.network.partition.ResultPartitionType;
 import org.apache.flink.runtime.io.network.partition.consumer.PartitionConnectionException;
 import org.apache.flink.runtime.jobgraph.IntermediateResultPartitionID;
+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;
 import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;
 import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;
 import org.apache.flink.runtime.scheduler.strategy.TestingSchedulingExecutionVertex;
@@ -33,6 +34,7 @@ import org.junit.jupiter.api.Test;
 
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.Set;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -331,6 +333,54 @@ class RestartPipelinedRegionFailoverStrategyTest {
         verifyThatFailedExecution(strategy, v4).restarts(v4);
     }
 
+    /**
+     * Tests to verify region failover results of PIPELINED/BLOCKING/HYBRID_FULL/HYBRID_SELECTIVE
+     * type.
+     *
+     * <pre>
+     *
+     *     (v1)  -**- \
+     *                 \
+     *     (v2)  -//-  (v5) -**-(v6)
+     *                 / /
+     *     (v3) -##- / /
+     *               /
+     *     (v4)----/
+     *
+     *
+     *    ----: pipelined        edge
+     *    -**-: hybrid_full      edge
+     *    -##-: hybrid_selective edge
+     *    -//-: blocking         edge
+     *
+     * </pre>
+     *
+     * Except that v4 and v5 belong to the same region, each vertex is in an individual region.
+     */
+    @Test
+    void testRegionFailoverForHybridEdge() {
+        final TestingSchedulingTopology topology = new TestingSchedulingTopology();
+
+        TestingSchedulingExecutionVertex v1 = topology.newExecutionVertex(ExecutionState.FINISHED);
+        TestingSchedulingExecutionVertex v2 = topology.newExecutionVertex(ExecutionState.FINISHED);
+        TestingSchedulingExecutionVertex v3 = topology.newExecutionVertex(ExecutionState.FINISHED);
+        TestingSchedulingExecutionVertex v4 = topology.newExecutionVertex(ExecutionState.RUNNING);
+        TestingSchedulingExecutionVertex v5 = topology.newExecutionVertex(ExecutionState.FINISHED);
+        TestingSchedulingExecutionVertex v6 = topology.newExecutionVertex(ExecutionState.RUNNING);
+
+        topology.connect(v1, v5, ResultPartitionType.HYBRID_FULL);
+        topology.connect(v2, v5, ResultPartitionType.BLOCKING);
+        topology.connect(v3, v5, ResultPartitionType.HYBRID_SELECTIVE);
+        topology.connect(v4, v5, ResultPartitionType.PIPELINED);
+        topology.connect(v5, v6, ResultPartitionType.HYBRID_FULL);
+
+        RestartPipelinedRegionFailoverStrategy strategy =
+                new RestartPipelinedRegionFailoverStrategy(topology);
+
+        verifyThatFailedExecution(strategy, v5).restarts(v3, v4, v5, v6);
+        verifyThatFailedExecution(strategy, v6).restarts(v6);
+    }
+
     private static VerificationContext verifyThatFailedExecution(
             FailoverStrategy strategy, SchedulingExecutionVertex executionVertex) {
         return new VerificationContext(strategy, executionVertex);
@@ -364,7 +414,9 @@ class RestartPipelinedRegionFailoverStrategyTest {
         }
 
         private void restarts(SchedulingExecutionVertex... expectedResult) {
-            assertThat(strategy.getTasksNeedingRestart(executionVertex.getId(), cause))
+            Set<ExecutionVertexID> tasksNeedingRestart =
+                    strategy.getTasksNeedingRestart(executionVertex.getId(), cause);
+            assertThat(tasksNeedingRestart)
                     .containsExactlyInAnyOrderElementsOf(
                             Stream.of(expectedResult)
                                     .map(SchedulingExecutionVertex::getId)
