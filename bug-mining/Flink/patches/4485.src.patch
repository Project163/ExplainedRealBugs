diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/codegen/CalcCodeGenerator.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/codegen/CalcCodeGenerator.scala
index 87ec9b77ad8..9406de403a5 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/codegen/CalcCodeGenerator.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/codegen/CalcCodeGenerator.scala
@@ -25,7 +25,7 @@ import org.apache.flink.table.runtime.generated.GeneratedFunction
 import org.apache.flink.table.runtime.operators.CodeGenOperatorFactory
 import org.apache.flink.table.runtime.typeutils.InternalTypeInfo
 import org.apache.flink.table.types.logical.RowType
-import org.apache.calcite.plan.RelOptCluster
+
 import org.apache.calcite.rex._
 
 import scala.collection.JavaConversions._
@@ -34,10 +34,8 @@ object CalcCodeGenerator {
 
   private[flink] def generateCalcOperator(
       ctx: CodeGeneratorContext,
-      cluster: RelOptCluster,
       inputTransform: Transformation[RowData],
       outputType: RowType,
-      config: TableConfig,
       calcProgram: RexProgram,
       condition: Option[RexNode],
       retainHeader: Boolean = false,
@@ -52,8 +50,6 @@ object CalcCodeGenerator {
       inputType,
       outputType,
       classOf[BoxedWrapperRowData],
-      outputType.getFieldNames,
-      config,
       calcProgram,
       condition,
       eagerInputUnboxingCode = true,
@@ -88,8 +84,6 @@ object CalcCodeGenerator {
       inputType,
       returnType,
       outRowClass,
-      returnType.getFieldNames,
-      config,
       calcProjection,
       calcCondition,
       collectorTerm = collectorTerm,
@@ -113,8 +107,6 @@ object CalcCodeGenerator {
       inputType: RowType,
       outRowType: RowType,
       outRowClass: Class[_ <: RowData],
-      resultFieldNames: Seq[String],
-      config: TableConfig,
       calcProgram: RexProgram,
       condition: Option[RexNode],
       inputTerm: String = CodeGenUtils.DEFAULT_INPUT1_TERM,
@@ -140,23 +132,12 @@ object CalcCodeGenerator {
     }
 
     def produceProjectionCode = {
-      // we cannot use for-loop optimization if projection contains other calculations
-      // (for example "select id + 1 from T")
-      val simpleProjection = projection.forall { rexNode => rexNode.isInstanceOf[RexInputRef] }
-
-      val projectionExpression = if (simpleProjection) {
-        val inputMapping = projection.map(_.asInstanceOf[RexInputRef].getIndex).toArray
-        ProjectionCodeGenerator.generateProjectionExpression(
-          ctx, inputType, outRowType, inputMapping,
-          outRowClass, inputTerm, nullCheck = config.getNullCheck)
-      } else {
-        val projectionExprs = projection.map(exprGenerator.generateExpression)
-        exprGenerator.generateResultExpression(
-          projectionExprs,
-          outRowType,
-          outRowClass,
-          allowSplit = allowSplit)
-      }
+      val projectionExprs = projection.map(exprGenerator.generateExpression)
+      val projectionExpression = exprGenerator.generateResultExpression(
+        projectionExprs,
+        outRowType,
+        outRowClass,
+        allowSplit = allowSplit)
 
       val projectionExpressionCode = projectionExpression.code
 
diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/codegen/ProjectionCodeGenerator.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/codegen/ProjectionCodeGenerator.scala
index eceb0c9db36..bc5726b8f61 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/codegen/ProjectionCodeGenerator.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/codegen/ProjectionCodeGenerator.scala
@@ -24,9 +24,7 @@ import org.apache.flink.table.planner.codegen.CodeGenUtils._
 import org.apache.flink.table.planner.codegen.GenerateUtils.generateRecordStatement
 import org.apache.flink.table.planner.codegen.GeneratedExpression.{NEVER_NULL, NO_CODE}
 import org.apache.flink.table.runtime.generated.{GeneratedProjection, Projection}
-import org.apache.flink.table.types.logical.{LogicalType, RowType}
-
-import scala.collection.mutable
+import org.apache.flink.table.types.logical.RowType
 
 /**
   * CodeGenerator for projection, Take out some fields of [[RowData]] to generate
@@ -34,13 +32,6 @@ import scala.collection.mutable
   */
 object ProjectionCodeGenerator {
 
-  // for loop optimization will only be enabled
-  // if the number of fields to be project exceeds the limit
-  //
-  // this value is tuned by hand according to projecting
-  // some string type fields with randomized order
-  val FOR_LOOP_FIELD_LIMIT: Int = 25
-
   def generateProjectionExpression(
       ctx: CodeGeneratorContext,
       inType: RowType,
@@ -50,77 +41,18 @@ object ProjectionCodeGenerator {
       inputTerm: String = DEFAULT_INPUT1_TERM,
       outRecordTerm: String = DEFAULT_OUT_RECORD_TERM,
       outRecordWriterTerm: String = DEFAULT_OUT_RECORD_WRITER_TERM,
-      reusedOutRecord: Boolean = true,
-      nullCheck: Boolean = true): GeneratedExpression = {
-
-    // we use a for loop to do all the projections for the same field type
-    // instead of generating separated code for each field.
-    // when the number of fields of the same type is large, this can improve performance.
-    def generateLoop(
-        fieldType: LogicalType,
-        inIdxs: mutable.ArrayBuffer[Int],
-        outIdxs: mutable.ArrayBuffer[Int]): String = {
-      // this array contains the indices of the fields
-      // whose type equals to `fieldType` in the input row
-      val inIdxArr = newName("inIdx")
-      ctx.addReusableMember(s"int[] $inIdxArr = null;")
-      ctx.addReusableInitStatement(s"$inIdxArr = new int[] {${inIdxs.mkString(", ")}};")
-
-      // this array contains the indices of the fields
-      // whose type equals to `fieldType` in the output row
-      val outIdxArr = newName("outIdx")
-      ctx.addReusableMember(s"int[] $outIdxArr = null;")
-      ctx.addReusableInitStatement(s"$outIdxArr = new int[] {${outIdxs.mkString(", ")}};")
-
-      val loopIdx = newName("i")
-
-      val fieldVal = CodeGenUtils.rowFieldReadAccess(
-        ctx, s"$inIdxArr[$loopIdx]", inputTerm, fieldType)
-
-      val inIdx = s"$inIdxArr[$loopIdx]"
-      val outIdx = s"$outIdxArr[$loopIdx]"
-      val nullTerm = s"$inputTerm.isNullAt($inIdx)"
-      s"""
-         |for (int $loopIdx = 0; $loopIdx < $inIdxArr.length; $loopIdx++) {
-         |  ${CodeGenUtils.rowSetField(ctx, outClass, outRecordTerm, outIdx,
-                GeneratedExpression(fieldVal, nullTerm, "", fieldType),
-                Some(outRecordWriterTerm))}
-         |}
-       """.stripMargin
-    }
-
-    val outFieldTypes = outType.getChildren
-    val typeIdxs = new mutable.HashMap[
-      LogicalType,
-      (mutable.ArrayBuffer[Int], mutable.ArrayBuffer[Int])]()
-
-    for (i <- 0 until outFieldTypes.size()) {
-      val (inIdxs, outIdxs) = typeIdxs.getOrElseUpdate(
-        outFieldTypes.get(i), (mutable.ArrayBuffer.empty[Int], mutable.ArrayBuffer.empty[Int]))
-      inIdxs.append(inputMapping(i))
-      outIdxs.append(i)
-    }
-
-    val codeBuffer = mutable.ArrayBuffer.empty[String]
-    for ((fieldType, (inIdxs, outIdxs)) <- typeIdxs) {
-      if (inIdxs.length >= FOR_LOOP_FIELD_LIMIT) {
-        // for loop optimization will only be enabled
-        // if the number of fields to be project exceeds the limit
-        codeBuffer.append(generateLoop(fieldType, inIdxs, outIdxs))
-      } else {
-        // otherwise we do not use for loop
-        for (i <- inIdxs.indices) {
-          val nullTerm = s"$inputTerm.isNullAt(${inIdxs(i)})"
-          codeBuffer.append(
-            CodeGenUtils.rowSetField(ctx, outClass, outRecordTerm, outIdxs(i).toString,
-              GeneratedExpression(rowFieldReadAccess(
-                ctx, inIdxs(i), inputTerm, fieldType), nullTerm, "", fieldType),
-              Some(outRecordWriterTerm)))
-        }
-      }
-    }
-
-    val setFieldsCode = codeBuffer.mkString("\n")
+      reusedOutRecord: Boolean = true): GeneratedExpression = {
+    val exprGenerator = new ExprCodeGenerator(ctx, false)
+      .bindInput(inType, inputTerm = inputTerm, inputFieldMapping = Option(inputMapping))
+    val accessExprs = inputMapping.map(
+      idx => GenerateUtils.generateFieldAccess(ctx, inType, inputTerm, idx))
+    val expression = exprGenerator.generateResultExpression(
+      accessExprs,
+      outType,
+      outClass,
+      outRow = outRecordTerm,
+      outRowWriter = Option(outRecordWriterTerm),
+      reusedOutRow = reusedOutRecord)
 
     val outRowInitCode = {
       val initCode = generateRecordStatement(
@@ -132,22 +64,11 @@ object ProjectionCodeGenerator {
       }
     }
 
-    val code = if (outClass == classOf[BinaryRowData]) {
-      val writer = outRecordWriterTerm
-      val resetWriter = if (ctx.nullCheck) s"$writer.reset();" else s"$writer.resetCursor();"
-      val completeWriter: String = s"$writer.complete();"
-      s"""
-         |$outRowInitCode
-         |$resetWriter
-         |$setFieldsCode
-         |$completeWriter
-        """.stripMargin
-    } else {
+    val code =
       s"""
          |$outRowInitCode
-         |$setFieldsCode
+         |${expression.code}
         """.stripMargin
-    }
     GeneratedExpression(outRecordTerm, NEVER_NULL, code, outType)
   }
 
@@ -168,14 +89,13 @@ object ProjectionCodeGenerator {
       inputTerm: String = DEFAULT_INPUT1_TERM,
       outRecordTerm: String = DEFAULT_OUT_RECORD_TERM,
       outRecordWriterTerm: String = DEFAULT_OUT_RECORD_WRITER_TERM,
-      reusedOutRecord: Boolean = true,
-      nullCheck: Boolean = true): GeneratedProjection = {
+      reusedOutRecord: Boolean = true): GeneratedProjection = {
     val className = newName(name)
     val baseClass = classOf[Projection[_, _]]
 
     val expression = generateProjectionExpression(
       ctx, inType, outType, inputMapping, outClass,
-      inputTerm, outRecordTerm, outRecordWriterTerm, reusedOutRecord, nullCheck)
+      inputTerm, outRecordTerm, outRecordWriterTerm, reusedOutRecord)
 
     val code =
       s"""
diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/batch/BatchExecCalc.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/batch/BatchExecCalc.scala
index 06267cf83b6..761cc0c1cd0 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/batch/BatchExecCalc.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/batch/BatchExecCalc.scala
@@ -61,10 +61,8 @@ class BatchExecCalc(
     val ctx = CodeGeneratorContext(config)
     val operator = CalcCodeGenerator.generateCalcOperator(
       ctx,
-      cluster,
       inputTransform,
       outputType,
-      config,
       calcProgram,
       condition,
       opName = "BatchCalc"
diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecCalc.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecCalc.scala
index 3aacfc353e8..730b19922b8 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecCalc.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/physical/stream/StreamExecCalc.scala
@@ -76,10 +76,8 @@ class StreamExecCalc(
     val outputType = FlinkTypeFactory.toLogicalRowType(getRowType)
     val substituteStreamOperator = CalcCodeGenerator.generateCalcOperator(
       ctx,
-      cluster,
       inputTransform,
       outputType,
-      config,
       calcProgram,
       condition,
       retainHeader = true,
diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/codegen/ProjectionCodeGeneratorTest.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/codegen/ProjectionCodeGeneratorTest.scala
index 41d0791dc09..8311bde52e3 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/codegen/ProjectionCodeGeneratorTest.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/codegen/ProjectionCodeGeneratorTest.scala
@@ -20,9 +20,11 @@ package org.apache.flink.table.planner.codegen
 
 import org.apache.flink.table.api.TableConfig
 import org.apache.flink.table.data.binary.BinaryRowData
-import org.apache.flink.table.data.{GenericRowData, RowData}
+import org.apache.flink.table.data.writer.BinaryRowWriter
+import org.apache.flink.table.data.{DecimalData, GenericRowData, RowData, TimestampData}
 import org.apache.flink.table.runtime.generated.Projection
-import org.apache.flink.table.types.logical.{BigIntType, IntType, RowType}
+import org.apache.flink.table.types.logical.{BigIntType, DecimalType, IntType, RowType, TimestampType}
+
 import org.junit.{Assert, Test}
 
 import scala.util.Random
@@ -100,6 +102,36 @@ class ProjectionCodeGeneratorTest {
     }
   }
 
+  @Test
+  def testProjectionBinaryRowWithVariableLengthData(): Unit = {
+    val projection = ProjectionCodeGenerator.generateProjection(
+      new CodeGeneratorContext(new TableConfig),
+      "name",
+      RowType.of(
+        new DecimalType(38, 0),
+        new DecimalType(38, 0),
+        new TimestampType(9)),
+      RowType.of(
+        new DecimalType(38, 0),
+        new TimestampType(9),
+        new DecimalType(38, 0)),
+      Array(1, 2, 0)
+    ).newInstance(classLoader).asInstanceOf[Projection[RowData, BinaryRowData]]
+
+    val decimal = DecimalData.fromBigDecimal(java.math.BigDecimal.valueOf(123), 38, 0)
+    val timestamp = TimestampData.fromEpochMillis(123)
+
+    val expected: BinaryRowData = new BinaryRowData(3)
+    val writer: BinaryRowWriter = new BinaryRowWriter(expected)
+    writer.writeDecimal(0, decimal, 38)
+    writer.writeTimestamp(1, timestamp, 9)
+    writer.writeDecimal(2, decimal, 38)
+    writer.complete()
+
+    val actual: BinaryRowData = projection.apply(GenericRowData.of(decimal, decimal, timestamp))
+    Assert.assertEquals(expected, actual)
+  }
+
   def ji(i: Int): Integer = {
     new Integer(i)
   }
