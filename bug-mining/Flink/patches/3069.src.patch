diff --git a/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/TableEnvironmentImpl.java b/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/TableEnvironmentImpl.java
index 4817dcb6e6e..34685c0b7ce 100644
--- a/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/TableEnvironmentImpl.java
+++ b/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/TableEnvironmentImpl.java
@@ -82,8 +82,8 @@ public class TableEnvironmentImpl implements TableEnvironment {
 
 	private final CatalogManager catalogManager;
 
-	private final String defaultCatalogName;
-	private final String defaultDatabaseName;
+	private final String builtinCatalogName;
+	private final String builtinDatabaseName;
 	private final OperationTreeBuilder operationTreeBuilder;
 	private final List<ModifyOperation> bufferedModifyOperations = new ArrayList<>();
 
@@ -103,8 +103,10 @@ public class TableEnvironmentImpl implements TableEnvironment {
 		this.execEnv = executor;
 
 		this.tableConfig = tableConfig;
-		this.defaultCatalogName = catalogManager.getCurrentCatalog();
-		this.defaultDatabaseName = catalogManager.getCurrentDatabase();
+		// The current catalog and database are definitely builtin,
+		// see #create(EnvironmentSettings)
+		this.builtinCatalogName = catalogManager.getCurrentCatalog();
+		this.builtinDatabaseName = catalogManager.getCurrentDatabase();
 
 		this.functionCatalog = functionCatalog;
 		this.planner = planner;
@@ -191,7 +193,7 @@ public class TableEnvironmentImpl implements TableEnvironment {
 		}
 
 		CatalogBaseTable tableTable = new QueryOperationCatalogView(table.getQueryOperation());
-		registerTableInternal(new String[] { name }, tableTable, false);
+		registerTableInternal(name, tableTable);
 	}
 
 	@Override
@@ -300,7 +302,7 @@ public class TableEnvironmentImpl implements TableEnvironment {
 		Operation operation = operations.get(0);
 		if (operation instanceof CreateTableOperation) {
 			CreateTableOperation createTableOperation = (CreateTableOperation) operation;
-			registerTableInternal(
+			registerCatalogTableInternal(
 				createTableOperation.getTablePath(),
 				createTableOperation.getCatalogTable(),
 				createTableOperation.isIgnoreIfExists());
@@ -470,7 +472,7 @@ public class TableEnvironmentImpl implements TableEnvironment {
 	 * @param ignoreIfExists If true, do nothing if there is already same table name under
 	 *                       the {@code path}. If false, a TableAlreadyExistException throws.
 	 */
-	private void registerTableInternal(String[] path,
+	private void registerCatalogTableInternal(String[] path,
 			CatalogBaseTable catalogTable,
 			boolean ignoreIfExists) {
 		String[] fullName = catalogManager.getFullTablePath(Arrays.asList(path));
@@ -484,10 +486,26 @@ public class TableEnvironmentImpl implements TableEnvironment {
 		}
 	}
 
+	protected void registerTableInternal(String name, CatalogBaseTable table) {
+		try {
+			checkValidTableName(name);
+			ObjectPath path = new ObjectPath(builtinDatabaseName, name);
+			Optional<Catalog> catalog = catalogManager.getCatalog(builtinCatalogName);
+			if (catalog.isPresent()) {
+				catalog.get().createTable(
+					path,
+					table,
+					false);
+			}
+		} catch (Exception e) {
+			throw new TableException("Could not register table", e);
+		}
+	}
+
 	private void replaceTableInternal(String name, CatalogBaseTable table) {
 		try {
-			ObjectPath path = new ObjectPath(defaultDatabaseName, name);
-			Optional<Catalog> catalog = catalogManager.getCatalog(defaultCatalogName);
+			ObjectPath path = new ObjectPath(builtinDatabaseName, name);
+			Optional<Catalog> catalog = catalogManager.getCatalog(builtinCatalogName);
 			if (catalog.isPresent()) {
 				catalog.get().alterTable(
 					path,
@@ -507,7 +525,7 @@ public class TableEnvironmentImpl implements TableEnvironment {
 
 	private void registerTableSourceInternal(String name, TableSource<?> tableSource) {
 		validateTableSource(tableSource);
-		Optional<CatalogBaseTable> table = getCatalogTable(defaultCatalogName, defaultDatabaseName, name);
+		Optional<CatalogBaseTable> table = getCatalogTable(builtinCatalogName, builtinDatabaseName, name);
 
 		if (table.isPresent()) {
 			if (table.get() instanceof ConnectorCatalogTable<?, ?>) {
@@ -527,13 +545,12 @@ public class TableEnvironmentImpl implements TableEnvironment {
 					"Table '%s' already exists. Please choose a different name.", name));
 			}
 		} else {
-			registerTableInternal(new String[] { name },
-				ConnectorCatalogTable.source(tableSource, false), false);
+			registerTableInternal(name, ConnectorCatalogTable.source(tableSource, false));
 		}
 	}
 
 	private void registerTableSinkInternal(String name, TableSink<?> tableSink) {
-		Optional<CatalogBaseTable> table = getCatalogTable(defaultCatalogName, defaultDatabaseName, name);
+		Optional<CatalogBaseTable> table = getCatalogTable(builtinCatalogName, builtinDatabaseName, name);
 
 		if (table.isPresent()) {
 			if (table.get() instanceof ConnectorCatalogTable<?, ?>) {
@@ -553,8 +570,7 @@ public class TableEnvironmentImpl implements TableEnvironment {
 					"Table '%s' already exists. Please choose a different name.", name));
 			}
 		} else {
-			registerTableInternal(new String[] { name },
-				ConnectorCatalogTable.sink(tableSink, false), false);
+			registerTableInternal(name, ConnectorCatalogTable.sink(tableSink, false));
 		}
 	}
 
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/api/internal/TableEnvImpl.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/api/internal/TableEnvImpl.scala
index 36e30cb06fd..3507c81ab42 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/api/internal/TableEnvImpl.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/api/internal/TableEnvImpl.scala
@@ -58,13 +58,14 @@ abstract class TableEnvImpl(
     private val catalogManager: CatalogManager)
   extends TableEnvironment {
 
-  protected val defaultCatalogName: String = catalogManager.getCurrentCatalog
-  protected val defaultDatabaseName: String = catalogManager.getCurrentDatabase
+  // The current catalog and database are definitely builtin.
+  protected val builtinCatalogName: String = catalogManager.getCurrentCatalog
+  protected val builtinDatabaseName: String = catalogManager.getCurrentDatabase
 
   // Table API/SQL function catalog
   private[flink] val functionCatalog: FunctionCatalog = new FunctionCatalog(
-    defaultCatalogName,
-    defaultDatabaseName)
+    builtinCatalogName,
+    builtinDatabaseName)
 
   // temporary bridge between API and planner
   private[flink] val expressionBridge: ExpressionBridge[PlannerExpression] =
@@ -192,7 +193,7 @@ abstract class TableEnvImpl(
     }
 
     val tableTable = new QueryOperationCatalogView(table.getQueryOperation)
-    registerTableInternal(Array[String](name), tableTable, ignoreIfExists = false)
+    registerTableInternal(name, tableTable)
   }
 
   override def registerTableSource(name: String, tableSource: TableSource[_]): Unit = {
@@ -260,7 +261,7 @@ abstract class TableEnvImpl(
     tableSource: TableSource[_])
   : Unit = {
     // register
-    getCatalogTable(defaultCatalogName, defaultDatabaseName, name) match {
+    getCatalogTable(builtinCatalogName, builtinDatabaseName, name) match {
 
       // check if a table (source or sink) is registered
       case Some(table: ConnectorCatalogTable[_, _]) =>
@@ -278,8 +279,7 @@ abstract class TableEnvImpl(
 
       // no table is registered
       case _ =>
-        registerTableInternal(Array[String](name),
-          ConnectorCatalogTable.source(tableSource, isBatch), ignoreIfExists = false)
+        registerTableInternal(name, ConnectorCatalogTable.source(tableSource, isBatch))
     }
   }
 
@@ -288,7 +288,7 @@ abstract class TableEnvImpl(
     tableSink: TableSink[_])
   : Unit = {
     // check if a table (source or sink) is registered
-    getCatalogTable(defaultCatalogName, defaultDatabaseName, name) match {
+    getCatalogTable(builtinCatalogName, builtinDatabaseName, name) match {
 
       // table source and/or sink is registered
       case Some(table: ConnectorCatalogTable[_, _]) =>
@@ -306,8 +306,7 @@ abstract class TableEnvImpl(
 
       // no table is registered
       case _ =>
-        registerTableInternal(Array[String](name),
-          ConnectorCatalogTable.sink(tableSink, isBatch), ignoreIfExists = false)
+        registerTableInternal(name, ConnectorCatalogTable.sink(tableSink, isBatch))
     }
   }
 
@@ -333,7 +332,7 @@ abstract class TableEnvImpl(
     * @param ignoreIfExists If true, do nothing if there is already same table name under
     *                       the { @code path}. If false, a TableAlreadyExistException throws.
     */
-  private def registerTableInternal(
+  private def registerCatalogTableInternal(
       path: Array[String],
       catalogTable: CatalogBaseTable,
       ignoreIfExists: Boolean): Unit = {
@@ -346,10 +345,23 @@ abstract class TableEnvImpl(
     catalog.createTable(objectPath, catalogTable, ignoreIfExists)
   }
 
+  protected def registerTableInternal(name: String, table: CatalogBaseTable): Unit = {
+    checkValidTableName(name)
+    val path = new ObjectPath(builtinDatabaseName, name)
+    JavaScalaConversionUtil.toScala(catalogManager.getCatalog(builtinCatalogName)) match {
+      case Some(catalog) =>
+        catalog.createTable(
+          path,
+          table,
+          false)
+      case None => throw new TableException("The default catalog does not exist.")
+    }
+  }
+
   protected def replaceTableInternal(name: String, table: CatalogBaseTable): Unit = {
     checkValidTableName(name)
-    val path = new ObjectPath(defaultDatabaseName, name)
-    JavaScalaConversionUtil.toScala(catalogManager.getCatalog(defaultCatalogName)) match {
+    val path = new ObjectPath(builtinDatabaseName, name)
+    JavaScalaConversionUtil.toScala(catalogManager.getCatalog(builtinCatalogName)) match {
       case Some(catalog) =>
         catalog.alterTable(
           path,
@@ -427,7 +439,7 @@ abstract class TableEnvImpl(
           val operation = SqlToOperationConverter
             .convert(planner, createTable)
             .asInstanceOf[CreateTableOperation]
-          registerTableInternal(operation.getTablePath,
+          registerCatalogTableInternal(operation.getTablePath,
             operation.getCatalogTable,
             operation.isIgnoreIfExists)
           // returns null for DDL statement now
