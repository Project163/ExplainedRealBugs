diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java
index 8fe2b738f8e..08a52495693 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java
@@ -855,7 +855,7 @@ public class ExecutionGraph implements AccessExecutionGraph {
 		}
 
 		// the topology assigning should happen before notifying new vertices to failoverStrategy
-		executionTopology = new DefaultExecutionTopology(this);
+		executionTopology = DefaultExecutionTopology.fromExecutionGraph(this);
 
 		failoverStrategy.notifyNewVertices(newExecJobVertices);
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopology.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopology.java
index d7eb54e7784..36946fe9b9f 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopology.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopology.java
@@ -33,6 +33,8 @@ import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.annotation.Nullable;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -58,11 +60,13 @@ public class DefaultExecutionTopology implements SchedulingTopology {
 
 	private final Map<IntermediateResultPartitionID, DefaultResultPartition> resultPartitionsById;
 
-	private final Map<ExecutionVertexID, DefaultSchedulingPipelinedRegion> pipelinedRegionsByVertex;
+	@Nullable
+	private Map<ExecutionVertexID, DefaultSchedulingPipelinedRegion> pipelinedRegionsByVertex;
 
-	private final List<DefaultSchedulingPipelinedRegion> pipelinedRegions;
+	@Nullable
+	private List<DefaultSchedulingPipelinedRegion> pipelinedRegions;
 
-	public DefaultExecutionTopology(ExecutionGraph graph) {
+	private DefaultExecutionTopology(ExecutionGraph graph) {
 		checkNotNull(graph, "execution graph can not be null");
 
 		this.containsCoLocationConstraints = graph.getAllVertices().values().stream()
@@ -87,28 +91,17 @@ public class DefaultExecutionTopology implements SchedulingTopology {
 		this.resultPartitionsById = tmpResultPartitionsById;
 
 		connectVerticesToConsumedPartitions(executionVertexMap, tmpResultPartitionsById);
-
-		this.pipelinedRegionsByVertex = new HashMap<>();
-		this.pipelinedRegions = new ArrayList<>();
-		initializePipelinedRegions();
 	}
 
-	private void initializePipelinedRegions() {
-		final long buildRegionsStartTime = System.nanoTime();
-
-		final Set<Set<SchedulingExecutionVertex>> rawPipelinedRegions = PipelinedRegionComputeUtil.computePipelinedRegions(this);
-		for (Set<? extends SchedulingExecutionVertex> rawPipelinedRegion : rawPipelinedRegions) {
-			//noinspection unchecked
-			final DefaultSchedulingPipelinedRegion pipelinedRegion = new DefaultSchedulingPipelinedRegion((Set<DefaultExecutionVertex>) rawPipelinedRegion);
-			pipelinedRegions.add(pipelinedRegion);
+	private void setPipelinedRegions(List<DefaultSchedulingPipelinedRegion> pipelinedRegions) {
+		this.pipelinedRegions = checkNotNull(pipelinedRegions);
 
-			for (SchedulingExecutionVertex executionVertex : rawPipelinedRegion) {
+		this.pipelinedRegionsByVertex = new HashMap<>();
+		for (DefaultSchedulingPipelinedRegion pipelinedRegion : pipelinedRegions) {
+			for (SchedulingExecutionVertex executionVertex : pipelinedRegion.getVertices()) {
 				pipelinedRegionsByVertex.put(executionVertex.getId(), pipelinedRegion);
 			}
 		}
-
-		final long buildRegionsDuration = (System.nanoTime() - buildRegionsStartTime) / 1_000_000;
-		LOG.info("Built {} pipelined regions in {} ms", pipelinedRegions.size(), buildRegionsDuration);
 	}
 
 	@Override
@@ -141,11 +134,15 @@ public class DefaultExecutionTopology implements SchedulingTopology {
 
 	@Override
 	public Iterable<DefaultSchedulingPipelinedRegion> getAllPipelinedRegions() {
+		checkNotNull(pipelinedRegions);
+
 		return Collections.unmodifiableCollection(pipelinedRegions);
 	}
 
 	@Override
 	public DefaultSchedulingPipelinedRegion getPipelinedRegionOfVertex(final ExecutionVertexID vertexId) {
+		checkNotNull(pipelinedRegionsByVertex);
+
 		final DefaultSchedulingPipelinedRegion pipelinedRegion = pipelinedRegionsByVertex.get(vertexId);
 		if (pipelinedRegion == null) {
 			throw new IllegalArgumentException("Unknown execution vertex " + vertexId);
@@ -201,4 +198,33 @@ public class DefaultExecutionTopology implements SchedulingTopology {
 			}
 		}
 	}
+
+	public static DefaultExecutionTopology fromExecutionGraph(ExecutionGraph executionGraph) {
+		final DefaultExecutionTopology topology = new DefaultExecutionTopology(executionGraph);
+
+		final List<DefaultSchedulingPipelinedRegion> pipelinedRegions = generatePipelinedRegions(topology);
+		topology.setPipelinedRegions(pipelinedRegions);
+
+		return topology;
+	}
+
+	private static List<DefaultSchedulingPipelinedRegion> generatePipelinedRegions(DefaultExecutionTopology topology) {
+		final long buildRegionsStartTime = System.nanoTime();
+
+		final Set<Set<SchedulingExecutionVertex>> rawPipelinedRegions = PipelinedRegionComputeUtil
+			.computePipelinedRegions(topology);
+
+		final List<DefaultSchedulingPipelinedRegion> pipelinedRegions = new ArrayList<>();
+		for (Set<? extends SchedulingExecutionVertex> rawPipelinedRegion : rawPipelinedRegions) {
+			//noinspection unchecked
+			final DefaultSchedulingPipelinedRegion pipelinedRegion = new DefaultSchedulingPipelinedRegion(
+				(Set<DefaultExecutionVertex>) rawPipelinedRegion);
+			pipelinedRegions.add(pipelinedRegion);
+		}
+
+		final long buildRegionsDuration = (System.nanoTime() - buildRegionsStartTime) / 1_000_000;
+		LOG.info("Built {} pipelined regions in {} ms", pipelinedRegions.size(), buildRegionsDuration);
+
+		return pipelinedRegions;
+	}
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopologyTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopologyTest.java
index 57c9204ecd3..b116887d83d 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopologyTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopologyTest.java
@@ -86,7 +86,7 @@ public class DefaultExecutionTopologyTest extends TestLogger {
 			taskManagerGateway,
 			triggeredRestartStrategy,
 			jobVertices);
-		adapter = new DefaultExecutionTopology(executionGraph);
+		adapter = DefaultExecutionTopology.fromExecutionGraph(executionGraph);
 	}
 
 	@Test
@@ -147,7 +147,7 @@ public class DefaultExecutionTopologyTest extends TestLogger {
 	@Test
 	public void testWithCoLocationConstraints() throws Exception {
 		ExecutionGraph executionGraph = createExecutionGraphWithCoLocationConstraint();
-		adapter = new DefaultExecutionTopology(executionGraph);
+		adapter = DefaultExecutionTopology.fromExecutionGraph(executionGraph);
 		assertTrue(adapter.containsCoLocationConstraints());
 	}
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adapter/DefaultSchedulingPipelinedRegionTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adapter/DefaultSchedulingPipelinedRegionTest.java
index c97bad8bec5..f2511efc6e2 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adapter/DefaultSchedulingPipelinedRegionTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adapter/DefaultSchedulingPipelinedRegionTest.java
@@ -109,7 +109,7 @@ public class DefaultSchedulingPipelinedRegionTest extends TestLogger {
 		e.connectNewDataSetAsInput(d, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED);
 
 		final ExecutionGraph simpleTestGraph = ExecutionGraphTestUtils.createSimpleTestGraph(a, b, c, d, e);
-		final DefaultExecutionTopology topology = new DefaultExecutionTopology(simpleTestGraph);
+		final DefaultExecutionTopology topology = DefaultExecutionTopology.fromExecutionGraph(simpleTestGraph);
 
 		final DefaultSchedulingPipelinedRegion firstPipelinedRegion = topology.getPipelinedRegionOfVertex(new ExecutionVertexID(a.getID(), 0));
 		final DefaultSchedulingPipelinedRegion secondPipelinedRegion = topology.getPipelinedRegionOfVertex(new ExecutionVertexID(e.getID(), 0));
