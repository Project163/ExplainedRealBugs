<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:38:10 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-11094] Restored state in RocksDBStateBackend that has not been accessed in restored execution causes NPE on snapshot</title>
                <link>https://issues.apache.org/jira/browse/FLINK-11094</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;This was caused by changes in&#160;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10679&quot; title=&quot;Let TypeSerializerSchemaCompatibility.resolveSchemaCompatibility() be the entry point for compatibility checks in framework code&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10679&quot;&gt;&lt;del&gt;FLINK-10679&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The problem is that in that change, in the &lt;tt&gt;RocksDBKeyedBackend&lt;/tt&gt;, &lt;tt&gt;RegisteredStateMetaInfoBase&lt;/tt&gt; s&#160;were no longer created eagerly for all restored state, but instead only lazily created when the state was accessed again by the user. This causes non-accessed restored state to have empty meta info, and throws NPE when trying to take a snapshot of them.&lt;/p&gt;

&lt;p&gt;The rationale behind &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10679&quot; title=&quot;Let TypeSerializerSchemaCompatibility.resolveSchemaCompatibility() be the entry point for compatibility checks in framework code&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10679&quot;&gt;&lt;del&gt;FLINK-10679&lt;/del&gt;&lt;/a&gt; was that, since &lt;tt&gt;RegisteredStateMetaInfoBase&lt;/tt&gt;&#160;holds already serializer instances for state access, creating them eagerly at restore time with restored serializer snapshots did not make sense (because&#160;at that point-in-time, we do not have the new serializers yet for state access; the snapshot is only capable of creating the previous state serializer).&lt;/p&gt;

&lt;p&gt;I propose the following:&lt;/p&gt;

&lt;p&gt;Instead of&#160;having final&#160;&lt;tt&gt;TypeSerializer&lt;/tt&gt; instances in subclasses of&#160;&lt;tt&gt;RegisteredStateMetaInfoBase&lt;/tt&gt;, they should have a &lt;tt&gt;StateSerializerProvider&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;tt&gt;StateSerializerProvider&lt;/tt&gt; would have the following methods:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class&#160;&lt;/span&gt;StateSerializerProvider&amp;lt;T&amp;gt; {
&#160; &#160; TypeSerializer&amp;lt;T&amp;gt; getCurrentSerializer();
&#160; &#160; void updateCurrentSerializer(TypeSerializer&amp;lt;T&amp;gt; newSerializer);
&#160; &#160; TypeSerializer&amp;lt;T&amp;gt; getPreviousSerializer();
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;A &lt;tt&gt;StateSerializerProvider&lt;/tt&gt; can be created either from:&lt;br/&gt;
 1) A restored serializer snapshot when restoring the state.&lt;br/&gt;
 2) A fresh, new state&apos;s serializer, when registering the state for the first time.&lt;/p&gt;

&lt;p&gt;For 1), state that has not been accessed yet after the restore will return the same serializer (i.e. the previous serializer) for both &lt;tt&gt;getPreviousSerializer&lt;/tt&gt; and &lt;tt&gt;getCurrentSerializer&lt;/tt&gt;.&lt;br/&gt;
 Once a restored state is re-accessed, then &lt;tt&gt;updateCurrentSerializer(TypeSerializer&amp;lt;T&amp;gt; newSerializer)&lt;/tt&gt; should be used to update what serializer the provider returns in &lt;tt&gt;getCurrentSerializer&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;We could also make use of this new&#160;abstraction&#160;to move away some of the new serializer&apos;s compatibility checks from the state backend to &lt;tt&gt;StateSerializerProvider#updateCurrentSerializer&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;For tests, apparently we&apos;re lacking test coverage for restored state that has not been accessed and being snapshotted again. This should be included as part of the fix.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13202977">FLINK-11094</key>
            <summary>Restored state in RocksDBStateBackend that has not been accessed in restored execution causes NPE on snapshot</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="tzulitai">Tzu-Li (Gordon) Tai</assignee>
                                    <reporter username="tzulitai">Tzu-Li (Gordon) Tai</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Fri, 7 Dec 2018 06:40:18 +0000</created>
                <updated>Tue, 11 Dec 2018 12:41:59 +0000</updated>
                            <resolved>Tue, 11 Dec 2018 12:41:49 +0000</resolved>
                                    <version>1.7.0</version>
                                    <fixVersion>1.7.1</fixVersion>
                    <fixVersion>1.8.0</fixVersion>
                                    <component>Runtime / State Backends</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="16713898" author="githubbot" created="Sun, 9 Dec 2018 08:36:57 +0000"  >&lt;p&gt;tzulitai opened a new pull request #7264: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-11094&quot; title=&quot;Restored state in RocksDBStateBackend that has not been accessed in restored execution causes NPE on snapshot&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-11094&quot;&gt;&lt;del&gt;FLINK-11094&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;rocksdb&amp;#93;&lt;/span&gt; Make non-accessed restored state in RocksDBStateBackend snapshottable&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/7264&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/7264&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   The ultimate goal of this PR is to fix a bug where NPE is thrown if a non-accessed restored state in `RocksDBKeyedStatebackend` was snapshotted.&lt;br/&gt;
   This was an overlooked issue caused by changes in &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10679&quot; title=&quot;Let TypeSerializerSchemaCompatibility.resolveSchemaCompatibility() be the entry point for compatibility checks in framework code&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10679&quot;&gt;&lt;del&gt;FLINK-10679&lt;/del&gt;&lt;/a&gt;(&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10679&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-10679&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;   The problem is that in that change, in the `RocksDBKeyedBackend`, `RegisteredStateMetaInfoBase`s were no longer created eagerly for all restored state, but instead only lazily created when the state was accessed again by the user. This causes non-accessed restored state to have empty meta info, and throws NPE when trying to take a snapshot of them.&lt;/p&gt;

&lt;p&gt;   The rationale behind &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10679&quot; title=&quot;Let TypeSerializerSchemaCompatibility.resolveSchemaCompatibility() be the entry point for compatibility checks in framework code&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10679&quot;&gt;&lt;del&gt;FLINK-10679&lt;/del&gt;&lt;/a&gt; was that, since `RegisteredStateMetaInfoBase` holds already serializer instances for state access, creating them eagerly at restore time with restored serializer snapshots did not make sense (because at that point-in-time, we do not have the new serializers yet for state access; the snapshot is only capable of creating the previous state serializer).&lt;/p&gt;

&lt;p&gt;   This PR fixes this by letting state meta infos hold a `StateSerializerProvider`, instead of serializer instances. This allows meta infos to be instantiated from snapshots without eagerly accessing the restore serializer.&lt;/p&gt;

&lt;p&gt;   The API for the `StateSerializerProvider` is as follows:&lt;br/&gt;
   ```&lt;br/&gt;
   public abstract class StateSerializerProvider&amp;lt;T&amp;gt; &lt;/p&gt;
{
       TypeSerializer&amp;lt;T&amp;gt; currentSchemaSerializer();
       TypeSerializerSchemaCompatibility&amp;lt;T&amp;gt; registerSerializerForRestoredState(TypeSerializer&amp;lt;T&amp;gt; newRegisteredSerializer);
       TypeSerializer&amp;lt;T&amp;gt; previousSchemaSerializer();
   
       // factory methods for provider:
       public static &amp;lt;T&amp;gt; StateSerializerProvider&amp;lt;T&amp;gt; fromNewState(TypeSerializer&amp;lt;T&amp;gt; registeredSerializer);
       public static &amp;lt;T&amp;gt; StateSerializerProvider&amp;lt;T&amp;gt; fromRestoredState(TypeSerializerSnapshot&amp;lt;T&amp;gt; snapshot);
   }
&lt;p&gt;   ```&lt;/p&gt;

&lt;p&gt;   A StateSerializerProvider can be created either from:&lt;br/&gt;
   1. A restored serializer snapshot when restoring the state.&lt;br/&gt;
   2. A fresh, new state&apos;s serializer, when registering the state for the first time.&lt;/p&gt;

&lt;p&gt;   For 1), state that has not been accessed yet after the restore will return the same serializer (i.e. the serializer for previous schema) for both `currentSchemaSerializer` and `previousSchemaSerializer`, meaning that since no new serializer has been registered, the schema remains the same anyways.&lt;br/&gt;
   Once a restored state is re-accessed, then `registerSerializerForRestoredState(TypeSerializer&amp;lt;T&amp;gt; newSerializer)` should be used to update what serializer the provider returns in `currentSchemaSerializer`.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   Main changes are:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;First 3 hotfixes (3555f30 to 9e0a400) is some preliminary code cleanup / test hardening for the `StateBackendMigrationTestBase`.&lt;/li&gt;
	&lt;li&gt;c20c2cc: Introduce the new `StateSerializerProvider` abstraction and added tests for it&lt;/li&gt;
	&lt;li&gt;ee192df: Eagerly create meta infos from restored snapshots, so that they are created even if the state isn&apos;t accessed.&lt;/li&gt;
	&lt;li&gt;02d5a9d: Let meta infos use `StateSerializerProvider` instead of serializer instance&lt;/li&gt;
	&lt;li&gt;e9542d0: Add test coverage for snapshotting non-accessed restored state&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   This PR adds a new test `StateBackendTestBase.testSnapshotNonAccessedState()` to cover the issue.&lt;br/&gt;
   The test fails for RocksDB state backend case without the fixes.&lt;/p&gt;

&lt;p&gt;   Also, unit tests are added for `StateSerializerProvider`, in `StateSerializerProviderTest`.&lt;/p&gt;

&lt;p&gt;   All existing migration related tests in `StateBackendMigrationTestBase` are also related and should not be failing.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;The serializers: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (*&lt;b&gt;yes&lt;/b&gt;* / no / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16714575" author="githubbot" created="Mon, 10 Dec 2018 11:01:58 +0000"  >&lt;p&gt;igalshilman commented on issue #7264: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-11094&quot; title=&quot;Restored state in RocksDBStateBackend that has not been accessed in restored execution causes NPE on snapshot&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-11094&quot;&gt;&lt;del&gt;FLINK-11094&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;rocksdb&amp;#93;&lt;/span&gt; Make non-accessed restored state in RocksDBStateBackend snapshottable&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/7264#issuecomment-445776605&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/7264#issuecomment-445776605&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Hey @tzulitai, thanks for addressing this issue!&lt;br/&gt;
   I went through the commits and they align to our discussions offline, it looks good to me &#128077;&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16716705" author="githubbot" created="Tue, 11 Dec 2018 09:49:41 +0000"  >&lt;p&gt;asfgit closed pull request #7264: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-11094&quot; title=&quot;Restored state in RocksDBStateBackend that has not been accessed in restored execution causes NPE on snapshot&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-11094&quot;&gt;&lt;del&gt;FLINK-11094&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;rocksdb&amp;#93;&lt;/span&gt; Make non-accessed restored state in RocksDBStateBackend snapshottable&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/7264&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/7264&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/DefaultOperatorStateBackend.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/DefaultOperatorStateBackend.java&lt;br/&gt;
index 4702919384f..952dffbc70f 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/state/DefaultOperatorStateBackend.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/DefaultOperatorStateBackend.java&lt;br/&gt;
@@ -26,7 +26,6 @@&lt;br/&gt;
 import org.apache.flink.api.common.state.MapStateDescriptor;&lt;br/&gt;
 import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
 import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;&lt;br/&gt;
-import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;&lt;br/&gt;
 import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
 import org.apache.flink.core.fs.CloseableRegistry;&lt;br/&gt;
 import org.apache.flink.core.fs.FSDataInputStream;&lt;br/&gt;
@@ -105,23 +104,10 @@&lt;br/&gt;
 	 */&lt;br/&gt;
 	private final boolean asynchronousSnapshots;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Map of state names to their corresponding restored state meta info.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;TODO this map can be removed when eager-state registration is in place.&lt;/li&gt;
	&lt;li&gt;* TODO we currently need this cached to check state migration strategies when new serializers are registered.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private final Map&amp;lt;String, StateMetaInfoSnapshot&amp;gt; restoredOperatorStateMetaInfos;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Map of state names to their corresponding restored broadcast state meta info.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private final Map&amp;lt;String, StateMetaInfoSnapshot&amp;gt; restoredBroadcastStateMetaInfos;&lt;br/&gt;
-&lt;br/&gt;
 	/**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Cache of already accessed states.&lt;br/&gt;
 	 *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;In contrast to 
{@link #registeredOperatorStates} and {@link #restoredOperatorStateMetaInfos} which may be repopulated&lt;br/&gt;
+	 * &amp;lt;p&amp;gt;In contrast to {@link #registeredOperatorStates}
&lt;p&gt; which may be repopulated&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;with restored state, this map is always empty at the beginning.&lt;br/&gt;
 	 *&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;TODO this map should be moved to a base class once we have proper hierarchy for the operator state backends.&lt;br/&gt;
@@ -148,8 +134,6 @@ public DefaultOperatorStateBackend(&lt;br/&gt;
 		this.asynchronousSnapshots = asynchronousSnapshots;&lt;br/&gt;
 		this.accessedStatesByName = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
 		this.accessedBroadcastStatesByName = new HashMap&amp;lt;&amp;gt;();&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.restoredOperatorStateMetaInfos = new HashMap&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;this.restoredBroadcastStateMetaInfos = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
 		this.snapshotStrategy = new DefaultOperatorStateBackendSnapshotStrategy();&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -226,34 +210,22 @@ public void dispose() {&lt;br/&gt;
 					broadcastState.getStateMetaInfo().getAssignmentMode(),&lt;br/&gt;
 					OperatorStateHandle.Mode.BROADCAST);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final StateMetaInfoSnapshot metaInfoSnapshot = restoredBroadcastStateMetaInfos.get(name);&lt;br/&gt;
+			RegisteredBroadcastStateBackendMetaInfo&amp;lt;K, V&amp;gt; restoredBroadcastStateMetaInfo = broadcastState.getStateMetaInfo();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			// check whether new serializers are incompatible&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TypeSerializerSnapshot&amp;lt;K&amp;gt; keySerializerSnapshot = Preconditions.checkNotNull(&lt;/li&gt;
	&lt;li&gt;(TypeSerializerSnapshot&amp;lt;K&amp;gt;) metaInfoSnapshot.getTypeSerializerConfigSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.KEY_SERIALIZER));&lt;br/&gt;
-&lt;br/&gt;
 			TypeSerializerSchemaCompatibility&amp;lt;K&amp;gt; keyCompatibility =&lt;/li&gt;
	&lt;li&gt;keySerializerSnapshot.resolveSchemaCompatibility(broadcastStateKeySerializer);&lt;br/&gt;
+				restoredBroadcastStateMetaInfo.updateKeySerializer(broadcastStateKeySerializer);&lt;br/&gt;
 			if (keyCompatibility.isIncompatible()) 
{
 				throw new StateMigrationException(&quot;The new key serializer for broadcast state must not be incompatible.&quot;);
 			}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TypeSerializerSnapshot&amp;lt;V&amp;gt; valueSerializerSnapshot = Preconditions.checkNotNull(&lt;/li&gt;
	&lt;li&gt;(TypeSerializerSnapshot&amp;lt;V&amp;gt;) metaInfoSnapshot.getTypeSerializerConfigSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER));&lt;br/&gt;
-&lt;br/&gt;
 			TypeSerializerSchemaCompatibility&amp;lt;V&amp;gt; valueCompatibility =&lt;/li&gt;
	&lt;li&gt;valueSerializerSnapshot.resolveSchemaCompatibility(broadcastStateValueSerializer);&lt;br/&gt;
+				restoredBroadcastStateMetaInfo.updateValueSerializer(broadcastStateValueSerializer);&lt;br/&gt;
 			if (valueCompatibility.isIncompatible()) 
{
 				throw new StateMigrationException(&quot;The new value serializer for broadcast state must not be incompatible.&quot;);
 			}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// new serializer is compatible; use it to replace the old serializer&lt;/li&gt;
	&lt;li&gt;broadcastState.setStateMetaInfo(&lt;/li&gt;
	&lt;li&gt;new RegisteredBroadcastStateBackendMetaInfo&amp;lt;&amp;gt;(&lt;/li&gt;
	&lt;li&gt;name,&lt;/li&gt;
	&lt;li&gt;OperatorStateHandle.Mode.BROADCAST,&lt;/li&gt;
	&lt;li&gt;broadcastStateKeySerializer,&lt;/li&gt;
	&lt;li&gt;broadcastStateValueSerializer));&lt;br/&gt;
+			broadcastState.setStateMetaInfo(restoredBroadcastStateMetaInfo);&lt;br/&gt;
 		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		accessedBroadcastStatesByName.put(name, broadcastState);&lt;br/&gt;
@@ -345,8 +317,6 @@ public void restore(Collection&amp;lt;OperatorStateHandle&amp;gt; restoreSnapshots) throws Exc&lt;br/&gt;
 							&quot; not be loaded. This is a temporary restriction that will be fixed in future versions.&quot;);&lt;br/&gt;
 					}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;restoredOperatorStateMetaInfos.put(restoredSnapshot.getName(), restoredSnapshot);&lt;br/&gt;
-&lt;br/&gt;
 					PartitionableListState&amp;lt;?&amp;gt; listState = registeredOperatorStates.get(restoredSnapshot.getName());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 					if (null == listState) &lt;/p&gt;
{
@@ -381,8 +351,6 @@ public void restore(Collection&amp;lt;OperatorStateHandle&amp;gt; restoreSnapshots) throws Exc
 								&quot; not be loaded. This is a temporary restriction that will be fixed in future versions.&quot;);
 					}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;restoredBroadcastStateMetaInfos.put(restoredSnapshot.getName(), restoredSnapshot);&lt;br/&gt;
-&lt;br/&gt;
 					BackendWritableBroadcastState&amp;lt;? ,?&amp;gt; broadcastState = registeredBroadcastStates.get(restoredSnapshot.getName());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 					if (broadcastState == null) {&lt;br/&gt;
@@ -590,25 +558,19 @@ public void addAll(List&amp;lt;S&amp;gt; values) {&lt;br/&gt;
 					partitionableListState.getStateMetaInfo().getAssignmentMode(),&lt;br/&gt;
 					mode);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;StateMetaInfoSnapshot restoredSnapshot = restoredOperatorStateMetaInfos.get(name);&lt;/li&gt;
	&lt;li&gt;RegisteredOperatorStateBackendMetaInfo&amp;lt;S&amp;gt; metaInfo =&lt;/li&gt;
	&lt;li&gt;new RegisteredOperatorStateBackendMetaInfo&amp;lt;&amp;gt;(restoredSnapshot);&lt;br/&gt;
+			RegisteredOperatorStateBackendMetaInfo&amp;lt;S&amp;gt; restoredPartitionableListStateMetaInfo =&lt;br/&gt;
+				partitionableListState.getStateMetaInfo();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// check compatibility to determine if state migration is required&lt;br/&gt;
+			// check compatibility to determine if new serializers are incompatible&lt;br/&gt;
 			TypeSerializer&amp;lt;S&amp;gt; newPartitionStateSerializer = partitionStateSerializer.duplicate();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/li&gt;
	&lt;li&gt;TypeSerializerSnapshot&amp;lt;S&amp;gt; stateSerializerSnapshot = Preconditions.checkNotNull(&lt;/li&gt;
	&lt;li&gt;(TypeSerializerSnapshot&amp;lt;S&amp;gt;) restoredSnapshot.getTypeSerializerConfigSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER));&lt;br/&gt;
-&lt;br/&gt;
 			TypeSerializerSchemaCompatibility&amp;lt;S&amp;gt; stateCompatibility =&lt;/li&gt;
	&lt;li&gt;stateSerializerSnapshot.resolveSchemaCompatibility(newPartitionStateSerializer);&lt;br/&gt;
+				restoredPartitionableListStateMetaInfo.updatePartitionStateSerializer(newPartitionStateSerializer);&lt;br/&gt;
 			if (stateCompatibility.isIncompatible()) 
{
 				throw new StateMigrationException(&quot;The new state serializer for operator state must not be incompatible.&quot;);
 			}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;partitionableListState.setStateMetaInfo(&lt;/li&gt;
	&lt;li&gt;new RegisteredOperatorStateBackendMetaInfo&amp;lt;&amp;gt;(name, newPartitionStateSerializer, mode));&lt;br/&gt;
+			partitionableListState.setStateMetaInfo(restoredPartitionableListStateMetaInfo);&lt;br/&gt;
 		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		accessedStatesByName.put(name, partitionableListState);&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredBroadcastStateBackendMetaInfo.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredBroadcastStateBackendMetaInfo.java&lt;br/&gt;
index 70a14142474..ecc13faa43d 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredBroadcastStateBackendMetaInfo.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredBroadcastStateBackendMetaInfo.java&lt;br/&gt;
@@ -19,11 +19,13 @@&lt;br/&gt;
 package org.apache.flink.runtime.state;&lt;/p&gt;

&lt;p&gt; import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;&lt;br/&gt;
 import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;&lt;br/&gt;
 import org.apache.flink.runtime.state.metainfo.StateMetaInfoSnapshot;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;/p&gt;

&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
+import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.util.Collections;&lt;br/&gt;
 import java.util.HashMap;&lt;br/&gt;
@@ -38,11 +40,11 @@&lt;/p&gt;

&lt;p&gt; 	/** The type serializer for the keys in the map state. */&lt;br/&gt;
 	@Nonnull&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
+	private final StateSerializerProvider&amp;lt;K&amp;gt; keySerializerProvider;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/** The type serializer for the values in the map state. */&lt;br/&gt;
 	@Nonnull&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final TypeSerializer&amp;lt;V&amp;gt; valueSerializer;&lt;br/&gt;
+	private final StateSerializerProvider&amp;lt;V&amp;gt; valueSerializerProvider;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	public RegisteredBroadcastStateBackendMetaInfo(&lt;br/&gt;
 			@Nonnull final String name,&lt;br/&gt;
@@ -50,19 +52,19 @@ public RegisteredBroadcastStateBackendMetaInfo(&lt;br/&gt;
 			@Nonnull final TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
 			@Nonnull final TypeSerializer&amp;lt;V&amp;gt; valueSerializer) &lt;/p&gt;
{
 
-		super(name);
-		Preconditions.checkArgument(assignmentMode == OperatorStateHandle.Mode.BROADCAST);
-		this.assignmentMode = assignmentMode;
-		this.keySerializer = keySerializer;
-		this.valueSerializer = valueSerializer;
+		this(
+			name,
+			assignmentMode,
+			StateSerializerProvider.fromNewState(keySerializer),
+			StateSerializerProvider.fromNewState(valueSerializer));
 	}

&lt;p&gt; 	public RegisteredBroadcastStateBackendMetaInfo(@Nonnull RegisteredBroadcastStateBackendMetaInfo&amp;lt;K, V&amp;gt; copy) &lt;/p&gt;
{
 		this(
 			Preconditions.checkNotNull(copy).name,
 			copy.assignmentMode,
-			copy.keySerializer.duplicate(),
-			copy.valueSerializer.duplicate());
+			copy.getKeySerializer().duplicate(),
+			copy.getValueSerializer().duplicate());
 	}

&lt;p&gt; 	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
@@ -71,10 +73,13 @@ public RegisteredBroadcastStateBackendMetaInfo(@Nonnull StateMetaInfoSnapshot sn&lt;br/&gt;
 			snapshot.getName(),&lt;br/&gt;
 			OperatorStateHandle.Mode.valueOf(&lt;br/&gt;
 				snapshot.getOption(StateMetaInfoSnapshot.CommonOptionsKeys.OPERATOR_STATE_DISTRIBUTION_MODE)),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(TypeSerializer&amp;lt;K&amp;gt;) Preconditions.checkNotNull(&lt;/li&gt;
	&lt;li&gt;snapshot.restoreTypeSerializer(StateMetaInfoSnapshot.CommonSerializerKeys.KEY_SERIALIZER)),&lt;/li&gt;
	&lt;li&gt;(TypeSerializer&amp;lt;V&amp;gt;) Preconditions.checkNotNull(&lt;/li&gt;
	&lt;li&gt;snapshot.restoreTypeSerializer(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER)));&lt;br/&gt;
+			StateSerializerProvider.fromRestoredState(&lt;br/&gt;
+				(TypeSerializerSnapshot&amp;lt;K&amp;gt;) Preconditions.checkNotNull(&lt;br/&gt;
+					snapshot.getTypeSerializerSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.KEY_SERIALIZER))),&lt;br/&gt;
+			StateSerializerProvider.fromRestoredState(&lt;br/&gt;
+				(TypeSerializerSnapshot&amp;lt;V&amp;gt;) Preconditions.checkNotNull(&lt;br/&gt;
+					snapshot.getTypeSerializerSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER))));&lt;br/&gt;
+&lt;br/&gt;
 		Preconditions.checkState(StateMetaInfoSnapshot.BackendStateType.BROADCAST == snapshot.getBackendStateType());&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -86,6 +91,19 @@ public RegisteredBroadcastStateBackendMetaInfo(@Nonnull StateMetaInfoSnapshot sn&lt;br/&gt;
 		return new RegisteredBroadcastStateBackendMetaInfo&amp;lt;&amp;gt;(this);&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	private RegisteredBroadcastStateBackendMetaInfo(&lt;br/&gt;
+		@Nonnull final String name,&lt;br/&gt;
+		@Nonnull final OperatorStateHandle.Mode assignmentMode,&lt;br/&gt;
+		@Nonnull final StateSerializerProvider&amp;lt;K&amp;gt; keySerializerProvider,&lt;br/&gt;
+		@Nonnull final StateSerializerProvider&amp;lt;V&amp;gt; valueSerializerProvider) &lt;/p&gt;
{
+
+		super(name);
+		Preconditions.checkArgument(assignmentMode == OperatorStateHandle.Mode.BROADCAST);
+		this.assignmentMode = assignmentMode;
+		this.keySerializerProvider = keySerializerProvider;
+		this.valueSerializerProvider = valueSerializerProvider;
+	}
&lt;p&gt;+&lt;br/&gt;
 	@Nonnull&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public StateMetaInfoSnapshot snapshot() {&lt;br/&gt;
@@ -94,12 +112,32 @@ public StateMetaInfoSnapshot snapshot() {&lt;/p&gt;

&lt;p&gt; 	@Nonnull&lt;br/&gt;
 	public TypeSerializer&amp;lt;K&amp;gt; getKeySerializer() &lt;/p&gt;
{
-		return keySerializer;
+		return keySerializerProvider.currentSchemaSerializer();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	public TypeSerializerSchemaCompatibility&amp;lt;K&amp;gt; updateKeySerializer(TypeSerializer&amp;lt;K&amp;gt; newKeySerializer) &lt;/p&gt;
{
+		return keySerializerProvider.registerNewSerializerForRestoredState(newKeySerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public TypeSerializer&amp;lt;K&amp;gt; getPreviousKeySerializer() &lt;/p&gt;
{
+		return keySerializerProvider.previousSchemaSerializer();
 	}

&lt;p&gt; 	@Nonnull&lt;br/&gt;
 	public TypeSerializer&amp;lt;V&amp;gt; getValueSerializer() &lt;/p&gt;
{
-		return valueSerializer;
+		return valueSerializerProvider.currentSchemaSerializer();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	public TypeSerializerSchemaCompatibility&amp;lt;V&amp;gt; updateValueSerializer(TypeSerializer&amp;lt;V&amp;gt; newValueSerializer) &lt;/p&gt;
{
+		return valueSerializerProvider.registerNewSerializerForRestoredState(newValueSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public TypeSerializer&amp;lt;V&amp;gt; getPreviousValueSerializer() &lt;/p&gt;
{
+		return valueSerializerProvider.previousSchemaSerializer();
 	}

&lt;p&gt; 	@Nonnull&lt;br/&gt;
@@ -122,16 +160,16 @@ public boolean equals(Object obj) &lt;/p&gt;
{
 
 		return Objects.equals(name, other.getName())
 				&amp;amp;&amp;amp; Objects.equals(assignmentMode, other.getAssignmentMode())
-				&amp;amp;&amp;amp; Objects.equals(keySerializer, other.getKeySerializer())
-				&amp;amp;&amp;amp; Objects.equals(valueSerializer, other.getValueSerializer());
+				&amp;amp;&amp;amp; Objects.equals(getKeySerializer(), other.getKeySerializer())
+				&amp;amp;&amp;amp; Objects.equals(getValueSerializer(), other.getValueSerializer());
 	}

&lt;p&gt; 	@Override&lt;br/&gt;
 	public int hashCode() &lt;/p&gt;
{
 		int result = name.hashCode();
 		result = 31 * result + assignmentMode.hashCode();
-		result = 31 * result + keySerializer.hashCode();
-		result = 31 * result + valueSerializer.hashCode();
+		result = 31 * result + getKeySerializer().hashCode();
+		result = 31 * result + getValueSerializer().hashCode();
 		return result;
 	}

&lt;p&gt;@@ -139,8 +177,8 @@ public int hashCode() {&lt;br/&gt;
 	public String toString() {&lt;br/&gt;
 		return &quot;RegisteredBroadcastBackendStateMetaInfo&lt;/p&gt;
{&quot; +
 				&quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +
-				&quot;, keySerializer=&quot; + keySerializer +
-				&quot;, valueSerializer=&quot; + valueSerializer +
+				&quot;, keySerializer=&quot; + getKeySerializer() +
+				&quot;, valueSerializer=&quot; + getValueSerializer() +
 				&quot;, assignmentMode=&quot; + assignmentMode +
 				&apos;}
&lt;p&gt;&apos;;&lt;br/&gt;
 	}&lt;br/&gt;
@@ -154,8 +192,12 @@ private StateMetaInfoSnapshot computeSnapshot() {&lt;br/&gt;
 		Map&amp;lt;String, TypeSerializerSnapshot&amp;lt;?&amp;gt;&amp;gt; serializerConfigSnapshotsMap = new HashMap&amp;lt;&amp;gt;(2);&lt;br/&gt;
 		String keySerializerKey = StateMetaInfoSnapshot.CommonSerializerKeys.KEY_SERIALIZER.toString();&lt;br/&gt;
 		String valueSerializerKey = StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER.toString();&lt;br/&gt;
+&lt;br/&gt;
+		TypeSerializer&amp;lt;K&amp;gt; keySerializer = getKeySerializer();&lt;br/&gt;
 		serializerMap.put(keySerializerKey, keySerializer.duplicate());&lt;br/&gt;
 		serializerConfigSnapshotsMap.put(keySerializerKey, keySerializer.snapshotConfiguration());&lt;br/&gt;
+&lt;br/&gt;
+		TypeSerializer&amp;lt;V&amp;gt; valueSerializer = getValueSerializer();&lt;br/&gt;
 		serializerMap.put(valueSerializerKey, valueSerializer.duplicate());&lt;br/&gt;
 		serializerConfigSnapshotsMap.put(valueSerializerKey, valueSerializer.snapshotConfiguration());&lt;/p&gt;

&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredKeyValueStateBackendMetaInfo.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredKeyValueStateBackendMetaInfo.java&lt;br/&gt;
index d05f31a0c5c..b37c79de026 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredKeyValueStateBackendMetaInfo.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredKeyValueStateBackendMetaInfo.java&lt;br/&gt;
@@ -20,6 +20,7 @@&lt;/p&gt;

&lt;p&gt; import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
 import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;&lt;br/&gt;
 import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;&lt;br/&gt;
 import org.apache.flink.runtime.state.metainfo.StateMetaInfoSnapshot;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;br/&gt;
@@ -44,18 +45,24 @@&lt;br/&gt;
 	@Nonnull&lt;br/&gt;
 	private final StateDescriptor.Type stateType;&lt;br/&gt;
 	@Nonnull&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer;&lt;br/&gt;
+	private final StateSerializerProvider&amp;lt;N&amp;gt; namespaceSerializerProvider;&lt;br/&gt;
 	@Nonnull&lt;/li&gt;
	&lt;li&gt;private final TypeSerializer&amp;lt;S&amp;gt; stateSerializer;&lt;br/&gt;
+	private final StateSerializerProvider&amp;lt;S&amp;gt; stateSerializerProvider;&lt;br/&gt;
 	@Nullable&lt;/li&gt;
	&lt;li&gt;private final StateSnapshotTransformer&amp;lt;S&amp;gt; snapshotTransformer;&lt;br/&gt;
+	private StateSnapshotTransformer&amp;lt;S&amp;gt; snapshotTransformer;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	public RegisteredKeyValueStateBackendMetaInfo(&lt;br/&gt;
 		@Nonnull StateDescriptor.Type stateType,&lt;br/&gt;
 		@Nonnull String name,&lt;br/&gt;
 		@Nonnull TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer,&lt;br/&gt;
 		@Nonnull TypeSerializer&amp;lt;S&amp;gt; stateSerializer) &lt;/p&gt;
{
-		this(stateType, name, namespaceSerializer, stateSerializer, null);
+
+		this(
+			stateType,
+			name,
+			StateSerializerProvider.fromNewState(namespaceSerializer),
+			StateSerializerProvider.fromNewState(stateSerializer),
+			null);
 	}

&lt;p&gt; 	public RegisteredKeyValueStateBackendMetaInfo(&lt;br/&gt;
@@ -65,11 +72,12 @@ public RegisteredKeyValueStateBackendMetaInfo(&lt;br/&gt;
 		@Nonnull TypeSerializer&amp;lt;S&amp;gt; stateSerializer,&lt;br/&gt;
 		@Nullable StateSnapshotTransformer&amp;lt;S&amp;gt; snapshotTransformer) &lt;/p&gt;
{
 
-		super(name);
-		this.stateType = stateType;
-		this.namespaceSerializer = namespaceSerializer;
-		this.stateSerializer = stateSerializer;
-		this.snapshotTransformer = snapshotTransformer;
+		this(
+			stateType,
+			name,
+			StateSerializerProvider.fromNewState(namespaceSerializer),
+			StateSerializerProvider.fromNewState(stateSerializer),
+			snapshotTransformer);
 	}

&lt;p&gt; 	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
@@ -77,13 +85,31 @@ public RegisteredKeyValueStateBackendMetaInfo(@Nonnull StateMetaInfoSnapshot sna&lt;br/&gt;
 		this(&lt;br/&gt;
 			StateDescriptor.Type.valueOf(snapshot.getOption(StateMetaInfoSnapshot.CommonOptionsKeys.KEYED_STATE_TYPE)),&lt;br/&gt;
 			snapshot.getName(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(TypeSerializer&amp;lt;N&amp;gt;) Preconditions.checkNotNull(&lt;/li&gt;
	&lt;li&gt;snapshot.restoreTypeSerializer(StateMetaInfoSnapshot.CommonSerializerKeys.NAMESPACE_SERIALIZER)),&lt;/li&gt;
	&lt;li&gt;(TypeSerializer&amp;lt;S&amp;gt;) Preconditions.checkNotNull(&lt;/li&gt;
	&lt;li&gt;snapshot.restoreTypeSerializer(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER)), null);&lt;br/&gt;
+			StateSerializerProvider.fromRestoredState(&lt;br/&gt;
+				(TypeSerializerSnapshot&amp;lt;N&amp;gt;) Preconditions.checkNotNull(&lt;br/&gt;
+					snapshot.getTypeSerializerSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.NAMESPACE_SERIALIZER))),&lt;br/&gt;
+			StateSerializerProvider.fromRestoredState(&lt;br/&gt;
+				(TypeSerializerSnapshot&amp;lt;S&amp;gt;) Preconditions.checkNotNull(&lt;br/&gt;
+					snapshot.getTypeSerializerSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER))),&lt;br/&gt;
+			null);&lt;br/&gt;
+&lt;br/&gt;
 		Preconditions.checkState(StateMetaInfoSnapshot.BackendStateType.KEY_VALUE == snapshot.getBackendStateType());&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	private RegisteredKeyValueStateBackendMetaInfo(&lt;br/&gt;
+		@Nonnull StateDescriptor.Type stateType,&lt;br/&gt;
+		@Nonnull String name,&lt;br/&gt;
+		@Nonnull StateSerializerProvider&amp;lt;N&amp;gt; namespaceSerializerProvider,&lt;br/&gt;
+		@Nonnull StateSerializerProvider&amp;lt;S&amp;gt; stateSerializerProvider,&lt;br/&gt;
+		@Nullable StateSnapshotTransformer&amp;lt;S&amp;gt; snapshotTransformer) &lt;/p&gt;
{
+
+		super(name);
+		this.stateType = stateType;
+		this.namespaceSerializerProvider = namespaceSerializerProvider;
+		this.stateSerializerProvider = stateSerializerProvider;
+		this.snapshotTransformer = snapshotTransformer;
+	}
&lt;p&gt;+&lt;br/&gt;
 	@Nonnull&lt;br/&gt;
 	public StateDescriptor.Type getStateType() {&lt;br/&gt;
 		return stateType;&lt;br/&gt;
@@ -91,12 +117,32 @@ public RegisteredKeyValueStateBackendMetaInfo(@Nonnull StateMetaInfoSnapshot sna&lt;/p&gt;

&lt;p&gt; 	@Nonnull&lt;br/&gt;
 	public TypeSerializer&amp;lt;N&amp;gt; getNamespaceSerializer() &lt;/p&gt;
{
-		return namespaceSerializer;
+		return namespaceSerializerProvider.currentSchemaSerializer();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	public TypeSerializerSchemaCompatibility&amp;lt;N&amp;gt; updateNamespaceSerializer(TypeSerializer&amp;lt;N&amp;gt; newNamespaceSerializer) &lt;/p&gt;
{
+		return namespaceSerializerProvider.registerNewSerializerForRestoredState(newNamespaceSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public TypeSerializer&amp;lt;N&amp;gt; getPreviousNamespaceSerializer() &lt;/p&gt;
{
+		return namespaceSerializerProvider.previousSchemaSerializer();
 	}

&lt;p&gt; 	@Nonnull&lt;br/&gt;
 	public TypeSerializer&amp;lt;S&amp;gt; getStateSerializer() &lt;/p&gt;
{
-		return stateSerializer;
+		return stateSerializerProvider.currentSchemaSerializer();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	public TypeSerializerSchemaCompatibility&amp;lt;S&amp;gt; updateStateSerializer(TypeSerializer&amp;lt;S&amp;gt; newStateSerializer) &lt;/p&gt;
{
+		return stateSerializerProvider.registerNewSerializerForRestoredState(newStateSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public TypeSerializer&amp;lt;S&amp;gt; getPreviousStateSerializer() &lt;/p&gt;
{
+		return stateSerializerProvider.previousSchemaSerializer();
 	}

&lt;p&gt; 	@Nullable&lt;br/&gt;
@@ -104,6 +150,10 @@ public RegisteredKeyValueStateBackendMetaInfo(@Nonnull StateMetaInfoSnapshot sna&lt;br/&gt;
 		return snapshotTransformer;&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	public void updateSnapshotTransformer(StateSnapshotTransformer&amp;lt;S&amp;gt; snapshotTransformer) &lt;/p&gt;
{
+		this.snapshotTransformer = snapshotTransformer;
+	}
&lt;p&gt;+&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public boolean equals(Object o) {&lt;br/&gt;
 		if (this == o) {&lt;br/&gt;
@@ -133,8 +183,8 @@ public String toString() {&lt;br/&gt;
 		return &quot;RegisteredKeyedBackendStateMetaInfo&lt;/p&gt;
{&quot; +
 				&quot;stateType=&quot; + stateType +
 				&quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +
-				&quot;, namespaceSerializer=&quot; + namespaceSerializer +
-				&quot;, stateSerializer=&quot; + stateSerializer +
+				&quot;, namespaceSerializer=&quot; + getNamespaceSerializer() +
+				&quot;, stateSerializer=&quot; + getStateSerializer() +
 				&apos;}
&lt;p&gt;&apos;;&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;@@ -153,34 +203,19 @@ public StateMetaInfoSnapshot snapshot() &lt;/p&gt;
{
 		return computeSnapshot();
 	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static void checkStateMetaInfo(StateMetaInfoSnapshot stateMetaInfoSnapshot, StateDescriptor&amp;lt;?, ?&amp;gt; stateDesc) {&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(&lt;/li&gt;
	&lt;li&gt;stateMetaInfoSnapshot != null,&lt;/li&gt;
	&lt;li&gt;&quot;Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo,&quot; +&lt;/li&gt;
	&lt;li&gt;&quot; but its corresponding restored snapshot cannot be found.&quot;);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(stateMetaInfoSnapshot.getBackendStateType()&lt;/li&gt;
	&lt;li&gt;== StateMetaInfoSnapshot.BackendStateType.KEY_VALUE,&lt;/li&gt;
	&lt;li&gt;&quot;Incompatible state types. &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;Was &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot; + stateMetaInfoSnapshot.getBackendStateType() + &amp;quot;&amp;#93;&lt;/span&gt;, &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;registered as &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot; + StateMetaInfoSnapshot.BackendStateType.KEY_VALUE + &amp;quot;&amp;#93;&lt;/span&gt;.&quot;);&lt;br/&gt;
+	public void checkStateMetaInfo(StateDescriptor&amp;lt;?, ?&amp;gt; stateDesc) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		Preconditions.checkState(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Objects.equals(stateDesc.getName(), stateMetaInfoSnapshot.getName()),&lt;br/&gt;
+			Objects.equals(stateDesc.getName(), getName()),&lt;br/&gt;
 			&quot;Incompatible state names. &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;Was &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot; + stateMetaInfoSnapshot.getName() + &amp;quot;&amp;#93;&lt;/span&gt;, &quot; +&lt;br/&gt;
+				&quot;Was &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot; + getName() + &amp;quot;&amp;#93;&lt;/span&gt;, &quot; +&lt;br/&gt;
 				&quot;registered with &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot; + stateDesc.getName() + &amp;quot;&amp;#93;&lt;/span&gt;.&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final StateDescriptor.Type restoredType =&lt;/li&gt;
	&lt;li&gt;StateDescriptor.Type.valueOf(&lt;/li&gt;
	&lt;li&gt;stateMetaInfoSnapshot.getOption(&lt;/li&gt;
	&lt;li&gt;StateMetaInfoSnapshot.CommonOptionsKeys.KEYED_STATE_TYPE));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;if (stateDesc.getType() != StateDescriptor.Type.UNKNOWN &amp;amp;&amp;amp; restoredType != StateDescriptor.Type.UNKNOWN) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		if (stateDesc.getType() != StateDescriptor.Type.UNKNOWN &amp;amp;&amp;amp; getStateType() != StateDescriptor.Type.UNKNOWN) {
 			Preconditions.checkState(
-				stateDesc.getType() == restoredType,
+				stateDesc.getType() == getStateType(),
 				&quot;Incompatible key/value state types. &quot; +
-					&quot;Was [&quot; + restoredType + &quot;], &quot; +
+					&quot;Was [&quot; + getStateType() + &quot;], &quot; +
 					&quot;registered with [&quot; + stateDesc.getType() + &quot;].&quot;);
 		} 	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;@@ -194,8 +229,12 @@ private StateMetaInfoSnapshot computeSnapshot() {&lt;br/&gt;
 		Map&amp;lt;String, TypeSerializerSnapshot&amp;lt;?&amp;gt;&amp;gt; serializerConfigSnapshotsMap = new HashMap&amp;lt;&amp;gt;(2);&lt;br/&gt;
 		String namespaceSerializerKey = StateMetaInfoSnapshot.CommonSerializerKeys.NAMESPACE_SERIALIZER.toString();&lt;br/&gt;
 		String valueSerializerKey = StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER.toString();&lt;br/&gt;
+&lt;br/&gt;
+		TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer = getNamespaceSerializer();&lt;br/&gt;
 		serializerMap.put(namespaceSerializerKey, namespaceSerializer.duplicate());&lt;br/&gt;
 		serializerConfigSnapshotsMap.put(namespaceSerializerKey, namespaceSerializer.snapshotConfiguration());&lt;br/&gt;
+&lt;br/&gt;
+		TypeSerializer&amp;lt;S&amp;gt; stateSerializer = getStateSerializer();&lt;br/&gt;
 		serializerMap.put(valueSerializerKey, stateSerializer.duplicate());&lt;br/&gt;
 		serializerConfigSnapshotsMap.put(valueSerializerKey, stateSerializer.snapshotConfiguration());&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredOperatorStateBackendMetaInfo.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredOperatorStateBackendMetaInfo.java&lt;br/&gt;
index 10ba0296057..921947a4dd0 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredOperatorStateBackendMetaInfo.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredOperatorStateBackendMetaInfo.java&lt;br/&gt;
@@ -19,11 +19,13 @@&lt;br/&gt;
 package org.apache.flink.runtime.state;&lt;/p&gt;

&lt;p&gt; import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;&lt;br/&gt;
 import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;&lt;br/&gt;
 import org.apache.flink.runtime.state.metainfo.StateMetaInfoSnapshot;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;/p&gt;

&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
+import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.util.Collections;&lt;br/&gt;
 import java.util.Map;&lt;br/&gt;
@@ -46,21 +48,22 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The type serializer for the elements in the state list&lt;br/&gt;
 	 */&lt;br/&gt;
 	@Nonnull&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final TypeSerializer&amp;lt;S&amp;gt; partitionStateSerializer;&lt;br/&gt;
+	private final StateSerializerProvider&amp;lt;S&amp;gt; partitionStateSerializerProvider;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	public RegisteredOperatorStateBackendMetaInfo(&lt;br/&gt;
 			@Nonnull String name,&lt;br/&gt;
 			@Nonnull TypeSerializer&amp;lt;S&amp;gt; partitionStateSerializer,&lt;br/&gt;
 			@Nonnull OperatorStateHandle.Mode assignmentMode) &lt;/p&gt;
{
-		super(name);
-		this.partitionStateSerializer = partitionStateSerializer;
-		this.assignmentMode = assignmentMode;
+		this(
+			name,
+			StateSerializerProvider.fromNewState(partitionStateSerializer),
+			assignmentMode);
 	}

&lt;p&gt; 	private RegisteredOperatorStateBackendMetaInfo(@Nonnull RegisteredOperatorStateBackendMetaInfo&amp;lt;S&amp;gt; copy) &lt;/p&gt;
{
 		this(
 			Preconditions.checkNotNull(copy).name,
-			copy.partitionStateSerializer.duplicate(),
+			copy.getPartitionStateSerializer().duplicate(),
 			copy.assignmentMode);
 	}

&lt;p&gt;@@ -68,13 +71,24 @@ private RegisteredOperatorStateBackendMetaInfo(@Nonnull RegisteredOperatorStateB&lt;br/&gt;
 	public RegisteredOperatorStateBackendMetaInfo(@Nonnull StateMetaInfoSnapshot snapshot) &lt;/p&gt;
{
 		this(
 			snapshot.getName(),
-			(TypeSerializer&amp;lt;S&amp;gt;) Preconditions.checkNotNull(
-				snapshot.restoreTypeSerializer(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER)),
+			StateSerializerProvider.fromRestoredState(
+				(TypeSerializerSnapshot&amp;lt;S&amp;gt;) Preconditions.checkNotNull(
+					snapshot.getTypeSerializerSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER))),
 			OperatorStateHandle.Mode.valueOf(
 				snapshot.getOption(StateMetaInfoSnapshot.CommonOptionsKeys.OPERATOR_STATE_DISTRIBUTION_MODE)));
+
 		Preconditions.checkState(StateMetaInfoSnapshot.BackendStateType.OPERATOR == snapshot.getBackendStateType());
 	}

&lt;p&gt;+	private RegisteredOperatorStateBackendMetaInfo(&lt;br/&gt;
+			@Nonnull String name,&lt;br/&gt;
+			@Nonnull StateSerializerProvider&amp;lt;S&amp;gt; partitionStateSerializerProvider,&lt;br/&gt;
+			@Nonnull OperatorStateHandle.Mode assignmentMode) &lt;/p&gt;
{
+		super(name);
+		this.partitionStateSerializerProvider = partitionStateSerializerProvider;
+		this.assignmentMode = assignmentMode;
+	}
&lt;p&gt;+&lt;br/&gt;
 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Creates a deep copy of the itself.&lt;br/&gt;
 	 */&lt;br/&gt;
@@ -96,7 +110,17 @@ public StateMetaInfoSnapshot snapshot() {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	@Nonnull&lt;br/&gt;
 	public TypeSerializer&amp;lt;S&amp;gt; getPartitionStateSerializer() &lt;/p&gt;
{
-		return partitionStateSerializer;
+		return partitionStateSerializerProvider.currentSchemaSerializer();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	public TypeSerializerSchemaCompatibility&amp;lt;S&amp;gt; updatePartitionStateSerializer(TypeSerializer&amp;lt;S&amp;gt; newPartitionStateSerializer) &lt;/p&gt;
{
+		return partitionStateSerializerProvider.registerNewSerializerForRestoredState(newPartitionStateSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public TypeSerializer&amp;lt;S&amp;gt; getPreviousPartitionStateSerializer() &lt;/p&gt;
{
+		return partitionStateSerializerProvider.previousSchemaSerializer();
 	}

&lt;p&gt; 	@Override&lt;br/&gt;
@@ -112,7 +136,7 @@ public boolean equals(Object obj) &lt;/p&gt;
{
 		return (obj instanceof RegisteredOperatorStateBackendMetaInfo)
 			&amp;amp;&amp;amp; name.equals(((RegisteredOperatorStateBackendMetaInfo) obj).getName())
 			&amp;amp;&amp;amp; assignmentMode.equals(((RegisteredOperatorStateBackendMetaInfo) obj).getAssignmentMode())
-			&amp;amp;&amp;amp; partitionStateSerializer.equals(((RegisteredOperatorStateBackendMetaInfo) obj).getPartitionStateSerializer());
+			&amp;amp;&amp;amp; getPartitionStateSerializer().equals(((RegisteredOperatorStateBackendMetaInfo) obj).getPartitionStateSerializer());
 	}

&lt;p&gt; 	@Override&lt;br/&gt;
@@ -128,7 +152,7 @@ public String toString() {&lt;br/&gt;
 		return &quot;RegisteredOperatorBackendStateMetaInfo&lt;/p&gt;
{&quot; +
 			&quot;name=&apos;&quot; + name + &quot;\&apos;&quot; +
 			&quot;, assignmentMode=&quot; + assignmentMode +
-			&quot;, partitionStateSerializer=&quot; + partitionStateSerializer +
+			&quot;, partitionStateSerializer=&quot; + getPartitionStateSerializer() +
 			&apos;}
&lt;p&gt;&apos;;&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;@@ -138,6 +162,8 @@ private StateMetaInfoSnapshot computeSnapshot() {&lt;br/&gt;
 			StateMetaInfoSnapshot.CommonOptionsKeys.OPERATOR_STATE_DISTRIBUTION_MODE.toString(),&lt;br/&gt;
 			assignmentMode.toString());&lt;br/&gt;
 		String valueSerializerKey = StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER.toString();&lt;br/&gt;
+&lt;br/&gt;
+		TypeSerializer&amp;lt;S&amp;gt; partitionStateSerializer = getPartitionStateSerializer();&lt;br/&gt;
 		Map&amp;lt;String, TypeSerializer&amp;lt;?&amp;gt;&amp;gt; serializerMap =&lt;br/&gt;
 			Collections.singletonMap(valueSerializerKey, partitionStateSerializer.duplicate());&lt;br/&gt;
 		Map&amp;lt;String, TypeSerializerSnapshot&amp;lt;?&amp;gt;&amp;gt; serializerConfigSnapshotsMap =&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredPriorityQueueStateBackendMetaInfo.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredPriorityQueueStateBackendMetaInfo.java&lt;br/&gt;
index 0304b929c6d..961d96fa405 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredPriorityQueueStateBackendMetaInfo.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredPriorityQueueStateBackendMetaInfo.java&lt;br/&gt;
@@ -19,11 +19,13 @@&lt;br/&gt;
 package org.apache.flink.runtime.state;&lt;/p&gt;

&lt;p&gt; import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;&lt;br/&gt;
 import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;&lt;br/&gt;
 import org.apache.flink.runtime.state.metainfo.StateMetaInfoSnapshot;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;/p&gt;

&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
+import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.util.Collections;&lt;br/&gt;
 import java.util.Map;&lt;br/&gt;
@@ -34,24 +36,34 @@&lt;br/&gt;
 public class RegisteredPriorityQueueStateBackendMetaInfo&amp;lt;T&amp;gt; extends RegisteredStateMetaInfoBase {&lt;/p&gt;

&lt;p&gt; 	@Nonnull&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final TypeSerializer&amp;lt;T&amp;gt; elementSerializer;&lt;br/&gt;
+	private final StateSerializerProvider&amp;lt;T&amp;gt; elementSerializerProvider;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	public RegisteredPriorityQueueStateBackendMetaInfo(&lt;br/&gt;
 		@Nonnull String name,&lt;br/&gt;
 		@Nonnull TypeSerializer&amp;lt;T&amp;gt; elementSerializer) &lt;/p&gt;
{
 
-		super(name);
-		this.elementSerializer = elementSerializer;
+		this(name, StateSerializerProvider.fromNewState(elementSerializer));
 	}

&lt;p&gt; 	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
 	public RegisteredPriorityQueueStateBackendMetaInfo(StateMetaInfoSnapshot snapshot) &lt;/p&gt;
{
-		this(snapshot.getName(),
-			(TypeSerializer&amp;lt;T&amp;gt;) Preconditions.checkNotNull(
-				snapshot.restoreTypeSerializer(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER)));
+		this(
+			snapshot.getName(),
+			StateSerializerProvider.fromRestoredState(
+				(TypeSerializerSnapshot&amp;lt;T&amp;gt;) Preconditions.checkNotNull(
+					snapshot.getTypeSerializerSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER))));
+
 		Preconditions.checkState(StateMetaInfoSnapshot.BackendStateType.PRIORITY_QUEUE == snapshot.getBackendStateType());
 	}

&lt;p&gt;+	private RegisteredPriorityQueueStateBackendMetaInfo(&lt;br/&gt;
+		@Nonnull String name,&lt;br/&gt;
+		@Nonnull StateSerializerProvider&amp;lt;T&amp;gt; elementSerializerProvider) &lt;/p&gt;
{
+
+		super(name);
+		this.elementSerializerProvider = elementSerializerProvider;
+	}
&lt;p&gt;+&lt;br/&gt;
 	@Nonnull&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public StateMetaInfoSnapshot snapshot() {&lt;br/&gt;
@@ -60,10 +72,21 @@ public StateMetaInfoSnapshot snapshot() {&lt;/p&gt;

&lt;p&gt; 	@Nonnull&lt;br/&gt;
 	public TypeSerializer&amp;lt;T&amp;gt; getElementSerializer() &lt;/p&gt;
{
-		return elementSerializer;
+		return elementSerializerProvider.currentSchemaSerializer();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	public TypeSerializerSchemaCompatibility&amp;lt;T&amp;gt; updateElementSerializer(TypeSerializer&amp;lt;T&amp;gt; newElementSerializer) &lt;/p&gt;
{
+		return elementSerializerProvider.registerNewSerializerForRestoredState(newElementSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public TypeSerializer&amp;lt;T&amp;gt; getPreviousElementSerializer() &lt;/p&gt;
{
+		return elementSerializerProvider.previousSchemaSerializer();
 	}

&lt;p&gt; 	private StateMetaInfoSnapshot computeSnapshot() {&lt;br/&gt;
+		TypeSerializer&amp;lt;T&amp;gt; elementSerializer = getElementSerializer();&lt;br/&gt;
 		Map&amp;lt;String, TypeSerializer&amp;lt;?&amp;gt;&amp;gt; serializerMap =&lt;br/&gt;
 			Collections.singletonMap(&lt;br/&gt;
 				StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER.toString(),&lt;br/&gt;
@@ -82,6 +105,6 @@ private StateMetaInfoSnapshot computeSnapshot() {&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt; 	public RegisteredPriorityQueueStateBackendMetaInfo deepCopy() &lt;/p&gt;
{
-		return new RegisteredPriorityQueueStateBackendMetaInfo&amp;lt;&amp;gt;(name, elementSerializer.duplicate());
+		return new RegisteredPriorityQueueStateBackendMetaInfo&amp;lt;&amp;gt;(name, getElementSerializer().duplicate());
 	}
&lt;p&gt; }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredStateMetaInfoBase.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredStateMetaInfoBase.java&lt;br/&gt;
index 4132d144a4a..b7dff59aef0 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredStateMetaInfoBase.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/RegisteredStateMetaInfoBase.java&lt;br/&gt;
@@ -42,4 +42,21 @@ public String getName() {&lt;/p&gt;

&lt;p&gt; 	@Nonnull&lt;br/&gt;
 	public abstract StateMetaInfoSnapshot snapshot();&lt;br/&gt;
+&lt;br/&gt;
+	public static RegisteredStateMetaInfoBase fromMetaInfoSnapshot(@Nonnull StateMetaInfoSnapshot snapshot) {&lt;br/&gt;
+&lt;br/&gt;
+		final StateMetaInfoSnapshot.BackendStateType backendStateType = snapshot.getBackendStateType();&lt;br/&gt;
+		switch (backendStateType) &lt;/p&gt;
{
+			case KEY_VALUE:
+				return new RegisteredKeyValueStateBackendMetaInfo&amp;lt;&amp;gt;(snapshot);
+			case OPERATOR:
+				return new RegisteredOperatorStateBackendMetaInfo&amp;lt;&amp;gt;(snapshot);
+			case BROADCAST:
+				return new RegisteredBroadcastStateBackendMetaInfo&amp;lt;&amp;gt;(snapshot);
+			case PRIORITY_QUEUE:
+				return new RegisteredPriorityQueueStateBackendMetaInfo&amp;lt;&amp;gt;(snapshot);
+			default:
+				throw new IllegalArgumentException(&quot;Unknown backend state type: &quot; + backendStateType);
+		}
&lt;p&gt;+	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/StateSerializerProvider.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/StateSerializerProvider.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..a24f12e42fb&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/StateSerializerProvider.java&lt;br/&gt;
@@ -0,0 +1,245 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.state;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * A &lt;/p&gt;
{@link StateSerializerProvider} wraps logic on how to obtain serializers for registered state,&lt;br/&gt;
+ * either with the previous schema of state in checkpoints or the current schema of state.&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; the type of the state.&lt;br/&gt;
+ */&lt;br/&gt;
+@Internal&lt;br/&gt;
+public abstract class StateSerializerProvider&amp;lt;T&amp;gt; {&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * The registered serializer for the state.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * &amp;lt;p&amp;gt;In the case that this provider was created from a restored serializer snapshot via&lt;br/&gt;
+	 * {@link #fromRestoredState(TypeSerializerSnapshot)}, but a new serializer was never registered&lt;br/&gt;
+	 * for the state (i.e., this is the case if a restored state was never accessed), this would be {@code null}.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	TypeSerializer&amp;lt;T&amp;gt; registeredSerializer;&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Creates a {@link StateSerializerProvider}
&lt;p&gt; for restored state from the previous serializer&apos;s snapshot.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * &amp;lt;p&amp;gt;Once a new serializer is registered for the state, it should be provided via&lt;br/&gt;
+	 * the &lt;/p&gt;
{@link #registerNewSerializerForRestoredState(TypeSerializer)}
&lt;p&gt; method.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param stateSerializerSnapshot the previous serializer&apos;s snapshot.&lt;br/&gt;
+	 * @param &amp;lt;T&amp;gt; the type of the state.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return a new &lt;/p&gt;
{@link StateSerializerProvider} for restored state.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; StateSerializerProvider&amp;lt;T&amp;gt; fromRestoredState(TypeSerializerSnapshot&amp;lt;T&amp;gt; stateSerializerSnapshot) {
+		return new RestoredStateSerializerProvider&amp;lt;&amp;gt;(stateSerializerSnapshot);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Creates a {@link StateSerializerProvider}
&lt;p&gt; for new state from the registered state serializer.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param registeredStateSerializer the new state&apos;s registered serializer.&lt;br/&gt;
+	 * @param &amp;lt;T&amp;gt; the type of the state.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return a new &lt;/p&gt;
{@link StateSerializerProvider} for new state.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; StateSerializerProvider&amp;lt;T&amp;gt; fromNewState(TypeSerializer&amp;lt;T&amp;gt; registeredStateSerializer) {
+		return new NewStateSerializerProvider&amp;lt;&amp;gt;(registeredStateSerializer);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private StateSerializerProvider(@Nullable TypeSerializer&amp;lt;T&amp;gt; stateSerializer) {
+		this.registeredSerializer = stateSerializer;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Gets the serializer that recognizes the current serialization schema of the state.&lt;br/&gt;
+	 * This is the serializer that should be used for regular state serialization and&lt;br/&gt;
+	 * deserialization after state has been restored.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * &amp;lt;p&amp;gt;If this provider was created from a restored state&apos;s serializer snapshot, while a&lt;br/&gt;
+	 * new serializer (with a new schema) was not registered for the state (i.e., because&lt;br/&gt;
+	 * the state was never accessed after it was restored), then the schema of state remains&lt;br/&gt;
+	 * identical. Therefore, in this case, it is guaranteed that the serializer returned by&lt;br/&gt;
+	 * this method is the same as the one returned by {@link #previousSchemaSerializer()}.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * &amp;lt;p&amp;gt;If this provider was created from new state, then this always returns the&lt;br/&gt;
+	 * serializer that the new state was registered with.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return a serializer that reads and writes in the current schema of the state.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	public abstract TypeSerializer&amp;lt;T&amp;gt; currentSchemaSerializer();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Gets the serializer that recognizes the previous serialization schema of the state.&lt;br/&gt;
+	 * This is the serializer that should be used for restoring the state, i.e. when the state&lt;br/&gt;
+	 * is still in the previous serialization schema.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * &amp;lt;p&amp;gt;This method can only be used if this provider was created from a restored state&apos;s serializer&lt;br/&gt;
+	 * snapshot. If this provider was created from new state, then this method is&lt;br/&gt;
+	 * irrelevant, since there doesn&apos;t exist any previous version of the state schema.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return a serializer that reads and writes in the previous schema of the state.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	public abstract TypeSerializer&amp;lt;T&amp;gt; previousSchemaSerializer();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * For restored state, register a new serializer that potentially has a new serialization schema.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * &amp;lt;p&amp;gt;Users are allowed to register serializers for state only once. Therefore, this method&lt;br/&gt;
+	 * is irrelevant if this provider was created from new state, since a state serializer had&lt;br/&gt;
+	 * been registered already.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * &amp;lt;p&amp;gt;For the case where this provider was created from restored state, then this method should&lt;br/&gt;
+	 * be called at most once. The new serializer will be checked for its schema compatibility with the&lt;br/&gt;
+	 * previous serializer&apos;s schema, and returned to the caller. The caller is responsible for&lt;br/&gt;
+	 * checking the result and react appropriately to it, as follows:&lt;br/&gt;
+	 * &amp;lt;ul&amp;gt;&lt;br/&gt;
+	 *     &amp;lt;li&amp;gt;{@link TypeSerializerSchemaCompatibility#isCompatibleAsIs()}: nothing needs to be done.&lt;br/&gt;
+	 *     {@link #currentSchemaSerializer()} now returns the newly registered serializer.&amp;lt;/li&amp;gt;&lt;br/&gt;
+	 *     &amp;lt;li&amp;gt;{@link TypeSerializerSchemaCompatibility#isCompatibleAfterMigration()} ()}: state needs to be&lt;br/&gt;
+	 *     migrated before the serializer returned by {@link #currentSchemaSerializer()} can be used.&lt;br/&gt;
+	 *     The migration should be performed by reading the state with {@link #previousSchemaSerializer()},&lt;br/&gt;
+	 *     and then writing it again with {@link #currentSchemaSerializer()}.&amp;lt;/li&amp;gt;&lt;br/&gt;
+	 *     &amp;lt;li&amp;gt;{@link TypeSerializerSchemaCompatibility#isIncompatible()}: the registered serializer is&lt;br/&gt;
+	 *     incompatible. {@link #currentSchemaSerializer()} can no longer return a serializer for&lt;br/&gt;
+	 *     the state, and therefore this provider shouldn&apos;t be used anymore.&amp;lt;/li&amp;gt;&lt;br/&gt;
+	 * &amp;lt;/ul&amp;gt;&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return the schema compatibility of the new registered serializer, with respect to the previous serializer.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	public abstract TypeSerializerSchemaCompatibility&amp;lt;T&amp;gt; registerNewSerializerForRestoredState(TypeSerializer&amp;lt;T&amp;gt; newSerializer);&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Implementation of the {@link StateSerializerProvider}
&lt;p&gt; for the restored state case.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private static class RestoredStateSerializerProvider&amp;lt;T&amp;gt; extends StateSerializerProvider&amp;lt;T&amp;gt; {&lt;br/&gt;
+&lt;br/&gt;
+		/**&lt;br/&gt;
+		 * The snapshot of the previous serializer of the state.&lt;br/&gt;
+		 */&lt;br/&gt;
+		@Nonnull&lt;br/&gt;
+		private final TypeSerializerSnapshot&amp;lt;T&amp;gt; previousSerializerSnapshot;&lt;br/&gt;
+&lt;br/&gt;
+		private boolean isRegisteredWithIncompatibleSerializer = false;&lt;br/&gt;
+&lt;br/&gt;
+		RestoredStateSerializerProvider(TypeSerializerSnapshot&amp;lt;T&amp;gt; previousSerializerSnapshot) &lt;/p&gt;
{
+			super(null);
+			this.previousSerializerSnapshot = Preconditions.checkNotNull(previousSerializerSnapshot);
+		}
&lt;p&gt;+&lt;br/&gt;
+		/**&lt;br/&gt;
+		 * The restore serializer, lazily created only when the restore serializer is accessed.&lt;br/&gt;
+		 *&lt;br/&gt;
+		 * &amp;lt;p&amp;gt;NOTE: It is important to only create this lazily, so that off-heap&lt;br/&gt;
+		 * state do not fail eagerly when restoring state that has a&lt;br/&gt;
+		 * &lt;/p&gt;
{@link UnloadableDummyTypeSerializer}
&lt;p&gt; as the previous serializer. This should&lt;br/&gt;
+		 * be relevant only for restores from Flink versions prior to 1.7.x.&lt;br/&gt;
+		 */&lt;br/&gt;
+		@Nullable&lt;br/&gt;
+		private TypeSerializer&amp;lt;T&amp;gt; cachedRestoredSerializer;&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		@Nonnull&lt;br/&gt;
+		public TypeSerializer&amp;lt;T&amp;gt; currentSchemaSerializer() {&lt;br/&gt;
+			if (registeredSerializer != null) &lt;/p&gt;
{
+				checkState(
+					!isRegisteredWithIncompatibleSerializer,
+					&quot;Unable to provide a serializer with the current schema, because the restored state was &quot; +
+						&quot;registered with a new serializer that has incompatible schema.&quot;);
+
+					return registeredSerializer;
+			}
&lt;p&gt;+&lt;br/&gt;
+			// if we are not yet registered with a new serializer,&lt;br/&gt;
+			// we can just use the restore serializer to read / write the state.&lt;br/&gt;
+			return previousSchemaSerializer();&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Nonnull&lt;br/&gt;
+		public TypeSerializerSchemaCompatibility&amp;lt;T&amp;gt; registerNewSerializerForRestoredState(TypeSerializer&amp;lt;T&amp;gt; newSerializer) {&lt;br/&gt;
+			checkNotNull(newSerializer);&lt;br/&gt;
+			if (registeredSerializer != null) &lt;/p&gt;
{
+				throw new UnsupportedOperationException(&quot;A serializer has already been registered for the state; re-registration is not allowed.&quot;);
+			}
&lt;p&gt;+&lt;br/&gt;
+			TypeSerializerSchemaCompatibility&amp;lt;T&amp;gt; result = previousSerializerSnapshot.resolveSchemaCompatibility(newSerializer);&lt;br/&gt;
+			if (result.isIncompatible()) &lt;/p&gt;
{
+				this.isRegisteredWithIncompatibleSerializer = true;
+			}
&lt;p&gt;+			this.registeredSerializer = newSerializer;&lt;br/&gt;
+			return result;&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Nonnull&lt;br/&gt;
+		public final TypeSerializer&amp;lt;T&amp;gt; previousSchemaSerializer() {&lt;br/&gt;
+			if (cachedRestoredSerializer != null) &lt;/p&gt;
{
+				return cachedRestoredSerializer;
+			}
&lt;p&gt;+&lt;br/&gt;
+			this.cachedRestoredSerializer = previousSerializerSnapshot.restoreSerializer();&lt;br/&gt;
+			return cachedRestoredSerializer;&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Implementation of the &lt;/p&gt;
{@link StateSerializerProvider} for the new state case.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private static class NewStateSerializerProvider&amp;lt;T&amp;gt; extends StateSerializerProvider&amp;lt;T&amp;gt; {&lt;br/&gt;
+&lt;br/&gt;
+		NewStateSerializerProvider(TypeSerializer&amp;lt;T&amp;gt; registeredStateSerializer) {
+			super(Preconditions.checkNotNull(registeredStateSerializer));
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		@Nonnull&lt;br/&gt;
+		@SuppressWarnings(&quot;ConstantConditions&quot;)&lt;br/&gt;
+		public TypeSerializer&amp;lt;T&amp;gt; currentSchemaSerializer() {
+			return registeredSerializer;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		@Nonnull&lt;br/&gt;
+		public TypeSerializerSchemaCompatibility&amp;lt;T&amp;gt; registerNewSerializerForRestoredState(TypeSerializer&amp;lt;T&amp;gt; newSerializer) {
+			throw new UnsupportedOperationException(&quot;A serializer has already been registered for the state; re-registration is not allowed.&quot;);
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		@Nonnull&lt;br/&gt;
+		public TypeSerializer&amp;lt;T&amp;gt; previousSchemaSerializer() {
+			throw new UnsupportedOperationException(&quot;This is a NewStateSerializerProvider; you cannot get a restore serializer because there was no restored state.&quot;);
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java&lt;br/&gt;
index 4eff3a285bb..3f8761b657a 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java&lt;br/&gt;
@@ -30,7 +30,6 @@&lt;br/&gt;
 import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
 import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
 import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;&lt;br/&gt;
-import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;&lt;br/&gt;
 import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
 import org.apache.flink.core.fs.FSDataInputStream;&lt;br/&gt;
 import org.apache.flink.core.memory.DataInputViewStreamWrapper;&lt;br/&gt;
@@ -79,6 +78,7 @@&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
 &lt;br/&gt;
 import javax.annotation.Nonnull;&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
 &lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.io.InputStream;&lt;br/&gt;
@@ -125,14 +125,6 @@&lt;br/&gt;
 	 */&lt;br/&gt;
 	private final Map&amp;lt;String, HeapPriorityQueueSnapshotRestoreWrapper&amp;gt; registeredPQStates;&lt;br/&gt;
 &lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Map of state names to their corresponding restored state meta info.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;TODO this map can be removed when eager-state registration is in place.&lt;br/&gt;
-	 * TODO we currently need this cached to check state migration strategies when new serializers are registered.&lt;br/&gt;
-	 */&lt;br/&gt;
-	private final Map&amp;lt;StateUID, StateMetaInfoSnapshot&amp;gt; restoredStateMetaInfo;&lt;br/&gt;
-&lt;br/&gt;
 	/**&lt;br/&gt;
 	 * The configuration for local recovery.&lt;br/&gt;
 	 */&lt;br/&gt;
@@ -173,7 +165,6 @@ public HeapKeyedStateBackend(&lt;br/&gt;
 &lt;br/&gt;
 		this.snapshotStrategy = new HeapSnapshotStrategy(synchronicityTrait);&lt;br/&gt;
 		LOG.info(&quot;Initializing heap keyed state backend with stream factory.&quot;);&lt;br/&gt;
-		this.restoredStateMetaInfo = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
 		this.priorityQueueSetFactory = priorityQueueSetFactory;&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
@@ -194,23 +185,9 @@ public HeapKeyedStateBackend(&lt;br/&gt;
 			// TODO we implement the simple way of supporting the current functionality, mimicking keyed state&lt;br/&gt;
 			// because this should be reworked in &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9376&quot; title=&quot;Allow upgrading to incompatible state serializers (state schema evolution)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9376&quot;&gt;&lt;del&gt;FLINK-9376&lt;/del&gt;&lt;/a&gt; and then we should have a common algorithm over&lt;br/&gt;
 			// StateMetaInfoSnapshot that avoids this code duplication.&lt;br/&gt;
-			StateMetaInfoSnapshot restoredMetaInfoSnapshot =&lt;br/&gt;
-				restoredStateMetaInfo.get(StateUID.of(stateName, StateMetaInfoSnapshot.BackendStateType.PRIORITY_QUEUE));&lt;br/&gt;
-&lt;br/&gt;
-			Preconditions.checkState(&lt;br/&gt;
-				restoredMetaInfoSnapshot != null,&lt;br/&gt;
-				&quot;Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo,&quot; +&lt;br/&gt;
-					&quot; but its corresponding restored snapshot cannot be found.&quot;);&lt;br/&gt;
-&lt;br/&gt;
-			StateMetaInfoSnapshot.CommonSerializerKeys serializerKey =&lt;br/&gt;
-				StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER;&lt;br/&gt;
-&lt;br/&gt;
-			@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
-			TypeSerializerSnapshot&amp;lt;T&amp;gt; serializerSnapshot = Preconditions.checkNotNull(&lt;br/&gt;
-				(TypeSerializerSnapshot&amp;lt;T&amp;gt;) restoredMetaInfoSnapshot.getTypeSerializerConfigSnapshot(serializerKey));&lt;br/&gt;
 &lt;br/&gt;
 			TypeSerializerSchemaCompatibility&amp;lt;T&amp;gt; compatibilityResult =&lt;br/&gt;
-				serializerSnapshot.resolveSchemaCompatibility(byteOrderedElementSerializer);&lt;br/&gt;
+				existingState.getMetaInfo().updateElementSerializer(byteOrderedElementSerializer);&lt;br/&gt;
 &lt;br/&gt;
 			if (compatibilityResult.isIncompatible()) {&lt;br/&gt;
 				throw new FlinkRuntimeException(new StateMigrationException(&quot;For heap backends, the new priority queue serializer must not be incompatible.&quot;));&lt;br/&gt;
@@ -252,57 +229,42 @@ public HeapKeyedStateBackend(&lt;br/&gt;
 	private &amp;lt;N, V&amp;gt; StateTable&amp;lt;K, N, V&amp;gt; tryRegisterStateTable(&lt;br/&gt;
 			TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer,&lt;br/&gt;
 			StateDescriptor&amp;lt;?, V&amp;gt; stateDesc,&lt;br/&gt;
-			StateSnapshotTransformer&amp;lt;V&amp;gt; snapshotTransformer) throws StateMigrationException {&lt;br/&gt;
+			@Nullable StateSnapshotTransformer&amp;lt;V&amp;gt; snapshotTransformer) throws StateMigrationException {&lt;br/&gt;
 &lt;br/&gt;
 		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
 		StateTable&amp;lt;K, N, V&amp;gt; stateTable = (StateTable&amp;lt;K, N, V&amp;gt;) registeredKVStates.get(stateDesc.getName());&lt;br/&gt;
 &lt;br/&gt;
 		TypeSerializer&amp;lt;V&amp;gt; newStateSerializer = stateDesc.getSerializer();&lt;br/&gt;
-		RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, V&amp;gt; newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo&amp;lt;&amp;gt;(&lt;br/&gt;
-			stateDesc.getType(),&lt;br/&gt;
-			stateDesc.getName(),&lt;br/&gt;
-			namespaceSerializer,&lt;br/&gt;
-			newStateSerializer,&lt;br/&gt;
-			snapshotTransformer);&lt;br/&gt;
 &lt;br/&gt;
 		if (stateTable != null) {&lt;br/&gt;
-			@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
-			StateMetaInfoSnapshot restoredMetaInfoSnapshot =&lt;br/&gt;
-				restoredStateMetaInfo.get(&lt;br/&gt;
-					StateUID.of(stateDesc.getName(), StateMetaInfoSnapshot.BackendStateType.KEY_VALUE));&lt;br/&gt;
-&lt;br/&gt;
-			Preconditions.checkState(&lt;br/&gt;
-				restoredMetaInfoSnapshot != null,&lt;br/&gt;
-				&quot;Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo,&quot; +&lt;br/&gt;
-					&quot; but its corresponding restored snapshot cannot be found.&quot;);&lt;br/&gt;
+			RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, V&amp;gt; restoredKvMetaInfo = stateTable.getMetaInfo();&lt;br/&gt;
 &lt;br/&gt;
-			@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
-			TypeSerializerSnapshot&amp;lt;N&amp;gt; namespaceSerializerSnapshot = Preconditions.checkNotNull(&lt;br/&gt;
-				(TypeSerializerSnapshot&amp;lt;N&amp;gt;) restoredMetaInfoSnapshot.getTypeSerializerConfigSnapshot(&lt;br/&gt;
-					StateMetaInfoSnapshot.CommonSerializerKeys.NAMESPACE_SERIALIZER.toString()));&lt;br/&gt;
+			restoredKvMetaInfo.updateSnapshotTransformer(snapshotTransformer);&lt;br/&gt;
 &lt;br/&gt;
 			TypeSerializerSchemaCompatibility&amp;lt;N&amp;gt; namespaceCompatibility =&lt;br/&gt;
-				namespaceSerializerSnapshot.resolveSchemaCompatibility(namespaceSerializer);&lt;br/&gt;
-			if (namespaceCompatibility.isIncompatible()) {&lt;br/&gt;
-				throw new StateMigrationException(&quot;For heap backends, the new namespace serializer must not be incompatible.&quot;);&lt;br/&gt;
+				restoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer);&lt;br/&gt;
+			if (!namespaceCompatibility.isCompatibleAsIs()) {
+				throw new StateMigrationException(&quot;For heap backends, the new namespace serializer must be compatible.&quot;);
 			}&lt;br/&gt;
 &lt;br/&gt;
-			@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
-			TypeSerializerSnapshot&amp;lt;V&amp;gt; stateSerializerSnapshot = Preconditions.checkNotNull(&lt;br/&gt;
-				(TypeSerializerSnapshot&amp;lt;V&amp;gt;) restoredMetaInfoSnapshot.getTypeSerializerConfigSnapshot(&lt;br/&gt;
-					StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER.toString()));&lt;br/&gt;
-&lt;br/&gt;
-			RegisteredKeyValueStateBackendMetaInfo.checkStateMetaInfo(restoredMetaInfoSnapshot, stateDesc);&lt;br/&gt;
+			restoredKvMetaInfo.checkStateMetaInfo(stateDesc);&lt;br/&gt;
 &lt;br/&gt;
 			TypeSerializerSchemaCompatibility&amp;lt;V&amp;gt; stateCompatibility =&lt;br/&gt;
-				stateSerializerSnapshot.resolveSchemaCompatibility(newStateSerializer);&lt;br/&gt;
+				restoredKvMetaInfo.updateStateSerializer(newStateSerializer);&lt;br/&gt;
 &lt;br/&gt;
 			if (stateCompatibility.isIncompatible()) {
 				throw new StateMigrationException(&quot;For heap backends, the new state serializer must not be incompatible.&quot;);
 			}&lt;br/&gt;
 &lt;br/&gt;
-			stateTable.setMetaInfo(newMetaInfo);&lt;br/&gt;
+			stateTable.setMetaInfo(restoredKvMetaInfo);&lt;br/&gt;
 		} else {
+			RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, V&amp;gt; newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo&amp;lt;&amp;gt;(
+				stateDesc.getType(),
+				stateDesc.getName(),
+				namespaceSerializer,
+				newStateSerializer,
+				snapshotTransformer);
+
 			stateTable = snapshotStrategy.newStateTable(newMetaInfo);
 			registeredKVStates.put(stateDesc.getName(), stateTable);
 		}&lt;br/&gt;
@@ -536,10 +498,6 @@ private void createOrCheckStateForMetaInfo(&lt;br/&gt;
 		Map&amp;lt;Integer, StateMetaInfoSnapshot&amp;gt; kvStatesById) {&lt;br/&gt;
 &lt;br/&gt;
 		for (StateMetaInfoSnapshot metaInfoSnapshot : restoredMetaInfo) {&lt;br/&gt;
-			restoredStateMetaInfo.put(&lt;br/&gt;
-				StateUID.of(metaInfoSnapshot.getName(), metaInfoSnapshot.getBackendStateType()),&lt;br/&gt;
-				metaInfoSnapshot);&lt;br/&gt;
-&lt;br/&gt;
 			final StateSnapshotRestore registeredState;&lt;br/&gt;
 &lt;br/&gt;
 			switch (metaInfoSnapshot.getBackendStateType()) {&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/metainfo/StateMetaInfoSnapshot.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/metainfo/StateMetaInfoSnapshot.java&lt;br/&gt;
index 1e9d9191079..9b05500e4d0 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/state/metainfo/StateMetaInfoSnapshot.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/metainfo/StateMetaInfoSnapshot.java&lt;br/&gt;
@@ -81,7 +81,7 @@&lt;br/&gt;
 &lt;br/&gt;
 	/** The configurations of all the type serializers used with the state. */&lt;br/&gt;
 	@Nonnull&lt;br/&gt;
-	private final Map&amp;lt;String, TypeSerializerSnapshot&amp;lt;?&amp;gt;&amp;gt; serializerConfigSnapshots;&lt;br/&gt;
+	private final Map&amp;lt;String, TypeSerializerSnapshot&amp;lt;?&amp;gt;&amp;gt; serializerSnapshots;&lt;br/&gt;
 &lt;br/&gt;
 	// TODO this will go away once all serializers have the restoreSerializer() factory method properly implemented.&lt;br/&gt;
 	/** The serializers used by the state. */&lt;br/&gt;
@@ -92,8 +92,8 @@ public StateMetaInfoSnapshot(&lt;br/&gt;
 		@Nonnull String name,&lt;br/&gt;
 		@Nonnull BackendStateType backendStateType,&lt;br/&gt;
 		@Nonnull Map&amp;lt;String, String&amp;gt; options,&lt;br/&gt;
-		@Nonnull Map&amp;lt;String, TypeSerializerSnapshot&amp;lt;?&amp;gt;&amp;gt; serializerConfigSnapshots) {&lt;br/&gt;
-		this(name, backendStateType, options, serializerConfigSnapshots, new HashMap&amp;lt;&amp;gt;());&lt;br/&gt;
+		@Nonnull Map&amp;lt;String, TypeSerializerSnapshot&amp;lt;?&amp;gt;&amp;gt; serializerSnapshots) {
+		this(name, backendStateType, options, serializerSnapshots, new HashMap&amp;lt;&amp;gt;());
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -106,12 +106,12 @@ public StateMetaInfoSnapshot(&lt;br/&gt;
 		@Nonnull String name,&lt;br/&gt;
 		@Nonnull BackendStateType backendStateType,&lt;br/&gt;
 		@Nonnull Map&amp;lt;String, String&amp;gt; options,&lt;br/&gt;
-		@Nonnull Map&amp;lt;String, TypeSerializerSnapshot&amp;lt;?&amp;gt;&amp;gt; serializerConfigSnapshots,&lt;br/&gt;
+		@Nonnull Map&amp;lt;String, TypeSerializerSnapshot&amp;lt;?&amp;gt;&amp;gt; serializerSnapshots,&lt;br/&gt;
 		@Nonnull Map&amp;lt;String, TypeSerializer&amp;lt;?&amp;gt;&amp;gt; serializers) {
 		this.name = name;
 		this.backendStateType = backendStateType;
 		this.options = options;
-		this.serializerConfigSnapshots = serializerConfigSnapshots;
+		this.serializerSnapshots = serializerSnapshots;
 		this.serializers = serializers;
 	}&lt;br/&gt;
 &lt;br/&gt;
@@ -121,13 +121,13 @@ public BackendStateType getBackendStateType() {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Nullable&lt;br/&gt;
-	public TypeSerializerSnapshot&amp;lt;?&amp;gt; getTypeSerializerConfigSnapshot(@Nonnull String key) {&lt;br/&gt;
-		return serializerConfigSnapshots.get(key);&lt;br/&gt;
+	public TypeSerializerSnapshot&amp;lt;?&amp;gt; getTypeSerializerSnapshot(@Nonnull String key) {
+		return serializerSnapshots.get(key);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Nullable&lt;br/&gt;
-	public TypeSerializerSnapshot&amp;lt;?&amp;gt; getTypeSerializerConfigSnapshot(@Nonnull CommonSerializerKeys key) {&lt;br/&gt;
-		return getTypeSerializerConfigSnapshot(key.toString());&lt;br/&gt;
+	public TypeSerializerSnapshot&amp;lt;?&amp;gt; getTypeSerializerSnapshot(@Nonnull CommonSerializerKeys key) {
+		return getTypeSerializerSnapshot(key.toString());
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Nullable&lt;br/&gt;
@@ -150,20 +150,9 @@ public String getName() {
 		return name;
 	}&lt;br/&gt;
 &lt;br/&gt;
-	@Nullable&lt;br/&gt;
-	public TypeSerializer&amp;lt;?&amp;gt; restoreTypeSerializer(@Nonnull String key) {
-		TypeSerializerSnapshot&amp;lt;?&amp;gt; configSnapshot = getTypeSerializerConfigSnapshot(key);
-		return (configSnapshot != null) ? configSnapshot.restoreSerializer() : null;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	@Nullable&lt;br/&gt;
-	public TypeSerializer&amp;lt;?&amp;gt; restoreTypeSerializer(@Nonnull CommonSerializerKeys key) {
-		return restoreTypeSerializer(key.toString());
-	}&lt;br/&gt;
-&lt;br/&gt;
 	@Nonnull&lt;br/&gt;
-	public Map&amp;lt;String, TypeSerializerSnapshot&amp;lt;?&amp;gt;&amp;gt; getSerializerConfigSnapshotsImmutable() {&lt;br/&gt;
-		return Collections.unmodifiableMap(serializerConfigSnapshots);&lt;br/&gt;
+	public Map&amp;lt;String, TypeSerializerSnapshot&amp;lt;?&amp;gt;&amp;gt; getSerializerSnapshotsImmutable() {
+		return Collections.unmodifiableMap(serializerSnapshots);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/metainfo/StateMetaInfoSnapshotReadersWriters.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/metainfo/StateMetaInfoSnapshotReadersWriters.java&lt;br/&gt;
index 4408dfcacef..ad1e7be2871 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/state/metainfo/StateMetaInfoSnapshotReadersWriters.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/metainfo/StateMetaInfoSnapshotReadersWriters.java&lt;br/&gt;
@@ -165,7 +165,7 @@ public void writeStateMetaInfoSnapshot(&lt;br/&gt;
 			@Nonnull DataOutputView outputView) throws IOException {
 			final Map&amp;lt;String, String&amp;gt; optionsMap = snapshot.getOptionsImmutable();
 			final Map&amp;lt;String, TypeSerializerSnapshot&amp;lt;?&amp;gt;&amp;gt; serializerConfigSnapshotsMap =
-				snapshot.getSerializerConfigSnapshotsImmutable();
+				snapshot.getSerializerSnapshotsImmutable();
 
 			outputView.writeUTF(snapshot.getName());
 			outputView.writeInt(snapshot.getBackendStateType().ordinal());
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/SerializationProxiesTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/SerializationProxiesTest.java
index c1f08e06b3c..55aacb23057 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/SerializationProxiesTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/SerializationProxiesTest.java
@@ -251,7 +251,7 @@ private void assertEqualStateMetaInfoSnapshots(StateMetaInfoSnapshot expected, S
 		Assert.assertEquals(expected.getBackendStateType(), actual.getBackendStateType());
 		Assert.assertEquals(expected.getOptionsImmutable(), actual.getOptionsImmutable());
 		Assert.assertEquals(
-			expected.getSerializerConfigSnapshotsImmutable(),
-			actual.getSerializerConfigSnapshotsImmutable());
+			expected.getSerializerSnapshotsImmutable(),
+			actual.getSerializerSnapshotsImmutable());
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendMigrationTestBase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendMigrationTestBase.java&lt;br/&gt;
index f5f30d5037a..5511792673e 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendMigrationTestBase.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendMigrationTestBase.java&lt;br/&gt;
@@ -34,21 +34,20 @@&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.StateObjectCollection;&lt;br/&gt;
 import org.apache.flink.runtime.execution.Environment;&lt;br/&gt;
 import org.apache.flink.runtime.operators.testutils.DummyEnvironment;&lt;br/&gt;
-import org.apache.flink.runtime.state.heap.HeapPriorityQueueElement;&lt;br/&gt;
+import org.apache.flink.runtime.testutils.statemigration.TestType;&lt;br/&gt;
 import org.apache.flink.util.ExceptionUtils;&lt;br/&gt;
 import org.apache.flink.util.StateMigrationException;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
 import org.junit.Assert;&lt;br/&gt;
 import org.junit.Rule;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
 import org.junit.rules.TemporaryFolder;&lt;br/&gt;
 &lt;br/&gt;
-import javax.annotation.Nonnull;&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.util.Collections;&lt;br/&gt;
 import java.util.Iterator;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
-import java.util.Objects;&lt;br/&gt;
 import java.util.concurrent.RunnableFuture;&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
@@ -69,17 +68,6 @@&lt;br/&gt;
 	// lazily initialized stream storage&lt;br/&gt;
 	private CheckpointStorageLocation checkpointStorageLocation;&lt;br/&gt;
 &lt;br/&gt;
-	/**&lt;br/&gt;
-	 * The compatibility behaviour of {@link TestSerializer}.&lt;br/&gt;
-	 * This controls what format the serializer writes in, as well as&lt;br/&gt;
-	 * the result of the compatibility check against the prior serializer snapshot.&lt;br/&gt;
-	 */&lt;br/&gt;
-	public enum SerializerCompatibilityType {
-		COMPATIBLE_AS_IS,
-		REQUIRES_MIGRATION,
-		INCOMPATIBLE
-	}&lt;br/&gt;
-&lt;br/&gt;
 	// -------------------------------------------------------------------------------&lt;br/&gt;
 	//  Keyed state backend migration tests&lt;br/&gt;
 	// -------------------------------------------------------------------------------&lt;br/&gt;
@@ -95,7 +83,7 @@ public void testKeyedValueStateMigration() throws Exception {&lt;br/&gt;
 		try {&lt;br/&gt;
 			ValueStateDescriptor&amp;lt;TestType&amp;gt; kvId = new ValueStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS));&lt;br/&gt;
+				new TestType.V1TestTypeSerializer());&lt;br/&gt;
 			ValueState&amp;lt;TestType&amp;gt; valueState = backend&lt;br/&gt;
 				.getPartitionedState(VoidNamespace.INSTANCE, CustomVoidNamespaceSerializer.INSTANCE, kvId);&lt;br/&gt;
 &lt;br/&gt;
@@ -113,10 +101,10 @@ public void testKeyedValueStateMigration() throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 			backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot);&lt;br/&gt;
 &lt;br/&gt;
-			// the new serializer is REQUIRES_MIGRATION, and has a completely new serialization schema.&lt;br/&gt;
+			// the new serializer is V2, and has a completely new serialization schema.&lt;br/&gt;
 			kvId = new ValueStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.REQUIRES_MIGRATION));&lt;br/&gt;
+				new TestType.V2TestTypeSerializer());&lt;br/&gt;
 			valueState = backend&lt;br/&gt;
 				.getPartitionedState(VoidNamespace.INSTANCE, CustomVoidNamespaceSerializer.INSTANCE, kvId);&lt;br/&gt;
 &lt;br/&gt;
@@ -151,7 +139,7 @@ public void testKeyedListStateMigration() throws Exception {&lt;br/&gt;
 		try {&lt;br/&gt;
 			ListStateDescriptor&amp;lt;TestType&amp;gt; kvId = new ListStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS));&lt;br/&gt;
+				new TestType.V1TestTypeSerializer());&lt;br/&gt;
 			ListState&amp;lt;TestType&amp;gt; listState = backend&lt;br/&gt;
 				.getPartitionedState(VoidNamespace.INSTANCE, CustomVoidNamespaceSerializer.INSTANCE, kvId);&lt;br/&gt;
 &lt;br/&gt;
@@ -174,10 +162,10 @@ public void testKeyedListStateMigration() throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 			backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot);&lt;br/&gt;
 &lt;br/&gt;
-			// the new serializer is REQUIRES_MIGRATION, and has a completely new serialization schema.&lt;br/&gt;
+			// the new serializer is V2, and has a completely new serialization schema.&lt;br/&gt;
 			kvId = new ListStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.REQUIRES_MIGRATION));&lt;br/&gt;
+				new TestType.V2TestTypeSerializer());&lt;br/&gt;
 			listState = backend&lt;br/&gt;
 				.getPartitionedState(VoidNamespace.INSTANCE, CustomVoidNamespaceSerializer.INSTANCE, kvId);&lt;br/&gt;
 &lt;br/&gt;
@@ -221,7 +209,7 @@ public void testKeyedValueStateRegistrationFailsIfNewStateSerializerIsIncompatib&lt;br/&gt;
 		try {
 			ValueStateDescriptor&amp;lt;TestType&amp;gt; kvId = new ValueStateDescriptor&amp;lt;&amp;gt;(
 				stateName,
-				new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS));
+				new TestType.V1TestTypeSerializer());
 			ValueState&amp;lt;TestType&amp;gt; valueState = backend
 				.getPartitionedState(VoidNamespace.INSTANCE, CustomVoidNamespaceSerializer.INSTANCE, kvId);
 
@@ -241,10 +229,12 @@ public void testKeyedValueStateRegistrationFailsIfNewStateSerializerIsIncompatib
 
 			kvId = new ValueStateDescriptor&amp;lt;&amp;gt;(
 				stateName,
-				new TestSerializer(SerializerCompatibilityType.INCOMPATIBLE));
+				new TestType.IncompatibleTestTypeSerializer());
 
 			// the new serializer is INCOMPATIBLE, so registering the state should fail
 			backend.getPartitionedState(VoidNamespace.INSTANCE, CustomVoidNamespaceSerializer.INSTANCE, kvId);
+
+			Assert.fail(&quot;should have failed&quot;);
 		} catch (Exception e) {
 			Assert.assertTrue(ExceptionUtils.findThrowable(e, StateMigrationException.class).isPresent());
 		}finally {&lt;br/&gt;
@@ -263,7 +253,7 @@ public void testKeyedListStateRegistrationFailsIfNewStateSerializerIsIncompatibl&lt;br/&gt;
 		try {
 			ListStateDescriptor&amp;lt;TestType&amp;gt; kvId = new ListStateDescriptor&amp;lt;&amp;gt;(
 				stateName,
-				new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS));
+				new TestType.V1TestTypeSerializer());
 			ListState&amp;lt;TestType&amp;gt; listState = backend
 				.getPartitionedState(VoidNamespace.INSTANCE, CustomVoidNamespaceSerializer.INSTANCE, kvId);
 
@@ -288,10 +278,12 @@ public void testKeyedListStateRegistrationFailsIfNewStateSerializerIsIncompatibl
 
 			kvId = new ListStateDescriptor&amp;lt;&amp;gt;(
 				stateName,
-				new TestSerializer(SerializerCompatibilityType.REQUIRES_MIGRATION));
+				new TestType.IncompatibleTestTypeSerializer());
 
 			// the new serializer is INCOMPATIBLE, so registering the state should fail
 			backend.getPartitionedState(VoidNamespace.INSTANCE, CustomVoidNamespaceSerializer.INSTANCE, kvId);
+
+			Assert.fail(&quot;should have failed&quot;);
 		} catch (Exception e) { 			Assert.assertTrue(ExceptionUtils.findThrowable(e, StateMigrationException.class).isPresent()); 		} finally {&lt;br/&gt;
@@ -308,7 +300,7 @@ public void testPriorityQueueStateCreationFailsIfNewSerializerIsNotCompatible()&lt;br/&gt;
 &lt;br/&gt;
 		try {
 			InternalPriorityQueue&amp;lt;TestType&amp;gt; internalPriorityQueue = backend.create(
-				&quot;testPriorityQueue&quot;, new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS));
+				&quot;testPriorityQueue&quot;, new TestType.V1TestTypeSerializer());
 
 			internalPriorityQueue.add(new TestType(&quot;key-1&quot;, 123));
 			internalPriorityQueue.add(new TestType(&quot;key-2&quot;, 346));
@@ -321,7 +313,7 @@ public void testPriorityQueueStateCreationFailsIfNewSerializerIsNotCompatible()
 
 			backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot);
 			backend.create(
-				&quot;testPriorityQueue&quot;, new TestSerializer(SerializerCompatibilityType.INCOMPATIBLE));
+				&quot;testPriorityQueue&quot;, new TestType.IncompatibleTestTypeSerializer());
 
 			Assert.fail(&quot;should have failed&quot;);
 		} catch (Exception e) {&lt;br/&gt;
@@ -337,7 +329,7 @@ public void testStateBackendCreationFailsIfNewKeySerializerIsNotCompatible() thr&lt;br/&gt;
 		SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();&lt;br/&gt;
 &lt;br/&gt;
 		AbstractKeyedStateBackend&amp;lt;TestType&amp;gt; backend = createKeyedBackend(&lt;br/&gt;
-			new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS));&lt;br/&gt;
+			new TestType.V1TestTypeSerializer());&lt;br/&gt;
 &lt;br/&gt;
 		final String stateName = &quot;test-name&quot;;&lt;br/&gt;
 		try {&lt;br/&gt;
@@ -357,14 +349,18 @@ public void testStateBackendCreationFailsIfNewKeySerializerIsNotCompatible() thr&lt;br/&gt;
 &lt;br/&gt;
 			try {
 				// the new key serializer is incompatible; this should fail the restore
-				restoreKeyedBackend(new TestSerializer(SerializerCompatibilityType.INCOMPATIBLE), snapshot);
+				restoreKeyedBackend(new TestType.IncompatibleTestTypeSerializer(), snapshot);
+
+				Assert.fail(&quot;should have failed&quot;);
 			} catch (Exception e) {
 				Assert.assertTrue(ExceptionUtils.findThrowable(e, StateMigrationException.class).isPresent());
 			}&lt;br/&gt;
 &lt;br/&gt;
 			try {
 				// the new key serializer requires migration; this should fail the restore
-				restoreKeyedBackend(new TestSerializer(SerializerCompatibilityType.REQUIRES_MIGRATION), snapshot);
+				restoreKeyedBackend(new TestType.V2TestTypeSerializer(), snapshot);
+
+				Assert.fail(&quot;should have failed&quot;);
 			} catch (Exception e) { 				Assert.assertTrue(ExceptionUtils.findThrowable(e, StateMigrationException.class).isPresent()); 			}&lt;br/&gt;
@@ -386,7 +382,7 @@ public void testKeyedStateRegistrationFailsIfNewNamespaceSerializerIsNotCompatib&lt;br/&gt;
 			ValueState&amp;lt;Integer&amp;gt; valueState = backend&lt;br/&gt;
 				.getPartitionedState(&lt;br/&gt;
 					new TestType(&quot;namespace&quot;, 123),&lt;br/&gt;
-					new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS),&lt;br/&gt;
+					new TestType.V1TestTypeSerializer(),&lt;br/&gt;
 					kvId);&lt;br/&gt;
 &lt;br/&gt;
 			backend.setCurrentKey(1);&lt;br/&gt;
@@ -397,26 +393,33 @@ public void testKeyedStateRegistrationFailsIfNewNamespaceSerializerIsNotCompatib&lt;br/&gt;
 			KeyedStateHandle snapshot = runSnapshot(&lt;br/&gt;
 				backend.snapshot(1L, 2L, streamFactory, CheckpointOptions.forCheckpointWithDefaultLocation()),&lt;br/&gt;
 				sharedStateRegistry);&lt;br/&gt;
-			backend.dispose();&lt;br/&gt;
 &lt;br/&gt;
+			// test incompatible namespace serializer; start with a freshly restored backend&lt;br/&gt;
+			backend.dispose();&lt;br/&gt;
 			backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot);&lt;br/&gt;
-&lt;br/&gt;
 			try {
 				// the new namespace serializer is incompatible; this should fail the restore
 				backend.getPartitionedState(
 					new TestType(&quot;namespace&quot;, 123),
-					new TestSerializer(SerializerCompatibilityType.INCOMPATIBLE),
+					new TestType.IncompatibleTestTypeSerializer(),
 					kvId);
+
+				Assert.fail(&quot;should have failed&quot;);
 			} catch (Exception e) {
 				Assert.assertTrue(ExceptionUtils.findThrowable(e, StateMigrationException.class).isPresent());
 			}&lt;br/&gt;
 &lt;br/&gt;
+			// test namespace serializer that requires migration; start with a freshly restored backend&lt;br/&gt;
+			backend.dispose();&lt;br/&gt;
+			backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot);&lt;br/&gt;
 			try {
 				// the new namespace serializer requires migration; this should fail the restore
 				backend.getPartitionedState(
 					new TestType(&quot;namespace&quot;, 123),
-					new TestSerializer(SerializerCompatibilityType.REQUIRES_MIGRATION),
+					new TestType.V2TestTypeSerializer(),
 					kvId);
+
+				Assert.fail(&quot;should have failed&quot;);
 			} catch (Exception e) { 				Assert.assertTrue(ExceptionUtils.findThrowable(e, StateMigrationException.class).isPresent()); 			}&lt;br/&gt;
@@ -439,7 +442,7 @@ public void testOperatorParitionableListStateMigration() throws Exception {&lt;br/&gt;
 		try {&lt;br/&gt;
 			ListStateDescriptor&amp;lt;TestType&amp;gt; descriptor = new ListStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS));&lt;br/&gt;
+				new TestType.V1TestTypeSerializer());&lt;br/&gt;
 			ListState&amp;lt;TestType&amp;gt; state = backend.getListState(descriptor);&lt;br/&gt;
 &lt;br/&gt;
 			state.add(new TestType(&quot;foo&quot;, 13));&lt;br/&gt;
@@ -453,7 +456,7 @@ public void testOperatorParitionableListStateMigration() throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 			descriptor = new ListStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.REQUIRES_MIGRATION));&lt;br/&gt;
+				new TestType.V2TestTypeSerializer());&lt;br/&gt;
 			state = backend.getListState(descriptor);&lt;br/&gt;
 &lt;br/&gt;
 			// the state backend should have decided whether or not it needs to perform state migration;&lt;br/&gt;
@@ -478,7 +481,7 @@ public void testUnionListStateMigration() throws Exception {&lt;br/&gt;
 		try {&lt;br/&gt;
 			ListStateDescriptor&amp;lt;TestType&amp;gt; descriptor = new ListStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS));&lt;br/&gt;
+				new TestType.V1TestTypeSerializer());&lt;br/&gt;
 			ListState&amp;lt;TestType&amp;gt; state = backend.getUnionListState(descriptor);&lt;br/&gt;
 &lt;br/&gt;
 			state.add(new TestType(&quot;foo&quot;, 13));&lt;br/&gt;
@@ -492,7 +495,7 @@ public void testUnionListStateMigration() throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 			descriptor = new ListStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.REQUIRES_MIGRATION));&lt;br/&gt;
+				new TestType.V2TestTypeSerializer());&lt;br/&gt;
 			state = backend.getUnionListState(descriptor);&lt;br/&gt;
 &lt;br/&gt;
 			// the state backend should have decided whether or not it needs to perform state migration;&lt;br/&gt;
@@ -518,7 +521,7 @@ public void testBroadcastStateValueMigration() throws Exception {&lt;br/&gt;
 			MapStateDescriptor&amp;lt;Integer, TestType&amp;gt; descriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
 				IntSerializer.INSTANCE,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS));&lt;br/&gt;
+				new TestType.V1TestTypeSerializer());&lt;br/&gt;
 			BroadcastState&amp;lt;Integer, TestType&amp;gt; state = backend.getBroadcastState(descriptor);&lt;br/&gt;
 &lt;br/&gt;
 			state.put(3, new TestType(&quot;foo&quot;, 13));&lt;br/&gt;
@@ -533,7 +536,7 @@ public void testBroadcastStateValueMigration() throws Exception {&lt;br/&gt;
 			descriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
 				IntSerializer.INSTANCE,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.REQUIRES_MIGRATION));&lt;br/&gt;
+				new TestType.V2TestTypeSerializer());&lt;br/&gt;
 			state = backend.getBroadcastState(descriptor);&lt;br/&gt;
 &lt;br/&gt;
 			// the state backend should have decided whether or not it needs to perform state migration;&lt;br/&gt;
@@ -556,7 +559,7 @@ public void testBroadcastStateKeyMigration() throws Exception {&lt;br/&gt;
 		try {&lt;br/&gt;
 			MapStateDescriptor&amp;lt;TestType, Integer&amp;gt; descriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS),&lt;br/&gt;
+				new TestType.V1TestTypeSerializer(),&lt;br/&gt;
 				IntSerializer.INSTANCE);&lt;br/&gt;
 			BroadcastState&amp;lt;TestType, Integer&amp;gt; state = backend.getBroadcastState(descriptor);&lt;br/&gt;
 &lt;br/&gt;
@@ -571,7 +574,7 @@ public void testBroadcastStateKeyMigration() throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 			descriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.REQUIRES_MIGRATION),&lt;br/&gt;
+				new TestType.V2TestTypeSerializer(),&lt;br/&gt;
 				IntSerializer.INSTANCE);&lt;br/&gt;
 			state = backend.getBroadcastState(descriptor);&lt;br/&gt;
 &lt;br/&gt;
@@ -595,7 +598,7 @@ public void testOperatorParitionableListStateRegistrationFailsIfNewSerializerIsI&lt;br/&gt;
 		try {&lt;br/&gt;
 			ListStateDescriptor&amp;lt;TestType&amp;gt; descriptor = new ListStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS));&lt;br/&gt;
+				new TestType.V1TestTypeSerializer());&lt;br/&gt;
 			ListState&amp;lt;TestType&amp;gt; state = backend.getListState(descriptor);&lt;br/&gt;
 &lt;br/&gt;
 			state.add(new TestType(&quot;foo&quot;, 13));&lt;br/&gt;
@@ -609,7 +612,7 @@ public void testOperatorParitionableListStateRegistrationFailsIfNewSerializerIsI&lt;br/&gt;
 &lt;br/&gt;
 			descriptor = new ListStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
 				stateName,&lt;br/&gt;
-				new TestSerializer(SerializerCompatibilityType.INCOMPATIBLE));&lt;br/&gt;
+				new TestType.IncompatibleTestTypeSerializer());&lt;br/&gt;
 &lt;br/&gt;
 			// the new serializer is INCOMPATIBLE, so registering the state should fail&lt;br/&gt;
 			backend.getListState(descriptor);&lt;br/&gt;
@@ -632,7 +635,7 @@ public void testUnionListStateRegistrationFailsIfNewSerializerIsIncompatible() t&lt;br/&gt;
 		try {
 			ListStateDescriptor&amp;lt;TestType&amp;gt; descriptor = new ListStateDescriptor&amp;lt;&amp;gt;(
 				stateName,
-				new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS));
+				new TestType.V1TestTypeSerializer());
 			ListState&amp;lt;TestType&amp;gt; state = backend.getUnionListState(descriptor);
 
 			state.add(new TestType(&quot;foo&quot;, 13));
@@ -646,7 +649,7 @@ public void testUnionListStateRegistrationFailsIfNewSerializerIsIncompatible() t
 
 			descriptor = new ListStateDescriptor&amp;lt;&amp;gt;(
 				stateName,
-				new TestSerializer(SerializerCompatibilityType.INCOMPATIBLE));
+				new TestType.IncompatibleTestTypeSerializer());
 
 			// the new serializer is INCOMPATIBLE, so registering the state should fail
 			backend.getUnionListState(descriptor);
@@ -670,7 +673,7 @@ public void testBroadcastStateRegistrationFailsIfNewValueSerializerIsIncompatibl
 			MapStateDescriptor&amp;lt;Integer, TestType&amp;gt; descriptor = new MapStateDescriptor&amp;lt;&amp;gt;(
 				stateName,
 				IntSerializer.INSTANCE,
-				new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS));
+				new TestType.V1TestTypeSerializer());
 			BroadcastState&amp;lt;Integer, TestType&amp;gt; state = backend.getBroadcastState(descriptor);
 
 			state.put(3, new TestType(&quot;foo&quot;, 13));
@@ -685,10 +688,12 @@ public void testBroadcastStateRegistrationFailsIfNewValueSerializerIsIncompatibl
 			descriptor = new MapStateDescriptor&amp;lt;&amp;gt;(
 				stateName,
 				IntSerializer.INSTANCE,
-				new TestSerializer(SerializerCompatibilityType.REQUIRES_MIGRATION));
+				new TestType.IncompatibleTestTypeSerializer());
 
 			// the new value serializer is INCOMPATIBLE, so registering the state should fail
 			backend.getBroadcastState(descriptor);
+
+			Assert.fail(&quot;should have failed.&quot;);
 		} catch (Exception e) {
 			Assert.assertTrue(ExceptionUtils.findThrowable(e, StateMigrationException.class).isPresent());
 		} finally {&lt;br/&gt;
@@ -706,7 +711,7 @@ public void testBroadcastStateRegistrationFailsIfNewKeySerializerIsIncompatible(&lt;br/&gt;
 		try {
 			MapStateDescriptor&amp;lt;TestType, Integer&amp;gt; descriptor = new MapStateDescriptor&amp;lt;&amp;gt;(
 				stateName,
-				new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS),
+				new TestType.V1TestTypeSerializer(),
 				IntSerializer.INSTANCE);
 			BroadcastState&amp;lt;TestType, Integer&amp;gt; state = backend.getBroadcastState(descriptor);
 
@@ -721,11 +726,13 @@ public void testBroadcastStateRegistrationFailsIfNewKeySerializerIsIncompatible(
 
 			descriptor = new MapStateDescriptor&amp;lt;&amp;gt;(
 				stateName,
-				new TestSerializer(SerializerCompatibilityType.INCOMPATIBLE),
+				new TestType.IncompatibleTestTypeSerializer(),
 				IntSerializer.INSTANCE);
 
 			// the new key serializer is INCOMPATIBLE, so registering the state should fail
 			backend.getBroadcastState(descriptor);
+
+			Assert.fail(&quot;should have failed.&quot;);
 		} catch (Exception e) { 			Assert.assertTrue(ExceptionUtils.findThrowable(e, StateMigrationException.class).isPresent()); 		} finally {&lt;br/&gt;
@@ -737,223 +744,6 @@ public void testBroadcastStateRegistrationFailsIfNewKeySerializerIsIncompatible(&lt;br/&gt;
 	//  Test types, serializers, and serializer snapshots&lt;br/&gt;
 	// -------------------------------------------------------------------------------&lt;br/&gt;
 &lt;br/&gt;
-	/**&lt;br/&gt;
-	 * The type used as state under tests.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;This is implemented so that the type can also be used as keyed priority queue state.&lt;br/&gt;
-	 */&lt;br/&gt;
-	private static class TestType implements HeapPriorityQueueElement, PriorityComparable&amp;lt;TestType&amp;gt;, Keyed&amp;lt;String&amp;gt; {&lt;br/&gt;
-&lt;br/&gt;
-		private int index;&lt;br/&gt;
-&lt;br/&gt;
-		private final int value;&lt;br/&gt;
-		private final String key;&lt;br/&gt;
-&lt;br/&gt;
-		public TestType(String key, int value) {
-			this.key = key;
-			this.value = value;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public String getKey() {
-			return key;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public int comparePriorityTo(@Nonnull TestType other) {
-			return Integer.compare(value, other.value);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public int getInternalIndex() {
-			return index;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public void setInternalIndex(int newIndex) {
-			this.index = newIndex;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public boolean equals(Object obj) {&lt;br/&gt;
-			if (obj == null || !(obj instanceof StateBackendMigrationTestBase.TestType)) {
-				return false;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			if (obj == this) {
-				return true;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			TestType other = (TestType) obj;&lt;br/&gt;
-			return Objects.equals(key, other.key) &amp;amp;&amp;amp; value == other.value;&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public int hashCode() {
-			return 31 * key.hashCode() + value;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private static class TestSerializer extends TypeSerializer&amp;lt;TestType&amp;gt; {&lt;br/&gt;
-&lt;br/&gt;
-		private static final String MIGRATION_PAYLOAD = &quot;random-migration-payload&quot;;&lt;br/&gt;
-&lt;br/&gt;
-		private final SerializerCompatibilityType compatibilityType;&lt;br/&gt;
-&lt;br/&gt;
-		TestSerializer(SerializerCompatibilityType compatibilityType) {
-			this.compatibilityType = compatibilityType;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		// --------------------------------------------------------------------------------&lt;br/&gt;
-		//  State serialization relevant methods&lt;br/&gt;
-		// --------------------------------------------------------------------------------&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public void serialize(TestType record, DataOutputView target) throws IOException {&lt;br/&gt;
-			switch (compatibilityType) {
-				case COMPATIBLE_AS_IS:
-					target.writeUTF(record.getKey());
-					target.writeInt(record.value);
-					break;
-
-				case REQUIRES_MIGRATION:
-					target.writeUTF(record.getKey());
-					target.writeUTF(MIGRATION_PAYLOAD);
-					target.writeInt(record.value);
-					target.writeBoolean(true);
-					break;
-
-				case INCOMPATIBLE:
-					// the serializer shouldn&apos;t be used in this case
-					throw new UnsupportedOperationException();
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public TestType deserialize(DataInputView source) throws IOException {&lt;br/&gt;
-			String key;&lt;br/&gt;
-			int value;&lt;br/&gt;
-&lt;br/&gt;
-			switch (compatibilityType) {
-				case COMPATIBLE_AS_IS:
-					key = source.readUTF();
-					value = source.readInt();
-					break;
-
-				case REQUIRES_MIGRATION:
-					key = source.readUTF();
-					Assert.assertEquals(MIGRATION_PAYLOAD, source.readUTF());
-					value = source.readInt();
-					Assert.assertTrue(source.readBoolean());
-					break;
-
-				default:
-				case INCOMPATIBLE:
-					// the serializer shouldn&apos;t be used in this case
-					throw new UnsupportedOperationException();
-			}&lt;br/&gt;
-&lt;br/&gt;
-			return new TestType(key, value);&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public TestType copy(TestType from) {
-			return new TestType(from.key, from.value);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public TypeSerializerSnapshot&amp;lt;TestType&amp;gt; snapshotConfiguration() {
-			return new TestSerializerSnapshot();
-		}&lt;br/&gt;
-&lt;br/&gt;
-		// --------------------------------------------------------------------------------&lt;br/&gt;
-		//  Miscellaneous serializer methods&lt;br/&gt;
-		// --------------------------------------------------------------------------------&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public void copy(DataInputView source, DataOutputView target) throws IOException {
-			serialize(deserialize(source), target);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public TestType deserialize(TestType reuse, DataInputView source) throws IOException {
-			return deserialize(source);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public TestType copy(TestType from, TestType reuse) {
-			return copy(from);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public TestType createInstance() {
-			throw new UnsupportedOperationException();
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public TypeSerializer&amp;lt;TestType&amp;gt; duplicate() {
-			return this;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public boolean isImmutableType() {
-			return false;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public int getLength() {
-			return -1;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public boolean canEqual(Object obj) {
-			return getClass().equals(obj.getClass());
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public int hashCode() {
-			return getClass().hashCode();
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public boolean equals(Object obj) {
-			return obj == this;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	public static class TestSerializerSnapshot implements TypeSerializerSnapshot&amp;lt;TestType&amp;gt; {&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public int getCurrentVersion() {
-			return 1;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public TypeSerializer&amp;lt;TestType&amp;gt; restoreSerializer() {
-			return new TestSerializer(SerializerCompatibilityType.COMPATIBLE_AS_IS);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public TypeSerializerSchemaCompatibility&amp;lt;TestType&amp;gt; resolveSchemaCompatibility(TypeSerializer&amp;lt;TestType&amp;gt; newSerializer) {&lt;br/&gt;
-			switch (((TestSerializer) newSerializer).compatibilityType) {
-				case COMPATIBLE_AS_IS:
-					return TypeSerializerSchemaCompatibility.compatibleAsIs();
-				case REQUIRES_MIGRATION:
-					return TypeSerializerSchemaCompatibility.compatibleAfterMigration();
-				case INCOMPATIBLE:
-					return TypeSerializerSchemaCompatibility.incompatible();
-				default:
-					throw new UnsupportedOperationException();
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public void writeSnapshot(DataOutputView out) throws IOException {}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public void readSnapshot(int readVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
 	public static class CustomVoidNamespaceSerializer extends TypeSerializer&amp;lt;VoidNamespace&amp;gt; {&lt;br/&gt;
 &lt;br/&gt;
 		private static final long serialVersionUID = 1L;&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java&lt;br/&gt;
index 54cac1ea177..a9bd1f694a3 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java&lt;br/&gt;
@@ -149,14 +149,6 @@&lt;br/&gt;
 	@Rule&lt;br/&gt;
 	public final ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
 &lt;br/&gt;
-	/**&lt;br/&gt;
-	 * The serialization timeliness behaviour of the state backend under test.&lt;br/&gt;
-	 */&lt;br/&gt;
-	public enum BackendSerializationTimeliness {
-		ON_ACCESS,
-		ON_CHECKPOINTS
-	}&lt;br/&gt;
-&lt;br/&gt;
 	// lazily initialized stream storage&lt;br/&gt;
 	private CheckpointStorageLocation checkpointStorageLocation;&lt;br/&gt;
 &lt;br/&gt;
@@ -3145,6 +3137,57 @@ public void testMapStateDefaultValue() throws Exception {
 		backend.dispose();
 	}&lt;br/&gt;
 &lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testSnapshotNonAccessedState() throws Exception {&lt;br/&gt;
+		CheckpointStreamFactory streamFactory = createStreamFactory();&lt;br/&gt;
+		SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();&lt;br/&gt;
+		AbstractKeyedStateBackend&amp;lt;String&amp;gt; backend = createKeyedBackend(StringSerializer.INSTANCE);&lt;br/&gt;
+&lt;br/&gt;
+		final String stateName = &quot;test-name&quot;;&lt;br/&gt;
+		try {
+			MapStateDescriptor&amp;lt;Integer, String&amp;gt; kvId = new MapStateDescriptor&amp;lt;&amp;gt;(stateName, Integer.class, String.class);
+			MapState&amp;lt;Integer, String&amp;gt; mapState = backend
+				.getPartitionedState(VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+
+			// write some state to be snapshotted
+			backend.setCurrentKey(&quot;1&quot;);
+			mapState.put(11, &quot;foo&quot;);
+			backend.setCurrentKey(&quot;2&quot;);
+			mapState.put(8, &quot;bar&quot;);
+			backend.setCurrentKey(&quot;3&quot;);
+			mapState.put(91, &quot;hello world&quot;);
+
+			// take a snapshot, and then restore backend with snapshot
+			KeyedStateHandle snapshot = runSnapshot(
+				backend.snapshot(1L, 2L, streamFactory, CheckpointOptions.forCheckpointWithDefaultLocation()),
+				sharedStateRegistry);
+			backend.dispose();
+
+			backend = restoreKeyedBackend(StringSerializer.INSTANCE, snapshot);
+
+			// now take a snapshot again without accessing the state
+			snapshot = runSnapshot(
+				backend.snapshot(2L, 3L, streamFactory, CheckpointOptions.forCheckpointWithDefaultLocation()),
+				sharedStateRegistry);
+			backend.dispose();
+
+			// we restore again and try to access previous state
+			backend = restoreKeyedBackend(StringSerializer.INSTANCE, snapshot);
+			mapState = backend.getPartitionedState(VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+
+			backend.setCurrentKey(&quot;1&quot;);
+			assertEquals(&quot;foo&quot;, mapState.get(11));
+			backend.setCurrentKey(&quot;2&quot;);
+			assertEquals(&quot;bar&quot;, mapState.get(8));
+			backend.setCurrentKey(&quot;3&quot;);
+			assertEquals(&quot;hello world&quot;, mapState.get(91));
+
+			snapshot.discardState();
+		} finally {
+			backend.dispose();
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	/**&lt;br/&gt;
 	 * This test verifies that state is correctly assigned to key groups and that restore&lt;br/&gt;
 	 * restores the relevant key groups in the backend.&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateSerializerProviderTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateSerializerProviderTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..de1f2bd962c&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateSerializerProviderTest.java&lt;br/&gt;
@@ -0,0 +1,187 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.state;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.runtime.testutils.statemigration.TestType;&lt;br/&gt;
+&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+import static org.junit.Assert.fail;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Test suit for {@link StateSerializerProvider}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class StateSerializerProviderTest {&lt;br/&gt;
+&lt;br/&gt;
+	// --------------------------------------------------------------------------------&lt;br/&gt;
+	//  Tests for #currentSchemaSerializer()&lt;br/&gt;
+	// --------------------------------------------------------------------------------&lt;br/&gt;
+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testCurrentSchemaSerializerForNewStateSerializerProvider() &lt;/p&gt;
{
+		StateSerializerProvider&amp;lt;TestType&amp;gt; testProvider = StateSerializerProvider.fromNewState(new TestType.V1TestTypeSerializer());
+		assertTrue(testProvider.currentSchemaSerializer() instanceof TestType.V1TestTypeSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testCurrentSchemaSerializerForRestoredStateSerializerProvider() &lt;/p&gt;
{
+		TestType.V1TestTypeSerializer serializer = new TestType.V1TestTypeSerializer();
+		StateSerializerProvider&amp;lt;TestType&amp;gt; testProvider = StateSerializerProvider.fromRestoredState(serializer.snapshotConfiguration());
+		assertTrue(testProvider.currentSchemaSerializer() instanceof TestType.V1TestTypeSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	// --------------------------------------------------------------------------------&lt;br/&gt;
+	//  Tests for #previousSchemaSerializer()&lt;br/&gt;
+	// --------------------------------------------------------------------------------&lt;br/&gt;
+&lt;br/&gt;
+	@Test(expected = UnsupportedOperationException.class)&lt;br/&gt;
+	public void testPreviousSchemaSerializerForNewStateSerializerProvider() &lt;/p&gt;
{
+		StateSerializerProvider&amp;lt;TestType&amp;gt; testProvider = StateSerializerProvider.fromNewState(new TestType.V1TestTypeSerializer());
+
+		// this should fail with an exception
+		testProvider.previousSchemaSerializer();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testPreviousSchemaSerializerForRestoredStateSerializerProvider() &lt;/p&gt;
{
+		TestType.V1TestTypeSerializer serializer = new TestType.V1TestTypeSerializer();
+		StateSerializerProvider&amp;lt;TestType&amp;gt; testProvider = StateSerializerProvider.fromRestoredState(serializer.snapshotConfiguration());
+		assertTrue(testProvider.previousSchemaSerializer() instanceof TestType.V1TestTypeSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testLazyInstantiationOfPreviousSchemaSerializer() {&lt;br/&gt;
+		// create the provider with an exception throwing snapshot;&lt;br/&gt;
+		// this would throw an exception if the restore serializer was eagerly accessed&lt;br/&gt;
+		StateSerializerProvider&amp;lt;String&amp;gt; testProvider =&lt;br/&gt;
+			StateSerializerProvider.fromRestoredState(new ExceptionThrowingSerializerSnapshot());&lt;br/&gt;
+&lt;br/&gt;
+		try &lt;/p&gt;
{
+			// if we fail here, that means the restore serializer was indeed lazily accessed
+			testProvider.previousSchemaSerializer();
+			fail(&quot;expected to fail when accessing the restore serializer.&quot;);
+		}
&lt;p&gt; catch (Exception expected) &lt;/p&gt;
{
+			// success
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	// --------------------------------------------------------------------------------&lt;br/&gt;
+	//  Tests for #registerNewSerializerForRestoredState(TypeSerializer)&lt;br/&gt;
+	// --------------------------------------------------------------------------------&lt;br/&gt;
+&lt;br/&gt;
+	@Test(expected = UnsupportedOperationException.class)&lt;br/&gt;
+	public void testRegisterNewSerializerWithNewStateSerializerProviderShouldFail() {
+		StateSerializerProvider&amp;lt;TestType&amp;gt; testProvider = StateSerializerProvider.fromNewState(new TestType.V1TestTypeSerializer());
+		testProvider.registerNewSerializerForRestoredState(new TestType.V2TestTypeSerializer());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Test(expected = UnsupportedOperationException.class)&lt;br/&gt;
+	public void testRegisterNewSerializerTwiceWithNewStateSerializerProviderShouldFail() {
+		TestType.V1TestTypeSerializer serializer = new TestType.V1TestTypeSerializer();
+		StateSerializerProvider&amp;lt;TestType&amp;gt; testProvider = StateSerializerProvider.fromRestoredState(serializer.snapshotConfiguration());
+
+		testProvider.registerNewSerializerForRestoredState(new TestType.V2TestTypeSerializer());
+
+		// second registration should fail
+		testProvider.registerNewSerializerForRestoredState(new TestType.V2TestTypeSerializer());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testRegisterNewCompatibleAsIsSerializer() {
+		TestType.V1TestTypeSerializer serializer = new TestType.V1TestTypeSerializer();
+		StateSerializerProvider&amp;lt;TestType&amp;gt; testProvider = StateSerializerProvider.fromRestoredState(serializer.snapshotConfiguration());
+
+		// register compatible serializer for state
+		TypeSerializerSchemaCompatibility&amp;lt;TestType&amp;gt; schemaCompatibility =
+			testProvider.registerNewSerializerForRestoredState(new TestType.V1TestTypeSerializer());
+		assertTrue(schemaCompatibility.isCompatibleAsIs());
+
+		assertTrue(testProvider.currentSchemaSerializer() instanceof TestType.V1TestTypeSerializer);
+		assertTrue(testProvider.previousSchemaSerializer() instanceof TestType.V1TestTypeSerializer);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testRegisterNewCompatibleAfterMigrationSerializer() {
+		TestType.V1TestTypeSerializer serializer = new TestType.V1TestTypeSerializer();
+		StateSerializerProvider&amp;lt;TestType&amp;gt; testProvider = StateSerializerProvider.fromRestoredState(serializer.snapshotConfiguration());
+
+		// register serializer that requires migration for state
+		TypeSerializerSchemaCompatibility&amp;lt;TestType&amp;gt; schemaCompatibility =
+			testProvider.registerNewSerializerForRestoredState(new TestType.V2TestTypeSerializer());
+		assertTrue(schemaCompatibility.isCompatibleAfterMigration());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testRegisterIncompatibleSerializer() {&lt;br/&gt;
+		TestType.V1TestTypeSerializer serializer = new TestType.V1TestTypeSerializer();&lt;br/&gt;
+		StateSerializerProvider&amp;lt;TestType&amp;gt; testProvider = StateSerializerProvider.fromRestoredState(serializer.snapshotConfiguration());&lt;br/&gt;
+&lt;br/&gt;
+		// register serializer that requires migration for state&lt;br/&gt;
+		TypeSerializerSchemaCompatibility&amp;lt;TestType&amp;gt; schemaCompatibility =&lt;br/&gt;
+			testProvider.registerNewSerializerForRestoredState(new TestType.IncompatibleTestTypeSerializer());&lt;br/&gt;
+		assertTrue(schemaCompatibility.isIncompatible());&lt;br/&gt;
+&lt;br/&gt;
+		try {
+			// a serializer for the current schema will no longer be accessible
+			testProvider.currentSchemaSerializer();
+		} catch (Exception excepted) {+			// success+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	// --------------------------------------------------------------------------------&lt;br/&gt;
+	//  Utilities&lt;br/&gt;
+	// --------------------------------------------------------------------------------&lt;br/&gt;
+&lt;br/&gt;
+	public static class ExceptionThrowingSerializerSnapshot implements TypeSerializerSnapshot&amp;lt;String&amp;gt; {&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public TypeSerializer&amp;lt;String&amp;gt; restoreSerializer() &lt;/p&gt;
{
+			throw new UnsupportedOperationException();
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public void writeSnapshot(DataOutputView out) throws IOException {+			throw new UnsupportedOperationException();+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public void readSnapshot(int readVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException &lt;/p&gt;
{
+			throw new UnsupportedOperationException();
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public TypeSerializerSchemaCompatibility&amp;lt;String&amp;gt; resolveSchemaCompatibility(TypeSerializer&amp;lt;String&amp;gt; newSerializer) {+			throw new UnsupportedOperationException();+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public int getCurrentVersion() &lt;/p&gt;
{
+			throw new UnsupportedOperationException();
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/statemigration/TestType.java b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/statemigration/TestType.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..e3b0a066e51&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/statemigration/TestType.java&lt;br/&gt;
@@ -0,0 +1,237 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.testutils.statemigration;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.runtime.state.Keyed;&lt;br/&gt;
+import org.apache.flink.runtime.state.PriorityComparable;&lt;br/&gt;
+import org.apache.flink.runtime.state.heap.HeapPriorityQueueElement;&lt;br/&gt;
+import org.junit.Assert;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.Objects;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * A data type used as state in state migration tests.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;This is implemented so that the type can also be used as keyed priority queue state.&lt;br/&gt;
+ */&lt;br/&gt;
+public class TestType implements HeapPriorityQueueElement, PriorityComparable&amp;lt;TestType&amp;gt;, Keyed&amp;lt;String&amp;gt; {&lt;br/&gt;
+&lt;br/&gt;
+    private int index;&lt;br/&gt;
+&lt;br/&gt;
+    private final int value;&lt;br/&gt;
+    private final String key;&lt;br/&gt;
+&lt;br/&gt;
+    public TestType(String key, int value) {
+        this.key = key;
+        this.value = value;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public String getKey() {
+        return key;
+    }&lt;br/&gt;
+&lt;br/&gt;
+	public int getValue() {
+		return value;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+    public int comparePriorityTo(@Nonnull TestType other) {
+        return Integer.compare(value, other.value);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public int getInternalIndex() {
+        return index;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void setInternalIndex(int newIndex) {
+        this.index = newIndex;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public boolean equals(Object obj) {&lt;br/&gt;
+        if (obj == null || !(obj instanceof TestType)) {
+            return false;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        if (obj == this) {
+            return true;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        TestType other = (TestType) obj;&lt;br/&gt;
+        return Objects.equals(key, other.key) &amp;amp;&amp;amp; value == other.value;&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public int hashCode() {
+        return 31 * key.hashCode() + value;
+    }&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * A serializer that read / writes {@link TestType} in schema version 1.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static class V1TestTypeSerializer extends TestTypeSerializerBase {&lt;br/&gt;
+		private static final long serialVersionUID = 5053346160938769779L;&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public void serialize(TestType record, DataOutputView target) throws IOException {
+			target.writeUTF(record.getKey());
+			target.writeInt(record.getValue());
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public TestType deserialize(DataInputView source) throws IOException {
+			return new TestType(source.readUTF(), source.readInt());
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public TypeSerializerSnapshot&amp;lt;TestType&amp;gt; snapshotConfiguration() {
+			return new V1TestTypeSerializerSnapshot();
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * A serializer that read / writes {@link TestType} in schema version 2.&lt;br/&gt;
+	 * Migration is required if the state was previously written with {@link V1TestTypeSerializer}.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static class V2TestTypeSerializer extends TestTypeSerializerBase {&lt;br/&gt;
+&lt;br/&gt;
+		private static final long serialVersionUID = 7199590310936186578L;&lt;br/&gt;
+&lt;br/&gt;
+		private static final String RANDOM_PAYLOAD = &quot;random-payload&quot;;&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public void serialize(TestType record, DataOutputView target) throws IOException {
+			target.writeUTF(record.getKey());
+			target.writeUTF(RANDOM_PAYLOAD);
+			target.writeInt(record.getValue());
+			target.writeBoolean(true);
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public TestType deserialize(DataInputView source) throws IOException {
+			String key = source.readUTF();
+			Assert.assertEquals(RANDOM_PAYLOAD, source.readUTF());
+			int value = source.readInt();
+			Assert.assertTrue(source.readBoolean());
+
+			return new TestType(key, value);
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public TypeSerializerSnapshot&amp;lt;TestType&amp;gt; snapshotConfiguration() {
+			return new V1TestTypeSerializerSnapshot();
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * A serializer that is meant to be incompatible with any of the serializers.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static class IncompatibleTestTypeSerializer extends TestTypeSerializerBase {&lt;br/&gt;
+&lt;br/&gt;
+		private static final long serialVersionUID = -2959080770523247215L;&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public void serialize(TestType record, DataOutputView target) throws IOException {
+			throw new UnsupportedOperationException(&quot;This is an incompatible serializer; shouldn&apos;t be used.&quot;);
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public TestType deserialize(DataInputView source) throws IOException {+			throw new UnsupportedOperationException(&quot;This is an incompatible serializer; shouldn&apos;t be used.&quot;);+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public TypeSerializerSnapshot&amp;lt;TestType&amp;gt; snapshotConfiguration() {
+			throw new UnsupportedOperationException(&quot;This is an incompatible serializer; shouldn&apos;t be used.&quot;);
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	public static abstract class TestTypeSerializerBase extends TypeSerializer&amp;lt;TestType&amp;gt; {&lt;br/&gt;
+&lt;br/&gt;
+		private static final long serialVersionUID = 256299937766275871L;&lt;br/&gt;
+&lt;br/&gt;
+		// --------------------------------------------------------------------------------&lt;br/&gt;
+		//  Miscellaneous serializer methods&lt;br/&gt;
+		// --------------------------------------------------------------------------------&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public TestType copy(TestType from) {
+			return new TestType(from.getKey(), from.getValue());
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public void copy(DataInputView source, DataOutputView target) throws IOException {
+			serialize(deserialize(source), target);
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public TestType deserialize(TestType reuse, DataInputView source) throws IOException {
+			return deserialize(source);
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public TestType copy(TestType from, TestType reuse) {
+			return copy(from);
+		}&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public TestType createInstance() {+			throw new UnsupportedOperationException();+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public TypeSerializer&amp;lt;TestType&amp;gt; duplicate() &lt;/p&gt;
{
+			return this;
+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public boolean isImmutableType() &lt;/p&gt;
{
+			return false;
+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public int getLength() &lt;/p&gt;
{
+			return -1;
+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public boolean canEqual(Object obj) &lt;/p&gt;
{
+			return getClass().equals(obj.getClass());
+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public int hashCode() &lt;/p&gt;
{
+			return getClass().hashCode();
+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public boolean equals(Object obj) &lt;/p&gt;
{
+			return obj == this;
+		}
&lt;p&gt;+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/statemigration/V1TestTypeSerializerSnapshot.java b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/statemigration/V1TestTypeSerializerSnapshot.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..b2b802a30c2&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/statemigration/V1TestTypeSerializerSnapshot.java&lt;br/&gt;
@@ -0,0 +1,62 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.testutils.statemigration;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Snapshot class for &lt;/p&gt;
{@link TestType.V1TestTypeSerializer}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class V1TestTypeSerializerSnapshot implements TypeSerializerSnapshot&amp;lt;TestType&amp;gt; {&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public int getCurrentVersion() &lt;/p&gt;
{
+		return 1;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public TypeSerializerSchemaCompatibility&amp;lt;TestType&amp;gt; resolveSchemaCompatibility(TypeSerializer&amp;lt;TestType&amp;gt; newSerializer) {&lt;br/&gt;
+		if (newSerializer instanceof TestType.V1TestTypeSerializer) {
+			return TypeSerializerSchemaCompatibility.compatibleAsIs();
+		} else if (newSerializer instanceof TestType.V2TestTypeSerializer) {
+			return TypeSerializerSchemaCompatibility.compatibleAfterMigration();
+		} else {
+			return TypeSerializerSchemaCompatibility.incompatible();
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public TypeSerializer&amp;lt;TestType&amp;gt; restoreSerializer() {
+		return new TestType.V1TestTypeSerializer();
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+    public void writeSnapshot(DataOutputView out) throws IOException {
+	}&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void readSnapshot(int readVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/statemigration/V2TestTypeSerializerSnapshot.java b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/statemigration/V2TestTypeSerializerSnapshot.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..3cd4fff8d86&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/statemigration/V2TestTypeSerializerSnapshot.java&lt;br/&gt;
@@ -0,0 +1,60 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.testutils.statemigration;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Snapshot class for {@link TestType.V2TestTypeSerializer}.&lt;br/&gt;
+ */&lt;br/&gt;
+public class V2TestTypeSerializerSnapshot implements TypeSerializerSnapshot&amp;lt;TestType&amp;gt; {&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public int getCurrentVersion() {+		return 1;+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public TypeSerializerSchemaCompatibility&amp;lt;TestType&amp;gt; resolveSchemaCompatibility(TypeSerializer&amp;lt;TestType&amp;gt; newSerializer) {&lt;br/&gt;
+		if (newSerializer instanceof TestType.V2TestTypeSerializer) &lt;/p&gt;
{
+			return TypeSerializerSchemaCompatibility.compatibleAsIs();
+		}
&lt;p&gt; else &lt;/p&gt;
{
+			return TypeSerializerSchemaCompatibility.incompatible();
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public TypeSerializer&amp;lt;TestType&amp;gt; restoreSerializer() &lt;/p&gt;
{
+		return new TestType.V2TestTypeSerializer();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void writeSnapshot(DataOutputView out) throws IOException &lt;/p&gt;
{
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void readSnapshot(int readVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java b/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java&lt;br/&gt;
index 50caa0d912a..a37f8aa8df8 100644&lt;br/&gt;
&amp;#8212; a/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java&lt;br/&gt;
+++ b/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java&lt;br/&gt;
@@ -29,7 +29,6 @@&lt;br/&gt;
 import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
 import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
 import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;&lt;br/&gt;
-import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;&lt;br/&gt;
 import org.apache.flink.api.common.typeutils.base.array.BytePrimitiveArraySerializer;&lt;br/&gt;
 import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
 import org.apache.flink.configuration.ConfigConstants;&lt;br/&gt;
@@ -112,7 +111,6 @@&lt;br/&gt;
 import java.util.Arrays;&lt;br/&gt;
 import java.util.Collection;&lt;br/&gt;
 import java.util.Collections;&lt;br/&gt;
-import java.util.HashMap;&lt;br/&gt;
 import java.util.LinkedHashMap;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Map;&lt;br/&gt;
@@ -213,14 +211,6 @@&lt;br/&gt;
 	 */&lt;br/&gt;
 	private final LinkedHashMap&amp;lt;String, Tuple2&amp;lt;ColumnFamilyHandle, RegisteredStateMetaInfoBase&amp;gt;&amp;gt; kvStateInformation;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Map of state names to their corresponding restored state meta info.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;TODO this map can be removed when eager-state registration is in place.&lt;/li&gt;
	&lt;li&gt;* TODO we currently need this cached to check state migration strategies when new serializers are registered.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private final Map&amp;lt;String, StateMetaInfoSnapshot&amp;gt; restoredKvStateMetaInfos;&lt;br/&gt;
-&lt;br/&gt;
 	/** Number of bytes required to prefix the key groups. */&lt;br/&gt;
 	private final int keyGroupPrefixBytes;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -297,7 +287,6 @@ public RocksDBKeyedStateBackend(&lt;br/&gt;
 		this.keyGroupPrefixBytes =&lt;br/&gt;
 			RocksDBKeySerializationUtils.computeRequiredBytesInKeyGroupPrefix(getNumberOfKeyGroups());&lt;br/&gt;
 		this.kvStateInformation = new LinkedHashMap&amp;lt;&amp;gt;();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.restoredKvStateMetaInfos = new HashMap&amp;lt;&amp;gt;();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		this.writeOptions = new WriteOptions().setDisableWAL(true);&lt;/p&gt;

&lt;p&gt;@@ -425,7 +414,6 @@ public void dispose() &lt;/p&gt;
{
 			IOUtils.closeQuietly(dbOptions);
 			IOUtils.closeQuietly(writeOptions);
 			kvStateInformation.clear();
-			restoredKvStateMetaInfos.clear();
 
 			cleanInstanceBasePath();
 		}
&lt;p&gt;@@ -511,7 +499,6 @@ public void restore(Collection&amp;lt;KeyedStateHandle&amp;gt; restoreState) throws Exception&lt;/p&gt;

&lt;p&gt; 		// clear all meta data&lt;br/&gt;
 		kvStateInformation.clear();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;restoredKvStateMetaInfos.clear();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		try &lt;/p&gt;
{
 			RocksDBIncrementalRestoreOperation&amp;lt;K&amp;gt; incrementalRestoreOperation = null;
@@ -754,11 +741,13 @@ private void restoreKVStateMetaData() throws IOException, StateMigrationExceptio
 						nameBytes,
 						rocksDBKeyedStateBackend.columnOptions);
 
-					rocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo);
-
 					ColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor);
 
-					registeredColumn = new Tuple2&amp;lt;&amp;gt;(columnFamily, null);
+					// create a meta info for the state on restore;
+					// this allows us to retain the state in future snapshots even if it wasn&apos;t accessed
+					RegisteredStateMetaInfoBase stateMetaInfo =
+						RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(restoredMetaInfo);
+					registeredColumn = new Tuple2&amp;lt;&amp;gt;(columnFamily, stateMetaInfo);
 					rocksDBKeyedStateBackend.kvStateInformation.put(restoredMetaInfo.getName(), registeredColumn);
 
 				}
&lt;p&gt; else {&lt;br/&gt;
@@ -1069,10 +1058,14 @@ private ColumnFamilyHandle getOrRegisterColumnFamilyHandle(&lt;br/&gt;
 				stateBackend.kvStateInformation.get(stateMetaInfoSnapshot.getName());&lt;/p&gt;

&lt;p&gt; 			if (null == registeredStateMetaInfoEntry) &lt;/p&gt;
{
+				// create a meta info for the state on restore;
+				// this allows us to retain the state in future snapshots even if it wasn&apos;t accessed
+				RegisteredStateMetaInfoBase stateMetaInfo =
+					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot);
 				registeredStateMetaInfoEntry =
 					new Tuple2&amp;lt;&amp;gt;(
 						columnFamilyHandle != null ? columnFamilyHandle : stateBackend.db.createColumnFamily(columnFamilyDescriptor),
-						null);
+						stateMetaInfo);
 
 				stateBackend.registerKvStateInformation(
 					stateMetaInfoSnapshot.getName(),
@@ -1159,7 +1152,6 @@ private void initTargetDB(
 					stateBackend.columnOptions);
 
 				columnFamilyDescriptors.add(columnFamilyDescriptor);
-				stateBackend.restoredKvStateMetaInfos.put(stateMetaInfoSnapshot.getName(), stateMetaInfoSnapshot);
 			}
&lt;p&gt; 			return columnFamilyDescriptors;&lt;br/&gt;
 		}&lt;br/&gt;
@@ -1201,9 +1193,13 @@ private void restoreLocalStateIntoFullInstance(&lt;/p&gt;

&lt;p&gt; 				ColumnFamilyHandle columnFamilyHandle = columnFamilyHandles.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;/p&gt;

&lt;p&gt;+				// create a meta info for the state on restore;&lt;br/&gt;
+				// this allows us to retain the state in future snapshots even if it wasn&apos;t accessed&lt;br/&gt;
+				RegisteredStateMetaInfoBase stateMetaInfo =&lt;br/&gt;
+					RegisteredStateMetaInfoBase.fromMetaInfoSnapshot(stateMetaInfoSnapshot);&lt;br/&gt;
 				stateBackend.registerKvStateInformation(&lt;br/&gt;
 					stateMetaInfoSnapshot.getName(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;new Tuple2&amp;lt;&amp;gt;(columnFamilyHandle, null));&lt;br/&gt;
+					new Tuple2&amp;lt;&amp;gt;(columnFamilyHandle, stateMetaInfo));&lt;br/&gt;
 			}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			// use the restore sst files as the base for succeeding checkpoints&lt;br/&gt;
@@ -1365,78 +1361,69 @@ private void copyStateDataHandleData(&lt;br/&gt;
 			TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer,&lt;br/&gt;
 			@Nullable StateSnapshotTransformer&amp;lt;SV&amp;gt; snapshotTransformer) throws Exception {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Tuple2&amp;lt;ColumnFamilyHandle, RegisteredStateMetaInfoBase&amp;gt; stateInfo =&lt;br/&gt;
+		Tuple2&amp;lt;ColumnFamilyHandle, RegisteredStateMetaInfoBase&amp;gt; oldStateInfo =&lt;br/&gt;
 			kvStateInformation.get(stateDesc.getName());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		TypeSerializer&amp;lt;SV&amp;gt; stateSerializer = stateDesc.getSerializer();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, SV&amp;gt; newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo&amp;lt;&amp;gt;(&lt;/li&gt;
	&lt;li&gt;stateDesc.getType(),&lt;/li&gt;
	&lt;li&gt;stateDesc.getName(),&lt;/li&gt;
	&lt;li&gt;namespaceSerializer,&lt;/li&gt;
	&lt;li&gt;stateSerializer,&lt;/li&gt;
	&lt;li&gt;snapshotTransformer);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;if (stateInfo != null) {&lt;/li&gt;
	&lt;li&gt;newMetaInfo = migrateStateIfNecessary(&lt;/li&gt;
	&lt;li&gt;newMetaInfo,&lt;br/&gt;
+&lt;br/&gt;
+		ColumnFamilyHandle newColumnFamily;&lt;br/&gt;
+		RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, SV&amp;gt; newMetaInfo;&lt;br/&gt;
+		if (oldStateInfo != null) 
{
+			@SuppressWarnings(&quot;unchecked&quot;)
+			RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, SV&amp;gt; castedMetaInfo = (RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, SV&amp;gt;) oldStateInfo.f1;
+
+			newMetaInfo = updateRestoredStateMetaInfo(
+				Tuple2.of(oldStateInfo.f0, castedMetaInfo),
 				stateDesc,
 				namespaceSerializer,
 				stateSerializer,
-				stateInfo);
+				snapshotTransformer);
 
-			stateInfo.f1 = newMetaInfo;
+			oldStateInfo.f1 = newMetaInfo;
+			newColumnFamily = oldStateInfo.f0;
 		}
&lt;p&gt; else &lt;/p&gt;
{
-			ColumnFamilyHandle columnFamily = createColumnFamily(stateDesc.getName());
+			newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo&amp;lt;&amp;gt;(
+				stateDesc.getType(),
+				stateDesc.getName(),
+				namespaceSerializer,
+				stateSerializer,
+				snapshotTransformer);
 
-			stateInfo = Tuple2.of(columnFamily, newMetaInfo);
-			registerKvStateInformation(stateDesc.getName(), stateInfo);
+			newColumnFamily = createColumnFamily(stateDesc.getName());
+			registerKvStateInformation(stateDesc.getName(), Tuple2.of(newColumnFamily, newMetaInfo));
 		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return Tuple2.of(stateInfo.f0, newMetaInfo);&lt;br/&gt;
+		return Tuple2.of(newColumnFamily, newMetaInfo);&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private &amp;lt;N, S extends State, SV&amp;gt; RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, SV&amp;gt; migrateStateIfNecessary(&lt;/li&gt;
	&lt;li&gt;RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, SV&amp;gt; newMetaInfo,&lt;br/&gt;
+	private &amp;lt;N, S extends State, SV&amp;gt; RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, SV&amp;gt; updateRestoredStateMetaInfo(&lt;br/&gt;
+			Tuple2&amp;lt;ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, SV&amp;gt;&amp;gt; oldStateInfo,&lt;br/&gt;
 			StateDescriptor&amp;lt;S, SV&amp;gt; stateDesc,&lt;br/&gt;
 			TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer,&lt;br/&gt;
 			TypeSerializer&amp;lt;SV&amp;gt; stateSerializer,&lt;/li&gt;
	&lt;li&gt;Tuple2&amp;lt;ColumnFamilyHandle, RegisteredStateMetaInfoBase&amp;gt; stateInfo) throws Exception {&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateDesc.getName());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(&lt;/li&gt;
	&lt;li&gt;restoredMetaInfoSnapshot != null,&lt;/li&gt;
	&lt;li&gt;&quot;Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo,&quot; +&lt;/li&gt;
	&lt;li&gt;&quot; but its corresponding restored snapshot cannot be found.&quot;);&lt;br/&gt;
+			@Nullable StateSnapshotTransformer&amp;lt;SV&amp;gt; snapshotTransformer) throws Exception {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		@SuppressWarnings(&quot;unchecked&quot;)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TypeSerializerSnapshot&amp;lt;N&amp;gt; namespaceSerializerSnapshot = Preconditions.checkNotNull(&lt;/li&gt;
	&lt;li&gt;(TypeSerializerSnapshot&amp;lt;N&amp;gt;) restoredMetaInfoSnapshot.getTypeSerializerConfigSnapshot(&lt;/li&gt;
	&lt;li&gt;StateMetaInfoSnapshot.CommonSerializerKeys.NAMESPACE_SERIALIZER.toString()));&lt;br/&gt;
+		RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, SV&amp;gt; restoredKvStateMetaInfo = oldStateInfo.f1;&lt;br/&gt;
+&lt;br/&gt;
+		restoredKvStateMetaInfo.updateSnapshotTransformer(snapshotTransformer);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TypeSerializerSchemaCompatibility&amp;lt;N&amp;gt; namespaceCompatibility =&lt;/li&gt;
	&lt;li&gt;namespaceSerializerSnapshot.resolveSchemaCompatibility(namespaceSerializer);&lt;/li&gt;
	&lt;li&gt;if (!namespaceCompatibility.isCompatibleAsIs()) {&lt;br/&gt;
+		TypeSerializerSchemaCompatibility&amp;lt;N&amp;gt; s = restoredKvStateMetaInfo.updateNamespaceSerializer(namespaceSerializer);&lt;br/&gt;
+		if (!s.isCompatibleAsIs()) 
{
 			throw new StateMigrationException(&quot;The new namespace serializer must be compatible.&quot;);
 		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/li&gt;
	&lt;li&gt;TypeSerializerSnapshot&amp;lt;SV&amp;gt; stateSerializerSnapshot = Preconditions.checkNotNull(&lt;/li&gt;
	&lt;li&gt;(TypeSerializerSnapshot&amp;lt;SV&amp;gt;) restoredMetaInfoSnapshot.getTypeSerializerConfigSnapshot(&lt;/li&gt;
	&lt;li&gt;StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER.toString()));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;RegisteredKeyValueStateBackendMetaInfo.checkStateMetaInfo(restoredMetaInfoSnapshot, stateDesc);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;TypeSerializerSchemaCompatibility&amp;lt;SV&amp;gt; stateCompatibility =&lt;/li&gt;
	&lt;li&gt;stateSerializerSnapshot.resolveSchemaCompatibility(stateSerializer);&lt;br/&gt;
+		restoredKvStateMetaInfo.checkStateMetaInfo(stateDesc);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (stateCompatibility.isCompatibleAfterMigration()) 
{
-			migrateStateValues(stateDesc, stateInfo, restoredMetaInfoSnapshot, newMetaInfo, stateSerializer);
-		}
&lt;p&gt; else if (stateCompatibility.isIncompatible()) {&lt;br/&gt;
+		TypeSerializerSchemaCompatibility&amp;lt;SV&amp;gt; newStateSerializerCompatibility =&lt;br/&gt;
+			restoredKvStateMetaInfo.updateStateSerializer(stateSerializer);&lt;br/&gt;
+		if (newStateSerializerCompatibility.isCompatibleAfterMigration()) &lt;/p&gt;
{
+			migrateStateValues(stateDesc, oldStateInfo);
+		}
&lt;p&gt; else if (newStateSerializerCompatibility.isIncompatible()) &lt;/p&gt;
{
 			throw new StateMigrationException(&quot;The new state serializer cannot be incompatible.&quot;);
 		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return newMetaInfo;&lt;br/&gt;
+		return restoredKvStateMetaInfo;&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;br/&gt;
@@ -1446,10 +1433,7 @@ private void copyStateDataHandleData(&lt;br/&gt;
 	 */&lt;br/&gt;
 	private &amp;lt;N, S extends State, SV&amp;gt; void migrateStateValues(&lt;br/&gt;
 		StateDescriptor&amp;lt;S, SV&amp;gt; stateDesc,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Tuple2&amp;lt;ColumnFamilyHandle, RegisteredStateMetaInfoBase&amp;gt; stateInfo,&lt;/li&gt;
	&lt;li&gt;StateMetaInfoSnapshot restoredMetaInfoSnapshot,&lt;/li&gt;
	&lt;li&gt;RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, SV&amp;gt; newMetaInfo,&lt;/li&gt;
	&lt;li&gt;TypeSerializer&amp;lt;SV&amp;gt; newStateSerializer) throws Exception {&lt;br/&gt;
+		Tuple2&amp;lt;ColumnFamilyHandle, RegisteredKeyValueStateBackendMetaInfo&amp;lt;N, SV&amp;gt;&amp;gt; stateMetaInfo) throws Exception {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		if (stateDesc.getType() == StateDescriptor.Type.MAP) &lt;/p&gt;
{
 			throw new StateMigrationException(&quot;The new serializer for a MapState requires state migration in order for the job to proceed.&quot; +
@@ -1471,7 +1455,7 @@ private void copyStateDataHandleData(
 		}
&lt;p&gt; 		State state = stateFactory.createState(&lt;br/&gt;
 			stateDesc,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Tuple2.of(stateInfo.f0, newMetaInfo),&lt;br/&gt;
+			stateMetaInfo,&lt;br/&gt;
 			RocksDBKeyedStateBackend.this);&lt;br/&gt;
 		if (!(state instanceof AbstractRocksDBState)) {&lt;br/&gt;
 			throw new FlinkRuntimeException(&lt;br/&gt;
@@ -1483,16 +1467,11 @@ private void copyStateDataHandleData(&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		Snapshot rocksDBSnapshot = db.getSnapshot();&lt;br/&gt;
 		try (&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;RocksIteratorWrapper iterator = getRocksIterator(db, stateInfo.f0);&lt;br/&gt;
+			RocksIteratorWrapper iterator = getRocksIterator(db, stateMetaInfo.f0);&lt;br/&gt;
 			RocksDBWriteBatchWrapper batchWriter = new RocksDBWriteBatchWrapper(db, getWriteOptions())&lt;br/&gt;
 		) {&lt;br/&gt;
 			iterator.seekToFirst();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/li&gt;
	&lt;li&gt;TypeSerializerSnapshot&amp;lt;SV&amp;gt; priorValueSerializerSnapshot = (TypeSerializerSnapshot&amp;lt;SV&amp;gt;)&lt;/li&gt;
	&lt;li&gt;Preconditions.checkNotNull(restoredMetaInfoSnapshot.getTypeSerializerConfigSnapshot(StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER));&lt;/li&gt;
	&lt;li&gt;TypeSerializer&amp;lt;SV&amp;gt; priorValueSerializer = priorValueSerializerSnapshot.restoreSerializer();&lt;br/&gt;
-&lt;br/&gt;
 			DataInputDeserializer serializedValueInput = new DataInputDeserializer();&lt;br/&gt;
 			DataOutputSerializer migratedSerializedValueOutput = new DataOutputSerializer(512);&lt;br/&gt;
 			while (iterator.isValid()) {&lt;br/&gt;
@@ -1501,10 +1480,10 @@ private void copyStateDataHandleData(&lt;br/&gt;
 				rocksDBState.migrateSerializedValue(&lt;br/&gt;
 					serializedValueInput,&lt;br/&gt;
 					migratedSerializedValueOutput,&lt;/li&gt;
	&lt;li&gt;priorValueSerializer,&lt;/li&gt;
	&lt;li&gt;newStateSerializer);&lt;br/&gt;
+					stateMetaInfo.f1.getPreviousStateSerializer(),&lt;br/&gt;
+					stateMetaInfo.f1.getStateSerializer());&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;batchWriter.put(stateInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer());&lt;br/&gt;
+				batchWriter.put(stateMetaInfo.f0, iterator.key(), migratedSerializedValueOutput.getCopyOfBuffer());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 				migratedSerializedValueOutput.clear();&lt;br/&gt;
 				iterator.next();&lt;br/&gt;
@@ -1698,25 +1677,16 @@ public static RocksIteratorWrapper getRocksIterator(&lt;br/&gt;
 			// TODO we implement the simple way of supporting the current functionality, mimicking keyed state&lt;br/&gt;
 			// because this should be reworked in &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9376&quot; title=&quot;Allow upgrading to incompatible state serializers (state schema evolution)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9376&quot;&gt;&lt;del&gt;FLINK-9376&lt;/del&gt;&lt;/a&gt; and then we should have a common algorithm over&lt;br/&gt;
 			// StateMetaInfoSnapshot that avoids this code duplication.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;StateMetaInfoSnapshot restoredMetaInfoSnapshot = restoredKvStateMetaInfos.get(stateName);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(&lt;/li&gt;
	&lt;li&gt;restoredMetaInfoSnapshot != null,&lt;/li&gt;
	&lt;li&gt;&quot;Requested to check compatibility of a restored RegisteredKeyedBackendStateMetaInfo,&quot; +&lt;/li&gt;
	&lt;li&gt;&quot; but its corresponding restored snapshot cannot be found.&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;StateMetaInfoSnapshot.CommonSerializerKeys serializerKey =&lt;/li&gt;
	&lt;li&gt;StateMetaInfoSnapshot.CommonSerializerKeys.VALUE_SERIALIZER;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;TypeSerializer&amp;lt;?&amp;gt; metaInfoTypeSerializer = restoredMetaInfoSnapshot.restoreTypeSerializer(serializerKey);&lt;br/&gt;
+			@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
+			RegisteredPriorityQueueStateBackendMetaInfo&amp;lt;T&amp;gt; castedMetaInfo =&lt;br/&gt;
+				(RegisteredPriorityQueueStateBackendMetaInfo&amp;lt;T&amp;gt;) metaInfoTuple.f1;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (metaInfoTypeSerializer != byteOrderedElementSerializer) {&lt;/li&gt;
	&lt;li&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/li&gt;
	&lt;li&gt;TypeSerializerSnapshot&amp;lt;T&amp;gt; serializerSnapshot = Preconditions.checkNotNull(&lt;/li&gt;
	&lt;li&gt;(TypeSerializerSnapshot&amp;lt;T&amp;gt;) restoredMetaInfoSnapshot.getTypeSerializerConfigSnapshot(serializerKey));&lt;br/&gt;
+			TypeSerializer&amp;lt;T&amp;gt; previousElementSerializer = castedMetaInfo.getPreviousElementSerializer();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+			if (previousElementSerializer != byteOrderedElementSerializer) {&lt;br/&gt;
 				TypeSerializerSchemaCompatibility&amp;lt;T&amp;gt; compatibilityResult =&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;serializerSnapshot.resolveSchemaCompatibility(byteOrderedElementSerializer);&lt;br/&gt;
+					castedMetaInfo.updateElementSerializer(byteOrderedElementSerializer);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 				// Since priority queue elements are written into RocksDB&lt;br/&gt;
 				// as keys prefixed with the key group and namespace, we do not support&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16717036" author="tzulitai" created="Tue, 11 Dec 2018 12:41:49 +0000"  >&lt;p&gt;Merged.&lt;/p&gt;

&lt;p&gt;1.8.0 (master):&#160;97f556ebd122dfe16dd8e148d3ac7c5386fd08ac&lt;br/&gt;
1.7.1:&#160;c8860074ffca82bf0314c8065b62901a8a4cabdd&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            6 years, 49 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|s019sg:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>