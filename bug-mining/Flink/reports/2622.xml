<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:34:55 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-10011] Old job resurrected during HA failover</title>
                <link>https://issues.apache.org/jira/browse/FLINK-10011</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;For the second time we&apos;ve observed Flink resurrect an old job during JobManager high-availability fail over.&lt;/p&gt;
&lt;h4&gt;&lt;a name=&quot;Configuration&quot;&gt;&lt;/a&gt;Configuration&lt;/h4&gt;
&lt;ul&gt;
	&lt;li&gt;AWS environment&lt;/li&gt;
	&lt;li&gt;Flink 1.4.2 standalong cluster in HA mode&lt;/li&gt;
	&lt;li&gt;2 JMs, 3 TMs&lt;/li&gt;
	&lt;li&gt;3 node ZK ensemble&lt;/li&gt;
	&lt;li&gt;1 job consuming to/from Kafka&lt;/li&gt;
	&lt;li&gt;Checkpoints in S3 using the Presto file system adaptor&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;&lt;a name=&quot;Timeline%C2%A0&quot;&gt;&lt;/a&gt;Timeline&#160;&lt;/h4&gt;
&lt;ul&gt;
	&lt;li&gt;15:18:10 JM 2 completes checkpoint 69256.&lt;/li&gt;
	&lt;li&gt;15:19:10 JM 2 completes checkpoint 69257.&lt;/li&gt;
	&lt;li&gt;15:19:57 ZK 1 (follower) loses connectivity to the leader as a result of a SocketTimeoutException&lt;/li&gt;
	&lt;li&gt;15:19:57 ZK 1 closes connection to JM 2 (leader)&lt;/li&gt;
	&lt;li&gt;15:19:57 ZK 2 (leader) reports a network error and closes connection to ZK 1&lt;/li&gt;
	&lt;li&gt;15:19:57 JM 2 reports it can&apos;t read data from ZK
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;Unable to read additional data from server sessionid 0x30000003f4a0003, likely server has closed socket, closing socket connection and attempting reconnect)&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;org.apache.flink.shaded.zookeeper.org.apache.zookeeper.ClientCnxn&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;15:19:57 JM 2 ZK Curator changes connection state to SUSPENDED
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;Connection to ZooKeeper suspended. Can no longer retrieve the leader from ZooKeeper.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;ZooKeeper connection SUSPENDED. }}{{Changes to the submitted job graphs are not monitored (temporarily).&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Connection to ZooKeeper suspended. The contender akka.tcp://flink@flink-jm-2:6123/user/jobmanager no longer participates in the leader election&lt;/tt&gt;&lt;tt&gt;&#160;&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Connection to ZooKeeper suspended. Can no longer retrieve the leader from ZooKeeper.&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;15:19:57 JM 2 gives up leadership
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;JobManager akka://flink/user/jobmanager#33755521 was revoked leadership.&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:19:57 JM 2 changes job &lt;font color=&quot;#14892c&quot;&gt;2a4eff355aef849c5ca37dbac04f2ff1&lt;/font&gt; status to SUSPENDED
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;Stopping checkpoint coordinator for job &lt;font color=&quot;#14892c&quot;&gt;2a4eff355aef849c5ca37dbac04f2ff1&lt;/font&gt;&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:19:57 TMs start disasociating with JM 2, but JM 2 discard the messages because there is no leader
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;Discard message LeaderSessionMessage(d29e9f38-a16d-4c87-b34f-5212caab0473,Disconnect(b97363d53ad22aedfebdc8e5ba3c672f,java.lang.Exception: TaskManager akka://flink/user/taskmanager is disassociating)) because there is currently no valid leader id known.&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:19:57 JM 2 connects to ZK 2 and renews its session
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;Opening socket connection to server ip-10-210-43-221.ec2.internal/10.210.43.221:2181&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Socket connection established to ip-10-210-43-221.ec2.internal/10.210.43.221:2181, initiating session&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Connection to ZooKeeper was reconnected. Leader retrieval can be restarted.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Session establishment complete on server ip-10-210-43-221.ec2.internal/10.210.43.221:2181, sessionid = 0x30000003f4a0003, negotiated timeout = 40000&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Connection to ZooKeeper was reconnected. Leader election can be restarted.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;ZooKeeper connection RECONNECTED. Changes to the submitted job graphs are monitored again.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;State change: RECONNECTED&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:19:57: JM 1 reports JM 1 has been granted leadership:
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;JobManager akka.tcp://flink@flink-jm-1:6123/user/jobmanager was granted leadership with leader session ID Some(ae0a1a17-eccc-40b4-985d-93bc59f5b936).&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:19:57 JM 2 reports the job has been suspended
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;org.apache.flink.runtime.checkpoint.ZooKeeperCheckpointIDCounter Shutting down.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Job 2a4eff355aef849c5ca37dbac04f2ff1 has been suspended.&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:19:57 JM 2 reports it has lost leadership:
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;Associated JobManager Actor&lt;a href=&quot;#33755521&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;akka://flink/user/jobmanager#33755521&lt;/a&gt; lost leader status&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Received leader address but not running in leader ActorSystem. Cancelling registration.&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:19:57 TMs register with JM 1&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:20:07 JM 1 Attempts to recover jobs and find there are two jobs:
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;Attempting to recover all jobs.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;There are 2 jobs to recover. Starting the job recovery.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Attempting to recover job &lt;font color=&quot;#14892c&quot;&gt;2a4eff355aef849c5ca37dbac04f2ff1&lt;/font&gt;.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Attempting to recover job &lt;font color=&quot;#d04437&quot;&gt;61bca496065cd05e4263070a5e923a05&lt;/font&gt;.&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:20:08 &#8211; 15:32:27 ZK 2 reports a large number of errors of the form:
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;Got user-level KeeperException when processing sessionid:0x2000001d2330001 type:create cxid:0x4211 zxid:0x60009dc70 txntype:-1 reqpath:n/a Error Path:/flink/cluster_a/checkpoint-counter/2a4eff355aef849c5ca37dbac04f2ff1 Error:KeeperErrorCode = NodeExists for /flink/cluster_a/checkpoint-counter/2a4eff355aef849c5ca37dbac04f2ff1&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Got user-level KeeperException when processing sessionid:0x2000001d2330001 type:create cxid:0x4230 zxid:0x60009dc78 txntype:-1 reqpath:n/a Error Path:/flink/cluster_a/checkpoints/2a4eff355aef849c5ca37dbac04f2ff1/0000000000000069255/37d25086-374f-4969-b763-4261e87022a2 Error:KeeperErrorCode = NodeExists for /flink/cluster_a/checkpoints/2a4eff355aef849c5ca37dbac04f2ff1/0000000000000069255/37d25086-374f-4969-b763-4261e87022a2&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:29:08 JM 1 starts to recover job &lt;font color=&quot;#14892c&quot;&gt;2a4eff355aef849c5ca37dbac04f2ff1&lt;/font&gt;
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;Recovered SubmittedJobGraph(2a4eff355aef849c5ca37dbac04f2ff1, JobInfo(clients: Set((Actor&lt;span class=&quot;error&quot;&gt;&amp;#91;akka.tcp://flink@ip-10-210-42-62.ec2.internal:37564/temp/$c&amp;#93;&lt;/span&gt;,DETACHED)), start: 1528833686265)).&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Submitting recovered job 2a4eff355aef849c5ca37dbac04f2ff1.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Submitting job 2a4eff355aef849c5ca37dbac04f2ff1 (Some Job) (Recovery).&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Using restart strategy FixedDelayRestartStrategy(maxNumberRestartAttempts=2147483647, delayBetweenRestartAttempts=30000) for 2a4eff355aef849c5ca37dbac04f2ff1.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Successfully ran initialization on master in 0 ms.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Job recovers via failover strategy: full graph restart&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Running initialization on master for job Some Job (2a4eff355aef849c5ca37dbac04f2ff1).&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Initialized in &apos;/checkpoints/2a4eff355aef849c5ca37dbac04f2ff1&apos;.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Using application-defined state backend for checkpoint/savepoint metadata: File State Backend @ s3://bucket/flink/cluster_1/checkpoints.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Persisting periodic checkpoints externally at s3://bucket/flink/cluster_1/checkpoints-external.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Recovering checkpoints from ZooKeeper.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Found 3 checkpoints in ZooKeeper.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Trying to retrieve checkpoint 69255.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Trying to fetch 3 checkpoints from storage.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Trying to retrieve checkpoint 69256.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Trying to retrieve checkpoint 69257.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Restoring from latest valid checkpoint: Checkpoint 69257 @ 1532989148882 for 2a4eff355aef849c5ca37dbac04f2ff1.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Scheduling job 2a4eff355aef849c5ca37dbac04f2ff1 (Some Job).&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Job Some Job (2a4eff355aef849c5ca37dbac04f2ff1) switched from state CREATED to RUNNING.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Job Some Job (2a4eff355aef849c5ca37dbac04f2ff1) switched from state RUNNING to FAILING.&lt;/tt&gt;{{ org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException: Not enough free slots available to run the job. You can decrease the operator parallelism or increase the number of slots per TaskManager in the configuration.}}&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:20:09 JM 1 starts to recover &lt;font color=&quot;#d04437&quot;&gt;61bca496065cd05e4263070a5e923a05&lt;/font&gt;
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;Recovered SubmittedJobGraph(61bca496065cd05e4263070a5e923a05, JobInfo(clients: Set((Actor&lt;span class=&quot;error&quot;&gt;&amp;#91;akka.tcp://flink@ip-10-210-22-167.ec2.internal:41001/temp/$c&amp;#93;&lt;/span&gt;,DETACHED)), start: 1525728377900)).&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Submitting recovered job 61bca496065cd05e4263070a5e923a05.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Submitting job 61bca496065cd05e4263070a5e923a05 (Some Job) (Recovery).&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Using restart strategy FixedDelayRestartStrategy(maxNumberRestartAttempts=2147483647, delayBetweenRestartAttempts=30000) for 61bca496065cd05e4263070a5e923a05.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Job recovers via failover strategy: full graph restart&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Successfully ran initialization on master in 0 ms.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Running initialization on master for job Some Job (61bca496065cd05e4263070a5e923a05).&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Initialized in &apos;/checkpoints/61bca496065cd05e4263070a5e923a05&apos;.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Using application-defined state backend for checkpoint/savepoint metadata: File State Backend @ s3://bucket/flink/cluster_1/checkpoints.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Persisting periodic checkpoints externally at s3://bucket/flink/cluster_1/checkpoints-external.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Recovering checkpoints from ZooKeeper.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Scheduling job 61bca496065cd05e4263070a5e923a05 (Some Job).&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Job Some Job (61bca496065cd05e4263070a5e923a05) switched from state CREATED to RUNNING.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Trying to fetch 0 checkpoints from storage&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Found 0 checkpoints in ZooKeeper.&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:20:09 JM 1 reports a bunch of metric collisions because of the two jobs:
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;Name collision: Group already contains a Metric with the name &apos;lastCheckpointSize&apos;. Metric will not be reported.&lt;span class=&quot;error&quot;&gt;&amp;#91;jobmanager, job&amp;#93;&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Name collision: Group already contains a Metric with the name &apos;lastCheckpointAlignmentBuffered&apos;. Metric will not be reported.&lt;span class=&quot;error&quot;&gt;&amp;#91;jobmanager, job&amp;#93;&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;etc&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:20:39 JM 1 begins attempting to restart the &lt;font color=&quot;#14892c&quot;&gt;2a4eff355aef849c5ca37dbac04f2ff1&lt;/font&gt; job repeatedly
	&lt;ul&gt;
		&lt;li&gt;&lt;tt&gt;Job Some Job (2a4eff355aef849c5ca37dbac04f2ff1) switched from state FAILING to RESTARTING.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Restarting the job Some Job (2a4eff355aef849c5ca37dbac04f2ff1).&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Job Some Job (2a4eff355aef849c5ca37dbac04f2ff1) switched from state RESTARTING to CREATED.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Recovering checkpoints from ZooKeeper.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Found 3 checkpoints in ZooKeeper.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Trying to fetch 3 checkpoints from storage.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Trying to retrieve checkpoint 69255.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Trying to retrieve checkpoint 69256.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Trying to retrieve checkpoint 69257.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Restoring from latest valid checkpoint: Checkpoint 69257 @ 1532989148882 for 2a4eff355aef849c5ca37dbac04f2ff1.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Job Some Job (2a4eff355aef849c5ca37dbac04f2ff1) switched from state CREATED to RUNNING.&lt;/tt&gt;&lt;/li&gt;
		&lt;li&gt;&lt;tt&gt;Job Some Job (2a4eff355aef849c5ca37dbac04f2ff1) switched from state RUNNING to FAILING.&lt;/tt&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;15:35:39 ZK 1 reestablishes connection with ZK 2 and 3 and becomes a follower&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&#160;&lt;/p&gt;
&lt;h4&gt;&lt;a name=&quot;Analysis&quot;&gt;&lt;/a&gt;Analysis&lt;/h4&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;The cluster was running job&#160;&lt;font color=&quot;#14892c&quot;&gt;2a4eff355aef849c5ca37dbac04f2ff1&lt;/font&gt;. &#160;The JM HA leader&#160;was JM 2, which was connected to ZK 1. &#160;ZK 1 was a follower in the ZK ensemble. &#160;The ZK leader was ZK 2. &#160;&lt;/p&gt;

&lt;p&gt;ZK 1 lost network connectivity for about 16 minutes. &#160;Upon loss of connectivity to ZK 1, JM 2 gives up leadership and shutdown the&#160; &lt;font color=&quot;#14892c&quot;&gt;2a4eff355aef849c5ca37dbac04f2ff1&lt;/font&gt; job. &#160;JM 2 then immediately connects to ZK 2, without its ZK session having expired. &#160;Nonetheless, as it gave up leadership JM 1 is elected the new JM leader.&lt;/p&gt;

&lt;p&gt;JM 1 then erroneously decides there are two jobs to restore. &#160;The previously running job,&#160; &lt;font color=&quot;#14892c&quot;&gt;2a4eff355aef849c5ca37dbac04f2ff1&lt;/font&gt;, and&#160;&lt;font color=&quot;#d04437&quot;&gt;61bca496065cd05e4263070a5e923a05&lt;/font&gt;. &#160;JM 1 decides there are no checkpoints for&#160;&lt;font color=&quot;#d04437&quot;&gt;61bca496065cd05e4263070a5e923a05&lt;/font&gt;, which starts right away. &#160;&#160;JM 1 attempts to restore &lt;font color=&quot;#14892c&quot;&gt;2a4eff355aef849c5ca37dbac04f2ff1&lt;/font&gt; from the latest checkpoint, but it fails because there aren&apos;t enough task slots in the cluster as a result of the other job starting. &#160;Thus,&#160; &lt;font color=&quot;#14892c&quot;&gt;2a4eff355aef849c5ca37dbac04f2ff1&lt;/font&gt; entered a restart loop.&lt;/p&gt;

&lt;p&gt;We manually stopped both jobs and starts a new job based on the last known checkpoint for&#160; &lt;font color=&quot;#14892c&quot;&gt;2a4eff355aef849c5ca37dbac04f2ff1&lt;/font&gt;.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Job &lt;font color=&quot;#d04437&quot;&gt;61bca496065cd05e4263070a5e923a05&lt;/font&gt; &#160;is an old job that we ran for a month between May 7th and June 5th.&lt;/p&gt;

&lt;p&gt;After our manual intervention, the&#160;the HA state directory in S3 looks like this:&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;s3cmd ls s3://bucket/flink/cluster_1/recovery/&lt;/tt&gt;&lt;br/&gt;
{{ DIR s3://bucket/flink/cluster_1/recovery/some_job/}}&lt;br/&gt;
&lt;tt&gt;2018-07-31 17:33 35553 s3://bucket/flink/cluster_1/recovery/completedCheckpoint12e06bef01c5&lt;/tt&gt;&lt;br/&gt;
&lt;tt&gt;2018-07-31 17:34 35553 s3://bucket/flink/cluster_1/recovery/completedCheckpoint187e0d2ae7cb&lt;/tt&gt;&lt;br/&gt;
&lt;tt&gt;2018-07-31 17:32 35553 s3://bucket/flink/cluster_1/recovery/completedCheckpoint22fc8ca46f02&lt;/tt&gt;&lt;br/&gt;
&lt;tt&gt;2018-06-12 20:01 284626 s3://bucket/flink/cluster_1/recovery/submittedJobGraph7f627a661cec&lt;/tt&gt;&lt;br/&gt;
&lt;tt&gt;2018-07-30 23:01 285257 s3://bucket/flink/cluster_1/recovery/submittedJobGraphf3767780c00c&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;submittedJobGraph7f627a661cec appears to be job &lt;font color=&quot;#14892c&quot;&gt;2a4eff355aef849c5ca37dbac04f2ff1&lt;/font&gt;, the long running job that failed during the ZK failover&lt;/p&gt;

&lt;p&gt;submittedJobGraphf3767780c00c appears to be job &lt;font color=&quot;#205081&quot;&gt;d77948df92813a68ea6dfd6783f40e7e&lt;/font&gt;, the job we started restoring from a checkpoint after shutting down the duplicate jobs&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;A few questions come to mind.&lt;/p&gt;
&lt;h5&gt;&lt;a name=&quot;WhydoestheJMterminaterunningjobswhenitcanimmediatelyconnecttoanotherZKnodeanditsZKsessionhasnotexpired%3F&quot;&gt;&lt;/a&gt;Why does the JM terminate running jobs when it can immediately connect to another ZK node and its ZK session has not expired?&lt;/h5&gt;

&lt;p&gt;This seems to be a result of using the&#160;LeaderLatch recipe in Curator. &#160;It&apos;s &lt;a href=&quot;https://github.com/Netflix/curator/wiki/Leader-Latch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;docs&lt;/a&gt; state:&#160;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;LeaderLatch instances add a ConnectionStateListener to watch for connection problems. If SUSPENDED or LOST is reported, the LeaderLatch that is the &lt;b&gt;leader will report that it is no longer the leader&lt;/b&gt; (i.e. there will not be a leader until the connection is re-established). If a LOST connection is RECONNECTED, the LeaderLatch &lt;b&gt;will delete its previous ZNode and create a new one&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;Users of LeaderLatch must take account that connection issues can cause leadership to be lost. i.e. hasLeadership() returns true but some time later the connection is SUSPENDED or LOST. At that point hasLeadership() will return false. It is highly recommended that LeaderLatch users register a ConnectionStateListener.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;So not only is leadership lost while disconnected, but will likely stay&#160;lost when reconnecting as a result of the znode deletion and recreation.&lt;/p&gt;

&lt;p&gt;This can probably be solved by using the Curator LeaderElection recipe instead, which &lt;a href=&quot;https://github.com/Netflix/curator/wiki/Leader-Election&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;states&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The &lt;tt&gt;LeaderSelectorListener&lt;/tt&gt; class extends &lt;tt&gt;ConnectionStateListener&lt;/tt&gt;. When the LeaderSelector is started, it adds the listener to the Curator instance. Users of the &lt;tt&gt;LeaderSelector&lt;/tt&gt; must pay attention to any connection state changes. If an instance becomes the leader, it should respond to notification of being SUSPENDED or LOST.&lt;/p&gt;

&lt;p&gt;If the SUSPENDED state is reported, the instance must assume that it might no longer be the leader until it receives a RECONNECTED state. If the LOST state is reported, the instance is no longer the leader and its &lt;tt&gt;takeLeadership&lt;/tt&gt; method should exit.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;So with LeaderElection it seems that what to do during the SUSPENDED state is left up to the application, which may choose to continue being leader until the state becomes LOST.&lt;/p&gt;

&lt;p&gt;Obviously there are dangers with doing so, but at the very least you would expect the JM not to give up leadership until it tried to connect to other ZK members within the remaining ZK session timeout.&lt;/p&gt;

&lt;p&gt;This problem has been &lt;a href=&quot;http://apache-flink-mailing-list-archive.1008284.n3.nabble.com/Zookeeper-failure-handling-td19611.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;previously discussed&lt;/a&gt; in the mailing list, which led to&#160;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6174&quot; title=&quot;Introduce a leader election service in yarn mode to make JobManager always available&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-6174&quot;&gt;&lt;del&gt;FLINK-6174&lt;/del&gt;&lt;/a&gt;&#160;and this &lt;a href=&quot;https://github.com/apache/flink/pull/3599&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;PR&lt;/a&gt;, which appears to be a modification of the Curator LeaderLatch recipe. &#160;It also lead to&#160;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5703&quot; title=&quot;ExecutionGraph recovery based on reconciliation with TaskManager reports&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5703&quot;&gt;&lt;del&gt;FLINK-5703&lt;/del&gt;&lt;/a&gt;, which seems like an attempt to keep jobs running during JM failover. &#160;While that is a valuable addition, I argue that is not required to avoid this failure, as the previous leader can continue being leader so long as it connects to a new ZK before its ZK session expires.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;h5&gt;&lt;a name=&quot;WhydidJM1resurrecttheoldjob%3F&quot;&gt;&lt;/a&gt;Why did JM 1 resurrect the old job?&lt;/h5&gt;

&lt;p&gt;Something must have been off with the state stored in the S3 HA recovery directory. &#160;The job must have not been fully removed. &#160;&lt;/p&gt;

&lt;p&gt;In fact, right now the recovery directory has the file&#160;submittedJobGraph7f627a661cec which appears to be job &lt;font color=&quot;#14892c&quot;&gt;2a4eff355aef849c5ca37dbac04f2ff1&lt;/font&gt;. Is that expected? &#160;That job is no longer running. &#160;Shouldn&apos;t that file no longer exist in the recovery directory?&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</description>
                <environment></environment>
        <key id="13175977">FLINK-10011</key>
            <summary>Old job resurrected during HA failover</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="trohrmann">Till Rohrmann</assignee>
                                    <reporter username="elevy">Elias Levy</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Tue, 31 Jul 2018 22:38:43 +0000</created>
                <updated>Fri, 27 Sep 2019 10:25:25 +0000</updated>
                            <resolved>Wed, 12 Sep 2018 14:52:02 +0000</resolved>
                                    <version>1.4.2</version>
                    <version>1.5.2</version>
                    <version>1.6.0</version>
                                    <fixVersion>1.4.3</fixVersion>
                    <fixVersion>1.5.4</fixVersion>
                    <fixVersion>1.6.1</fixVersion>
                    <fixVersion>1.7.0</fixVersion>
                                    <component>Runtime / Coordination</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>19</watches>
                                                                                                                <comments>
                            <comment id="16564569" author="elevy" created="Wed, 1 Aug 2018 00:47:19 +0000"  >&lt;p&gt;It appears that it may not be necessary to replace the &lt;tt&gt;LeaderLatch&lt;/tt&gt; Curator recipe to avoid loosing leadership during temporary connection failures.&lt;/p&gt;

&lt;p&gt;The Curator error handling &lt;a href=&quot;https://curator.apache.org/errors.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;documentation&lt;/a&gt; talks about a&#160;&lt;tt&gt;SessionConnectionStateErrorPolicy&lt;/tt&gt; that treats &lt;tt&gt;SUSPENDED&lt;/tt&gt; and &lt;tt&gt;LOST&lt;/tt&gt; connection states differently. &#160;And this &lt;a href=&quot;https://github.com/apache/curator/blob/d502dde1c4601b2abc6d831d764561a73316bf00/curator-recipes/src/test/java/org/apache/curator/framework/recipes/leader/TestLeaderLatch.java#L72-L146&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;test&lt;/a&gt; shows how leadership is not lost with a&#160;&lt;tt&gt;LeaderLatch&lt;/tt&gt;&#160;and that policy. &#160;The &lt;a href=&quot;https://github.com/apache/curator/blob/ed3082ecfebc332ba96da7a5bda4508a1985db6e/curator-recipes/src/main/java/org/apache/curator/framework/recipes/leader/LeaderLatch.java#L625-L631&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;code&lt;/a&gt; implementing the policy. &#160;And &lt;a href=&quot;https://github.com/apache/curator/blob/5920c744508afd678a20309313e1b8d78baac0c4/curator-framework/src/main/java/org/apache/curator/framework/state/ConnectionStateManager.java#L298-L314&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;this shows&lt;/a&gt; that Curator will inject a session expiration even while it is in &lt;tt&gt;SUSPENDED&lt;/tt&gt; state, so that a disconnected client won&apos;t continue to think it is leader past its session expiration.&lt;/p&gt;</comment>
                            <comment id="16564573" author="elevy" created="Wed, 1 Aug 2018 00:50:10 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trohrmann%40apache.org&quot; class=&quot;user-hover&quot; rel=&quot;trohrmann@apache.org&quot;&gt;trohrmann@apache.org&lt;/a&gt; what do you think?&lt;/p&gt;</comment>
                            <comment id="16565583" author="azagrebin" created="Wed, 1 Aug 2018 16:28:07 +0000"  >&lt;p&gt;This problem might be related to the recently fixed race condition in&#160;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9575&quot; title=&quot;Potential race condition when removing JobGraph in HA&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9575&quot;&gt;&lt;del&gt;FLINK-9575&lt;/del&gt;&lt;/a&gt;. It is about async deletion of graph and sync deletion of canceled job&apos;s blob data, so that&#160;async deletion might fail and graph stays then.&lt;/p&gt;</comment>
                            <comment id="16566032" author="elevy" created="Wed, 1 Aug 2018 21:43:43 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=azagrebin&quot; class=&quot;user-hover&quot; rel=&quot;azagrebin&quot;&gt;azagrebin&lt;/a&gt; I don&apos;t think they are the same issue.  The issue I am observing is that the new JM leader after a failover can&apos;t delete a job graph in ZK when it is canceled because the previous JM leader still has the job graph locked in ZK via the child ephemeral node.&lt;/p&gt;

&lt;p&gt;This is the state in ZK:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;zk: localhost:2181(CONNECTED) 5&amp;#93;&lt;/span&gt; ls /flink/cluster_1/jobgraphs&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;d77948df92813a68ea6dfd6783f40e7e, 2a4eff355aef849c5ca37dbac04f2ff1&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Job 2a4eff355aef849c5ca37dbac04f2ff1 was running before fail over and we canceled after fail over.  The job is no longer running, but it is still in ZK.&lt;/p&gt;

&lt;p&gt;In the logs we see that the JM 1 (10.210.22.167), that one that became leader after failover, thinks it deleted the 2a4eff355aef849c5ca37dbac04f2ff1 job from ZK when it was canceled:&lt;/p&gt;

&lt;p&gt;July 30th 2018, 15:32:27.231	Trying to cancel job with ID 2a4eff355aef849c5ca37dbac04f2ff1.&lt;br/&gt;
July 30th 2018, 15:32:27.232	Job Some Job (2a4eff355aef849c5ca37dbac04f2ff1) switched from state RESTARTING to CANCELED.&lt;br/&gt;
July 30th 2018, 15:32:27.232	Stopping checkpoint coordinator for job 2a4eff355aef849c5ca37dbac04f2ff1&lt;br/&gt;
July 30th 2018, 15:32:27.239	Removed job graph 2a4eff355aef849c5ca37dbac04f2ff1 from ZooKeeper.&lt;br/&gt;
July 30th 2018, 15:32:27.245	Removing /flink/cluster_1/checkpoints/2a4eff355aef849c5ca37dbac04f2ff1 from ZooKeeper&lt;br/&gt;
July 30th 2018, 15:32:27.251	Removing /checkpoint-counter/2a4eff355aef849c5ca37dbac04f2ff1 from ZooKeeper&lt;/p&gt;

&lt;p&gt;Looking at the ZK logs I find the problem:&lt;/p&gt;

&lt;p&gt;July 30th 2018, 15:32:27.241	Got user-level KeeperException when processing sessionid:0x2000001d2330001 type:delete cxid:0x434c zxid:0x60009dd94 txntype:-1 reqpath:n/a Error Path:/flink/cluster_1/jobgraphs/2a4eff355aef849c5ca37dbac04f2ff1 Error:KeeperErrorCode = Directory not empty for /flink/cluster_1/jobgraphs/2a4eff355aef849c5ca37dbac04f2ff1&lt;/p&gt;

&lt;p&gt;Looking in ZK, we see:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;zk: localhost:2181(CONNECTED) 0&amp;#93;&lt;/span&gt; ls /flink/cluster_1/jobgraphs/2a4eff355aef849c5ca37dbac04f2ff1&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;d833418c-891a-4b5e-b983-080be803275c&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;From the comments in ZooKeeperStateHandleStore.java I gather that this child node is used as a deletion lock.  Looking at the contents of this ephemeral lock node:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;zk: localhost:2181(CONNECTED) 16&amp;#93;&lt;/span&gt; get /flink/cluster_1/jobgraphs/2a4eff355aef849c5ca37dbac04f2ff1/d833418c-891a-4b5e-b983-080be803275c&lt;br/&gt;
10.210.42.62&lt;br/&gt;
cZxid = 0x60002ffa7&lt;br/&gt;
ctime = Tue Jun 12 20:01:26 UTC 2018&lt;br/&gt;
mZxid = 0x60002ffa7&lt;br/&gt;
mtime = Tue Jun 12 20:01:26 UTC 2018&lt;br/&gt;
pZxid = 0x60002ffa7&lt;br/&gt;
cversion = 0&lt;br/&gt;
dataVersion = 0&lt;br/&gt;
aclVersion = 0&lt;br/&gt;
ephemeralOwner = 0x30000003f4a0003&lt;br/&gt;
dataLength = 12&lt;br/&gt;
numChildren = 0&lt;/p&gt;

&lt;p&gt;and compared to the ephemeral node lock of the currently running job:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;zk: localhost:2181(CONNECTED) 17&amp;#93;&lt;/span&gt; get /flink/cluster_1/jobgraphs/d77948df92813a68ea6dfd6783f40e7e/596a4add-9f5c-4113-99ec-9c942fe91172&lt;br/&gt;
10.210.22.167&lt;br/&gt;
cZxid = 0x60009df4b&lt;br/&gt;
ctime = Mon Jul 30 23:01:04 UTC 2018&lt;br/&gt;
mZxid = 0x60009df4b&lt;br/&gt;
mtime = Mon Jul 30 23:01:04 UTC 2018&lt;br/&gt;
pZxid = 0x60009df4b&lt;br/&gt;
cversion = 0&lt;br/&gt;
dataVersion = 0&lt;br/&gt;
aclVersion = 0&lt;br/&gt;
ephemeralOwner = 0x2000001d2330001&lt;br/&gt;
dataLength = 13&lt;br/&gt;
numChildren = 0&lt;/p&gt;

&lt;p&gt;Assuming the content of the nodes represent the owner, it seems the job graph for the old canceled job, 2a4eff355aef849c5ca37dbac04f2ff1, is locked by the previous JM leader, JM 2(10.210.42.62), while the running job locked by the current JM leader, JM 1 (10.210.22.167).&lt;/p&gt;

&lt;p&gt;Somehow the previous leader, JM 2, did not give up the lock when leadership failed over to JM 2.  Note that JM 2 never lost it&apos;s ZK session, as it recovered it when it connected to another ZK node.  So some code in the JobManager needed to explicitly release the lock on the job graph during failover and failed to do so.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=till.rohrmann&quot; class=&quot;user-hover&quot; rel=&quot;till.rohrmann&quot;&gt;till.rohrmann&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=uce&quot; class=&quot;user-hover&quot; rel=&quot;uce&quot;&gt;uce&lt;/a&gt; I think you wrote the ZK HA code.  Any thoughts?&lt;/p&gt;</comment>
                            <comment id="16568489" author="till.rohrmann" created="Fri, 3 Aug 2018 17:09:17 +0000"  >&lt;p&gt;I think your analysis is correct &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=elevy&quot; class=&quot;user-hover&quot; rel=&quot;elevy&quot;&gt;elevy&lt;/a&gt; and the problem is that in a multi standby JobManager scenario, it can happen that old leaders can keep locks on &lt;tt&gt;JobGraphs&lt;/tt&gt;. As Elias proposed, we should explicitly free locked resources in case of a lost leadership in order to solve this problem. This issue not only affects the legacy mode but also the new mode.&lt;/p&gt;

&lt;p&gt;A somewhat related problem is to harden Flink&apos;s behaviour in case of a suspended ZooKeeper connection. I think it is a good idea to wait for the ZooKeeper session timeout before giving up the leadership instead of doing it right away. That way, Flink could tolerate ZooKeeper hickups/network issues without failing an executed job. I would like to create a new JIRA issue for this improvement since the underlying problem of this issue is the non released lock on the &lt;tt&gt;JobGraph&lt;/tt&gt;.&lt;/p&gt;


</comment>
                            <comment id="16568511" author="till.rohrmann" created="Fri, 3 Aug 2018 17:32:45 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10052&quot; title=&quot;Tolerate temporarily suspended ZooKeeper connections&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10052&quot;&gt;&lt;del&gt;FLINK-10052&lt;/del&gt;&lt;/a&gt; is the dedicated issue for allowing Flink to tolerate temporarily suspended ZooKeeper connections.&lt;/p&gt;</comment>
                            <comment id="16586618" author="githubbot" created="Mon, 20 Aug 2018 22:47:51 +0000"  >&lt;p&gt;tillrohrmann opened a new pull request #6587: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6587&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   This PR fixes the problem that sometimes `JobGraphs` cannot be removed from the `ZooKeeperSubmittedJobGraphStore` because a former leader might still keep a lock on the `JobGraph`. This usually happens in multi stand-by JobManager/Dispatcher scenarios, where a leader loses leadership due to a temporary network glitch but can restore its connection to ZooKeeper. The lock nodes, which are ephemeral and are created to protect against concurrent deletions, won&apos;t be deleted in this case and, thus, the `JobGraph` won&apos;t be removable by the new leader.&lt;/p&gt;

&lt;p&gt;   The problem will be solved by explicitly removing all locks a `JobManager`/`Dispatcher` keeps on the stored `JobGraphs` if it loses leadership.&lt;/p&gt;

&lt;p&gt;   This PR is based on #6586 &lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   SubmitedJobGraphStore#releaseJobGraph removes a potentially existing lock&lt;br/&gt;
   from the specified JobGraph. This allows other SubmittedJobGraphStores to&lt;br/&gt;
   remove the JobGraph given that it is no longer locked.&lt;/p&gt;

&lt;p&gt;   The JobManager now releases its lock on all JobGraphs it has stored in&lt;br/&gt;
   the SubmittedJobGraphStore if the JobManager loses leadership. This ensures&lt;br/&gt;
   that a different JobManager can delete these jobs after it has recovered&lt;br/&gt;
   them and reached a globally terminal state. This is especially important&lt;br/&gt;
   when using stand-by JobManagers where a former leader might still be&lt;br/&gt;
   connected to ZooKeeper and, thus, keeping all ephemeral nodes/locks.&lt;/p&gt;

&lt;p&gt;   The Dispatcher now releases all JobGraphs it has stored in the SubmittedJobGraphStore&lt;br/&gt;
   if it loses leadership. This ensures that the newly elected leader after recovering&lt;br/&gt;
   the jobs can remove them from the SubmittedJobGraphStore. Before, the problem was&lt;br/&gt;
   that a former leader might still be connected to ZooKeeper which keeps its ephemeral&lt;br/&gt;
   lock nodes alive. This could prevent the deletion of the JobGraph from ZooKeeper.&lt;br/&gt;
   The problem occurs in particular in multi stand-by Dispatcher scenarios.&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added `ZooKeeperHAJobManagerTest#testSubmittedJobGraphRelease` and `ZooKeeperHADispatcherTest#testSubmittedJobGraphRelease`&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (no)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (no)&lt;/li&gt;
	&lt;li&gt;The serializers: (no)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (no)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (yes)&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: (no)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (no)&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? (not applicable)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16586624" author="githubbot" created="Mon, 20 Aug 2018 22:50:09 +0000"  >&lt;p&gt;tillrohrmann opened a new pull request #6588: &lt;span class=&quot;error&quot;&gt;&amp;#91;Backport 1.6&amp;#93;&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6588&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6588&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   Backport of #6587 for `release-1.6`.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16586627" author="githubbot" created="Mon, 20 Aug 2018 22:53:23 +0000"  >&lt;p&gt;tillrohrmann opened a new pull request #6589: &lt;span class=&quot;error&quot;&gt;&amp;#91;Backport 1.5&amp;#93;&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6589&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6589&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   Backport of #6587 for `release-1.5`.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16586652" author="githubbot" created="Mon, 20 Aug 2018 23:16:35 +0000"  >&lt;p&gt;tillrohrmann opened a new pull request #6590: &lt;span class=&quot;error&quot;&gt;&amp;#91;Backport 1.4&amp;#93;&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6590&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6590&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   Backport of #6587 for `release-1.4`.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16590519" author="githubbot" created="Thu, 23 Aug 2018 16:53:22 +0000"  >&lt;p&gt;azagrebin commented on a change in pull request #6587: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6587#discussion_r212379451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6587#discussion_r212379451&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,179 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.jobmanager;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.configuration.Configuration;&lt;br/&gt;
+import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
+import org.apache.flink.runtime.akka.ActorUtils;&lt;br/&gt;
+import org.apache.flink.runtime.akka.AkkaUtils;&lt;br/&gt;
+import org.apache.flink.runtime.akka.ListeningBehaviour;&lt;br/&gt;
+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;&lt;br/&gt;
+import org.apache.flink.runtime.dispatcher.DispatcherHATest;&lt;br/&gt;
+import org.apache.flink.runtime.dispatcher.NoOpSubmittedJobGraphListener;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.HighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.instance.ActorGateway;&lt;br/&gt;
+import org.apache.flink.runtime.instance.AkkaActorGateway;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;&lt;br/&gt;
+import org.apache.flink.runtime.messages.JobManagerMessages;&lt;br/&gt;
+import org.apache.flink.runtime.metrics.NoOpMetricRegistry;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingJobManager;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingJobManagerMessages;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingUtils;&lt;br/&gt;
+import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import akka.actor.ActorRef;&lt;br/&gt;
+import akka.actor.ActorSystem;&lt;br/&gt;
+import akka.actor.ExtendedActorSystem;&lt;br/&gt;
+import akka.actor.Identify;&lt;br/&gt;
+import akka.actor.Terminated;&lt;br/&gt;
+import akka.pattern.Patterns;&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.junit.AfterClass;&lt;br/&gt;
+import org.junit.BeforeClass;&lt;br/&gt;
+import org.junit.ClassRule;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.rules.TemporaryFolder;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+&lt;br/&gt;
+import scala.Option;&lt;br/&gt;
+import scala.concurrent.Await;&lt;br/&gt;
+import scala.concurrent.Future;&lt;br/&gt;
+import scala.concurrent.duration.FiniteDuration;&lt;br/&gt;
+&lt;br/&gt;
+import static org.hamcrest.Matchers.contains;&lt;br/&gt;
+import static org.hamcrest.Matchers.is;&lt;br/&gt;
+import static org.hamcrest.Matchers.not;&lt;br/&gt;
+import static org.hamcrest.Matchers.notNullValue;&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tests for the ZooKeeper HA service and &lt;/p&gt;
{@link JobManager} interaction.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ZooKeeperHAJobManagerTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final ZooKeeperResource ZOO_KEEPER_RESOURCE = new ZooKeeperResource();&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();&lt;br/&gt;
+&lt;br/&gt;
+	private static final FiniteDuration TIMEOUT = FiniteDuration.apply(10L, TimeUnit.SECONDS);&lt;br/&gt;
+&lt;br/&gt;
+	private static ActorSystem system;&lt;br/&gt;
+&lt;br/&gt;
+	@BeforeClass&lt;br/&gt;
+	public static void setup() {
+		system = AkkaUtils.createLocalActorSystem(new Configuration());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@AfterClass&lt;br/&gt;
+	public static void teardown() throws Exception {
+		final Future&amp;lt;Terminated&amp;gt; terminationFuture = system.terminate();
+		Await.ready(terminationFuture, TIMEOUT);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the {@link JobManager}
&lt;p&gt; releases all locked &lt;/p&gt;
{@link JobGraph}
&lt;p&gt; if it loses&lt;br/&gt;
+	 * leadership.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testJobGraphReleaseWhenLosingLeadership() throws Exception {&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, ZOO_KEEPER_RESOURCE.getConnectString());&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_STORAGE_PATH, TEMPORARY_FOLDER.newFolder().getAbsolutePath());&lt;br/&gt;
+&lt;br/&gt;
+		final TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices();&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I suggest to put all closables in tests to try(...) with resources to avoid possible conflicts with other tests, even if `close()` is empty currently.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16590520" author="githubbot" created="Thu, 23 Aug 2018 16:53:22 +0000"  >&lt;p&gt;azagrebin commented on a change in pull request #6587: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6587#discussion_r212321052&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6587#discussion_r212321052&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -237,7 +239,18 @@ public void addCheckpoint(final CompletedCheckpoint checkpoint) throws Exception&lt;br/&gt;
 		// Everything worked, let&apos;s remove a previous checkpoint if necessary.&lt;br/&gt;
 		while (completedCheckpoints.size() &amp;gt; maxNumberOfCheckpointsToRetain) {&lt;br/&gt;
 			try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;removeSubsumed(completedCheckpoints.removeFirst());&lt;br/&gt;
+				final CompletedCheckpoint completedCheckpoint = completedCheckpoints.removeFirst();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   I would try to move the whole try/catch into one method to deduplicate code with `shutdown()`, e.g.:&lt;br/&gt;
   ```&lt;br/&gt;
   void tryRemove(Runnable doRemove) {&lt;br/&gt;
     try &lt;/p&gt;
{
       // ..
         doRemove.run(); // completedCheckpoint.discardOnSubsume(); or OnShutdown
       // ..
     }
&lt;p&gt; catch &lt;/p&gt;
{
       // ...
     }
&lt;p&gt;   }&lt;br/&gt;
   ```&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16596355" author="githubbot" created="Wed, 29 Aug 2018 13:53:28 +0000"  >&lt;p&gt;tillrohrmann commented on issue #6587: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6587#issuecomment-416961912&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6587#issuecomment-416961912&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Unfortunately, this only fixes half of the problem. There is still another problem with standby Dispatchers/JobMaster. See &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-10255&lt;/a&gt; for more information. Nevertheless, I think this PR fixes a valid problem and thus should be merged after addressing @azagrebin comments.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16596459" author="till.rohrmann" created="Wed, 29 Aug 2018 15:19:50 +0000"  >&lt;p&gt;I might have misdiagnosed the underlying problem a little bit. Initially I thought that the &lt;tt&gt;JM2&lt;/tt&gt; did not release the lock it created when the job was initially submitted. However, in order for &lt;tt&gt;JM1&lt;/tt&gt; to become leader, &lt;tt&gt;JM2&lt;/tt&gt; needs to lose its ZooKeeper session (otherwise the ephemeral leader Znode would not be deleted). In this case, also the &lt;tt&gt;JobGraph&lt;/tt&gt; lock Znodes should be removed. &lt;/p&gt;

&lt;p&gt;So where do the lock nodes come from? The answer could come from &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt;. In Flip-6 we always recover and in pre-Flip-6 we sometimes jobs if we are not the leader. If we are not the leader, then we won&apos;t start execution of the job though. However, recovering the job will also lock it. Therefore, my suspicion is that the old leader &lt;tt&gt;JM2&lt;/tt&gt; actually recovered the job after it reconnected to ZooKeeper. If this is the case, then you should see the following log line in the log file of &lt;tt&gt;JM2&lt;/tt&gt;: &lt;tt&gt;org.apache.flink.runtime.jobmanager.ZooKeeperSubmittedJobGraphStore  - Recovered SubmittedJobGraph(&amp;lt;JOBID&amp;gt;, null)&lt;/tt&gt;. Do you still have the logs to check whether this is true or not &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=elevy&quot; class=&quot;user-hover&quot; rel=&quot;elevy&quot;&gt;elevy&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;An non-volatile variable could also explain why it only occurs sometimes with pre-Flip-6 and always with Flip-6.&lt;/p&gt;</comment>
                            <comment id="16608014" author="githubbot" created="Sat, 8 Sep 2018 10:52:32 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6587: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6587#discussion_r216127558&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6587#discussion_r216127558&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,179 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.jobmanager;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.configuration.Configuration;&lt;br/&gt;
+import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
+import org.apache.flink.runtime.akka.ActorUtils;&lt;br/&gt;
+import org.apache.flink.runtime.akka.AkkaUtils;&lt;br/&gt;
+import org.apache.flink.runtime.akka.ListeningBehaviour;&lt;br/&gt;
+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;&lt;br/&gt;
+import org.apache.flink.runtime.dispatcher.DispatcherHATest;&lt;br/&gt;
+import org.apache.flink.runtime.dispatcher.NoOpSubmittedJobGraphListener;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.HighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.instance.ActorGateway;&lt;br/&gt;
+import org.apache.flink.runtime.instance.AkkaActorGateway;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;&lt;br/&gt;
+import org.apache.flink.runtime.messages.JobManagerMessages;&lt;br/&gt;
+import org.apache.flink.runtime.metrics.NoOpMetricRegistry;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingJobManager;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingJobManagerMessages;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingUtils;&lt;br/&gt;
+import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import akka.actor.ActorRef;&lt;br/&gt;
+import akka.actor.ActorSystem;&lt;br/&gt;
+import akka.actor.ExtendedActorSystem;&lt;br/&gt;
+import akka.actor.Identify;&lt;br/&gt;
+import akka.actor.Terminated;&lt;br/&gt;
+import akka.pattern.Patterns;&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.junit.AfterClass;&lt;br/&gt;
+import org.junit.BeforeClass;&lt;br/&gt;
+import org.junit.ClassRule;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.rules.TemporaryFolder;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+&lt;br/&gt;
+import scala.Option;&lt;br/&gt;
+import scala.concurrent.Await;&lt;br/&gt;
+import scala.concurrent.Future;&lt;br/&gt;
+import scala.concurrent.duration.FiniteDuration;&lt;br/&gt;
+&lt;br/&gt;
+import static org.hamcrest.Matchers.contains;&lt;br/&gt;
+import static org.hamcrest.Matchers.is;&lt;br/&gt;
+import static org.hamcrest.Matchers.not;&lt;br/&gt;
+import static org.hamcrest.Matchers.notNullValue;&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tests for the ZooKeeper HA service and &lt;/p&gt;
{@link JobManager} interaction.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ZooKeeperHAJobManagerTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final ZooKeeperResource ZOO_KEEPER_RESOURCE = new ZooKeeperResource();&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();&lt;br/&gt;
+&lt;br/&gt;
+	private static final FiniteDuration TIMEOUT = FiniteDuration.apply(10L, TimeUnit.SECONDS);&lt;br/&gt;
+&lt;br/&gt;
+	private static ActorSystem system;&lt;br/&gt;
+&lt;br/&gt;
+	@BeforeClass&lt;br/&gt;
+	public static void setup() {
+		system = AkkaUtils.createLocalActorSystem(new Configuration());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@AfterClass&lt;br/&gt;
+	public static void teardown() throws Exception {
+		final Future&amp;lt;Terminated&amp;gt; terminationFuture = system.terminate();
+		Await.ready(terminationFuture, TIMEOUT);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the {@link JobManager}
&lt;p&gt; releases all locked &lt;/p&gt;
{@link JobGraph}
&lt;p&gt; if it loses&lt;br/&gt;
+	 * leadership.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testJobGraphReleaseWhenLosingLeadership() throws Exception {&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, ZOO_KEEPER_RESOURCE.getConnectString());&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_STORAGE_PATH, TEMPORARY_FOLDER.newFolder().getAbsolutePath());&lt;br/&gt;
+&lt;br/&gt;
+		final TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices();&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Good point. Will refactor it.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16608017" author="githubbot" created="Sat, 8 Sep 2018 11:06:12 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6587: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6587#discussion_r216127860&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6587#discussion_r216127860&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -237,7 +239,18 @@ public void addCheckpoint(final CompletedCheckpoint checkpoint) throws Exception&lt;br/&gt;
 		// Everything worked, let&apos;s remove a previous checkpoint if necessary.&lt;br/&gt;
 		while (completedCheckpoints.size() &amp;gt; maxNumberOfCheckpointsToRetain) {&lt;br/&gt;
 			try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;removeSubsumed(completedCheckpoints.removeFirst());&lt;br/&gt;
+				final CompletedCheckpoint completedCheckpoint = completedCheckpoints.removeFirst();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Good idea. I&apos;ve changed it according to your suggestion.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612230" author="githubbot" created="Wed, 12 Sep 2018 14:37:38 +0000"  >&lt;p&gt;tillrohrmann commented on issue #6587: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6587#issuecomment-420672486&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6587#issuecomment-420672486&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Thanks for the review @azagrebin. Merging this PR.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612245" author="githubbot" created="Wed, 12 Sep 2018 14:45:11 +0000"  >&lt;p&gt;asfgit closed pull request #6587: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6587&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java b/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java&lt;br/&gt;
index 069cb833a3a..45d11412c50 100644&lt;br/&gt;
&amp;#8212; a/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java&lt;br/&gt;
+++ b/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java&lt;br/&gt;
@@ -56,8 +56,7 @@ public MesosWorkerStore createMesosWorkerStore(Configuration configuration, Exec&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;MesosWorkerStore.Worker&amp;gt; zooKeeperStateHandleStore = zooKeeperUtilityFactory.createZooKeeperStateHandleStore(&lt;br/&gt;
 			&quot;/workers&quot;,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;stateStorageHelper,&lt;/li&gt;
	&lt;li&gt;executor);&lt;br/&gt;
+			stateStorageHelper);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperSharedValue frameworkId = zooKeeperUtilityFactory.createSharedValue(&quot;/frameworkId&quot;, new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
 		ZooKeeperSharedCount totalTaskCount = zooKeeperUtilityFactory.createSharedCount(&quot;/taskCount&quot;, 0);&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java&lt;br/&gt;
index f2f905971c3..9a992814235 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java&lt;br/&gt;
@@ -19,9 +19,11 @@&lt;br/&gt;
 package org.apache.flink.runtime.akka;&lt;/p&gt;

&lt;p&gt; import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.runtime.instance.AkkaActorGateway;&lt;/p&gt;

&lt;p&gt; import akka.actor.ActorRef;&lt;br/&gt;
 import akka.actor.Kill;&lt;br/&gt;
+import akka.actor.PoisonPill;&lt;br/&gt;
 import akka.pattern.Patterns;&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
@@ -85,5 +87,13 @@&lt;br/&gt;
 		return FutureUtils.completeAll(terminationFutures);&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	public static void stopActor(AkkaActorGateway akkaActorGateway) &lt;/p&gt;
{
+		stopActor(akkaActorGateway.actor());
+	}
&lt;p&gt;+&lt;br/&gt;
+	public static void stopActor(ActorRef actorRef) &lt;/p&gt;
{
+		actorRef.tell(PoisonPill.getInstance(), ActorRef.noSender());
+	}
&lt;p&gt;+&lt;br/&gt;
 	private ActorUtils() {}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
index f22127041d3..131733924ae 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
@@ -25,14 +25,13 @@&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;&lt;br/&gt;
 import org.apache.flink.util.FlinkException;&lt;br/&gt;
+import org.apache.flink.util.function.ConsumerWithException;&lt;/p&gt;

&lt;p&gt; import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
 import org.apache.curator.utils.ZKPaths;&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;/p&gt;

&lt;p&gt;-import javax.annotation.Nullable;&lt;br/&gt;
-&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.util.ArrayDeque;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
@@ -86,6 +85,8 @@&lt;br/&gt;
 	 */&lt;br/&gt;
 	private final ArrayDeque&amp;lt;CompletedCheckpoint&amp;gt; completedCheckpoints;&lt;/p&gt;

&lt;p&gt;+	private final Executor executor;&lt;br/&gt;
+&lt;br/&gt;
 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Creates a 
{@link ZooKeeperCompletedCheckpointStore} instance.&lt;br/&gt;
 	 *&lt;br/&gt;
@@ -98,7 +99,7 @@&lt;br/&gt;
 	 *                                       start with a &apos;/&apos;)&lt;br/&gt;
 	 * @param stateStorage                   State storage to be used to persist the completed&lt;br/&gt;
 	 *                                       checkpoint&lt;br/&gt;
-	 * @param executor to give to the ZooKeeperStateHandleStore to run ZooKeeper callbacks&lt;br/&gt;
+	 * @param executor to execute blocking calls&lt;br/&gt;
 	 * @throws Exception&lt;br/&gt;
 	 */&lt;br/&gt;
 	public ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
@@ -123,10 +124,12 @@ public ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
 		// All operations will have the path as root&lt;br/&gt;
 		this.client = client.usingNamespace(client.getNamespace() + checkpointsPath);&lt;br/&gt;
 &lt;br/&gt;
-		this.checkpointsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(this.client, stateStorage, executor);&lt;br/&gt;
+		this.checkpointsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(this.client, stateStorage);&lt;br/&gt;
 &lt;br/&gt;
 		this.completedCheckpoints = new ArrayDeque&amp;lt;&amp;gt;(maxNumberOfCheckpointsToRetain + 1);&lt;br/&gt;
 &lt;br/&gt;
+		this.executor = checkNotNull(executor);&lt;br/&gt;
+&lt;br/&gt;
 		LOG.info(&quot;Initialized in &apos;{}&apos;.&quot;, checkpointsPath);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
@@ -236,16 +239,30 @@ public void addCheckpoint(final CompletedCheckpoint checkpoint) throws Exception&lt;br/&gt;
 &lt;br/&gt;
 		// Everything worked, let&apos;s remove a previous checkpoint if necessary.&lt;br/&gt;
 		while (completedCheckpoints.size() &amp;gt; maxNumberOfCheckpointsToRetain) {&lt;br/&gt;
-			try {
-				removeSubsumed(completedCheckpoints.removeFirst());
-			} catch (Exception e) {
-				LOG.warn(&quot;Failed to subsume the old checkpoint&quot;, e);
-			}&lt;br/&gt;
+			final CompletedCheckpoint completedCheckpoint = completedCheckpoints.removeFirst();&lt;br/&gt;
+			tryRemoveCompletedCheckpoint(completedCheckpoint, CompletedCheckpoint::discardOnSubsume);&lt;br/&gt;
 		}&lt;br/&gt;
 &lt;br/&gt;
 		LOG.debug(&quot;Added {} to {}.&quot;, checkpoint, path);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	private void tryRemoveCompletedCheckpoint(CompletedCheckpoint completedCheckpoint, ConsumerWithException&amp;lt;CompletedCheckpoint, Exception&amp;gt; discardCallback) {&lt;br/&gt;
+		try {&lt;br/&gt;
+			if (tryRemove(completedCheckpoint.getCheckpointID())) {&lt;br/&gt;
+				executor.execute(() -&amp;gt; {&lt;br/&gt;
+					try {
+						discardCallback.accept(completedCheckpoint);
+					} catch (Exception e) {&lt;br/&gt;
+						LOG.warn(&quot;Could not discard completed checkpoint {}.&quot;, completedCheckpoint.getCheckpointID(), e);&lt;br/&gt;
+					}&lt;br/&gt;
+				});&lt;br/&gt;
+&lt;br/&gt;
+			}&lt;br/&gt;
+		} catch (Exception e) {
+			LOG.warn(&quot;Failed to subsume the old checkpoint&quot;, e);
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public CompletedCheckpoint getLatestCheckpoint() {&lt;br/&gt;
 		if (completedCheckpoints.isEmpty()) {&lt;br/&gt;
@@ -278,11 +295,9 @@ public void shutdown(JobStatus jobStatus) throws Exception {&lt;br/&gt;
 			LOG.info(&quot;Shutting down&quot;);&lt;br/&gt;
 &lt;br/&gt;
 			for (CompletedCheckpoint checkpoint : completedCheckpoints) {&lt;br/&gt;
-				try {
-					removeShutdown(checkpoint, jobStatus);
-				} catch (Exception e) {
-					LOG.error(&quot;Failed to discard checkpoint.&quot;, e);
-				}&lt;br/&gt;
+				tryRemoveCompletedCheckpoint(&lt;br/&gt;
+					checkpoint,&lt;br/&gt;
+					completedCheckpoint -&amp;gt; completedCheckpoint.discardOnShutdown(jobStatus));&lt;br/&gt;
 			}&lt;br/&gt;
 &lt;br/&gt;
 			completedCheckpoints.clear();&lt;br/&gt;
@@ -305,59 +320,13 @@ public void shutdown(JobStatus jobStatus) throws Exception {&lt;br/&gt;
 	// ------------------------------------------------------------------------&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
-	 * Removes a subsumed checkpoint from ZooKeeper and drops the state.&lt;br/&gt;
-	 */&lt;br/&gt;
-	private void removeSubsumed(&lt;br/&gt;
-		final CompletedCheckpoint completedCheckpoint) throws Exception {&lt;br/&gt;
-&lt;br/&gt;
-		if (completedCheckpoint == null) {
-			return;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt; action =&lt;br/&gt;
-			new ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt;() {&lt;br/&gt;
-				@Override&lt;br/&gt;
-				public void apply(@Nullable RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; value) throws FlinkException {&lt;br/&gt;
-					if (value != null) {&lt;br/&gt;
-						try {
-							completedCheckpoint.discardOnSubsume();
-						} catch (Exception e) {
-							throw new FlinkException(&quot;Could not discard the completed checkpoint on subsume.&quot;, e);
-						}&lt;br/&gt;
-					}&lt;br/&gt;
-				}&lt;br/&gt;
-			};&lt;br/&gt;
-&lt;br/&gt;
-		checkpointsInZooKeeper.releaseAndTryRemove(&lt;br/&gt;
-			checkpointIdToPath(completedCheckpoint.getCheckpointID()),&lt;br/&gt;
-			action);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Removes a checkpoint from ZooKeeper because of Job shutdown and drops the state.&lt;br/&gt;
+	 * Tries to remove the checkpoint identified by the given checkpoint id.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param checkpointId identifying the checkpoint to remove&lt;br/&gt;
+	 * @return true if the checkpoint could be removed&lt;br/&gt;
 	 */&lt;br/&gt;
-	private void removeShutdown(&lt;br/&gt;
-			final CompletedCheckpoint completedCheckpoint,&lt;br/&gt;
-			final JobStatus jobStatus) throws Exception {&lt;br/&gt;
-&lt;br/&gt;
-		if (completedCheckpoint == null) {-			return;-		}&lt;br/&gt;
-&lt;br/&gt;
-		ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt; removeAction = new ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt;() {&lt;br/&gt;
-			@Override&lt;br/&gt;
-			public void apply(@Nullable RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; value) throws FlinkException {&lt;br/&gt;
-				try {
-					completedCheckpoint.discardOnShutdown(jobStatus);
-				} catch (Exception e) {
-					throw new FlinkException(&quot;Could not discard the completed checkpoint on subsume.&quot;, e);
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-		};&lt;br/&gt;
-&lt;br/&gt;
-		checkpointsInZooKeeper.releaseAndTryRemove(&lt;br/&gt;
-			checkpointIdToPath(completedCheckpoint.getCheckpointID()),&lt;br/&gt;
-			removeAction);&lt;br/&gt;
+	private boolean tryRemove(long checkpointId) throws Exception {
+		return checkpointsInZooKeeper.releaseAndTryRemove(checkpointIdToPath(checkpointId));
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -381,7 +350,7 @@ public static long pathToCheckpointId(String path) {&lt;br/&gt;
 			String numberString;&lt;br/&gt;
 &lt;br/&gt;
 			// check if we have a leading slash&lt;br/&gt;
-			if (&apos;/&apos; == path.charAt(0) ) {&lt;br/&gt;
+			if (&apos;/&apos; == path.charAt(0)) {
 				numberString = path.substring(1);
 			} else {
 				numberString = path;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
index c96acbd3192..c31e64c0adc 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
@@ -572,30 +572,38 @@ private void registerJobManagerRunnerTerminationFuture(JobID jobId, CompletableF
 		}&lt;br/&gt;
 &lt;br/&gt;
 		return jobManagerRunnerTerminationFuture.thenRunAsync(&lt;br/&gt;
-			() -&amp;gt; {
-				jobManagerMetricGroup.removeJob(jobId);
+			() -&amp;gt; cleanUpJobData(jobId, cleanupHA),
+			getRpcService().getExecutor());
+	}&lt;br/&gt;
 &lt;br/&gt;
-				boolean cleanupHABlobs = false;&lt;br/&gt;
-				if (cleanupHA) {&lt;br/&gt;
-					try {&lt;br/&gt;
-						submittedJobGraphStore.removeJobGraph(jobId);&lt;br/&gt;
+	private void cleanUpJobData(JobID jobId, boolean cleanupHA) {
+		jobManagerMetricGroup.removeJob(jobId);
 
-						// only clean up the HA blobs if we could remove the job from HA storage
-						cleanupHABlobs = true;
-					} catch (Exception e) {&lt;br/&gt;
-						log.warn(&quot;Could not properly remove job {} from submitted job graph store.&quot;, jobId, e);&lt;br/&gt;
-					}&lt;br/&gt;
+		boolean cleanupHABlobs = false;&lt;br/&gt;
+		if (cleanupHA) {&lt;br/&gt;
+			try {&lt;br/&gt;
+				submittedJobGraphStore.removeJobGraph(jobId);&lt;br/&gt;
 &lt;br/&gt;
-					try {
-						runningJobsRegistry.clearJob(jobId);
-					} catch (IOException e) {&lt;br/&gt;
-						log.warn(&quot;Could not properly remove job {} from the running jobs registry.&quot;, jobId, e);&lt;br/&gt;
-					}&lt;br/&gt;
-				}&lt;br/&gt;
+				// only clean up the HA blobs if we could remove the job from HA storage&lt;br/&gt;
+				cleanupHABlobs = true;&lt;br/&gt;
+			} catch (Exception e) {&lt;br/&gt;
+				log.warn(&quot;Could not properly remove job {} from submitted job graph store.&quot;, jobId, e);&lt;br/&gt;
+			}&lt;br/&gt;
 &lt;br/&gt;
-				blobServer.cleanupJob(jobId, cleanupHABlobs);&lt;br/&gt;
-			},&lt;br/&gt;
-			getRpcService().getExecutor());&lt;br/&gt;
+			try {
+				runningJobsRegistry.clearJob(jobId);
+			} catch (IOException e) {&lt;br/&gt;
+				log.warn(&quot;Could not properly remove job {} from the running jobs registry.&quot;, jobId, e);&lt;br/&gt;
+			}&lt;br/&gt;
+		} else {&lt;br/&gt;
+			try {
+				submittedJobGraphStore.releaseJobGraph(jobId);
+			} catch (Exception e) {&lt;br/&gt;
+				log.warn(&quot;Could not properly release job {} from submitted job graph store.&quot;, jobId, e);&lt;br/&gt;
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		blobServer.cleanupJob(jobId, cleanupHABlobs);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -806,8 +814,7 @@ public void grantLeadership(final UUID newLeaderSessionID) {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	private CompletableFuture&amp;lt;Void&amp;gt; waitForTerminatingJobManager(JobID jobId, JobGraph jobGraph, ConsumerWithException&amp;lt;JobGraph, ?&amp;gt; action) {&lt;br/&gt;
-		final CompletableFuture&amp;lt;Void&amp;gt; jobManagerTerminationFuture = jobManagerTerminationFutures&lt;br/&gt;
-			.getOrDefault(jobId, CompletableFuture.completedFuture(null))&lt;br/&gt;
+		final CompletableFuture&amp;lt;Void&amp;gt; jobManagerTerminationFuture = getJobTerminationFuture(jobId)&lt;br/&gt;
 			.exceptionally((Throwable throwable) -&amp;gt; {&lt;br/&gt;
 				throw new CompletionException(&lt;br/&gt;
 					new DispatcherException(&lt;br/&gt;
@@ -822,6 +829,14 @@ public void grantLeadership(final UUID newLeaderSessionID) {
 			getMainThreadExecutor());
 	}&lt;br/&gt;
 &lt;br/&gt;
+	protected CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;br/&gt;
+		if (jobManagerRunners.containsKey(jobId)) {
+			return FutureUtils.completedExceptionally(new DispatcherException(String.format(&quot;Job with job id %s is still running.&quot;, jobId)));
+		} else {
+			return jobManagerTerminationFutures.getOrDefault(jobId, CompletableFuture.completedFuture(null));
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	private void setNewFencingToken(@Nullable DispatcherId dispatcherId) {&lt;br/&gt;
 		// clear the state if we&apos;ve been the leader before&lt;br/&gt;
 		if (getFencingToken() != null) {&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/SingleJobSubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/SingleJobSubmittedJobGraphStore.java&lt;br/&gt;
index 26d3abc2f1f..fe7f5f14cc8 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/SingleJobSubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/SingleJobSubmittedJobGraphStore.java&lt;br/&gt;
@@ -66,12 +66,17 @@ public void putJobGraph(SubmittedJobGraph jobGraph) throws Exception {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public void removeJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+	public void removeJobGraph(JobID jobId) {
 		// ignore
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) {
+		// ignore
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public Collection&amp;lt;JobID&amp;gt; getJobIds() {
 		return Collections.singleton(jobGraph.getJobID());
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java&lt;br/&gt;
index 3882479ce95..ea96d7d43d2 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java&lt;br/&gt;
@@ -179,7 +179,7 @@ public CheckpointRecoveryFactory getCheckpointRecoveryFactory() {&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
 	public SubmittedJobGraphStore getSubmittedJobGraphStore() throws Exception {
-		return ZooKeeperUtils.createSubmittedJobGraphs(client, configuration, executor);
+		return ZooKeeperUtils.createSubmittedJobGraphs(client, configuration);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java&lt;br/&gt;
index d1ca1a38853..f28621f0d69 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java&lt;br/&gt;
@@ -43,22 +43,27 @@ public void stop() {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public void putJobGraph(SubmittedJobGraph jobGraph) throws Exception {&lt;br/&gt;
+	public void putJobGraph(SubmittedJobGraph jobGraph) {
 		// Nothing to do
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public void removeJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+	public void removeJobGraph(JobID jobId) { 		// Nothing to do 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) {
+		// nothing to do
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public Collection&amp;lt;JobID&amp;gt; getJobIds() {
 		return Collections.emptyList();
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public SubmittedJobGraph recoverJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+	public SubmittedJobGraph recoverJobGraph(JobID jobId) {
 		return null;
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java&lt;br/&gt;
index 7e624ec6e1d..b40a4a2b95f 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java&lt;br/&gt;
@@ -19,6 +19,7 @@&lt;br/&gt;
 package org.apache.flink.runtime.jobmanager;&lt;br/&gt;
 &lt;br/&gt;
 import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
 &lt;br/&gt;
 import javax.annotation.Nullable;&lt;br/&gt;
 &lt;br/&gt;
@@ -58,6 +59,17 @@&lt;br/&gt;
 	 */&lt;br/&gt;
 	void removeJobGraph(JobID jobId) throws Exception;&lt;br/&gt;
 &lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Releases the locks on the specified {@link JobGraph}.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * Releasing the locks allows that another instance can delete the job from&lt;br/&gt;
+	 * the {@link SubmittedJobGraphStore}.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param jobId specifying the job to release the locks for&lt;br/&gt;
+	 * @throws Exception if the locks cannot be released&lt;br/&gt;
+	 */&lt;br/&gt;
+	void releaseJobGraph(JobID jobId) throws Exception;&lt;br/&gt;
+&lt;br/&gt;
 	/**&lt;br/&gt;
 	 * Get all job ids of submitted job graphs to the submitted job graph store.&lt;br/&gt;
 	 *&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java&lt;br/&gt;
index 7ba5d481177..2b935af229a 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java&lt;br/&gt;
@@ -41,7 +41,6 @@&lt;br/&gt;
 import java.util.HashSet;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Set;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
@@ -69,13 +68,13 @@&lt;br/&gt;
 	/** Lock to synchronize with the {@link SubmittedJobGraphListener}. */&lt;br/&gt;
 	private final Object cacheLock = new Object();&lt;br/&gt;
 &lt;br/&gt;
-	/** Client (not a namespace facade) */&lt;br/&gt;
+	/** Client (not a namespace facade). */&lt;br/&gt;
 	private final CuratorFramework client;&lt;br/&gt;
 &lt;br/&gt;
 	/** The set of IDs of all added job graphs. */&lt;br/&gt;
 	private final Set&amp;lt;JobID&amp;gt; addedJobGraphs = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
 &lt;br/&gt;
-	/** Completed checkpoints in ZooKeeper */&lt;br/&gt;
+	/** Completed checkpoints in ZooKeeper. */&lt;br/&gt;
 	private final ZooKeeperStateHandleStore&amp;lt;SubmittedJobGraph&amp;gt; jobGraphsInZooKeeper;&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -94,19 +93,17 @@&lt;br/&gt;
 	private boolean isRunning;&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
-	 * Submitted job graph store backed by ZooKeeper&lt;br/&gt;
+	 * Submitted job graph store backed by ZooKeeper.&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param client ZooKeeper client&lt;br/&gt;
 	 * @param currentJobsPath ZooKeeper path for current job graphs&lt;br/&gt;
 	 * @param stateStorage State storage used to persist the submitted jobs&lt;br/&gt;
-	 * @param executor to give to the ZooKeeperStateHandleStore to run ZooKeeper callbacks&lt;br/&gt;
 	 * @throws Exception&lt;br/&gt;
 	 */&lt;br/&gt;
 	public ZooKeeperSubmittedJobGraphStore(&lt;br/&gt;
 			CuratorFramework client,&lt;br/&gt;
 			String currentJobsPath,&lt;br/&gt;
-			RetrievableStateStorageHelper&amp;lt;SubmittedJobGraph&amp;gt; stateStorage,&lt;br/&gt;
-			Executor executor) throws Exception {&lt;br/&gt;
+			RetrievableStateStorageHelper&amp;lt;SubmittedJobGraph&amp;gt; stateStorage) throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 		checkNotNull(currentJobsPath, &quot;Current jobs path&quot;);&lt;br/&gt;
 		checkNotNull(stateStorage, &quot;State storage&quot;);&lt;br/&gt;
@@ -123,7 +120,7 @@ public ZooKeeperSubmittedJobGraphStore(&lt;br/&gt;
 		CuratorFramework facade = client.usingNamespace(client.getNamespace() + currentJobsPath);&lt;br/&gt;
 &lt;br/&gt;
 		this.zooKeeperFullBasePath = client.getNamespace() + currentJobsPath;&lt;br/&gt;
-		this.jobGraphsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(facade, stateStorage, executor);&lt;br/&gt;
+		this.jobGraphsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(facade, stateStorage);&lt;br/&gt;
 &lt;br/&gt;
 		this.pathCache = new PathChildrenCache(facade, &quot;/&quot;, false);&lt;br/&gt;
 		pathCache.getListenable().addListener(new SubmittedJobGraphsPathCacheListener());&lt;br/&gt;
@@ -276,6 +273,24 @@ public void removeJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
 		LOG.info(&quot;Removed job graph {} from ZooKeeper.&quot;, jobId);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+		checkNotNull(jobId, &quot;Job ID&quot;);&lt;br/&gt;
+		final String path = getPathForJob(jobId);&lt;br/&gt;
+&lt;br/&gt;
+		LOG.debug(&quot;Releasing locks of job graph {} from {}{}.&quot;, jobId, zooKeeperFullBasePath, path);&lt;br/&gt;
+&lt;br/&gt;
+		synchronized (cacheLock) {&lt;br/&gt;
+			if (addedJobGraphs.contains(jobId)) {
+				jobGraphsInZooKeeper.release(path);
+
+				addedJobGraphs.remove(jobId);
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		LOG.info(&quot;Released locks of job graph {} from ZooKeeper.&quot;, jobId);&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
 		Collection&amp;lt;String&amp;gt; paths;&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java&lt;br/&gt;
index 43c930e6fea..cc1ec7044c4 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java&lt;br/&gt;
@@ -54,6 +54,9 @@&lt;br/&gt;
 &lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * Class containing helper functions to interact with ZooKeeper.&lt;br/&gt;
+ */&lt;br/&gt;
 public class ZooKeeperUtils {&lt;br/&gt;
 &lt;br/&gt;
 	private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperUtils.class);&lt;br/&gt;
@@ -227,14 +230,12 @@ public static ZooKeeperLeaderElectionService createLeaderElectionService(&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param client        The {@link CuratorFramework} ZooKeeper client to use&lt;br/&gt;
 	 * @param configuration {@link Configuration} object&lt;br/&gt;
-	 * @param executor to run ZooKeeper callbacks&lt;br/&gt;
 	 * @return {@link ZooKeeperSubmittedJobGraphStore} instance&lt;br/&gt;
 	 * @throws Exception if the submitted job graph store cannot be created&lt;br/&gt;
 	 */&lt;br/&gt;
 	public static ZooKeeperSubmittedJobGraphStore createSubmittedJobGraphs(&lt;br/&gt;
 			CuratorFramework client,&lt;br/&gt;
-			Configuration configuration,&lt;br/&gt;
-			Executor executor) throws Exception {&lt;br/&gt;
+			Configuration configuration) throws Exception {
 
 		checkNotNull(configuration, &quot;Configuration&quot;);
 
@@ -244,7 +245,9 @@ public static ZooKeeperSubmittedJobGraphStore createSubmittedJobGraphs(
 		String zooKeeperSubmittedJobsPath = configuration.getString(HighAvailabilityOptions.HA_ZOOKEEPER_JOBGRAPHS_PATH);
 
 		return new ZooKeeperSubmittedJobGraphStore(
-				client, zooKeeperSubmittedJobsPath, stateStorage, executor);
+			client,
+			zooKeeperSubmittedJobsPath,
+			stateStorage);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -344,6 +347,9 @@ public static String generateZookeeperPath(String root, String namespace) {
 		return root + namespace;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Secure {@link ACLProvider} implementation.&lt;br/&gt;
+	 */&lt;br/&gt;
 	public static class SecureAclProvider implements ACLProvider {&lt;br/&gt;
 		@Override&lt;br/&gt;
 		public List&amp;lt;ACL&amp;gt; getDefaultAcl() {&lt;br/&gt;
@@ -356,6 +362,9 @@ public static String generateZookeeperPath(String root, String namespace) {&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	/**&lt;br/&gt;
+	 * ZooKeeper client ACL mode enum.&lt;br/&gt;
+	 */&lt;br/&gt;
 	public enum ZkClientACLMode {&lt;br/&gt;
 		CREATOR,&lt;br/&gt;
 		OPEN;&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
index 87a433adace..8c3d31fc51b 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
@@ -18,17 +18,13 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.flink.runtime.zookeeper;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
-import org.apache.curator.framework.api.BackgroundCallback;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEvent;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEventType;&lt;br/&gt;
-import org.apache.curator.utils.ZKPaths;&lt;br/&gt;
 import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
 import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
 import org.apache.flink.util.ExceptionUtils;&lt;br/&gt;
-import org.apache.flink.util.FlinkException;&lt;br/&gt;
 import org.apache.flink.util.InstantiationUtil;&lt;br/&gt;
-import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.apache.curator.utils.ZKPaths;&lt;br/&gt;
 import org.apache.zookeeper.CreateMode;&lt;br/&gt;
 import org.apache.zookeeper.KeeperException;&lt;br/&gt;
 import org.apache.zookeeper.data.Stat;&lt;br/&gt;
@@ -36,6 +32,7 @@&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
 &lt;br/&gt;
 import javax.annotation.Nullable;&lt;br/&gt;
+&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.io.Serializable;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
@@ -44,7 +41,6 @@&lt;br/&gt;
 import java.util.ConcurrentModificationException;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.UUID;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
 &lt;br/&gt;
@@ -68,13 +64,13 @@&lt;br/&gt;
  * State handle in ZooKeeper =&amp;gt; State handle exists&lt;br/&gt;
  * &amp;lt;/pre&amp;gt;&lt;br/&gt;
  *&lt;br/&gt;
- * But not:&lt;br/&gt;
+ * &amp;lt;p&amp;gt;But not:&lt;br/&gt;
  *&lt;br/&gt;
  * &amp;lt;pre&amp;gt;&lt;br/&gt;
  * State handle exists =&amp;gt; State handle in ZooKeeper&lt;br/&gt;
  * &amp;lt;/pre&amp;gt;&lt;br/&gt;
  *&lt;br/&gt;
- * There can be lingering state handles when failures happen during operation. They&lt;br/&gt;
+ * &amp;lt;p&amp;gt;There can be lingering state handles when failures happen during operation. They&lt;br/&gt;
  * need to be cleaned up manually (see &amp;lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-2513&quot;&amp;gt;&lt;br/&gt;
  * &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-2513&quot; title=&quot;Extend state handle provider interface to list all state handles&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-2513&quot;&gt;&lt;del&gt;FLINK-2513&lt;/del&gt;&lt;/a&gt;&amp;lt;/a&amp;gt; about a possible way to overcome this).&lt;br/&gt;
  *&lt;br/&gt;
@@ -84,13 +80,11 @@&lt;br/&gt;
 &lt;br/&gt;
 	private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperStateHandleStore.class);&lt;br/&gt;
 &lt;br/&gt;
-	/** Curator ZooKeeper client */&lt;br/&gt;
+	/** Curator ZooKeeper client. */&lt;br/&gt;
 	private final CuratorFramework client;&lt;br/&gt;
 &lt;br/&gt;
 	private final RetrievableStateStorageHelper&amp;lt;T&amp;gt; storage;&lt;br/&gt;
 &lt;br/&gt;
-	private final Executor executor;&lt;br/&gt;
-&lt;br/&gt;
 	/** Lock node name of this ZooKeeperStateHandleStore. The name should be unique among all other state handle stores. */&lt;br/&gt;
 	private final String lockNode;&lt;br/&gt;
 &lt;br/&gt;
@@ -103,16 +97,13 @@&lt;br/&gt;
 	 *                            instance, e.g. &amp;lt;code&amp;gt;client.usingNamespace(&quot;/stateHandles&quot;)&amp;lt;/code&amp;gt;&lt;br/&gt;
 	 * @param storage to persist the actual state and whose returned state handle is then written&lt;br/&gt;
 	 *                to ZooKeeper&lt;br/&gt;
-	 * @param executor to run the ZooKeeper callbacks&lt;br/&gt;
 	 */&lt;br/&gt;
 	public ZooKeeperStateHandleStore(&lt;br/&gt;
 		CuratorFramework client,&lt;br/&gt;
-		RetrievableStateStorageHelper&amp;lt;T&amp;gt; storage,&lt;br/&gt;
-		Executor executor) {&lt;br/&gt;
+		RetrievableStateStorageHelper&amp;lt;T&amp;gt; storage) {&lt;br/&gt;
 &lt;br/&gt;
 		this.client = checkNotNull(client, &quot;Curator client&quot;);&lt;br/&gt;
 		this.storage = checkNotNull(storage, &quot;State storage&quot;);&lt;br/&gt;
-		this.executor = checkNotNull(executor);&lt;br/&gt;
 &lt;br/&gt;
 		// Generate a unique lock node name&lt;br/&gt;
 		lockNode = UUID.randomUUID().toString();&lt;br/&gt;
@@ -262,7 +253,7 @@ public int exists(String pathInZooKeeper) throws Exception {&lt;br/&gt;
 	public Collection&amp;lt;String&amp;gt; getAllPaths() throws Exception {&lt;br/&gt;
 		final String path = &quot;/&quot;;&lt;br/&gt;
 &lt;br/&gt;
-		while(true) {&lt;br/&gt;
+		while (true) {&lt;br/&gt;
 			Stat stat = client.checkExists().forPath(path);&lt;br/&gt;
 &lt;br/&gt;
 			if (stat == null) {&lt;br/&gt;
@@ -393,33 +384,14 @@ public int exists(String pathInZooKeeper) throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
 	 * Releases the lock for the given state node and tries to remove the state node if it is no longer locked.&lt;br/&gt;
-	 * The deletion of the state node is executed asynchronously.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Important&amp;lt;/strong&amp;gt;: This also discards the stored state handle after the given action&lt;br/&gt;
-	 * has been executed.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param pathInZooKeeper Path of state handle to remove (expected to start with a &apos;/&apos;)&lt;br/&gt;
-	 * @throws Exception If the ZooKeeper operation fails&lt;br/&gt;
-	 */&lt;br/&gt;
-	public void releaseAndTryRemove(String pathInZooKeeper) throws Exception {
-		releaseAndTryRemove(pathInZooKeeper, null);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Releases the lock for the given state node and tries to remove the state node if it is no longer locked.&lt;br/&gt;
-	 * The deletion of the state node is executed asynchronously. After the state node has been deleted, the given&lt;br/&gt;
-	 * callback is called with the {@link RetrievableStateHandle} of the deleted state node.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Important&amp;lt;/strong&amp;gt;: This also discards the stored state handle after the given action&lt;br/&gt;
-	 * has been executed.&lt;br/&gt;
+	 * It returns the {@link RetrievableStateHandle} stored under the given state node if any.&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param pathInZooKeeper Path of state handle to remove&lt;br/&gt;
-	 * @param callback The callback to execute after a successful deletion. Null if no action needs to be executed.&lt;br/&gt;
-	 * @throws Exception If the ZooKeeper operation fails&lt;br/&gt;
+	 * @return True if the state handle could be released&lt;br/&gt;
+	 * @throws Exception If the ZooKeeper operation or discarding the state handle fails&lt;br/&gt;
 	 */&lt;br/&gt;
-	public void releaseAndTryRemove(&lt;br/&gt;
-			String pathInZooKeeper,&lt;br/&gt;
-			@Nullable final RemoveCallback&amp;lt;T&amp;gt; callback) throws Exception {&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public boolean releaseAndTryRemove(String pathInZooKeeper) throws Exception {&lt;br/&gt;
 		checkNotNull(pathInZooKeeper, &quot;Path in ZooKeeper&quot;);&lt;br/&gt;
 &lt;br/&gt;
 		final String path = normalizePath(pathInZooKeeper);&lt;br/&gt;
@@ -429,14 +401,23 @@ public void releaseAndTryRemove(&lt;br/&gt;
 		try {
 			stateHandle = get(path, false);
 		} catch (Exception e) {&lt;br/&gt;
-			LOG.warn(&quot;Could not retrieve the state handle from node &quot; + path + &apos;.&apos;, e);&lt;br/&gt;
+			LOG.warn(&quot;Could not retrieve the state handle from node {}.&quot;, path, e);&lt;br/&gt;
 		}&lt;br/&gt;
 &lt;br/&gt;
 		release(pathInZooKeeper);&lt;br/&gt;
 &lt;br/&gt;
-		final BackgroundCallback backgroundCallback = new RemoveBackgroundCallback&amp;lt;&amp;gt;(stateHandle, callback, path);&lt;br/&gt;
+		try {
+			client.delete().forPath(path);
+		} catch (KeeperException.NotEmptyException ignored) {&lt;br/&gt;
+			LOG.debug(&quot;Could not delete znode {} because it is still locked.&quot;, path);&lt;br/&gt;
+			return false;&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		if (stateHandle != null) {
+			stateHandle.discardState();
+		}&lt;br/&gt;
 &lt;br/&gt;
-		client.delete().inBackground(backgroundCallback, executor).forPath(path);&lt;br/&gt;
+		return true;&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -583,7 +564,7 @@ protected String getLockPath(String rootPath) {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
-	 * Makes sure that every path starts with a &quot;/&quot;&lt;br/&gt;
+	 * Makes sure that every path starts with a &quot;/&quot;.&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param path Path to normalize&lt;br/&gt;
 	 * @return Normalized path such that it starts with a &quot;/&quot;&lt;br/&gt;
@@ -595,103 +576,4 @@ private static String normalizePath(String path) {
 			return &apos;/&apos; + path;
 		}&lt;br/&gt;
 	}&lt;br/&gt;
-&lt;br/&gt;
-	// ---------------------------------------------------------------------------------------------------------&lt;br/&gt;
-	// Utility classes&lt;br/&gt;
-	// ---------------------------------------------------------------------------------------------------------&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Callback which is executed when removing a node from ZooKeeper. The callback will call the given&lt;br/&gt;
-	 * {@link RemoveCallback} if it is not null. Afterwards, it will discard the given {@link RetrievableStateHandle}&lt;br/&gt;
-	 * if it is not null.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param &amp;lt;T&amp;gt; Type of the value stored in the RetrievableStateHandle&lt;br/&gt;
-	 */&lt;br/&gt;
-	private static final class RemoveBackgroundCallback&amp;lt;T extends Serializable&amp;gt; implements BackgroundCallback {&lt;br/&gt;
-		@Nullable&lt;br/&gt;
-		private final RetrievableStateHandle&amp;lt;T&amp;gt; stateHandle;&lt;br/&gt;
-&lt;br/&gt;
-		@Nullable&lt;br/&gt;
-		private final RemoveCallback&amp;lt;T&amp;gt; callback;&lt;br/&gt;
-&lt;br/&gt;
-		private final String pathInZooKeeper;&lt;br/&gt;
-&lt;br/&gt;
-		private RemoveBackgroundCallback(&lt;br/&gt;
-			@Nullable RetrievableStateHandle&amp;lt;T&amp;gt; stateHandle,&lt;br/&gt;
-			@Nullable RemoveCallback&amp;lt;T&amp;gt; callback,&lt;br/&gt;
-			String pathInZooKeeper) {
-
-			this.stateHandle = stateHandle;
-			this.callback = callback;
-			this.pathInZooKeeper = Preconditions.checkNotNull(pathInZooKeeper);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {&lt;br/&gt;
-			try {&lt;br/&gt;
-				if (event.getType() == CuratorEventType.DELETE) {&lt;br/&gt;
-					final KeeperException.Code resultCode = KeeperException.Code.get(event.getResultCode());&lt;br/&gt;
-&lt;br/&gt;
-					if (resultCode == KeeperException.Code.OK) {&lt;br/&gt;
-						Exception exception = null;&lt;br/&gt;
-&lt;br/&gt;
-						if (null != callback) {&lt;br/&gt;
-							try {
-								callback.apply(stateHandle);
-							} catch (Throwable e) {
-								exception = new Exception(&quot;Could not execute delete action for node &quot; +
-									pathInZooKeeper + &apos;.&apos;, e);
-							}&lt;br/&gt;
-						}&lt;br/&gt;
-&lt;br/&gt;
-						if (stateHandle != null) {&lt;br/&gt;
-							try {
-								// Discard the state handle
-								stateHandle.discardState();
-							} catch (Throwable e) {&lt;br/&gt;
-								Exception newException = new Exception(&quot;Could not discard state handle of node &quot; +&lt;br/&gt;
-									pathInZooKeeper + &apos;.&apos;, e);&lt;br/&gt;
-&lt;br/&gt;
-								if (exception == null) {
-									exception = newException;
-								} else {
-									exception.addSuppressed(newException);
-								}&lt;br/&gt;
-							}&lt;br/&gt;
-						}&lt;br/&gt;
-&lt;br/&gt;
-						if (exception != null) {
-							throw exception;
-						}&lt;br/&gt;
-					} else if (resultCode == KeeperException.Code.NOTEMPTY) {
-						// Could not delete the node because it still contains children/locks
-						LOG.debug(&quot;Could not delete node &quot; + pathInZooKeeper + &quot; because it is still locked.&quot;);
-					} else {
-						throw new IllegalStateException(&quot;Unexpected result code &quot; +
-							resultCode.name() + &quot; in &apos;&quot; + event + &quot;&apos; callback.&quot;);
-					}&lt;br/&gt;
-				} else {
-					throw new IllegalStateException(&quot;Unexpected event type &quot; +
-						event.getType() + &quot; in &apos;&quot; + event + &quot;&apos; callback.&quot;);
-				}&lt;br/&gt;
-			} catch (Exception e) {
-				LOG.warn(&quot;Failed to run callback for delete operation on node &quot; + pathInZooKeeper + &apos;.&apos;, e);
-			}&lt;br/&gt;
-&lt;br/&gt;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Callback interface for remove calls&lt;br/&gt;
-	 */&lt;br/&gt;
-	public interface RemoveCallback&amp;lt;T extends Serializable&amp;gt; {&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * Callback method. The parameter can be null if the {@link RetrievableStateHandle} could not be retrieved&lt;br/&gt;
-		 * from ZooKeeper.&lt;br/&gt;
-		 *&lt;br/&gt;
-		 * @param value RetrievableStateHandle retrieved from ZooKeeper, null if it was not retrievable&lt;br/&gt;
-		 * @throws FlinkException If the callback failed&lt;br/&gt;
-		 */&lt;br/&gt;
-		void apply(@Nullable RetrievableStateHandle&amp;lt;T&amp;gt; value) throws FlinkException;&lt;br/&gt;
-	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java&lt;br/&gt;
index d3b7dc5b379..3e294e0dbdd 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java&lt;br/&gt;
@@ -18,15 +18,15 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.flink.runtime.zookeeper;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
-import org.apache.curator.framework.recipes.shared.SharedCount;&lt;br/&gt;
-import org.apache.curator.framework.recipes.shared.SharedValue;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
 import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;br/&gt;
 &lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.apache.curator.framework.recipes.shared.SharedCount;&lt;br/&gt;
+import org.apache.curator.framework.recipes.shared.SharedValue;&lt;br/&gt;
+&lt;br/&gt;
 import java.io.Serializable;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * Creates ZooKeeper utility classes without exposing the {@link CuratorFramework} dependency. The&lt;br/&gt;
@@ -71,7 +71,6 @@ public void close(boolean cleanup) throws Exception {&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param zkStateHandleStorePath specifying the path in ZooKeeper to store the state handles to&lt;br/&gt;
 	 * @param stateStorageHelper storing the actual state data&lt;br/&gt;
-	 * @param executor to run asynchronous callbacks of the state handle store&lt;br/&gt;
 	 * @param &amp;lt;T&amp;gt; Type of the state to be stored&lt;br/&gt;
 	 * @return a ZooKeeperStateHandleStore instance&lt;br/&gt;
 	 * @throws Exception if ZooKeeper could not create the provided state handle store path in&lt;br/&gt;
@@ -79,8 +78,7 @@ public void close(boolean cleanup) throws Exception {&lt;br/&gt;
 	 */&lt;br/&gt;
 	public &amp;lt;T extends Serializable&amp;gt; ZooKeeperStateHandleStore&amp;lt;T&amp;gt; createZooKeeperStateHandleStore(&lt;br/&gt;
 			String zkStateHandleStorePath,&lt;br/&gt;
-			RetrievableStateStorageHelper&amp;lt;T&amp;gt; stateStorageHelper,&lt;br/&gt;
-			Executor executor) throws Exception {&lt;br/&gt;
+			RetrievableStateStorageHelper&amp;lt;T&amp;gt; stateStorageHelper) throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 		facade.newNamespaceAwareEnsurePath(zkStateHandleStorePath).ensure(facade.getZookeeperClient());&lt;br/&gt;
 		CuratorFramework stateHandleStoreFacade = facade.usingNamespace(&lt;br/&gt;
@@ -88,7 +86,7 @@ public void close(boolean cleanup) throws Exception {
 				facade.getNamespace(),
 				zkStateHandleStorePath));
 
-		return new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(stateHandleStoreFacade, stateStorageHelper, executor);
+		return new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(stateHandleStoreFacade, stateStorageHelper);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
diff --git a/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala b/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala&lt;br/&gt;
index 0988730689a..6d27dc35cf4 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala&lt;br/&gt;
+++ b/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala&lt;br/&gt;
@@ -1729,21 +1729,22 @@ class JobManager(&lt;br/&gt;
     val futureOption = currentJobs.remove(jobID) match {&lt;br/&gt;
       case Some((eg, _)) =&amp;gt;&lt;br/&gt;
         val cleanUpFuture: Future&lt;span class=&quot;error&quot;&gt;&amp;#91;Unit&amp;#93;&lt;/span&gt; = Future {&lt;br/&gt;
-          val cleanupHABlobs = if (removeJobFromStateBackend) {&lt;br/&gt;
-            try {&lt;br/&gt;
+          val cleanupHABlobs = try {&lt;br/&gt;
+            if (removeJobFromStateBackend) {
               // ...otherwise, we can have lingering resources when there is a  concurrent shutdown
               // and the ZooKeeper client is closed. Not removing the job immediately allow the
               // shutdown to release all resources.
               submittedJobGraphs.removeJobGraph(jobID)
               true
-            } catch {&lt;br/&gt;
-              case t: Throwable =&amp;gt; {
-                log.warn(s&quot;Could not remove submitted job graph $jobID.&quot;, t)
-                false
-              }&lt;br/&gt;
+            } else {
+              submittedJobGraphs.releaseJobGraph(jobID)
+              false
+            }&lt;br/&gt;
+          } catch {&lt;br/&gt;
+            case t: Throwable =&amp;gt; {
+              log.warn(s&quot;Could not remove submitted job graph $jobID.&quot;, t)
+              false
             }&lt;br/&gt;
-          } else {
-            false
           }&lt;br/&gt;
 &lt;br/&gt;
           blobServer.cleanupJob(jobID, cleanupHABlobs)&lt;br/&gt;
@@ -1778,19 +1779,23 @@ class JobManager(&lt;br/&gt;
     */&lt;br/&gt;
   private def cancelAndClearEverything(cause: Throwable)&lt;br/&gt;
     : Seq[Future&lt;span class=&quot;error&quot;&gt;&amp;#91;Unit&amp;#93;&lt;/span&gt;] = {&lt;br/&gt;
-    val futures = for ((jobID, (eg, jobInfo)) &amp;lt;- currentJobs) yield {&lt;br/&gt;
-      future {&lt;br/&gt;
-        eg.suspend(cause)&lt;br/&gt;
-        jobManagerMetricGroup.removeJob(eg.getJobID)&lt;br/&gt;
+&lt;br/&gt;
+    val futures = currentJobs.values.flatMap(&lt;br/&gt;
+      egJobInfo =&amp;gt; {
+        val executionGraph = egJobInfo._1
+        val jobInfo = egJobInfo._2
+
+        executionGraph.suspend(cause)
+
+        val jobId = executionGraph.getJobID
 
         jobInfo.notifyNonDetachedClients(
           decorateMessage(
             Failure(
-              new JobExecutionException(jobID, &quot;All jobs are cancelled and cleared.&quot;, cause))))
-      }(context.dispatcher)&lt;br/&gt;
-    }&lt;br/&gt;
+              new JobExecutionException(jobId, &quot;All jobs are cancelled and cleared.&quot;, cause))))&lt;br/&gt;
 &lt;br/&gt;
-    currentJobs.clear()&lt;br/&gt;
+        removeJob(jobId, false)&lt;br/&gt;
+      })&lt;br/&gt;
 &lt;br/&gt;
     futures.toSeq&lt;br/&gt;
   }&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java&lt;br/&gt;
index 81569649663..c4d89030dc3 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java&lt;br/&gt;
@@ -193,7 +193,7 @@ public void testDiscardAllCheckpoints() throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 	// ---------------------------------------------------------------------------------------------&lt;br/&gt;
 &lt;br/&gt;
-	protected TestCompletedCheckpoint createCheckpoint(&lt;br/&gt;
+	public static TestCompletedCheckpoint createCheckpoint(&lt;br/&gt;
 		int id,&lt;br/&gt;
 		SharedStateRegistry sharedStateRegistry) throws IOException {
 
@@ -226,7 +226,12 @@ protected void verifyCheckpointRegistered(Collection&amp;lt;OperatorState&amp;gt; operatorStat
 		}&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
-	protected void verifyCheckpointDiscarded(Collection&amp;lt;OperatorState&amp;gt; operatorStates) {&lt;br/&gt;
+	public static void verifyCheckpointDiscarded(TestCompletedCheckpoint completedCheckpoint) {
+		assertTrue(completedCheckpoint.isDiscarded());
+		verifyCheckpointDiscarded(completedCheckpoint.getOperatorStates().values());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	protected static void verifyCheckpointDiscarded(Collection&amp;lt;OperatorState&amp;gt; operatorStates) {&lt;br/&gt;
 		for (OperatorState operatorState : operatorStates) {&lt;br/&gt;
 			for (OperatorSubtaskState subtaskState : operatorState.getStates()) {&lt;br/&gt;
 				Assert.assertTrue(((TestOperatorSubtaskState)subtaskState).discarded);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..1f7d3691e50&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java&lt;br/&gt;
@@ -0,0 +1,261 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.checkpoint;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
+import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
+import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.apache.curator.framework.api.BackgroundCallback;&lt;br/&gt;
+import org.apache.curator.framework.api.CuratorEvent;&lt;br/&gt;
+import org.apache.curator.framework.api.CuratorEventType;&lt;br/&gt;
+import org.apache.curator.framework.api.ErrorListenerPathable;&lt;br/&gt;
+import org.apache.curator.utils.EnsurePath;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.runner.RunWith;&lt;br/&gt;
+import org.mockito.Mockito;&lt;br/&gt;
+import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
+import org.mockito.stubbing.Answer;&lt;br/&gt;
+import org.powermock.core.classloader.annotations.PrepareForTest;&lt;br/&gt;
+import org.powermock.modules.junit4.PowerMockRunner;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.ArrayList;&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.Collections;&lt;br/&gt;
+import java.util.HashMap;&lt;br/&gt;
+import java.util.HashSet;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+import java.util.concurrent.Executor;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertEquals;&lt;br/&gt;
+import static org.junit.Assert.assertFalse;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+import static org.mockito.Matchers.any;&lt;br/&gt;
+import static org.mockito.Matchers.anyString;&lt;br/&gt;
+import static org.mockito.Mockito.doReturn;&lt;br/&gt;
+import static org.mockito.Mockito.mock;&lt;br/&gt;
+import static org.mockito.Mockito.never;&lt;br/&gt;
+import static org.mockito.Mockito.spy;&lt;br/&gt;
+import static org.mockito.Mockito.verify;&lt;br/&gt;
+import static org.mockito.Mockito.when;&lt;br/&gt;
+import static org.powermock.api.mockito.PowerMockito.doAnswer;&lt;br/&gt;
+import static org.powermock.api.mockito.PowerMockito.doThrow;&lt;br/&gt;
+import static org.powermock.api.mockito.PowerMockito.whenNew;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Mockito based tests for the {@link ZooKeeperStateHandleStore}.&lt;br/&gt;
+ */&lt;br/&gt;
+@RunWith(PowerMockRunner.class)&lt;br/&gt;
+@PrepareForTest(ZooKeeperCompletedCheckpointStore.class)&lt;br/&gt;
+public class ZooKeeperCompletedCheckpointStoreMockitoTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the completed checkpoint store can retrieve all checkpoints stored in ZooKeeper&lt;br/&gt;
+	 * and ignores those which cannot be retrieved via their state handles.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * &amp;lt;p&amp;gt;We have a timeout in case the ZooKeeper store get&apos;s into a deadlock/livelock situation.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test(timeout = 50000)&lt;br/&gt;
+	public void testCheckpointRecovery() throws Exception {&lt;br/&gt;
+		final JobID jobID = new JobID();&lt;br/&gt;
+		final long checkpoint1Id = 1L;&lt;br/&gt;
+		final long checkpoint2Id = 2;&lt;br/&gt;
+		final List&amp;lt;Tuple2&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;, String&amp;gt;&amp;gt; checkpointsInZooKeeper = new ArrayList&amp;lt;&amp;gt;(4);&lt;br/&gt;
+&lt;br/&gt;
+		final Collection&amp;lt;Long&amp;gt; expectedCheckpointIds = new HashSet&amp;lt;&amp;gt;(2);&lt;br/&gt;
+		expectedCheckpointIds.add(1L);&lt;br/&gt;
+		expectedCheckpointIds.add(2L);&lt;br/&gt;
+&lt;br/&gt;
+		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; failingRetrievableStateHandle = mock(RetrievableStateHandle.class);&lt;br/&gt;
+		when(failingRetrievableStateHandle.retrieveState()).thenThrow(new IOException(&quot;Test exception&quot;));&lt;br/&gt;
+&lt;br/&gt;
+		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle1 = mock(RetrievableStateHandle.class);&lt;br/&gt;
+		when(retrievableStateHandle1.retrieveState()).then(&lt;br/&gt;
+			(invocation) -&amp;gt; new CompletedCheckpoint(&lt;br/&gt;
+				jobID,&lt;br/&gt;
+				checkpoint1Id,&lt;br/&gt;
+				1L,&lt;br/&gt;
+				1L,&lt;br/&gt;
+				new HashMap&amp;lt;&amp;gt;(),&lt;br/&gt;
+				null,&lt;br/&gt;
+				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),&lt;br/&gt;
+				new TestCompletedCheckpointStorageLocation()));&lt;br/&gt;
+&lt;br/&gt;
+		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle2 = mock(RetrievableStateHandle.class);&lt;br/&gt;
+		when(retrievableStateHandle2.retrieveState()).then(&lt;br/&gt;
+			(invocation -&amp;gt; new CompletedCheckpoint(&lt;br/&gt;
+				jobID,&lt;br/&gt;
+				checkpoint2Id,&lt;br/&gt;
+				2L,&lt;br/&gt;
+				2L,&lt;br/&gt;
+				new HashMap&amp;lt;&amp;gt;(),&lt;br/&gt;
+				null,&lt;br/&gt;
+				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),&lt;br/&gt;
+				new TestCompletedCheckpointStorageLocation())));&lt;br/&gt;
+&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle1, &quot;/foobar1&quot;));&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing1&quot;));&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle2, &quot;/foobar2&quot;));&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing2&quot;));&lt;br/&gt;
+&lt;br/&gt;
+		final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zooKeeperStateHandleStoreMock = spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock));&lt;br/&gt;
+		whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zooKeeperStateHandleStoreMock);&lt;br/&gt;
+		doReturn(checkpointsInZooKeeper).when(zooKeeperStateHandleStoreMock).getAllSortedByNameAndLock();&lt;br/&gt;
+&lt;br/&gt;
+		final int numCheckpointsToRetain = 1;&lt;br/&gt;
+&lt;br/&gt;
+		// Mocking for the delete operation on the CuratorFramework client&lt;br/&gt;
+		// It assures that the callback is executed synchronously&lt;br/&gt;
+&lt;br/&gt;
+		final EnsurePath ensurePathMock = mock(EnsurePath.class);&lt;br/&gt;
+		final CuratorEvent curatorEventMock = mock(CuratorEvent.class);&lt;br/&gt;
+		when(curatorEventMock.getType()).thenReturn(CuratorEventType.DELETE);&lt;br/&gt;
+		when(curatorEventMock.getResultCode()).thenReturn(0);&lt;br/&gt;
+		when(client.newNamespaceAwareEnsurePath(anyString())).thenReturn(ensurePathMock);&lt;br/&gt;
+&lt;br/&gt;
+		when(&lt;br/&gt;
+			client&lt;br/&gt;
+				.delete()&lt;br/&gt;
+				.inBackground(any(BackgroundCallback.class), any(Executor.class))&lt;br/&gt;
+		).thenAnswer(new Answer&amp;lt;ErrorListenerPathable&amp;lt;Void&amp;gt;&amp;gt;() {&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public ErrorListenerPathable&amp;lt;Void&amp;gt; answer(InvocationOnMock invocation) throws Throwable {&lt;br/&gt;
+				final BackgroundCallback callback = (BackgroundCallback) invocation.getArguments()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+&lt;br/&gt;
+				ErrorListenerPathable&amp;lt;Void&amp;gt; result = mock(ErrorListenerPathable.class);&lt;br/&gt;
+&lt;br/&gt;
+				when(result.forPath(anyString())).thenAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
+					@Override&lt;br/&gt;
+					public Void answer(InvocationOnMock invocation) throws Throwable {
+
+						callback.processResult(client, curatorEventMock);
+
+						return null;
+					}&lt;br/&gt;
+				});&lt;br/&gt;
+&lt;br/&gt;
+				return result;&lt;br/&gt;
+			}&lt;br/&gt;
+		});&lt;br/&gt;
+&lt;br/&gt;
+		final String checkpointsPath = &quot;foobar&quot;;&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateStorage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
+			numCheckpointsToRetain,&lt;br/&gt;
+			client,&lt;br/&gt;
+			checkpointsPath,&lt;br/&gt;
+			stateStorage,&lt;br/&gt;
+			Executors.directExecutor());&lt;br/&gt;
+&lt;br/&gt;
+		zooKeeperCompletedCheckpointStore.recover();&lt;br/&gt;
+&lt;br/&gt;
+		CompletedCheckpoint latestCompletedCheckpoint = zooKeeperCompletedCheckpointStore.getLatestCheckpoint();&lt;br/&gt;
+&lt;br/&gt;
+		// check that we return the latest retrievable checkpoint&lt;br/&gt;
+		// this should remove the latest checkpoint because it is broken&lt;br/&gt;
+		assertEquals(checkpoint2Id, latestCompletedCheckpoint.getCheckpointID());&lt;br/&gt;
+&lt;br/&gt;
+		// this should remove the second broken checkpoint because we&apos;re iterating over all checkpoints&lt;br/&gt;
+		List&amp;lt;CompletedCheckpoint&amp;gt; completedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();&lt;br/&gt;
+&lt;br/&gt;
+		Collection&amp;lt;Long&amp;gt; actualCheckpointIds = new HashSet&amp;lt;&amp;gt;(completedCheckpoints.size());&lt;br/&gt;
+&lt;br/&gt;
+		for (CompletedCheckpoint completedCheckpoint : completedCheckpoints) {
+			actualCheckpointIds.add(completedCheckpoint.getCheckpointID());
+		}&lt;br/&gt;
+&lt;br/&gt;
+		assertEquals(expectedCheckpointIds, actualCheckpointIds);&lt;br/&gt;
+&lt;br/&gt;
+		// check that we did not discard any of the state handles&lt;br/&gt;
+		verify(retrievableStateHandle1, never()).discardState();&lt;br/&gt;
+		verify(retrievableStateHandle2, never()).discardState();&lt;br/&gt;
+&lt;br/&gt;
+		// Make sure that we also didn&apos;t discard any of the broken handles. Only when checkpoints&lt;br/&gt;
+		// are subsumed should they be discarded.&lt;br/&gt;
+		verify(failingRetrievableStateHandle, never()).discardState();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the checkpoint does not exist in the store when we fail to add&lt;br/&gt;
+	 * it into the store (i.e., there exists an exception thrown by the method).&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testAddCheckpointWithFailedRemove() throws Exception {&lt;br/&gt;
+		final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zookeeperStateHandleStoreMock =&lt;br/&gt;
+			spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock));&lt;br/&gt;
+		whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zookeeperStateHandleStoreMock);&lt;br/&gt;
+&lt;br/&gt;
+		doAnswer(new Answer&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;&amp;gt;() {&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; answer(InvocationOnMock invocationOnMock) throws Throwable {
+				CompletedCheckpoint checkpoint = (CompletedCheckpoint) invocationOnMock.getArguments()[1];
+
+				RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle = mock(RetrievableStateHandle.class);
+				when(retrievableStateHandle.retrieveState()).thenReturn(checkpoint);
+
+				return retrievableStateHandle;
+			}&lt;br/&gt;
+		}).when(zookeeperStateHandleStoreMock).addAndLock(anyString(), any(CompletedCheckpoint.class));&lt;br/&gt;
+&lt;br/&gt;
+		doThrow(new Exception()).when(zookeeperStateHandleStoreMock).releaseAndTryRemove(anyString());&lt;br/&gt;
+&lt;br/&gt;
+		final int numCheckpointsToRetain = 1;&lt;br/&gt;
+		final String checkpointsPath = &quot;foobar&quot;;&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateSotrage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
+			numCheckpointsToRetain,&lt;br/&gt;
+			client,&lt;br/&gt;
+			checkpointsPath,&lt;br/&gt;
+			stateSotrage,&lt;br/&gt;
+			Executors.directExecutor());&lt;br/&gt;
+&lt;br/&gt;
+		for (long i = 0; i &amp;lt;= numCheckpointsToRetain; ++i) {&lt;br/&gt;
+			CompletedCheckpoint checkpointToAdd = mock(CompletedCheckpoint.class);&lt;br/&gt;
+			doReturn&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.when(checkpointToAdd).getCheckpointID();&lt;br/&gt;
+			doReturn(Collections.emptyMap()).when(checkpointToAdd).getOperatorStates();&lt;br/&gt;
+&lt;br/&gt;
+			try {
+				zooKeeperCompletedCheckpointStore.addCheckpoint(checkpointToAdd);
+
+				// The checkpoint should be in the store if we successfully add it into the store.
+				List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();
+				assertTrue(addedCheckpoints.contains(checkpointToAdd));
+			} catch (Exception e) {
+				// The checkpoint should not be in the store if any exception is thrown.
+				List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();
+				assertFalse(addedCheckpoints.contains(checkpointToAdd));
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java&lt;br/&gt;
index 0384733fdb1..f992d3b00c0 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java&lt;br/&gt;
@@ -18,60 +18,39 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.flink.runtime.checkpoint;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.flink.api.common.JobID;&lt;br/&gt;
-import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.configuration.Configuration;&lt;br/&gt;
+import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobStatus;&lt;br/&gt;
 import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
-import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;&lt;br/&gt;
+import org.apache.flink.runtime.state.SharedStateRegistry;&lt;br/&gt;
+import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;&lt;br/&gt;
-import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
 &lt;br/&gt;
 import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
-import org.apache.curator.framework.api.BackgroundCallback;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEvent;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEventType;&lt;br/&gt;
-import org.apache.curator.framework.api.ErrorListenerPathable;&lt;br/&gt;
-import org.apache.curator.utils.EnsurePath;&lt;br/&gt;
+import org.hamcrest.Matchers;&lt;br/&gt;
+import org.junit.ClassRule;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
-import org.junit.runner.RunWith;&lt;br/&gt;
-import org.mockito.Mockito;&lt;br/&gt;
-import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
-import org.mockito.stubbing.Answer;&lt;br/&gt;
-import org.powermock.core.classloader.annotations.PrepareForTest;&lt;br/&gt;
-import org.powermock.modules.junit4.PowerMockRunner;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
 &lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
-import java.util.ArrayList;&lt;br/&gt;
-import java.util.Collection;&lt;br/&gt;
-import java.util.Collections;&lt;br/&gt;
-import java.util.HashMap;&lt;br/&gt;
-import java.util.HashSet;&lt;br/&gt;
+import java.io.Serializable;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 import static org.junit.Assert.assertEquals;&lt;br/&gt;
-import static org.junit.Assert.assertFalse;&lt;br/&gt;
-import static org.junit.Assert.assertTrue;&lt;br/&gt;
-import static org.mockito.Matchers.any;&lt;br/&gt;
-import static org.mockito.Matchers.anyString;&lt;br/&gt;
-import static org.mockito.Mockito.doReturn;&lt;br/&gt;
-import static org.mockito.Mockito.mock;&lt;br/&gt;
-import static org.mockito.Mockito.never;&lt;br/&gt;
-import static org.mockito.Mockito.spy;&lt;br/&gt;
-import static org.mockito.Mockito.verify;&lt;br/&gt;
-import static org.mockito.Mockito.when;&lt;br/&gt;
-import static org.powermock.api.mockito.PowerMockito.doAnswer;&lt;br/&gt;
-import static org.powermock.api.mockito.PowerMockito.doThrow;&lt;br/&gt;
-import static org.powermock.api.mockito.PowerMockito.whenNew;&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * Tests for {@link ZooKeeperCompletedCheckpointStore}
&lt;p&gt;.&lt;br/&gt;
  */&lt;br/&gt;
-@RunWith(PowerMockRunner.class)&lt;br/&gt;
-@PrepareForTest(ZooKeeperCompletedCheckpointStore.class)&lt;br/&gt;
 public class ZooKeeperCompletedCheckpointStoreTest extends TestLogger {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	@ClassRule&lt;br/&gt;
+	public static ZooKeeperResource zooKeeperResource = new ZooKeeperResource();&lt;br/&gt;
+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testPathConversion() {&lt;br/&gt;
 		final long checkpointId = 42L;&lt;br/&gt;
@@ -82,188 +61,103 @@ public void testPathConversion() {&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Tests that the completed checkpoint store can retrieve all checkpoints stored in ZooKeeper&lt;/li&gt;
	&lt;li&gt;* and ignores those which cannot be retrieved via their state handles.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;We have a timeout in case the ZooKeeper store get&apos;s into a deadlock/livelock situation.&lt;br/&gt;
+	 * Tests that subsumed checkpoints are discarded.&lt;br/&gt;
 	 */&lt;/li&gt;
	&lt;li&gt;@Test(timeout = 50000)&lt;/li&gt;
	&lt;li&gt;public void testCheckpointRecovery() throws Exception {&lt;/li&gt;
	&lt;li&gt;final JobID jobID = new JobID();&lt;/li&gt;
	&lt;li&gt;final long checkpoint1Id = 1L;&lt;/li&gt;
	&lt;li&gt;final long checkpoint2Id = 2;&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;Tuple2&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;, String&amp;gt;&amp;gt; checkpointsInZooKeeper = new ArrayList&amp;lt;&amp;gt;(4);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final Collection&amp;lt;Long&amp;gt; expectedCheckpointIds = new HashSet&amp;lt;&amp;gt;(2);&lt;/li&gt;
	&lt;li&gt;expectedCheckpointIds.add(1L);&lt;/li&gt;
	&lt;li&gt;expectedCheckpointIds.add(2L);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; failingRetrievableStateHandle = mock(RetrievableStateHandle.class);&lt;/li&gt;
	&lt;li&gt;when(failingRetrievableStateHandle.retrieveState()).thenThrow(new IOException(&quot;Test exception&quot;));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle1 = mock(RetrievableStateHandle.class);&lt;/li&gt;
	&lt;li&gt;when(retrievableStateHandle1.retrieveState()).then(&lt;/li&gt;
	&lt;li&gt;(invocation) -&amp;gt; new CompletedCheckpoint(&lt;/li&gt;
	&lt;li&gt;jobID,&lt;/li&gt;
	&lt;li&gt;checkpoint1Id,&lt;/li&gt;
	&lt;li&gt;1L,&lt;/li&gt;
	&lt;li&gt;1L,&lt;/li&gt;
	&lt;li&gt;new HashMap&amp;lt;&amp;gt;(),&lt;/li&gt;
	&lt;li&gt;null,&lt;/li&gt;
	&lt;li&gt;CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),&lt;/li&gt;
	&lt;li&gt;new TestCompletedCheckpointStorageLocation()));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle2 = mock(RetrievableStateHandle.class);&lt;/li&gt;
	&lt;li&gt;when(retrievableStateHandle2.retrieveState()).then(&lt;/li&gt;
	&lt;li&gt;(invocation -&amp;gt; new CompletedCheckpoint(&lt;/li&gt;
	&lt;li&gt;jobID,&lt;/li&gt;
	&lt;li&gt;checkpoint2Id,&lt;/li&gt;
	&lt;li&gt;2L,&lt;/li&gt;
	&lt;li&gt;2L,&lt;/li&gt;
	&lt;li&gt;new HashMap&amp;lt;&amp;gt;(),&lt;/li&gt;
	&lt;li&gt;null,&lt;/li&gt;
	&lt;li&gt;CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),&lt;/li&gt;
	&lt;li&gt;new TestCompletedCheckpointStorageLocation())));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle1, &quot;/foobar1&quot;));&lt;/li&gt;
	&lt;li&gt;checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing1&quot;));&lt;/li&gt;
	&lt;li&gt;checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle2, &quot;/foobar2&quot;));&lt;/li&gt;
	&lt;li&gt;checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing2&quot;));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;/li&gt;
	&lt;li&gt;final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zooKeeperStateHandleStoreMock = spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock, Executors.directExecutor()));&lt;/li&gt;
	&lt;li&gt;whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zooKeeperStateHandleStoreMock);&lt;/li&gt;
	&lt;li&gt;doReturn(checkpointsInZooKeeper).when(zooKeeperStateHandleStoreMock).getAllSortedByNameAndLock();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final int numCheckpointsToRetain = 1;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Mocking for the delete operation on the CuratorFramework client&lt;/li&gt;
	&lt;li&gt;// It assures that the callback is executed synchronously&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final EnsurePath ensurePathMock = mock(EnsurePath.class);&lt;/li&gt;
	&lt;li&gt;final CuratorEvent curatorEventMock = mock(CuratorEvent.class);&lt;/li&gt;
	&lt;li&gt;when(curatorEventMock.getType()).thenReturn(CuratorEventType.DELETE);&lt;/li&gt;
	&lt;li&gt;when(curatorEventMock.getResultCode()).thenReturn(0);&lt;/li&gt;
	&lt;li&gt;when(client.newNamespaceAwareEnsurePath(anyString())).thenReturn(ensurePathMock);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;when(&lt;/li&gt;
	&lt;li&gt;client&lt;/li&gt;
	&lt;li&gt;.delete()&lt;/li&gt;
	&lt;li&gt;.inBackground(any(BackgroundCallback.class), any(Executor.class))&lt;/li&gt;
	&lt;li&gt;).thenAnswer(new Answer&amp;lt;ErrorListenerPathable&amp;lt;Void&amp;gt;&amp;gt;() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public ErrorListenerPathable&amp;lt;Void&amp;gt; answer(InvocationOnMock invocation) throws Throwable {&lt;/li&gt;
	&lt;li&gt;final BackgroundCallback callback = (BackgroundCallback) invocation.getArguments()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testDiscardingSubsumedCheckpoints() throws Exception 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		final SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();+		final Configuration configuration = new Configuration();+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString());++		final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);+		final ZooKeeperCompletedCheckpointStore checkpointStore = createZooKeeperCheckpointStore(client);++		try {
+			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint1 = CompletedCheckpointStoreTest.createCheckpoint(0, sharedStateRegistry);
+
+			checkpointStore.addCheckpoint(checkpoint1);
+			assertThat(checkpointStore.getAllCheckpoints(), Matchers.contains(checkpoint1));
+
+			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint2 = CompletedCheckpointStoreTest.createCheckpoint(1, sharedStateRegistry);
+			checkpointStore.addCheckpoint(checkpoint2);
+			final List&amp;lt;CompletedCheckpoint&amp;gt; allCheckpoints = checkpointStore.getAllCheckpoints();
+			assertThat(allCheckpoints, Matchers.contains(checkpoint2));
+			assertThat(allCheckpoints, Matchers.not(Matchers.contains(checkpoint1)));
+
+			// verify that the subsumed checkpoint is discarded
+			CompletedCheckpointStoreTest.verifyCheckpointDiscarded(checkpoint1);
+		} finally {
+			client.close();
+		}&lt;br/&gt;
+	}&lt;br/&gt;
 &lt;br/&gt;
-				ErrorListenerPathable&amp;lt;Void&amp;gt; result = mock(ErrorListenerPathable.class);&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that checkpoints are discarded when the completed checkpoint store is shut&lt;br/&gt;
+	 * down with a globally terminal state.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testDiscardingCheckpointsAtShutDown() throws Exception {&lt;br/&gt;
+		final SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString());&lt;br/&gt;
 &lt;br/&gt;
-				when(result.forPath(anyString())).thenAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
-					@Override&lt;br/&gt;
-					public Void answer(InvocationOnMock invocation) throws Throwable {&lt;br/&gt;
+		final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+		final ZooKeeperCompletedCheckpointStore checkpointStore = createZooKeeperCheckpointStore(client);&lt;br/&gt;
 &lt;br/&gt;
-						callback.processResult(client, curatorEventMock);&lt;br/&gt;
+		try {
+			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint1 = CompletedCheckpointStoreTest.createCheckpoint(0, sharedStateRegistry);
 
-						return null;
-					}&lt;br/&gt;
-				});&lt;br/&gt;
+			checkpointStore.addCheckpoint(checkpoint1);&lt;br/&gt;
+			assertThat(checkpointStore.getAllCheckpoints(), Matchers.contains(checkpoint1));&lt;br/&gt;
 &lt;br/&gt;
-				return result;&lt;br/&gt;
-			}&lt;br/&gt;
-		});&lt;br/&gt;
+			checkpointStore.shutdown(JobStatus.FINISHED);&lt;br/&gt;
 &lt;br/&gt;
-		final String checkpointsPath = &quot;foobar&quot;;&lt;br/&gt;
-		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateStorage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+			// verify that the checkpoint is discarded&lt;br/&gt;
+			CompletedCheckpointStoreTest.verifyCheckpointDiscarded(checkpoint1);&lt;br/&gt;
+		} finally {+			client.close();+		}+	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;/li&gt;
	&lt;li&gt;numCheckpointsToRetain,&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private ZooKeeperCompletedCheckpointStore createZooKeeperCheckpointStore(CuratorFramework client) throws Exception 
{
+		return new ZooKeeperCompletedCheckpointStore(
+			1,
 			client,
-			checkpointsPath,
-			stateStorage,
+			&quot;/checkpoints&quot;,
+			new TestingRetrievableStateStorageHelper&amp;lt;&amp;gt;(),
 			Executors.directExecutor());
+	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;zooKeeperCompletedCheckpointStore.recover();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;CompletedCheckpoint latestCompletedCheckpoint = zooKeeperCompletedCheckpointStore.getLatestCheckpoint();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// check that we return the latest retrievable checkpoint&lt;/li&gt;
	&lt;li&gt;// this should remove the latest checkpoint because it is broken&lt;/li&gt;
	&lt;li&gt;assertEquals(checkpoint2Id, latestCompletedCheckpoint.getCheckpointID());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// this should remove the second broken checkpoint because we&apos;re iterating over all checkpoints&lt;/li&gt;
	&lt;li&gt;List&amp;lt;CompletedCheckpoint&amp;gt; completedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;Collection&amp;lt;Long&amp;gt; actualCheckpointIds = new HashSet&amp;lt;&amp;gt;(completedCheckpoints.size());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;for (CompletedCheckpoint completedCheckpoint : completedCheckpoints) {&lt;/li&gt;
	&lt;li&gt;actualCheckpointIds.add(completedCheckpoint.getCheckpointID());&lt;br/&gt;
+	private static final class TestingRetrievableStateStorageHelper&amp;lt;T extends Serializable&amp;gt; implements RetrievableStateStorageHelper&amp;lt;T&amp;gt; {&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public RetrievableStateHandle&amp;lt;T&amp;gt; store(T state) 
{
+			return new TestingRetrievableStateHandle&amp;lt;&amp;gt;(state);
 		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertEquals(expectedCheckpointIds, actualCheckpointIds);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// check that we did not discard any of the state handles&lt;/li&gt;
	&lt;li&gt;verify(retrievableStateHandle1, never()).discardState();&lt;/li&gt;
	&lt;li&gt;verify(retrievableStateHandle2, never()).discardState();&lt;br/&gt;
+		private static class TestingRetrievableStateHandle&amp;lt;T extends Serializable&amp;gt; implements RetrievableStateHandle&amp;lt;T&amp;gt; 
{
 
-		// Make sure that we also didn&apos;t discard any of the broken handles. Only when checkpoints
-		// are subsumed should they be discarded.
-		verify(failingRetrievableStateHandle, never()).discardState();
-	}
&lt;p&gt;+			private static final long serialVersionUID = 137053380713794300L;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Tests that the checkpoint does not exist in the store when we fail to add&lt;/li&gt;
	&lt;li&gt;* it into the store (i.e., there exists an exception thrown by the method).&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testAddCheckpointWithFailedRemove() throws Exception {&lt;/li&gt;
	&lt;li&gt;final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;/li&gt;
	&lt;li&gt;final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+			private final T state;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zookeeperStateHandleStoreMock =&lt;/li&gt;
	&lt;li&gt;spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock, Executors.directExecutor()));&lt;/li&gt;
	&lt;li&gt;whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zookeeperStateHandleStoreMock);&lt;br/&gt;
+			private TestingRetrievableStateHandle(T state) 
{
+				this.state = state;
+			}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;doAnswer(new Answer&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;&amp;gt;() {&lt;br/&gt;
 			@Override&lt;/li&gt;
	&lt;li&gt;public RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; answer(InvocationOnMock invocationOnMock) throws Throwable {&lt;/li&gt;
	&lt;li&gt;CompletedCheckpoint checkpoint = (CompletedCheckpoint) invocationOnMock.getArguments()&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle = mock(RetrievableStateHandle.class);&lt;/li&gt;
	&lt;li&gt;when(retrievableStateHandle.retrieveState()).thenReturn(checkpoint);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;return retrievableStateHandle;&lt;br/&gt;
+			public T retrieveState() throws IOException, ClassNotFoundException 
{
+				return state;
 			}&lt;/li&gt;
	&lt;li&gt;}).when(zookeeperStateHandleStoreMock).addAndLock(anyString(), any(CompletedCheckpoint.class));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;doThrow(new Exception()).when(zookeeperStateHandleStoreMock).releaseAndTryRemove(anyString(), any(ZooKeeperStateHandleStore.RemoveCallback.class));&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final int numCheckpointsToRetain = 1;&lt;/li&gt;
	&lt;li&gt;final String checkpointsPath = &quot;foobar&quot;;&lt;/li&gt;
	&lt;li&gt;final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateSotrage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;/li&gt;
	&lt;li&gt;numCheckpointsToRetain,&lt;/li&gt;
	&lt;li&gt;client,&lt;/li&gt;
	&lt;li&gt;checkpointsPath,&lt;/li&gt;
	&lt;li&gt;stateSotrage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public void discardState() throws Exception 
{
+				// no op
+			}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for (long i = 0; i &amp;lt;= numCheckpointsToRetain; ++i) {&lt;/li&gt;
	&lt;li&gt;CompletedCheckpoint checkpointToAdd = mock(CompletedCheckpoint.class);&lt;/li&gt;
	&lt;li&gt;doReturn&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.when(checkpointToAdd).getCheckpointID();&lt;/li&gt;
	&lt;li&gt;doReturn(Collections.emptyMap()).when(checkpointToAdd).getOperatorStates();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;try 
{
-				zooKeeperCompletedCheckpointStore.addCheckpoint(checkpointToAdd);
-
-				// The checkpoint should be in the store if we successfully add it into the store.
-				List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();
-				assertTrue(addedCheckpoints.contains(checkpointToAdd));
-			}
&lt;p&gt; catch (Exception e) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// The checkpoint should not be in the store if any exception is thrown.&lt;/li&gt;
	&lt;li&gt;List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();&lt;/li&gt;
	&lt;li&gt;assertFalse(addedCheckpoints.contains(checkpointToAdd));&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public long getStateSize() 
{
+				return 0;
 			}
&lt;p&gt; 		}&lt;br/&gt;
 	}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java&lt;br/&gt;
index 2c030d24c49..cb26f4862b1 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java&lt;br/&gt;
@@ -30,9 +30,11 @@&lt;br/&gt;
 import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobVertex;&lt;br/&gt;
+import org.apache.flink.runtime.jobmanager.StandaloneSubmittedJobGraphStore;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.SubmittedJobGraph;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore;&lt;br/&gt;
 import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;&lt;br/&gt;
+import org.apache.flink.runtime.messages.Acknowledge;&lt;br/&gt;
 import org.apache.flink.runtime.metrics.groups.JobManagerMetricGroup;&lt;br/&gt;
 import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;&lt;br/&gt;
 import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;&lt;br/&gt;
@@ -41,6 +43,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.rpc.RpcService;&lt;br/&gt;
 import org.apache.flink.runtime.rpc.RpcUtils;&lt;br/&gt;
 import org.apache.flink.runtime.rpc.TestingRpcService;&lt;br/&gt;
+import org.apache.flink.runtime.testtasks.NoOpInvokable;&lt;br/&gt;
 import org.apache.flink.runtime.util.TestingFatalErrorHandler;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
@@ -110,8 +113,6 @@ public static void teardownClass() throws ExecutionException, InterruptedExcepti&lt;br/&gt;
 	 */&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testGrantingRevokingLeadership() throws Exception {&lt;br/&gt;
-&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;final Configuration configuration = new Configuration();&lt;br/&gt;
 		final TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices();&lt;br/&gt;
 		final JobGraph nonEmptyJobGraph = createNonEmptyJobGraph();&lt;br/&gt;
 		final SubmittedJobGraph submittedJobGraph = new SubmittedJobGraph(nonEmptyJobGraph, null);&lt;br/&gt;
@@ -124,7 +125,34 @@ public void testGrantingRevokingLeadership() throws Exception {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final BlockingQueue&amp;lt;DispatcherId&amp;gt; fencingTokens = new ArrayBlockingQueue&amp;lt;&amp;gt;(2);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final HATestingDispatcher dispatcher = new HATestingDispatcher(&lt;br/&gt;
+		final HATestingDispatcher dispatcher = createHADispatcher(highAvailabilityServices, fencingTokens);&lt;br/&gt;
+&lt;br/&gt;
+		dispatcher.start();&lt;br/&gt;
+&lt;br/&gt;
+		try 
{
+			final UUID leaderId = UUID.randomUUID();
+			dispatcherLeaderElectionService.isLeader(leaderId);
+
+			dispatcherLeaderElectionService.notLeader();
+
+			final DispatcherId firstFencingToken = fencingTokens.take();
+
+			assertThat(firstFencingToken, equalTo(NULL_FENCING_TOKEN));
+
+			enterGetJobIdsLatch.await();
+			proceedGetJobIdsLatch.trigger();
+
+			assertThat(dispatcher.getNumberJobs(timeout).get(), is(0));
+
+		}
&lt;p&gt; finally &lt;/p&gt;
{
+			RpcUtils.terminateRpcEndpoint(dispatcher, timeout);
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private HATestingDispatcher createHADispatcher(TestingHighAvailabilityServices highAvailabilityServices, BlockingQueue&amp;lt;DispatcherId&amp;gt; fencingTokens) throws Exception {&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		return new HATestingDispatcher(&lt;br/&gt;
 			rpcService,&lt;br/&gt;
 			UUID.randomUUID().toString(),&lt;br/&gt;
 			configuration,&lt;br/&gt;
@@ -138,33 +166,63 @@ public void testGrantingRevokingLeadership() throws Exception &lt;/p&gt;
{
 			new TestingJobManagerRunnerFactory(new CompletableFuture&amp;lt;&amp;gt;(), new CompletableFuture&amp;lt;&amp;gt;()),
 			testingFatalErrorHandler,
 			fencingTokens);
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that all JobManagerRunner are terminated if the leadership of the&lt;br/&gt;
+	 * Dispatcher is revoked.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testRevokeLeadershipTerminatesJobManagerRunners() throws Exception {&lt;br/&gt;
+&lt;br/&gt;
+		final TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices();&lt;br/&gt;
+		highAvailabilityServices.setSubmittedJobGraphStore(new StandaloneSubmittedJobGraphStore());&lt;br/&gt;
+&lt;br/&gt;
+		final TestingLeaderElectionService leaderElectionService = new TestingLeaderElectionService();&lt;br/&gt;
+		highAvailabilityServices.setDispatcherLeaderElectionService(leaderElectionService);&lt;br/&gt;
+&lt;br/&gt;
+		final ArrayBlockingQueue&amp;lt;DispatcherId&amp;gt; fencingTokens = new ArrayBlockingQueue&amp;lt;&amp;gt;(2);&lt;br/&gt;
+		final HATestingDispatcher dispatcher = createHADispatcher(&lt;br/&gt;
+			highAvailabilityServices,&lt;br/&gt;
+			fencingTokens);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		dispatcher.start();&lt;/p&gt;

&lt;p&gt; 		try &lt;/p&gt;
{
-			final UUID leaderId = UUID.randomUUID();
-			dispatcherLeaderElectionService.isLeader(leaderId);
+			// grant leadership and submit a single job
+			final DispatcherId expectedDispatcherId = DispatcherId.generate();
 
-			dispatcherLeaderElectionService.notLeader();
+			leaderElectionService.isLeader(expectedDispatcherId.toUUID()).get();
 
-			final DispatcherId firstFencingToken = fencingTokens.take();
+			assertThat(fencingTokens.take(), is(equalTo(expectedDispatcherId)));
 
-			assertThat(firstFencingToken, equalTo(NULL_FENCING_TOKEN));
+			final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 
-			enterGetJobIdsLatch.await();
-			proceedGetJobIdsLatch.trigger();
+			final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = dispatcherGateway.submitJob(createNonEmptyJobGraph(), timeout);
 
-			assertThat(dispatcher.getNumberJobs(timeout).get(), is(0));
+			submissionFuture.get();
+
+			assertThat(dispatcher.getNumberJobs(timeout).get(), is(1));
+
+			// revoke the leadership --&amp;gt; this should stop all running JobManagerRunners
+			leaderElectionService.notLeader();
+
+			assertThat(fencingTokens.take(), is(equalTo(NULL_FENCING_TOKEN)));
 
+			assertThat(dispatcher.getNumberJobs(timeout).get(), is(0));
 		}
&lt;p&gt; finally &lt;/p&gt;
{
 			RpcUtils.terminateRpcEndpoint(dispatcher, timeout);
 		}
&lt;p&gt; 	}&lt;/p&gt;

&lt;p&gt; 	@Nonnull&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private JobGraph createNonEmptyJobGraph() {&lt;br/&gt;
+	public static JobGraph createNonEmptyJobGraph() 
{
 		final JobVertex noOpVertex = new JobVertex(&quot;NoOp vertex&quot;);
-		return new JobGraph(noOpVertex);
+		noOpVertex.setInvokableClass(NoOpInvokable.class);
+		final JobGraph jobGraph = new JobGraph(noOpVertex);
+		jobGraph.setAllowQueuedScheduling(true);
+
+		return jobGraph;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	private static class HATestingDispatcher extends TestingDispatcher {&lt;br/&gt;
@@ -243,6 +301,11 @@ public void removeJobGraph(JobID jobId) throws Exception &lt;/p&gt;
{
 			throw new UnsupportedOperationException(&quot;Should not be called.&quot;);
 		}

&lt;p&gt;+		@Override&lt;br/&gt;
+		public void releaseJobGraph(JobID jobId) throws Exception &lt;/p&gt;
{
+			throw new UnsupportedOperationException(&quot;Should not be called.&quot;);
+		}
&lt;p&gt;+&lt;br/&gt;
 		@Override&lt;br/&gt;
 		public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
 			enterGetJobIdsLatch.trigger();&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/NoOpSubmittedJobGraphListener.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/NoOpSubmittedJobGraphListener.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..493534dd93c&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/NoOpSubmittedJobGraphListener.java&lt;br/&gt;
@@ -0,0 +1,40 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.dispatcher;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * No operation &lt;/p&gt;
{@link org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore.SubmittedJobGraphListener}
&lt;p&gt;+ * implemetation for testing purposes.&lt;br/&gt;
+ */&lt;br/&gt;
+public enum NoOpSubmittedJobGraphListener implements SubmittedJobGraphStore.SubmittedJobGraphListener {&lt;br/&gt;
+	INSTANCE;&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void onAddedJobGraph(JobID jobId) &lt;/p&gt;
{
+		// No op
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void onRemovedJobGraph(JobID jobId) {+		// No op+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
index f5091ea5b10..5141be039f7 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
@@ -19,6 +19,8 @@&lt;br/&gt;
 package org.apache.flink.runtime.dispatcher;&lt;/p&gt;

&lt;p&gt; import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.api.common.time.Time;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
 import org.apache.flink.runtime.blob.BlobServer;&lt;br/&gt;
 import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;&lt;br/&gt;
@@ -29,8 +31,12 @@&lt;br/&gt;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;&lt;br/&gt;
 import org.apache.flink.runtime.rpc.RpcService;&lt;/p&gt;

&lt;p&gt;+import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt;+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.function.Function;&lt;br/&gt;
+&lt;br/&gt;
 /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;{@link Dispatcher} implementation used for testing purposes.&lt;br/&gt;
  */&lt;br/&gt;
@@ -72,4 +78,11 @@ void completeJobExecution(ArchivedExecutionGraph archivedExecutionGraph) {
 		runAsync(
 			() -&amp;gt; jobReachedGloballyTerminalState(archivedExecutionGraph));
 	}&lt;br/&gt;
+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(@Nonnull JobID jobId, @Nonnull Time timeout) {
+		return callAsyncWithoutFencing(
+			() -&amp;gt; getJobTerminationFuture(jobId),
+			timeout).thenCompose(Function.identity());
+	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..dd0375886a9&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java&lt;br/&gt;
@@ -0,0 +1,203 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.dispatcher;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.api.common.time.Time;&lt;br/&gt;
+import org.apache.flink.configuration.Configuration;&lt;br/&gt;
+import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
+import org.apache.flink.runtime.blob.BlobServer;&lt;br/&gt;
+import org.apache.flink.runtime.blob.VoidBlobStore;&lt;br/&gt;
+import org.apache.flink.runtime.heartbeat.HeartbeatServices;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
+import org.apache.flink.runtime.jobmanager.SubmittedJobGraph;&lt;br/&gt;
+import org.apache.flink.runtime.jobmanager.ZooKeeperSubmittedJobGraphStore;&lt;br/&gt;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;&lt;br/&gt;
+import org.apache.flink.runtime.messages.Acknowledge;&lt;br/&gt;
+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;&lt;br/&gt;
+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;&lt;br/&gt;
+import org.apache.flink.runtime.rpc.RpcUtils;&lt;br/&gt;
+import org.apache.flink.runtime.rpc.TestingRpcService;&lt;br/&gt;
+import org.apache.flink.runtime.util.TestingFatalErrorHandler;&lt;br/&gt;
+import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.hamcrest.Matchers;&lt;br/&gt;
+import org.junit.After;&lt;br/&gt;
+import org.junit.AfterClass;&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.BeforeClass;&lt;br/&gt;
+import org.junit.ClassRule;&lt;br/&gt;
+import org.junit.Rule;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.rules.TemporaryFolder;&lt;br/&gt;
+import org.junit.rules.TestName;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Test cases for the interaction between ZooKeeper HA and the {@link Dispatcher}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ZooKeeperHADispatcherTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	private static final Time TIMEOUT = Time.seconds(10L);&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final ZooKeeperResource ZOO_KEEPER_RESOURCE = new ZooKeeperResource();&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();&lt;br/&gt;
+&lt;br/&gt;
+	private static Configuration configuration;&lt;br/&gt;
+&lt;br/&gt;
+	private static TestingRpcService rpcService;&lt;br/&gt;
+&lt;br/&gt;
+	private static BlobServer blobServer;&lt;br/&gt;
+&lt;br/&gt;
+	@Rule&lt;br/&gt;
+	public TestName name = new TestName();&lt;br/&gt;
+&lt;br/&gt;
+	private TestingFatalErrorHandler testingFatalErrorHandler;&lt;br/&gt;
+&lt;br/&gt;
+	@BeforeClass&lt;br/&gt;
+	public static void setupClass() throws IOException &lt;/p&gt;
{
+		configuration = new Configuration();
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, ZOO_KEEPER_RESOURCE.getConnectString());
+		configuration.setString(HighAvailabilityOptions.HA_STORAGE_PATH, TEMPORARY_FOLDER.newFolder().getAbsolutePath());
+		rpcService = new TestingRpcService();
+		blobServer = new BlobServer(configuration, new VoidBlobStore());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Before&lt;br/&gt;
+	public void setup() &lt;/p&gt;
{
+		testingFatalErrorHandler = new TestingFatalErrorHandler();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@After&lt;br/&gt;
+	public void teardown() throws Exception &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		if (testingFatalErrorHandler != null) {
+			testingFatalErrorHandler.rethrowError();
+		}+	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+	@AfterClass&lt;br/&gt;
+	public static void teardownClass() throws Exception &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		if (rpcService != null) {
+			RpcUtils.terminateRpcService(rpcService, TIMEOUT);
+			rpcService = null;
+		}++		if (blobServer != null) {
+			blobServer.close();
+			blobServer = null;
+		}+	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the &lt;/p&gt;
{@link Dispatcher}
&lt;p&gt; releases a locked &lt;/p&gt;
{@link SubmittedJobGraph}
&lt;p&gt; if it&lt;br/&gt;
+	 * lost the leadership.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testSubmittedJobGraphRelease() throws Exception {&lt;br/&gt;
+		final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+		final CuratorFramework otherClient = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+&lt;br/&gt;
+		try (final TestingHighAvailabilityServices testingHighAvailabilityServices = new TestingHighAvailabilityServices()) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			testingHighAvailabilityServices.setSubmittedJobGraphStore(ZooKeeperUtils.createSubmittedJobGraphs(client, configuration));++			final ZooKeeperSubmittedJobGraphStore otherSubmittedJobGraphStore = ZooKeeperUtils.createSubmittedJobGraphs(+				otherClient,+				configuration);++			otherSubmittedJobGraphStore.start(NoOpSubmittedJobGraphListener.INSTANCE);++			final TestingLeaderElectionService leaderElectionService = new TestingLeaderElectionService();+			testingHighAvailabilityServices.setDispatcherLeaderElectionService(leaderElectionService);++			final TestingDispatcher dispatcher = createDispatcher(testingHighAvailabilityServices);++			dispatcher.start();++			try {
+				final DispatcherId expectedLeaderId = DispatcherId.generate();
+				leaderElectionService.isLeader(expectedLeaderId.toUUID()).get();
+
+				final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
+
+				final JobGraph nonEmptyJobGraph = DispatcherHATest.createNonEmptyJobGraph();
+				final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = dispatcherGateway.submitJob(nonEmptyJobGraph, TIMEOUT);
+				submissionFuture.get();
+
+				Collection&amp;lt;JobID&amp;gt; jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+				final JobID jobId = nonEmptyJobGraph.getJobID();
+				assertThat(jobIds, Matchers.contains(jobId));
+
+				leaderElectionService.notLeader();
+
+				// wait for the job to properly terminate
+				final CompletableFuture&amp;lt;Void&amp;gt; jobTerminationFuture = dispatcher.getJobTerminationFuture(jobId, TIMEOUT);
+				jobTerminationFuture.get();
+
+				// recover the job
+				final SubmittedJobGraph submittedJobGraph = otherSubmittedJobGraphStore.recoverJobGraph(jobId);
+
+				assertThat(submittedJobGraph, Matchers.is(Matchers.notNullValue()));
+
+				// check that the other submitted job graph store can remove the job graph after the original leader
+				// has lost its leadership
+				otherSubmittedJobGraphStore.removeJobGraph(jobId);
+
+				jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+				assertThat(jobIds, Matchers.not(Matchers.contains(jobId)));
+			} finally {
+				RpcUtils.terminateRpcEndpoint(dispatcher, TIMEOUT);
+				client.close();
+				otherClient.close();
+			}+		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private TestingDispatcher createDispatcher(TestingHighAvailabilityServices testingHighAvailabilityServices) throws Exception &lt;/p&gt;
{
+		return new TestingDispatcher(
+			rpcService,
+			Dispatcher.DISPATCHER_NAME + &apos;_&apos; + name.getMethodName(),
+			configuration,
+			testingHighAvailabilityServices,
+			new TestingResourceManagerGateway(),
+			blobServer,
+			new HeartbeatServices(1000L, 1000L),
+			UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(),
+			null,
+			new MemoryArchivedExecutionGraphStore(),
+			new TestingJobManagerRunnerFactory(new CompletableFuture&amp;lt;&amp;gt;(), new CompletableFuture&amp;lt;&amp;gt;()),
+			testingFatalErrorHandler);
+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java&lt;br/&gt;
index 052349cd043..098f564f6bf 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java&lt;br/&gt;
@@ -32,8 +32,8 @@&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointMetrics;&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
-import org.apache.flink.runtime.checkpoint.CheckpointType;&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointRetentionPolicy;&lt;br/&gt;
+import org.apache.flink.runtime.checkpoint.CheckpointType;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.messages.NotifyResourceStarted;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.messages.RegisterResourceManager;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.messages.RegisterResourceManagerSuccessful;&lt;br/&gt;
@@ -152,7 +152,6 @@&lt;br/&gt;
 import static org.junit.Assert.assertNotNull;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;br/&gt;
 import static org.junit.Assert.fail;&lt;br/&gt;
-&lt;br/&gt;
 import static org.mockito.Mockito.mock;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; public class JobManagerTest extends TestLogger {&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..8e5b1b9b392&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java&lt;br/&gt;
@@ -0,0 +1,180 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.jobmanager;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.configuration.Configuration;&lt;br/&gt;
+import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
+import org.apache.flink.runtime.akka.ActorUtils;&lt;br/&gt;
+import org.apache.flink.runtime.akka.AkkaUtils;&lt;br/&gt;
+import org.apache.flink.runtime.akka.ListeningBehaviour;&lt;br/&gt;
+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;&lt;br/&gt;
+import org.apache.flink.runtime.dispatcher.DispatcherHATest;&lt;br/&gt;
+import org.apache.flink.runtime.dispatcher.NoOpSubmittedJobGraphListener;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.HighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.instance.ActorGateway;&lt;br/&gt;
+import org.apache.flink.runtime.instance.AkkaActorGateway;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;&lt;br/&gt;
+import org.apache.flink.runtime.messages.JobManagerMessages;&lt;br/&gt;
+import org.apache.flink.runtime.metrics.NoOpMetricRegistry;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingJobManager;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingJobManagerMessages;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingUtils;&lt;br/&gt;
+import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import akka.actor.ActorRef;&lt;br/&gt;
+import akka.actor.ActorSystem;&lt;br/&gt;
+import akka.actor.ExtendedActorSystem;&lt;br/&gt;
+import akka.actor.Identify;&lt;br/&gt;
+import akka.actor.Terminated;&lt;br/&gt;
+import akka.pattern.Patterns;&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.junit.AfterClass;&lt;br/&gt;
+import org.junit.BeforeClass;&lt;br/&gt;
+import org.junit.ClassRule;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.rules.TemporaryFolder;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+&lt;br/&gt;
+import scala.Option;&lt;br/&gt;
+import scala.concurrent.Await;&lt;br/&gt;
+import scala.concurrent.Future;&lt;br/&gt;
+import scala.concurrent.duration.FiniteDuration;&lt;br/&gt;
+&lt;br/&gt;
+import static org.hamcrest.Matchers.contains;&lt;br/&gt;
+import static org.hamcrest.Matchers.is;&lt;br/&gt;
+import static org.hamcrest.Matchers.not;&lt;br/&gt;
+import static org.hamcrest.Matchers.notNullValue;&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tests for the ZooKeeper HA service and &lt;/p&gt;
{@link JobManager} interaction.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ZooKeeperHAJobManagerTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final ZooKeeperResource ZOO_KEEPER_RESOURCE = new ZooKeeperResource();&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();&lt;br/&gt;
+&lt;br/&gt;
+	private static final FiniteDuration TIMEOUT = FiniteDuration.apply(10L, TimeUnit.SECONDS);&lt;br/&gt;
+&lt;br/&gt;
+	private static ActorSystem system;&lt;br/&gt;
+&lt;br/&gt;
+	@BeforeClass&lt;br/&gt;
+	public static void setup() {
+		system = AkkaUtils.createLocalActorSystem(new Configuration());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@AfterClass&lt;br/&gt;
+	public static void teardown() throws Exception {
+		final Future&amp;lt;Terminated&amp;gt; terminationFuture = system.terminate();
+		Await.ready(terminationFuture, TIMEOUT);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the {@link JobManager}
&lt;p&gt; releases all locked &lt;/p&gt;
{@link JobGraph}
&lt;p&gt; if it loses&lt;br/&gt;
+	 * leadership.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testJobGraphReleaseWhenLosingLeadership() throws Exception {&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, ZOO_KEEPER_RESOURCE.getConnectString());&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_STORAGE_PATH, TEMPORARY_FOLDER.newFolder().getAbsolutePath());&lt;br/&gt;
+&lt;br/&gt;
+		try (TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices()) {&lt;br/&gt;
+&lt;br/&gt;
+			final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+			final TestingLeaderElectionService leaderElectionService = new TestingLeaderElectionService();&lt;br/&gt;
+			highAvailabilityServices.setJobMasterLeaderElectionService(HighAvailabilityServices.DEFAULT_JOB_ID, leaderElectionService);&lt;br/&gt;
+			highAvailabilityServices.setSubmittedJobGraphStore(ZooKeeperUtils.createSubmittedJobGraphs(client, configuration));&lt;br/&gt;
+			highAvailabilityServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());&lt;br/&gt;
+&lt;br/&gt;
+			final CuratorFramework otherClient = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+			final ZooKeeperSubmittedJobGraphStore otherSubmittedJobGraphStore = ZooKeeperUtils.createSubmittedJobGraphs(otherClient, configuration);&lt;br/&gt;
+			otherSubmittedJobGraphStore.start(NoOpSubmittedJobGraphListener.INSTANCE);&lt;br/&gt;
+&lt;br/&gt;
+			ActorRef jobManagerActorRef = null;&lt;br/&gt;
+			try &lt;/p&gt;
{
+				jobManagerActorRef = JobManager.startJobManagerActors(
+					configuration,
+					system,
+					TestingUtils.defaultExecutor(),
+					TestingUtils.defaultExecutor(),
+					highAvailabilityServices,
+					NoOpMetricRegistry.INSTANCE,
+					Option.empty(),
+					TestingJobManager.class,
+					MemoryArchivist.class)._1();
+
+				waitForActorToBeStarted(jobManagerActorRef, TIMEOUT);
+
+				final ActorGateway jobManager = new AkkaActorGateway(jobManagerActorRef, HighAvailabilityServices.DEFAULT_LEADER_ID);
+
+				leaderElectionService.isLeader(HighAvailabilityServices.DEFAULT_LEADER_ID).get();
+
+				final JobGraph nonEmptyJobGraph = DispatcherHATest.createNonEmptyJobGraph();
+
+				final JobManagerMessages.SubmitJob submitJobMessage = new JobManagerMessages.SubmitJob(nonEmptyJobGraph, ListeningBehaviour.DETACHED);
+
+				Await.result(jobManager.ask(submitJobMessage, TIMEOUT), TIMEOUT);
+
+				Collection&amp;lt;JobID&amp;gt; jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+				final JobID jobId = nonEmptyJobGraph.getJobID();
+				assertThat(jobIds, contains(jobId));
+
+				// revoke the leadership
+				leaderElectionService.notLeader();
+
+				Await.result(jobManager.ask(TestingJobManagerMessages.getWaitForBackgroundTasksToFinish(), TIMEOUT), TIMEOUT);
+
+				final SubmittedJobGraph recoveredJobGraph = akka.serialization.JavaSerializer.currentSystem().withValue(
+					((ExtendedActorSystem) system),
+					() -&amp;gt; otherSubmittedJobGraphStore.recoverJobGraph(jobId));
+
+				assertThat(recoveredJobGraph, is(notNullValue()));
+
+				otherSubmittedJobGraphStore.removeJobGraph(jobId);
+
+				jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+				assertThat(jobIds, not(contains(jobId)));
+			}
&lt;p&gt; finally {&lt;br/&gt;
+				client.close();&lt;br/&gt;
+				otherClient.close();&lt;br/&gt;
+&lt;br/&gt;
+				if (jobManagerActorRef != null) &lt;/p&gt;
{
+					ActorUtils.stopActor(jobManagerActorRef);
+				}
&lt;p&gt;+			}&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private void waitForActorToBeStarted(ActorRef jobManagerActorRef, FiniteDuration timeout) throws InterruptedException, java.util.concurrent.TimeoutException &lt;/p&gt;
{
+		Await.ready(Patterns.ask(jobManagerActorRef, new Identify(42), timeout.toMillis()), timeout);
+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java&lt;br/&gt;
index c1a7b536721..e9be145c37f 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java&lt;br/&gt;
@@ -20,7 +20,6 @@&lt;/p&gt;

&lt;p&gt; import org.apache.flink.api.common.JobID;&lt;br/&gt;
 import org.apache.flink.runtime.akka.ListeningBehaviour;&lt;br/&gt;
-import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobVertex;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore.SubmittedJobGraphListener;&lt;br/&gt;
@@ -90,8 +89,7 @@ public void testPutAndRemoveJobGraph() throws Exception {&lt;br/&gt;
 		ZooKeeperSubmittedJobGraphStore jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;br/&gt;
 			ZooKeeper.createClient(),&lt;br/&gt;
 			&quot;/testPutAndRemoveJobGraph&quot;,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;localStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		try {&lt;br/&gt;
 			SubmittedJobGraphListener listener = mock(SubmittedJobGraphListener.class);&lt;br/&gt;
@@ -147,7 +145,7 @@ public void testPutAndRemoveJobGraph() throws Exception {&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testRecoverJobGraphs() throws Exception {&lt;br/&gt;
 		ZooKeeperSubmittedJobGraphStore jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testRecoverJobGraphs&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+				ZooKeeper.createClient(), &quot;/testRecoverJobGraphs&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		try {&lt;br/&gt;
 			SubmittedJobGraphListener listener = mock(SubmittedJobGraphListener.class);&lt;br/&gt;
@@ -198,10 +196,10 @@ public void testConcurrentAddJobGraph() throws Exception {&lt;/p&gt;

&lt;p&gt; 		try {&lt;br/&gt;
 			jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+					ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			otherJobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+					ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt; 			SubmittedJobGraph jobGraph = createSubmittedJobGraph(new JobID(), 0);&lt;br/&gt;
@@ -257,10 +255,10 @@ public Void answer(InvocationOnMock invocation) throws Throwable {&lt;br/&gt;
 	@Test(expected = IllegalStateException.class)&lt;br/&gt;
 	public void testUpdateJobGraphYouDidNotGetOrAdd() throws Exception {&lt;br/&gt;
 		ZooKeeperSubmittedJobGraphStore jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+				ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperSubmittedJobGraphStore otherJobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+				ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		jobGraphs.start(null);&lt;br/&gt;
 		otherJobGraphs.start(null);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java&lt;br/&gt;
index ba0dc80fbb5..3b9c5786ca4 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java&lt;br/&gt;
@@ -96,6 +96,11 @@ public synchronized void removeJobGraph(JobID jobId) throws Exception &lt;/p&gt;
{
 		storedJobs.remove(jobId);
 	}

&lt;p&gt;+	@Override&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) &lt;/p&gt;
{
+		verifyIsStarted();
+	}
&lt;p&gt;+&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public synchronized Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
 		verifyIsStarted();&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperResource.java b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperResource.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..c4c56949cd9&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperResource.java&lt;br/&gt;
@@ -0,0 +1,72 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.zookeeper;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.test.TestingServer;&lt;br/&gt;
+import org.junit.rules.ExternalResource;&lt;br/&gt;
+import org.slf4j.Logger;&lt;br/&gt;
+import org.slf4j.LoggerFactory;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * &lt;/p&gt;
{@link ExternalResource}
&lt;p&gt; which starts a &lt;/p&gt;
{@link org.apache.zookeeper.server.ZooKeeperServer}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ZooKeeperResource extends ExternalResource {&lt;br/&gt;
+&lt;br/&gt;
+	private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperResource.class);&lt;br/&gt;
+&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	private TestingServer zooKeeperServer;&lt;br/&gt;
+&lt;br/&gt;
+	public String getConnectString() &lt;/p&gt;
{
+		verifyIsRunning();
+		return zooKeeperServer.getConnectString();
+	}
&lt;p&gt;+&lt;br/&gt;
+	private void verifyIsRunning() &lt;/p&gt;
{
+		Preconditions.checkState(zooKeeperServer != null);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	protected void before() throws Throwable &lt;/p&gt;
{
+		terminateZooKeeperServer();
+		zooKeeperServer = new TestingServer(true);
+	}
&lt;p&gt;+&lt;br/&gt;
+	private void terminateZooKeeperServer() throws IOException {&lt;br/&gt;
+		if (zooKeeperServer != null) &lt;/p&gt;
{
+			zooKeeperServer.stop();
+			zooKeeperServer = null;
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	protected void after() {&lt;br/&gt;
+		try &lt;/p&gt;
{
+			terminateZooKeeperServer();
+		}
&lt;p&gt; catch (IOException e) {&lt;br/&gt;
+			LOG.warn(&quot;Could not properly terminate the {}.&quot;, getClass().getSimpleName(), e);&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java&lt;br/&gt;
index fd39b25991c..2dd27e7c897 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java&lt;br/&gt;
@@ -18,21 +18,19 @@&lt;/p&gt;

&lt;p&gt; package org.apache.flink.runtime.zookeeper;&lt;/p&gt;

&lt;p&gt;-import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
 import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
 import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
-import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
 import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
 import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
 import org.apache.flink.util.InstantiationUtil;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
 import org.apache.zookeeper.data.Stat;&lt;br/&gt;
 import org.junit.AfterClass;&lt;br/&gt;
 import org.junit.Before;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
-import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
-import org.mockito.stubbing.Answer;&lt;/p&gt;

&lt;p&gt; import java.io.IOException;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
@@ -41,7 +39,6 @@&lt;br/&gt;
 import java.util.HashSet;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Set;&lt;br/&gt;
-import java.util.concurrent.CountDownLatch;&lt;/p&gt;

&lt;p&gt; import static org.junit.Assert.assertEquals;&lt;br/&gt;
 import static org.junit.Assert.assertNotEquals;&lt;br/&gt;
@@ -49,12 +46,7 @@&lt;br/&gt;
 import static org.junit.Assert.assertNull;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;br/&gt;
 import static org.junit.Assert.fail;&lt;br/&gt;
-import static org.mockito.Matchers.any;&lt;br/&gt;
-import static org.mockito.Mockito.doAnswer;&lt;br/&gt;
-import static org.mockito.Mockito.mock;&lt;br/&gt;
 import static org.mockito.Mockito.spy;&lt;br/&gt;
-import static org.mockito.Mockito.times;&lt;br/&gt;
-import static org.mockito.Mockito.verify;&lt;br/&gt;
 import static org.mockito.Mockito.when;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -88,8 +80,8 @@ public void cleanUp() throws Exception {&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testAddAndLock() throws Exception {&lt;br/&gt;
 		LongStateStorage longStateStorage = new LongStateStorage();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;Long&amp;gt;(&lt;/li&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), longStateStorage, Executors.directExecutor());&lt;br/&gt;
+		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
+			ZOOKEEPER.getClient(), longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testAdd&quot;;&lt;br/&gt;
@@ -136,7 +128,7 @@ public void testAddAlreadyExistingPath() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZOOKEEPER.getClient().create().forPath(&quot;/testAddAlreadyExistingPath&quot;);&lt;/p&gt;

&lt;p&gt;@@ -161,7 +153,7 @@ public void testAddDiscardStateHandleAfterFailure() throws Exception {&lt;br/&gt;
 		when(client.inTransaction().create()).thenThrow(new RuntimeException(&quot;Expected test Exception.&quot;));&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client, stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				client, stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testAddDiscardStateHandleAfterFailure&quot;;&lt;br/&gt;
@@ -191,7 +183,7 @@ public void testReplace() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testReplace&quot;;&lt;br/&gt;
@@ -230,7 +222,7 @@ public void testReplaceNonExistingPath() throws Exception &lt;/p&gt;
{
 		RetrievableStateStorageHelper&amp;lt;Long&amp;gt; stateStorage = new LongStateStorage();
 
 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(
-				ZOOKEEPER.getClient(), stateStorage, Executors.directExecutor());
+				ZOOKEEPER.getClient(), stateStorage);
 
 		store.replace(&quot;/testReplaceNonExistingPath&quot;, 0, 1L);
 	}
&lt;p&gt;@@ -247,7 +239,7 @@ public void testReplaceDiscardStateHandleAfterFailure() throws Exception {&lt;br/&gt;
 		when(client.setData()).thenThrow(new RuntimeException(&quot;Expected test Exception.&quot;));&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client, stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				client, stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testReplaceDiscardStateHandleAfterFailure&quot;;&lt;br/&gt;
@@ -289,7 +281,7 @@ public void testGetAndExists() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testGetAndExists&quot;;&lt;br/&gt;
@@ -314,7 +306,7 @@ public void testGetNonExistingPath() throws Exception &lt;/p&gt;
{
 		LongStateStorage stateHandleProvider = new LongStateStorage();
 
 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(
-				ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());
+				ZOOKEEPER.getClient(), stateHandleProvider);
 
 		store.getAndLock(&quot;/testGetNonExistingPath&quot;);
 	}
&lt;p&gt;@@ -328,7 +320,7 @@ public void testGetAll() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testGetAll&quot;;&lt;br/&gt;
@@ -359,7 +351,7 @@ public void testGetAllSortedByName() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String basePath = &quot;/testGetAllSortedByName&quot;;&lt;br/&gt;
@@ -393,7 +385,7 @@ public void testRemove() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testRemove&quot;;&lt;br/&gt;
@@ -401,50 +393,14 @@ public void testRemove() throws Exception &lt;/p&gt;
{
 
 		store.addAndLock(pathInZooKeeper, state);
 
+		final int numberOfGlobalDiscardCalls = LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls();
+
 		// Test
 		store.releaseAndTryRemove(pathInZooKeeper);
 
 		// Verify discarded
 		assertEquals(0, ZOOKEEPER.getClient().getChildren().forPath(&quot;/&quot;).size());
-	}
&lt;p&gt;-&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Tests that state handles are correctly removed with a callback.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testRemoveWithCallback() throws Exception {&lt;/li&gt;
	&lt;li&gt;// Setup&lt;/li&gt;
	&lt;li&gt;LongStateStorage stateHandleProvider = new LongStateStorage();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/li&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Config&lt;/li&gt;
	&lt;li&gt;final String pathInZooKeeper = &quot;/testRemoveWithCallback&quot;;&lt;/li&gt;
	&lt;li&gt;final Long state = 27255442L;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;store.addAndLock(pathInZooKeeper, state);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CountDownLatch sync = new CountDownLatch(1);&lt;/li&gt;
	&lt;li&gt;ZooKeeperStateHandleStore.RemoveCallback&amp;lt;Long&amp;gt; callback = mock(ZooKeeperStateHandleStore.RemoveCallback.class);&lt;/li&gt;
	&lt;li&gt;doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public Void answer(InvocationOnMock invocation) throws Throwable 
{
-				sync.countDown();
-				return null;
-			}&lt;/li&gt;
	&lt;li&gt;}).when(callback).apply(any(RetrievableStateHandle.class));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Test&lt;/li&gt;
	&lt;li&gt;store.releaseAndTryRemove(pathInZooKeeper, callback);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Verify discarded and callback called&lt;/li&gt;
	&lt;li&gt;assertEquals(0, ZOOKEEPER.getClient().getChildren().forPath(&quot;/&quot;).size());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;sync.await();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;verify(callback, times(1))&lt;/li&gt;
	&lt;li&gt;.apply(any(RetrievableStateHandle.class));&lt;br/&gt;
+		assertEquals(numberOfGlobalDiscardCalls + 1, LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls());&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/** Tests that all state handles are correctly discarded. */&lt;br/&gt;
@@ -454,7 +410,7 @@ public void testReleaseAndTryRemoveAll() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testDiscardAll&quot;;&lt;br/&gt;
@@ -486,8 +442,7 @@ public void testCorruptedData() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;stateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			stateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final Collection&amp;lt;Long&amp;gt; input = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
 		input.add(1L);&lt;br/&gt;
@@ -543,13 +498,11 @@ public void testConcurrentDeleteOperation() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore1 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore2 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final String statePath = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -586,13 +539,11 @@ public void testLockCleanupWhenGetAndLockFails() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore1 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore2 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final String path = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -649,8 +600,7 @@ public void testLockCleanupWhenClientTimesOut() throws Exception {&lt;/p&gt;

&lt;p&gt; 			ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 				client,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+				longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			final String path = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -682,8 +632,7 @@ public void testRelease() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final String path = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -720,8 +669,7 @@ public void testReleaseAll() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final Collection&amp;lt;String&amp;gt; paths = Arrays.asList(&quot;/state1&quot;, &quot;/state2&quot;, &quot;/state3&quot;);&lt;/p&gt;

&lt;p&gt;@@ -775,9 +723,11 @@ public void testReleaseAll() throws Exception {&lt;/p&gt;

&lt;p&gt; 		private static final long serialVersionUID = -3555329254423838912L;&lt;/p&gt;

&lt;p&gt;+		private static int numberOfGlobalDiscardCalls = 0;&lt;br/&gt;
+&lt;br/&gt;
 		private final Long state;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private int numberOfDiscardCalls;&lt;br/&gt;
+		private int numberOfDiscardCalls = 0;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		public LongRetrievableStateHandle(Long state) {&lt;br/&gt;
 			this.state = state;&lt;br/&gt;
@@ -790,6 +740,7 @@ public Long retrieveState() {&lt;/p&gt;

&lt;p&gt; 		@Override&lt;br/&gt;
 		public void discardState() throws Exception &lt;/p&gt;
{
+			numberOfGlobalDiscardCalls++;
 			numberOfDiscardCalls++;
 		}

&lt;p&gt;@@ -798,8 +749,12 @@ public long getStateSize() &lt;/p&gt;
{
 			return 0;
 		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public int getNumberOfDiscardCalls() 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		int getNumberOfDiscardCalls() {
 			return numberOfDiscardCalls;
 		}++		public static int getNumberOfGlobalDiscardCalls() {
+			return numberOfGlobalDiscardCalls;
+		} 	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; }&lt;br/&gt;
diff --git a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala&lt;br/&gt;
index 0640f39f4cf..ebe46399395 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala&lt;br/&gt;
+++ b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala&lt;br/&gt;
@@ -454,6 +454,14 @@ trait TestingJobManagerLike extends FlinkActor 
{
         val receiver = waitForNumRegisteredTaskManagers.dequeue()._2
         receiver ! Acknowledge.get()
       }
&lt;p&gt;+&lt;br/&gt;
+    case WaitForBackgroundTasksToFinish =&amp;gt;&lt;br/&gt;
+      val future = futuresToComplete match &lt;/p&gt;
{
+        case Some(futures) =&amp;gt; Future.sequence(futures)
+        case None =&amp;gt; Future.successful(Seq())
+      }
&lt;p&gt;+&lt;br/&gt;
+      future.pipeTo(sender())&lt;br/&gt;
   }&lt;/p&gt;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   def checkIfAllVerticesRunning(jobID: JobID): Boolean = {&lt;br/&gt;
diff --git a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala&lt;br/&gt;
index c8529a9e07a..64af056f24d 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala&lt;br/&gt;
+++ b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala&lt;br/&gt;
@@ -59,6 +59,8 @@ object TestingJobManagerMessages {&lt;/p&gt;

&lt;p&gt;   case object NotifyListeners&lt;/p&gt;

&lt;p&gt;+  case object WaitForBackgroundTasksToFinish&lt;br/&gt;
+&lt;br/&gt;
   case class NotifyWhenTaskManagerTerminated(taskManager: ActorRef)&lt;br/&gt;
   case class TaskManagerTerminated(taskManager: ActorRef)&lt;/p&gt;

&lt;p&gt;@@ -164,4 +166,5 @@ object TestingJobManagerMessages &lt;/p&gt;
{
   def getClientConnected(): AnyRef = ClientConnected
   def getClassLoadingPropsDelivered(): AnyRef = ClassLoadingPropsDelivered
 
+  def getWaitForBackgroundTasksToFinish(): AnyRef = WaitForBackgroundTasksToFinish
 }




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612252" author="githubbot" created="Wed, 12 Sep 2018 14:49:22 +0000"  >&lt;p&gt;tillrohrmann commented on issue #6588: &lt;span class=&quot;error&quot;&gt;&amp;#91;Backport 1.6&amp;#93;&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6588#issuecomment-420677005&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6588#issuecomment-420677005&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Merged via&lt;br/&gt;
   fabd246e5342001d64be55c820ba50b3cf75d2a6&lt;br/&gt;
   5e62da0f95d9abe35997e45dc9b0df3a9c7495cd&lt;br/&gt;
   4d7204784270b5ad8d5455d82f7a965efdb5ae45&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612253" author="githubbot" created="Wed, 12 Sep 2018 14:49:23 +0000"  >&lt;p&gt;tillrohrmann closed pull request #6588: &lt;span class=&quot;error&quot;&gt;&amp;#91;Backport 1.6&amp;#93;&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6588&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6588&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java b/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java&lt;br/&gt;
index 069cb833a3a..45d11412c50 100644&lt;br/&gt;
&amp;#8212; a/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java&lt;br/&gt;
+++ b/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java&lt;br/&gt;
@@ -56,8 +56,7 @@ public MesosWorkerStore createMesosWorkerStore(Configuration configuration, Exec&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;MesosWorkerStore.Worker&amp;gt; zooKeeperStateHandleStore = zooKeeperUtilityFactory.createZooKeeperStateHandleStore(&lt;br/&gt;
 			&quot;/workers&quot;,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;stateStorageHelper,&lt;/li&gt;
	&lt;li&gt;executor);&lt;br/&gt;
+			stateStorageHelper);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperSharedValue frameworkId = zooKeeperUtilityFactory.createSharedValue(&quot;/frameworkId&quot;, new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
 		ZooKeeperSharedCount totalTaskCount = zooKeeperUtilityFactory.createSharedCount(&quot;/taskCount&quot;, 0);&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java&lt;br/&gt;
index f2f905971c3..9a992814235 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java&lt;br/&gt;
@@ -19,9 +19,11 @@&lt;br/&gt;
 package org.apache.flink.runtime.akka;&lt;/p&gt;

&lt;p&gt; import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.runtime.instance.AkkaActorGateway;&lt;/p&gt;

&lt;p&gt; import akka.actor.ActorRef;&lt;br/&gt;
 import akka.actor.Kill;&lt;br/&gt;
+import akka.actor.PoisonPill;&lt;br/&gt;
 import akka.pattern.Patterns;&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
@@ -85,5 +87,13 @@&lt;br/&gt;
 		return FutureUtils.completeAll(terminationFutures);&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	public static void stopActor(AkkaActorGateway akkaActorGateway) &lt;/p&gt;
{
+		stopActor(akkaActorGateway.actor());
+	}
&lt;p&gt;+&lt;br/&gt;
+	public static void stopActor(ActorRef actorRef) &lt;/p&gt;
{
+		actorRef.tell(PoisonPill.getInstance(), ActorRef.noSender());
+	}
&lt;p&gt;+&lt;br/&gt;
 	private ActorUtils() {}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
index f22127041d3..131733924ae 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
@@ -25,14 +25,13 @@&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;&lt;br/&gt;
 import org.apache.flink.util.FlinkException;&lt;br/&gt;
+import org.apache.flink.util.function.ConsumerWithException;&lt;/p&gt;

&lt;p&gt; import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
 import org.apache.curator.utils.ZKPaths;&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;/p&gt;

&lt;p&gt;-import javax.annotation.Nullable;&lt;br/&gt;
-&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.util.ArrayDeque;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
@@ -86,6 +85,8 @@&lt;br/&gt;
 	 */&lt;br/&gt;
 	private final ArrayDeque&amp;lt;CompletedCheckpoint&amp;gt; completedCheckpoints;&lt;/p&gt;

&lt;p&gt;+	private final Executor executor;&lt;br/&gt;
+&lt;br/&gt;
 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Creates a 
{@link ZooKeeperCompletedCheckpointStore} instance.&lt;br/&gt;
 	 *&lt;br/&gt;
@@ -98,7 +99,7 @@&lt;br/&gt;
 	 *                                       start with a &apos;/&apos;)&lt;br/&gt;
 	 * @param stateStorage                   State storage to be used to persist the completed&lt;br/&gt;
 	 *                                       checkpoint&lt;br/&gt;
-	 * @param executor to give to the ZooKeeperStateHandleStore to run ZooKeeper callbacks&lt;br/&gt;
+	 * @param executor to execute blocking calls&lt;br/&gt;
 	 * @throws Exception&lt;br/&gt;
 	 */&lt;br/&gt;
 	public ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
@@ -123,10 +124,12 @@ public ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
 		// All operations will have the path as root&lt;br/&gt;
 		this.client = client.usingNamespace(client.getNamespace() + checkpointsPath);&lt;br/&gt;
 &lt;br/&gt;
-		this.checkpointsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(this.client, stateStorage, executor);&lt;br/&gt;
+		this.checkpointsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(this.client, stateStorage);&lt;br/&gt;
 &lt;br/&gt;
 		this.completedCheckpoints = new ArrayDeque&amp;lt;&amp;gt;(maxNumberOfCheckpointsToRetain + 1);&lt;br/&gt;
 &lt;br/&gt;
+		this.executor = checkNotNull(executor);&lt;br/&gt;
+&lt;br/&gt;
 		LOG.info(&quot;Initialized in &apos;{}&apos;.&quot;, checkpointsPath);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
@@ -236,16 +239,30 @@ public void addCheckpoint(final CompletedCheckpoint checkpoint) throws Exception&lt;br/&gt;
 &lt;br/&gt;
 		// Everything worked, let&apos;s remove a previous checkpoint if necessary.&lt;br/&gt;
 		while (completedCheckpoints.size() &amp;gt; maxNumberOfCheckpointsToRetain) {&lt;br/&gt;
-			try {
-				removeSubsumed(completedCheckpoints.removeFirst());
-			} catch (Exception e) {
-				LOG.warn(&quot;Failed to subsume the old checkpoint&quot;, e);
-			}&lt;br/&gt;
+			final CompletedCheckpoint completedCheckpoint = completedCheckpoints.removeFirst();&lt;br/&gt;
+			tryRemoveCompletedCheckpoint(completedCheckpoint, CompletedCheckpoint::discardOnSubsume);&lt;br/&gt;
 		}&lt;br/&gt;
 &lt;br/&gt;
 		LOG.debug(&quot;Added {} to {}.&quot;, checkpoint, path);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	private void tryRemoveCompletedCheckpoint(CompletedCheckpoint completedCheckpoint, ConsumerWithException&amp;lt;CompletedCheckpoint, Exception&amp;gt; discardCallback) {&lt;br/&gt;
+		try {&lt;br/&gt;
+			if (tryRemove(completedCheckpoint.getCheckpointID())) {&lt;br/&gt;
+				executor.execute(() -&amp;gt; {&lt;br/&gt;
+					try {
+						discardCallback.accept(completedCheckpoint);
+					} catch (Exception e) {&lt;br/&gt;
+						LOG.warn(&quot;Could not discard completed checkpoint {}.&quot;, completedCheckpoint.getCheckpointID(), e);&lt;br/&gt;
+					}&lt;br/&gt;
+				});&lt;br/&gt;
+&lt;br/&gt;
+			}&lt;br/&gt;
+		} catch (Exception e) {
+			LOG.warn(&quot;Failed to subsume the old checkpoint&quot;, e);
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public CompletedCheckpoint getLatestCheckpoint() {&lt;br/&gt;
 		if (completedCheckpoints.isEmpty()) {&lt;br/&gt;
@@ -278,11 +295,9 @@ public void shutdown(JobStatus jobStatus) throws Exception {&lt;br/&gt;
 			LOG.info(&quot;Shutting down&quot;);&lt;br/&gt;
 &lt;br/&gt;
 			for (CompletedCheckpoint checkpoint : completedCheckpoints) {&lt;br/&gt;
-				try {
-					removeShutdown(checkpoint, jobStatus);
-				} catch (Exception e) {
-					LOG.error(&quot;Failed to discard checkpoint.&quot;, e);
-				}&lt;br/&gt;
+				tryRemoveCompletedCheckpoint(&lt;br/&gt;
+					checkpoint,&lt;br/&gt;
+					completedCheckpoint -&amp;gt; completedCheckpoint.discardOnShutdown(jobStatus));&lt;br/&gt;
 			}&lt;br/&gt;
 &lt;br/&gt;
 			completedCheckpoints.clear();&lt;br/&gt;
@@ -305,59 +320,13 @@ public void shutdown(JobStatus jobStatus) throws Exception {&lt;br/&gt;
 	// ------------------------------------------------------------------------&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
-	 * Removes a subsumed checkpoint from ZooKeeper and drops the state.&lt;br/&gt;
-	 */&lt;br/&gt;
-	private void removeSubsumed(&lt;br/&gt;
-		final CompletedCheckpoint completedCheckpoint) throws Exception {&lt;br/&gt;
-&lt;br/&gt;
-		if (completedCheckpoint == null) {
-			return;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt; action =&lt;br/&gt;
-			new ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt;() {&lt;br/&gt;
-				@Override&lt;br/&gt;
-				public void apply(@Nullable RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; value) throws FlinkException {&lt;br/&gt;
-					if (value != null) {&lt;br/&gt;
-						try {
-							completedCheckpoint.discardOnSubsume();
-						} catch (Exception e) {
-							throw new FlinkException(&quot;Could not discard the completed checkpoint on subsume.&quot;, e);
-						}&lt;br/&gt;
-					}&lt;br/&gt;
-				}&lt;br/&gt;
-			};&lt;br/&gt;
-&lt;br/&gt;
-		checkpointsInZooKeeper.releaseAndTryRemove(&lt;br/&gt;
-			checkpointIdToPath(completedCheckpoint.getCheckpointID()),&lt;br/&gt;
-			action);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Removes a checkpoint from ZooKeeper because of Job shutdown and drops the state.&lt;br/&gt;
+	 * Tries to remove the checkpoint identified by the given checkpoint id.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param checkpointId identifying the checkpoint to remove&lt;br/&gt;
+	 * @return true if the checkpoint could be removed&lt;br/&gt;
 	 */&lt;br/&gt;
-	private void removeShutdown(&lt;br/&gt;
-			final CompletedCheckpoint completedCheckpoint,&lt;br/&gt;
-			final JobStatus jobStatus) throws Exception {&lt;br/&gt;
-&lt;br/&gt;
-		if (completedCheckpoint == null) {-			return;-		}&lt;br/&gt;
-&lt;br/&gt;
-		ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt; removeAction = new ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt;() {&lt;br/&gt;
-			@Override&lt;br/&gt;
-			public void apply(@Nullable RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; value) throws FlinkException {&lt;br/&gt;
-				try {
-					completedCheckpoint.discardOnShutdown(jobStatus);
-				} catch (Exception e) {
-					throw new FlinkException(&quot;Could not discard the completed checkpoint on subsume.&quot;, e);
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-		};&lt;br/&gt;
-&lt;br/&gt;
-		checkpointsInZooKeeper.releaseAndTryRemove(&lt;br/&gt;
-			checkpointIdToPath(completedCheckpoint.getCheckpointID()),&lt;br/&gt;
-			removeAction);&lt;br/&gt;
+	private boolean tryRemove(long checkpointId) throws Exception {
+		return checkpointsInZooKeeper.releaseAndTryRemove(checkpointIdToPath(checkpointId));
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -381,7 +350,7 @@ public static long pathToCheckpointId(String path) {&lt;br/&gt;
 			String numberString;&lt;br/&gt;
 &lt;br/&gt;
 			// check if we have a leading slash&lt;br/&gt;
-			if (&apos;/&apos; == path.charAt(0) ) {&lt;br/&gt;
+			if (&apos;/&apos; == path.charAt(0)) {
 				numberString = path.substring(1);
 			} else {
 				numberString = path;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
index c96acbd3192..c31e64c0adc 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
@@ -572,30 +572,38 @@ private void registerJobManagerRunnerTerminationFuture(JobID jobId, CompletableF
 		}&lt;br/&gt;
 &lt;br/&gt;
 		return jobManagerRunnerTerminationFuture.thenRunAsync(&lt;br/&gt;
-			() -&amp;gt; {
-				jobManagerMetricGroup.removeJob(jobId);
+			() -&amp;gt; cleanUpJobData(jobId, cleanupHA),
+			getRpcService().getExecutor());
+	}&lt;br/&gt;
 &lt;br/&gt;
-				boolean cleanupHABlobs = false;&lt;br/&gt;
-				if (cleanupHA) {&lt;br/&gt;
-					try {&lt;br/&gt;
-						submittedJobGraphStore.removeJobGraph(jobId);&lt;br/&gt;
+	private void cleanUpJobData(JobID jobId, boolean cleanupHA) {
+		jobManagerMetricGroup.removeJob(jobId);
 
-						// only clean up the HA blobs if we could remove the job from HA storage
-						cleanupHABlobs = true;
-					} catch (Exception e) {&lt;br/&gt;
-						log.warn(&quot;Could not properly remove job {} from submitted job graph store.&quot;, jobId, e);&lt;br/&gt;
-					}&lt;br/&gt;
+		boolean cleanupHABlobs = false;&lt;br/&gt;
+		if (cleanupHA) {&lt;br/&gt;
+			try {&lt;br/&gt;
+				submittedJobGraphStore.removeJobGraph(jobId);&lt;br/&gt;
 &lt;br/&gt;
-					try {
-						runningJobsRegistry.clearJob(jobId);
-					} catch (IOException e) {&lt;br/&gt;
-						log.warn(&quot;Could not properly remove job {} from the running jobs registry.&quot;, jobId, e);&lt;br/&gt;
-					}&lt;br/&gt;
-				}&lt;br/&gt;
+				// only clean up the HA blobs if we could remove the job from HA storage&lt;br/&gt;
+				cleanupHABlobs = true;&lt;br/&gt;
+			} catch (Exception e) {&lt;br/&gt;
+				log.warn(&quot;Could not properly remove job {} from submitted job graph store.&quot;, jobId, e);&lt;br/&gt;
+			}&lt;br/&gt;
 &lt;br/&gt;
-				blobServer.cleanupJob(jobId, cleanupHABlobs);&lt;br/&gt;
-			},&lt;br/&gt;
-			getRpcService().getExecutor());&lt;br/&gt;
+			try {
+				runningJobsRegistry.clearJob(jobId);
+			} catch (IOException e) {&lt;br/&gt;
+				log.warn(&quot;Could not properly remove job {} from the running jobs registry.&quot;, jobId, e);&lt;br/&gt;
+			}&lt;br/&gt;
+		} else {&lt;br/&gt;
+			try {
+				submittedJobGraphStore.releaseJobGraph(jobId);
+			} catch (Exception e) {&lt;br/&gt;
+				log.warn(&quot;Could not properly release job {} from submitted job graph store.&quot;, jobId, e);&lt;br/&gt;
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		blobServer.cleanupJob(jobId, cleanupHABlobs);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -806,8 +814,7 @@ public void grantLeadership(final UUID newLeaderSessionID) {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	private CompletableFuture&amp;lt;Void&amp;gt; waitForTerminatingJobManager(JobID jobId, JobGraph jobGraph, ConsumerWithException&amp;lt;JobGraph, ?&amp;gt; action) {&lt;br/&gt;
-		final CompletableFuture&amp;lt;Void&amp;gt; jobManagerTerminationFuture = jobManagerTerminationFutures&lt;br/&gt;
-			.getOrDefault(jobId, CompletableFuture.completedFuture(null))&lt;br/&gt;
+		final CompletableFuture&amp;lt;Void&amp;gt; jobManagerTerminationFuture = getJobTerminationFuture(jobId)&lt;br/&gt;
 			.exceptionally((Throwable throwable) -&amp;gt; {&lt;br/&gt;
 				throw new CompletionException(&lt;br/&gt;
 					new DispatcherException(&lt;br/&gt;
@@ -822,6 +829,14 @@ public void grantLeadership(final UUID newLeaderSessionID) {
 			getMainThreadExecutor());
 	}&lt;br/&gt;
 &lt;br/&gt;
+	protected CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;br/&gt;
+		if (jobManagerRunners.containsKey(jobId)) {
+			return FutureUtils.completedExceptionally(new DispatcherException(String.format(&quot;Job with job id %s is still running.&quot;, jobId)));
+		} else {
+			return jobManagerTerminationFutures.getOrDefault(jobId, CompletableFuture.completedFuture(null));
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	private void setNewFencingToken(@Nullable DispatcherId dispatcherId) {&lt;br/&gt;
 		// clear the state if we&apos;ve been the leader before&lt;br/&gt;
 		if (getFencingToken() != null) {&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/SingleJobSubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/SingleJobSubmittedJobGraphStore.java&lt;br/&gt;
index 26d3abc2f1f..fe7f5f14cc8 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/SingleJobSubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/SingleJobSubmittedJobGraphStore.java&lt;br/&gt;
@@ -66,12 +66,17 @@ public void putJobGraph(SubmittedJobGraph jobGraph) throws Exception {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public void removeJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+	public void removeJobGraph(JobID jobId) {
 		// ignore
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) {
+		// ignore
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public Collection&amp;lt;JobID&amp;gt; getJobIds() {
 		return Collections.singleton(jobGraph.getJobID());
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java&lt;br/&gt;
index 3882479ce95..ea96d7d43d2 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java&lt;br/&gt;
@@ -179,7 +179,7 @@ public CheckpointRecoveryFactory getCheckpointRecoveryFactory() {&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
 	public SubmittedJobGraphStore getSubmittedJobGraphStore() throws Exception {
-		return ZooKeeperUtils.createSubmittedJobGraphs(client, configuration, executor);
+		return ZooKeeperUtils.createSubmittedJobGraphs(client, configuration);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java&lt;br/&gt;
index d1ca1a38853..f28621f0d69 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java&lt;br/&gt;
@@ -43,22 +43,27 @@ public void stop() {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public void putJobGraph(SubmittedJobGraph jobGraph) throws Exception {&lt;br/&gt;
+	public void putJobGraph(SubmittedJobGraph jobGraph) {
 		// Nothing to do
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public void removeJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+	public void removeJobGraph(JobID jobId) { 		// Nothing to do 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) {
+		// nothing to do
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public Collection&amp;lt;JobID&amp;gt; getJobIds() {
 		return Collections.emptyList();
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public SubmittedJobGraph recoverJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+	public SubmittedJobGraph recoverJobGraph(JobID jobId) {
 		return null;
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java&lt;br/&gt;
index 7e624ec6e1d..b40a4a2b95f 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java&lt;br/&gt;
@@ -19,6 +19,7 @@&lt;br/&gt;
 package org.apache.flink.runtime.jobmanager;&lt;br/&gt;
 &lt;br/&gt;
 import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
 &lt;br/&gt;
 import javax.annotation.Nullable;&lt;br/&gt;
 &lt;br/&gt;
@@ -58,6 +59,17 @@&lt;br/&gt;
 	 */&lt;br/&gt;
 	void removeJobGraph(JobID jobId) throws Exception;&lt;br/&gt;
 &lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Releases the locks on the specified {@link JobGraph}.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * Releasing the locks allows that another instance can delete the job from&lt;br/&gt;
+	 * the {@link SubmittedJobGraphStore}.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param jobId specifying the job to release the locks for&lt;br/&gt;
+	 * @throws Exception if the locks cannot be released&lt;br/&gt;
+	 */&lt;br/&gt;
+	void releaseJobGraph(JobID jobId) throws Exception;&lt;br/&gt;
+&lt;br/&gt;
 	/**&lt;br/&gt;
 	 * Get all job ids of submitted job graphs to the submitted job graph store.&lt;br/&gt;
 	 *&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java&lt;br/&gt;
index 7ba5d481177..2b935af229a 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java&lt;br/&gt;
@@ -41,7 +41,6 @@&lt;br/&gt;
 import java.util.HashSet;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Set;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
@@ -69,13 +68,13 @@&lt;br/&gt;
 	/** Lock to synchronize with the {@link SubmittedJobGraphListener}. */&lt;br/&gt;
 	private final Object cacheLock = new Object();&lt;br/&gt;
 &lt;br/&gt;
-	/** Client (not a namespace facade) */&lt;br/&gt;
+	/** Client (not a namespace facade). */&lt;br/&gt;
 	private final CuratorFramework client;&lt;br/&gt;
 &lt;br/&gt;
 	/** The set of IDs of all added job graphs. */&lt;br/&gt;
 	private final Set&amp;lt;JobID&amp;gt; addedJobGraphs = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
 &lt;br/&gt;
-	/** Completed checkpoints in ZooKeeper */&lt;br/&gt;
+	/** Completed checkpoints in ZooKeeper. */&lt;br/&gt;
 	private final ZooKeeperStateHandleStore&amp;lt;SubmittedJobGraph&amp;gt; jobGraphsInZooKeeper;&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -94,19 +93,17 @@&lt;br/&gt;
 	private boolean isRunning;&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
-	 * Submitted job graph store backed by ZooKeeper&lt;br/&gt;
+	 * Submitted job graph store backed by ZooKeeper.&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param client ZooKeeper client&lt;br/&gt;
 	 * @param currentJobsPath ZooKeeper path for current job graphs&lt;br/&gt;
 	 * @param stateStorage State storage used to persist the submitted jobs&lt;br/&gt;
-	 * @param executor to give to the ZooKeeperStateHandleStore to run ZooKeeper callbacks&lt;br/&gt;
 	 * @throws Exception&lt;br/&gt;
 	 */&lt;br/&gt;
 	public ZooKeeperSubmittedJobGraphStore(&lt;br/&gt;
 			CuratorFramework client,&lt;br/&gt;
 			String currentJobsPath,&lt;br/&gt;
-			RetrievableStateStorageHelper&amp;lt;SubmittedJobGraph&amp;gt; stateStorage,&lt;br/&gt;
-			Executor executor) throws Exception {&lt;br/&gt;
+			RetrievableStateStorageHelper&amp;lt;SubmittedJobGraph&amp;gt; stateStorage) throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 		checkNotNull(currentJobsPath, &quot;Current jobs path&quot;);&lt;br/&gt;
 		checkNotNull(stateStorage, &quot;State storage&quot;);&lt;br/&gt;
@@ -123,7 +120,7 @@ public ZooKeeperSubmittedJobGraphStore(&lt;br/&gt;
 		CuratorFramework facade = client.usingNamespace(client.getNamespace() + currentJobsPath);&lt;br/&gt;
 &lt;br/&gt;
 		this.zooKeeperFullBasePath = client.getNamespace() + currentJobsPath;&lt;br/&gt;
-		this.jobGraphsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(facade, stateStorage, executor);&lt;br/&gt;
+		this.jobGraphsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(facade, stateStorage);&lt;br/&gt;
 &lt;br/&gt;
 		this.pathCache = new PathChildrenCache(facade, &quot;/&quot;, false);&lt;br/&gt;
 		pathCache.getListenable().addListener(new SubmittedJobGraphsPathCacheListener());&lt;br/&gt;
@@ -276,6 +273,24 @@ public void removeJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
 		LOG.info(&quot;Removed job graph {} from ZooKeeper.&quot;, jobId);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+		checkNotNull(jobId, &quot;Job ID&quot;);&lt;br/&gt;
+		final String path = getPathForJob(jobId);&lt;br/&gt;
+&lt;br/&gt;
+		LOG.debug(&quot;Releasing locks of job graph {} from {}{}.&quot;, jobId, zooKeeperFullBasePath, path);&lt;br/&gt;
+&lt;br/&gt;
+		synchronized (cacheLock) {&lt;br/&gt;
+			if (addedJobGraphs.contains(jobId)) {
+				jobGraphsInZooKeeper.release(path);
+
+				addedJobGraphs.remove(jobId);
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		LOG.info(&quot;Released locks of job graph {} from ZooKeeper.&quot;, jobId);&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
 		Collection&amp;lt;String&amp;gt; paths;&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java&lt;br/&gt;
index 43c930e6fea..cc1ec7044c4 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java&lt;br/&gt;
@@ -54,6 +54,9 @@&lt;br/&gt;
 &lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * Class containing helper functions to interact with ZooKeeper.&lt;br/&gt;
+ */&lt;br/&gt;
 public class ZooKeeperUtils {&lt;br/&gt;
 &lt;br/&gt;
 	private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperUtils.class);&lt;br/&gt;
@@ -227,14 +230,12 @@ public static ZooKeeperLeaderElectionService createLeaderElectionService(&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param client        The {@link CuratorFramework} ZooKeeper client to use&lt;br/&gt;
 	 * @param configuration {@link Configuration} object&lt;br/&gt;
-	 * @param executor to run ZooKeeper callbacks&lt;br/&gt;
 	 * @return {@link ZooKeeperSubmittedJobGraphStore} instance&lt;br/&gt;
 	 * @throws Exception if the submitted job graph store cannot be created&lt;br/&gt;
 	 */&lt;br/&gt;
 	public static ZooKeeperSubmittedJobGraphStore createSubmittedJobGraphs(&lt;br/&gt;
 			CuratorFramework client,&lt;br/&gt;
-			Configuration configuration,&lt;br/&gt;
-			Executor executor) throws Exception {&lt;br/&gt;
+			Configuration configuration) throws Exception {
 
 		checkNotNull(configuration, &quot;Configuration&quot;);
 
@@ -244,7 +245,9 @@ public static ZooKeeperSubmittedJobGraphStore createSubmittedJobGraphs(
 		String zooKeeperSubmittedJobsPath = configuration.getString(HighAvailabilityOptions.HA_ZOOKEEPER_JOBGRAPHS_PATH);
 
 		return new ZooKeeperSubmittedJobGraphStore(
-				client, zooKeeperSubmittedJobsPath, stateStorage, executor);
+			client,
+			zooKeeperSubmittedJobsPath,
+			stateStorage);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -344,6 +347,9 @@ public static String generateZookeeperPath(String root, String namespace) {
 		return root + namespace;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Secure {@link ACLProvider} implementation.&lt;br/&gt;
+	 */&lt;br/&gt;
 	public static class SecureAclProvider implements ACLProvider {&lt;br/&gt;
 		@Override&lt;br/&gt;
 		public List&amp;lt;ACL&amp;gt; getDefaultAcl() {&lt;br/&gt;
@@ -356,6 +362,9 @@ public static String generateZookeeperPath(String root, String namespace) {&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	/**&lt;br/&gt;
+	 * ZooKeeper client ACL mode enum.&lt;br/&gt;
+	 */&lt;br/&gt;
 	public enum ZkClientACLMode {&lt;br/&gt;
 		CREATOR,&lt;br/&gt;
 		OPEN;&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
index 87a433adace..8c3d31fc51b 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
@@ -18,17 +18,13 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.flink.runtime.zookeeper;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
-import org.apache.curator.framework.api.BackgroundCallback;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEvent;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEventType;&lt;br/&gt;
-import org.apache.curator.utils.ZKPaths;&lt;br/&gt;
 import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
 import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
 import org.apache.flink.util.ExceptionUtils;&lt;br/&gt;
-import org.apache.flink.util.FlinkException;&lt;br/&gt;
 import org.apache.flink.util.InstantiationUtil;&lt;br/&gt;
-import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.apache.curator.utils.ZKPaths;&lt;br/&gt;
 import org.apache.zookeeper.CreateMode;&lt;br/&gt;
 import org.apache.zookeeper.KeeperException;&lt;br/&gt;
 import org.apache.zookeeper.data.Stat;&lt;br/&gt;
@@ -36,6 +32,7 @@&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
 &lt;br/&gt;
 import javax.annotation.Nullable;&lt;br/&gt;
+&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.io.Serializable;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
@@ -44,7 +41,6 @@&lt;br/&gt;
 import java.util.ConcurrentModificationException;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.UUID;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
 &lt;br/&gt;
@@ -68,13 +64,13 @@&lt;br/&gt;
  * State handle in ZooKeeper =&amp;gt; State handle exists&lt;br/&gt;
  * &amp;lt;/pre&amp;gt;&lt;br/&gt;
  *&lt;br/&gt;
- * But not:&lt;br/&gt;
+ * &amp;lt;p&amp;gt;But not:&lt;br/&gt;
  *&lt;br/&gt;
  * &amp;lt;pre&amp;gt;&lt;br/&gt;
  * State handle exists =&amp;gt; State handle in ZooKeeper&lt;br/&gt;
  * &amp;lt;/pre&amp;gt;&lt;br/&gt;
  *&lt;br/&gt;
- * There can be lingering state handles when failures happen during operation. They&lt;br/&gt;
+ * &amp;lt;p&amp;gt;There can be lingering state handles when failures happen during operation. They&lt;br/&gt;
  * need to be cleaned up manually (see &amp;lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-2513&quot;&amp;gt;&lt;br/&gt;
  * &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-2513&quot; title=&quot;Extend state handle provider interface to list all state handles&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-2513&quot;&gt;&lt;del&gt;FLINK-2513&lt;/del&gt;&lt;/a&gt;&amp;lt;/a&amp;gt; about a possible way to overcome this).&lt;br/&gt;
  *&lt;br/&gt;
@@ -84,13 +80,11 @@&lt;br/&gt;
 &lt;br/&gt;
 	private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperStateHandleStore.class);&lt;br/&gt;
 &lt;br/&gt;
-	/** Curator ZooKeeper client */&lt;br/&gt;
+	/** Curator ZooKeeper client. */&lt;br/&gt;
 	private final CuratorFramework client;&lt;br/&gt;
 &lt;br/&gt;
 	private final RetrievableStateStorageHelper&amp;lt;T&amp;gt; storage;&lt;br/&gt;
 &lt;br/&gt;
-	private final Executor executor;&lt;br/&gt;
-&lt;br/&gt;
 	/** Lock node name of this ZooKeeperStateHandleStore. The name should be unique among all other state handle stores. */&lt;br/&gt;
 	private final String lockNode;&lt;br/&gt;
 &lt;br/&gt;
@@ -103,16 +97,13 @@&lt;br/&gt;
 	 *                            instance, e.g. &amp;lt;code&amp;gt;client.usingNamespace(&quot;/stateHandles&quot;)&amp;lt;/code&amp;gt;&lt;br/&gt;
 	 * @param storage to persist the actual state and whose returned state handle is then written&lt;br/&gt;
 	 *                to ZooKeeper&lt;br/&gt;
-	 * @param executor to run the ZooKeeper callbacks&lt;br/&gt;
 	 */&lt;br/&gt;
 	public ZooKeeperStateHandleStore(&lt;br/&gt;
 		CuratorFramework client,&lt;br/&gt;
-		RetrievableStateStorageHelper&amp;lt;T&amp;gt; storage,&lt;br/&gt;
-		Executor executor) {&lt;br/&gt;
+		RetrievableStateStorageHelper&amp;lt;T&amp;gt; storage) {&lt;br/&gt;
 &lt;br/&gt;
 		this.client = checkNotNull(client, &quot;Curator client&quot;);&lt;br/&gt;
 		this.storage = checkNotNull(storage, &quot;State storage&quot;);&lt;br/&gt;
-		this.executor = checkNotNull(executor);&lt;br/&gt;
 &lt;br/&gt;
 		// Generate a unique lock node name&lt;br/&gt;
 		lockNode = UUID.randomUUID().toString();&lt;br/&gt;
@@ -262,7 +253,7 @@ public int exists(String pathInZooKeeper) throws Exception {&lt;br/&gt;
 	public Collection&amp;lt;String&amp;gt; getAllPaths() throws Exception {&lt;br/&gt;
 		final String path = &quot;/&quot;;&lt;br/&gt;
 &lt;br/&gt;
-		while(true) {&lt;br/&gt;
+		while (true) {&lt;br/&gt;
 			Stat stat = client.checkExists().forPath(path);&lt;br/&gt;
 &lt;br/&gt;
 			if (stat == null) {&lt;br/&gt;
@@ -393,33 +384,14 @@ public int exists(String pathInZooKeeper) throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
 	 * Releases the lock for the given state node and tries to remove the state node if it is no longer locked.&lt;br/&gt;
-	 * The deletion of the state node is executed asynchronously.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Important&amp;lt;/strong&amp;gt;: This also discards the stored state handle after the given action&lt;br/&gt;
-	 * has been executed.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param pathInZooKeeper Path of state handle to remove (expected to start with a &apos;/&apos;)&lt;br/&gt;
-	 * @throws Exception If the ZooKeeper operation fails&lt;br/&gt;
-	 */&lt;br/&gt;
-	public void releaseAndTryRemove(String pathInZooKeeper) throws Exception {
-		releaseAndTryRemove(pathInZooKeeper, null);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Releases the lock for the given state node and tries to remove the state node if it is no longer locked.&lt;br/&gt;
-	 * The deletion of the state node is executed asynchronously. After the state node has been deleted, the given&lt;br/&gt;
-	 * callback is called with the {@link RetrievableStateHandle} of the deleted state node.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Important&amp;lt;/strong&amp;gt;: This also discards the stored state handle after the given action&lt;br/&gt;
-	 * has been executed.&lt;br/&gt;
+	 * It returns the {@link RetrievableStateHandle} stored under the given state node if any.&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param pathInZooKeeper Path of state handle to remove&lt;br/&gt;
-	 * @param callback The callback to execute after a successful deletion. Null if no action needs to be executed.&lt;br/&gt;
-	 * @throws Exception If the ZooKeeper operation fails&lt;br/&gt;
+	 * @return True if the state handle could be released&lt;br/&gt;
+	 * @throws Exception If the ZooKeeper operation or discarding the state handle fails&lt;br/&gt;
 	 */&lt;br/&gt;
-	public void releaseAndTryRemove(&lt;br/&gt;
-			String pathInZooKeeper,&lt;br/&gt;
-			@Nullable final RemoveCallback&amp;lt;T&amp;gt; callback) throws Exception {&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public boolean releaseAndTryRemove(String pathInZooKeeper) throws Exception {&lt;br/&gt;
 		checkNotNull(pathInZooKeeper, &quot;Path in ZooKeeper&quot;);&lt;br/&gt;
 &lt;br/&gt;
 		final String path = normalizePath(pathInZooKeeper);&lt;br/&gt;
@@ -429,14 +401,23 @@ public void releaseAndTryRemove(&lt;br/&gt;
 		try {
 			stateHandle = get(path, false);
 		} catch (Exception e) {&lt;br/&gt;
-			LOG.warn(&quot;Could not retrieve the state handle from node &quot; + path + &apos;.&apos;, e);&lt;br/&gt;
+			LOG.warn(&quot;Could not retrieve the state handle from node {}.&quot;, path, e);&lt;br/&gt;
 		}&lt;br/&gt;
 &lt;br/&gt;
 		release(pathInZooKeeper);&lt;br/&gt;
 &lt;br/&gt;
-		final BackgroundCallback backgroundCallback = new RemoveBackgroundCallback&amp;lt;&amp;gt;(stateHandle, callback, path);&lt;br/&gt;
+		try {
+			client.delete().forPath(path);
+		} catch (KeeperException.NotEmptyException ignored) {&lt;br/&gt;
+			LOG.debug(&quot;Could not delete znode {} because it is still locked.&quot;, path);&lt;br/&gt;
+			return false;&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		if (stateHandle != null) {
+			stateHandle.discardState();
+		}&lt;br/&gt;
 &lt;br/&gt;
-		client.delete().inBackground(backgroundCallback, executor).forPath(path);&lt;br/&gt;
+		return true;&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -583,7 +564,7 @@ protected String getLockPath(String rootPath) {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
-	 * Makes sure that every path starts with a &quot;/&quot;&lt;br/&gt;
+	 * Makes sure that every path starts with a &quot;/&quot;.&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param path Path to normalize&lt;br/&gt;
 	 * @return Normalized path such that it starts with a &quot;/&quot;&lt;br/&gt;
@@ -595,103 +576,4 @@ private static String normalizePath(String path) {
 			return &apos;/&apos; + path;
 		}&lt;br/&gt;
 	}&lt;br/&gt;
-&lt;br/&gt;
-	// ---------------------------------------------------------------------------------------------------------&lt;br/&gt;
-	// Utility classes&lt;br/&gt;
-	// ---------------------------------------------------------------------------------------------------------&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Callback which is executed when removing a node from ZooKeeper. The callback will call the given&lt;br/&gt;
-	 * {@link RemoveCallback} if it is not null. Afterwards, it will discard the given {@link RetrievableStateHandle}&lt;br/&gt;
-	 * if it is not null.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param &amp;lt;T&amp;gt; Type of the value stored in the RetrievableStateHandle&lt;br/&gt;
-	 */&lt;br/&gt;
-	private static final class RemoveBackgroundCallback&amp;lt;T extends Serializable&amp;gt; implements BackgroundCallback {&lt;br/&gt;
-		@Nullable&lt;br/&gt;
-		private final RetrievableStateHandle&amp;lt;T&amp;gt; stateHandle;&lt;br/&gt;
-&lt;br/&gt;
-		@Nullable&lt;br/&gt;
-		private final RemoveCallback&amp;lt;T&amp;gt; callback;&lt;br/&gt;
-&lt;br/&gt;
-		private final String pathInZooKeeper;&lt;br/&gt;
-&lt;br/&gt;
-		private RemoveBackgroundCallback(&lt;br/&gt;
-			@Nullable RetrievableStateHandle&amp;lt;T&amp;gt; stateHandle,&lt;br/&gt;
-			@Nullable RemoveCallback&amp;lt;T&amp;gt; callback,&lt;br/&gt;
-			String pathInZooKeeper) {
-
-			this.stateHandle = stateHandle;
-			this.callback = callback;
-			this.pathInZooKeeper = Preconditions.checkNotNull(pathInZooKeeper);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {&lt;br/&gt;
-			try {&lt;br/&gt;
-				if (event.getType() == CuratorEventType.DELETE) {&lt;br/&gt;
-					final KeeperException.Code resultCode = KeeperException.Code.get(event.getResultCode());&lt;br/&gt;
-&lt;br/&gt;
-					if (resultCode == KeeperException.Code.OK) {&lt;br/&gt;
-						Exception exception = null;&lt;br/&gt;
-&lt;br/&gt;
-						if (null != callback) {&lt;br/&gt;
-							try {
-								callback.apply(stateHandle);
-							} catch (Throwable e) {
-								exception = new Exception(&quot;Could not execute delete action for node &quot; +
-									pathInZooKeeper + &apos;.&apos;, e);
-							}&lt;br/&gt;
-						}&lt;br/&gt;
-&lt;br/&gt;
-						if (stateHandle != null) {&lt;br/&gt;
-							try {
-								// Discard the state handle
-								stateHandle.discardState();
-							} catch (Throwable e) {&lt;br/&gt;
-								Exception newException = new Exception(&quot;Could not discard state handle of node &quot; +&lt;br/&gt;
-									pathInZooKeeper + &apos;.&apos;, e);&lt;br/&gt;
-&lt;br/&gt;
-								if (exception == null) {
-									exception = newException;
-								} else {
-									exception.addSuppressed(newException);
-								}&lt;br/&gt;
-							}&lt;br/&gt;
-						}&lt;br/&gt;
-&lt;br/&gt;
-						if (exception != null) {
-							throw exception;
-						}&lt;br/&gt;
-					} else if (resultCode == KeeperException.Code.NOTEMPTY) {
-						// Could not delete the node because it still contains children/locks
-						LOG.debug(&quot;Could not delete node &quot; + pathInZooKeeper + &quot; because it is still locked.&quot;);
-					} else {
-						throw new IllegalStateException(&quot;Unexpected result code &quot; +
-							resultCode.name() + &quot; in &apos;&quot; + event + &quot;&apos; callback.&quot;);
-					}&lt;br/&gt;
-				} else {
-					throw new IllegalStateException(&quot;Unexpected event type &quot; +
-						event.getType() + &quot; in &apos;&quot; + event + &quot;&apos; callback.&quot;);
-				}&lt;br/&gt;
-			} catch (Exception e) {
-				LOG.warn(&quot;Failed to run callback for delete operation on node &quot; + pathInZooKeeper + &apos;.&apos;, e);
-			}&lt;br/&gt;
-&lt;br/&gt;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Callback interface for remove calls&lt;br/&gt;
-	 */&lt;br/&gt;
-	public interface RemoveCallback&amp;lt;T extends Serializable&amp;gt; {&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * Callback method. The parameter can be null if the {@link RetrievableStateHandle} could not be retrieved&lt;br/&gt;
-		 * from ZooKeeper.&lt;br/&gt;
-		 *&lt;br/&gt;
-		 * @param value RetrievableStateHandle retrieved from ZooKeeper, null if it was not retrievable&lt;br/&gt;
-		 * @throws FlinkException If the callback failed&lt;br/&gt;
-		 */&lt;br/&gt;
-		void apply(@Nullable RetrievableStateHandle&amp;lt;T&amp;gt; value) throws FlinkException;&lt;br/&gt;
-	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java&lt;br/&gt;
index d3b7dc5b379..3e294e0dbdd 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java&lt;br/&gt;
@@ -18,15 +18,15 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.flink.runtime.zookeeper;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
-import org.apache.curator.framework.recipes.shared.SharedCount;&lt;br/&gt;
-import org.apache.curator.framework.recipes.shared.SharedValue;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
 import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;br/&gt;
 &lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.apache.curator.framework.recipes.shared.SharedCount;&lt;br/&gt;
+import org.apache.curator.framework.recipes.shared.SharedValue;&lt;br/&gt;
+&lt;br/&gt;
 import java.io.Serializable;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * Creates ZooKeeper utility classes without exposing the {@link CuratorFramework} dependency. The&lt;br/&gt;
@@ -71,7 +71,6 @@ public void close(boolean cleanup) throws Exception {&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param zkStateHandleStorePath specifying the path in ZooKeeper to store the state handles to&lt;br/&gt;
 	 * @param stateStorageHelper storing the actual state data&lt;br/&gt;
-	 * @param executor to run asynchronous callbacks of the state handle store&lt;br/&gt;
 	 * @param &amp;lt;T&amp;gt; Type of the state to be stored&lt;br/&gt;
 	 * @return a ZooKeeperStateHandleStore instance&lt;br/&gt;
 	 * @throws Exception if ZooKeeper could not create the provided state handle store path in&lt;br/&gt;
@@ -79,8 +78,7 @@ public void close(boolean cleanup) throws Exception {&lt;br/&gt;
 	 */&lt;br/&gt;
 	public &amp;lt;T extends Serializable&amp;gt; ZooKeeperStateHandleStore&amp;lt;T&amp;gt; createZooKeeperStateHandleStore(&lt;br/&gt;
 			String zkStateHandleStorePath,&lt;br/&gt;
-			RetrievableStateStorageHelper&amp;lt;T&amp;gt; stateStorageHelper,&lt;br/&gt;
-			Executor executor) throws Exception {&lt;br/&gt;
+			RetrievableStateStorageHelper&amp;lt;T&amp;gt; stateStorageHelper) throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 		facade.newNamespaceAwareEnsurePath(zkStateHandleStorePath).ensure(facade.getZookeeperClient());&lt;br/&gt;
 		CuratorFramework stateHandleStoreFacade = facade.usingNamespace(&lt;br/&gt;
@@ -88,7 +86,7 @@ public void close(boolean cleanup) throws Exception {
 				facade.getNamespace(),
 				zkStateHandleStorePath));
 
-		return new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(stateHandleStoreFacade, stateStorageHelper, executor);
+		return new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(stateHandleStoreFacade, stateStorageHelper);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
diff --git a/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala b/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala&lt;br/&gt;
index 4f0709ed416..c588ecc7053 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala&lt;br/&gt;
+++ b/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala&lt;br/&gt;
@@ -1728,21 +1728,22 @@ class JobManager(&lt;br/&gt;
     val futureOption = currentJobs.remove(jobID) match {&lt;br/&gt;
       case Some((eg, _)) =&amp;gt;&lt;br/&gt;
         val cleanUpFuture: Future&lt;span class=&quot;error&quot;&gt;&amp;#91;Unit&amp;#93;&lt;/span&gt; = Future {&lt;br/&gt;
-          val cleanupHABlobs = if (removeJobFromStateBackend) {&lt;br/&gt;
-            try {&lt;br/&gt;
+          val cleanupHABlobs = try {&lt;br/&gt;
+            if (removeJobFromStateBackend) {
               // ...otherwise, we can have lingering resources when there is a  concurrent shutdown
               // and the ZooKeeper client is closed. Not removing the job immediately allow the
               // shutdown to release all resources.
               submittedJobGraphs.removeJobGraph(jobID)
               true
-            } catch {&lt;br/&gt;
-              case t: Throwable =&amp;gt; {
-                log.warn(s&quot;Could not remove submitted job graph $jobID.&quot;, t)
-                false
-              }&lt;br/&gt;
+            } else {
+              submittedJobGraphs.releaseJobGraph(jobID)
+              false
+            }&lt;br/&gt;
+          } catch {&lt;br/&gt;
+            case t: Throwable =&amp;gt; {
+              log.warn(s&quot;Could not remove submitted job graph $jobID.&quot;, t)
+              false
             }&lt;br/&gt;
-          } else {
-            false
           }&lt;br/&gt;
 &lt;br/&gt;
           blobServer.cleanupJob(jobID, cleanupHABlobs)&lt;br/&gt;
@@ -1777,19 +1778,23 @@ class JobManager(&lt;br/&gt;
     */&lt;br/&gt;
   private def cancelAndClearEverything(cause: Throwable)&lt;br/&gt;
     : Seq[Future&lt;span class=&quot;error&quot;&gt;&amp;#91;Unit&amp;#93;&lt;/span&gt;] = {&lt;br/&gt;
-    val futures = for ((jobID, (eg, jobInfo)) &amp;lt;- currentJobs) yield {&lt;br/&gt;
-      future {&lt;br/&gt;
-        eg.suspend(cause)&lt;br/&gt;
-        jobManagerMetricGroup.removeJob(eg.getJobID)&lt;br/&gt;
+&lt;br/&gt;
+    val futures = currentJobs.values.flatMap(&lt;br/&gt;
+      egJobInfo =&amp;gt; {
+        val executionGraph = egJobInfo._1
+        val jobInfo = egJobInfo._2
+
+        executionGraph.suspend(cause)
+
+        val jobId = executionGraph.getJobID
 
         jobInfo.notifyNonDetachedClients(
           decorateMessage(
             Failure(
-              new JobExecutionException(jobID, &quot;All jobs are cancelled and cleared.&quot;, cause))))
-      }(context.dispatcher)&lt;br/&gt;
-    }&lt;br/&gt;
+              new JobExecutionException(jobId, &quot;All jobs are cancelled and cleared.&quot;, cause))))&lt;br/&gt;
 &lt;br/&gt;
-    currentJobs.clear()&lt;br/&gt;
+        removeJob(jobId, false)&lt;br/&gt;
+      })&lt;br/&gt;
 &lt;br/&gt;
     futures.toSeq&lt;br/&gt;
   }&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java&lt;br/&gt;
index 81569649663..c4d89030dc3 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java&lt;br/&gt;
@@ -193,7 +193,7 @@ public void testDiscardAllCheckpoints() throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 	// ---------------------------------------------------------------------------------------------&lt;br/&gt;
 &lt;br/&gt;
-	protected TestCompletedCheckpoint createCheckpoint(&lt;br/&gt;
+	public static TestCompletedCheckpoint createCheckpoint(&lt;br/&gt;
 		int id,&lt;br/&gt;
 		SharedStateRegistry sharedStateRegistry) throws IOException {
 
@@ -226,7 +226,12 @@ protected void verifyCheckpointRegistered(Collection&amp;lt;OperatorState&amp;gt; operatorStat
 		}&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
-	protected void verifyCheckpointDiscarded(Collection&amp;lt;OperatorState&amp;gt; operatorStates) {&lt;br/&gt;
+	public static void verifyCheckpointDiscarded(TestCompletedCheckpoint completedCheckpoint) {
+		assertTrue(completedCheckpoint.isDiscarded());
+		verifyCheckpointDiscarded(completedCheckpoint.getOperatorStates().values());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	protected static void verifyCheckpointDiscarded(Collection&amp;lt;OperatorState&amp;gt; operatorStates) {&lt;br/&gt;
 		for (OperatorState operatorState : operatorStates) {&lt;br/&gt;
 			for (OperatorSubtaskState subtaskState : operatorState.getStates()) {&lt;br/&gt;
 				Assert.assertTrue(((TestOperatorSubtaskState)subtaskState).discarded);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..1f7d3691e50&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java&lt;br/&gt;
@@ -0,0 +1,261 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.checkpoint;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
+import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
+import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.apache.curator.framework.api.BackgroundCallback;&lt;br/&gt;
+import org.apache.curator.framework.api.CuratorEvent;&lt;br/&gt;
+import org.apache.curator.framework.api.CuratorEventType;&lt;br/&gt;
+import org.apache.curator.framework.api.ErrorListenerPathable;&lt;br/&gt;
+import org.apache.curator.utils.EnsurePath;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.runner.RunWith;&lt;br/&gt;
+import org.mockito.Mockito;&lt;br/&gt;
+import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
+import org.mockito.stubbing.Answer;&lt;br/&gt;
+import org.powermock.core.classloader.annotations.PrepareForTest;&lt;br/&gt;
+import org.powermock.modules.junit4.PowerMockRunner;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.ArrayList;&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.Collections;&lt;br/&gt;
+import java.util.HashMap;&lt;br/&gt;
+import java.util.HashSet;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+import java.util.concurrent.Executor;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertEquals;&lt;br/&gt;
+import static org.junit.Assert.assertFalse;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+import static org.mockito.Matchers.any;&lt;br/&gt;
+import static org.mockito.Matchers.anyString;&lt;br/&gt;
+import static org.mockito.Mockito.doReturn;&lt;br/&gt;
+import static org.mockito.Mockito.mock;&lt;br/&gt;
+import static org.mockito.Mockito.never;&lt;br/&gt;
+import static org.mockito.Mockito.spy;&lt;br/&gt;
+import static org.mockito.Mockito.verify;&lt;br/&gt;
+import static org.mockito.Mockito.when;&lt;br/&gt;
+import static org.powermock.api.mockito.PowerMockito.doAnswer;&lt;br/&gt;
+import static org.powermock.api.mockito.PowerMockito.doThrow;&lt;br/&gt;
+import static org.powermock.api.mockito.PowerMockito.whenNew;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Mockito based tests for the {@link ZooKeeperStateHandleStore}.&lt;br/&gt;
+ */&lt;br/&gt;
+@RunWith(PowerMockRunner.class)&lt;br/&gt;
+@PrepareForTest(ZooKeeperCompletedCheckpointStore.class)&lt;br/&gt;
+public class ZooKeeperCompletedCheckpointStoreMockitoTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the completed checkpoint store can retrieve all checkpoints stored in ZooKeeper&lt;br/&gt;
+	 * and ignores those which cannot be retrieved via their state handles.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * &amp;lt;p&amp;gt;We have a timeout in case the ZooKeeper store get&apos;s into a deadlock/livelock situation.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test(timeout = 50000)&lt;br/&gt;
+	public void testCheckpointRecovery() throws Exception {&lt;br/&gt;
+		final JobID jobID = new JobID();&lt;br/&gt;
+		final long checkpoint1Id = 1L;&lt;br/&gt;
+		final long checkpoint2Id = 2;&lt;br/&gt;
+		final List&amp;lt;Tuple2&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;, String&amp;gt;&amp;gt; checkpointsInZooKeeper = new ArrayList&amp;lt;&amp;gt;(4);&lt;br/&gt;
+&lt;br/&gt;
+		final Collection&amp;lt;Long&amp;gt; expectedCheckpointIds = new HashSet&amp;lt;&amp;gt;(2);&lt;br/&gt;
+		expectedCheckpointIds.add(1L);&lt;br/&gt;
+		expectedCheckpointIds.add(2L);&lt;br/&gt;
+&lt;br/&gt;
+		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; failingRetrievableStateHandle = mock(RetrievableStateHandle.class);&lt;br/&gt;
+		when(failingRetrievableStateHandle.retrieveState()).thenThrow(new IOException(&quot;Test exception&quot;));&lt;br/&gt;
+&lt;br/&gt;
+		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle1 = mock(RetrievableStateHandle.class);&lt;br/&gt;
+		when(retrievableStateHandle1.retrieveState()).then(&lt;br/&gt;
+			(invocation) -&amp;gt; new CompletedCheckpoint(&lt;br/&gt;
+				jobID,&lt;br/&gt;
+				checkpoint1Id,&lt;br/&gt;
+				1L,&lt;br/&gt;
+				1L,&lt;br/&gt;
+				new HashMap&amp;lt;&amp;gt;(),&lt;br/&gt;
+				null,&lt;br/&gt;
+				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),&lt;br/&gt;
+				new TestCompletedCheckpointStorageLocation()));&lt;br/&gt;
+&lt;br/&gt;
+		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle2 = mock(RetrievableStateHandle.class);&lt;br/&gt;
+		when(retrievableStateHandle2.retrieveState()).then(&lt;br/&gt;
+			(invocation -&amp;gt; new CompletedCheckpoint(&lt;br/&gt;
+				jobID,&lt;br/&gt;
+				checkpoint2Id,&lt;br/&gt;
+				2L,&lt;br/&gt;
+				2L,&lt;br/&gt;
+				new HashMap&amp;lt;&amp;gt;(),&lt;br/&gt;
+				null,&lt;br/&gt;
+				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),&lt;br/&gt;
+				new TestCompletedCheckpointStorageLocation())));&lt;br/&gt;
+&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle1, &quot;/foobar1&quot;));&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing1&quot;));&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle2, &quot;/foobar2&quot;));&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing2&quot;));&lt;br/&gt;
+&lt;br/&gt;
+		final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zooKeeperStateHandleStoreMock = spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock));&lt;br/&gt;
+		whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zooKeeperStateHandleStoreMock);&lt;br/&gt;
+		doReturn(checkpointsInZooKeeper).when(zooKeeperStateHandleStoreMock).getAllSortedByNameAndLock();&lt;br/&gt;
+&lt;br/&gt;
+		final int numCheckpointsToRetain = 1;&lt;br/&gt;
+&lt;br/&gt;
+		// Mocking for the delete operation on the CuratorFramework client&lt;br/&gt;
+		// It assures that the callback is executed synchronously&lt;br/&gt;
+&lt;br/&gt;
+		final EnsurePath ensurePathMock = mock(EnsurePath.class);&lt;br/&gt;
+		final CuratorEvent curatorEventMock = mock(CuratorEvent.class);&lt;br/&gt;
+		when(curatorEventMock.getType()).thenReturn(CuratorEventType.DELETE);&lt;br/&gt;
+		when(curatorEventMock.getResultCode()).thenReturn(0);&lt;br/&gt;
+		when(client.newNamespaceAwareEnsurePath(anyString())).thenReturn(ensurePathMock);&lt;br/&gt;
+&lt;br/&gt;
+		when(&lt;br/&gt;
+			client&lt;br/&gt;
+				.delete()&lt;br/&gt;
+				.inBackground(any(BackgroundCallback.class), any(Executor.class))&lt;br/&gt;
+		).thenAnswer(new Answer&amp;lt;ErrorListenerPathable&amp;lt;Void&amp;gt;&amp;gt;() {&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public ErrorListenerPathable&amp;lt;Void&amp;gt; answer(InvocationOnMock invocation) throws Throwable {&lt;br/&gt;
+				final BackgroundCallback callback = (BackgroundCallback) invocation.getArguments()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+&lt;br/&gt;
+				ErrorListenerPathable&amp;lt;Void&amp;gt; result = mock(ErrorListenerPathable.class);&lt;br/&gt;
+&lt;br/&gt;
+				when(result.forPath(anyString())).thenAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
+					@Override&lt;br/&gt;
+					public Void answer(InvocationOnMock invocation) throws Throwable {
+
+						callback.processResult(client, curatorEventMock);
+
+						return null;
+					}&lt;br/&gt;
+				});&lt;br/&gt;
+&lt;br/&gt;
+				return result;&lt;br/&gt;
+			}&lt;br/&gt;
+		});&lt;br/&gt;
+&lt;br/&gt;
+		final String checkpointsPath = &quot;foobar&quot;;&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateStorage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
+			numCheckpointsToRetain,&lt;br/&gt;
+			client,&lt;br/&gt;
+			checkpointsPath,&lt;br/&gt;
+			stateStorage,&lt;br/&gt;
+			Executors.directExecutor());&lt;br/&gt;
+&lt;br/&gt;
+		zooKeeperCompletedCheckpointStore.recover();&lt;br/&gt;
+&lt;br/&gt;
+		CompletedCheckpoint latestCompletedCheckpoint = zooKeeperCompletedCheckpointStore.getLatestCheckpoint();&lt;br/&gt;
+&lt;br/&gt;
+		// check that we return the latest retrievable checkpoint&lt;br/&gt;
+		// this should remove the latest checkpoint because it is broken&lt;br/&gt;
+		assertEquals(checkpoint2Id, latestCompletedCheckpoint.getCheckpointID());&lt;br/&gt;
+&lt;br/&gt;
+		// this should remove the second broken checkpoint because we&apos;re iterating over all checkpoints&lt;br/&gt;
+		List&amp;lt;CompletedCheckpoint&amp;gt; completedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();&lt;br/&gt;
+&lt;br/&gt;
+		Collection&amp;lt;Long&amp;gt; actualCheckpointIds = new HashSet&amp;lt;&amp;gt;(completedCheckpoints.size());&lt;br/&gt;
+&lt;br/&gt;
+		for (CompletedCheckpoint completedCheckpoint : completedCheckpoints) {
+			actualCheckpointIds.add(completedCheckpoint.getCheckpointID());
+		}&lt;br/&gt;
+&lt;br/&gt;
+		assertEquals(expectedCheckpointIds, actualCheckpointIds);&lt;br/&gt;
+&lt;br/&gt;
+		// check that we did not discard any of the state handles&lt;br/&gt;
+		verify(retrievableStateHandle1, never()).discardState();&lt;br/&gt;
+		verify(retrievableStateHandle2, never()).discardState();&lt;br/&gt;
+&lt;br/&gt;
+		// Make sure that we also didn&apos;t discard any of the broken handles. Only when checkpoints&lt;br/&gt;
+		// are subsumed should they be discarded.&lt;br/&gt;
+		verify(failingRetrievableStateHandle, never()).discardState();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the checkpoint does not exist in the store when we fail to add&lt;br/&gt;
+	 * it into the store (i.e., there exists an exception thrown by the method).&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testAddCheckpointWithFailedRemove() throws Exception {&lt;br/&gt;
+		final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zookeeperStateHandleStoreMock =&lt;br/&gt;
+			spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock));&lt;br/&gt;
+		whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zookeeperStateHandleStoreMock);&lt;br/&gt;
+&lt;br/&gt;
+		doAnswer(new Answer&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;&amp;gt;() {&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; answer(InvocationOnMock invocationOnMock) throws Throwable {
+				CompletedCheckpoint checkpoint = (CompletedCheckpoint) invocationOnMock.getArguments()[1];
+
+				RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle = mock(RetrievableStateHandle.class);
+				when(retrievableStateHandle.retrieveState()).thenReturn(checkpoint);
+
+				return retrievableStateHandle;
+			}&lt;br/&gt;
+		}).when(zookeeperStateHandleStoreMock).addAndLock(anyString(), any(CompletedCheckpoint.class));&lt;br/&gt;
+&lt;br/&gt;
+		doThrow(new Exception()).when(zookeeperStateHandleStoreMock).releaseAndTryRemove(anyString());&lt;br/&gt;
+&lt;br/&gt;
+		final int numCheckpointsToRetain = 1;&lt;br/&gt;
+		final String checkpointsPath = &quot;foobar&quot;;&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateSotrage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
+			numCheckpointsToRetain,&lt;br/&gt;
+			client,&lt;br/&gt;
+			checkpointsPath,&lt;br/&gt;
+			stateSotrage,&lt;br/&gt;
+			Executors.directExecutor());&lt;br/&gt;
+&lt;br/&gt;
+		for (long i = 0; i &amp;lt;= numCheckpointsToRetain; ++i) {&lt;br/&gt;
+			CompletedCheckpoint checkpointToAdd = mock(CompletedCheckpoint.class);&lt;br/&gt;
+			doReturn&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.when(checkpointToAdd).getCheckpointID();&lt;br/&gt;
+			doReturn(Collections.emptyMap()).when(checkpointToAdd).getOperatorStates();&lt;br/&gt;
+&lt;br/&gt;
+			try {
+				zooKeeperCompletedCheckpointStore.addCheckpoint(checkpointToAdd);
+
+				// The checkpoint should be in the store if we successfully add it into the store.
+				List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();
+				assertTrue(addedCheckpoints.contains(checkpointToAdd));
+			} catch (Exception e) {
+				// The checkpoint should not be in the store if any exception is thrown.
+				List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();
+				assertFalse(addedCheckpoints.contains(checkpointToAdd));
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java&lt;br/&gt;
index 0384733fdb1..f992d3b00c0 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java&lt;br/&gt;
@@ -18,60 +18,39 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.flink.runtime.checkpoint;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.flink.api.common.JobID;&lt;br/&gt;
-import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.configuration.Configuration;&lt;br/&gt;
+import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobStatus;&lt;br/&gt;
 import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
-import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;&lt;br/&gt;
+import org.apache.flink.runtime.state.SharedStateRegistry;&lt;br/&gt;
+import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;&lt;br/&gt;
-import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
 &lt;br/&gt;
 import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
-import org.apache.curator.framework.api.BackgroundCallback;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEvent;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEventType;&lt;br/&gt;
-import org.apache.curator.framework.api.ErrorListenerPathable;&lt;br/&gt;
-import org.apache.curator.utils.EnsurePath;&lt;br/&gt;
+import org.hamcrest.Matchers;&lt;br/&gt;
+import org.junit.ClassRule;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
-import org.junit.runner.RunWith;&lt;br/&gt;
-import org.mockito.Mockito;&lt;br/&gt;
-import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
-import org.mockito.stubbing.Answer;&lt;br/&gt;
-import org.powermock.core.classloader.annotations.PrepareForTest;&lt;br/&gt;
-import org.powermock.modules.junit4.PowerMockRunner;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
 &lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
-import java.util.ArrayList;&lt;br/&gt;
-import java.util.Collection;&lt;br/&gt;
-import java.util.Collections;&lt;br/&gt;
-import java.util.HashMap;&lt;br/&gt;
-import java.util.HashSet;&lt;br/&gt;
+import java.io.Serializable;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 import static org.junit.Assert.assertEquals;&lt;br/&gt;
-import static org.junit.Assert.assertFalse;&lt;br/&gt;
-import static org.junit.Assert.assertTrue;&lt;br/&gt;
-import static org.mockito.Matchers.any;&lt;br/&gt;
-import static org.mockito.Matchers.anyString;&lt;br/&gt;
-import static org.mockito.Mockito.doReturn;&lt;br/&gt;
-import static org.mockito.Mockito.mock;&lt;br/&gt;
-import static org.mockito.Mockito.never;&lt;br/&gt;
-import static org.mockito.Mockito.spy;&lt;br/&gt;
-import static org.mockito.Mockito.verify;&lt;br/&gt;
-import static org.mockito.Mockito.when;&lt;br/&gt;
-import static org.powermock.api.mockito.PowerMockito.doAnswer;&lt;br/&gt;
-import static org.powermock.api.mockito.PowerMockito.doThrow;&lt;br/&gt;
-import static org.powermock.api.mockito.PowerMockito.whenNew;&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * Tests for {@link ZooKeeperCompletedCheckpointStore}
&lt;p&gt;.&lt;br/&gt;
  */&lt;br/&gt;
-@RunWith(PowerMockRunner.class)&lt;br/&gt;
-@PrepareForTest(ZooKeeperCompletedCheckpointStore.class)&lt;br/&gt;
 public class ZooKeeperCompletedCheckpointStoreTest extends TestLogger {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	@ClassRule&lt;br/&gt;
+	public static ZooKeeperResource zooKeeperResource = new ZooKeeperResource();&lt;br/&gt;
+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testPathConversion() {&lt;br/&gt;
 		final long checkpointId = 42L;&lt;br/&gt;
@@ -82,188 +61,103 @@ public void testPathConversion() {&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Tests that the completed checkpoint store can retrieve all checkpoints stored in ZooKeeper&lt;/li&gt;
	&lt;li&gt;* and ignores those which cannot be retrieved via their state handles.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;We have a timeout in case the ZooKeeper store get&apos;s into a deadlock/livelock situation.&lt;br/&gt;
+	 * Tests that subsumed checkpoints are discarded.&lt;br/&gt;
 	 */&lt;/li&gt;
	&lt;li&gt;@Test(timeout = 50000)&lt;/li&gt;
	&lt;li&gt;public void testCheckpointRecovery() throws Exception {&lt;/li&gt;
	&lt;li&gt;final JobID jobID = new JobID();&lt;/li&gt;
	&lt;li&gt;final long checkpoint1Id = 1L;&lt;/li&gt;
	&lt;li&gt;final long checkpoint2Id = 2;&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;Tuple2&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;, String&amp;gt;&amp;gt; checkpointsInZooKeeper = new ArrayList&amp;lt;&amp;gt;(4);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final Collection&amp;lt;Long&amp;gt; expectedCheckpointIds = new HashSet&amp;lt;&amp;gt;(2);&lt;/li&gt;
	&lt;li&gt;expectedCheckpointIds.add(1L);&lt;/li&gt;
	&lt;li&gt;expectedCheckpointIds.add(2L);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; failingRetrievableStateHandle = mock(RetrievableStateHandle.class);&lt;/li&gt;
	&lt;li&gt;when(failingRetrievableStateHandle.retrieveState()).thenThrow(new IOException(&quot;Test exception&quot;));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle1 = mock(RetrievableStateHandle.class);&lt;/li&gt;
	&lt;li&gt;when(retrievableStateHandle1.retrieveState()).then(&lt;/li&gt;
	&lt;li&gt;(invocation) -&amp;gt; new CompletedCheckpoint(&lt;/li&gt;
	&lt;li&gt;jobID,&lt;/li&gt;
	&lt;li&gt;checkpoint1Id,&lt;/li&gt;
	&lt;li&gt;1L,&lt;/li&gt;
	&lt;li&gt;1L,&lt;/li&gt;
	&lt;li&gt;new HashMap&amp;lt;&amp;gt;(),&lt;/li&gt;
	&lt;li&gt;null,&lt;/li&gt;
	&lt;li&gt;CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),&lt;/li&gt;
	&lt;li&gt;new TestCompletedCheckpointStorageLocation()));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle2 = mock(RetrievableStateHandle.class);&lt;/li&gt;
	&lt;li&gt;when(retrievableStateHandle2.retrieveState()).then(&lt;/li&gt;
	&lt;li&gt;(invocation -&amp;gt; new CompletedCheckpoint(&lt;/li&gt;
	&lt;li&gt;jobID,&lt;/li&gt;
	&lt;li&gt;checkpoint2Id,&lt;/li&gt;
	&lt;li&gt;2L,&lt;/li&gt;
	&lt;li&gt;2L,&lt;/li&gt;
	&lt;li&gt;new HashMap&amp;lt;&amp;gt;(),&lt;/li&gt;
	&lt;li&gt;null,&lt;/li&gt;
	&lt;li&gt;CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),&lt;/li&gt;
	&lt;li&gt;new TestCompletedCheckpointStorageLocation())));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle1, &quot;/foobar1&quot;));&lt;/li&gt;
	&lt;li&gt;checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing1&quot;));&lt;/li&gt;
	&lt;li&gt;checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle2, &quot;/foobar2&quot;));&lt;/li&gt;
	&lt;li&gt;checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing2&quot;));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;/li&gt;
	&lt;li&gt;final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zooKeeperStateHandleStoreMock = spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock, Executors.directExecutor()));&lt;/li&gt;
	&lt;li&gt;whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zooKeeperStateHandleStoreMock);&lt;/li&gt;
	&lt;li&gt;doReturn(checkpointsInZooKeeper).when(zooKeeperStateHandleStoreMock).getAllSortedByNameAndLock();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final int numCheckpointsToRetain = 1;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Mocking for the delete operation on the CuratorFramework client&lt;/li&gt;
	&lt;li&gt;// It assures that the callback is executed synchronously&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final EnsurePath ensurePathMock = mock(EnsurePath.class);&lt;/li&gt;
	&lt;li&gt;final CuratorEvent curatorEventMock = mock(CuratorEvent.class);&lt;/li&gt;
	&lt;li&gt;when(curatorEventMock.getType()).thenReturn(CuratorEventType.DELETE);&lt;/li&gt;
	&lt;li&gt;when(curatorEventMock.getResultCode()).thenReturn(0);&lt;/li&gt;
	&lt;li&gt;when(client.newNamespaceAwareEnsurePath(anyString())).thenReturn(ensurePathMock);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;when(&lt;/li&gt;
	&lt;li&gt;client&lt;/li&gt;
	&lt;li&gt;.delete()&lt;/li&gt;
	&lt;li&gt;.inBackground(any(BackgroundCallback.class), any(Executor.class))&lt;/li&gt;
	&lt;li&gt;).thenAnswer(new Answer&amp;lt;ErrorListenerPathable&amp;lt;Void&amp;gt;&amp;gt;() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public ErrorListenerPathable&amp;lt;Void&amp;gt; answer(InvocationOnMock invocation) throws Throwable {&lt;/li&gt;
	&lt;li&gt;final BackgroundCallback callback = (BackgroundCallback) invocation.getArguments()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testDiscardingSubsumedCheckpoints() throws Exception 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		final SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();+		final Configuration configuration = new Configuration();+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString());++		final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);+		final ZooKeeperCompletedCheckpointStore checkpointStore = createZooKeeperCheckpointStore(client);++		try {
+			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint1 = CompletedCheckpointStoreTest.createCheckpoint(0, sharedStateRegistry);
+
+			checkpointStore.addCheckpoint(checkpoint1);
+			assertThat(checkpointStore.getAllCheckpoints(), Matchers.contains(checkpoint1));
+
+			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint2 = CompletedCheckpointStoreTest.createCheckpoint(1, sharedStateRegistry);
+			checkpointStore.addCheckpoint(checkpoint2);
+			final List&amp;lt;CompletedCheckpoint&amp;gt; allCheckpoints = checkpointStore.getAllCheckpoints();
+			assertThat(allCheckpoints, Matchers.contains(checkpoint2));
+			assertThat(allCheckpoints, Matchers.not(Matchers.contains(checkpoint1)));
+
+			// verify that the subsumed checkpoint is discarded
+			CompletedCheckpointStoreTest.verifyCheckpointDiscarded(checkpoint1);
+		} finally {
+			client.close();
+		}&lt;br/&gt;
+	}&lt;br/&gt;
 &lt;br/&gt;
-				ErrorListenerPathable&amp;lt;Void&amp;gt; result = mock(ErrorListenerPathable.class);&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that checkpoints are discarded when the completed checkpoint store is shut&lt;br/&gt;
+	 * down with a globally terminal state.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testDiscardingCheckpointsAtShutDown() throws Exception {&lt;br/&gt;
+		final SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString());&lt;br/&gt;
 &lt;br/&gt;
-				when(result.forPath(anyString())).thenAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
-					@Override&lt;br/&gt;
-					public Void answer(InvocationOnMock invocation) throws Throwable {&lt;br/&gt;
+		final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+		final ZooKeeperCompletedCheckpointStore checkpointStore = createZooKeeperCheckpointStore(client);&lt;br/&gt;
 &lt;br/&gt;
-						callback.processResult(client, curatorEventMock);&lt;br/&gt;
+		try {
+			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint1 = CompletedCheckpointStoreTest.createCheckpoint(0, sharedStateRegistry);
 
-						return null;
-					}&lt;br/&gt;
-				});&lt;br/&gt;
+			checkpointStore.addCheckpoint(checkpoint1);&lt;br/&gt;
+			assertThat(checkpointStore.getAllCheckpoints(), Matchers.contains(checkpoint1));&lt;br/&gt;
 &lt;br/&gt;
-				return result;&lt;br/&gt;
-			}&lt;br/&gt;
-		});&lt;br/&gt;
+			checkpointStore.shutdown(JobStatus.FINISHED);&lt;br/&gt;
 &lt;br/&gt;
-		final String checkpointsPath = &quot;foobar&quot;;&lt;br/&gt;
-		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateStorage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+			// verify that the checkpoint is discarded&lt;br/&gt;
+			CompletedCheckpointStoreTest.verifyCheckpointDiscarded(checkpoint1);&lt;br/&gt;
+		} finally {+			client.close();+		}+	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;/li&gt;
	&lt;li&gt;numCheckpointsToRetain,&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private ZooKeeperCompletedCheckpointStore createZooKeeperCheckpointStore(CuratorFramework client) throws Exception 
{
+		return new ZooKeeperCompletedCheckpointStore(
+			1,
 			client,
-			checkpointsPath,
-			stateStorage,
+			&quot;/checkpoints&quot;,
+			new TestingRetrievableStateStorageHelper&amp;lt;&amp;gt;(),
 			Executors.directExecutor());
+	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;zooKeeperCompletedCheckpointStore.recover();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;CompletedCheckpoint latestCompletedCheckpoint = zooKeeperCompletedCheckpointStore.getLatestCheckpoint();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// check that we return the latest retrievable checkpoint&lt;/li&gt;
	&lt;li&gt;// this should remove the latest checkpoint because it is broken&lt;/li&gt;
	&lt;li&gt;assertEquals(checkpoint2Id, latestCompletedCheckpoint.getCheckpointID());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// this should remove the second broken checkpoint because we&apos;re iterating over all checkpoints&lt;/li&gt;
	&lt;li&gt;List&amp;lt;CompletedCheckpoint&amp;gt; completedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;Collection&amp;lt;Long&amp;gt; actualCheckpointIds = new HashSet&amp;lt;&amp;gt;(completedCheckpoints.size());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;for (CompletedCheckpoint completedCheckpoint : completedCheckpoints) {&lt;/li&gt;
	&lt;li&gt;actualCheckpointIds.add(completedCheckpoint.getCheckpointID());&lt;br/&gt;
+	private static final class TestingRetrievableStateStorageHelper&amp;lt;T extends Serializable&amp;gt; implements RetrievableStateStorageHelper&amp;lt;T&amp;gt; {&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public RetrievableStateHandle&amp;lt;T&amp;gt; store(T state) 
{
+			return new TestingRetrievableStateHandle&amp;lt;&amp;gt;(state);
 		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertEquals(expectedCheckpointIds, actualCheckpointIds);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// check that we did not discard any of the state handles&lt;/li&gt;
	&lt;li&gt;verify(retrievableStateHandle1, never()).discardState();&lt;/li&gt;
	&lt;li&gt;verify(retrievableStateHandle2, never()).discardState();&lt;br/&gt;
+		private static class TestingRetrievableStateHandle&amp;lt;T extends Serializable&amp;gt; implements RetrievableStateHandle&amp;lt;T&amp;gt; 
{
 
-		// Make sure that we also didn&apos;t discard any of the broken handles. Only when checkpoints
-		// are subsumed should they be discarded.
-		verify(failingRetrievableStateHandle, never()).discardState();
-	}
&lt;p&gt;+			private static final long serialVersionUID = 137053380713794300L;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Tests that the checkpoint does not exist in the store when we fail to add&lt;/li&gt;
	&lt;li&gt;* it into the store (i.e., there exists an exception thrown by the method).&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testAddCheckpointWithFailedRemove() throws Exception {&lt;/li&gt;
	&lt;li&gt;final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;/li&gt;
	&lt;li&gt;final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+			private final T state;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zookeeperStateHandleStoreMock =&lt;/li&gt;
	&lt;li&gt;spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock, Executors.directExecutor()));&lt;/li&gt;
	&lt;li&gt;whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zookeeperStateHandleStoreMock);&lt;br/&gt;
+			private TestingRetrievableStateHandle(T state) 
{
+				this.state = state;
+			}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;doAnswer(new Answer&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;&amp;gt;() {&lt;br/&gt;
 			@Override&lt;/li&gt;
	&lt;li&gt;public RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; answer(InvocationOnMock invocationOnMock) throws Throwable {&lt;/li&gt;
	&lt;li&gt;CompletedCheckpoint checkpoint = (CompletedCheckpoint) invocationOnMock.getArguments()&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle = mock(RetrievableStateHandle.class);&lt;/li&gt;
	&lt;li&gt;when(retrievableStateHandle.retrieveState()).thenReturn(checkpoint);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;return retrievableStateHandle;&lt;br/&gt;
+			public T retrieveState() throws IOException, ClassNotFoundException 
{
+				return state;
 			}&lt;/li&gt;
	&lt;li&gt;}).when(zookeeperStateHandleStoreMock).addAndLock(anyString(), any(CompletedCheckpoint.class));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;doThrow(new Exception()).when(zookeeperStateHandleStoreMock).releaseAndTryRemove(anyString(), any(ZooKeeperStateHandleStore.RemoveCallback.class));&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final int numCheckpointsToRetain = 1;&lt;/li&gt;
	&lt;li&gt;final String checkpointsPath = &quot;foobar&quot;;&lt;/li&gt;
	&lt;li&gt;final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateSotrage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;/li&gt;
	&lt;li&gt;numCheckpointsToRetain,&lt;/li&gt;
	&lt;li&gt;client,&lt;/li&gt;
	&lt;li&gt;checkpointsPath,&lt;/li&gt;
	&lt;li&gt;stateSotrage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public void discardState() throws Exception 
{
+				// no op
+			}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for (long i = 0; i &amp;lt;= numCheckpointsToRetain; ++i) {&lt;/li&gt;
	&lt;li&gt;CompletedCheckpoint checkpointToAdd = mock(CompletedCheckpoint.class);&lt;/li&gt;
	&lt;li&gt;doReturn&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.when(checkpointToAdd).getCheckpointID();&lt;/li&gt;
	&lt;li&gt;doReturn(Collections.emptyMap()).when(checkpointToAdd).getOperatorStates();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;try 
{
-				zooKeeperCompletedCheckpointStore.addCheckpoint(checkpointToAdd);
-
-				// The checkpoint should be in the store if we successfully add it into the store.
-				List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();
-				assertTrue(addedCheckpoints.contains(checkpointToAdd));
-			}
&lt;p&gt; catch (Exception e) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// The checkpoint should not be in the store if any exception is thrown.&lt;/li&gt;
	&lt;li&gt;List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();&lt;/li&gt;
	&lt;li&gt;assertFalse(addedCheckpoints.contains(checkpointToAdd));&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public long getStateSize() 
{
+				return 0;
 			}
&lt;p&gt; 		}&lt;br/&gt;
 	}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java&lt;br/&gt;
index 2c030d24c49..cb26f4862b1 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java&lt;br/&gt;
@@ -30,9 +30,11 @@&lt;br/&gt;
 import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobVertex;&lt;br/&gt;
+import org.apache.flink.runtime.jobmanager.StandaloneSubmittedJobGraphStore;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.SubmittedJobGraph;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore;&lt;br/&gt;
 import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;&lt;br/&gt;
+import org.apache.flink.runtime.messages.Acknowledge;&lt;br/&gt;
 import org.apache.flink.runtime.metrics.groups.JobManagerMetricGroup;&lt;br/&gt;
 import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;&lt;br/&gt;
 import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;&lt;br/&gt;
@@ -41,6 +43,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.rpc.RpcService;&lt;br/&gt;
 import org.apache.flink.runtime.rpc.RpcUtils;&lt;br/&gt;
 import org.apache.flink.runtime.rpc.TestingRpcService;&lt;br/&gt;
+import org.apache.flink.runtime.testtasks.NoOpInvokable;&lt;br/&gt;
 import org.apache.flink.runtime.util.TestingFatalErrorHandler;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
@@ -110,8 +113,6 @@ public static void teardownClass() throws ExecutionException, InterruptedExcepti&lt;br/&gt;
 	 */&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testGrantingRevokingLeadership() throws Exception {&lt;br/&gt;
-&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;final Configuration configuration = new Configuration();&lt;br/&gt;
 		final TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices();&lt;br/&gt;
 		final JobGraph nonEmptyJobGraph = createNonEmptyJobGraph();&lt;br/&gt;
 		final SubmittedJobGraph submittedJobGraph = new SubmittedJobGraph(nonEmptyJobGraph, null);&lt;br/&gt;
@@ -124,7 +125,34 @@ public void testGrantingRevokingLeadership() throws Exception {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final BlockingQueue&amp;lt;DispatcherId&amp;gt; fencingTokens = new ArrayBlockingQueue&amp;lt;&amp;gt;(2);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final HATestingDispatcher dispatcher = new HATestingDispatcher(&lt;br/&gt;
+		final HATestingDispatcher dispatcher = createHADispatcher(highAvailabilityServices, fencingTokens);&lt;br/&gt;
+&lt;br/&gt;
+		dispatcher.start();&lt;br/&gt;
+&lt;br/&gt;
+		try 
{
+			final UUID leaderId = UUID.randomUUID();
+			dispatcherLeaderElectionService.isLeader(leaderId);
+
+			dispatcherLeaderElectionService.notLeader();
+
+			final DispatcherId firstFencingToken = fencingTokens.take();
+
+			assertThat(firstFencingToken, equalTo(NULL_FENCING_TOKEN));
+
+			enterGetJobIdsLatch.await();
+			proceedGetJobIdsLatch.trigger();
+
+			assertThat(dispatcher.getNumberJobs(timeout).get(), is(0));
+
+		}
&lt;p&gt; finally &lt;/p&gt;
{
+			RpcUtils.terminateRpcEndpoint(dispatcher, timeout);
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private HATestingDispatcher createHADispatcher(TestingHighAvailabilityServices highAvailabilityServices, BlockingQueue&amp;lt;DispatcherId&amp;gt; fencingTokens) throws Exception {&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		return new HATestingDispatcher(&lt;br/&gt;
 			rpcService,&lt;br/&gt;
 			UUID.randomUUID().toString(),&lt;br/&gt;
 			configuration,&lt;br/&gt;
@@ -138,33 +166,63 @@ public void testGrantingRevokingLeadership() throws Exception &lt;/p&gt;
{
 			new TestingJobManagerRunnerFactory(new CompletableFuture&amp;lt;&amp;gt;(), new CompletableFuture&amp;lt;&amp;gt;()),
 			testingFatalErrorHandler,
 			fencingTokens);
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that all JobManagerRunner are terminated if the leadership of the&lt;br/&gt;
+	 * Dispatcher is revoked.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testRevokeLeadershipTerminatesJobManagerRunners() throws Exception {&lt;br/&gt;
+&lt;br/&gt;
+		final TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices();&lt;br/&gt;
+		highAvailabilityServices.setSubmittedJobGraphStore(new StandaloneSubmittedJobGraphStore());&lt;br/&gt;
+&lt;br/&gt;
+		final TestingLeaderElectionService leaderElectionService = new TestingLeaderElectionService();&lt;br/&gt;
+		highAvailabilityServices.setDispatcherLeaderElectionService(leaderElectionService);&lt;br/&gt;
+&lt;br/&gt;
+		final ArrayBlockingQueue&amp;lt;DispatcherId&amp;gt; fencingTokens = new ArrayBlockingQueue&amp;lt;&amp;gt;(2);&lt;br/&gt;
+		final HATestingDispatcher dispatcher = createHADispatcher(&lt;br/&gt;
+			highAvailabilityServices,&lt;br/&gt;
+			fencingTokens);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		dispatcher.start();&lt;/p&gt;

&lt;p&gt; 		try &lt;/p&gt;
{
-			final UUID leaderId = UUID.randomUUID();
-			dispatcherLeaderElectionService.isLeader(leaderId);
+			// grant leadership and submit a single job
+			final DispatcherId expectedDispatcherId = DispatcherId.generate();
 
-			dispatcherLeaderElectionService.notLeader();
+			leaderElectionService.isLeader(expectedDispatcherId.toUUID()).get();
 
-			final DispatcherId firstFencingToken = fencingTokens.take();
+			assertThat(fencingTokens.take(), is(equalTo(expectedDispatcherId)));
 
-			assertThat(firstFencingToken, equalTo(NULL_FENCING_TOKEN));
+			final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 
-			enterGetJobIdsLatch.await();
-			proceedGetJobIdsLatch.trigger();
+			final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = dispatcherGateway.submitJob(createNonEmptyJobGraph(), timeout);
 
-			assertThat(dispatcher.getNumberJobs(timeout).get(), is(0));
+			submissionFuture.get();
+
+			assertThat(dispatcher.getNumberJobs(timeout).get(), is(1));
+
+			// revoke the leadership --&amp;gt; this should stop all running JobManagerRunners
+			leaderElectionService.notLeader();
+
+			assertThat(fencingTokens.take(), is(equalTo(NULL_FENCING_TOKEN)));
 
+			assertThat(dispatcher.getNumberJobs(timeout).get(), is(0));
 		}
&lt;p&gt; finally &lt;/p&gt;
{
 			RpcUtils.terminateRpcEndpoint(dispatcher, timeout);
 		}
&lt;p&gt; 	}&lt;/p&gt;

&lt;p&gt; 	@Nonnull&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private JobGraph createNonEmptyJobGraph() {&lt;br/&gt;
+	public static JobGraph createNonEmptyJobGraph() 
{
 		final JobVertex noOpVertex = new JobVertex(&quot;NoOp vertex&quot;);
-		return new JobGraph(noOpVertex);
+		noOpVertex.setInvokableClass(NoOpInvokable.class);
+		final JobGraph jobGraph = new JobGraph(noOpVertex);
+		jobGraph.setAllowQueuedScheduling(true);
+
+		return jobGraph;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	private static class HATestingDispatcher extends TestingDispatcher {&lt;br/&gt;
@@ -243,6 +301,11 @@ public void removeJobGraph(JobID jobId) throws Exception &lt;/p&gt;
{
 			throw new UnsupportedOperationException(&quot;Should not be called.&quot;);
 		}

&lt;p&gt;+		@Override&lt;br/&gt;
+		public void releaseJobGraph(JobID jobId) throws Exception &lt;/p&gt;
{
+			throw new UnsupportedOperationException(&quot;Should not be called.&quot;);
+		}
&lt;p&gt;+&lt;br/&gt;
 		@Override&lt;br/&gt;
 		public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
 			enterGetJobIdsLatch.trigger();&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/NoOpSubmittedJobGraphListener.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/NoOpSubmittedJobGraphListener.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..493534dd93c&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/NoOpSubmittedJobGraphListener.java&lt;br/&gt;
@@ -0,0 +1,40 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.dispatcher;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * No operation &lt;/p&gt;
{@link org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore.SubmittedJobGraphListener}
&lt;p&gt;+ * implemetation for testing purposes.&lt;br/&gt;
+ */&lt;br/&gt;
+public enum NoOpSubmittedJobGraphListener implements SubmittedJobGraphStore.SubmittedJobGraphListener {&lt;br/&gt;
+	INSTANCE;&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void onAddedJobGraph(JobID jobId) &lt;/p&gt;
{
+		// No op
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void onRemovedJobGraph(JobID jobId) {+		// No op+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
index f5091ea5b10..5141be039f7 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
@@ -19,6 +19,8 @@&lt;br/&gt;
 package org.apache.flink.runtime.dispatcher;&lt;/p&gt;

&lt;p&gt; import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.api.common.time.Time;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
 import org.apache.flink.runtime.blob.BlobServer;&lt;br/&gt;
 import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;&lt;br/&gt;
@@ -29,8 +31,12 @@&lt;br/&gt;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;&lt;br/&gt;
 import org.apache.flink.runtime.rpc.RpcService;&lt;/p&gt;

&lt;p&gt;+import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt;+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.function.Function;&lt;br/&gt;
+&lt;br/&gt;
 /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;{@link Dispatcher} implementation used for testing purposes.&lt;br/&gt;
  */&lt;br/&gt;
@@ -72,4 +78,11 @@ void completeJobExecution(ArchivedExecutionGraph archivedExecutionGraph) {
 		runAsync(
 			() -&amp;gt; jobReachedGloballyTerminalState(archivedExecutionGraph));
 	}&lt;br/&gt;
+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(@Nonnull JobID jobId, @Nonnull Time timeout) {
+		return callAsyncWithoutFencing(
+			() -&amp;gt; getJobTerminationFuture(jobId),
+			timeout).thenCompose(Function.identity());
+	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..dd0375886a9&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java&lt;br/&gt;
@@ -0,0 +1,203 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.dispatcher;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.api.common.time.Time;&lt;br/&gt;
+import org.apache.flink.configuration.Configuration;&lt;br/&gt;
+import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
+import org.apache.flink.runtime.blob.BlobServer;&lt;br/&gt;
+import org.apache.flink.runtime.blob.VoidBlobStore;&lt;br/&gt;
+import org.apache.flink.runtime.heartbeat.HeartbeatServices;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
+import org.apache.flink.runtime.jobmanager.SubmittedJobGraph;&lt;br/&gt;
+import org.apache.flink.runtime.jobmanager.ZooKeeperSubmittedJobGraphStore;&lt;br/&gt;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;&lt;br/&gt;
+import org.apache.flink.runtime.messages.Acknowledge;&lt;br/&gt;
+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;&lt;br/&gt;
+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;&lt;br/&gt;
+import org.apache.flink.runtime.rpc.RpcUtils;&lt;br/&gt;
+import org.apache.flink.runtime.rpc.TestingRpcService;&lt;br/&gt;
+import org.apache.flink.runtime.util.TestingFatalErrorHandler;&lt;br/&gt;
+import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.hamcrest.Matchers;&lt;br/&gt;
+import org.junit.After;&lt;br/&gt;
+import org.junit.AfterClass;&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.BeforeClass;&lt;br/&gt;
+import org.junit.ClassRule;&lt;br/&gt;
+import org.junit.Rule;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.rules.TemporaryFolder;&lt;br/&gt;
+import org.junit.rules.TestName;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Test cases for the interaction between ZooKeeper HA and the {@link Dispatcher}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ZooKeeperHADispatcherTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	private static final Time TIMEOUT = Time.seconds(10L);&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final ZooKeeperResource ZOO_KEEPER_RESOURCE = new ZooKeeperResource();&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();&lt;br/&gt;
+&lt;br/&gt;
+	private static Configuration configuration;&lt;br/&gt;
+&lt;br/&gt;
+	private static TestingRpcService rpcService;&lt;br/&gt;
+&lt;br/&gt;
+	private static BlobServer blobServer;&lt;br/&gt;
+&lt;br/&gt;
+	@Rule&lt;br/&gt;
+	public TestName name = new TestName();&lt;br/&gt;
+&lt;br/&gt;
+	private TestingFatalErrorHandler testingFatalErrorHandler;&lt;br/&gt;
+&lt;br/&gt;
+	@BeforeClass&lt;br/&gt;
+	public static void setupClass() throws IOException &lt;/p&gt;
{
+		configuration = new Configuration();
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, ZOO_KEEPER_RESOURCE.getConnectString());
+		configuration.setString(HighAvailabilityOptions.HA_STORAGE_PATH, TEMPORARY_FOLDER.newFolder().getAbsolutePath());
+		rpcService = new TestingRpcService();
+		blobServer = new BlobServer(configuration, new VoidBlobStore());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Before&lt;br/&gt;
+	public void setup() &lt;/p&gt;
{
+		testingFatalErrorHandler = new TestingFatalErrorHandler();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@After&lt;br/&gt;
+	public void teardown() throws Exception &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		if (testingFatalErrorHandler != null) {
+			testingFatalErrorHandler.rethrowError();
+		}+	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+	@AfterClass&lt;br/&gt;
+	public static void teardownClass() throws Exception &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		if (rpcService != null) {
+			RpcUtils.terminateRpcService(rpcService, TIMEOUT);
+			rpcService = null;
+		}++		if (blobServer != null) {
+			blobServer.close();
+			blobServer = null;
+		}+	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the &lt;/p&gt;
{@link Dispatcher}
&lt;p&gt; releases a locked &lt;/p&gt;
{@link SubmittedJobGraph}
&lt;p&gt; if it&lt;br/&gt;
+	 * lost the leadership.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testSubmittedJobGraphRelease() throws Exception {&lt;br/&gt;
+		final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+		final CuratorFramework otherClient = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+&lt;br/&gt;
+		try (final TestingHighAvailabilityServices testingHighAvailabilityServices = new TestingHighAvailabilityServices()) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			testingHighAvailabilityServices.setSubmittedJobGraphStore(ZooKeeperUtils.createSubmittedJobGraphs(client, configuration));++			final ZooKeeperSubmittedJobGraphStore otherSubmittedJobGraphStore = ZooKeeperUtils.createSubmittedJobGraphs(+				otherClient,+				configuration);++			otherSubmittedJobGraphStore.start(NoOpSubmittedJobGraphListener.INSTANCE);++			final TestingLeaderElectionService leaderElectionService = new TestingLeaderElectionService();+			testingHighAvailabilityServices.setDispatcherLeaderElectionService(leaderElectionService);++			final TestingDispatcher dispatcher = createDispatcher(testingHighAvailabilityServices);++			dispatcher.start();++			try {
+				final DispatcherId expectedLeaderId = DispatcherId.generate();
+				leaderElectionService.isLeader(expectedLeaderId.toUUID()).get();
+
+				final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
+
+				final JobGraph nonEmptyJobGraph = DispatcherHATest.createNonEmptyJobGraph();
+				final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = dispatcherGateway.submitJob(nonEmptyJobGraph, TIMEOUT);
+				submissionFuture.get();
+
+				Collection&amp;lt;JobID&amp;gt; jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+				final JobID jobId = nonEmptyJobGraph.getJobID();
+				assertThat(jobIds, Matchers.contains(jobId));
+
+				leaderElectionService.notLeader();
+
+				// wait for the job to properly terminate
+				final CompletableFuture&amp;lt;Void&amp;gt; jobTerminationFuture = dispatcher.getJobTerminationFuture(jobId, TIMEOUT);
+				jobTerminationFuture.get();
+
+				// recover the job
+				final SubmittedJobGraph submittedJobGraph = otherSubmittedJobGraphStore.recoverJobGraph(jobId);
+
+				assertThat(submittedJobGraph, Matchers.is(Matchers.notNullValue()));
+
+				// check that the other submitted job graph store can remove the job graph after the original leader
+				// has lost its leadership
+				otherSubmittedJobGraphStore.removeJobGraph(jobId);
+
+				jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+				assertThat(jobIds, Matchers.not(Matchers.contains(jobId)));
+			} finally {
+				RpcUtils.terminateRpcEndpoint(dispatcher, TIMEOUT);
+				client.close();
+				otherClient.close();
+			}+		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private TestingDispatcher createDispatcher(TestingHighAvailabilityServices testingHighAvailabilityServices) throws Exception &lt;/p&gt;
{
+		return new TestingDispatcher(
+			rpcService,
+			Dispatcher.DISPATCHER_NAME + &apos;_&apos; + name.getMethodName(),
+			configuration,
+			testingHighAvailabilityServices,
+			new TestingResourceManagerGateway(),
+			blobServer,
+			new HeartbeatServices(1000L, 1000L),
+			UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(),
+			null,
+			new MemoryArchivedExecutionGraphStore(),
+			new TestingJobManagerRunnerFactory(new CompletableFuture&amp;lt;&amp;gt;(), new CompletableFuture&amp;lt;&amp;gt;()),
+			testingFatalErrorHandler);
+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java&lt;br/&gt;
index 873a4f1f4f4..c499f265416 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java&lt;br/&gt;
@@ -32,8 +32,8 @@&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointMetrics;&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
-import org.apache.flink.runtime.checkpoint.CheckpointType;&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointRetentionPolicy;&lt;br/&gt;
+import org.apache.flink.runtime.checkpoint.CheckpointType;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.messages.NotifyResourceStarted;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.messages.RegisterResourceManager;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.messages.RegisterResourceManagerSuccessful;&lt;br/&gt;
@@ -151,7 +151,6 @@&lt;br/&gt;
 import static org.junit.Assert.assertNotNull;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;br/&gt;
 import static org.junit.Assert.fail;&lt;br/&gt;
-&lt;br/&gt;
 import static org.mockito.Mockito.mock;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; public class JobManagerTest extends TestLogger {&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..8e5b1b9b392&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java&lt;br/&gt;
@@ -0,0 +1,180 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.jobmanager;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.configuration.Configuration;&lt;br/&gt;
+import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
+import org.apache.flink.runtime.akka.ActorUtils;&lt;br/&gt;
+import org.apache.flink.runtime.akka.AkkaUtils;&lt;br/&gt;
+import org.apache.flink.runtime.akka.ListeningBehaviour;&lt;br/&gt;
+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;&lt;br/&gt;
+import org.apache.flink.runtime.dispatcher.DispatcherHATest;&lt;br/&gt;
+import org.apache.flink.runtime.dispatcher.NoOpSubmittedJobGraphListener;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.HighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.instance.ActorGateway;&lt;br/&gt;
+import org.apache.flink.runtime.instance.AkkaActorGateway;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;&lt;br/&gt;
+import org.apache.flink.runtime.messages.JobManagerMessages;&lt;br/&gt;
+import org.apache.flink.runtime.metrics.NoOpMetricRegistry;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingJobManager;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingJobManagerMessages;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingUtils;&lt;br/&gt;
+import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import akka.actor.ActorRef;&lt;br/&gt;
+import akka.actor.ActorSystem;&lt;br/&gt;
+import akka.actor.ExtendedActorSystem;&lt;br/&gt;
+import akka.actor.Identify;&lt;br/&gt;
+import akka.actor.Terminated;&lt;br/&gt;
+import akka.pattern.Patterns;&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.junit.AfterClass;&lt;br/&gt;
+import org.junit.BeforeClass;&lt;br/&gt;
+import org.junit.ClassRule;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.rules.TemporaryFolder;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+&lt;br/&gt;
+import scala.Option;&lt;br/&gt;
+import scala.concurrent.Await;&lt;br/&gt;
+import scala.concurrent.Future;&lt;br/&gt;
+import scala.concurrent.duration.FiniteDuration;&lt;br/&gt;
+&lt;br/&gt;
+import static org.hamcrest.Matchers.contains;&lt;br/&gt;
+import static org.hamcrest.Matchers.is;&lt;br/&gt;
+import static org.hamcrest.Matchers.not;&lt;br/&gt;
+import static org.hamcrest.Matchers.notNullValue;&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tests for the ZooKeeper HA service and &lt;/p&gt;
{@link JobManager} interaction.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ZooKeeperHAJobManagerTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final ZooKeeperResource ZOO_KEEPER_RESOURCE = new ZooKeeperResource();&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();&lt;br/&gt;
+&lt;br/&gt;
+	private static final FiniteDuration TIMEOUT = FiniteDuration.apply(10L, TimeUnit.SECONDS);&lt;br/&gt;
+&lt;br/&gt;
+	private static ActorSystem system;&lt;br/&gt;
+&lt;br/&gt;
+	@BeforeClass&lt;br/&gt;
+	public static void setup() {
+		system = AkkaUtils.createLocalActorSystem(new Configuration());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@AfterClass&lt;br/&gt;
+	public static void teardown() throws Exception {
+		final Future&amp;lt;Terminated&amp;gt; terminationFuture = system.terminate();
+		Await.ready(terminationFuture, TIMEOUT);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the {@link JobManager}
&lt;p&gt; releases all locked &lt;/p&gt;
{@link JobGraph}
&lt;p&gt; if it loses&lt;br/&gt;
+	 * leadership.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testJobGraphReleaseWhenLosingLeadership() throws Exception {&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, ZOO_KEEPER_RESOURCE.getConnectString());&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_STORAGE_PATH, TEMPORARY_FOLDER.newFolder().getAbsolutePath());&lt;br/&gt;
+&lt;br/&gt;
+		try (TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices()) {&lt;br/&gt;
+&lt;br/&gt;
+			final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+			final TestingLeaderElectionService leaderElectionService = new TestingLeaderElectionService();&lt;br/&gt;
+			highAvailabilityServices.setJobMasterLeaderElectionService(HighAvailabilityServices.DEFAULT_JOB_ID, leaderElectionService);&lt;br/&gt;
+			highAvailabilityServices.setSubmittedJobGraphStore(ZooKeeperUtils.createSubmittedJobGraphs(client, configuration));&lt;br/&gt;
+			highAvailabilityServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());&lt;br/&gt;
+&lt;br/&gt;
+			final CuratorFramework otherClient = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+			final ZooKeeperSubmittedJobGraphStore otherSubmittedJobGraphStore = ZooKeeperUtils.createSubmittedJobGraphs(otherClient, configuration);&lt;br/&gt;
+			otherSubmittedJobGraphStore.start(NoOpSubmittedJobGraphListener.INSTANCE);&lt;br/&gt;
+&lt;br/&gt;
+			ActorRef jobManagerActorRef = null;&lt;br/&gt;
+			try &lt;/p&gt;
{
+				jobManagerActorRef = JobManager.startJobManagerActors(
+					configuration,
+					system,
+					TestingUtils.defaultExecutor(),
+					TestingUtils.defaultExecutor(),
+					highAvailabilityServices,
+					NoOpMetricRegistry.INSTANCE,
+					Option.empty(),
+					TestingJobManager.class,
+					MemoryArchivist.class)._1();
+
+				waitForActorToBeStarted(jobManagerActorRef, TIMEOUT);
+
+				final ActorGateway jobManager = new AkkaActorGateway(jobManagerActorRef, HighAvailabilityServices.DEFAULT_LEADER_ID);
+
+				leaderElectionService.isLeader(HighAvailabilityServices.DEFAULT_LEADER_ID).get();
+
+				final JobGraph nonEmptyJobGraph = DispatcherHATest.createNonEmptyJobGraph();
+
+				final JobManagerMessages.SubmitJob submitJobMessage = new JobManagerMessages.SubmitJob(nonEmptyJobGraph, ListeningBehaviour.DETACHED);
+
+				Await.result(jobManager.ask(submitJobMessage, TIMEOUT), TIMEOUT);
+
+				Collection&amp;lt;JobID&amp;gt; jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+				final JobID jobId = nonEmptyJobGraph.getJobID();
+				assertThat(jobIds, contains(jobId));
+
+				// revoke the leadership
+				leaderElectionService.notLeader();
+
+				Await.result(jobManager.ask(TestingJobManagerMessages.getWaitForBackgroundTasksToFinish(), TIMEOUT), TIMEOUT);
+
+				final SubmittedJobGraph recoveredJobGraph = akka.serialization.JavaSerializer.currentSystem().withValue(
+					((ExtendedActorSystem) system),
+					() -&amp;gt; otherSubmittedJobGraphStore.recoverJobGraph(jobId));
+
+				assertThat(recoveredJobGraph, is(notNullValue()));
+
+				otherSubmittedJobGraphStore.removeJobGraph(jobId);
+
+				jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+				assertThat(jobIds, not(contains(jobId)));
+			}
&lt;p&gt; finally {&lt;br/&gt;
+				client.close();&lt;br/&gt;
+				otherClient.close();&lt;br/&gt;
+&lt;br/&gt;
+				if (jobManagerActorRef != null) &lt;/p&gt;
{
+					ActorUtils.stopActor(jobManagerActorRef);
+				}
&lt;p&gt;+			}&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private void waitForActorToBeStarted(ActorRef jobManagerActorRef, FiniteDuration timeout) throws InterruptedException, java.util.concurrent.TimeoutException &lt;/p&gt;
{
+		Await.ready(Patterns.ask(jobManagerActorRef, new Identify(42), timeout.toMillis()), timeout);
+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java&lt;br/&gt;
index c1a7b536721..e9be145c37f 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java&lt;br/&gt;
@@ -20,7 +20,6 @@&lt;/p&gt;

&lt;p&gt; import org.apache.flink.api.common.JobID;&lt;br/&gt;
 import org.apache.flink.runtime.akka.ListeningBehaviour;&lt;br/&gt;
-import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobVertex;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore.SubmittedJobGraphListener;&lt;br/&gt;
@@ -90,8 +89,7 @@ public void testPutAndRemoveJobGraph() throws Exception {&lt;br/&gt;
 		ZooKeeperSubmittedJobGraphStore jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;br/&gt;
 			ZooKeeper.createClient(),&lt;br/&gt;
 			&quot;/testPutAndRemoveJobGraph&quot;,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;localStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		try {&lt;br/&gt;
 			SubmittedJobGraphListener listener = mock(SubmittedJobGraphListener.class);&lt;br/&gt;
@@ -147,7 +145,7 @@ public void testPutAndRemoveJobGraph() throws Exception {&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testRecoverJobGraphs() throws Exception {&lt;br/&gt;
 		ZooKeeperSubmittedJobGraphStore jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testRecoverJobGraphs&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+				ZooKeeper.createClient(), &quot;/testRecoverJobGraphs&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		try {&lt;br/&gt;
 			SubmittedJobGraphListener listener = mock(SubmittedJobGraphListener.class);&lt;br/&gt;
@@ -198,10 +196,10 @@ public void testConcurrentAddJobGraph() throws Exception {&lt;/p&gt;

&lt;p&gt; 		try {&lt;br/&gt;
 			jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+					ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			otherJobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+					ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt; 			SubmittedJobGraph jobGraph = createSubmittedJobGraph(new JobID(), 0);&lt;br/&gt;
@@ -257,10 +255,10 @@ public Void answer(InvocationOnMock invocation) throws Throwable {&lt;br/&gt;
 	@Test(expected = IllegalStateException.class)&lt;br/&gt;
 	public void testUpdateJobGraphYouDidNotGetOrAdd() throws Exception {&lt;br/&gt;
 		ZooKeeperSubmittedJobGraphStore jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+				ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperSubmittedJobGraphStore otherJobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+				ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		jobGraphs.start(null);&lt;br/&gt;
 		otherJobGraphs.start(null);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java&lt;br/&gt;
index ba0dc80fbb5..3b9c5786ca4 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java&lt;br/&gt;
@@ -96,6 +96,11 @@ public synchronized void removeJobGraph(JobID jobId) throws Exception &lt;/p&gt;
{
 		storedJobs.remove(jobId);
 	}

&lt;p&gt;+	@Override&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) &lt;/p&gt;
{
+		verifyIsStarted();
+	}
&lt;p&gt;+&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public synchronized Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
 		verifyIsStarted();&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperResource.java b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperResource.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..c4c56949cd9&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperResource.java&lt;br/&gt;
@@ -0,0 +1,72 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.zookeeper;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.test.TestingServer;&lt;br/&gt;
+import org.junit.rules.ExternalResource;&lt;br/&gt;
+import org.slf4j.Logger;&lt;br/&gt;
+import org.slf4j.LoggerFactory;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * &lt;/p&gt;
{@link ExternalResource}
&lt;p&gt; which starts a &lt;/p&gt;
{@link org.apache.zookeeper.server.ZooKeeperServer}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ZooKeeperResource extends ExternalResource {&lt;br/&gt;
+&lt;br/&gt;
+	private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperResource.class);&lt;br/&gt;
+&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	private TestingServer zooKeeperServer;&lt;br/&gt;
+&lt;br/&gt;
+	public String getConnectString() &lt;/p&gt;
{
+		verifyIsRunning();
+		return zooKeeperServer.getConnectString();
+	}
&lt;p&gt;+&lt;br/&gt;
+	private void verifyIsRunning() &lt;/p&gt;
{
+		Preconditions.checkState(zooKeeperServer != null);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	protected void before() throws Throwable &lt;/p&gt;
{
+		terminateZooKeeperServer();
+		zooKeeperServer = new TestingServer(true);
+	}
&lt;p&gt;+&lt;br/&gt;
+	private void terminateZooKeeperServer() throws IOException {&lt;br/&gt;
+		if (zooKeeperServer != null) &lt;/p&gt;
{
+			zooKeeperServer.stop();
+			zooKeeperServer = null;
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	protected void after() {&lt;br/&gt;
+		try &lt;/p&gt;
{
+			terminateZooKeeperServer();
+		}
&lt;p&gt; catch (IOException e) {&lt;br/&gt;
+			LOG.warn(&quot;Could not properly terminate the {}.&quot;, getClass().getSimpleName(), e);&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java&lt;br/&gt;
index fd39b25991c..2dd27e7c897 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java&lt;br/&gt;
@@ -18,21 +18,19 @@&lt;/p&gt;

&lt;p&gt; package org.apache.flink.runtime.zookeeper;&lt;/p&gt;

&lt;p&gt;-import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
 import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
 import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
-import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
 import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
 import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
 import org.apache.flink.util.InstantiationUtil;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
 import org.apache.zookeeper.data.Stat;&lt;br/&gt;
 import org.junit.AfterClass;&lt;br/&gt;
 import org.junit.Before;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
-import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
-import org.mockito.stubbing.Answer;&lt;/p&gt;

&lt;p&gt; import java.io.IOException;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
@@ -41,7 +39,6 @@&lt;br/&gt;
 import java.util.HashSet;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Set;&lt;br/&gt;
-import java.util.concurrent.CountDownLatch;&lt;/p&gt;

&lt;p&gt; import static org.junit.Assert.assertEquals;&lt;br/&gt;
 import static org.junit.Assert.assertNotEquals;&lt;br/&gt;
@@ -49,12 +46,7 @@&lt;br/&gt;
 import static org.junit.Assert.assertNull;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;br/&gt;
 import static org.junit.Assert.fail;&lt;br/&gt;
-import static org.mockito.Matchers.any;&lt;br/&gt;
-import static org.mockito.Mockito.doAnswer;&lt;br/&gt;
-import static org.mockito.Mockito.mock;&lt;br/&gt;
 import static org.mockito.Mockito.spy;&lt;br/&gt;
-import static org.mockito.Mockito.times;&lt;br/&gt;
-import static org.mockito.Mockito.verify;&lt;br/&gt;
 import static org.mockito.Mockito.when;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -88,8 +80,8 @@ public void cleanUp() throws Exception {&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testAddAndLock() throws Exception {&lt;br/&gt;
 		LongStateStorage longStateStorage = new LongStateStorage();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;Long&amp;gt;(&lt;/li&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), longStateStorage, Executors.directExecutor());&lt;br/&gt;
+		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
+			ZOOKEEPER.getClient(), longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testAdd&quot;;&lt;br/&gt;
@@ -136,7 +128,7 @@ public void testAddAlreadyExistingPath() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZOOKEEPER.getClient().create().forPath(&quot;/testAddAlreadyExistingPath&quot;);&lt;/p&gt;

&lt;p&gt;@@ -161,7 +153,7 @@ public void testAddDiscardStateHandleAfterFailure() throws Exception {&lt;br/&gt;
 		when(client.inTransaction().create()).thenThrow(new RuntimeException(&quot;Expected test Exception.&quot;));&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client, stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				client, stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testAddDiscardStateHandleAfterFailure&quot;;&lt;br/&gt;
@@ -191,7 +183,7 @@ public void testReplace() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testReplace&quot;;&lt;br/&gt;
@@ -230,7 +222,7 @@ public void testReplaceNonExistingPath() throws Exception &lt;/p&gt;
{
 		RetrievableStateStorageHelper&amp;lt;Long&amp;gt; stateStorage = new LongStateStorage();
 
 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(
-				ZOOKEEPER.getClient(), stateStorage, Executors.directExecutor());
+				ZOOKEEPER.getClient(), stateStorage);
 
 		store.replace(&quot;/testReplaceNonExistingPath&quot;, 0, 1L);
 	}
&lt;p&gt;@@ -247,7 +239,7 @@ public void testReplaceDiscardStateHandleAfterFailure() throws Exception {&lt;br/&gt;
 		when(client.setData()).thenThrow(new RuntimeException(&quot;Expected test Exception.&quot;));&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client, stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				client, stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testReplaceDiscardStateHandleAfterFailure&quot;;&lt;br/&gt;
@@ -289,7 +281,7 @@ public void testGetAndExists() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testGetAndExists&quot;;&lt;br/&gt;
@@ -314,7 +306,7 @@ public void testGetNonExistingPath() throws Exception &lt;/p&gt;
{
 		LongStateStorage stateHandleProvider = new LongStateStorage();
 
 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(
-				ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());
+				ZOOKEEPER.getClient(), stateHandleProvider);
 
 		store.getAndLock(&quot;/testGetNonExistingPath&quot;);
 	}
&lt;p&gt;@@ -328,7 +320,7 @@ public void testGetAll() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testGetAll&quot;;&lt;br/&gt;
@@ -359,7 +351,7 @@ public void testGetAllSortedByName() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String basePath = &quot;/testGetAllSortedByName&quot;;&lt;br/&gt;
@@ -393,7 +385,7 @@ public void testRemove() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testRemove&quot;;&lt;br/&gt;
@@ -401,50 +393,14 @@ public void testRemove() throws Exception &lt;/p&gt;
{
 
 		store.addAndLock(pathInZooKeeper, state);
 
+		final int numberOfGlobalDiscardCalls = LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls();
+
 		// Test
 		store.releaseAndTryRemove(pathInZooKeeper);
 
 		// Verify discarded
 		assertEquals(0, ZOOKEEPER.getClient().getChildren().forPath(&quot;/&quot;).size());
-	}
&lt;p&gt;-&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Tests that state handles are correctly removed with a callback.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testRemoveWithCallback() throws Exception {&lt;/li&gt;
	&lt;li&gt;// Setup&lt;/li&gt;
	&lt;li&gt;LongStateStorage stateHandleProvider = new LongStateStorage();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/li&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Config&lt;/li&gt;
	&lt;li&gt;final String pathInZooKeeper = &quot;/testRemoveWithCallback&quot;;&lt;/li&gt;
	&lt;li&gt;final Long state = 27255442L;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;store.addAndLock(pathInZooKeeper, state);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CountDownLatch sync = new CountDownLatch(1);&lt;/li&gt;
	&lt;li&gt;ZooKeeperStateHandleStore.RemoveCallback&amp;lt;Long&amp;gt; callback = mock(ZooKeeperStateHandleStore.RemoveCallback.class);&lt;/li&gt;
	&lt;li&gt;doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public Void answer(InvocationOnMock invocation) throws Throwable 
{
-				sync.countDown();
-				return null;
-			}&lt;/li&gt;
	&lt;li&gt;}).when(callback).apply(any(RetrievableStateHandle.class));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Test&lt;/li&gt;
	&lt;li&gt;store.releaseAndTryRemove(pathInZooKeeper, callback);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Verify discarded and callback called&lt;/li&gt;
	&lt;li&gt;assertEquals(0, ZOOKEEPER.getClient().getChildren().forPath(&quot;/&quot;).size());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;sync.await();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;verify(callback, times(1))&lt;/li&gt;
	&lt;li&gt;.apply(any(RetrievableStateHandle.class));&lt;br/&gt;
+		assertEquals(numberOfGlobalDiscardCalls + 1, LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls());&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/** Tests that all state handles are correctly discarded. */&lt;br/&gt;
@@ -454,7 +410,7 @@ public void testReleaseAndTryRemoveAll() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testDiscardAll&quot;;&lt;br/&gt;
@@ -486,8 +442,7 @@ public void testCorruptedData() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;stateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			stateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final Collection&amp;lt;Long&amp;gt; input = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
 		input.add(1L);&lt;br/&gt;
@@ -543,13 +498,11 @@ public void testConcurrentDeleteOperation() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore1 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore2 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final String statePath = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -586,13 +539,11 @@ public void testLockCleanupWhenGetAndLockFails() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore1 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore2 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final String path = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -649,8 +600,7 @@ public void testLockCleanupWhenClientTimesOut() throws Exception {&lt;/p&gt;

&lt;p&gt; 			ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 				client,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+				longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			final String path = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -682,8 +632,7 @@ public void testRelease() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final String path = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -720,8 +669,7 @@ public void testReleaseAll() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final Collection&amp;lt;String&amp;gt; paths = Arrays.asList(&quot;/state1&quot;, &quot;/state2&quot;, &quot;/state3&quot;);&lt;/p&gt;

&lt;p&gt;@@ -775,9 +723,11 @@ public void testReleaseAll() throws Exception {&lt;/p&gt;

&lt;p&gt; 		private static final long serialVersionUID = -3555329254423838912L;&lt;/p&gt;

&lt;p&gt;+		private static int numberOfGlobalDiscardCalls = 0;&lt;br/&gt;
+&lt;br/&gt;
 		private final Long state;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private int numberOfDiscardCalls;&lt;br/&gt;
+		private int numberOfDiscardCalls = 0;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		public LongRetrievableStateHandle(Long state) {&lt;br/&gt;
 			this.state = state;&lt;br/&gt;
@@ -790,6 +740,7 @@ public Long retrieveState() {&lt;/p&gt;

&lt;p&gt; 		@Override&lt;br/&gt;
 		public void discardState() throws Exception &lt;/p&gt;
{
+			numberOfGlobalDiscardCalls++;
 			numberOfDiscardCalls++;
 		}

&lt;p&gt;@@ -798,8 +749,12 @@ public long getStateSize() &lt;/p&gt;
{
 			return 0;
 		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public int getNumberOfDiscardCalls() 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		int getNumberOfDiscardCalls() {
 			return numberOfDiscardCalls;
 		}++		public static int getNumberOfGlobalDiscardCalls() {
+			return numberOfGlobalDiscardCalls;
+		} 	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; }&lt;br/&gt;
diff --git a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala&lt;br/&gt;
index 0640f39f4cf..ebe46399395 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala&lt;br/&gt;
+++ b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala&lt;br/&gt;
@@ -454,6 +454,14 @@ trait TestingJobManagerLike extends FlinkActor 
{
         val receiver = waitForNumRegisteredTaskManagers.dequeue()._2
         receiver ! Acknowledge.get()
       }
&lt;p&gt;+&lt;br/&gt;
+    case WaitForBackgroundTasksToFinish =&amp;gt;&lt;br/&gt;
+      val future = futuresToComplete match &lt;/p&gt;
{
+        case Some(futures) =&amp;gt; Future.sequence(futures)
+        case None =&amp;gt; Future.successful(Seq())
+      }
&lt;p&gt;+&lt;br/&gt;
+      future.pipeTo(sender())&lt;br/&gt;
   }&lt;/p&gt;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   def checkIfAllVerticesRunning(jobID: JobID): Boolean = {&lt;br/&gt;
diff --git a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala&lt;br/&gt;
index c8529a9e07a..64af056f24d 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala&lt;br/&gt;
+++ b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala&lt;br/&gt;
@@ -59,6 +59,8 @@ object TestingJobManagerMessages {&lt;/p&gt;

&lt;p&gt;   case object NotifyListeners&lt;/p&gt;

&lt;p&gt;+  case object WaitForBackgroundTasksToFinish&lt;br/&gt;
+&lt;br/&gt;
   case class NotifyWhenTaskManagerTerminated(taskManager: ActorRef)&lt;br/&gt;
   case class TaskManagerTerminated(taskManager: ActorRef)&lt;/p&gt;

&lt;p&gt;@@ -164,4 +166,5 @@ object TestingJobManagerMessages &lt;/p&gt;
{
   def getClientConnected(): AnyRef = ClientConnected
   def getClassLoadingPropsDelivered(): AnyRef = ClassLoadingPropsDelivered
 
+  def getWaitForBackgroundTasksToFinish(): AnyRef = WaitForBackgroundTasksToFinish
 }




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612256" author="githubbot" created="Wed, 12 Sep 2018 14:50:19 +0000"  >&lt;p&gt;tillrohrmann commented on issue #6589: &lt;span class=&quot;error&quot;&gt;&amp;#91;Backport 1.5&amp;#93;&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6589#issuecomment-420677376&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6589#issuecomment-420677376&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Merged via&lt;br/&gt;
   7c56d15b911d4fb87c073a25eb93d61502995c5a&lt;br/&gt;
   5c8630cf34b3d3cce5a821972840f0a7c2fa1bb7&lt;br/&gt;
   dd096eb44d8401d22f7e3cfaa51345f59abe04d4&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612257" author="githubbot" created="Wed, 12 Sep 2018 14:50:21 +0000"  >&lt;p&gt;tillrohrmann closed pull request #6589: &lt;span class=&quot;error&quot;&gt;&amp;#91;Backport 1.5&amp;#93;&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6589&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6589&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java b/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java&lt;br/&gt;
index 069cb833a3a..45d11412c50 100644&lt;br/&gt;
&amp;#8212; a/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java&lt;br/&gt;
+++ b/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java&lt;br/&gt;
@@ -56,8 +56,7 @@ public MesosWorkerStore createMesosWorkerStore(Configuration configuration, Exec&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;MesosWorkerStore.Worker&amp;gt; zooKeeperStateHandleStore = zooKeeperUtilityFactory.createZooKeeperStateHandleStore(&lt;br/&gt;
 			&quot;/workers&quot;,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;stateStorageHelper,&lt;/li&gt;
	&lt;li&gt;executor);&lt;br/&gt;
+			stateStorageHelper);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperSharedValue frameworkId = zooKeeperUtilityFactory.createSharedValue(&quot;/frameworkId&quot;, new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
 		ZooKeeperSharedCount totalTaskCount = zooKeeperUtilityFactory.createSharedCount(&quot;/taskCount&quot;, 0);&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java&lt;br/&gt;
index f2f905971c3..9a992814235 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java&lt;br/&gt;
@@ -19,9 +19,11 @@&lt;br/&gt;
 package org.apache.flink.runtime.akka;&lt;/p&gt;

&lt;p&gt; import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.runtime.instance.AkkaActorGateway;&lt;/p&gt;

&lt;p&gt; import akka.actor.ActorRef;&lt;br/&gt;
 import akka.actor.Kill;&lt;br/&gt;
+import akka.actor.PoisonPill;&lt;br/&gt;
 import akka.pattern.Patterns;&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
@@ -85,5 +87,13 @@&lt;br/&gt;
 		return FutureUtils.completeAll(terminationFutures);&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	public static void stopActor(AkkaActorGateway akkaActorGateway) &lt;/p&gt;
{
+		stopActor(akkaActorGateway.actor());
+	}
&lt;p&gt;+&lt;br/&gt;
+	public static void stopActor(ActorRef actorRef) &lt;/p&gt;
{
+		actorRef.tell(PoisonPill.getInstance(), ActorRef.noSender());
+	}
&lt;p&gt;+&lt;br/&gt;
 	private ActorUtils() {}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
index f22127041d3..131733924ae 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
@@ -25,14 +25,13 @@&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;&lt;br/&gt;
 import org.apache.flink.util.FlinkException;&lt;br/&gt;
+import org.apache.flink.util.function.ConsumerWithException;&lt;/p&gt;

&lt;p&gt; import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
 import org.apache.curator.utils.ZKPaths;&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;/p&gt;

&lt;p&gt;-import javax.annotation.Nullable;&lt;br/&gt;
-&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.util.ArrayDeque;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
@@ -86,6 +85,8 @@&lt;br/&gt;
 	 */&lt;br/&gt;
 	private final ArrayDeque&amp;lt;CompletedCheckpoint&amp;gt; completedCheckpoints;&lt;/p&gt;

&lt;p&gt;+	private final Executor executor;&lt;br/&gt;
+&lt;br/&gt;
 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Creates a 
{@link ZooKeeperCompletedCheckpointStore} instance.&lt;br/&gt;
 	 *&lt;br/&gt;
@@ -98,7 +99,7 @@&lt;br/&gt;
 	 *                                       start with a &apos;/&apos;)&lt;br/&gt;
 	 * @param stateStorage                   State storage to be used to persist the completed&lt;br/&gt;
 	 *                                       checkpoint&lt;br/&gt;
-	 * @param executor to give to the ZooKeeperStateHandleStore to run ZooKeeper callbacks&lt;br/&gt;
+	 * @param executor to execute blocking calls&lt;br/&gt;
 	 * @throws Exception&lt;br/&gt;
 	 */&lt;br/&gt;
 	public ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
@@ -123,10 +124,12 @@ public ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
 		// All operations will have the path as root&lt;br/&gt;
 		this.client = client.usingNamespace(client.getNamespace() + checkpointsPath);&lt;br/&gt;
 &lt;br/&gt;
-		this.checkpointsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(this.client, stateStorage, executor);&lt;br/&gt;
+		this.checkpointsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(this.client, stateStorage);&lt;br/&gt;
 &lt;br/&gt;
 		this.completedCheckpoints = new ArrayDeque&amp;lt;&amp;gt;(maxNumberOfCheckpointsToRetain + 1);&lt;br/&gt;
 &lt;br/&gt;
+		this.executor = checkNotNull(executor);&lt;br/&gt;
+&lt;br/&gt;
 		LOG.info(&quot;Initialized in &apos;{}&apos;.&quot;, checkpointsPath);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
@@ -236,16 +239,30 @@ public void addCheckpoint(final CompletedCheckpoint checkpoint) throws Exception&lt;br/&gt;
 &lt;br/&gt;
 		// Everything worked, let&apos;s remove a previous checkpoint if necessary.&lt;br/&gt;
 		while (completedCheckpoints.size() &amp;gt; maxNumberOfCheckpointsToRetain) {&lt;br/&gt;
-			try {
-				removeSubsumed(completedCheckpoints.removeFirst());
-			} catch (Exception e) {
-				LOG.warn(&quot;Failed to subsume the old checkpoint&quot;, e);
-			}&lt;br/&gt;
+			final CompletedCheckpoint completedCheckpoint = completedCheckpoints.removeFirst();&lt;br/&gt;
+			tryRemoveCompletedCheckpoint(completedCheckpoint, CompletedCheckpoint::discardOnSubsume);&lt;br/&gt;
 		}&lt;br/&gt;
 &lt;br/&gt;
 		LOG.debug(&quot;Added {} to {}.&quot;, checkpoint, path);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	private void tryRemoveCompletedCheckpoint(CompletedCheckpoint completedCheckpoint, ConsumerWithException&amp;lt;CompletedCheckpoint, Exception&amp;gt; discardCallback) {&lt;br/&gt;
+		try {&lt;br/&gt;
+			if (tryRemove(completedCheckpoint.getCheckpointID())) {&lt;br/&gt;
+				executor.execute(() -&amp;gt; {&lt;br/&gt;
+					try {
+						discardCallback.accept(completedCheckpoint);
+					} catch (Exception e) {&lt;br/&gt;
+						LOG.warn(&quot;Could not discard completed checkpoint {}.&quot;, completedCheckpoint.getCheckpointID(), e);&lt;br/&gt;
+					}&lt;br/&gt;
+				});&lt;br/&gt;
+&lt;br/&gt;
+			}&lt;br/&gt;
+		} catch (Exception e) {
+			LOG.warn(&quot;Failed to subsume the old checkpoint&quot;, e);
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public CompletedCheckpoint getLatestCheckpoint() {&lt;br/&gt;
 		if (completedCheckpoints.isEmpty()) {&lt;br/&gt;
@@ -278,11 +295,9 @@ public void shutdown(JobStatus jobStatus) throws Exception {&lt;br/&gt;
 			LOG.info(&quot;Shutting down&quot;);&lt;br/&gt;
 &lt;br/&gt;
 			for (CompletedCheckpoint checkpoint : completedCheckpoints) {&lt;br/&gt;
-				try {
-					removeShutdown(checkpoint, jobStatus);
-				} catch (Exception e) {
-					LOG.error(&quot;Failed to discard checkpoint.&quot;, e);
-				}&lt;br/&gt;
+				tryRemoveCompletedCheckpoint(&lt;br/&gt;
+					checkpoint,&lt;br/&gt;
+					completedCheckpoint -&amp;gt; completedCheckpoint.discardOnShutdown(jobStatus));&lt;br/&gt;
 			}&lt;br/&gt;
 &lt;br/&gt;
 			completedCheckpoints.clear();&lt;br/&gt;
@@ -305,59 +320,13 @@ public void shutdown(JobStatus jobStatus) throws Exception {&lt;br/&gt;
 	// ------------------------------------------------------------------------&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
-	 * Removes a subsumed checkpoint from ZooKeeper and drops the state.&lt;br/&gt;
-	 */&lt;br/&gt;
-	private void removeSubsumed(&lt;br/&gt;
-		final CompletedCheckpoint completedCheckpoint) throws Exception {&lt;br/&gt;
-&lt;br/&gt;
-		if (completedCheckpoint == null) {
-			return;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt; action =&lt;br/&gt;
-			new ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt;() {&lt;br/&gt;
-				@Override&lt;br/&gt;
-				public void apply(@Nullable RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; value) throws FlinkException {&lt;br/&gt;
-					if (value != null) {&lt;br/&gt;
-						try {
-							completedCheckpoint.discardOnSubsume();
-						} catch (Exception e) {
-							throw new FlinkException(&quot;Could not discard the completed checkpoint on subsume.&quot;, e);
-						}&lt;br/&gt;
-					}&lt;br/&gt;
-				}&lt;br/&gt;
-			};&lt;br/&gt;
-&lt;br/&gt;
-		checkpointsInZooKeeper.releaseAndTryRemove(&lt;br/&gt;
-			checkpointIdToPath(completedCheckpoint.getCheckpointID()),&lt;br/&gt;
-			action);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Removes a checkpoint from ZooKeeper because of Job shutdown and drops the state.&lt;br/&gt;
+	 * Tries to remove the checkpoint identified by the given checkpoint id.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param checkpointId identifying the checkpoint to remove&lt;br/&gt;
+	 * @return true if the checkpoint could be removed&lt;br/&gt;
 	 */&lt;br/&gt;
-	private void removeShutdown(&lt;br/&gt;
-			final CompletedCheckpoint completedCheckpoint,&lt;br/&gt;
-			final JobStatus jobStatus) throws Exception {&lt;br/&gt;
-&lt;br/&gt;
-		if (completedCheckpoint == null) {-			return;-		}&lt;br/&gt;
-&lt;br/&gt;
-		ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt; removeAction = new ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt;() {&lt;br/&gt;
-			@Override&lt;br/&gt;
-			public void apply(@Nullable RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; value) throws FlinkException {&lt;br/&gt;
-				try {
-					completedCheckpoint.discardOnShutdown(jobStatus);
-				} catch (Exception e) {
-					throw new FlinkException(&quot;Could not discard the completed checkpoint on subsume.&quot;, e);
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-		};&lt;br/&gt;
-&lt;br/&gt;
-		checkpointsInZooKeeper.releaseAndTryRemove(&lt;br/&gt;
-			checkpointIdToPath(completedCheckpoint.getCheckpointID()),&lt;br/&gt;
-			removeAction);&lt;br/&gt;
+	private boolean tryRemove(long checkpointId) throws Exception {
+		return checkpointsInZooKeeper.releaseAndTryRemove(checkpointIdToPath(checkpointId));
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -381,7 +350,7 @@ public static long pathToCheckpointId(String path) {&lt;br/&gt;
 			String numberString;&lt;br/&gt;
 &lt;br/&gt;
 			// check if we have a leading slash&lt;br/&gt;
-			if (&apos;/&apos; == path.charAt(0) ) {&lt;br/&gt;
+			if (&apos;/&apos; == path.charAt(0)) {
 				numberString = path.substring(1);
 			} else {
 				numberString = path;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
index c96acbd3192..c31e64c0adc 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
@@ -572,30 +572,38 @@ private void registerJobManagerRunnerTerminationFuture(JobID jobId, CompletableF
 		}&lt;br/&gt;
 &lt;br/&gt;
 		return jobManagerRunnerTerminationFuture.thenRunAsync(&lt;br/&gt;
-			() -&amp;gt; {
-				jobManagerMetricGroup.removeJob(jobId);
+			() -&amp;gt; cleanUpJobData(jobId, cleanupHA),
+			getRpcService().getExecutor());
+	}&lt;br/&gt;
 &lt;br/&gt;
-				boolean cleanupHABlobs = false;&lt;br/&gt;
-				if (cleanupHA) {&lt;br/&gt;
-					try {&lt;br/&gt;
-						submittedJobGraphStore.removeJobGraph(jobId);&lt;br/&gt;
+	private void cleanUpJobData(JobID jobId, boolean cleanupHA) {
+		jobManagerMetricGroup.removeJob(jobId);
 
-						// only clean up the HA blobs if we could remove the job from HA storage
-						cleanupHABlobs = true;
-					} catch (Exception e) {&lt;br/&gt;
-						log.warn(&quot;Could not properly remove job {} from submitted job graph store.&quot;, jobId, e);&lt;br/&gt;
-					}&lt;br/&gt;
+		boolean cleanupHABlobs = false;&lt;br/&gt;
+		if (cleanupHA) {&lt;br/&gt;
+			try {&lt;br/&gt;
+				submittedJobGraphStore.removeJobGraph(jobId);&lt;br/&gt;
 &lt;br/&gt;
-					try {
-						runningJobsRegistry.clearJob(jobId);
-					} catch (IOException e) {&lt;br/&gt;
-						log.warn(&quot;Could not properly remove job {} from the running jobs registry.&quot;, jobId, e);&lt;br/&gt;
-					}&lt;br/&gt;
-				}&lt;br/&gt;
+				// only clean up the HA blobs if we could remove the job from HA storage&lt;br/&gt;
+				cleanupHABlobs = true;&lt;br/&gt;
+			} catch (Exception e) {&lt;br/&gt;
+				log.warn(&quot;Could not properly remove job {} from submitted job graph store.&quot;, jobId, e);&lt;br/&gt;
+			}&lt;br/&gt;
 &lt;br/&gt;
-				blobServer.cleanupJob(jobId, cleanupHABlobs);&lt;br/&gt;
-			},&lt;br/&gt;
-			getRpcService().getExecutor());&lt;br/&gt;
+			try {
+				runningJobsRegistry.clearJob(jobId);
+			} catch (IOException e) {&lt;br/&gt;
+				log.warn(&quot;Could not properly remove job {} from the running jobs registry.&quot;, jobId, e);&lt;br/&gt;
+			}&lt;br/&gt;
+		} else {&lt;br/&gt;
+			try {
+				submittedJobGraphStore.releaseJobGraph(jobId);
+			} catch (Exception e) {&lt;br/&gt;
+				log.warn(&quot;Could not properly release job {} from submitted job graph store.&quot;, jobId, e);&lt;br/&gt;
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		blobServer.cleanupJob(jobId, cleanupHABlobs);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -806,8 +814,7 @@ public void grantLeadership(final UUID newLeaderSessionID) {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	private CompletableFuture&amp;lt;Void&amp;gt; waitForTerminatingJobManager(JobID jobId, JobGraph jobGraph, ConsumerWithException&amp;lt;JobGraph, ?&amp;gt; action) {&lt;br/&gt;
-		final CompletableFuture&amp;lt;Void&amp;gt; jobManagerTerminationFuture = jobManagerTerminationFutures&lt;br/&gt;
-			.getOrDefault(jobId, CompletableFuture.completedFuture(null))&lt;br/&gt;
+		final CompletableFuture&amp;lt;Void&amp;gt; jobManagerTerminationFuture = getJobTerminationFuture(jobId)&lt;br/&gt;
 			.exceptionally((Throwable throwable) -&amp;gt; {&lt;br/&gt;
 				throw new CompletionException(&lt;br/&gt;
 					new DispatcherException(&lt;br/&gt;
@@ -822,6 +829,14 @@ public void grantLeadership(final UUID newLeaderSessionID) {
 			getMainThreadExecutor());
 	}&lt;br/&gt;
 &lt;br/&gt;
+	protected CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;br/&gt;
+		if (jobManagerRunners.containsKey(jobId)) {
+			return FutureUtils.completedExceptionally(new DispatcherException(String.format(&quot;Job with job id %s is still running.&quot;, jobId)));
+		} else {
+			return jobManagerTerminationFutures.getOrDefault(jobId, CompletableFuture.completedFuture(null));
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	private void setNewFencingToken(@Nullable DispatcherId dispatcherId) {&lt;br/&gt;
 		// clear the state if we&apos;ve been the leader before&lt;br/&gt;
 		if (getFencingToken() != null) {&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/SingleJobSubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/SingleJobSubmittedJobGraphStore.java&lt;br/&gt;
index 26d3abc2f1f..fe7f5f14cc8 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/SingleJobSubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/SingleJobSubmittedJobGraphStore.java&lt;br/&gt;
@@ -66,12 +66,17 @@ public void putJobGraph(SubmittedJobGraph jobGraph) throws Exception {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public void removeJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+	public void removeJobGraph(JobID jobId) {
 		// ignore
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) {
+		// ignore
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public Collection&amp;lt;JobID&amp;gt; getJobIds() {
 		return Collections.singleton(jobGraph.getJobID());
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java&lt;br/&gt;
index 3882479ce95..ea96d7d43d2 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java&lt;br/&gt;
@@ -179,7 +179,7 @@ public CheckpointRecoveryFactory getCheckpointRecoveryFactory() {&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
 	public SubmittedJobGraphStore getSubmittedJobGraphStore() throws Exception {
-		return ZooKeeperUtils.createSubmittedJobGraphs(client, configuration, executor);
+		return ZooKeeperUtils.createSubmittedJobGraphs(client, configuration);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java&lt;br/&gt;
index d1ca1a38853..f28621f0d69 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java&lt;br/&gt;
@@ -43,22 +43,27 @@ public void stop() {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public void putJobGraph(SubmittedJobGraph jobGraph) throws Exception {&lt;br/&gt;
+	public void putJobGraph(SubmittedJobGraph jobGraph) {
 		// Nothing to do
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public void removeJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+	public void removeJobGraph(JobID jobId) { 		// Nothing to do 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) {
+		// nothing to do
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public Collection&amp;lt;JobID&amp;gt; getJobIds() {
 		return Collections.emptyList();
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public SubmittedJobGraph recoverJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+	public SubmittedJobGraph recoverJobGraph(JobID jobId) {
 		return null;
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java&lt;br/&gt;
index 7e624ec6e1d..b40a4a2b95f 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java&lt;br/&gt;
@@ -19,6 +19,7 @@&lt;br/&gt;
 package org.apache.flink.runtime.jobmanager;&lt;br/&gt;
 &lt;br/&gt;
 import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
 &lt;br/&gt;
 import javax.annotation.Nullable;&lt;br/&gt;
 &lt;br/&gt;
@@ -58,6 +59,17 @@&lt;br/&gt;
 	 */&lt;br/&gt;
 	void removeJobGraph(JobID jobId) throws Exception;&lt;br/&gt;
 &lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Releases the locks on the specified {@link JobGraph}.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * Releasing the locks allows that another instance can delete the job from&lt;br/&gt;
+	 * the {@link SubmittedJobGraphStore}.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param jobId specifying the job to release the locks for&lt;br/&gt;
+	 * @throws Exception if the locks cannot be released&lt;br/&gt;
+	 */&lt;br/&gt;
+	void releaseJobGraph(JobID jobId) throws Exception;&lt;br/&gt;
+&lt;br/&gt;
 	/**&lt;br/&gt;
 	 * Get all job ids of submitted job graphs to the submitted job graph store.&lt;br/&gt;
 	 *&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java&lt;br/&gt;
index 7ba5d481177..2b935af229a 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java&lt;br/&gt;
@@ -41,7 +41,6 @@&lt;br/&gt;
 import java.util.HashSet;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Set;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
@@ -69,13 +68,13 @@&lt;br/&gt;
 	/** Lock to synchronize with the {@link SubmittedJobGraphListener}. */&lt;br/&gt;
 	private final Object cacheLock = new Object();&lt;br/&gt;
 &lt;br/&gt;
-	/** Client (not a namespace facade) */&lt;br/&gt;
+	/** Client (not a namespace facade). */&lt;br/&gt;
 	private final CuratorFramework client;&lt;br/&gt;
 &lt;br/&gt;
 	/** The set of IDs of all added job graphs. */&lt;br/&gt;
 	private final Set&amp;lt;JobID&amp;gt; addedJobGraphs = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
 &lt;br/&gt;
-	/** Completed checkpoints in ZooKeeper */&lt;br/&gt;
+	/** Completed checkpoints in ZooKeeper. */&lt;br/&gt;
 	private final ZooKeeperStateHandleStore&amp;lt;SubmittedJobGraph&amp;gt; jobGraphsInZooKeeper;&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -94,19 +93,17 @@&lt;br/&gt;
 	private boolean isRunning;&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
-	 * Submitted job graph store backed by ZooKeeper&lt;br/&gt;
+	 * Submitted job graph store backed by ZooKeeper.&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param client ZooKeeper client&lt;br/&gt;
 	 * @param currentJobsPath ZooKeeper path for current job graphs&lt;br/&gt;
 	 * @param stateStorage State storage used to persist the submitted jobs&lt;br/&gt;
-	 * @param executor to give to the ZooKeeperStateHandleStore to run ZooKeeper callbacks&lt;br/&gt;
 	 * @throws Exception&lt;br/&gt;
 	 */&lt;br/&gt;
 	public ZooKeeperSubmittedJobGraphStore(&lt;br/&gt;
 			CuratorFramework client,&lt;br/&gt;
 			String currentJobsPath,&lt;br/&gt;
-			RetrievableStateStorageHelper&amp;lt;SubmittedJobGraph&amp;gt; stateStorage,&lt;br/&gt;
-			Executor executor) throws Exception {&lt;br/&gt;
+			RetrievableStateStorageHelper&amp;lt;SubmittedJobGraph&amp;gt; stateStorage) throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 		checkNotNull(currentJobsPath, &quot;Current jobs path&quot;);&lt;br/&gt;
 		checkNotNull(stateStorage, &quot;State storage&quot;);&lt;br/&gt;
@@ -123,7 +120,7 @@ public ZooKeeperSubmittedJobGraphStore(&lt;br/&gt;
 		CuratorFramework facade = client.usingNamespace(client.getNamespace() + currentJobsPath);&lt;br/&gt;
 &lt;br/&gt;
 		this.zooKeeperFullBasePath = client.getNamespace() + currentJobsPath;&lt;br/&gt;
-		this.jobGraphsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(facade, stateStorage, executor);&lt;br/&gt;
+		this.jobGraphsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(facade, stateStorage);&lt;br/&gt;
 &lt;br/&gt;
 		this.pathCache = new PathChildrenCache(facade, &quot;/&quot;, false);&lt;br/&gt;
 		pathCache.getListenable().addListener(new SubmittedJobGraphsPathCacheListener());&lt;br/&gt;
@@ -276,6 +273,24 @@ public void removeJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
 		LOG.info(&quot;Removed job graph {} from ZooKeeper.&quot;, jobId);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+		checkNotNull(jobId, &quot;Job ID&quot;);&lt;br/&gt;
+		final String path = getPathForJob(jobId);&lt;br/&gt;
+&lt;br/&gt;
+		LOG.debug(&quot;Releasing locks of job graph {} from {}{}.&quot;, jobId, zooKeeperFullBasePath, path);&lt;br/&gt;
+&lt;br/&gt;
+		synchronized (cacheLock) {&lt;br/&gt;
+			if (addedJobGraphs.contains(jobId)) {
+				jobGraphsInZooKeeper.release(path);
+
+				addedJobGraphs.remove(jobId);
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		LOG.info(&quot;Released locks of job graph {} from ZooKeeper.&quot;, jobId);&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
 		Collection&amp;lt;String&amp;gt; paths;&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java&lt;br/&gt;
index 43c930e6fea..cc1ec7044c4 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java&lt;br/&gt;
@@ -54,6 +54,9 @@&lt;br/&gt;
 &lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * Class containing helper functions to interact with ZooKeeper.&lt;br/&gt;
+ */&lt;br/&gt;
 public class ZooKeeperUtils {&lt;br/&gt;
 &lt;br/&gt;
 	private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperUtils.class);&lt;br/&gt;
@@ -227,14 +230,12 @@ public static ZooKeeperLeaderElectionService createLeaderElectionService(&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param client        The {@link CuratorFramework} ZooKeeper client to use&lt;br/&gt;
 	 * @param configuration {@link Configuration} object&lt;br/&gt;
-	 * @param executor to run ZooKeeper callbacks&lt;br/&gt;
 	 * @return {@link ZooKeeperSubmittedJobGraphStore} instance&lt;br/&gt;
 	 * @throws Exception if the submitted job graph store cannot be created&lt;br/&gt;
 	 */&lt;br/&gt;
 	public static ZooKeeperSubmittedJobGraphStore createSubmittedJobGraphs(&lt;br/&gt;
 			CuratorFramework client,&lt;br/&gt;
-			Configuration configuration,&lt;br/&gt;
-			Executor executor) throws Exception {&lt;br/&gt;
+			Configuration configuration) throws Exception {
 
 		checkNotNull(configuration, &quot;Configuration&quot;);
 
@@ -244,7 +245,9 @@ public static ZooKeeperSubmittedJobGraphStore createSubmittedJobGraphs(
 		String zooKeeperSubmittedJobsPath = configuration.getString(HighAvailabilityOptions.HA_ZOOKEEPER_JOBGRAPHS_PATH);
 
 		return new ZooKeeperSubmittedJobGraphStore(
-				client, zooKeeperSubmittedJobsPath, stateStorage, executor);
+			client,
+			zooKeeperSubmittedJobsPath,
+			stateStorage);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -344,6 +347,9 @@ public static String generateZookeeperPath(String root, String namespace) {
 		return root + namespace;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Secure {@link ACLProvider} implementation.&lt;br/&gt;
+	 */&lt;br/&gt;
 	public static class SecureAclProvider implements ACLProvider {&lt;br/&gt;
 		@Override&lt;br/&gt;
 		public List&amp;lt;ACL&amp;gt; getDefaultAcl() {&lt;br/&gt;
@@ -356,6 +362,9 @@ public static String generateZookeeperPath(String root, String namespace) {&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	/**&lt;br/&gt;
+	 * ZooKeeper client ACL mode enum.&lt;br/&gt;
+	 */&lt;br/&gt;
 	public enum ZkClientACLMode {&lt;br/&gt;
 		CREATOR,&lt;br/&gt;
 		OPEN;&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
index f0d67fd2a87..f266e36471c 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
@@ -18,17 +18,13 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.flink.runtime.zookeeper;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
-import org.apache.curator.framework.api.BackgroundCallback;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEvent;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEventType;&lt;br/&gt;
-import org.apache.curator.utils.ZKPaths;&lt;br/&gt;
 import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
 import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
 import org.apache.flink.util.ExceptionUtils;&lt;br/&gt;
-import org.apache.flink.util.FlinkException;&lt;br/&gt;
 import org.apache.flink.util.InstantiationUtil;&lt;br/&gt;
-import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.apache.curator.utils.ZKPaths;&lt;br/&gt;
 import org.apache.zookeeper.CreateMode;&lt;br/&gt;
 import org.apache.zookeeper.KeeperException;&lt;br/&gt;
 import org.apache.zookeeper.data.Stat;&lt;br/&gt;
@@ -36,6 +32,7 @@&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
 &lt;br/&gt;
 import javax.annotation.Nullable;&lt;br/&gt;
+&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.io.Serializable;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
@@ -44,7 +41,6 @@&lt;br/&gt;
 import java.util.ConcurrentModificationException;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.UUID;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
 &lt;br/&gt;
@@ -68,13 +64,13 @@&lt;br/&gt;
  * State handle in ZooKeeper =&amp;gt; State handle exists&lt;br/&gt;
  * &amp;lt;/pre&amp;gt;&lt;br/&gt;
  *&lt;br/&gt;
- * But not:&lt;br/&gt;
+ * &amp;lt;p&amp;gt;But not:&lt;br/&gt;
  *&lt;br/&gt;
  * &amp;lt;pre&amp;gt;&lt;br/&gt;
  * State handle exists =&amp;gt; State handle in ZooKeeper&lt;br/&gt;
  * &amp;lt;/pre&amp;gt;&lt;br/&gt;
  *&lt;br/&gt;
- * There can be lingering state handles when failures happen during operation. They&lt;br/&gt;
+ * &amp;lt;p&amp;gt;There can be lingering state handles when failures happen during operation. They&lt;br/&gt;
  * need to be cleaned up manually (see &amp;lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-2513&quot;&amp;gt;&lt;br/&gt;
  * &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-2513&quot; title=&quot;Extend state handle provider interface to list all state handles&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-2513&quot;&gt;&lt;del&gt;FLINK-2513&lt;/del&gt;&lt;/a&gt;&amp;lt;/a&amp;gt; about a possible way to overcome this).&lt;br/&gt;
  *&lt;br/&gt;
@@ -84,13 +80,11 @@&lt;br/&gt;
 &lt;br/&gt;
 	public static Logger LOG = LoggerFactory.getLogger(ZooKeeperStateHandleStore.class);&lt;br/&gt;
 &lt;br/&gt;
-	/** Curator ZooKeeper client */&lt;br/&gt;
+	/** Curator ZooKeeper client. */&lt;br/&gt;
 	private final CuratorFramework client;&lt;br/&gt;
 &lt;br/&gt;
 	private final RetrievableStateStorageHelper&amp;lt;T&amp;gt; storage;&lt;br/&gt;
 &lt;br/&gt;
-	private final Executor executor;&lt;br/&gt;
-&lt;br/&gt;
 	/** Lock node name of this ZooKeeperStateHandleStore. The name should be unique among all other state handle stores. */&lt;br/&gt;
 	private final String lockNode;&lt;br/&gt;
 &lt;br/&gt;
@@ -103,16 +97,13 @@&lt;br/&gt;
 	 *                            instance, e.g. &amp;lt;code&amp;gt;client.usingNamespace(&quot;/stateHandles&quot;)&amp;lt;/code&amp;gt;&lt;br/&gt;
 	 * @param storage to persist the actual state and whose returned state handle is then written&lt;br/&gt;
 	 *                to ZooKeeper&lt;br/&gt;
-	 * @param executor to run the ZooKeeper callbacks&lt;br/&gt;
 	 */&lt;br/&gt;
 	public ZooKeeperStateHandleStore(&lt;br/&gt;
 		CuratorFramework client,&lt;br/&gt;
-		RetrievableStateStorageHelper&amp;lt;T&amp;gt; storage,&lt;br/&gt;
-		Executor executor) {&lt;br/&gt;
+		RetrievableStateStorageHelper&amp;lt;T&amp;gt; storage) {&lt;br/&gt;
 &lt;br/&gt;
 		this.client = checkNotNull(client, &quot;Curator client&quot;);&lt;br/&gt;
 		this.storage = checkNotNull(storage, &quot;State storage&quot;);&lt;br/&gt;
-		this.executor = checkNotNull(executor);&lt;br/&gt;
 &lt;br/&gt;
 		// Generate a unique lock node name&lt;br/&gt;
 		lockNode = UUID.randomUUID().toString();&lt;br/&gt;
@@ -262,7 +253,7 @@ public int exists(String pathInZooKeeper) throws Exception {&lt;br/&gt;
 	public Collection&amp;lt;String&amp;gt; getAllPaths() throws Exception {&lt;br/&gt;
 		final String path = &quot;/&quot;;&lt;br/&gt;
 &lt;br/&gt;
-		while(true) {&lt;br/&gt;
+		while (true) {&lt;br/&gt;
 			Stat stat = client.checkExists().forPath(path);&lt;br/&gt;
 &lt;br/&gt;
 			if (stat == null) {&lt;br/&gt;
@@ -393,33 +384,14 @@ public int exists(String pathInZooKeeper) throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
 	 * Releases the lock for the given state node and tries to remove the state node if it is no longer locked.&lt;br/&gt;
-	 * The deletion of the state node is executed asynchronously.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Important&amp;lt;/strong&amp;gt;: This also discards the stored state handle after the given action&lt;br/&gt;
-	 * has been executed.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param pathInZooKeeper Path of state handle to remove (expected to start with a &apos;/&apos;)&lt;br/&gt;
-	 * @throws Exception If the ZooKeeper operation fails&lt;br/&gt;
-	 */&lt;br/&gt;
-	public void releaseAndTryRemove(String pathInZooKeeper) throws Exception {
-		releaseAndTryRemove(pathInZooKeeper, null);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Releases the lock for the given state node and tries to remove the state node if it is no longer locked.&lt;br/&gt;
-	 * The deletion of the state node is executed asynchronously. After the state node has been deleted, the given&lt;br/&gt;
-	 * callback is called with the {@link RetrievableStateHandle} of the deleted state node.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Important&amp;lt;/strong&amp;gt;: This also discards the stored state handle after the given action&lt;br/&gt;
-	 * has been executed.&lt;br/&gt;
+	 * It returns the {@link RetrievableStateHandle} stored under the given state node if any.&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param pathInZooKeeper Path of state handle to remove&lt;br/&gt;
-	 * @param callback The callback to execute after a successful deletion. Null if no action needs to be executed.&lt;br/&gt;
-	 * @throws Exception If the ZooKeeper operation fails&lt;br/&gt;
+	 * @return True if the state handle could be released&lt;br/&gt;
+	 * @throws Exception If the ZooKeeper operation or discarding the state handle fails&lt;br/&gt;
 	 */&lt;br/&gt;
-	public void releaseAndTryRemove(&lt;br/&gt;
-			String pathInZooKeeper,&lt;br/&gt;
-			@Nullable final RemoveCallback&amp;lt;T&amp;gt; callback) throws Exception {&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public boolean releaseAndTryRemove(String pathInZooKeeper) throws Exception {&lt;br/&gt;
 		checkNotNull(pathInZooKeeper, &quot;Path in ZooKeeper&quot;);&lt;br/&gt;
 &lt;br/&gt;
 		final String path = normalizePath(pathInZooKeeper);&lt;br/&gt;
@@ -429,14 +401,23 @@ public void releaseAndTryRemove(&lt;br/&gt;
 		try {
 			stateHandle = get(path, false);
 		} catch (Exception e) {&lt;br/&gt;
-			LOG.warn(&quot;Could not retrieve the state handle from node &quot; + path + &apos;.&apos;, e);&lt;br/&gt;
+			LOG.warn(&quot;Could not retrieve the state handle from node {}.&quot;, path, e);&lt;br/&gt;
 		}&lt;br/&gt;
 &lt;br/&gt;
 		release(pathInZooKeeper);&lt;br/&gt;
 &lt;br/&gt;
-		final BackgroundCallback backgroundCallback = new RemoveBackgroundCallback&amp;lt;&amp;gt;(stateHandle, callback, path);&lt;br/&gt;
+		try {
+			client.delete().forPath(path);
+		} catch (KeeperException.NotEmptyException ignored) {&lt;br/&gt;
+			LOG.debug(&quot;Could not delete znode {} because it is still locked.&quot;, path);&lt;br/&gt;
+			return false;&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		if (stateHandle != null) {
+			stateHandle.discardState();
+		}&lt;br/&gt;
 &lt;br/&gt;
-		client.delete().inBackground(backgroundCallback, executor).forPath(path);&lt;br/&gt;
+		return true;&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -583,7 +564,7 @@ protected String getLockPath(String rootPath) {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
-	 * Makes sure that every path starts with a &quot;/&quot;&lt;br/&gt;
+	 * Makes sure that every path starts with a &quot;/&quot;.&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param path Path to normalize&lt;br/&gt;
 	 * @return Normalized path such that it starts with a &quot;/&quot;&lt;br/&gt;
@@ -595,103 +576,4 @@ private static String normalizePath(String path) {
 			return &apos;/&apos; + path;
 		}&lt;br/&gt;
 	}&lt;br/&gt;
-&lt;br/&gt;
-	// ---------------------------------------------------------------------------------------------------------&lt;br/&gt;
-	// Utility classes&lt;br/&gt;
-	// ---------------------------------------------------------------------------------------------------------&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Callback which is executed when removing a node from ZooKeeper. The callback will call the given&lt;br/&gt;
-	 * {@link RemoveCallback} if it is not null. Afterwards, it will discard the given {@link RetrievableStateHandle}&lt;br/&gt;
-	 * if it is not null.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param &amp;lt;T&amp;gt; Type of the value stored in the RetrievableStateHandle&lt;br/&gt;
-	 */&lt;br/&gt;
-	private static final class RemoveBackgroundCallback&amp;lt;T extends Serializable&amp;gt; implements BackgroundCallback {&lt;br/&gt;
-		@Nullable&lt;br/&gt;
-		private final RetrievableStateHandle&amp;lt;T&amp;gt; stateHandle;&lt;br/&gt;
-&lt;br/&gt;
-		@Nullable&lt;br/&gt;
-		private final RemoveCallback&amp;lt;T&amp;gt; callback;&lt;br/&gt;
-&lt;br/&gt;
-		private final String pathInZooKeeper;&lt;br/&gt;
-&lt;br/&gt;
-		private RemoveBackgroundCallback(&lt;br/&gt;
-			@Nullable RetrievableStateHandle&amp;lt;T&amp;gt; stateHandle,&lt;br/&gt;
-			@Nullable RemoveCallback&amp;lt;T&amp;gt; callback,&lt;br/&gt;
-			String pathInZooKeeper) {
-
-			this.stateHandle = stateHandle;
-			this.callback = callback;
-			this.pathInZooKeeper = Preconditions.checkNotNull(pathInZooKeeper);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {&lt;br/&gt;
-			try {&lt;br/&gt;
-				if (event.getType() == CuratorEventType.DELETE) {&lt;br/&gt;
-					final KeeperException.Code resultCode = KeeperException.Code.get(event.getResultCode());&lt;br/&gt;
-&lt;br/&gt;
-					if (resultCode == KeeperException.Code.OK) {&lt;br/&gt;
-						Exception exception = null;&lt;br/&gt;
-&lt;br/&gt;
-						if (null != callback) {&lt;br/&gt;
-							try {
-								callback.apply(stateHandle);
-							} catch (Throwable e) {
-								exception = new Exception(&quot;Could not execute delete action for node &quot; +
-									pathInZooKeeper + &apos;.&apos;, e);
-							}&lt;br/&gt;
-						}&lt;br/&gt;
-&lt;br/&gt;
-						if (stateHandle != null) {&lt;br/&gt;
-							try {
-								// Discard the state handle
-								stateHandle.discardState();
-							} catch (Throwable e) {&lt;br/&gt;
-								Exception newException = new Exception(&quot;Could not discard state handle of node &quot; +&lt;br/&gt;
-									pathInZooKeeper + &apos;.&apos;, e);&lt;br/&gt;
-&lt;br/&gt;
-								if (exception == null) {
-									exception = newException;
-								} else {
-									exception.addSuppressed(newException);
-								}&lt;br/&gt;
-							}&lt;br/&gt;
-						}&lt;br/&gt;
-&lt;br/&gt;
-						if (exception != null) {
-							throw exception;
-						}&lt;br/&gt;
-					} else if (resultCode == KeeperException.Code.NOTEMPTY) {
-						// Could not delete the node because it still contains children/locks
-						LOG.debug(&quot;Could not delete node &quot; + pathInZooKeeper + &quot; because it is still locked.&quot;);
-					} else {
-						throw new IllegalStateException(&quot;Unexpected result code &quot; +
-							resultCode.name() + &quot; in &apos;&quot; + event + &quot;&apos; callback.&quot;);
-					}&lt;br/&gt;
-				} else {
-					throw new IllegalStateException(&quot;Unexpected event type &quot; +
-						event.getType() + &quot; in &apos;&quot; + event + &quot;&apos; callback.&quot;);
-				}&lt;br/&gt;
-			} catch (Exception e) {
-				LOG.warn(&quot;Failed to run callback for delete operation on node &quot; + pathInZooKeeper + &apos;.&apos;, e);
-			}&lt;br/&gt;
-&lt;br/&gt;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Callback interface for remove calls&lt;br/&gt;
-	 */&lt;br/&gt;
-	public interface RemoveCallback&amp;lt;T extends Serializable&amp;gt; {&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * Callback method. The parameter can be null if the {@link RetrievableStateHandle} could not be retrieved&lt;br/&gt;
-		 * from ZooKeeper.&lt;br/&gt;
-		 *&lt;br/&gt;
-		 * @param value RetrievableStateHandle retrieved from ZooKeeper, null if it was not retrievable&lt;br/&gt;
-		 * @throws FlinkException If the callback failed&lt;br/&gt;
-		 */&lt;br/&gt;
-		void apply(@Nullable RetrievableStateHandle&amp;lt;T&amp;gt; value) throws FlinkException;&lt;br/&gt;
-	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java&lt;br/&gt;
index d3b7dc5b379..3e294e0dbdd 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java&lt;br/&gt;
@@ -18,15 +18,15 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.flink.runtime.zookeeper;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
-import org.apache.curator.framework.recipes.shared.SharedCount;&lt;br/&gt;
-import org.apache.curator.framework.recipes.shared.SharedValue;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
 import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;br/&gt;
 &lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.apache.curator.framework.recipes.shared.SharedCount;&lt;br/&gt;
+import org.apache.curator.framework.recipes.shared.SharedValue;&lt;br/&gt;
+&lt;br/&gt;
 import java.io.Serializable;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * Creates ZooKeeper utility classes without exposing the {@link CuratorFramework} dependency. The&lt;br/&gt;
@@ -71,7 +71,6 @@ public void close(boolean cleanup) throws Exception {&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param zkStateHandleStorePath specifying the path in ZooKeeper to store the state handles to&lt;br/&gt;
 	 * @param stateStorageHelper storing the actual state data&lt;br/&gt;
-	 * @param executor to run asynchronous callbacks of the state handle store&lt;br/&gt;
 	 * @param &amp;lt;T&amp;gt; Type of the state to be stored&lt;br/&gt;
 	 * @return a ZooKeeperStateHandleStore instance&lt;br/&gt;
 	 * @throws Exception if ZooKeeper could not create the provided state handle store path in&lt;br/&gt;
@@ -79,8 +78,7 @@ public void close(boolean cleanup) throws Exception {&lt;br/&gt;
 	 */&lt;br/&gt;
 	public &amp;lt;T extends Serializable&amp;gt; ZooKeeperStateHandleStore&amp;lt;T&amp;gt; createZooKeeperStateHandleStore(&lt;br/&gt;
 			String zkStateHandleStorePath,&lt;br/&gt;
-			RetrievableStateStorageHelper&amp;lt;T&amp;gt; stateStorageHelper,&lt;br/&gt;
-			Executor executor) throws Exception {&lt;br/&gt;
+			RetrievableStateStorageHelper&amp;lt;T&amp;gt; stateStorageHelper) throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 		facade.newNamespaceAwareEnsurePath(zkStateHandleStorePath).ensure(facade.getZookeeperClient());&lt;br/&gt;
 		CuratorFramework stateHandleStoreFacade = facade.usingNamespace(&lt;br/&gt;
@@ -88,7 +86,7 @@ public void close(boolean cleanup) throws Exception {
 				facade.getNamespace(),
 				zkStateHandleStorePath));
 
-		return new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(stateHandleStoreFacade, stateStorageHelper, executor);
+		return new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(stateHandleStoreFacade, stateStorageHelper);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
diff --git a/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala b/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala&lt;br/&gt;
index 1828baa17df..2000f7d961a 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala&lt;br/&gt;
+++ b/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala&lt;br/&gt;
@@ -1728,21 +1728,22 @@ class JobManager(&lt;br/&gt;
     val futureOption = currentJobs.remove(jobID) match {&lt;br/&gt;
       case Some((eg, _)) =&amp;gt;&lt;br/&gt;
         val cleanUpFuture: Future&lt;span class=&quot;error&quot;&gt;&amp;#91;Unit&amp;#93;&lt;/span&gt; = Future {&lt;br/&gt;
-          val cleanupHABlobs = if (removeJobFromStateBackend) {&lt;br/&gt;
-            try {&lt;br/&gt;
+          val cleanupHABlobs = try {&lt;br/&gt;
+            if (removeJobFromStateBackend) {
               // ...otherwise, we can have lingering resources when there is a  concurrent shutdown
               // and the ZooKeeper client is closed. Not removing the job immediately allow the
               // shutdown to release all resources.
               submittedJobGraphs.removeJobGraph(jobID)
               true
-            } catch {&lt;br/&gt;
-              case t: Throwable =&amp;gt; {
-                log.warn(s&quot;Could not remove submitted job graph $jobID.&quot;, t)
-                false
-              }&lt;br/&gt;
+            } else {
+              submittedJobGraphs.releaseJobGraph(jobID)
+              false
+            }&lt;br/&gt;
+          } catch {&lt;br/&gt;
+            case t: Throwable =&amp;gt; {
+              log.warn(s&quot;Could not remove submitted job graph $jobID.&quot;, t)
+              false
             }&lt;br/&gt;
-          } else {
-            false
           }&lt;br/&gt;
 &lt;br/&gt;
           blobServer.cleanupJob(jobID, cleanupHABlobs)&lt;br/&gt;
@@ -1777,19 +1778,23 @@ class JobManager(&lt;br/&gt;
     */&lt;br/&gt;
   private def cancelAndClearEverything(cause: Throwable)&lt;br/&gt;
     : Seq[Future&lt;span class=&quot;error&quot;&gt;&amp;#91;Unit&amp;#93;&lt;/span&gt;] = {&lt;br/&gt;
-    val futures = for ((jobID, (eg, jobInfo)) &amp;lt;- currentJobs) yield {&lt;br/&gt;
-      future {&lt;br/&gt;
-        eg.suspend(cause)&lt;br/&gt;
-        jobManagerMetricGroup.removeJob(eg.getJobID)&lt;br/&gt;
+&lt;br/&gt;
+    val futures = currentJobs.values.flatMap(&lt;br/&gt;
+      egJobInfo =&amp;gt; {
+        val executionGraph = egJobInfo._1
+        val jobInfo = egJobInfo._2
+
+        executionGraph.suspend(cause)
+
+        val jobId = executionGraph.getJobID
 
         jobInfo.notifyNonDetachedClients(
           decorateMessage(
             Failure(
-              new JobExecutionException(jobID, &quot;All jobs are cancelled and cleared.&quot;, cause))))
-      }(context.dispatcher)&lt;br/&gt;
-    }&lt;br/&gt;
+              new JobExecutionException(jobId, &quot;All jobs are cancelled and cleared.&quot;, cause))))&lt;br/&gt;
 &lt;br/&gt;
-    currentJobs.clear()&lt;br/&gt;
+        removeJob(jobId, false)&lt;br/&gt;
+      })&lt;br/&gt;
 &lt;br/&gt;
     futures.toSeq&lt;br/&gt;
   }&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java&lt;br/&gt;
index 81569649663..c4d89030dc3 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java&lt;br/&gt;
@@ -193,7 +193,7 @@ public void testDiscardAllCheckpoints() throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 	// ---------------------------------------------------------------------------------------------&lt;br/&gt;
 &lt;br/&gt;
-	protected TestCompletedCheckpoint createCheckpoint(&lt;br/&gt;
+	public static TestCompletedCheckpoint createCheckpoint(&lt;br/&gt;
 		int id,&lt;br/&gt;
 		SharedStateRegistry sharedStateRegistry) throws IOException {
 
@@ -226,7 +226,12 @@ protected void verifyCheckpointRegistered(Collection&amp;lt;OperatorState&amp;gt; operatorStat
 		}&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
-	protected void verifyCheckpointDiscarded(Collection&amp;lt;OperatorState&amp;gt; operatorStates) {&lt;br/&gt;
+	public static void verifyCheckpointDiscarded(TestCompletedCheckpoint completedCheckpoint) {
+		assertTrue(completedCheckpoint.isDiscarded());
+		verifyCheckpointDiscarded(completedCheckpoint.getOperatorStates().values());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	protected static void verifyCheckpointDiscarded(Collection&amp;lt;OperatorState&amp;gt; operatorStates) {&lt;br/&gt;
 		for (OperatorState operatorState : operatorStates) {&lt;br/&gt;
 			for (OperatorSubtaskState subtaskState : operatorState.getStates()) {&lt;br/&gt;
 				Assert.assertTrue(((TestOperatorSubtaskState)subtaskState).discarded);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..1f7d3691e50&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java&lt;br/&gt;
@@ -0,0 +1,261 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.checkpoint;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
+import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
+import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.apache.curator.framework.api.BackgroundCallback;&lt;br/&gt;
+import org.apache.curator.framework.api.CuratorEvent;&lt;br/&gt;
+import org.apache.curator.framework.api.CuratorEventType;&lt;br/&gt;
+import org.apache.curator.framework.api.ErrorListenerPathable;&lt;br/&gt;
+import org.apache.curator.utils.EnsurePath;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.runner.RunWith;&lt;br/&gt;
+import org.mockito.Mockito;&lt;br/&gt;
+import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
+import org.mockito.stubbing.Answer;&lt;br/&gt;
+import org.powermock.core.classloader.annotations.PrepareForTest;&lt;br/&gt;
+import org.powermock.modules.junit4.PowerMockRunner;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.ArrayList;&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.Collections;&lt;br/&gt;
+import java.util.HashMap;&lt;br/&gt;
+import java.util.HashSet;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+import java.util.concurrent.Executor;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertEquals;&lt;br/&gt;
+import static org.junit.Assert.assertFalse;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+import static org.mockito.Matchers.any;&lt;br/&gt;
+import static org.mockito.Matchers.anyString;&lt;br/&gt;
+import static org.mockito.Mockito.doReturn;&lt;br/&gt;
+import static org.mockito.Mockito.mock;&lt;br/&gt;
+import static org.mockito.Mockito.never;&lt;br/&gt;
+import static org.mockito.Mockito.spy;&lt;br/&gt;
+import static org.mockito.Mockito.verify;&lt;br/&gt;
+import static org.mockito.Mockito.when;&lt;br/&gt;
+import static org.powermock.api.mockito.PowerMockito.doAnswer;&lt;br/&gt;
+import static org.powermock.api.mockito.PowerMockito.doThrow;&lt;br/&gt;
+import static org.powermock.api.mockito.PowerMockito.whenNew;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Mockito based tests for the {@link ZooKeeperStateHandleStore}.&lt;br/&gt;
+ */&lt;br/&gt;
+@RunWith(PowerMockRunner.class)&lt;br/&gt;
+@PrepareForTest(ZooKeeperCompletedCheckpointStore.class)&lt;br/&gt;
+public class ZooKeeperCompletedCheckpointStoreMockitoTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the completed checkpoint store can retrieve all checkpoints stored in ZooKeeper&lt;br/&gt;
+	 * and ignores those which cannot be retrieved via their state handles.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * &amp;lt;p&amp;gt;We have a timeout in case the ZooKeeper store get&apos;s into a deadlock/livelock situation.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test(timeout = 50000)&lt;br/&gt;
+	public void testCheckpointRecovery() throws Exception {&lt;br/&gt;
+		final JobID jobID = new JobID();&lt;br/&gt;
+		final long checkpoint1Id = 1L;&lt;br/&gt;
+		final long checkpoint2Id = 2;&lt;br/&gt;
+		final List&amp;lt;Tuple2&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;, String&amp;gt;&amp;gt; checkpointsInZooKeeper = new ArrayList&amp;lt;&amp;gt;(4);&lt;br/&gt;
+&lt;br/&gt;
+		final Collection&amp;lt;Long&amp;gt; expectedCheckpointIds = new HashSet&amp;lt;&amp;gt;(2);&lt;br/&gt;
+		expectedCheckpointIds.add(1L);&lt;br/&gt;
+		expectedCheckpointIds.add(2L);&lt;br/&gt;
+&lt;br/&gt;
+		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; failingRetrievableStateHandle = mock(RetrievableStateHandle.class);&lt;br/&gt;
+		when(failingRetrievableStateHandle.retrieveState()).thenThrow(new IOException(&quot;Test exception&quot;));&lt;br/&gt;
+&lt;br/&gt;
+		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle1 = mock(RetrievableStateHandle.class);&lt;br/&gt;
+		when(retrievableStateHandle1.retrieveState()).then(&lt;br/&gt;
+			(invocation) -&amp;gt; new CompletedCheckpoint(&lt;br/&gt;
+				jobID,&lt;br/&gt;
+				checkpoint1Id,&lt;br/&gt;
+				1L,&lt;br/&gt;
+				1L,&lt;br/&gt;
+				new HashMap&amp;lt;&amp;gt;(),&lt;br/&gt;
+				null,&lt;br/&gt;
+				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),&lt;br/&gt;
+				new TestCompletedCheckpointStorageLocation()));&lt;br/&gt;
+&lt;br/&gt;
+		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle2 = mock(RetrievableStateHandle.class);&lt;br/&gt;
+		when(retrievableStateHandle2.retrieveState()).then(&lt;br/&gt;
+			(invocation -&amp;gt; new CompletedCheckpoint(&lt;br/&gt;
+				jobID,&lt;br/&gt;
+				checkpoint2Id,&lt;br/&gt;
+				2L,&lt;br/&gt;
+				2L,&lt;br/&gt;
+				new HashMap&amp;lt;&amp;gt;(),&lt;br/&gt;
+				null,&lt;br/&gt;
+				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),&lt;br/&gt;
+				new TestCompletedCheckpointStorageLocation())));&lt;br/&gt;
+&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle1, &quot;/foobar1&quot;));&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing1&quot;));&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle2, &quot;/foobar2&quot;));&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing2&quot;));&lt;br/&gt;
+&lt;br/&gt;
+		final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zooKeeperStateHandleStoreMock = spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock));&lt;br/&gt;
+		whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zooKeeperStateHandleStoreMock);&lt;br/&gt;
+		doReturn(checkpointsInZooKeeper).when(zooKeeperStateHandleStoreMock).getAllSortedByNameAndLock();&lt;br/&gt;
+&lt;br/&gt;
+		final int numCheckpointsToRetain = 1;&lt;br/&gt;
+&lt;br/&gt;
+		// Mocking for the delete operation on the CuratorFramework client&lt;br/&gt;
+		// It assures that the callback is executed synchronously&lt;br/&gt;
+&lt;br/&gt;
+		final EnsurePath ensurePathMock = mock(EnsurePath.class);&lt;br/&gt;
+		final CuratorEvent curatorEventMock = mock(CuratorEvent.class);&lt;br/&gt;
+		when(curatorEventMock.getType()).thenReturn(CuratorEventType.DELETE);&lt;br/&gt;
+		when(curatorEventMock.getResultCode()).thenReturn(0);&lt;br/&gt;
+		when(client.newNamespaceAwareEnsurePath(anyString())).thenReturn(ensurePathMock);&lt;br/&gt;
+&lt;br/&gt;
+		when(&lt;br/&gt;
+			client&lt;br/&gt;
+				.delete()&lt;br/&gt;
+				.inBackground(any(BackgroundCallback.class), any(Executor.class))&lt;br/&gt;
+		).thenAnswer(new Answer&amp;lt;ErrorListenerPathable&amp;lt;Void&amp;gt;&amp;gt;() {&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public ErrorListenerPathable&amp;lt;Void&amp;gt; answer(InvocationOnMock invocation) throws Throwable {&lt;br/&gt;
+				final BackgroundCallback callback = (BackgroundCallback) invocation.getArguments()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+&lt;br/&gt;
+				ErrorListenerPathable&amp;lt;Void&amp;gt; result = mock(ErrorListenerPathable.class);&lt;br/&gt;
+&lt;br/&gt;
+				when(result.forPath(anyString())).thenAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
+					@Override&lt;br/&gt;
+					public Void answer(InvocationOnMock invocation) throws Throwable {
+
+						callback.processResult(client, curatorEventMock);
+
+						return null;
+					}&lt;br/&gt;
+				});&lt;br/&gt;
+&lt;br/&gt;
+				return result;&lt;br/&gt;
+			}&lt;br/&gt;
+		});&lt;br/&gt;
+&lt;br/&gt;
+		final String checkpointsPath = &quot;foobar&quot;;&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateStorage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
+			numCheckpointsToRetain,&lt;br/&gt;
+			client,&lt;br/&gt;
+			checkpointsPath,&lt;br/&gt;
+			stateStorage,&lt;br/&gt;
+			Executors.directExecutor());&lt;br/&gt;
+&lt;br/&gt;
+		zooKeeperCompletedCheckpointStore.recover();&lt;br/&gt;
+&lt;br/&gt;
+		CompletedCheckpoint latestCompletedCheckpoint = zooKeeperCompletedCheckpointStore.getLatestCheckpoint();&lt;br/&gt;
+&lt;br/&gt;
+		// check that we return the latest retrievable checkpoint&lt;br/&gt;
+		// this should remove the latest checkpoint because it is broken&lt;br/&gt;
+		assertEquals(checkpoint2Id, latestCompletedCheckpoint.getCheckpointID());&lt;br/&gt;
+&lt;br/&gt;
+		// this should remove the second broken checkpoint because we&apos;re iterating over all checkpoints&lt;br/&gt;
+		List&amp;lt;CompletedCheckpoint&amp;gt; completedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();&lt;br/&gt;
+&lt;br/&gt;
+		Collection&amp;lt;Long&amp;gt; actualCheckpointIds = new HashSet&amp;lt;&amp;gt;(completedCheckpoints.size());&lt;br/&gt;
+&lt;br/&gt;
+		for (CompletedCheckpoint completedCheckpoint : completedCheckpoints) {
+			actualCheckpointIds.add(completedCheckpoint.getCheckpointID());
+		}&lt;br/&gt;
+&lt;br/&gt;
+		assertEquals(expectedCheckpointIds, actualCheckpointIds);&lt;br/&gt;
+&lt;br/&gt;
+		// check that we did not discard any of the state handles&lt;br/&gt;
+		verify(retrievableStateHandle1, never()).discardState();&lt;br/&gt;
+		verify(retrievableStateHandle2, never()).discardState();&lt;br/&gt;
+&lt;br/&gt;
+		// Make sure that we also didn&apos;t discard any of the broken handles. Only when checkpoints&lt;br/&gt;
+		// are subsumed should they be discarded.&lt;br/&gt;
+		verify(failingRetrievableStateHandle, never()).discardState();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the checkpoint does not exist in the store when we fail to add&lt;br/&gt;
+	 * it into the store (i.e., there exists an exception thrown by the method).&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testAddCheckpointWithFailedRemove() throws Exception {&lt;br/&gt;
+		final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zookeeperStateHandleStoreMock =&lt;br/&gt;
+			spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock));&lt;br/&gt;
+		whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zookeeperStateHandleStoreMock);&lt;br/&gt;
+&lt;br/&gt;
+		doAnswer(new Answer&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;&amp;gt;() {&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; answer(InvocationOnMock invocationOnMock) throws Throwable {
+				CompletedCheckpoint checkpoint = (CompletedCheckpoint) invocationOnMock.getArguments()[1];
+
+				RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle = mock(RetrievableStateHandle.class);
+				when(retrievableStateHandle.retrieveState()).thenReturn(checkpoint);
+
+				return retrievableStateHandle;
+			}&lt;br/&gt;
+		}).when(zookeeperStateHandleStoreMock).addAndLock(anyString(), any(CompletedCheckpoint.class));&lt;br/&gt;
+&lt;br/&gt;
+		doThrow(new Exception()).when(zookeeperStateHandleStoreMock).releaseAndTryRemove(anyString());&lt;br/&gt;
+&lt;br/&gt;
+		final int numCheckpointsToRetain = 1;&lt;br/&gt;
+		final String checkpointsPath = &quot;foobar&quot;;&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateSotrage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
+			numCheckpointsToRetain,&lt;br/&gt;
+			client,&lt;br/&gt;
+			checkpointsPath,&lt;br/&gt;
+			stateSotrage,&lt;br/&gt;
+			Executors.directExecutor());&lt;br/&gt;
+&lt;br/&gt;
+		for (long i = 0; i &amp;lt;= numCheckpointsToRetain; ++i) {&lt;br/&gt;
+			CompletedCheckpoint checkpointToAdd = mock(CompletedCheckpoint.class);&lt;br/&gt;
+			doReturn&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.when(checkpointToAdd).getCheckpointID();&lt;br/&gt;
+			doReturn(Collections.emptyMap()).when(checkpointToAdd).getOperatorStates();&lt;br/&gt;
+&lt;br/&gt;
+			try {
+				zooKeeperCompletedCheckpointStore.addCheckpoint(checkpointToAdd);
+
+				// The checkpoint should be in the store if we successfully add it into the store.
+				List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();
+				assertTrue(addedCheckpoints.contains(checkpointToAdd));
+			} catch (Exception e) {
+				// The checkpoint should not be in the store if any exception is thrown.
+				List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();
+				assertFalse(addedCheckpoints.contains(checkpointToAdd));
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java&lt;br/&gt;
index 0384733fdb1..f992d3b00c0 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java&lt;br/&gt;
@@ -18,60 +18,39 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.flink.runtime.checkpoint;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.flink.api.common.JobID;&lt;br/&gt;
-import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.configuration.Configuration;&lt;br/&gt;
+import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobStatus;&lt;br/&gt;
 import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
-import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;&lt;br/&gt;
+import org.apache.flink.runtime.state.SharedStateRegistry;&lt;br/&gt;
+import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;&lt;br/&gt;
-import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
 &lt;br/&gt;
 import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
-import org.apache.curator.framework.api.BackgroundCallback;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEvent;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEventType;&lt;br/&gt;
-import org.apache.curator.framework.api.ErrorListenerPathable;&lt;br/&gt;
-import org.apache.curator.utils.EnsurePath;&lt;br/&gt;
+import org.hamcrest.Matchers;&lt;br/&gt;
+import org.junit.ClassRule;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
-import org.junit.runner.RunWith;&lt;br/&gt;
-import org.mockito.Mockito;&lt;br/&gt;
-import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
-import org.mockito.stubbing.Answer;&lt;br/&gt;
-import org.powermock.core.classloader.annotations.PrepareForTest;&lt;br/&gt;
-import org.powermock.modules.junit4.PowerMockRunner;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
 &lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
-import java.util.ArrayList;&lt;br/&gt;
-import java.util.Collection;&lt;br/&gt;
-import java.util.Collections;&lt;br/&gt;
-import java.util.HashMap;&lt;br/&gt;
-import java.util.HashSet;&lt;br/&gt;
+import java.io.Serializable;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 import static org.junit.Assert.assertEquals;&lt;br/&gt;
-import static org.junit.Assert.assertFalse;&lt;br/&gt;
-import static org.junit.Assert.assertTrue;&lt;br/&gt;
-import static org.mockito.Matchers.any;&lt;br/&gt;
-import static org.mockito.Matchers.anyString;&lt;br/&gt;
-import static org.mockito.Mockito.doReturn;&lt;br/&gt;
-import static org.mockito.Mockito.mock;&lt;br/&gt;
-import static org.mockito.Mockito.never;&lt;br/&gt;
-import static org.mockito.Mockito.spy;&lt;br/&gt;
-import static org.mockito.Mockito.verify;&lt;br/&gt;
-import static org.mockito.Mockito.when;&lt;br/&gt;
-import static org.powermock.api.mockito.PowerMockito.doAnswer;&lt;br/&gt;
-import static org.powermock.api.mockito.PowerMockito.doThrow;&lt;br/&gt;
-import static org.powermock.api.mockito.PowerMockito.whenNew;&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * Tests for {@link ZooKeeperCompletedCheckpointStore}
&lt;p&gt;.&lt;br/&gt;
  */&lt;br/&gt;
-@RunWith(PowerMockRunner.class)&lt;br/&gt;
-@PrepareForTest(ZooKeeperCompletedCheckpointStore.class)&lt;br/&gt;
 public class ZooKeeperCompletedCheckpointStoreTest extends TestLogger {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	@ClassRule&lt;br/&gt;
+	public static ZooKeeperResource zooKeeperResource = new ZooKeeperResource();&lt;br/&gt;
+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testPathConversion() {&lt;br/&gt;
 		final long checkpointId = 42L;&lt;br/&gt;
@@ -82,188 +61,103 @@ public void testPathConversion() {&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Tests that the completed checkpoint store can retrieve all checkpoints stored in ZooKeeper&lt;/li&gt;
	&lt;li&gt;* and ignores those which cannot be retrieved via their state handles.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;We have a timeout in case the ZooKeeper store get&apos;s into a deadlock/livelock situation.&lt;br/&gt;
+	 * Tests that subsumed checkpoints are discarded.&lt;br/&gt;
 	 */&lt;/li&gt;
	&lt;li&gt;@Test(timeout = 50000)&lt;/li&gt;
	&lt;li&gt;public void testCheckpointRecovery() throws Exception {&lt;/li&gt;
	&lt;li&gt;final JobID jobID = new JobID();&lt;/li&gt;
	&lt;li&gt;final long checkpoint1Id = 1L;&lt;/li&gt;
	&lt;li&gt;final long checkpoint2Id = 2;&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;Tuple2&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;, String&amp;gt;&amp;gt; checkpointsInZooKeeper = new ArrayList&amp;lt;&amp;gt;(4);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final Collection&amp;lt;Long&amp;gt; expectedCheckpointIds = new HashSet&amp;lt;&amp;gt;(2);&lt;/li&gt;
	&lt;li&gt;expectedCheckpointIds.add(1L);&lt;/li&gt;
	&lt;li&gt;expectedCheckpointIds.add(2L);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; failingRetrievableStateHandle = mock(RetrievableStateHandle.class);&lt;/li&gt;
	&lt;li&gt;when(failingRetrievableStateHandle.retrieveState()).thenThrow(new IOException(&quot;Test exception&quot;));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle1 = mock(RetrievableStateHandle.class);&lt;/li&gt;
	&lt;li&gt;when(retrievableStateHandle1.retrieveState()).then(&lt;/li&gt;
	&lt;li&gt;(invocation) -&amp;gt; new CompletedCheckpoint(&lt;/li&gt;
	&lt;li&gt;jobID,&lt;/li&gt;
	&lt;li&gt;checkpoint1Id,&lt;/li&gt;
	&lt;li&gt;1L,&lt;/li&gt;
	&lt;li&gt;1L,&lt;/li&gt;
	&lt;li&gt;new HashMap&amp;lt;&amp;gt;(),&lt;/li&gt;
	&lt;li&gt;null,&lt;/li&gt;
	&lt;li&gt;CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),&lt;/li&gt;
	&lt;li&gt;new TestCompletedCheckpointStorageLocation()));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle2 = mock(RetrievableStateHandle.class);&lt;/li&gt;
	&lt;li&gt;when(retrievableStateHandle2.retrieveState()).then(&lt;/li&gt;
	&lt;li&gt;(invocation -&amp;gt; new CompletedCheckpoint(&lt;/li&gt;
	&lt;li&gt;jobID,&lt;/li&gt;
	&lt;li&gt;checkpoint2Id,&lt;/li&gt;
	&lt;li&gt;2L,&lt;/li&gt;
	&lt;li&gt;2L,&lt;/li&gt;
	&lt;li&gt;new HashMap&amp;lt;&amp;gt;(),&lt;/li&gt;
	&lt;li&gt;null,&lt;/li&gt;
	&lt;li&gt;CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),&lt;/li&gt;
	&lt;li&gt;new TestCompletedCheckpointStorageLocation())));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle1, &quot;/foobar1&quot;));&lt;/li&gt;
	&lt;li&gt;checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing1&quot;));&lt;/li&gt;
	&lt;li&gt;checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle2, &quot;/foobar2&quot;));&lt;/li&gt;
	&lt;li&gt;checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing2&quot;));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;/li&gt;
	&lt;li&gt;final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zooKeeperStateHandleStoreMock = spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock, Executors.directExecutor()));&lt;/li&gt;
	&lt;li&gt;whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zooKeeperStateHandleStoreMock);&lt;/li&gt;
	&lt;li&gt;doReturn(checkpointsInZooKeeper).when(zooKeeperStateHandleStoreMock).getAllSortedByNameAndLock();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final int numCheckpointsToRetain = 1;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Mocking for the delete operation on the CuratorFramework client&lt;/li&gt;
	&lt;li&gt;// It assures that the callback is executed synchronously&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final EnsurePath ensurePathMock = mock(EnsurePath.class);&lt;/li&gt;
	&lt;li&gt;final CuratorEvent curatorEventMock = mock(CuratorEvent.class);&lt;/li&gt;
	&lt;li&gt;when(curatorEventMock.getType()).thenReturn(CuratorEventType.DELETE);&lt;/li&gt;
	&lt;li&gt;when(curatorEventMock.getResultCode()).thenReturn(0);&lt;/li&gt;
	&lt;li&gt;when(client.newNamespaceAwareEnsurePath(anyString())).thenReturn(ensurePathMock);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;when(&lt;/li&gt;
	&lt;li&gt;client&lt;/li&gt;
	&lt;li&gt;.delete()&lt;/li&gt;
	&lt;li&gt;.inBackground(any(BackgroundCallback.class), any(Executor.class))&lt;/li&gt;
	&lt;li&gt;).thenAnswer(new Answer&amp;lt;ErrorListenerPathable&amp;lt;Void&amp;gt;&amp;gt;() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public ErrorListenerPathable&amp;lt;Void&amp;gt; answer(InvocationOnMock invocation) throws Throwable {&lt;/li&gt;
	&lt;li&gt;final BackgroundCallback callback = (BackgroundCallback) invocation.getArguments()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testDiscardingSubsumedCheckpoints() throws Exception 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		final SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();+		final Configuration configuration = new Configuration();+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString());++		final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);+		final ZooKeeperCompletedCheckpointStore checkpointStore = createZooKeeperCheckpointStore(client);++		try {
+			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint1 = CompletedCheckpointStoreTest.createCheckpoint(0, sharedStateRegistry);
+
+			checkpointStore.addCheckpoint(checkpoint1);
+			assertThat(checkpointStore.getAllCheckpoints(), Matchers.contains(checkpoint1));
+
+			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint2 = CompletedCheckpointStoreTest.createCheckpoint(1, sharedStateRegistry);
+			checkpointStore.addCheckpoint(checkpoint2);
+			final List&amp;lt;CompletedCheckpoint&amp;gt; allCheckpoints = checkpointStore.getAllCheckpoints();
+			assertThat(allCheckpoints, Matchers.contains(checkpoint2));
+			assertThat(allCheckpoints, Matchers.not(Matchers.contains(checkpoint1)));
+
+			// verify that the subsumed checkpoint is discarded
+			CompletedCheckpointStoreTest.verifyCheckpointDiscarded(checkpoint1);
+		} finally {
+			client.close();
+		}&lt;br/&gt;
+	}&lt;br/&gt;
 &lt;br/&gt;
-				ErrorListenerPathable&amp;lt;Void&amp;gt; result = mock(ErrorListenerPathable.class);&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that checkpoints are discarded when the completed checkpoint store is shut&lt;br/&gt;
+	 * down with a globally terminal state.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testDiscardingCheckpointsAtShutDown() throws Exception {&lt;br/&gt;
+		final SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString());&lt;br/&gt;
 &lt;br/&gt;
-				when(result.forPath(anyString())).thenAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
-					@Override&lt;br/&gt;
-					public Void answer(InvocationOnMock invocation) throws Throwable {&lt;br/&gt;
+		final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+		final ZooKeeperCompletedCheckpointStore checkpointStore = createZooKeeperCheckpointStore(client);&lt;br/&gt;
 &lt;br/&gt;
-						callback.processResult(client, curatorEventMock);&lt;br/&gt;
+		try {
+			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint1 = CompletedCheckpointStoreTest.createCheckpoint(0, sharedStateRegistry);
 
-						return null;
-					}&lt;br/&gt;
-				});&lt;br/&gt;
+			checkpointStore.addCheckpoint(checkpoint1);&lt;br/&gt;
+			assertThat(checkpointStore.getAllCheckpoints(), Matchers.contains(checkpoint1));&lt;br/&gt;
 &lt;br/&gt;
-				return result;&lt;br/&gt;
-			}&lt;br/&gt;
-		});&lt;br/&gt;
+			checkpointStore.shutdown(JobStatus.FINISHED);&lt;br/&gt;
 &lt;br/&gt;
-		final String checkpointsPath = &quot;foobar&quot;;&lt;br/&gt;
-		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateStorage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+			// verify that the checkpoint is discarded&lt;br/&gt;
+			CompletedCheckpointStoreTest.verifyCheckpointDiscarded(checkpoint1);&lt;br/&gt;
+		} finally {+			client.close();+		}+	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;/li&gt;
	&lt;li&gt;numCheckpointsToRetain,&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private ZooKeeperCompletedCheckpointStore createZooKeeperCheckpointStore(CuratorFramework client) throws Exception 
{
+		return new ZooKeeperCompletedCheckpointStore(
+			1,
 			client,
-			checkpointsPath,
-			stateStorage,
+			&quot;/checkpoints&quot;,
+			new TestingRetrievableStateStorageHelper&amp;lt;&amp;gt;(),
 			Executors.directExecutor());
+	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;zooKeeperCompletedCheckpointStore.recover();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;CompletedCheckpoint latestCompletedCheckpoint = zooKeeperCompletedCheckpointStore.getLatestCheckpoint();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// check that we return the latest retrievable checkpoint&lt;/li&gt;
	&lt;li&gt;// this should remove the latest checkpoint because it is broken&lt;/li&gt;
	&lt;li&gt;assertEquals(checkpoint2Id, latestCompletedCheckpoint.getCheckpointID());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// this should remove the second broken checkpoint because we&apos;re iterating over all checkpoints&lt;/li&gt;
	&lt;li&gt;List&amp;lt;CompletedCheckpoint&amp;gt; completedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;Collection&amp;lt;Long&amp;gt; actualCheckpointIds = new HashSet&amp;lt;&amp;gt;(completedCheckpoints.size());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;for (CompletedCheckpoint completedCheckpoint : completedCheckpoints) {&lt;/li&gt;
	&lt;li&gt;actualCheckpointIds.add(completedCheckpoint.getCheckpointID());&lt;br/&gt;
+	private static final class TestingRetrievableStateStorageHelper&amp;lt;T extends Serializable&amp;gt; implements RetrievableStateStorageHelper&amp;lt;T&amp;gt; {&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public RetrievableStateHandle&amp;lt;T&amp;gt; store(T state) 
{
+			return new TestingRetrievableStateHandle&amp;lt;&amp;gt;(state);
 		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertEquals(expectedCheckpointIds, actualCheckpointIds);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// check that we did not discard any of the state handles&lt;/li&gt;
	&lt;li&gt;verify(retrievableStateHandle1, never()).discardState();&lt;/li&gt;
	&lt;li&gt;verify(retrievableStateHandle2, never()).discardState();&lt;br/&gt;
+		private static class TestingRetrievableStateHandle&amp;lt;T extends Serializable&amp;gt; implements RetrievableStateHandle&amp;lt;T&amp;gt; 
{
 
-		// Make sure that we also didn&apos;t discard any of the broken handles. Only when checkpoints
-		// are subsumed should they be discarded.
-		verify(failingRetrievableStateHandle, never()).discardState();
-	}
&lt;p&gt;+			private static final long serialVersionUID = 137053380713794300L;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Tests that the checkpoint does not exist in the store when we fail to add&lt;/li&gt;
	&lt;li&gt;* it into the store (i.e., there exists an exception thrown by the method).&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testAddCheckpointWithFailedRemove() throws Exception {&lt;/li&gt;
	&lt;li&gt;final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;/li&gt;
	&lt;li&gt;final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+			private final T state;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zookeeperStateHandleStoreMock =&lt;/li&gt;
	&lt;li&gt;spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock, Executors.directExecutor()));&lt;/li&gt;
	&lt;li&gt;whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zookeeperStateHandleStoreMock);&lt;br/&gt;
+			private TestingRetrievableStateHandle(T state) 
{
+				this.state = state;
+			}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;doAnswer(new Answer&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;&amp;gt;() {&lt;br/&gt;
 			@Override&lt;/li&gt;
	&lt;li&gt;public RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; answer(InvocationOnMock invocationOnMock) throws Throwable {&lt;/li&gt;
	&lt;li&gt;CompletedCheckpoint checkpoint = (CompletedCheckpoint) invocationOnMock.getArguments()&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle = mock(RetrievableStateHandle.class);&lt;/li&gt;
	&lt;li&gt;when(retrievableStateHandle.retrieveState()).thenReturn(checkpoint);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;return retrievableStateHandle;&lt;br/&gt;
+			public T retrieveState() throws IOException, ClassNotFoundException 
{
+				return state;
 			}&lt;/li&gt;
	&lt;li&gt;}).when(zookeeperStateHandleStoreMock).addAndLock(anyString(), any(CompletedCheckpoint.class));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;doThrow(new Exception()).when(zookeeperStateHandleStoreMock).releaseAndTryRemove(anyString(), any(ZooKeeperStateHandleStore.RemoveCallback.class));&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final int numCheckpointsToRetain = 1;&lt;/li&gt;
	&lt;li&gt;final String checkpointsPath = &quot;foobar&quot;;&lt;/li&gt;
	&lt;li&gt;final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateSotrage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;/li&gt;
	&lt;li&gt;numCheckpointsToRetain,&lt;/li&gt;
	&lt;li&gt;client,&lt;/li&gt;
	&lt;li&gt;checkpointsPath,&lt;/li&gt;
	&lt;li&gt;stateSotrage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public void discardState() throws Exception 
{
+				// no op
+			}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for (long i = 0; i &amp;lt;= numCheckpointsToRetain; ++i) {&lt;/li&gt;
	&lt;li&gt;CompletedCheckpoint checkpointToAdd = mock(CompletedCheckpoint.class);&lt;/li&gt;
	&lt;li&gt;doReturn&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.when(checkpointToAdd).getCheckpointID();&lt;/li&gt;
	&lt;li&gt;doReturn(Collections.emptyMap()).when(checkpointToAdd).getOperatorStates();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;try 
{
-				zooKeeperCompletedCheckpointStore.addCheckpoint(checkpointToAdd);
-
-				// The checkpoint should be in the store if we successfully add it into the store.
-				List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();
-				assertTrue(addedCheckpoints.contains(checkpointToAdd));
-			}
&lt;p&gt; catch (Exception e) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// The checkpoint should not be in the store if any exception is thrown.&lt;/li&gt;
	&lt;li&gt;List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();&lt;/li&gt;
	&lt;li&gt;assertFalse(addedCheckpoints.contains(checkpointToAdd));&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public long getStateSize() 
{
+				return 0;
 			}
&lt;p&gt; 		}&lt;br/&gt;
 	}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java&lt;br/&gt;
index 2c030d24c49..cb26f4862b1 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java&lt;br/&gt;
@@ -30,9 +30,11 @@&lt;br/&gt;
 import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobVertex;&lt;br/&gt;
+import org.apache.flink.runtime.jobmanager.StandaloneSubmittedJobGraphStore;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.SubmittedJobGraph;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore;&lt;br/&gt;
 import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;&lt;br/&gt;
+import org.apache.flink.runtime.messages.Acknowledge;&lt;br/&gt;
 import org.apache.flink.runtime.metrics.groups.JobManagerMetricGroup;&lt;br/&gt;
 import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;&lt;br/&gt;
 import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;&lt;br/&gt;
@@ -41,6 +43,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.rpc.RpcService;&lt;br/&gt;
 import org.apache.flink.runtime.rpc.RpcUtils;&lt;br/&gt;
 import org.apache.flink.runtime.rpc.TestingRpcService;&lt;br/&gt;
+import org.apache.flink.runtime.testtasks.NoOpInvokable;&lt;br/&gt;
 import org.apache.flink.runtime.util.TestingFatalErrorHandler;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
@@ -110,8 +113,6 @@ public static void teardownClass() throws ExecutionException, InterruptedExcepti&lt;br/&gt;
 	 */&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testGrantingRevokingLeadership() throws Exception {&lt;br/&gt;
-&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;final Configuration configuration = new Configuration();&lt;br/&gt;
 		final TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices();&lt;br/&gt;
 		final JobGraph nonEmptyJobGraph = createNonEmptyJobGraph();&lt;br/&gt;
 		final SubmittedJobGraph submittedJobGraph = new SubmittedJobGraph(nonEmptyJobGraph, null);&lt;br/&gt;
@@ -124,7 +125,34 @@ public void testGrantingRevokingLeadership() throws Exception {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final BlockingQueue&amp;lt;DispatcherId&amp;gt; fencingTokens = new ArrayBlockingQueue&amp;lt;&amp;gt;(2);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final HATestingDispatcher dispatcher = new HATestingDispatcher(&lt;br/&gt;
+		final HATestingDispatcher dispatcher = createHADispatcher(highAvailabilityServices, fencingTokens);&lt;br/&gt;
+&lt;br/&gt;
+		dispatcher.start();&lt;br/&gt;
+&lt;br/&gt;
+		try 
{
+			final UUID leaderId = UUID.randomUUID();
+			dispatcherLeaderElectionService.isLeader(leaderId);
+
+			dispatcherLeaderElectionService.notLeader();
+
+			final DispatcherId firstFencingToken = fencingTokens.take();
+
+			assertThat(firstFencingToken, equalTo(NULL_FENCING_TOKEN));
+
+			enterGetJobIdsLatch.await();
+			proceedGetJobIdsLatch.trigger();
+
+			assertThat(dispatcher.getNumberJobs(timeout).get(), is(0));
+
+		}
&lt;p&gt; finally &lt;/p&gt;
{
+			RpcUtils.terminateRpcEndpoint(dispatcher, timeout);
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private HATestingDispatcher createHADispatcher(TestingHighAvailabilityServices highAvailabilityServices, BlockingQueue&amp;lt;DispatcherId&amp;gt; fencingTokens) throws Exception {&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		return new HATestingDispatcher(&lt;br/&gt;
 			rpcService,&lt;br/&gt;
 			UUID.randomUUID().toString(),&lt;br/&gt;
 			configuration,&lt;br/&gt;
@@ -138,33 +166,63 @@ public void testGrantingRevokingLeadership() throws Exception &lt;/p&gt;
{
 			new TestingJobManagerRunnerFactory(new CompletableFuture&amp;lt;&amp;gt;(), new CompletableFuture&amp;lt;&amp;gt;()),
 			testingFatalErrorHandler,
 			fencingTokens);
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that all JobManagerRunner are terminated if the leadership of the&lt;br/&gt;
+	 * Dispatcher is revoked.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testRevokeLeadershipTerminatesJobManagerRunners() throws Exception {&lt;br/&gt;
+&lt;br/&gt;
+		final TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices();&lt;br/&gt;
+		highAvailabilityServices.setSubmittedJobGraphStore(new StandaloneSubmittedJobGraphStore());&lt;br/&gt;
+&lt;br/&gt;
+		final TestingLeaderElectionService leaderElectionService = new TestingLeaderElectionService();&lt;br/&gt;
+		highAvailabilityServices.setDispatcherLeaderElectionService(leaderElectionService);&lt;br/&gt;
+&lt;br/&gt;
+		final ArrayBlockingQueue&amp;lt;DispatcherId&amp;gt; fencingTokens = new ArrayBlockingQueue&amp;lt;&amp;gt;(2);&lt;br/&gt;
+		final HATestingDispatcher dispatcher = createHADispatcher(&lt;br/&gt;
+			highAvailabilityServices,&lt;br/&gt;
+			fencingTokens);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		dispatcher.start();&lt;/p&gt;

&lt;p&gt; 		try &lt;/p&gt;
{
-			final UUID leaderId = UUID.randomUUID();
-			dispatcherLeaderElectionService.isLeader(leaderId);
+			// grant leadership and submit a single job
+			final DispatcherId expectedDispatcherId = DispatcherId.generate();
 
-			dispatcherLeaderElectionService.notLeader();
+			leaderElectionService.isLeader(expectedDispatcherId.toUUID()).get();
 
-			final DispatcherId firstFencingToken = fencingTokens.take();
+			assertThat(fencingTokens.take(), is(equalTo(expectedDispatcherId)));
 
-			assertThat(firstFencingToken, equalTo(NULL_FENCING_TOKEN));
+			final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 
-			enterGetJobIdsLatch.await();
-			proceedGetJobIdsLatch.trigger();
+			final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = dispatcherGateway.submitJob(createNonEmptyJobGraph(), timeout);
 
-			assertThat(dispatcher.getNumberJobs(timeout).get(), is(0));
+			submissionFuture.get();
+
+			assertThat(dispatcher.getNumberJobs(timeout).get(), is(1));
+
+			// revoke the leadership --&amp;gt; this should stop all running JobManagerRunners
+			leaderElectionService.notLeader();
+
+			assertThat(fencingTokens.take(), is(equalTo(NULL_FENCING_TOKEN)));
 
+			assertThat(dispatcher.getNumberJobs(timeout).get(), is(0));
 		}
&lt;p&gt; finally &lt;/p&gt;
{
 			RpcUtils.terminateRpcEndpoint(dispatcher, timeout);
 		}
&lt;p&gt; 	}&lt;/p&gt;

&lt;p&gt; 	@Nonnull&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private JobGraph createNonEmptyJobGraph() {&lt;br/&gt;
+	public static JobGraph createNonEmptyJobGraph() 
{
 		final JobVertex noOpVertex = new JobVertex(&quot;NoOp vertex&quot;);
-		return new JobGraph(noOpVertex);
+		noOpVertex.setInvokableClass(NoOpInvokable.class);
+		final JobGraph jobGraph = new JobGraph(noOpVertex);
+		jobGraph.setAllowQueuedScheduling(true);
+
+		return jobGraph;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	private static class HATestingDispatcher extends TestingDispatcher {&lt;br/&gt;
@@ -243,6 +301,11 @@ public void removeJobGraph(JobID jobId) throws Exception &lt;/p&gt;
{
 			throw new UnsupportedOperationException(&quot;Should not be called.&quot;);
 		}

&lt;p&gt;+		@Override&lt;br/&gt;
+		public void releaseJobGraph(JobID jobId) throws Exception &lt;/p&gt;
{
+			throw new UnsupportedOperationException(&quot;Should not be called.&quot;);
+		}
&lt;p&gt;+&lt;br/&gt;
 		@Override&lt;br/&gt;
 		public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
 			enterGetJobIdsLatch.trigger();&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/NoOpSubmittedJobGraphListener.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/NoOpSubmittedJobGraphListener.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..493534dd93c&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/NoOpSubmittedJobGraphListener.java&lt;br/&gt;
@@ -0,0 +1,40 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.dispatcher;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * No operation &lt;/p&gt;
{@link org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore.SubmittedJobGraphListener}
&lt;p&gt;+ * implemetation for testing purposes.&lt;br/&gt;
+ */&lt;br/&gt;
+public enum NoOpSubmittedJobGraphListener implements SubmittedJobGraphStore.SubmittedJobGraphListener {&lt;br/&gt;
+	INSTANCE;&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void onAddedJobGraph(JobID jobId) &lt;/p&gt;
{
+		// No op
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void onRemovedJobGraph(JobID jobId) {+		// No op+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
index f5091ea5b10..5141be039f7 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
@@ -19,6 +19,8 @@&lt;br/&gt;
 package org.apache.flink.runtime.dispatcher;&lt;/p&gt;

&lt;p&gt; import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.api.common.time.Time;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
 import org.apache.flink.runtime.blob.BlobServer;&lt;br/&gt;
 import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;&lt;br/&gt;
@@ -29,8 +31,12 @@&lt;br/&gt;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;&lt;br/&gt;
 import org.apache.flink.runtime.rpc.RpcService;&lt;/p&gt;

&lt;p&gt;+import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt;+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.function.Function;&lt;br/&gt;
+&lt;br/&gt;
 /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;{@link Dispatcher} implementation used for testing purposes.&lt;br/&gt;
  */&lt;br/&gt;
@@ -72,4 +78,11 @@ void completeJobExecution(ArchivedExecutionGraph archivedExecutionGraph) {
 		runAsync(
 			() -&amp;gt; jobReachedGloballyTerminalState(archivedExecutionGraph));
 	}&lt;br/&gt;
+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(@Nonnull JobID jobId, @Nonnull Time timeout) {
+		return callAsyncWithoutFencing(
+			() -&amp;gt; getJobTerminationFuture(jobId),
+			timeout).thenCompose(Function.identity());
+	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..dd0375886a9&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java&lt;br/&gt;
@@ -0,0 +1,203 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.dispatcher;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.api.common.time.Time;&lt;br/&gt;
+import org.apache.flink.configuration.Configuration;&lt;br/&gt;
+import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
+import org.apache.flink.runtime.blob.BlobServer;&lt;br/&gt;
+import org.apache.flink.runtime.blob.VoidBlobStore;&lt;br/&gt;
+import org.apache.flink.runtime.heartbeat.HeartbeatServices;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
+import org.apache.flink.runtime.jobmanager.SubmittedJobGraph;&lt;br/&gt;
+import org.apache.flink.runtime.jobmanager.ZooKeeperSubmittedJobGraphStore;&lt;br/&gt;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;&lt;br/&gt;
+import org.apache.flink.runtime.messages.Acknowledge;&lt;br/&gt;
+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;&lt;br/&gt;
+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;&lt;br/&gt;
+import org.apache.flink.runtime.rpc.RpcUtils;&lt;br/&gt;
+import org.apache.flink.runtime.rpc.TestingRpcService;&lt;br/&gt;
+import org.apache.flink.runtime.util.TestingFatalErrorHandler;&lt;br/&gt;
+import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.hamcrest.Matchers;&lt;br/&gt;
+import org.junit.After;&lt;br/&gt;
+import org.junit.AfterClass;&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.BeforeClass;&lt;br/&gt;
+import org.junit.ClassRule;&lt;br/&gt;
+import org.junit.Rule;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.rules.TemporaryFolder;&lt;br/&gt;
+import org.junit.rules.TestName;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Test cases for the interaction between ZooKeeper HA and the {@link Dispatcher}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ZooKeeperHADispatcherTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	private static final Time TIMEOUT = Time.seconds(10L);&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final ZooKeeperResource ZOO_KEEPER_RESOURCE = new ZooKeeperResource();&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();&lt;br/&gt;
+&lt;br/&gt;
+	private static Configuration configuration;&lt;br/&gt;
+&lt;br/&gt;
+	private static TestingRpcService rpcService;&lt;br/&gt;
+&lt;br/&gt;
+	private static BlobServer blobServer;&lt;br/&gt;
+&lt;br/&gt;
+	@Rule&lt;br/&gt;
+	public TestName name = new TestName();&lt;br/&gt;
+&lt;br/&gt;
+	private TestingFatalErrorHandler testingFatalErrorHandler;&lt;br/&gt;
+&lt;br/&gt;
+	@BeforeClass&lt;br/&gt;
+	public static void setupClass() throws IOException &lt;/p&gt;
{
+		configuration = new Configuration();
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, ZOO_KEEPER_RESOURCE.getConnectString());
+		configuration.setString(HighAvailabilityOptions.HA_STORAGE_PATH, TEMPORARY_FOLDER.newFolder().getAbsolutePath());
+		rpcService = new TestingRpcService();
+		blobServer = new BlobServer(configuration, new VoidBlobStore());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Before&lt;br/&gt;
+	public void setup() &lt;/p&gt;
{
+		testingFatalErrorHandler = new TestingFatalErrorHandler();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@After&lt;br/&gt;
+	public void teardown() throws Exception &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		if (testingFatalErrorHandler != null) {
+			testingFatalErrorHandler.rethrowError();
+		}+	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+	@AfterClass&lt;br/&gt;
+	public static void teardownClass() throws Exception &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		if (rpcService != null) {
+			RpcUtils.terminateRpcService(rpcService, TIMEOUT);
+			rpcService = null;
+		}++		if (blobServer != null) {
+			blobServer.close();
+			blobServer = null;
+		}+	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the &lt;/p&gt;
{@link Dispatcher}
&lt;p&gt; releases a locked &lt;/p&gt;
{@link SubmittedJobGraph}
&lt;p&gt; if it&lt;br/&gt;
+	 * lost the leadership.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testSubmittedJobGraphRelease() throws Exception {&lt;br/&gt;
+		final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+		final CuratorFramework otherClient = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+&lt;br/&gt;
+		try (final TestingHighAvailabilityServices testingHighAvailabilityServices = new TestingHighAvailabilityServices()) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			testingHighAvailabilityServices.setSubmittedJobGraphStore(ZooKeeperUtils.createSubmittedJobGraphs(client, configuration));++			final ZooKeeperSubmittedJobGraphStore otherSubmittedJobGraphStore = ZooKeeperUtils.createSubmittedJobGraphs(+				otherClient,+				configuration);++			otherSubmittedJobGraphStore.start(NoOpSubmittedJobGraphListener.INSTANCE);++			final TestingLeaderElectionService leaderElectionService = new TestingLeaderElectionService();+			testingHighAvailabilityServices.setDispatcherLeaderElectionService(leaderElectionService);++			final TestingDispatcher dispatcher = createDispatcher(testingHighAvailabilityServices);++			dispatcher.start();++			try {
+				final DispatcherId expectedLeaderId = DispatcherId.generate();
+				leaderElectionService.isLeader(expectedLeaderId.toUUID()).get();
+
+				final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
+
+				final JobGraph nonEmptyJobGraph = DispatcherHATest.createNonEmptyJobGraph();
+				final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = dispatcherGateway.submitJob(nonEmptyJobGraph, TIMEOUT);
+				submissionFuture.get();
+
+				Collection&amp;lt;JobID&amp;gt; jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+				final JobID jobId = nonEmptyJobGraph.getJobID();
+				assertThat(jobIds, Matchers.contains(jobId));
+
+				leaderElectionService.notLeader();
+
+				// wait for the job to properly terminate
+				final CompletableFuture&amp;lt;Void&amp;gt; jobTerminationFuture = dispatcher.getJobTerminationFuture(jobId, TIMEOUT);
+				jobTerminationFuture.get();
+
+				// recover the job
+				final SubmittedJobGraph submittedJobGraph = otherSubmittedJobGraphStore.recoverJobGraph(jobId);
+
+				assertThat(submittedJobGraph, Matchers.is(Matchers.notNullValue()));
+
+				// check that the other submitted job graph store can remove the job graph after the original leader
+				// has lost its leadership
+				otherSubmittedJobGraphStore.removeJobGraph(jobId);
+
+				jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+				assertThat(jobIds, Matchers.not(Matchers.contains(jobId)));
+			} finally {
+				RpcUtils.terminateRpcEndpoint(dispatcher, TIMEOUT);
+				client.close();
+				otherClient.close();
+			}+		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private TestingDispatcher createDispatcher(TestingHighAvailabilityServices testingHighAvailabilityServices) throws Exception &lt;/p&gt;
{
+		return new TestingDispatcher(
+			rpcService,
+			Dispatcher.DISPATCHER_NAME + &apos;_&apos; + name.getMethodName(),
+			configuration,
+			testingHighAvailabilityServices,
+			new TestingResourceManagerGateway(),
+			blobServer,
+			new HeartbeatServices(1000L, 1000L),
+			UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(),
+			null,
+			new MemoryArchivedExecutionGraphStore(),
+			new TestingJobManagerRunnerFactory(new CompletableFuture&amp;lt;&amp;gt;(), new CompletableFuture&amp;lt;&amp;gt;()),
+			testingFatalErrorHandler);
+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java&lt;br/&gt;
index 79e6d20348a..8becb05ae91 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java&lt;br/&gt;
@@ -32,8 +32,8 @@&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointMetrics;&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
-import org.apache.flink.runtime.checkpoint.CheckpointType;&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointRetentionPolicy;&lt;br/&gt;
+import org.apache.flink.runtime.checkpoint.CheckpointType;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.messages.NotifyResourceStarted;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.messages.RegisterResourceManager;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.messages.RegisterResourceManagerSuccessful;&lt;br/&gt;
@@ -151,7 +151,6 @@&lt;br/&gt;
 import static org.junit.Assert.assertNotNull;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;br/&gt;
 import static org.junit.Assert.fail;&lt;br/&gt;
-&lt;br/&gt;
 import static org.mockito.Mockito.mock;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; public class JobManagerTest extends TestLogger {&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..8e5b1b9b392&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java&lt;br/&gt;
@@ -0,0 +1,180 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.jobmanager;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.configuration.Configuration;&lt;br/&gt;
+import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
+import org.apache.flink.runtime.akka.ActorUtils;&lt;br/&gt;
+import org.apache.flink.runtime.akka.AkkaUtils;&lt;br/&gt;
+import org.apache.flink.runtime.akka.ListeningBehaviour;&lt;br/&gt;
+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;&lt;br/&gt;
+import org.apache.flink.runtime.dispatcher.DispatcherHATest;&lt;br/&gt;
+import org.apache.flink.runtime.dispatcher.NoOpSubmittedJobGraphListener;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.HighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.instance.ActorGateway;&lt;br/&gt;
+import org.apache.flink.runtime.instance.AkkaActorGateway;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;&lt;br/&gt;
+import org.apache.flink.runtime.messages.JobManagerMessages;&lt;br/&gt;
+import org.apache.flink.runtime.metrics.NoOpMetricRegistry;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingJobManager;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingJobManagerMessages;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingUtils;&lt;br/&gt;
+import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import akka.actor.ActorRef;&lt;br/&gt;
+import akka.actor.ActorSystem;&lt;br/&gt;
+import akka.actor.ExtendedActorSystem;&lt;br/&gt;
+import akka.actor.Identify;&lt;br/&gt;
+import akka.actor.Terminated;&lt;br/&gt;
+import akka.pattern.Patterns;&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.junit.AfterClass;&lt;br/&gt;
+import org.junit.BeforeClass;&lt;br/&gt;
+import org.junit.ClassRule;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.rules.TemporaryFolder;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+&lt;br/&gt;
+import scala.Option;&lt;br/&gt;
+import scala.concurrent.Await;&lt;br/&gt;
+import scala.concurrent.Future;&lt;br/&gt;
+import scala.concurrent.duration.FiniteDuration;&lt;br/&gt;
+&lt;br/&gt;
+import static org.hamcrest.Matchers.contains;&lt;br/&gt;
+import static org.hamcrest.Matchers.is;&lt;br/&gt;
+import static org.hamcrest.Matchers.not;&lt;br/&gt;
+import static org.hamcrest.Matchers.notNullValue;&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tests for the ZooKeeper HA service and &lt;/p&gt;
{@link JobManager} interaction.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ZooKeeperHAJobManagerTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final ZooKeeperResource ZOO_KEEPER_RESOURCE = new ZooKeeperResource();&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();&lt;br/&gt;
+&lt;br/&gt;
+	private static final FiniteDuration TIMEOUT = FiniteDuration.apply(10L, TimeUnit.SECONDS);&lt;br/&gt;
+&lt;br/&gt;
+	private static ActorSystem system;&lt;br/&gt;
+&lt;br/&gt;
+	@BeforeClass&lt;br/&gt;
+	public static void setup() {
+		system = AkkaUtils.createLocalActorSystem(new Configuration());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@AfterClass&lt;br/&gt;
+	public static void teardown() throws Exception {
+		final Future&amp;lt;Terminated&amp;gt; terminationFuture = system.terminate();
+		Await.ready(terminationFuture, TIMEOUT);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the {@link JobManager}
&lt;p&gt; releases all locked &lt;/p&gt;
{@link JobGraph}
&lt;p&gt; if it loses&lt;br/&gt;
+	 * leadership.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testJobGraphReleaseWhenLosingLeadership() throws Exception {&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, ZOO_KEEPER_RESOURCE.getConnectString());&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_STORAGE_PATH, TEMPORARY_FOLDER.newFolder().getAbsolutePath());&lt;br/&gt;
+&lt;br/&gt;
+		try (TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices()) {&lt;br/&gt;
+&lt;br/&gt;
+			final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+			final TestingLeaderElectionService leaderElectionService = new TestingLeaderElectionService();&lt;br/&gt;
+			highAvailabilityServices.setJobMasterLeaderElectionService(HighAvailabilityServices.DEFAULT_JOB_ID, leaderElectionService);&lt;br/&gt;
+			highAvailabilityServices.setSubmittedJobGraphStore(ZooKeeperUtils.createSubmittedJobGraphs(client, configuration));&lt;br/&gt;
+			highAvailabilityServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());&lt;br/&gt;
+&lt;br/&gt;
+			final CuratorFramework otherClient = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+			final ZooKeeperSubmittedJobGraphStore otherSubmittedJobGraphStore = ZooKeeperUtils.createSubmittedJobGraphs(otherClient, configuration);&lt;br/&gt;
+			otherSubmittedJobGraphStore.start(NoOpSubmittedJobGraphListener.INSTANCE);&lt;br/&gt;
+&lt;br/&gt;
+			ActorRef jobManagerActorRef = null;&lt;br/&gt;
+			try &lt;/p&gt;
{
+				jobManagerActorRef = JobManager.startJobManagerActors(
+					configuration,
+					system,
+					TestingUtils.defaultExecutor(),
+					TestingUtils.defaultExecutor(),
+					highAvailabilityServices,
+					NoOpMetricRegistry.INSTANCE,
+					Option.empty(),
+					TestingJobManager.class,
+					MemoryArchivist.class)._1();
+
+				waitForActorToBeStarted(jobManagerActorRef, TIMEOUT);
+
+				final ActorGateway jobManager = new AkkaActorGateway(jobManagerActorRef, HighAvailabilityServices.DEFAULT_LEADER_ID);
+
+				leaderElectionService.isLeader(HighAvailabilityServices.DEFAULT_LEADER_ID).get();
+
+				final JobGraph nonEmptyJobGraph = DispatcherHATest.createNonEmptyJobGraph();
+
+				final JobManagerMessages.SubmitJob submitJobMessage = new JobManagerMessages.SubmitJob(nonEmptyJobGraph, ListeningBehaviour.DETACHED);
+
+				Await.result(jobManager.ask(submitJobMessage, TIMEOUT), TIMEOUT);
+
+				Collection&amp;lt;JobID&amp;gt; jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+				final JobID jobId = nonEmptyJobGraph.getJobID();
+				assertThat(jobIds, contains(jobId));
+
+				// revoke the leadership
+				leaderElectionService.notLeader();
+
+				Await.result(jobManager.ask(TestingJobManagerMessages.getWaitForBackgroundTasksToFinish(), TIMEOUT), TIMEOUT);
+
+				final SubmittedJobGraph recoveredJobGraph = akka.serialization.JavaSerializer.currentSystem().withValue(
+					((ExtendedActorSystem) system),
+					() -&amp;gt; otherSubmittedJobGraphStore.recoverJobGraph(jobId));
+
+				assertThat(recoveredJobGraph, is(notNullValue()));
+
+				otherSubmittedJobGraphStore.removeJobGraph(jobId);
+
+				jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+				assertThat(jobIds, not(contains(jobId)));
+			}
&lt;p&gt; finally {&lt;br/&gt;
+				client.close();&lt;br/&gt;
+				otherClient.close();&lt;br/&gt;
+&lt;br/&gt;
+				if (jobManagerActorRef != null) &lt;/p&gt;
{
+					ActorUtils.stopActor(jobManagerActorRef);
+				}
&lt;p&gt;+			}&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private void waitForActorToBeStarted(ActorRef jobManagerActorRef, FiniteDuration timeout) throws InterruptedException, java.util.concurrent.TimeoutException &lt;/p&gt;
{
+		Await.ready(Patterns.ask(jobManagerActorRef, new Identify(42), timeout.toMillis()), timeout);
+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java&lt;br/&gt;
index c1a7b536721..e9be145c37f 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java&lt;br/&gt;
@@ -20,7 +20,6 @@&lt;/p&gt;

&lt;p&gt; import org.apache.flink.api.common.JobID;&lt;br/&gt;
 import org.apache.flink.runtime.akka.ListeningBehaviour;&lt;br/&gt;
-import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobVertex;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore.SubmittedJobGraphListener;&lt;br/&gt;
@@ -90,8 +89,7 @@ public void testPutAndRemoveJobGraph() throws Exception {&lt;br/&gt;
 		ZooKeeperSubmittedJobGraphStore jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;br/&gt;
 			ZooKeeper.createClient(),&lt;br/&gt;
 			&quot;/testPutAndRemoveJobGraph&quot;,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;localStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		try {&lt;br/&gt;
 			SubmittedJobGraphListener listener = mock(SubmittedJobGraphListener.class);&lt;br/&gt;
@@ -147,7 +145,7 @@ public void testPutAndRemoveJobGraph() throws Exception {&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testRecoverJobGraphs() throws Exception {&lt;br/&gt;
 		ZooKeeperSubmittedJobGraphStore jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testRecoverJobGraphs&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+				ZooKeeper.createClient(), &quot;/testRecoverJobGraphs&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		try {&lt;br/&gt;
 			SubmittedJobGraphListener listener = mock(SubmittedJobGraphListener.class);&lt;br/&gt;
@@ -198,10 +196,10 @@ public void testConcurrentAddJobGraph() throws Exception {&lt;/p&gt;

&lt;p&gt; 		try {&lt;br/&gt;
 			jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+					ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			otherJobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+					ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt; 			SubmittedJobGraph jobGraph = createSubmittedJobGraph(new JobID(), 0);&lt;br/&gt;
@@ -257,10 +255,10 @@ public Void answer(InvocationOnMock invocation) throws Throwable {&lt;br/&gt;
 	@Test(expected = IllegalStateException.class)&lt;br/&gt;
 	public void testUpdateJobGraphYouDidNotGetOrAdd() throws Exception {&lt;br/&gt;
 		ZooKeeperSubmittedJobGraphStore jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+				ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperSubmittedJobGraphStore otherJobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+				ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		jobGraphs.start(null);&lt;br/&gt;
 		otherJobGraphs.start(null);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java&lt;br/&gt;
index ba0dc80fbb5..3b9c5786ca4 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java&lt;br/&gt;
@@ -96,6 +96,11 @@ public synchronized void removeJobGraph(JobID jobId) throws Exception &lt;/p&gt;
{
 		storedJobs.remove(jobId);
 	}

&lt;p&gt;+	@Override&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) &lt;/p&gt;
{
+		verifyIsStarted();
+	}
&lt;p&gt;+&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public synchronized Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
 		verifyIsStarted();&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperResource.java b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperResource.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..c4c56949cd9&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperResource.java&lt;br/&gt;
@@ -0,0 +1,72 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.zookeeper;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.test.TestingServer;&lt;br/&gt;
+import org.junit.rules.ExternalResource;&lt;br/&gt;
+import org.slf4j.Logger;&lt;br/&gt;
+import org.slf4j.LoggerFactory;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * &lt;/p&gt;
{@link ExternalResource}
&lt;p&gt; which starts a &lt;/p&gt;
{@link org.apache.zookeeper.server.ZooKeeperServer}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ZooKeeperResource extends ExternalResource {&lt;br/&gt;
+&lt;br/&gt;
+	private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperResource.class);&lt;br/&gt;
+&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	private TestingServer zooKeeperServer;&lt;br/&gt;
+&lt;br/&gt;
+	public String getConnectString() &lt;/p&gt;
{
+		verifyIsRunning();
+		return zooKeeperServer.getConnectString();
+	}
&lt;p&gt;+&lt;br/&gt;
+	private void verifyIsRunning() &lt;/p&gt;
{
+		Preconditions.checkState(zooKeeperServer != null);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	protected void before() throws Throwable &lt;/p&gt;
{
+		terminateZooKeeperServer();
+		zooKeeperServer = new TestingServer(true);
+	}
&lt;p&gt;+&lt;br/&gt;
+	private void terminateZooKeeperServer() throws IOException {&lt;br/&gt;
+		if (zooKeeperServer != null) &lt;/p&gt;
{
+			zooKeeperServer.stop();
+			zooKeeperServer = null;
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	protected void after() {&lt;br/&gt;
+		try &lt;/p&gt;
{
+			terminateZooKeeperServer();
+		}
&lt;p&gt; catch (IOException e) {&lt;br/&gt;
+			LOG.warn(&quot;Could not properly terminate the {}.&quot;, getClass().getSimpleName(), e);&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java&lt;br/&gt;
index fd39b25991c..2dd27e7c897 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java&lt;br/&gt;
@@ -18,21 +18,19 @@&lt;/p&gt;

&lt;p&gt; package org.apache.flink.runtime.zookeeper;&lt;/p&gt;

&lt;p&gt;-import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
 import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
 import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
-import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
 import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
 import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
 import org.apache.flink.util.InstantiationUtil;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
 import org.apache.zookeeper.data.Stat;&lt;br/&gt;
 import org.junit.AfterClass;&lt;br/&gt;
 import org.junit.Before;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
-import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
-import org.mockito.stubbing.Answer;&lt;/p&gt;

&lt;p&gt; import java.io.IOException;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
@@ -41,7 +39,6 @@&lt;br/&gt;
 import java.util.HashSet;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Set;&lt;br/&gt;
-import java.util.concurrent.CountDownLatch;&lt;/p&gt;

&lt;p&gt; import static org.junit.Assert.assertEquals;&lt;br/&gt;
 import static org.junit.Assert.assertNotEquals;&lt;br/&gt;
@@ -49,12 +46,7 @@&lt;br/&gt;
 import static org.junit.Assert.assertNull;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;br/&gt;
 import static org.junit.Assert.fail;&lt;br/&gt;
-import static org.mockito.Matchers.any;&lt;br/&gt;
-import static org.mockito.Mockito.doAnswer;&lt;br/&gt;
-import static org.mockito.Mockito.mock;&lt;br/&gt;
 import static org.mockito.Mockito.spy;&lt;br/&gt;
-import static org.mockito.Mockito.times;&lt;br/&gt;
-import static org.mockito.Mockito.verify;&lt;br/&gt;
 import static org.mockito.Mockito.when;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -88,8 +80,8 @@ public void cleanUp() throws Exception {&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testAddAndLock() throws Exception {&lt;br/&gt;
 		LongStateStorage longStateStorage = new LongStateStorage();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;Long&amp;gt;(&lt;/li&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), longStateStorage, Executors.directExecutor());&lt;br/&gt;
+		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
+			ZOOKEEPER.getClient(), longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testAdd&quot;;&lt;br/&gt;
@@ -136,7 +128,7 @@ public void testAddAlreadyExistingPath() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZOOKEEPER.getClient().create().forPath(&quot;/testAddAlreadyExistingPath&quot;);&lt;/p&gt;

&lt;p&gt;@@ -161,7 +153,7 @@ public void testAddDiscardStateHandleAfterFailure() throws Exception {&lt;br/&gt;
 		when(client.inTransaction().create()).thenThrow(new RuntimeException(&quot;Expected test Exception.&quot;));&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client, stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				client, stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testAddDiscardStateHandleAfterFailure&quot;;&lt;br/&gt;
@@ -191,7 +183,7 @@ public void testReplace() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testReplace&quot;;&lt;br/&gt;
@@ -230,7 +222,7 @@ public void testReplaceNonExistingPath() throws Exception &lt;/p&gt;
{
 		RetrievableStateStorageHelper&amp;lt;Long&amp;gt; stateStorage = new LongStateStorage();
 
 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(
-				ZOOKEEPER.getClient(), stateStorage, Executors.directExecutor());
+				ZOOKEEPER.getClient(), stateStorage);
 
 		store.replace(&quot;/testReplaceNonExistingPath&quot;, 0, 1L);
 	}
&lt;p&gt;@@ -247,7 +239,7 @@ public void testReplaceDiscardStateHandleAfterFailure() throws Exception {&lt;br/&gt;
 		when(client.setData()).thenThrow(new RuntimeException(&quot;Expected test Exception.&quot;));&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client, stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				client, stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testReplaceDiscardStateHandleAfterFailure&quot;;&lt;br/&gt;
@@ -289,7 +281,7 @@ public void testGetAndExists() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testGetAndExists&quot;;&lt;br/&gt;
@@ -314,7 +306,7 @@ public void testGetNonExistingPath() throws Exception &lt;/p&gt;
{
 		LongStateStorage stateHandleProvider = new LongStateStorage();
 
 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(
-				ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());
+				ZOOKEEPER.getClient(), stateHandleProvider);
 
 		store.getAndLock(&quot;/testGetNonExistingPath&quot;);
 	}
&lt;p&gt;@@ -328,7 +320,7 @@ public void testGetAll() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testGetAll&quot;;&lt;br/&gt;
@@ -359,7 +351,7 @@ public void testGetAllSortedByName() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String basePath = &quot;/testGetAllSortedByName&quot;;&lt;br/&gt;
@@ -393,7 +385,7 @@ public void testRemove() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testRemove&quot;;&lt;br/&gt;
@@ -401,50 +393,14 @@ public void testRemove() throws Exception &lt;/p&gt;
{
 
 		store.addAndLock(pathInZooKeeper, state);
 
+		final int numberOfGlobalDiscardCalls = LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls();
+
 		// Test
 		store.releaseAndTryRemove(pathInZooKeeper);
 
 		// Verify discarded
 		assertEquals(0, ZOOKEEPER.getClient().getChildren().forPath(&quot;/&quot;).size());
-	}
&lt;p&gt;-&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Tests that state handles are correctly removed with a callback.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testRemoveWithCallback() throws Exception {&lt;/li&gt;
	&lt;li&gt;// Setup&lt;/li&gt;
	&lt;li&gt;LongStateStorage stateHandleProvider = new LongStateStorage();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/li&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Config&lt;/li&gt;
	&lt;li&gt;final String pathInZooKeeper = &quot;/testRemoveWithCallback&quot;;&lt;/li&gt;
	&lt;li&gt;final Long state = 27255442L;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;store.addAndLock(pathInZooKeeper, state);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CountDownLatch sync = new CountDownLatch(1);&lt;/li&gt;
	&lt;li&gt;ZooKeeperStateHandleStore.RemoveCallback&amp;lt;Long&amp;gt; callback = mock(ZooKeeperStateHandleStore.RemoveCallback.class);&lt;/li&gt;
	&lt;li&gt;doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public Void answer(InvocationOnMock invocation) throws Throwable 
{
-				sync.countDown();
-				return null;
-			}&lt;/li&gt;
	&lt;li&gt;}).when(callback).apply(any(RetrievableStateHandle.class));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Test&lt;/li&gt;
	&lt;li&gt;store.releaseAndTryRemove(pathInZooKeeper, callback);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Verify discarded and callback called&lt;/li&gt;
	&lt;li&gt;assertEquals(0, ZOOKEEPER.getClient().getChildren().forPath(&quot;/&quot;).size());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;sync.await();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;verify(callback, times(1))&lt;/li&gt;
	&lt;li&gt;.apply(any(RetrievableStateHandle.class));&lt;br/&gt;
+		assertEquals(numberOfGlobalDiscardCalls + 1, LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls());&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/** Tests that all state handles are correctly discarded. */&lt;br/&gt;
@@ -454,7 +410,7 @@ public void testReleaseAndTryRemoveAll() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testDiscardAll&quot;;&lt;br/&gt;
@@ -486,8 +442,7 @@ public void testCorruptedData() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;stateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			stateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final Collection&amp;lt;Long&amp;gt; input = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
 		input.add(1L);&lt;br/&gt;
@@ -543,13 +498,11 @@ public void testConcurrentDeleteOperation() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore1 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore2 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final String statePath = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -586,13 +539,11 @@ public void testLockCleanupWhenGetAndLockFails() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore1 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore2 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final String path = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -649,8 +600,7 @@ public void testLockCleanupWhenClientTimesOut() throws Exception {&lt;/p&gt;

&lt;p&gt; 			ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 				client,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+				longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			final String path = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -682,8 +632,7 @@ public void testRelease() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final String path = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -720,8 +669,7 @@ public void testReleaseAll() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final Collection&amp;lt;String&amp;gt; paths = Arrays.asList(&quot;/state1&quot;, &quot;/state2&quot;, &quot;/state3&quot;);&lt;/p&gt;

&lt;p&gt;@@ -775,9 +723,11 @@ public void testReleaseAll() throws Exception {&lt;/p&gt;

&lt;p&gt; 		private static final long serialVersionUID = -3555329254423838912L;&lt;/p&gt;

&lt;p&gt;+		private static int numberOfGlobalDiscardCalls = 0;&lt;br/&gt;
+&lt;br/&gt;
 		private final Long state;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private int numberOfDiscardCalls;&lt;br/&gt;
+		private int numberOfDiscardCalls = 0;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		public LongRetrievableStateHandle(Long state) {&lt;br/&gt;
 			this.state = state;&lt;br/&gt;
@@ -790,6 +740,7 @@ public Long retrieveState() {&lt;/p&gt;

&lt;p&gt; 		@Override&lt;br/&gt;
 		public void discardState() throws Exception &lt;/p&gt;
{
+			numberOfGlobalDiscardCalls++;
 			numberOfDiscardCalls++;
 		}

&lt;p&gt;@@ -798,8 +749,12 @@ public long getStateSize() &lt;/p&gt;
{
 			return 0;
 		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public int getNumberOfDiscardCalls() 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		int getNumberOfDiscardCalls() {
 			return numberOfDiscardCalls;
 		}++		public static int getNumberOfGlobalDiscardCalls() {
+			return numberOfGlobalDiscardCalls;
+		} 	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; }&lt;br/&gt;
diff --git a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala&lt;br/&gt;
index 0640f39f4cf..ebe46399395 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala&lt;br/&gt;
+++ b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala&lt;br/&gt;
@@ -454,6 +454,14 @@ trait TestingJobManagerLike extends FlinkActor 
{
         val receiver = waitForNumRegisteredTaskManagers.dequeue()._2
         receiver ! Acknowledge.get()
       }
&lt;p&gt;+&lt;br/&gt;
+    case WaitForBackgroundTasksToFinish =&amp;gt;&lt;br/&gt;
+      val future = futuresToComplete match &lt;/p&gt;
{
+        case Some(futures) =&amp;gt; Future.sequence(futures)
+        case None =&amp;gt; Future.successful(Seq())
+      }
&lt;p&gt;+&lt;br/&gt;
+      future.pipeTo(sender())&lt;br/&gt;
   }&lt;/p&gt;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   def checkIfAllVerticesRunning(jobID: JobID): Boolean = {&lt;br/&gt;
diff --git a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala&lt;br/&gt;
index c8529a9e07a..64af056f24d 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala&lt;br/&gt;
+++ b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala&lt;br/&gt;
@@ -59,6 +59,8 @@ object TestingJobManagerMessages {&lt;/p&gt;

&lt;p&gt;   case object NotifyListeners&lt;/p&gt;

&lt;p&gt;+  case object WaitForBackgroundTasksToFinish&lt;br/&gt;
+&lt;br/&gt;
   case class NotifyWhenTaskManagerTerminated(taskManager: ActorRef)&lt;br/&gt;
   case class TaskManagerTerminated(taskManager: ActorRef)&lt;/p&gt;

&lt;p&gt;@@ -164,4 +166,5 @@ object TestingJobManagerMessages &lt;/p&gt;
{
   def getClientConnected(): AnyRef = ClientConnected
   def getClassLoadingPropsDelivered(): AnyRef = ClassLoadingPropsDelivered
 
+  def getWaitForBackgroundTasksToFinish(): AnyRef = WaitForBackgroundTasksToFinish
 }




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612262" author="till.rohrmann" created="Wed, 12 Sep 2018 14:52:02 +0000"  >&lt;p&gt;Fixed via&lt;br/&gt;
1.7.0:&lt;br/&gt;
cb69af18c5545b7218ea16d25d0b910f767ccf49&lt;br/&gt;
c395e896e5eb69a8255c372ea656483b05c8f94d&lt;br/&gt;
a933d87e14488da9b7305a671d0cb2e24f43155c&lt;/p&gt;

&lt;p&gt;1.6.1:&lt;br/&gt;
fabd246e5342001d64be55c820ba50b3cf75d2a6&lt;br/&gt;
5e62da0f95d9abe35997e45dc9b0df3a9c7495cd&lt;br/&gt;
4d7204784270b5ad8d5455d82f7a965efdb5ae45&lt;/p&gt;

&lt;p&gt;1.5.4:&lt;br/&gt;
7c56d15b911d4fb87c073a25eb93d61502995c5a&lt;br/&gt;
5c8630cf34b3d3cce5a821972840f0a7c2fa1bb7&lt;br/&gt;
dd096eb44d8401d22f7e3cfaa51345f59abe04d4&lt;/p&gt;

&lt;p&gt;1.4.3:&lt;br/&gt;
d2a828c714188902f2e29da68bf137c3f82de014&lt;br/&gt;
07ab3d9bc567cf67b0d5cb7ae55a185f898cc766&lt;/p&gt;</comment>
                            <comment id="16612264" author="githubbot" created="Wed, 12 Sep 2018 14:52:43 +0000"  >&lt;p&gt;tillrohrmann commented on issue #6590: &lt;span class=&quot;error&quot;&gt;&amp;#91;Backport 1.4&amp;#93;&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6590#issuecomment-420678214&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6590#issuecomment-420678214&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Merged via&lt;br/&gt;
   d2a828c714188902f2e29da68bf137c3f82de014&lt;br/&gt;
   07ab3d9bc567cf67b0d5cb7ae55a185f898cc766&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612265" author="githubbot" created="Wed, 12 Sep 2018 14:52:44 +0000"  >&lt;p&gt;tillrohrmann closed pull request #6590: &lt;span class=&quot;error&quot;&gt;&amp;#91;Backport 1.4&amp;#93;&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10011&quot; title=&quot;Old job resurrected during HA failover&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10011&quot;&gt;&lt;del&gt;FLINK-10011&lt;/del&gt;&lt;/a&gt; Release JobGraph from SubmittedJobGraphStore&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6590&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6590&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java b/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java&lt;br/&gt;
index 069cb833a3a..45d11412c50 100644&lt;br/&gt;
&amp;#8212; a/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java&lt;br/&gt;
+++ b/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/services/ZooKeeperMesosServices.java&lt;br/&gt;
@@ -56,8 +56,7 @@ public MesosWorkerStore createMesosWorkerStore(Configuration configuration, Exec&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;MesosWorkerStore.Worker&amp;gt; zooKeeperStateHandleStore = zooKeeperUtilityFactory.createZooKeeperStateHandleStore(&lt;br/&gt;
 			&quot;/workers&quot;,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;stateStorageHelper,&lt;/li&gt;
	&lt;li&gt;executor);&lt;br/&gt;
+			stateStorageHelper);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperSharedValue frameworkId = zooKeeperUtilityFactory.createSharedValue(&quot;/frameworkId&quot;, new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
 		ZooKeeperSharedCount totalTaskCount = zooKeeperUtilityFactory.createSharedCount(&quot;/taskCount&quot;, 0);&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
index f22127041d3..533026041f8 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
@@ -31,8 +31,6 @@&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;/p&gt;

&lt;p&gt;-import javax.annotation.Nullable;&lt;br/&gt;
-&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.util.ArrayDeque;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
@@ -86,6 +84,8 @@&lt;br/&gt;
 	 */&lt;br/&gt;
 	private final ArrayDeque&amp;lt;CompletedCheckpoint&amp;gt; completedCheckpoints;&lt;/p&gt;

&lt;p&gt;+	private final Executor executor;&lt;br/&gt;
+&lt;br/&gt;
 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Creates a 
{@link ZooKeeperCompletedCheckpointStore} instance.&lt;br/&gt;
 	 *&lt;br/&gt;
@@ -98,7 +98,7 @@&lt;br/&gt;
 	 *                                       start with a &apos;/&apos;)&lt;br/&gt;
 	 * @param stateStorage                   State storage to be used to persist the completed&lt;br/&gt;
 	 *                                       checkpoint&lt;br/&gt;
-	 * @param executor to give to the ZooKeeperStateHandleStore to run ZooKeeper callbacks&lt;br/&gt;
+	 * @param executor to execute blocking calls&lt;br/&gt;
 	 * @throws Exception&lt;br/&gt;
 	 */&lt;br/&gt;
 	public ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
@@ -123,10 +123,12 @@ public ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
 		// All operations will have the path as root&lt;br/&gt;
 		this.client = client.usingNamespace(client.getNamespace() + checkpointsPath);&lt;br/&gt;
 &lt;br/&gt;
-		this.checkpointsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(this.client, stateStorage, executor);&lt;br/&gt;
+		this.checkpointsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(this.client, stateStorage);&lt;br/&gt;
 &lt;br/&gt;
 		this.completedCheckpoints = new ArrayDeque&amp;lt;&amp;gt;(maxNumberOfCheckpointsToRetain + 1);&lt;br/&gt;
 &lt;br/&gt;
+		this.executor = checkNotNull(executor);&lt;br/&gt;
+&lt;br/&gt;
 		LOG.info(&quot;Initialized in &apos;{}&apos;.&quot;, checkpointsPath);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
@@ -237,7 +239,18 @@ public void addCheckpoint(final CompletedCheckpoint checkpoint) throws Exception&lt;br/&gt;
 		// Everything worked, let&apos;s remove a previous checkpoint if necessary.&lt;br/&gt;
 		while (completedCheckpoints.size() &amp;gt; maxNumberOfCheckpointsToRetain) {&lt;br/&gt;
 			try {&lt;br/&gt;
-				removeSubsumed(completedCheckpoints.removeFirst());&lt;br/&gt;
+				final CompletedCheckpoint completedCheckpoint = completedCheckpoints.removeFirst();&lt;br/&gt;
+&lt;br/&gt;
+				if (tryRemove(completedCheckpoint.getCheckpointID())) {&lt;br/&gt;
+					executor.execute(() -&amp;gt; {&lt;br/&gt;
+						try {
+							completedCheckpoint.discardOnSubsume();
+						} catch (Exception e) {&lt;br/&gt;
+							LOG.warn(&quot;Could not discard subsumed completed checkpoint {}.&quot;, completedCheckpoint.getCheckpointID(), e);&lt;br/&gt;
+						}&lt;br/&gt;
+					});&lt;br/&gt;
+&lt;br/&gt;
+				}&lt;br/&gt;
 			} catch (Exception e) {
 				LOG.warn(&quot;Failed to subsume the old checkpoint&quot;, e);
 			}&lt;br/&gt;
@@ -279,7 +292,17 @@ public void shutdown(JobStatus jobStatus) throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 			for (CompletedCheckpoint checkpoint : completedCheckpoints) {&lt;br/&gt;
 				try {&lt;br/&gt;
-					removeShutdown(checkpoint, jobStatus);&lt;br/&gt;
+					if (tryRemove(checkpoint.getCheckpointID())) {&lt;br/&gt;
+						executor.execute(&lt;br/&gt;
+							() -&amp;gt; {&lt;br/&gt;
+								try {
+									checkpoint.discardOnShutdown(jobStatus);
+								} catch (Exception e) {&lt;br/&gt;
+									LOG.warn(&quot;Could not discard completed checkpoint {} on shutdown.&quot;, checkpoint.getCheckpointID(), e);&lt;br/&gt;
+								}&lt;br/&gt;
+							}&lt;br/&gt;
+						);&lt;br/&gt;
+					}&lt;br/&gt;
 				} catch (Exception e) {
 					LOG.error(&quot;Failed to discard checkpoint.&quot;, e);
 				}&lt;br/&gt;
@@ -305,59 +328,13 @@ public void shutdown(JobStatus jobStatus) throws Exception {&lt;br/&gt;
 	// ------------------------------------------------------------------------&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
-	 * Removes a subsumed checkpoint from ZooKeeper and drops the state.&lt;br/&gt;
-	 */&lt;br/&gt;
-	private void removeSubsumed(&lt;br/&gt;
-		final CompletedCheckpoint completedCheckpoint) throws Exception {&lt;br/&gt;
-&lt;br/&gt;
-		if (completedCheckpoint == null) {
-			return;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt; action =&lt;br/&gt;
-			new ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt;() {&lt;br/&gt;
-				@Override&lt;br/&gt;
-				public void apply(@Nullable RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; value) throws FlinkException {&lt;br/&gt;
-					if (value != null) {&lt;br/&gt;
-						try {
-							completedCheckpoint.discardOnSubsume();
-						} catch (Exception e) {
-							throw new FlinkException(&quot;Could not discard the completed checkpoint on subsume.&quot;, e);
-						}&lt;br/&gt;
-					}&lt;br/&gt;
-				}&lt;br/&gt;
-			};&lt;br/&gt;
-&lt;br/&gt;
-		checkpointsInZooKeeper.releaseAndTryRemove(&lt;br/&gt;
-			checkpointIdToPath(completedCheckpoint.getCheckpointID()),&lt;br/&gt;
-			action);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Removes a checkpoint from ZooKeeper because of Job shutdown and drops the state.&lt;br/&gt;
+	 * Tries to remove the checkpoint identified by the given checkpoint id.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param checkpointId identifying the checkpoint to remove&lt;br/&gt;
+	 * @return true if the checkpoint could be removed&lt;br/&gt;
 	 */&lt;br/&gt;
-	private void removeShutdown(&lt;br/&gt;
-			final CompletedCheckpoint completedCheckpoint,&lt;br/&gt;
-			final JobStatus jobStatus) throws Exception {&lt;br/&gt;
-&lt;br/&gt;
-		if (completedCheckpoint == null) {-			return;-		}&lt;br/&gt;
-&lt;br/&gt;
-		ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt; removeAction = new ZooKeeperStateHandleStore.RemoveCallback&amp;lt;CompletedCheckpoint&amp;gt;() {&lt;br/&gt;
-			@Override&lt;br/&gt;
-			public void apply(@Nullable RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; value) throws FlinkException {&lt;br/&gt;
-				try {
-					completedCheckpoint.discardOnShutdown(jobStatus);
-				} catch (Exception e) {
-					throw new FlinkException(&quot;Could not discard the completed checkpoint on subsume.&quot;, e);
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-		};&lt;br/&gt;
-&lt;br/&gt;
-		checkpointsInZooKeeper.releaseAndTryRemove(&lt;br/&gt;
-			checkpointIdToPath(completedCheckpoint.getCheckpointID()),&lt;br/&gt;
-			removeAction);&lt;br/&gt;
+	private boolean tryRemove(long checkpointId) throws Exception {
+		return checkpointsInZooKeeper.releaseAndTryRemove(checkpointIdToPath(checkpointId));
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -381,7 +358,7 @@ public static long pathToCheckpointId(String path) {&lt;br/&gt;
 			String numberString;&lt;br/&gt;
 &lt;br/&gt;
 			// check if we have a leading slash&lt;br/&gt;
-			if (&apos;/&apos; == path.charAt(0) ) {&lt;br/&gt;
+			if (&apos;/&apos; == path.charAt(0)) {
 				numberString = path.substring(1);
 			} else {&lt;br/&gt;
 				numberString = path;&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java&lt;br/&gt;
index 04ab6d3cc96..b5822c5590a 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java&lt;br/&gt;
@@ -163,7 +163,7 @@ public CheckpointRecoveryFactory getCheckpointRecoveryFactory() {&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
 	public SubmittedJobGraphStore getSubmittedJobGraphStore() throws Exception {
-		return ZooKeeperUtils.createSubmittedJobGraphs(client, configuration, executor);
+		return ZooKeeperUtils.createSubmittedJobGraphs(client, configuration);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java&lt;br/&gt;
index d1ca1a38853..f28621f0d69 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/StandaloneSubmittedJobGraphStore.java&lt;br/&gt;
@@ -43,22 +43,27 @@ public void stop() {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public void putJobGraph(SubmittedJobGraph jobGraph) throws Exception {&lt;br/&gt;
+	public void putJobGraph(SubmittedJobGraph jobGraph) {
 		// Nothing to do
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public void removeJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+	public void removeJobGraph(JobID jobId) { 		// Nothing to do 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) {
+		// nothing to do
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public Collection&amp;lt;JobID&amp;gt; getJobIds() {
 		return Collections.emptyList();
 	}&lt;br/&gt;
 &lt;br/&gt;
 	@Override&lt;br/&gt;
-	public SubmittedJobGraph recoverJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+	public SubmittedJobGraph recoverJobGraph(JobID jobId) {
 		return null;
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java&lt;br/&gt;
index 6e91f80ebeb..b622823e7b7 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/SubmittedJobGraphStore.java&lt;br/&gt;
@@ -19,6 +19,7 @@&lt;br/&gt;
 package org.apache.flink.runtime.jobmanager;&lt;br/&gt;
 &lt;br/&gt;
 import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
 &lt;br/&gt;
 import java.util.Collection;&lt;br/&gt;
 &lt;br/&gt;
@@ -56,6 +57,17 @@&lt;br/&gt;
 	 */&lt;br/&gt;
 	void removeJobGraph(JobID jobId) throws Exception;&lt;br/&gt;
 &lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Releases the locks on the specified {@link JobGraph}.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * Releasing the locks allows that another instance can delete the job from&lt;br/&gt;
+	 * the {@link SubmittedJobGraphStore}.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param jobId specifying the job to release the locks for&lt;br/&gt;
+	 * @throws Exception if the locks cannot be released&lt;br/&gt;
+	 */&lt;br/&gt;
+	void releaseJobGraph(JobID jobId) throws Exception;&lt;br/&gt;
+&lt;br/&gt;
 	/**&lt;br/&gt;
 	 * Get all job ids of submitted job graphs to the submitted job graph store.&lt;br/&gt;
 	 *&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java&lt;br/&gt;
index f31c970a8dc..3ac4f25b709 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphStore.java&lt;br/&gt;
@@ -38,7 +38,6 @@&lt;br/&gt;
 import java.util.HashSet;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Set;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
@@ -66,13 +65,13 @@&lt;br/&gt;
 	/** Lock to synchronize with the {@link SubmittedJobGraphListener}. */&lt;br/&gt;
 	private final Object cacheLock = new Object();&lt;br/&gt;
 &lt;br/&gt;
-	/** Client (not a namespace facade) */&lt;br/&gt;
+	/** Client (not a namespace facade). */&lt;br/&gt;
 	private final CuratorFramework client;&lt;br/&gt;
 &lt;br/&gt;
 	/** The set of IDs of all added job graphs. */&lt;br/&gt;
 	private final Set&amp;lt;JobID&amp;gt; addedJobGraphs = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
 &lt;br/&gt;
-	/** Completed checkpoints in ZooKeeper */&lt;br/&gt;
+	/** Completed checkpoints in ZooKeeper. */&lt;br/&gt;
 	private final ZooKeeperStateHandleStore&amp;lt;SubmittedJobGraph&amp;gt; jobGraphsInZooKeeper;&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -91,19 +90,17 @@&lt;br/&gt;
 	private boolean isRunning;&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
-	 * Submitted job graph store backed by ZooKeeper&lt;br/&gt;
+	 * Submitted job graph store backed by ZooKeeper.&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param client ZooKeeper client&lt;br/&gt;
 	 * @param currentJobsPath ZooKeeper path for current job graphs&lt;br/&gt;
 	 * @param stateStorage State storage used to persist the submitted jobs&lt;br/&gt;
-	 * @param executor to give to the ZooKeeperStateHandleStore to run ZooKeeper callbacks&lt;br/&gt;
 	 * @throws Exception&lt;br/&gt;
 	 */&lt;br/&gt;
 	public ZooKeeperSubmittedJobGraphStore(&lt;br/&gt;
 			CuratorFramework client,&lt;br/&gt;
 			String currentJobsPath,&lt;br/&gt;
-			RetrievableStateStorageHelper&amp;lt;SubmittedJobGraph&amp;gt; stateStorage,&lt;br/&gt;
-			Executor executor) throws Exception {&lt;br/&gt;
+			RetrievableStateStorageHelper&amp;lt;SubmittedJobGraph&amp;gt; stateStorage) throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 		checkNotNull(currentJobsPath, &quot;Current jobs path&quot;);&lt;br/&gt;
 		checkNotNull(stateStorage, &quot;State storage&quot;);&lt;br/&gt;
@@ -120,7 +117,7 @@ public ZooKeeperSubmittedJobGraphStore(&lt;br/&gt;
 		CuratorFramework facade = client.usingNamespace(client.getNamespace() + currentJobsPath);&lt;br/&gt;
 &lt;br/&gt;
 		this.zooKeeperFullBasePath = client.getNamespace() + currentJobsPath;&lt;br/&gt;
-		this.jobGraphsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(facade, stateStorage, executor);&lt;br/&gt;
+		this.jobGraphsInZooKeeper = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(facade, stateStorage);&lt;br/&gt;
 &lt;br/&gt;
 		this.pathCache = new PathChildrenCache(facade, &quot;/&quot;, false);&lt;br/&gt;
 		pathCache.getListenable().addListener(new SubmittedJobGraphsPathCacheListener());&lt;br/&gt;
@@ -272,6 +269,24 @@ public void removeJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
 		LOG.info(&quot;Removed job graph {} from ZooKeeper.&quot;, jobId);&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void releaseJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
+		checkNotNull(jobId, &quot;Job ID&quot;);&lt;br/&gt;
+		final String path = getPathForJob(jobId);&lt;br/&gt;
+&lt;br/&gt;
+		LOG.debug(&quot;Releasing locks of job graph {} from {}{}.&quot;, jobId, zooKeeperFullBasePath, path);&lt;br/&gt;
+&lt;br/&gt;
+		synchronized (cacheLock) {&lt;br/&gt;
+			if (addedJobGraphs.contains(jobId)) {
+				jobGraphsInZooKeeper.release(path);
+
+				addedJobGraphs.remove(jobId);
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		LOG.info(&quot;Released locks of job graph {} from ZooKeeper.&quot;, jobId);&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
 		Collection&amp;lt;String&amp;gt; paths;&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java&lt;br/&gt;
index a7ac500a1d7..bd7b74ce1d4 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java&lt;br/&gt;
@@ -18,12 +18,6 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.flink.runtime.util;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.commons.lang3.StringUtils;&lt;br/&gt;
-import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
-import org.apache.curator.framework.CuratorFrameworkFactory;&lt;br/&gt;
-import org.apache.curator.framework.api.ACLProvider;&lt;br/&gt;
-import org.apache.curator.framework.imps.DefaultACLProvider;&lt;br/&gt;
-import org.apache.curator.retry.ExponentialBackoffRetry;&lt;br/&gt;
 import org.apache.flink.api.common.JobID;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
 import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
@@ -41,6 +35,13 @@&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.filesystem.FileSystemStateStorageHelper;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.commons.lang3.StringUtils;&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.apache.curator.framework.CuratorFrameworkFactory;&lt;br/&gt;
+import org.apache.curator.framework.api.ACLProvider;&lt;br/&gt;
+import org.apache.curator.framework.imps.DefaultACLProvider;&lt;br/&gt;
+import org.apache.curator.retry.ExponentialBackoffRetry;&lt;br/&gt;
 import org.apache.zookeeper.ZooDefs;&lt;br/&gt;
 import org.apache.zookeeper.data.ACL;&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
@@ -53,6 +54,9 @@&lt;br/&gt;
 &lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * Class containing helper functions to interact with ZooKeeper.&lt;br/&gt;
+ */&lt;br/&gt;
 public class ZooKeeperUtils {&lt;br/&gt;
 &lt;br/&gt;
 	private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperUtils.class);&lt;br/&gt;
@@ -92,14 +96,14 @@ public static CuratorFramework startCuratorFramework(Configuration configuration&lt;br/&gt;
 &lt;br/&gt;
 		ZkClientACLMode aclMode = ZkClientACLMode.fromConfig(configuration);&lt;br/&gt;
 &lt;br/&gt;
-		if(disableSaslClient &amp;amp;&amp;amp; aclMode == ZkClientACLMode.CREATOR) {&lt;br/&gt;
-			String errorMessage = &quot;Cannot set ACL role to &quot; + aclMode +&quot;  since SASL authentication is &quot; +&lt;br/&gt;
+		if (disableSaslClient &amp;amp;&amp;amp; aclMode == ZkClientACLMode.CREATOR) {
+			String errorMessage = &quot;Cannot set ACL role to &quot; + aclMode + &quot;  since SASL authentication is &quot; +
 					&quot;disabled through the &quot; + SecurityOptions.ZOOKEEPER_SASL_DISABLE.key() + &quot; property&quot;;
 			LOG.warn(errorMessage);
 			throw new IllegalConfigurationException(errorMessage);
 		}&lt;br/&gt;
 &lt;br/&gt;
-		if(aclMode == ZkClientACLMode.CREATOR) {&lt;br/&gt;
+		if (aclMode == ZkClientACLMode.CREATOR) {
 			LOG.info(&quot;Enforcing creator for ZK connections&quot;);
 			aclProvider = new SecureAclProvider();
 		} else {
@@ -107,7 +111,6 @@ public static CuratorFramework startCuratorFramework(Configuration configuration
 			aclProvider = new DefaultACLProvider();
 		}&lt;br/&gt;
 &lt;br/&gt;
-&lt;br/&gt;
 		String rootWithNamespace = generateZookeeperPath(root, namespace);&lt;br/&gt;
 &lt;br/&gt;
 		LOG.info(&quot;Using &apos;{}&apos; as Zookeeper namespace.&quot;, rootWithNamespace);&lt;br/&gt;
@@ -164,8 +167,7 @@ public static String getZooKeeperEnsemble(Configuration flinkConf)&lt;br/&gt;
 	 */&lt;br/&gt;
 	public static ZooKeeperLeaderRetrievalService createLeaderRetrievalService(&lt;br/&gt;
 		final CuratorFramework client,&lt;br/&gt;
-		final Configuration configuration) throws Exception&lt;br/&gt;
-	{&lt;br/&gt;
+		final Configuration configuration) throws Exception {
 		return createLeaderRetrievalService(client, configuration, &quot;&quot;);
 	}&lt;br/&gt;
 &lt;br/&gt;
@@ -181,8 +183,7 @@ public static ZooKeeperLeaderRetrievalService createLeaderRetrievalService(&lt;br/&gt;
 	public static ZooKeeperLeaderRetrievalService createLeaderRetrievalService(&lt;br/&gt;
 		final CuratorFramework client,&lt;br/&gt;
 		final Configuration configuration,&lt;br/&gt;
-		final String pathSuffix)&lt;br/&gt;
-	{&lt;br/&gt;
+		final String pathSuffix) {&lt;br/&gt;
 		String leaderPath = configuration.getString(&lt;br/&gt;
 			HighAvailabilityOptions.HA_ZOOKEEPER_LEADER_PATH) + pathSuffix;&lt;br/&gt;
 &lt;br/&gt;
@@ -214,8 +215,7 @@ public static ZooKeeperLeaderElectionService createLeaderElectionService(&lt;br/&gt;
 	public static ZooKeeperLeaderElectionService createLeaderElectionService(&lt;br/&gt;
 		final CuratorFramework client,&lt;br/&gt;
 		final Configuration configuration,&lt;br/&gt;
-		final String pathSuffix)&lt;br/&gt;
-	{&lt;br/&gt;
+		final String pathSuffix) {&lt;br/&gt;
 		final String latchPath = configuration.getString(&lt;br/&gt;
 			HighAvailabilityOptions.HA_ZOOKEEPER_LATCH_PATH) + pathSuffix;&lt;br/&gt;
 		final String leaderPath = configuration.getString(&lt;br/&gt;
@@ -229,14 +229,12 @@ public static ZooKeeperLeaderElectionService createLeaderElectionService(&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param client        The {@link CuratorFramework} ZooKeeper client to use&lt;br/&gt;
 	 * @param configuration {@link Configuration} object&lt;br/&gt;
-	 * @param executor to run ZooKeeper callbacks&lt;br/&gt;
 	 * @return {@link ZooKeeperSubmittedJobGraphStore} instance&lt;br/&gt;
 	 * @throws Exception if the submitted job graph store cannot be created&lt;br/&gt;
 	 */&lt;br/&gt;
 	public static ZooKeeperSubmittedJobGraphStore createSubmittedJobGraphs(&lt;br/&gt;
 			CuratorFramework client,&lt;br/&gt;
-			Configuration configuration,&lt;br/&gt;
-			Executor executor) throws Exception {&lt;br/&gt;
+			Configuration configuration) throws Exception {
 
 		checkNotNull(configuration, &quot;Configuration&quot;);
 
@@ -246,7 +244,9 @@ public static ZooKeeperSubmittedJobGraphStore createSubmittedJobGraphs(
 		String zooKeeperSubmittedJobsPath = configuration.getString(HighAvailabilityOptions.HA_ZOOKEEPER_JOBGRAPHS_PATH);
 
 		return new ZooKeeperSubmittedJobGraphStore(
-				client, zooKeeperSubmittedJobsPath, stateStorage, executor);
+			client,
+			zooKeeperSubmittedJobsPath,
+			stateStorage);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -346,22 +346,24 @@ public static String generateZookeeperPath(String root, String namespace) {
 		return root + namespace;
 	}&lt;br/&gt;
 &lt;br/&gt;
-&lt;br/&gt;
-	public static class SecureAclProvider implements ACLProvider&lt;br/&gt;
-	{&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Secure {@link ACLProvider} implementation.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static class SecureAclProvider implements ACLProvider {&lt;br/&gt;
 		@Override&lt;br/&gt;
-		public List&amp;lt;ACL&amp;gt; getDefaultAcl()&lt;br/&gt;
-		{&lt;br/&gt;
+		public List&amp;lt;ACL&amp;gt; getDefaultAcl() {
 			return ZooDefs.Ids.CREATOR_ALL_ACL;
 		}&lt;br/&gt;
 &lt;br/&gt;
 		@Override&lt;br/&gt;
-		public List&amp;lt;ACL&amp;gt; getAclForPath(String path)&lt;br/&gt;
-		{&lt;br/&gt;
+		public List&amp;lt;ACL&amp;gt; getAclForPath(String path) { 			return ZooDefs.Ids.CREATOR_ALL_ACL; 		}&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	/**&lt;br/&gt;
+	 * ZooKeeper client ACL mode enum.&lt;br/&gt;
+	 */&lt;br/&gt;
 	public enum ZkClientACLMode {&lt;br/&gt;
 		CREATOR,&lt;br/&gt;
 		OPEN;&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
index f0d67fd2a87..f266e36471c 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
@@ -18,17 +18,13 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.flink.runtime.zookeeper;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
-import org.apache.curator.framework.api.BackgroundCallback;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEvent;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEventType;&lt;br/&gt;
-import org.apache.curator.utils.ZKPaths;&lt;br/&gt;
 import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
 import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
 import org.apache.flink.util.ExceptionUtils;&lt;br/&gt;
-import org.apache.flink.util.FlinkException;&lt;br/&gt;
 import org.apache.flink.util.InstantiationUtil;&lt;br/&gt;
-import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.apache.curator.utils.ZKPaths;&lt;br/&gt;
 import org.apache.zookeeper.CreateMode;&lt;br/&gt;
 import org.apache.zookeeper.KeeperException;&lt;br/&gt;
 import org.apache.zookeeper.data.Stat;&lt;br/&gt;
@@ -36,6 +32,7 @@&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
 &lt;br/&gt;
 import javax.annotation.Nullable;&lt;br/&gt;
+&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.io.Serializable;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
@@ -44,7 +41,6 @@&lt;br/&gt;
 import java.util.ConcurrentModificationException;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.UUID;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
 &lt;br/&gt;
@@ -68,13 +64,13 @@&lt;br/&gt;
  * State handle in ZooKeeper =&amp;gt; State handle exists&lt;br/&gt;
  * &amp;lt;/pre&amp;gt;&lt;br/&gt;
  *&lt;br/&gt;
- * But not:&lt;br/&gt;
+ * &amp;lt;p&amp;gt;But not:&lt;br/&gt;
  *&lt;br/&gt;
  * &amp;lt;pre&amp;gt;&lt;br/&gt;
  * State handle exists =&amp;gt; State handle in ZooKeeper&lt;br/&gt;
  * &amp;lt;/pre&amp;gt;&lt;br/&gt;
  *&lt;br/&gt;
- * There can be lingering state handles when failures happen during operation. They&lt;br/&gt;
+ * &amp;lt;p&amp;gt;There can be lingering state handles when failures happen during operation. They&lt;br/&gt;
  * need to be cleaned up manually (see &amp;lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-2513&quot;&amp;gt;&lt;br/&gt;
  * &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-2513&quot; title=&quot;Extend state handle provider interface to list all state handles&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-2513&quot;&gt;&lt;del&gt;FLINK-2513&lt;/del&gt;&lt;/a&gt;&amp;lt;/a&amp;gt; about a possible way to overcome this).&lt;br/&gt;
  *&lt;br/&gt;
@@ -84,13 +80,11 @@&lt;br/&gt;
 &lt;br/&gt;
 	public static Logger LOG = LoggerFactory.getLogger(ZooKeeperStateHandleStore.class);&lt;br/&gt;
 &lt;br/&gt;
-	/** Curator ZooKeeper client */&lt;br/&gt;
+	/** Curator ZooKeeper client. */&lt;br/&gt;
 	private final CuratorFramework client;&lt;br/&gt;
 &lt;br/&gt;
 	private final RetrievableStateStorageHelper&amp;lt;T&amp;gt; storage;&lt;br/&gt;
 &lt;br/&gt;
-	private final Executor executor;&lt;br/&gt;
-&lt;br/&gt;
 	/** Lock node name of this ZooKeeperStateHandleStore. The name should be unique among all other state handle stores. */&lt;br/&gt;
 	private final String lockNode;&lt;br/&gt;
 &lt;br/&gt;
@@ -103,16 +97,13 @@&lt;br/&gt;
 	 *                            instance, e.g. &amp;lt;code&amp;gt;client.usingNamespace(&quot;/stateHandles&quot;)&amp;lt;/code&amp;gt;&lt;br/&gt;
 	 * @param storage to persist the actual state and whose returned state handle is then written&lt;br/&gt;
 	 *                to ZooKeeper&lt;br/&gt;
-	 * @param executor to run the ZooKeeper callbacks&lt;br/&gt;
 	 */&lt;br/&gt;
 	public ZooKeeperStateHandleStore(&lt;br/&gt;
 		CuratorFramework client,&lt;br/&gt;
-		RetrievableStateStorageHelper&amp;lt;T&amp;gt; storage,&lt;br/&gt;
-		Executor executor) {&lt;br/&gt;
+		RetrievableStateStorageHelper&amp;lt;T&amp;gt; storage) {&lt;br/&gt;
 &lt;br/&gt;
 		this.client = checkNotNull(client, &quot;Curator client&quot;);&lt;br/&gt;
 		this.storage = checkNotNull(storage, &quot;State storage&quot;);&lt;br/&gt;
-		this.executor = checkNotNull(executor);&lt;br/&gt;
 &lt;br/&gt;
 		// Generate a unique lock node name&lt;br/&gt;
 		lockNode = UUID.randomUUID().toString();&lt;br/&gt;
@@ -262,7 +253,7 @@ public int exists(String pathInZooKeeper) throws Exception {&lt;br/&gt;
 	public Collection&amp;lt;String&amp;gt; getAllPaths() throws Exception {&lt;br/&gt;
 		final String path = &quot;/&quot;;&lt;br/&gt;
 &lt;br/&gt;
-		while(true) {&lt;br/&gt;
+		while (true) {&lt;br/&gt;
 			Stat stat = client.checkExists().forPath(path);&lt;br/&gt;
 &lt;br/&gt;
 			if (stat == null) {&lt;br/&gt;
@@ -393,33 +384,14 @@ public int exists(String pathInZooKeeper) throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
 	 * Releases the lock for the given state node and tries to remove the state node if it is no longer locked.&lt;br/&gt;
-	 * The deletion of the state node is executed asynchronously.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Important&amp;lt;/strong&amp;gt;: This also discards the stored state handle after the given action&lt;br/&gt;
-	 * has been executed.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param pathInZooKeeper Path of state handle to remove (expected to start with a &apos;/&apos;)&lt;br/&gt;
-	 * @throws Exception If the ZooKeeper operation fails&lt;br/&gt;
-	 */&lt;br/&gt;
-	public void releaseAndTryRemove(String pathInZooKeeper) throws Exception {
-		releaseAndTryRemove(pathInZooKeeper, null);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Releases the lock for the given state node and tries to remove the state node if it is no longer locked.&lt;br/&gt;
-	 * The deletion of the state node is executed asynchronously. After the state node has been deleted, the given&lt;br/&gt;
-	 * callback is called with the {@link RetrievableStateHandle} of the deleted state node.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Important&amp;lt;/strong&amp;gt;: This also discards the stored state handle after the given action&lt;br/&gt;
-	 * has been executed.&lt;br/&gt;
+	 * It returns the {@link RetrievableStateHandle} stored under the given state node if any.&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param pathInZooKeeper Path of state handle to remove&lt;br/&gt;
-	 * @param callback The callback to execute after a successful deletion. Null if no action needs to be executed.&lt;br/&gt;
-	 * @throws Exception If the ZooKeeper operation fails&lt;br/&gt;
+	 * @return True if the state handle could be released&lt;br/&gt;
+	 * @throws Exception If the ZooKeeper operation or discarding the state handle fails&lt;br/&gt;
 	 */&lt;br/&gt;
-	public void releaseAndTryRemove(&lt;br/&gt;
-			String pathInZooKeeper,&lt;br/&gt;
-			@Nullable final RemoveCallback&amp;lt;T&amp;gt; callback) throws Exception {&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public boolean releaseAndTryRemove(String pathInZooKeeper) throws Exception {&lt;br/&gt;
 		checkNotNull(pathInZooKeeper, &quot;Path in ZooKeeper&quot;);&lt;br/&gt;
 &lt;br/&gt;
 		final String path = normalizePath(pathInZooKeeper);&lt;br/&gt;
@@ -429,14 +401,23 @@ public void releaseAndTryRemove(&lt;br/&gt;
 		try {
 			stateHandle = get(path, false);
 		} catch (Exception e) {&lt;br/&gt;
-			LOG.warn(&quot;Could not retrieve the state handle from node &quot; + path + &apos;.&apos;, e);&lt;br/&gt;
+			LOG.warn(&quot;Could not retrieve the state handle from node {}.&quot;, path, e);&lt;br/&gt;
 		}&lt;br/&gt;
 &lt;br/&gt;
 		release(pathInZooKeeper);&lt;br/&gt;
 &lt;br/&gt;
-		final BackgroundCallback backgroundCallback = new RemoveBackgroundCallback&amp;lt;&amp;gt;(stateHandle, callback, path);&lt;br/&gt;
+		try {
+			client.delete().forPath(path);
+		} catch (KeeperException.NotEmptyException ignored) {&lt;br/&gt;
+			LOG.debug(&quot;Could not delete znode {} because it is still locked.&quot;, path);&lt;br/&gt;
+			return false;&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		if (stateHandle != null) {
+			stateHandle.discardState();
+		}&lt;br/&gt;
 &lt;br/&gt;
-		client.delete().inBackground(backgroundCallback, executor).forPath(path);&lt;br/&gt;
+		return true;&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
@@ -583,7 +564,7 @@ protected String getLockPath(String rootPath) {&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
-	 * Makes sure that every path starts with a &quot;/&quot;&lt;br/&gt;
+	 * Makes sure that every path starts with a &quot;/&quot;.&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param path Path to normalize&lt;br/&gt;
 	 * @return Normalized path such that it starts with a &quot;/&quot;&lt;br/&gt;
@@ -595,103 +576,4 @@ private static String normalizePath(String path) {
 			return &apos;/&apos; + path;
 		}&lt;br/&gt;
 	}&lt;br/&gt;
-&lt;br/&gt;
-	// ---------------------------------------------------------------------------------------------------------&lt;br/&gt;
-	// Utility classes&lt;br/&gt;
-	// ---------------------------------------------------------------------------------------------------------&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Callback which is executed when removing a node from ZooKeeper. The callback will call the given&lt;br/&gt;
-	 * {@link RemoveCallback} if it is not null. Afterwards, it will discard the given {@link RetrievableStateHandle}&lt;br/&gt;
-	 * if it is not null.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param &amp;lt;T&amp;gt; Type of the value stored in the RetrievableStateHandle&lt;br/&gt;
-	 */&lt;br/&gt;
-	private static final class RemoveBackgroundCallback&amp;lt;T extends Serializable&amp;gt; implements BackgroundCallback {&lt;br/&gt;
-		@Nullable&lt;br/&gt;
-		private final RetrievableStateHandle&amp;lt;T&amp;gt; stateHandle;&lt;br/&gt;
-&lt;br/&gt;
-		@Nullable&lt;br/&gt;
-		private final RemoveCallback&amp;lt;T&amp;gt; callback;&lt;br/&gt;
-&lt;br/&gt;
-		private final String pathInZooKeeper;&lt;br/&gt;
-&lt;br/&gt;
-		private RemoveBackgroundCallback(&lt;br/&gt;
-			@Nullable RetrievableStateHandle&amp;lt;T&amp;gt; stateHandle,&lt;br/&gt;
-			@Nullable RemoveCallback&amp;lt;T&amp;gt; callback,&lt;br/&gt;
-			String pathInZooKeeper) {
-
-			this.stateHandle = stateHandle;
-			this.callback = callback;
-			this.pathInZooKeeper = Preconditions.checkNotNull(pathInZooKeeper);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Override&lt;br/&gt;
-		public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {&lt;br/&gt;
-			try {&lt;br/&gt;
-				if (event.getType() == CuratorEventType.DELETE) {&lt;br/&gt;
-					final KeeperException.Code resultCode = KeeperException.Code.get(event.getResultCode());&lt;br/&gt;
-&lt;br/&gt;
-					if (resultCode == KeeperException.Code.OK) {&lt;br/&gt;
-						Exception exception = null;&lt;br/&gt;
-&lt;br/&gt;
-						if (null != callback) {&lt;br/&gt;
-							try {
-								callback.apply(stateHandle);
-							} catch (Throwable e) {
-								exception = new Exception(&quot;Could not execute delete action for node &quot; +
-									pathInZooKeeper + &apos;.&apos;, e);
-							}&lt;br/&gt;
-						}&lt;br/&gt;
-&lt;br/&gt;
-						if (stateHandle != null) {&lt;br/&gt;
-							try {
-								// Discard the state handle
-								stateHandle.discardState();
-							} catch (Throwable e) {&lt;br/&gt;
-								Exception newException = new Exception(&quot;Could not discard state handle of node &quot; +&lt;br/&gt;
-									pathInZooKeeper + &apos;.&apos;, e);&lt;br/&gt;
-&lt;br/&gt;
-								if (exception == null) {
-									exception = newException;
-								} else {
-									exception.addSuppressed(newException);
-								}&lt;br/&gt;
-							}&lt;br/&gt;
-						}&lt;br/&gt;
-&lt;br/&gt;
-						if (exception != null) {
-							throw exception;
-						}&lt;br/&gt;
-					} else if (resultCode == KeeperException.Code.NOTEMPTY) {
-						// Could not delete the node because it still contains children/locks
-						LOG.debug(&quot;Could not delete node &quot; + pathInZooKeeper + &quot; because it is still locked.&quot;);
-					} else {
-						throw new IllegalStateException(&quot;Unexpected result code &quot; +
-							resultCode.name() + &quot; in &apos;&quot; + event + &quot;&apos; callback.&quot;);
-					}&lt;br/&gt;
-				} else {
-					throw new IllegalStateException(&quot;Unexpected event type &quot; +
-						event.getType() + &quot; in &apos;&quot; + event + &quot;&apos; callback.&quot;);
-				}&lt;br/&gt;
-			} catch (Exception e) {
-				LOG.warn(&quot;Failed to run callback for delete operation on node &quot; + pathInZooKeeper + &apos;.&apos;, e);
-			}&lt;br/&gt;
-&lt;br/&gt;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Callback interface for remove calls&lt;br/&gt;
-	 */&lt;br/&gt;
-	public interface RemoveCallback&amp;lt;T extends Serializable&amp;gt; {&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * Callback method. The parameter can be null if the {@link RetrievableStateHandle} could not be retrieved&lt;br/&gt;
-		 * from ZooKeeper.&lt;br/&gt;
-		 *&lt;br/&gt;
-		 * @param value RetrievableStateHandle retrieved from ZooKeeper, null if it was not retrievable&lt;br/&gt;
-		 * @throws FlinkException If the callback failed&lt;br/&gt;
-		 */&lt;br/&gt;
-		void apply(@Nullable RetrievableStateHandle&amp;lt;T&amp;gt; value) throws FlinkException;&lt;br/&gt;
-	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java&lt;br/&gt;
index d3b7dc5b379..3e294e0dbdd 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperUtilityFactory.java&lt;br/&gt;
@@ -18,15 +18,15 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.flink.runtime.zookeeper;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
-import org.apache.curator.framework.recipes.shared.SharedCount;&lt;br/&gt;
-import org.apache.curator.framework.recipes.shared.SharedValue;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
 import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;br/&gt;
 &lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.apache.curator.framework.recipes.shared.SharedCount;&lt;br/&gt;
+import org.apache.curator.framework.recipes.shared.SharedValue;&lt;br/&gt;
+&lt;br/&gt;
 import java.io.Serializable;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * Creates ZooKeeper utility classes without exposing the {@link CuratorFramework} dependency. The&lt;br/&gt;
@@ -71,7 +71,6 @@ public void close(boolean cleanup) throws Exception {&lt;br/&gt;
 	 *&lt;br/&gt;
 	 * @param zkStateHandleStorePath specifying the path in ZooKeeper to store the state handles to&lt;br/&gt;
 	 * @param stateStorageHelper storing the actual state data&lt;br/&gt;
-	 * @param executor to run asynchronous callbacks of the state handle store&lt;br/&gt;
 	 * @param &amp;lt;T&amp;gt; Type of the state to be stored&lt;br/&gt;
 	 * @return a ZooKeeperStateHandleStore instance&lt;br/&gt;
 	 * @throws Exception if ZooKeeper could not create the provided state handle store path in&lt;br/&gt;
@@ -79,8 +78,7 @@ public void close(boolean cleanup) throws Exception {&lt;br/&gt;
 	 */&lt;br/&gt;
 	public &amp;lt;T extends Serializable&amp;gt; ZooKeeperStateHandleStore&amp;lt;T&amp;gt; createZooKeeperStateHandleStore(&lt;br/&gt;
 			String zkStateHandleStorePath,&lt;br/&gt;
-			RetrievableStateStorageHelper&amp;lt;T&amp;gt; stateStorageHelper,&lt;br/&gt;
-			Executor executor) throws Exception {&lt;br/&gt;
+			RetrievableStateStorageHelper&amp;lt;T&amp;gt; stateStorageHelper) throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 		facade.newNamespaceAwareEnsurePath(zkStateHandleStorePath).ensure(facade.getZookeeperClient());&lt;br/&gt;
 		CuratorFramework stateHandleStoreFacade = facade.usingNamespace(&lt;br/&gt;
@@ -88,7 +86,7 @@ public void close(boolean cleanup) throws Exception {
 				facade.getNamespace(),
 				zkStateHandleStorePath));
 
-		return new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(stateHandleStoreFacade, stateStorageHelper, executor);
+		return new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(stateHandleStoreFacade, stateStorageHelper);
 	}&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
diff --git a/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala b/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala&lt;br/&gt;
index af42870ab69..27286969a0f 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala&lt;br/&gt;
+++ b/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala&lt;br/&gt;
@@ -1727,27 +1727,27 @@ class JobManager(&lt;br/&gt;
     // Don&apos;t remove the job yet...&lt;br/&gt;
     val futureOption = currentJobs.get(jobID) match {&lt;br/&gt;
       case Some((eg, _)) =&amp;gt;&lt;br/&gt;
-        val result = if (removeJobFromStateBackend) {&lt;br/&gt;
-          val futureOption = Some(future {&lt;br/&gt;
-            try {&lt;br/&gt;
+        val result = Some(future {&lt;br/&gt;
+          try {&lt;br/&gt;
+            if (removeJobFromStateBackend) {
               // ...otherwise, we can have lingering resources when there is a  concurrent shutdown
               // and the ZooKeeper client is closed. Not removing the job immediately allow the
               // shutdown to release all resources.
               submittedJobGraphs.removeJobGraph(jobID)
-            } catch {
-              case t: Throwable =&amp;gt; log.warn(s&quot;Could not remove submitted job graph $jobID.&quot;, t)
+            } else {
+              submittedJobGraphs.releaseJobGraph(jobID)
             }&lt;br/&gt;
-          }(context.dispatcher))&lt;br/&gt;
+          } catch {
+            case t: Throwable =&amp;gt; log.warn(s&quot;Could not remove submitted job graph $jobID.&quot;, t)
+          }&lt;br/&gt;
+        }(context.dispatcher))&lt;br/&gt;
 &lt;br/&gt;
+        if (removeJobFromStateBackend) {&lt;br/&gt;
           try {
             archive ! decorateMessage(ArchiveExecutionGraph(jobID, eg.archive()))
           } catch {
             case t: Throwable =&amp;gt; log.warn(s&quot;Could not archive the execution graph $eg.&quot;, t)
           }&lt;br/&gt;
-&lt;br/&gt;
-          futureOption&lt;br/&gt;
-        } else {
-          None
         }&lt;br/&gt;
 &lt;br/&gt;
         currentJobs.remove(jobID)&lt;br/&gt;
@@ -1772,18 +1772,23 @@ class JobManager(&lt;br/&gt;
     */&lt;br/&gt;
   private def cancelAndClearEverything(cause: Throwable)&lt;br/&gt;
     : Seq[Future&lt;span class=&quot;error&quot;&gt;&amp;#91;Unit&amp;#93;&lt;/span&gt;] = {&lt;br/&gt;
-    val futures = for ((jobID, (eg, jobInfo)) &amp;lt;- currentJobs) yield {&lt;br/&gt;
-      future {&lt;br/&gt;
-        eg.suspend(cause)&lt;br/&gt;
+&lt;br/&gt;
+    val futures = currentJobs.values.flatMap(&lt;br/&gt;
+      egJobInfo =&amp;gt; {
+        val executionGraph = egJobInfo._1
+        val jobInfo = egJobInfo._2
+
+        executionGraph.suspend(cause)
+
+        val jobId = executionGraph.getJobID
 
         jobInfo.notifyNonDetachedClients(
           decorateMessage(
             Failure(
-              new JobExecutionException(jobID, &quot;All jobs are cancelled and cleared.&quot;, cause))))
-      }(context.dispatcher)&lt;br/&gt;
-    }&lt;br/&gt;
+              new JobExecutionException(jobId, &quot;All jobs are cancelled and cleared.&quot;, cause))))&lt;br/&gt;
 &lt;br/&gt;
-    currentJobs.clear()&lt;br/&gt;
+        removeJob(jobId, false)&lt;br/&gt;
+      })&lt;br/&gt;
 &lt;br/&gt;
     futures.toSeq&lt;br/&gt;
   }&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java&lt;br/&gt;
index 320dc2df52b..b1fa9b4124e 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java&lt;br/&gt;
@@ -191,7 +191,7 @@ public void testDiscardAllCheckpoints() throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 	// ---------------------------------------------------------------------------------------------&lt;br/&gt;
 &lt;br/&gt;
-	protected TestCompletedCheckpoint createCheckpoint(&lt;br/&gt;
+	public static TestCompletedCheckpoint createCheckpoint(&lt;br/&gt;
 		int id,&lt;br/&gt;
 		SharedStateRegistry sharedStateRegistry) throws IOException {
 
@@ -224,7 +224,12 @@ protected void verifyCheckpointRegistered(Collection&amp;lt;OperatorState&amp;gt; operatorStat
 		}&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
-	protected void verifyCheckpointDiscarded(Collection&amp;lt;OperatorState&amp;gt; operatorStates) {&lt;br/&gt;
+	public static void verifyCheckpointDiscarded(TestCompletedCheckpoint completedCheckpoint) {
+		assertTrue(completedCheckpoint.isDiscarded());
+		verifyCheckpointDiscarded(completedCheckpoint.getOperatorStates().values());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	protected static void verifyCheckpointDiscarded(Collection&amp;lt;OperatorState&amp;gt; operatorStates) {&lt;br/&gt;
 		for (OperatorState operatorState : operatorStates) {&lt;br/&gt;
 			for (OperatorSubtaskState subtaskState : operatorState.getStates()) {&lt;br/&gt;
 				Assert.assertTrue(((TestOperatorSubtaskState)subtaskState).discarded);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..4e7f2405795&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java&lt;br/&gt;
@@ -0,0 +1,260 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.checkpoint;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
+import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.apache.curator.framework.api.BackgroundCallback;&lt;br/&gt;
+import org.apache.curator.framework.api.CuratorEvent;&lt;br/&gt;
+import org.apache.curator.framework.api.CuratorEventType;&lt;br/&gt;
+import org.apache.curator.framework.api.ErrorListenerPathable;&lt;br/&gt;
+import org.apache.curator.utils.EnsurePath;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.runner.RunWith;&lt;br/&gt;
+import org.mockito.Mockito;&lt;br/&gt;
+import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
+import org.mockito.stubbing.Answer;&lt;br/&gt;
+import org.powermock.core.classloader.annotations.PrepareForTest;&lt;br/&gt;
+import org.powermock.modules.junit4.PowerMockRunner;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.ArrayList;&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.Collections;&lt;br/&gt;
+import java.util.HashMap;&lt;br/&gt;
+import java.util.HashSet;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+import java.util.concurrent.Executor;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertEquals;&lt;br/&gt;
+import static org.junit.Assert.assertFalse;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+import static org.mockito.Matchers.any;&lt;br/&gt;
+import static org.mockito.Matchers.anyString;&lt;br/&gt;
+import static org.mockito.Mockito.doReturn;&lt;br/&gt;
+import static org.mockito.Mockito.mock;&lt;br/&gt;
+import static org.mockito.Mockito.never;&lt;br/&gt;
+import static org.mockito.Mockito.spy;&lt;br/&gt;
+import static org.mockito.Mockito.verify;&lt;br/&gt;
+import static org.mockito.Mockito.when;&lt;br/&gt;
+import static org.powermock.api.mockito.PowerMockito.doAnswer;&lt;br/&gt;
+import static org.powermock.api.mockito.PowerMockito.doThrow;&lt;br/&gt;
+import static org.powermock.api.mockito.PowerMockito.whenNew;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Mockito based tests for the {@link ZooKeeperStateHandleStore}.&lt;br/&gt;
+ */&lt;br/&gt;
+@RunWith(PowerMockRunner.class)&lt;br/&gt;
+@PrepareForTest(ZooKeeperCompletedCheckpointStore.class)&lt;br/&gt;
+public class ZooKeeperCompletedCheckpointStoreMockitoTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the completed checkpoint store can retrieve all checkpoints stored in ZooKeeper&lt;br/&gt;
+	 * and ignores those which cannot be retrieved via their state handles.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * &amp;lt;p&amp;gt;We have a timeout in case the ZooKeeper store get&apos;s into a deadlock/livelock situation.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test(timeout = 50000)&lt;br/&gt;
+	public void testCheckpointRecovery() throws Exception {&lt;br/&gt;
+		final JobID jobID = new JobID();&lt;br/&gt;
+		final long checkpoint1Id = 1L;&lt;br/&gt;
+		final long checkpoint2Id = 2;&lt;br/&gt;
+		final List&amp;lt;Tuple2&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;, String&amp;gt;&amp;gt; checkpointsInZooKeeper = new ArrayList&amp;lt;&amp;gt;(4);&lt;br/&gt;
+&lt;br/&gt;
+		final Collection&amp;lt;Long&amp;gt; expectedCheckpointIds = new HashSet&amp;lt;&amp;gt;(2);&lt;br/&gt;
+		expectedCheckpointIds.add(1L);&lt;br/&gt;
+		expectedCheckpointIds.add(2L);&lt;br/&gt;
+&lt;br/&gt;
+		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; failingRetrievableStateHandle = mock(RetrievableStateHandle.class);&lt;br/&gt;
+		when(failingRetrievableStateHandle.retrieveState()).thenThrow(new IOException(&quot;Test exception&quot;));&lt;br/&gt;
+&lt;br/&gt;
+		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle1 = mock(RetrievableStateHandle.class);&lt;br/&gt;
+		when(retrievableStateHandle1.retrieveState()).then(&lt;br/&gt;
+			(invocation) -&amp;gt; new CompletedCheckpoint(&lt;br/&gt;
+				jobID,&lt;br/&gt;
+				checkpoint1Id,&lt;br/&gt;
+				1L,&lt;br/&gt;
+				1L,&lt;br/&gt;
+				new HashMap&amp;lt;&amp;gt;(),&lt;br/&gt;
+				null,&lt;br/&gt;
+				CheckpointProperties.forStandardCheckpoint(),&lt;br/&gt;
+				null, null));&lt;br/&gt;
+&lt;br/&gt;
+		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle2 = mock(RetrievableStateHandle.class);&lt;br/&gt;
+		when(retrievableStateHandle2.retrieveState()).then(&lt;br/&gt;
+			(invocation -&amp;gt; new CompletedCheckpoint(&lt;br/&gt;
+				jobID,&lt;br/&gt;
+				checkpoint2Id,&lt;br/&gt;
+				1L,&lt;br/&gt;
+				1L,&lt;br/&gt;
+				new HashMap&amp;lt;&amp;gt;(),&lt;br/&gt;
+				null,&lt;br/&gt;
+				CheckpointProperties.forStandardCheckpoint(),&lt;br/&gt;
+				null, null)));&lt;br/&gt;
+&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle1, &quot;/foobar1&quot;));&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing1&quot;));&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle2, &quot;/foobar2&quot;));&lt;br/&gt;
+		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing2&quot;));&lt;br/&gt;
+&lt;br/&gt;
+		final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zooKeeperStateHandleStoreMock = spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock));&lt;br/&gt;
+		whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zooKeeperStateHandleStoreMock);&lt;br/&gt;
+		doReturn(checkpointsInZooKeeper).when(zooKeeperStateHandleStoreMock).getAllSortedByNameAndLock();&lt;br/&gt;
+&lt;br/&gt;
+		final int numCheckpointsToRetain = 1;&lt;br/&gt;
+&lt;br/&gt;
+		// Mocking for the delete operation on the CuratorFramework client&lt;br/&gt;
+		// It assures that the callback is executed synchronously&lt;br/&gt;
+&lt;br/&gt;
+		final EnsurePath ensurePathMock = mock(EnsurePath.class);&lt;br/&gt;
+		final CuratorEvent curatorEventMock = mock(CuratorEvent.class);&lt;br/&gt;
+		when(curatorEventMock.getType()).thenReturn(CuratorEventType.DELETE);&lt;br/&gt;
+		when(curatorEventMock.getResultCode()).thenReturn(0);&lt;br/&gt;
+		when(client.newNamespaceAwareEnsurePath(anyString())).thenReturn(ensurePathMock);&lt;br/&gt;
+&lt;br/&gt;
+		when(&lt;br/&gt;
+			client&lt;br/&gt;
+				.delete()&lt;br/&gt;
+				.inBackground(any(BackgroundCallback.class), any(Executor.class))&lt;br/&gt;
+		).thenAnswer(new Answer&amp;lt;ErrorListenerPathable&amp;lt;Void&amp;gt;&amp;gt;() {&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public ErrorListenerPathable&amp;lt;Void&amp;gt; answer(InvocationOnMock invocation) throws Throwable {&lt;br/&gt;
+				final BackgroundCallback callback = (BackgroundCallback) invocation.getArguments()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+&lt;br/&gt;
+				ErrorListenerPathable&amp;lt;Void&amp;gt; result = mock(ErrorListenerPathable.class);&lt;br/&gt;
+&lt;br/&gt;
+				when(result.forPath(anyString())).thenAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
+					@Override&lt;br/&gt;
+					public Void answer(InvocationOnMock invocation) throws Throwable {
+
+						callback.processResult(client, curatorEventMock);
+
+						return null;
+					}&lt;br/&gt;
+				});&lt;br/&gt;
+&lt;br/&gt;
+				return result;&lt;br/&gt;
+			}&lt;br/&gt;
+		});&lt;br/&gt;
+&lt;br/&gt;
+		final String checkpointsPath = &quot;foobar&quot;;&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateStorage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
+			numCheckpointsToRetain,&lt;br/&gt;
+			client,&lt;br/&gt;
+			checkpointsPath,&lt;br/&gt;
+			stateStorage,&lt;br/&gt;
+			Executors.directExecutor());&lt;br/&gt;
+&lt;br/&gt;
+		zooKeeperCompletedCheckpointStore.recover();&lt;br/&gt;
+&lt;br/&gt;
+		CompletedCheckpoint latestCompletedCheckpoint = zooKeeperCompletedCheckpointStore.getLatestCheckpoint();&lt;br/&gt;
+&lt;br/&gt;
+		// check that we return the latest retrievable checkpoint&lt;br/&gt;
+		// this should remove the latest checkpoint because it is broken&lt;br/&gt;
+		assertEquals(checkpoint2Id, latestCompletedCheckpoint.getCheckpointID());&lt;br/&gt;
+&lt;br/&gt;
+		// this should remove the second broken checkpoint because we&apos;re iterating over all checkpoints&lt;br/&gt;
+		List&amp;lt;CompletedCheckpoint&amp;gt; completedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();&lt;br/&gt;
+&lt;br/&gt;
+		Collection&amp;lt;Long&amp;gt; actualCheckpointIds = new HashSet&amp;lt;&amp;gt;(completedCheckpoints.size());&lt;br/&gt;
+&lt;br/&gt;
+		for (CompletedCheckpoint completedCheckpoint : completedCheckpoints) {
+			actualCheckpointIds.add(completedCheckpoint.getCheckpointID());
+		}&lt;br/&gt;
+&lt;br/&gt;
+		assertEquals(expectedCheckpointIds, actualCheckpointIds);&lt;br/&gt;
+&lt;br/&gt;
+		// check that we did not discard any of the state handles&lt;br/&gt;
+		verify(retrievableStateHandle1, never()).discardState();&lt;br/&gt;
+		verify(retrievableStateHandle2, never()).discardState();&lt;br/&gt;
+&lt;br/&gt;
+		// Make sure that we also didn&apos;t discard any of the broken handles. Only when checkpoints&lt;br/&gt;
+		// are subsumed should they be discarded.&lt;br/&gt;
+		verify(failingRetrievableStateHandle, never()).discardState();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the checkpoint does not exist in the store when we fail to add&lt;br/&gt;
+	 * it into the store (i.e., there exists an exception thrown by the method).&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testAddCheckpointWithFailedRemove() throws Exception {&lt;br/&gt;
+		final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zookeeperStateHandleStoreMock =&lt;br/&gt;
+			spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock));&lt;br/&gt;
+		whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zookeeperStateHandleStoreMock);&lt;br/&gt;
+&lt;br/&gt;
+		doAnswer(new Answer&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;&amp;gt;() {&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; answer(InvocationOnMock invocationOnMock) throws Throwable {
+				CompletedCheckpoint checkpoint = (CompletedCheckpoint) invocationOnMock.getArguments()[1];
+
+				RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle = mock(RetrievableStateHandle.class);
+				when(retrievableStateHandle.retrieveState()).thenReturn(checkpoint);
+
+				return retrievableStateHandle;
+			}&lt;br/&gt;
+		}).when(zookeeperStateHandleStoreMock).addAndLock(anyString(), any(CompletedCheckpoint.class));&lt;br/&gt;
+&lt;br/&gt;
+		doThrow(new Exception()).when(zookeeperStateHandleStoreMock).releaseAndTryRemove(anyString());&lt;br/&gt;
+&lt;br/&gt;
+		final int numCheckpointsToRetain = 1;&lt;br/&gt;
+		final String checkpointsPath = &quot;foobar&quot;;&lt;br/&gt;
+		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateSotrage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+&lt;br/&gt;
+		ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;br/&gt;
+			numCheckpointsToRetain,&lt;br/&gt;
+			client,&lt;br/&gt;
+			checkpointsPath,&lt;br/&gt;
+			stateSotrage,&lt;br/&gt;
+			Executors.directExecutor());&lt;br/&gt;
+&lt;br/&gt;
+		for (long i = 0; i &amp;lt;= numCheckpointsToRetain; ++i) {&lt;br/&gt;
+			CompletedCheckpoint checkpointToAdd = mock(CompletedCheckpoint.class);&lt;br/&gt;
+			doReturn&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.when(checkpointToAdd).getCheckpointID();&lt;br/&gt;
+			doReturn(Collections.emptyMap()).when(checkpointToAdd).getOperatorStates();&lt;br/&gt;
+&lt;br/&gt;
+			try {
+				zooKeeperCompletedCheckpointStore.addCheckpoint(checkpointToAdd);
+
+				// The checkpoint should be in the store if we successfully add it into the store.
+				List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();
+				assertTrue(addedCheckpoints.contains(checkpointToAdd));
+			} catch (Exception e) {
+				// The checkpoint should not be in the store if any exception is thrown.
+				List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();
+				assertFalse(addedCheckpoints.contains(checkpointToAdd));
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java&lt;br/&gt;
index 7156cb5e119..99f21c64213 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java&lt;br/&gt;
@@ -18,59 +18,39 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.flink.runtime.checkpoint;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.flink.api.common.JobID;&lt;br/&gt;
-import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.configuration.Configuration;&lt;br/&gt;
+import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobStatus;&lt;br/&gt;
 import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
+import org.apache.flink.runtime.state.SharedStateRegistry;&lt;br/&gt;
+import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;&lt;br/&gt;
-import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
 &lt;br/&gt;
 import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
-import org.apache.curator.framework.api.BackgroundCallback;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEvent;&lt;br/&gt;
-import org.apache.curator.framework.api.CuratorEventType;&lt;br/&gt;
-import org.apache.curator.framework.api.ErrorListenerPathable;&lt;br/&gt;
-import org.apache.curator.utils.EnsurePath;&lt;br/&gt;
+import org.hamcrest.Matchers;&lt;br/&gt;
+import org.junit.ClassRule;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
-import org.junit.runner.RunWith;&lt;br/&gt;
-import org.mockito.Mockito;&lt;br/&gt;
-import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
-import org.mockito.stubbing.Answer;&lt;br/&gt;
-import org.powermock.core.classloader.annotations.PrepareForTest;&lt;br/&gt;
-import org.powermock.modules.junit4.PowerMockRunner;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
 &lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
-import java.util.ArrayList;&lt;br/&gt;
-import java.util.Collection;&lt;br/&gt;
-import java.util.Collections;&lt;br/&gt;
-import java.util.HashMap;&lt;br/&gt;
-import java.util.HashSet;&lt;br/&gt;
+import java.io.Serializable;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
-import java.util.concurrent.Executor;&lt;br/&gt;
 &lt;br/&gt;
 import static org.junit.Assert.assertEquals;&lt;br/&gt;
-import static org.junit.Assert.assertFalse;&lt;br/&gt;
-import static org.junit.Assert.assertTrue;&lt;br/&gt;
-import static org.mockito.Matchers.any;&lt;br/&gt;
-import static org.mockito.Matchers.anyString;&lt;br/&gt;
-import static org.mockito.Mockito.doReturn;&lt;br/&gt;
-import static org.mockito.Mockito.mock;&lt;br/&gt;
-import static org.mockito.Mockito.never;&lt;br/&gt;
-import static org.mockito.Mockito.spy;&lt;br/&gt;
-import static org.mockito.Mockito.verify;&lt;br/&gt;
-import static org.mockito.Mockito.when;&lt;br/&gt;
-import static org.powermock.api.mockito.PowerMockito.doAnswer;&lt;br/&gt;
-import static org.powermock.api.mockito.PowerMockito.doThrow;&lt;br/&gt;
-import static org.powermock.api.mockito.PowerMockito.whenNew;&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * Tests for {@link ZooKeeperCompletedCheckpointStore}
&lt;p&gt;.&lt;br/&gt;
  */&lt;br/&gt;
-@RunWith(PowerMockRunner.class)&lt;br/&gt;
-@PrepareForTest(ZooKeeperCompletedCheckpointStore.class)&lt;br/&gt;
 public class ZooKeeperCompletedCheckpointStoreTest extends TestLogger {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	@ClassRule&lt;br/&gt;
+	public static ZooKeeperResource zooKeeperResource = new ZooKeeperResource();&lt;br/&gt;
+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testPathConversion() {&lt;br/&gt;
 		final long checkpointId = 42L;&lt;br/&gt;
@@ -80,189 +60,101 @@ public void testPathConversion() &lt;/p&gt;
{
 		assertEquals(checkpointId, ZooKeeperCompletedCheckpointStore.pathToCheckpointId(path));
 	}

&lt;p&gt;+	@Test&lt;br/&gt;
+	public void testDiscardingSubsumedCheckpoints() throws Exception {&lt;br/&gt;
+		final SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString());&lt;br/&gt;
+&lt;br/&gt;
+		final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+		final ZooKeeperCompletedCheckpointStore checkpointStore = createZooKeeperCheckpointStore(client);&lt;br/&gt;
+&lt;br/&gt;
+		try &lt;/p&gt;
{
+			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint1 = CompletedCheckpointStoreTest.createCheckpoint(0, sharedStateRegistry);
+
+			checkpointStore.addCheckpoint(checkpoint1);
+			assertThat(checkpointStore.getAllCheckpoints(), Matchers.contains(checkpoint1));
+
+			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint2 = CompletedCheckpointStoreTest.createCheckpoint(1, sharedStateRegistry);
+			checkpointStore.addCheckpoint(checkpoint2);
+			final List&amp;lt;CompletedCheckpoint&amp;gt; allCheckpoints = checkpointStore.getAllCheckpoints();
+			assertThat(allCheckpoints, Matchers.contains(checkpoint2));
+			assertThat(allCheckpoints, Matchers.not(Matchers.contains(checkpoint1)));
+
+			// verify that the subsumed checkpoint is discarded
+			CompletedCheckpointStoreTest.verifyCheckpointDiscarded(checkpoint1);
+		}
&lt;p&gt; finally &lt;/p&gt;
{
+			client.close();
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	/**&lt;br/&gt;
-	 * Tests that the completed checkpoint store can retrieve all checkpoints stored in ZooKeeper&lt;br/&gt;
-	 * and ignores those which cannot be retrieved via their state handles.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;We have a timeout in case the ZooKeeper store get&apos;s into a deadlock/livelock situation.&lt;br/&gt;
+	 * Tests that checkpoints are discarded when the completed checkpoint store is shut&lt;br/&gt;
+	 * down with a globally terminal state.&lt;br/&gt;
 	 */&lt;br/&gt;
-	@Test(timeout = 50000)&lt;br/&gt;
-	public void testCheckpointRecovery() throws Exception {&lt;br/&gt;
-		final JobID jobID = new JobID();&lt;br/&gt;
-		final long checkpoint1Id = 1L;&lt;br/&gt;
-		final long checkpoint2Id = 2;&lt;br/&gt;
-		final List&amp;lt;Tuple2&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;, String&amp;gt;&amp;gt; checkpointsInZooKeeper = new ArrayList&amp;lt;&amp;gt;(4);&lt;br/&gt;
-&lt;br/&gt;
-		final Collection&amp;lt;Long&amp;gt; expectedCheckpointIds = new HashSet&amp;lt;&amp;gt;(2);&lt;br/&gt;
-		expectedCheckpointIds.add(1L);&lt;br/&gt;
-		expectedCheckpointIds.add(2L);&lt;br/&gt;
-&lt;br/&gt;
-		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; failingRetrievableStateHandle = mock(RetrievableStateHandle.class);&lt;br/&gt;
-		when(failingRetrievableStateHandle.retrieveState()).thenThrow(new IOException(&quot;Test exception&quot;));&lt;br/&gt;
-&lt;br/&gt;
-		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle1 = mock(RetrievableStateHandle.class);&lt;br/&gt;
-		when(retrievableStateHandle1.retrieveState()).then(&lt;br/&gt;
-			(invocation) -&amp;gt; new CompletedCheckpoint(&lt;br/&gt;
-				jobID,&lt;br/&gt;
-				checkpoint1Id,&lt;br/&gt;
-				1L,&lt;br/&gt;
-				1L,&lt;br/&gt;
-				new HashMap&amp;lt;&amp;gt;(),&lt;br/&gt;
-				null,&lt;br/&gt;
-				CheckpointProperties.forStandardCheckpoint(),&lt;br/&gt;
-				null, null));&lt;br/&gt;
-&lt;br/&gt;
-		final RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle2 = mock(RetrievableStateHandle.class);&lt;br/&gt;
-		when(retrievableStateHandle2.retrieveState()).then(&lt;br/&gt;
-			(invocation -&amp;gt; new CompletedCheckpoint(&lt;br/&gt;
-				jobID,&lt;br/&gt;
-				checkpoint2Id,&lt;br/&gt;
-				1L,&lt;br/&gt;
-				1L,&lt;br/&gt;
-				new HashMap&amp;lt;&amp;gt;(),&lt;br/&gt;
-				null,&lt;br/&gt;
-				CheckpointProperties.forStandardCheckpoint(),&lt;br/&gt;
-				null, null)));&lt;br/&gt;
-&lt;br/&gt;
-		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle1, &quot;/foobar1&quot;));&lt;br/&gt;
-		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing1&quot;));&lt;br/&gt;
-		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle2, &quot;/foobar2&quot;));&lt;br/&gt;
-		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, &quot;/failing2&quot;));&lt;br/&gt;
-&lt;br/&gt;
-		final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;br/&gt;
-		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
-&lt;br/&gt;
-		ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zooKeeperStateHandleStoreMock = spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock, Executors.directExecutor()));&lt;br/&gt;
-		whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zooKeeperStateHandleStoreMock);&lt;br/&gt;
-		doReturn(checkpointsInZooKeeper).when(zooKeeperStateHandleStoreMock).getAllSortedByNameAndLock();&lt;br/&gt;
-&lt;br/&gt;
-		final int numCheckpointsToRetain = 1;&lt;br/&gt;
-&lt;br/&gt;
-		// Mocking for the delete operation on the CuratorFramework client&lt;br/&gt;
-		// It assures that the callback is executed synchronously&lt;br/&gt;
-&lt;br/&gt;
-		final EnsurePath ensurePathMock = mock(EnsurePath.class);&lt;br/&gt;
-		final CuratorEvent curatorEventMock = mock(CuratorEvent.class);&lt;br/&gt;
-		when(curatorEventMock.getType()).thenReturn(CuratorEventType.DELETE);&lt;br/&gt;
-		when(curatorEventMock.getResultCode()).thenReturn(0);&lt;br/&gt;
-		when(client.newNamespaceAwareEnsurePath(anyString())).thenReturn(ensurePathMock);&lt;br/&gt;
-&lt;br/&gt;
-		when(&lt;br/&gt;
-			client&lt;br/&gt;
-				.delete()&lt;br/&gt;
-				.inBackground(any(BackgroundCallback.class), any(Executor.class))&lt;br/&gt;
-		).thenAnswer(new Answer&amp;lt;ErrorListenerPathable&amp;lt;Void&amp;gt;&amp;gt;() {&lt;br/&gt;
-			@Override&lt;br/&gt;
-			public ErrorListenerPathable&amp;lt;Void&amp;gt; answer(InvocationOnMock invocation) throws Throwable {&lt;br/&gt;
-				final BackgroundCallback callback = (BackgroundCallback) invocation.getArguments()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testDiscardingCheckpointsAtShutDown() throws Exception {&lt;br/&gt;
+		final SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString());&lt;br/&gt;
 &lt;br/&gt;
-				ErrorListenerPathable&amp;lt;Void&amp;gt; result = mock(ErrorListenerPathable.class);&lt;br/&gt;
+		final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+		final ZooKeeperCompletedCheckpointStore checkpointStore = createZooKeeperCheckpointStore(client);&lt;br/&gt;
 &lt;br/&gt;
-				when(result.forPath(anyString())).thenAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
-					@Override&lt;br/&gt;
-					public Void answer(InvocationOnMock invocation) throws Throwable {&lt;br/&gt;
+		try {
+			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint1 = CompletedCheckpointStoreTest.createCheckpoint(0, sharedStateRegistry);
 
-						callback.processResult(client, curatorEventMock);
+			checkpointStore.addCheckpoint(checkpoint1);
+			assertThat(checkpointStore.getAllCheckpoints(), Matchers.contains(checkpoint1));
 
-						return null;
-					}&lt;br/&gt;
-				});&lt;br/&gt;
+			checkpointStore.shutdown(JobStatus.FINISHED);&lt;br/&gt;
 &lt;br/&gt;
-				return result;&lt;br/&gt;
-			}&lt;br/&gt;
-		});&lt;br/&gt;
-&lt;br/&gt;
-		final String checkpointsPath = &quot;foobar&quot;;&lt;br/&gt;
-		final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateStorage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+			// verify that the checkpoint is discarded&lt;br/&gt;
+			CompletedCheckpointStoreTest.verifyCheckpointDiscarded(checkpoint1);&lt;br/&gt;
+		} finally {+			client.close();+		}
&lt;p&gt;+	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;/li&gt;
	&lt;li&gt;numCheckpointsToRetain,&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private ZooKeeperCompletedCheckpointStore createZooKeeperCheckpointStore(CuratorFramework client) throws Exception 
{
+		return new ZooKeeperCompletedCheckpointStore(
+			1,
 			client,
-			checkpointsPath,
-			stateStorage,
+			&quot;/checkpoints&quot;,
+			new TestingRetrievableStateStorageHelper&amp;lt;&amp;gt;(),
 			Executors.directExecutor());
+	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;zooKeeperCompletedCheckpointStore.recover();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;CompletedCheckpoint latestCompletedCheckpoint = zooKeeperCompletedCheckpointStore.getLatestCheckpoint();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// check that we return the latest retrievable checkpoint&lt;/li&gt;
	&lt;li&gt;// this should remove the latest checkpoint because it is broken&lt;/li&gt;
	&lt;li&gt;assertEquals(checkpoint2Id, latestCompletedCheckpoint.getCheckpointID());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// this should remove the second broken checkpoint because we&apos;re iterating over all checkpoints&lt;/li&gt;
	&lt;li&gt;List&amp;lt;CompletedCheckpoint&amp;gt; completedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;Collection&amp;lt;Long&amp;gt; actualCheckpointIds = new HashSet&amp;lt;&amp;gt;(completedCheckpoints.size());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;for (CompletedCheckpoint completedCheckpoint : completedCheckpoints) {&lt;/li&gt;
	&lt;li&gt;actualCheckpointIds.add(completedCheckpoint.getCheckpointID());&lt;br/&gt;
+	private static final class TestingRetrievableStateStorageHelper&amp;lt;T extends Serializable&amp;gt; implements RetrievableStateStorageHelper&amp;lt;T&amp;gt; {&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public RetrievableStateHandle&amp;lt;T&amp;gt; store(T state) 
{
+			return new TestingRetrievableStateHandle&amp;lt;&amp;gt;(state);
 		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertEquals(expectedCheckpointIds, actualCheckpointIds);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// check that we did not discard any of the state handles&lt;/li&gt;
	&lt;li&gt;verify(retrievableStateHandle1, never()).discardState();&lt;/li&gt;
	&lt;li&gt;verify(retrievableStateHandle2, never()).discardState();&lt;br/&gt;
+		private static class TestingRetrievableStateHandle&amp;lt;T extends Serializable&amp;gt; implements RetrievableStateHandle&amp;lt;T&amp;gt; 
{
 
-		// Make sure that we also didn&apos;t discard any of the broken handles. Only when checkpoints
-		// are subsumed should they be discarded.
-		verify(failingRetrievableStateHandle, never()).discardState();
-	}
&lt;p&gt;+			private static final long serialVersionUID = 137053380713794300L;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Tests that the checkpoint does not exist in the store when we fail to add&lt;/li&gt;
	&lt;li&gt;* it into the store (i.e., there exists an exception thrown by the method).&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testAddCheckpointWithFailedRemove() throws Exception {&lt;/li&gt;
	&lt;li&gt;final CuratorFramework client = mock(CuratorFramework.class, Mockito.RETURNS_DEEP_STUBS);&lt;/li&gt;
	&lt;li&gt;final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; storageHelperMock = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
+			private final T state;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;CompletedCheckpoint&amp;gt; zookeeperStateHandleStoreMock =&lt;/li&gt;
	&lt;li&gt;spy(new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(client, storageHelperMock, Executors.directExecutor()));&lt;/li&gt;
	&lt;li&gt;whenNew(ZooKeeperStateHandleStore.class).withAnyArguments().thenReturn(zookeeperStateHandleStoreMock);&lt;br/&gt;
+			private TestingRetrievableStateHandle(T state) 
{
+				this.state = state;
+			}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;doAnswer(new Answer&amp;lt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt;&amp;gt;() {&lt;br/&gt;
 			@Override&lt;/li&gt;
	&lt;li&gt;public RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; answer(InvocationOnMock invocationOnMock) throws Throwable {&lt;/li&gt;
	&lt;li&gt;CompletedCheckpoint checkpoint = (CompletedCheckpoint) invocationOnMock.getArguments()&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;RetrievableStateHandle&amp;lt;CompletedCheckpoint&amp;gt; retrievableStateHandle = mock(RetrievableStateHandle.class);&lt;/li&gt;
	&lt;li&gt;when(retrievableStateHandle.retrieveState()).thenReturn(checkpoint);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;return retrievableStateHandle;&lt;br/&gt;
+			public T retrieveState() throws IOException, ClassNotFoundException 
{
+				return state;
 			}&lt;/li&gt;
	&lt;li&gt;}).when(zookeeperStateHandleStoreMock).addAndLock(anyString(), any(CompletedCheckpoint.class));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;doThrow(new Exception()).when(zookeeperStateHandleStoreMock).releaseAndTryRemove(anyString(), any(ZooKeeperStateHandleStore.RemoveCallback.class));&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final int numCheckpointsToRetain = 1;&lt;/li&gt;
	&lt;li&gt;final String checkpointsPath = &quot;foobar&quot;;&lt;/li&gt;
	&lt;li&gt;final RetrievableStateStorageHelper&amp;lt;CompletedCheckpoint&amp;gt; stateSotrage = mock(RetrievableStateStorageHelper.class);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(&lt;/li&gt;
	&lt;li&gt;numCheckpointsToRetain,&lt;/li&gt;
	&lt;li&gt;client,&lt;/li&gt;
	&lt;li&gt;checkpointsPath,&lt;/li&gt;
	&lt;li&gt;stateSotrage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public void discardState() throws Exception 
{
+				// no op
+			}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for (long i = 0; i &amp;lt;= numCheckpointsToRetain; ++i) {&lt;/li&gt;
	&lt;li&gt;CompletedCheckpoint checkpointToAdd = mock(CompletedCheckpoint.class);&lt;/li&gt;
	&lt;li&gt;doReturn&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.when(checkpointToAdd).getCheckpointID();&lt;/li&gt;
	&lt;li&gt;doReturn(Collections.emptyMap()).when(checkpointToAdd).getOperatorStates();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;try 
{
-				zooKeeperCompletedCheckpointStore.addCheckpoint(checkpointToAdd);
-
-				// The checkpoint should be in the store if we successfully add it into the store.
-				List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();
-				assertTrue(addedCheckpoints.contains(checkpointToAdd));
-			}
&lt;p&gt; catch (Exception e) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// The checkpoint should not be in the store if any exception is thrown.&lt;/li&gt;
	&lt;li&gt;List&amp;lt;CompletedCheckpoint&amp;gt; addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();&lt;/li&gt;
	&lt;li&gt;assertFalse(addedCheckpoints.contains(checkpointToAdd));&lt;br/&gt;
+			@Override&lt;br/&gt;
+			public long getStateSize() 
{
+				return 0;
 			}
&lt;p&gt; 		}&lt;br/&gt;
 	}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerHARecoveryTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerHARecoveryTest.java&lt;br/&gt;
index 88141d6ca71..ea5e01f385d 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerHARecoveryTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerHARecoveryTest.java&lt;br/&gt;
@@ -514,6 +514,11 @@ public void removeJobGraph(JobID jobId) throws Exception 
{
 			storedJobs.remove(jobId);
 		}&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+		@Override&lt;br/&gt;
+		public void releaseJobGraph(JobID jobId) throws Exception &lt;/p&gt;
{
+			// no op
+		}&lt;br/&gt;
+&lt;br/&gt;
 		@Override&lt;br/&gt;
 		public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
 			return storedJobs.keySet();&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..eb58557c0f8&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperHAJobManagerTest.java&lt;br/&gt;
@@ -0,0 +1,203 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.jobmanager;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.configuration.Configuration;&lt;br/&gt;
+import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
+import org.apache.flink.runtime.akka.AkkaUtils;&lt;br/&gt;
+import org.apache.flink.runtime.akka.ListeningBehaviour;&lt;br/&gt;
+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.HighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.instance.ActorGateway;&lt;br/&gt;
+import org.apache.flink.runtime.instance.AkkaActorGateway;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobVertex;&lt;br/&gt;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;&lt;br/&gt;
+import org.apache.flink.runtime.messages.JobManagerMessages;&lt;br/&gt;
+import org.apache.flink.runtime.metrics.MetricRegistryConfiguration;&lt;br/&gt;
+import org.apache.flink.runtime.metrics.MetricRegistryImpl;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingJobManager;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingJobManagerMessages;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingUtils;&lt;br/&gt;
+import org.apache.flink.runtime.testtasks.NoOpInvokable;&lt;br/&gt;
+import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
+import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import akka.actor.ActorRef;&lt;br/&gt;
+import akka.actor.ActorSystem;&lt;br/&gt;
+import akka.actor.ExtendedActorSystem;&lt;br/&gt;
+import akka.actor.Identify;&lt;br/&gt;
+import akka.actor.PoisonPill;&lt;br/&gt;
+import akka.actor.Terminated;&lt;br/&gt;
+import akka.pattern.Patterns;&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
+import org.junit.AfterClass;&lt;br/&gt;
+import org.junit.BeforeClass;&lt;br/&gt;
+import org.junit.ClassRule;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.rules.TemporaryFolder;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+&lt;br/&gt;
+import scala.Option;&lt;br/&gt;
+import scala.concurrent.Await;&lt;br/&gt;
+import scala.concurrent.Future;&lt;br/&gt;
+import scala.concurrent.duration.FiniteDuration;&lt;br/&gt;
+&lt;br/&gt;
+import static org.hamcrest.Matchers.contains;&lt;br/&gt;
+import static org.hamcrest.Matchers.is;&lt;br/&gt;
+import static org.hamcrest.Matchers.not;&lt;br/&gt;
+import static org.hamcrest.Matchers.notNullValue;&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tests for the ZooKeeper HA service and {@link JobManager} interaction.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ZooKeeperHAJobManagerTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final ZooKeeperResource ZOO_KEEPER_RESOURCE = new ZooKeeperResource();&lt;br/&gt;
+&lt;br/&gt;
+	@ClassRule&lt;br/&gt;
+	public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();&lt;br/&gt;
+&lt;br/&gt;
+	private static final FiniteDuration TIMEOUT = FiniteDuration.apply(10L, TimeUnit.SECONDS);&lt;br/&gt;
+&lt;br/&gt;
+	private static ActorSystem system;&lt;br/&gt;
+&lt;br/&gt;
+	@BeforeClass&lt;br/&gt;
+	public static void setup() {
+		system = AkkaUtils.createLocalActorSystem(new Configuration());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@AfterClass&lt;br/&gt;
+	public static void teardown() throws Exception {
+		final Future&amp;lt;Terminated&amp;gt; terminationFuture = system.terminate();
+		Await.ready(terminationFuture, TIMEOUT);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the {@link JobManager} releases all locked {@link JobGraph} if it loses&lt;br/&gt;
+	 * leadership.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testJobGraphReleaseWhenLosingLeadership() throws Exception {&lt;br/&gt;
+		final Configuration configuration = new Configuration();&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, ZOO_KEEPER_RESOURCE.getConnectString());&lt;br/&gt;
+		configuration.setString(HighAvailabilityOptions.HA_STORAGE_PATH, TEMPORARY_FOLDER.newFolder().getAbsolutePath());&lt;br/&gt;
+&lt;br/&gt;
+		final TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices();&lt;br/&gt;
+&lt;br/&gt;
+		final CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+		final TestingLeaderElectionService leaderElectionService = new TestingLeaderElectionService();&lt;br/&gt;
+		highAvailabilityServices.setJobMasterLeaderElectionService(HighAvailabilityServices.DEFAULT_JOB_ID, leaderElectionService);&lt;br/&gt;
+		highAvailabilityServices.setSubmittedJobGraphStore(ZooKeeperUtils.createSubmittedJobGraphs(client, configuration));&lt;br/&gt;
+		highAvailabilityServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());&lt;br/&gt;
+&lt;br/&gt;
+		final CuratorFramework otherClient = ZooKeeperUtils.startCuratorFramework(configuration);&lt;br/&gt;
+		final ZooKeeperSubmittedJobGraphStore otherSubmittedJobGraphStore = ZooKeeperUtils.createSubmittedJobGraphs(otherClient, configuration);&lt;br/&gt;
+		otherSubmittedJobGraphStore.start(NoOpSubmittedJobGraphListener.INSTANCE);&lt;br/&gt;
+&lt;br/&gt;
+		ActorRef jobManagerActorRef = null;&lt;br/&gt;
+		try {
+			jobManagerActorRef = JobManager.startJobManagerActors(
+				configuration,
+				system,
+				TestingUtils.defaultExecutor(),
+				TestingUtils.defaultExecutor(),
+				highAvailabilityServices,
+				new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(configuration)),
+				Option.empty(),
+				TestingJobManager.class,
+				MemoryArchivist.class)._1();
+
+			waitForActorToBeStarted(jobManagerActorRef, TIMEOUT);
+
+			final ActorGateway jobManager = new AkkaActorGateway(jobManagerActorRef, HighAvailabilityServices.DEFAULT_LEADER_ID);
+
+			leaderElectionService.isLeader(HighAvailabilityServices.DEFAULT_LEADER_ID).get();
+
+			final JobGraph nonEmptyJobGraph = createNonEmptyJobGraph();
+
+			final JobManagerMessages.SubmitJob submitJobMessage = new JobManagerMessages.SubmitJob(nonEmptyJobGraph, ListeningBehaviour.DETACHED);
+
+			Await.result(jobManager.ask(submitJobMessage, TIMEOUT), TIMEOUT);
+
+			Collection&amp;lt;JobID&amp;gt; jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+			final JobID jobId = nonEmptyJobGraph.getJobID();
+			assertThat(jobIds, contains(jobId));
+
+			// revoke the leadership
+			leaderElectionService.notLeader();
+
+			Await.result(jobManager.ask(TestingJobManagerMessages.getWaitForBackgroundTasksToFinish(), TIMEOUT), TIMEOUT);
+
+			final SubmittedJobGraph recoveredJobGraph = akka.serialization.JavaSerializer.currentSystem().withValue(
+				((ExtendedActorSystem) system),
+				() -&amp;gt; otherSubmittedJobGraphStore.recoverJobGraph(jobId));
+
+			assertThat(recoveredJobGraph, is(notNullValue()));
+
+			otherSubmittedJobGraphStore.removeJobGraph(jobId);
+
+			jobIds = otherSubmittedJobGraphStore.getJobIds();
+
+			assertThat(jobIds, not(contains(jobId)));
+		} finally {&lt;br/&gt;
+			client.close();&lt;br/&gt;
+			otherClient.close();&lt;br/&gt;
+&lt;br/&gt;
+			if (jobManagerActorRef != null) {
+				jobManagerActorRef.tell(PoisonPill.getInstance(), ActorRef.noSender());
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private JobGraph createNonEmptyJobGraph() {
+		final JobVertex noOpVertex = new JobVertex(&quot;NoOp vertex&quot;);
+		noOpVertex.setInvokableClass(NoOpInvokable.class);
+		final JobGraph jobGraph = new JobGraph(noOpVertex);
+		jobGraph.setAllowQueuedScheduling(true);
+
+		return jobGraph;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private void waitForActorToBeStarted(ActorRef jobManagerActorRef, FiniteDuration timeout) throws InterruptedException, java.util.concurrent.TimeoutException {
+		Await.ready(Patterns.ask(jobManagerActorRef, new Identify(42), timeout.toMillis()), timeout);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	enum NoOpSubmittedJobGraphListener implements SubmittedJobGraphStore.SubmittedJobGraphListener {&lt;br/&gt;
+		INSTANCE;&lt;br/&gt;
+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public void onAddedJobGraph(JobID jobId) {+			// no op+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public void onRemovedJobGraph(JobID jobId) &lt;/p&gt;
{
+			// no op
+		}
&lt;p&gt;+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java&lt;br/&gt;
index 9454d90e05c..d89894aff27 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/ZooKeeperSubmittedJobGraphsStoreITCase.java&lt;br/&gt;
@@ -21,7 +21,6 @@&lt;br/&gt;
 import akka.actor.ActorRef;&lt;br/&gt;
 import org.apache.flink.api.common.JobID;&lt;br/&gt;
 import org.apache.flink.runtime.akka.ListeningBehaviour;&lt;br/&gt;
-import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobVertex;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore.SubmittedJobGraphListener;&lt;br/&gt;
@@ -90,8 +89,7 @@ public void testPutAndRemoveJobGraph() throws Exception {&lt;br/&gt;
 		ZooKeeperSubmittedJobGraphStore jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;br/&gt;
 			ZooKeeper.createClient(),&lt;br/&gt;
 			&quot;/testPutAndRemoveJobGraph&quot;,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;localStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		try {&lt;br/&gt;
 			SubmittedJobGraphListener listener = mock(SubmittedJobGraphListener.class);&lt;br/&gt;
@@ -147,7 +145,7 @@ public void testPutAndRemoveJobGraph() throws Exception {&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testRecoverJobGraphs() throws Exception {&lt;br/&gt;
 		ZooKeeperSubmittedJobGraphStore jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testRecoverJobGraphs&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+				ZooKeeper.createClient(), &quot;/testRecoverJobGraphs&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		try {&lt;br/&gt;
 			SubmittedJobGraphListener listener = mock(SubmittedJobGraphListener.class);&lt;br/&gt;
@@ -198,10 +196,10 @@ public void testConcurrentAddJobGraph() throws Exception {&lt;/p&gt;

&lt;p&gt; 		try {&lt;br/&gt;
 			jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+					ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			otherJobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+					ZooKeeper.createClient(), &quot;/testConcurrentAddJobGraph&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt; 			SubmittedJobGraph jobGraph = createSubmittedJobGraph(new JobID(), 0);&lt;br/&gt;
@@ -257,10 +255,10 @@ public Void answer(InvocationOnMock invocation) throws Throwable {&lt;br/&gt;
 	@Test(expected = IllegalStateException.class)&lt;br/&gt;
 	public void testUpdateJobGraphYouDidNotGetOrAdd() throws Exception {&lt;br/&gt;
 		ZooKeeperSubmittedJobGraphStore jobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+				ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperSubmittedJobGraphStore otherJobGraphs = new ZooKeeperSubmittedJobGraphStore(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage, Executors.directExecutor());&lt;br/&gt;
+				ZooKeeper.createClient(), &quot;/testUpdateJobGraphYouDidNotGetOrAdd&quot;, localStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		jobGraphs.start(null);&lt;br/&gt;
 		otherJobGraphs.start(null);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperResource.java b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperResource.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..c4c56949cd9&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperResource.java&lt;br/&gt;
@@ -0,0 +1,72 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.zookeeper;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.test.TestingServer;&lt;br/&gt;
+import org.junit.rules.ExternalResource;&lt;br/&gt;
+import org.slf4j.Logger;&lt;br/&gt;
+import org.slf4j.LoggerFactory;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * &lt;/p&gt;
{@link ExternalResource}
&lt;p&gt; which starts a &lt;/p&gt;
{@link org.apache.zookeeper.server.ZooKeeperServer}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ZooKeeperResource extends ExternalResource {&lt;br/&gt;
+&lt;br/&gt;
+	private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperResource.class);&lt;br/&gt;
+&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	private TestingServer zooKeeperServer;&lt;br/&gt;
+&lt;br/&gt;
+	public String getConnectString() &lt;/p&gt;
{
+		verifyIsRunning();
+		return zooKeeperServer.getConnectString();
+	}
&lt;p&gt;+&lt;br/&gt;
+	private void verifyIsRunning() &lt;/p&gt;
{
+		Preconditions.checkState(zooKeeperServer != null);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	protected void before() throws Throwable &lt;/p&gt;
{
+		terminateZooKeeperServer();
+		zooKeeperServer = new TestingServer(true);
+	}
&lt;p&gt;+&lt;br/&gt;
+	private void terminateZooKeeperServer() throws IOException {&lt;br/&gt;
+		if (zooKeeperServer != null) &lt;/p&gt;
{
+			zooKeeperServer.stop();
+			zooKeeperServer = null;
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	protected void after() {&lt;br/&gt;
+		try &lt;/p&gt;
{
+			terminateZooKeeperServer();
+		}
&lt;p&gt; catch (IOException e) {&lt;br/&gt;
+			LOG.warn(&quot;Could not properly terminate the {}.&quot;, getClass().getSimpleName(), e);&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java&lt;br/&gt;
index fd39b25991c..2dd27e7c897 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java&lt;br/&gt;
@@ -18,21 +18,19 @@&lt;/p&gt;

&lt;p&gt; package org.apache.flink.runtime.zookeeper;&lt;/p&gt;

&lt;p&gt;-import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
 import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
 import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
-import org.apache.flink.runtime.concurrent.Executors;&lt;br/&gt;
 import org.apache.flink.runtime.state.RetrievableStateHandle;&lt;br/&gt;
 import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
 import org.apache.flink.util.InstantiationUtil;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
 import org.apache.zookeeper.data.Stat;&lt;br/&gt;
 import org.junit.AfterClass;&lt;br/&gt;
 import org.junit.Before;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
-import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
-import org.mockito.stubbing.Answer;&lt;/p&gt;

&lt;p&gt; import java.io.IOException;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
@@ -41,7 +39,6 @@&lt;br/&gt;
 import java.util.HashSet;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Set;&lt;br/&gt;
-import java.util.concurrent.CountDownLatch;&lt;/p&gt;

&lt;p&gt; import static org.junit.Assert.assertEquals;&lt;br/&gt;
 import static org.junit.Assert.assertNotEquals;&lt;br/&gt;
@@ -49,12 +46,7 @@&lt;br/&gt;
 import static org.junit.Assert.assertNull;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;br/&gt;
 import static org.junit.Assert.fail;&lt;br/&gt;
-import static org.mockito.Matchers.any;&lt;br/&gt;
-import static org.mockito.Mockito.doAnswer;&lt;br/&gt;
-import static org.mockito.Mockito.mock;&lt;br/&gt;
 import static org.mockito.Mockito.spy;&lt;br/&gt;
-import static org.mockito.Mockito.times;&lt;br/&gt;
-import static org.mockito.Mockito.verify;&lt;br/&gt;
 import static org.mockito.Mockito.when;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -88,8 +80,8 @@ public void cleanUp() throws Exception {&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testAddAndLock() throws Exception {&lt;br/&gt;
 		LongStateStorage longStateStorage = new LongStateStorage();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;Long&amp;gt;(&lt;/li&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), longStateStorage, Executors.directExecutor());&lt;br/&gt;
+		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
+			ZOOKEEPER.getClient(), longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testAdd&quot;;&lt;br/&gt;
@@ -136,7 +128,7 @@ public void testAddAlreadyExistingPath() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZOOKEEPER.getClient().create().forPath(&quot;/testAddAlreadyExistingPath&quot;);&lt;/p&gt;

&lt;p&gt;@@ -161,7 +153,7 @@ public void testAddDiscardStateHandleAfterFailure() throws Exception {&lt;br/&gt;
 		when(client.inTransaction().create()).thenThrow(new RuntimeException(&quot;Expected test Exception.&quot;));&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client, stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				client, stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testAddDiscardStateHandleAfterFailure&quot;;&lt;br/&gt;
@@ -191,7 +183,7 @@ public void testReplace() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testReplace&quot;;&lt;br/&gt;
@@ -230,7 +222,7 @@ public void testReplaceNonExistingPath() throws Exception &lt;/p&gt;
{
 		RetrievableStateStorageHelper&amp;lt;Long&amp;gt; stateStorage = new LongStateStorage();
 
 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(
-				ZOOKEEPER.getClient(), stateStorage, Executors.directExecutor());
+				ZOOKEEPER.getClient(), stateStorage);
 
 		store.replace(&quot;/testReplaceNonExistingPath&quot;, 0, 1L);
 	}
&lt;p&gt;@@ -247,7 +239,7 @@ public void testReplaceDiscardStateHandleAfterFailure() throws Exception {&lt;br/&gt;
 		when(client.setData()).thenThrow(new RuntimeException(&quot;Expected test Exception.&quot;));&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client, stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				client, stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testReplaceDiscardStateHandleAfterFailure&quot;;&lt;br/&gt;
@@ -289,7 +281,7 @@ public void testGetAndExists() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testGetAndExists&quot;;&lt;br/&gt;
@@ -314,7 +306,7 @@ public void testGetNonExistingPath() throws Exception &lt;/p&gt;
{
 		LongStateStorage stateHandleProvider = new LongStateStorage();
 
 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(
-				ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());
+				ZOOKEEPER.getClient(), stateHandleProvider);
 
 		store.getAndLock(&quot;/testGetNonExistingPath&quot;);
 	}
&lt;p&gt;@@ -328,7 +320,7 @@ public void testGetAll() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testGetAll&quot;;&lt;br/&gt;
@@ -359,7 +351,7 @@ public void testGetAllSortedByName() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String basePath = &quot;/testGetAllSortedByName&quot;;&lt;br/&gt;
@@ -393,7 +385,7 @@ public void testRemove() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testRemove&quot;;&lt;br/&gt;
@@ -401,50 +393,14 @@ public void testRemove() throws Exception &lt;/p&gt;
{
 
 		store.addAndLock(pathInZooKeeper, state);
 
+		final int numberOfGlobalDiscardCalls = LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls();
+
 		// Test
 		store.releaseAndTryRemove(pathInZooKeeper);
 
 		// Verify discarded
 		assertEquals(0, ZOOKEEPER.getClient().getChildren().forPath(&quot;/&quot;).size());
-	}
&lt;p&gt;-&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Tests that state handles are correctly removed with a callback.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testRemoveWithCallback() throws Exception {&lt;/li&gt;
	&lt;li&gt;// Setup&lt;/li&gt;
	&lt;li&gt;LongStateStorage stateHandleProvider = new LongStateStorage();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/li&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Config&lt;/li&gt;
	&lt;li&gt;final String pathInZooKeeper = &quot;/testRemoveWithCallback&quot;;&lt;/li&gt;
	&lt;li&gt;final Long state = 27255442L;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;store.addAndLock(pathInZooKeeper, state);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CountDownLatch sync = new CountDownLatch(1);&lt;/li&gt;
	&lt;li&gt;ZooKeeperStateHandleStore.RemoveCallback&amp;lt;Long&amp;gt; callback = mock(ZooKeeperStateHandleStore.RemoveCallback.class);&lt;/li&gt;
	&lt;li&gt;doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public Void answer(InvocationOnMock invocation) throws Throwable 
{
-				sync.countDown();
-				return null;
-			}&lt;/li&gt;
	&lt;li&gt;}).when(callback).apply(any(RetrievableStateHandle.class));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Test&lt;/li&gt;
	&lt;li&gt;store.releaseAndTryRemove(pathInZooKeeper, callback);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Verify discarded and callback called&lt;/li&gt;
	&lt;li&gt;assertEquals(0, ZOOKEEPER.getClient().getChildren().forPath(&quot;/&quot;).size());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;sync.await();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;verify(callback, times(1))&lt;/li&gt;
	&lt;li&gt;.apply(any(RetrievableStateHandle.class));&lt;br/&gt;
+		assertEquals(numberOfGlobalDiscardCalls + 1, LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls());&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/** Tests that all state handles are correctly discarded. */&lt;br/&gt;
@@ -454,7 +410,7 @@ public void testReleaseAndTryRemoveAll() throws Exception {&lt;br/&gt;
 		LongStateStorage stateHandleProvider = new LongStateStorage();&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ZOOKEEPER.getClient(), stateHandleProvider, Executors.directExecutor());&lt;br/&gt;
+				ZOOKEEPER.getClient(), stateHandleProvider);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// Config&lt;br/&gt;
 		final String pathInZooKeeper = &quot;/testDiscardAll&quot;;&lt;br/&gt;
@@ -486,8 +442,7 @@ public void testCorruptedData() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; store = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;stateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			stateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final Collection&amp;lt;Long&amp;gt; input = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
 		input.add(1L);&lt;br/&gt;
@@ -543,13 +498,11 @@ public void testConcurrentDeleteOperation() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore1 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore2 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final String statePath = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -586,13 +539,11 @@ public void testLockCleanupWhenGetAndLockFails() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore1 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore2 = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final String path = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -649,8 +600,7 @@ public void testLockCleanupWhenClientTimesOut() throws Exception {&lt;/p&gt;

&lt;p&gt; 			ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 				client,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+				longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			final String path = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -682,8 +632,7 @@ public void testRelease() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final String path = &quot;/state&quot;;&lt;/p&gt;

&lt;p&gt;@@ -720,8 +669,7 @@ public void testReleaseAll() throws Exception {&lt;/p&gt;

&lt;p&gt; 		ZooKeeperStateHandleStore&amp;lt;Long&amp;gt; zkStore = new ZooKeeperStateHandleStore&amp;lt;&amp;gt;(&lt;br/&gt;
 			ZOOKEEPER.getClient(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;longStateStorage,&lt;/li&gt;
	&lt;li&gt;Executors.directExecutor());&lt;br/&gt;
+			longStateStorage);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final Collection&amp;lt;String&amp;gt; paths = Arrays.asList(&quot;/state1&quot;, &quot;/state2&quot;, &quot;/state3&quot;);&lt;/p&gt;

&lt;p&gt;@@ -775,9 +723,11 @@ public void testReleaseAll() throws Exception {&lt;/p&gt;

&lt;p&gt; 		private static final long serialVersionUID = -3555329254423838912L;&lt;/p&gt;

&lt;p&gt;+		private static int numberOfGlobalDiscardCalls = 0;&lt;br/&gt;
+&lt;br/&gt;
 		private final Long state;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private int numberOfDiscardCalls;&lt;br/&gt;
+		private int numberOfDiscardCalls = 0;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		public LongRetrievableStateHandle(Long state) {&lt;br/&gt;
 			this.state = state;&lt;br/&gt;
@@ -790,6 +740,7 @@ public Long retrieveState() {&lt;/p&gt;

&lt;p&gt; 		@Override&lt;br/&gt;
 		public void discardState() throws Exception &lt;/p&gt;
{
+			numberOfGlobalDiscardCalls++;
 			numberOfDiscardCalls++;
 		}

&lt;p&gt;@@ -798,8 +749,12 @@ public long getStateSize() &lt;/p&gt;
{
 			return 0;
 		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public int getNumberOfDiscardCalls() 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		int getNumberOfDiscardCalls() {
 			return numberOfDiscardCalls;
 		}++		public static int getNumberOfGlobalDiscardCalls() {
+			return numberOfGlobalDiscardCalls;
+		} 	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; }&lt;br/&gt;
diff --git a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala&lt;br/&gt;
index cd88133a0bd..2609dc3b7fe 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala&lt;br/&gt;
+++ b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerLike.scala&lt;br/&gt;
@@ -440,6 +440,14 @@ trait TestingJobManagerLike extends FlinkActor 
{
         val receiver = waitForNumRegisteredTaskManagers.dequeue()._2
         receiver ! Acknowledge.get()
       }
&lt;p&gt;+&lt;br/&gt;
+    case WaitForBackgroundTasksToFinish =&amp;gt;&lt;br/&gt;
+      val future = futuresToComplete match &lt;/p&gt;
{
+        case Some(futures) =&amp;gt; Future.sequence(futures)
+        case None =&amp;gt; Future.successful(Seq())
+      }
&lt;p&gt;+&lt;br/&gt;
+      future.pipeTo(sender())&lt;br/&gt;
   }&lt;/p&gt;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   def checkIfAllVerticesRunning(jobID: JobID): Boolean = {&lt;br/&gt;
diff --git a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala&lt;br/&gt;
index f79c1249bc7..4decfcfc76c 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala&lt;br/&gt;
+++ b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingJobManagerMessages.scala&lt;br/&gt;
@@ -58,6 +58,8 @@ object TestingJobManagerMessages {&lt;/p&gt;

&lt;p&gt;   case object NotifyListeners&lt;/p&gt;

&lt;p&gt;+  case object WaitForBackgroundTasksToFinish&lt;br/&gt;
+&lt;br/&gt;
   case class NotifyWhenTaskManagerTerminated(taskManager: ActorRef)&lt;br/&gt;
   case class TaskManagerTerminated(taskManager: ActorRef)&lt;/p&gt;

&lt;p&gt;@@ -164,4 +166,5 @@ object TestingJobManagerMessages &lt;/p&gt;
{
   def getClientConnected(): AnyRef = ClientConnected
   def getClassLoadingPropsDelivered(): AnyRef = ClassLoadingPropsDelivered
 
+  def getWaitForBackgroundTasksToFinish(): AnyRef = WaitForBackgroundTasksToFinish
 }




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310361">
                    <name>Blocked</name>
                                                                <inwardlinks description="Blocked">
                                        <issuelink>
            <issuekey id="13176414">FLINK-10030</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="13206564">FLINK-11225</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="13070761">FLINK-6521</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13181923">FLINK-10255</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13184827">FLINK-10333</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13176771">FLINK-10052</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 9 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3wjnz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>