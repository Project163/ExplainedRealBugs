<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:33:15 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-9269] Concurrency problem in HeapKeyedStateBackend when performing checkpoint async</title>
                <link>https://issues.apache.org/jira/browse/FLINK-9269</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
@Test
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void testConccurrencyProblem() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {

	CheckpointStreamFactory streamFactory = createStreamFactory();
	Environment env = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; DummyEnvironment();
	AbstractKeyedStateBackend&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; backend = createKeyedBackend(IntSerializer.INSTANCE, env);

	&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
		&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; checkpointID = 0;
		List&amp;lt;Future&amp;gt; futureList = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayList();
		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; ++i) {
			ValueStateDescriptor&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; kvId = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ValueStateDescriptor&amp;lt;&amp;gt;(&lt;span class=&quot;code-quote&quot;&gt;&quot;id&quot;&lt;/span&gt; + i, IntSerializer.INSTANCE);
			ValueState&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; state = backend.getOrCreateKeyedState(VoidNamespaceSerializer.INSTANCE, kvId);
			((InternalValueState) state).setCurrentNamespace(VoidNamespace.INSTANCE);
			backend.setCurrentKey(i);
			state.update(i);

			futureList.add(runSnapshotAsync(backend.snapshot(checkpointID++, &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis(), streamFactory, CheckpointOptions.forCheckpointWithDefaultLocation())));
		}

		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (Future &lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt; : futureList) {
			&lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt;.get();
		}
	} &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
		fail();
	} &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
		backend.dispose();
	}
}

&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; Future&amp;lt;?&amp;gt; runSnapshotAsync(
	RunnableFuture&amp;lt;SnapshotResult&amp;lt;KeyedStateHandle&amp;gt;&amp;gt; snapshotRunnableFuture) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {

	&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!snapshotRunnableFuture.isDone()) {
		&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; Executors.newFixedThreadPool(5).submit(() -&amp;gt; {
			&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
				snapshotRunnableFuture.run();
				snapshotRunnableFuture.get();
			} &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
				e.printStackTrace();
				fail();
			}
		});
	}
	&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Place the above code in `StateBackendTestBase` and run `AsyncMemoryStateBackendTest`, it will get the follows exception&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
java.util.concurrent.ExecutionException: java.lang.NullPointerException
	at java.util.concurrent.FutureTask.report(FutureTask.java:122)
	at java.util.concurrent.FutureTask.get(FutureTask.java:192)
	at org.apache.flink.runtime.state.AsyncMemoryStateBackendTest.lambda$runSnapshotAsync$0(AsyncMemoryStateBackendTest.java:85)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:745)
Caused by: java.lang.NullPointerException
	at org.apache.flink.runtime.state.heap.HeapKeyedStateBackend$HeapSnapshotStrategy$1.performOperation(HeapKeyedStateBackend.java:716)
	at org.apache.flink.runtime.state.heap.HeapKeyedStateBackend$HeapSnapshotStrategy$1.performOperation(HeapKeyedStateBackend.java:662)
	at org.apache.flink.runtime.io.async.AbstractAsyncCallableWithResources.call(AbstractAsyncCallableWithResources.java:75)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at org.apache.flink.runtime.state.AsyncMemoryStateBackendTest.lambda$runSnapshotAsync$0(AsyncMemoryStateBackendTest.java:84)
	... 5 more
java.util.concurrent.ExecutionException: java.lang.NullPointerException
	at java.util.concurrent.FutureTask.report(FutureTask.java:122)
	at java.util.concurrent.FutureTask.get(FutureTask.java:192)
	at org.apache.flink.runtime.state.AsyncMemoryStateBackendTest.lambda$runSnapshotAsync$0(AsyncMemoryStateBackendTest.java:85)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:745)
Caused by: java.lang.NullPointerException
	at org.apache.flink.runtime.state.heap.HeapKeyedStateBackend$HeapSnapshotStrategy$1.performOperation(HeapKeyedStateBackend.java:716)
	at org.apache.flink.runtime.state.heap.HeapKeyedStateBackend$HeapSnapshotStrategy$1.performOperation(HeapKeyedStateBackend.java:662)
	at org.apache.flink.runtime.io.async.AbstractAsyncCallableWithResources.call(AbstractAsyncCallableWithResources.java:75)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at org.apache.flink.runtime.state.AsyncMemoryStateBackendTest.lambda$runSnapshotAsync$0(AsyncMemoryStateBackendTest.java:84)
	... 5 more
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
                <environment></environment>
        <key id="13155849">FLINK-9269</key>
            <summary>Concurrency problem in HeapKeyedStateBackend when performing checkpoint async</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="sihuazhou">Sihua Zhou</assignee>
                                    <reporter username="sihuazhou">Sihua Zhou</reporter>
                        <labels>
                    </labels>
                <created>Sat, 28 Apr 2018 02:30:04 +0000</created>
                <updated>Fri, 4 May 2018 08:05:02 +0000</updated>
                            <resolved>Fri, 4 May 2018 08:05:02 +0000</resolved>
                                    <version>1.5.0</version>
                                    <fixVersion>1.6.0</fixVersion>
                                    <component>Runtime / State Backends</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="16457332" author="githubbot" created="Sat, 28 Apr 2018 03:03:48 +0000"  >&lt;p&gt;GitHub user sihuazhou opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9269&quot; title=&quot;Concurrency problem in HeapKeyedStateBackend when performing checkpoint async&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9269&quot;&gt;&lt;del&gt;FLINK-9269&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;state&amp;#93;&lt;/span&gt;  fix concurrency problem when performing checkpoint in HeapKeyedStateBackend&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    &lt;b&gt;This PR fixes the concurrency problem in `HeapKeyedStateBackend`, and contains an additional hotfix for `RocksDBKeyedStateBackend` to duplicate the `KeySerializer` for full checkpoint&lt;/b&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;b&gt;fix concurrency problem when performing checkpoint in `HeapKeyedStateBackend`&lt;/b&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;hotfix&amp;#93;&lt;/span&gt; duplicate the key serializer when performing full checkpoint  in `RocksDBKeyedBackend`&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This change is a trivial rework / code cleanup without any test coverage.&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (yes)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    no&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/sihuazhou/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/sihuazhou/flink&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9269&quot; title=&quot;Concurrency problem in HeapKeyedStateBackend when performing checkpoint async&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9269&quot;&gt;&lt;del&gt;FLINK-9269&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #5934&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit f60d4d1fcd85612c792bec4d0c0d9ba1b142e1e9&lt;br/&gt;
Author: sihuazhou &amp;lt;summerleafs@...&amp;gt;&lt;br/&gt;
Date:   2018-04-28T02:50:41Z&lt;/p&gt;

&lt;p&gt;    fix concurrency problem when performing checkpoint in HeapKeyedStateBackend.&lt;/p&gt;

&lt;p&gt;commit c998dbfc78b657bcbd47a836d23b819ce61778b9&lt;br/&gt;
Author: sihuazhou &amp;lt;summerleafs@...&amp;gt;&lt;br/&gt;
Date:   2018-04-28T02:57:11Z&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;hotfix&amp;#93;&lt;/span&gt; duplicate the key serializer when performing full checkpoint in RocksDBKeyedBackend.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16457525" author="githubbot" created="Sat, 28 Apr 2018 10:32:43 +0000"  >&lt;p&gt;Github user StefanRRichter commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Hi, can you give some more detail about the actual problem you are trying to fix here? To me it looks like duplicating the serializer only for the meta data should not be required, because the serializer is just written and the getter is only used in a restore, which is never async. You can make an argument that this is just making the code more defensive, which is a good thing. But I just want to raise awareness that duplicating a serializer is not always super cheap, and this counts for the time spend in the synchronous part. So there is a tradeoff and that is why I would like to discuss if this is really a benefit?&lt;/p&gt;</comment>
                            <comment id="16457526" author="githubbot" created="Sat, 28 Apr 2018 10:41:30 +0000"  >&lt;p&gt;Github user sihuazhou commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Hi @StefanRRichter sorry for the unclearly description here. What this PR trying to fix is the mainly relate to the below code which run async:&lt;br/&gt;
    ```java&lt;br/&gt;
    for (Map.Entry&amp;lt;String, StateTable&amp;lt;K, ?, ?&amp;gt;&amp;gt; kvState : stateTables.entrySet()) &lt;/p&gt;
{
       // do something    								
    }
&lt;p&gt; // this will just close the outer compression stream&lt;br/&gt;
    ```&lt;br/&gt;
    the `stateTables` may cause concurrency problem.&lt;/p&gt;</comment>
                            <comment id="16457528" author="githubbot" created="Sat, 28 Apr 2018 10:48:11 +0000"  >&lt;p&gt;Github user sihuazhou commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    About the serializer duplication problem, I think you are right, duplicating a serialize is not always super cheap, so I think maybe the best tradeoff is to not duplicate the serializer to save the performance cost, and add some dedicated comments to describe why we don&apos;t duplicate it to making the code more &quot;defensive&quot;, what do you think?&lt;/p&gt;</comment>
                            <comment id="16457539" author="githubbot" created="Sat, 28 Apr 2018 11:04:56 +0000"  >&lt;p&gt;Github user StefanRRichter commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I am also a bit torn. Sometimes I am thinking we might just have a pool with as many serializer copies as se can have concurrent checkpoints + savepoints. But then again, it is borderline to premature optimization. For this particular case, I think your suggestion sounds good.&lt;/p&gt;</comment>
                            <comment id="16458031" author="githubbot" created="Sun, 29 Apr 2018 14:53:58 +0000"  >&lt;p&gt;Github user sihuazhou commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Hi @StefanRRichter , I think I feel lost again... when I writing the comments for the serializer about why we don&apos;t duplicate it, I found a loophole there. In theory, even tough the serializer is just written, but if the serializer is stateful (e.g. it maintain a `variable` inside, and do the serializing works according to it and also may update the `variable` according to the serialized result) then it might also lead to concurrency problem if we don&apos;t duplicate it. But in practice, I can&apos;t find any use cases that need a stateful serializer as far as I can see... So, now I feel lost in duplicating it to be on the safer side in theory or just add some comments without duplicate it to avoid the costs of the duplicating. What do you think?&lt;/p&gt;</comment>
                            <comment id="16458527" author="aljoscha" created="Mon, 30 Apr 2018 12:29:01 +0000"  >&lt;p&gt;Is there an actual symptom of this, i.e. a failure with a log or something?&lt;/p&gt;</comment>
                            <comment id="16458692" author="githubbot" created="Mon, 30 Apr 2018 15:59:30 +0000"  >&lt;p&gt;Github user StephanEwen commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Concerning serializer snapshots:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;We need to move away from Java Serializing the serializers into the config snapshots anyways and should do that in the near future.&lt;/li&gt;
	&lt;li&gt;I think the config snapshot should be created once when the state is created, encoded as `byte[]`, and then we only write the bytes. That safes us from repeated work on every checkpoint and would also prevent concurrent access to the serializer for creating the snapshot.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="16458756" author="sihuazhou" created="Mon, 30 Apr 2018 16:51:01 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=aljoscha&quot; class=&quot;user-hover&quot; rel=&quot;aljoscha&quot;&gt;aljoscha&lt;/a&gt;, I didn&apos;t find a symptom there yet. But I think I can trigger the concurrency problem very easily, because it&apos;s an obviously bug that there could be multi thread access the `stateTab` concurrency, and one of there can modify the `stateTab`...But so far, no users have reported the problem, maybe that&apos;s because most of the user are using the RocksDBKeyedBackend online instead of HeapKeyedStateBackend, now I&apos;m going to remove the it from the BROCKER list.&lt;/p&gt;</comment>
                            <comment id="16458775" author="githubbot" created="Mon, 30 Apr 2018 17:16:00 +0000"  >&lt;p&gt;Github user sihuazhou commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for your comments, @StephanEwen , If I am not misunderstanding , we don&apos;t need to duplicate the serializer now, because we will have a dedicated optimization for it in the near future, I am `+1` for that. Then, what about the concurrency problem cause by the `stateTables`, it&apos;s an obvious bug that there could be multi thread access the `stateTab` concurrently, and one of them could modify the `stateTab`...But so far, no users have reported that problem yet, maybe that&apos;s because most of the user are using the `RocksDBKeyedBackend` online instead of `HeapKeyedStateBackend`, so I think this is not an urgent bug, but...it&apos;s still a bug, Is it should be fixed for 1.5?&lt;/p&gt;</comment>
                            <comment id="16459483" author="sihuazhou" created="Tue, 1 May 2018 06:42:23 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=aljoscha&quot; class=&quot;user-hover&quot; rel=&quot;aljoscha&quot;&gt;aljoscha&lt;/a&gt; I have updated the JIRA description with the code to fire the problem and the corresponding exception log.&lt;/p&gt;</comment>
                            <comment id="16460806" author="githubbot" created="Wed, 2 May 2018 10:06:03 +0000"  >&lt;p&gt;Github user StefanRRichter commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Yes, there is a theoretical problem if the serialization would not be threadsafe. I think currently the silent assumption that holds is that serializers are immutable w.r.t. serialization after they have been created and passed to create a state. I think Stephan&apos;s suggestion would be the right approach to materialize that assumption into code and also gain a bit of efficiency.&lt;br/&gt;
    I think the other concurrency problem is a problem that comes from lazy state registration, and I assume most jobs use de-facto eager state registration, so all the state is registered in `open()` or `initializeState(...)`, and they are never changed at runtime. For the few remaining jobs, there must also be a certain timing that they need to register a new state while a checkpoint is running. Overall, I think those are the reasons why there is no reported case of a problem from this in practice. But I agree this should be addressed and is also very easy to fix.&lt;/p&gt;</comment>
                            <comment id="16460817" author="githubbot" created="Wed, 2 May 2018 10:11:36 +0000"  >&lt;p&gt;Github user sihuazhou commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Hi @StefanRRichter Thanks for your reply, I have updated the PR and add a test to guard this, but I not sure whether the test is indeed required because it looks a bit wired in my mind...&lt;/p&gt;</comment>
                            <comment id="16460901" author="githubbot" created="Wed, 2 May 2018 11:24:42 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934#discussion_r185464970&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934#discussion_r185464970&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java &amp;#8212;&lt;br/&gt;
    @@ -3594,6 +3599,58 @@ public String fold(String acc, Integer value) throws Exception {&lt;br/&gt;
     		}&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testCheckConcurrencyProblemWhenPerformingCheckpointAsync() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		CheckpointStreamFactory streamFactory = createStreamFactory();&lt;br/&gt;
    +		Environment env = new DummyEnvironment();&lt;br/&gt;
    +		AbstractKeyedStateBackend&amp;lt;Integer&amp;gt; backend = createKeyedBackend(IntSerializer.INSTANCE, env);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService executorService = Executors.newScheduledThreadPool(1);&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			long checkpointID = 0;&lt;br/&gt;
    +			List&amp;lt;Future&amp;gt; futureList = new ArrayList();&lt;br/&gt;
    +			for (int i = 0; i &amp;lt; 10; ++i) &lt;/p&gt;
{
    +				ValueStateDescriptor&amp;lt;Integer&amp;gt; kvId = new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;id&quot; + i, IntSerializer.INSTANCE);
    +				ValueState&amp;lt;Integer&amp;gt; state = backend.getOrCreateKeyedState(VoidNamespaceSerializer.INSTANCE, kvId);
    +				((InternalValueState) state).setCurrentNamespace(VoidNamespace.INSTANCE);
    +				backend.setCurrentKey(i);
    +				state.update(i);
    +
    +				futureList.add(runSnapshotAsync(executorService,
    +					backend.snapshot(checkpointID++, System.currentTimeMillis(), streamFactory, CheckpointOptions.forCheckpointWithDefaultLocation())));
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			for (Future future : futureList) &lt;/p&gt;
{
    +				future.get(10, TimeUnit.SECONDS);
    +			}
&lt;p&gt;    +		} catch (Exception e) &lt;/p&gt;
{
    +			fail();
    +		}
&lt;p&gt; finally &lt;/p&gt;
{
    +			backend.dispose();
    +			executorService.shutdown();
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected Future&amp;lt;SnapshotResult&amp;lt;KeyedStateHandle&amp;gt;&amp;gt; runSnapshotAsync(&lt;br/&gt;
    +		ExecutorService executorService,&lt;br/&gt;
    +		RunnableFuture&amp;lt;SnapshotResult&amp;lt;KeyedStateHandle&amp;gt;&amp;gt; snapshotRunnableFuture) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		if (!snapshotRunnableFuture.isDone()) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I think you could replace this code with `CompletableFuture.runAsync(...)`.&lt;/p&gt;</comment>
                            <comment id="16460902" author="githubbot" created="Wed, 2 May 2018 11:25:37 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934#discussion_r185465142&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934#discussion_r185465142&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1987,6 +1987,8 @@ private void writeKVStateMetaData() throws IOException {&lt;/p&gt;

&lt;p&gt;     			KeyedBackendSerializationProxy&amp;lt;K&amp;gt; serializationProxy =&lt;br/&gt;
     				new KeyedBackendSerializationProxy&amp;lt;&amp;gt;(&lt;br/&gt;
    +					// we use the statBackend&apos;s keySerializer directly here, because it just be written here.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    `statBackend&apos;s ` -&amp;gt; `stateBackend&apos;s`&lt;/p&gt;</comment>
                            <comment id="16460904" author="githubbot" created="Wed, 2 May 2018 11:26:53 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934#discussion_r185465407&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934#discussion_r185465407&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1987,6 +1987,8 @@ private void writeKVStateMetaData() throws IOException {&lt;/p&gt;

&lt;p&gt;     			KeyedBackendSerializationProxy&amp;lt;K&amp;gt; serializationProxy =&lt;br/&gt;
     				new KeyedBackendSerializationProxy&amp;lt;&amp;gt;(&lt;br/&gt;
    +					// we use the statBackend&apos;s keySerializer directly here, because it just be written here.&lt;br/&gt;
    +					// NOTE: There&apos;s a loophole when the serializer is stateful, but that rarely occur in reality use case.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I wonder if this note does not sound a bit to scary, maybe we could just add a todo that this code assumes that writing a serializer is threadsafe and that we could get a serialized form already at state registration time in the future?&lt;/p&gt;</comment>
                            <comment id="16460924" author="githubbot" created="Wed, 2 May 2018 11:52:17 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934#discussion_r185470576&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934#discussion_r185470576&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -622,20 +622,23 @@ public HeapSnapshotStrategy(&lt;/p&gt;

&lt;p&gt;     			final Map&amp;lt;String, Integer&amp;gt; kVStateToId = new HashMap&amp;lt;&amp;gt;(stateTables.size());&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final Map&amp;lt;StateTable&amp;lt;K, ?, ?&amp;gt;, StateTableSnapshot&amp;gt; cowStateStableSnapshots =&lt;br/&gt;
    +			final Map&amp;lt;String, StateTableSnapshot&amp;gt; cowStateStableSnapshots =&lt;br/&gt;
     				new HashedMap(stateTables.size());
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Seems like I accidentally used `new HashedMap(...)` here instead of Java&apos;s `new HashMap&amp;lt;&amp;gt;(...)`. As you touch this spot already, maybe you can just also correct that?&lt;/p&gt;</comment>
                            <comment id="16460925" author="githubbot" created="Wed, 2 May 2018 11:54:23 +0000"  >&lt;p&gt;Github user StefanRRichter commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for your work! Besides my comments, this looks good &#128077; &lt;/p&gt;</comment>
                            <comment id="16460982" author="githubbot" created="Wed, 2 May 2018 12:55:26 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934#discussion_r185485401&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934#discussion_r185485401&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java &amp;#8212;&lt;br/&gt;
    @@ -3594,6 +3599,58 @@ public String fold(String acc, Integer value) throws Exception {&lt;br/&gt;
     		}&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testCheckConcurrencyProblemWhenPerformingCheckpointAsync() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		CheckpointStreamFactory streamFactory = createStreamFactory();&lt;br/&gt;
    +		Environment env = new DummyEnvironment();&lt;br/&gt;
    +		AbstractKeyedStateBackend&amp;lt;Integer&amp;gt; backend = createKeyedBackend(IntSerializer.INSTANCE, env);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService executorService = Executors.newScheduledThreadPool(1);&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			long checkpointID = 0;&lt;br/&gt;
    +			List&amp;lt;Future&amp;gt; futureList = new ArrayList();&lt;br/&gt;
    +			for (int i = 0; i &amp;lt; 10; ++i) &lt;/p&gt;
{
    +				ValueStateDescriptor&amp;lt;Integer&amp;gt; kvId = new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;id&quot; + i, IntSerializer.INSTANCE);
    +				ValueState&amp;lt;Integer&amp;gt; state = backend.getOrCreateKeyedState(VoidNamespaceSerializer.INSTANCE, kvId);
    +				((InternalValueState) state).setCurrentNamespace(VoidNamespace.INSTANCE);
    +				backend.setCurrentKey(i);
    +				state.update(i);
    +
    +				futureList.add(runSnapshotAsync(executorService,
    +					backend.snapshot(checkpointID++, System.currentTimeMillis(), streamFactory, CheckpointOptions.forCheckpointWithDefaultLocation())));
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			for (Future future : futureList) &lt;/p&gt;
{
    +				future.get(10, TimeUnit.SECONDS);
    +			}
&lt;p&gt;    +		} catch (Exception e) &lt;/p&gt;
{
    +			fail();
    +		}
&lt;p&gt; finally &lt;/p&gt;
{
    +			backend.dispose();
    +			executorService.shutdown();
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected Future&amp;lt;SnapshotResult&amp;lt;KeyedStateHandle&amp;gt;&amp;gt; runSnapshotAsync(&lt;br/&gt;
    +		ExecutorService executorService,&lt;br/&gt;
    +		RunnableFuture&amp;lt;SnapshotResult&amp;lt;KeyedStateHandle&amp;gt;&amp;gt; snapshotRunnableFuture) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		if (!snapshotRunnableFuture.isDone()) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &#128077; &lt;/p&gt;</comment>
                            <comment id="16460983" author="githubbot" created="Wed, 2 May 2018 12:55:51 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934#discussion_r185485532&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934#discussion_r185485532&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1987,6 +1987,8 @@ private void writeKVStateMetaData() throws IOException {&lt;/p&gt;

&lt;p&gt;     			KeyedBackendSerializationProxy&amp;lt;K&amp;gt; serializationProxy =&lt;br/&gt;
     				new KeyedBackendSerializationProxy&amp;lt;&amp;gt;(&lt;br/&gt;
    +					// we use the statBackend&apos;s keySerializer directly here, because it just be written here.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &#128077; &lt;/p&gt;</comment>
                            <comment id="16460988" author="githubbot" created="Wed, 2 May 2018 12:58:18 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934#discussion_r185486196&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934#discussion_r185486196&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1987,6 +1987,8 @@ private void writeKVStateMetaData() throws IOException {&lt;/p&gt;

&lt;p&gt;     			KeyedBackendSerializationProxy&amp;lt;K&amp;gt; serializationProxy =&lt;br/&gt;
     				new KeyedBackendSerializationProxy&amp;lt;&amp;gt;(&lt;br/&gt;
    +					// we use the statBackend&apos;s keySerializer directly here, because it just be written here.&lt;br/&gt;
    +					// NOTE: There&apos;s a loophole when the serializer is stateful, but that rarely occur in reality use case.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &#128077; &lt;/p&gt;</comment>
                            <comment id="16460989" author="githubbot" created="Wed, 2 May 2018 12:58:40 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934#discussion_r185486283&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934#discussion_r185486283&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -622,20 +622,23 @@ public HeapSnapshotStrategy(&lt;/p&gt;

&lt;p&gt;     			final Map&amp;lt;String, Integer&amp;gt; kVStateToId = new HashMap&amp;lt;&amp;gt;(stateTables.size());&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final Map&amp;lt;StateTable&amp;lt;K, ?, ?&amp;gt;, StateTableSnapshot&amp;gt; cowStateStableSnapshots =&lt;br/&gt;
    +			final Map&amp;lt;String, StateTableSnapshot&amp;gt; cowStateStableSnapshots =&lt;br/&gt;
     				new HashedMap(stateTables.size());
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I will correct it in this PR.&lt;/p&gt;</comment>
                            <comment id="16461076" author="githubbot" created="Wed, 2 May 2018 14:09:09 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934#discussion_r185508430&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934#discussion_r185508430&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java &amp;#8212;&lt;br/&gt;
    @@ -3594,6 +3599,58 @@ public String fold(String acc, Integer value) throws Exception {&lt;br/&gt;
     		}&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testCheckConcurrencyProblemWhenPerformingCheckpointAsync() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		CheckpointStreamFactory streamFactory = createStreamFactory();&lt;br/&gt;
    +		Environment env = new DummyEnvironment();&lt;br/&gt;
    +		AbstractKeyedStateBackend&amp;lt;Integer&amp;gt; backend = createKeyedBackend(IntSerializer.INSTANCE, env);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService executorService = Executors.newScheduledThreadPool(1);&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			long checkpointID = 0;&lt;br/&gt;
    +			List&amp;lt;Future&amp;gt; futureList = new ArrayList();&lt;br/&gt;
    +			for (int i = 0; i &amp;lt; 10; ++i) &lt;/p&gt;
{
    +				ValueStateDescriptor&amp;lt;Integer&amp;gt; kvId = new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;id&quot; + i, IntSerializer.INSTANCE);
    +				ValueState&amp;lt;Integer&amp;gt; state = backend.getOrCreateKeyedState(VoidNamespaceSerializer.INSTANCE, kvId);
    +				((InternalValueState) state).setCurrentNamespace(VoidNamespace.INSTANCE);
    +				backend.setCurrentKey(i);
    +				state.update(i);
    +
    +				futureList.add(runSnapshotAsync(executorService,
    +					backend.snapshot(checkpointID++, System.currentTimeMillis(), streamFactory, CheckpointOptions.forCheckpointWithDefaultLocation())));
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			for (Future future : futureList) &lt;/p&gt;
{
    +				future.get(10, TimeUnit.SECONDS);
    +			}
&lt;p&gt;    +		} catch (Exception e) &lt;/p&gt;
{
    +			fail();
    +		}
&lt;p&gt; finally &lt;/p&gt;
{
    +			backend.dispose();
    +			executorService.shutdown();
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected Future&amp;lt;SnapshotResult&amp;lt;KeyedStateHandle&amp;gt;&amp;gt; runSnapshotAsync(&lt;br/&gt;
    +		ExecutorService executorService,&lt;br/&gt;
    +		RunnableFuture&amp;lt;SnapshotResult&amp;lt;KeyedStateHandle&amp;gt;&amp;gt; snapshotRunnableFuture) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		if (!snapshotRunnableFuture.isDone()) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Sorry, my bad, I overlooked that you are using the return value. I will revert this to your first approach before merging because this does not really improve it. &lt;/p&gt;</comment>
                            <comment id="16461077" author="githubbot" created="Wed, 2 May 2018 14:09:20 +0000"  >&lt;p&gt;Github user StefanRRichter commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks! Will merge once my travis run is green.&lt;/p&gt;</comment>
                            <comment id="16462049" author="githubbot" created="Thu, 3 May 2018 07:29:19 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5934&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16463526" author="srichter" created="Fri, 4 May 2018 08:05:02 +0000"  >&lt;p&gt;Merged in:&lt;/p&gt;

&lt;p&gt;master:&#160;14e7d35f26&lt;/p&gt;

&lt;p&gt;release-1.5:&#160;3ba21adc0e&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 28 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3t4pj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>