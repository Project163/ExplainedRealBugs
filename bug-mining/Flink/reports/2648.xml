<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:35:15 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-10415] RestClient does not react to lost connection</title>
                <link>https://issues.apache.org/jira/browse/FLINK-10415</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;While working on &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10403&quot; title=&quot;Port JobManagerHAProcessFailureBatchRecoveryITCase to new code base&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10403&quot;&gt;&lt;del&gt;FLINK-10403&lt;/del&gt;&lt;/a&gt;, I noticed that Flink&apos;s &lt;tt&gt;RestClient&lt;/tt&gt; does not seem to react to a lost connections in time. When sending a request to the current leader it happened that the leader was killed just after establishing the connection. Then the &lt;tt&gt;RestClient&lt;/tt&gt; did not fail the connection and was stuck in writing a request or retrieving a response from the lost leader. I&apos;m wondering whether we should introduce a &lt;tt&gt;ReadTimeoutHandler&lt;/tt&gt; and &lt;tt&gt;WriteTimeoutHandler&lt;/tt&gt; to handle these problems.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13187219">FLINK-10415</key>
            <summary>RestClient does not react to lost connection</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="trohrmann">Till Rohrmann</assignee>
                                    <reporter username="trohrmann">Till Rohrmann</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Tue, 25 Sep 2018 09:03:40 +0000</created>
                <updated>Fri, 28 Sep 2018 09:37:20 +0000</updated>
                            <resolved>Fri, 28 Sep 2018 09:37:01 +0000</resolved>
                                    <version>1.5.4</version>
                    <version>1.6.1</version>
                    <version>1.7.0</version>
                                    <fixVersion>1.5.5</fixVersion>
                    <fixVersion>1.6.2</fixVersion>
                    <fixVersion>1.7.0</fixVersion>
                                    <component>Runtime / REST</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16628368" author="githubbot" created="Wed, 26 Sep 2018 07:44:07 +0000"  >&lt;p&gt;tillrohrmann opened a new pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   If the RestClient detects that a connection was closed (channel became inactive), then&lt;br/&gt;
   it now fails the json response future with a ConnectionClosedException.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added `RestClientTest#testConnectionClosedHandling` and `RestClientTest#testRestClientClosedHandling`&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (no)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (no)&lt;/li&gt;
	&lt;li&gt;The serializers: (no)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (no)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (no)&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: (no)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (no)&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? (not applicable)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16628384" author="githubbot" created="Wed, 26 Sep 2018 08:02:20 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220461106&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220461106&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -428,6 +447,12 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) &lt;/p&gt;
{
 			ctx.close();
 		}

&lt;p&gt;+		@Override&lt;br/&gt;
+		public void channelInactive(ChannelHandlerContext ctx) throws Exception {&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   doesn&apos;t belong to this commit.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16628487" author="githubbot" created="Wed, 26 Sep 2018 09:46:47 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220495572&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220495572&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -428,6 +447,12 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) &lt;/p&gt;
{
 			ctx.close();
 		}

&lt;p&gt;+		@Override&lt;br/&gt;
+		public void channelInactive(ChannelHandlerContext ctx) throws Exception {&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   True, will fix it.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16628499" author="githubbot" created="Wed, 26 Sep 2018 10:00:57 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220500274&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220500274&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestClientTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -89,7 +91,78 @@ public void testInvalidVersionRejection() throws Exception {&lt;br/&gt;
 		} catch (IllegalArgumentException e) &lt;/p&gt;
{
 			// expected
 		}
&lt;p&gt;+	}&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the remote connection closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testConnectionClosedHandling() throws Exception {&lt;br/&gt;
+		final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+		final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+		final int targetPort = serverSocket.getLocalPort();&lt;br/&gt;
+&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;br/&gt;
+				targetAddress,&lt;br/&gt;
+				targetPort,&lt;br/&gt;
+				new TestMessageHeaders(),&lt;br/&gt;
+				EmptyMessageParameters.getInstance(),&lt;br/&gt;
+				EmptyRequestBody.getInstance(),&lt;br/&gt;
+				Collections.emptyList());&lt;br/&gt;
+&lt;br/&gt;
+			// establish connection&lt;br/&gt;
+			final Socket connectionSocket = serverSocket.accept();&lt;br/&gt;
+&lt;br/&gt;
+			// close connection&lt;br/&gt;
+			connectionSocket.close();&lt;br/&gt;
+&lt;br/&gt;
+			try &lt;/p&gt;
{
+				responseFuture.get();
+			} catch (ExecutionException ee) {
+				assertThat(ExceptionUtils.findThrowable(ee, ConnectionClosedException.class).isPresent(), is(true));
+			}&lt;br/&gt;
+		} finally {
+			serverSocket.close();
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the client closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testRestClientClosedHandling() throws Exception {&lt;br/&gt;
+		final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+		final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+		final int targetPort = serverSocket.getLocalPort();&lt;br/&gt;
+		Socket connectionSocket = null;&lt;br/&gt;
+&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;br/&gt;
+				targetAddress,&lt;br/&gt;
+				targetPort,&lt;br/&gt;
+				new TestMessageHeaders(),&lt;br/&gt;
+				EmptyMessageParameters.getInstance(),&lt;br/&gt;
+				EmptyRequestBody.getInstance(),&lt;br/&gt;
+				Collections.emptyList());&lt;br/&gt;
+&lt;br/&gt;
+			// establish connection&lt;br/&gt;
+			connectionSocket = serverSocket.accept();&lt;br/&gt;
+&lt;br/&gt;
+			restClient.close();&lt;br/&gt;
+&lt;br/&gt;
+			try {+				responseFuture.get();+			}
&lt;p&gt; catch (ExecutionException ee) {&lt;br/&gt;
+				assertThat(ExceptionUtils.findThrowable(ee, ConnectionClosedException.class).isPresent(), is(true));&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   this test is currently failing, and the travis logs aren&apos;t that helpful.&lt;br/&gt;
   We could write the assertion like this to make the error message more helpful:&lt;br/&gt;
   ```&lt;br/&gt;
   optionalException = ExceptionUtils.findThrowable(ee, ConnectionClosedException.class)&lt;br/&gt;
   if (!optionalException.isPresent()) &lt;/p&gt;
{
   	throw ee;
   }
&lt;p&gt;   ```&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16628507" author="githubbot" created="Wed, 26 Sep 2018 10:06:38 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220502083&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220502083&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestClientTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -89,7 +91,78 @@ public void testInvalidVersionRejection() throws Exception {&lt;br/&gt;
 		} catch (IllegalArgumentException e) &lt;/p&gt;
{
 			// expected
 		}
&lt;p&gt;+	}&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the remote connection closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testConnectionClosedHandling() throws Exception {&lt;br/&gt;
+		final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+		final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+		final int targetPort = serverSocket.getLocalPort();&lt;br/&gt;
+&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;br/&gt;
+				targetAddress,&lt;br/&gt;
+				targetPort,&lt;br/&gt;
+				new TestMessageHeaders(),&lt;br/&gt;
+				EmptyMessageParameters.getInstance(),&lt;br/&gt;
+				EmptyRequestBody.getInstance(),&lt;br/&gt;
+				Collections.emptyList());&lt;br/&gt;
+&lt;br/&gt;
+			// establish connection&lt;br/&gt;
+			final Socket connectionSocket = serverSocket.accept();&lt;br/&gt;
+&lt;br/&gt;
+			// close connection&lt;br/&gt;
+			connectionSocket.close();&lt;br/&gt;
+&lt;br/&gt;
+			try &lt;/p&gt;
{
+				responseFuture.get();
+			}
&lt;p&gt; catch (ExecutionException ee) &lt;/p&gt;
{
+				assertThat(ExceptionUtils.findThrowable(ee, ConnectionClosedException.class).isPresent(), is(true));
+			}
&lt;p&gt;+		} finally &lt;/p&gt;
{
+			serverSocket.close();
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the client closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testRestClientClosedHandling() throws Exception {&lt;br/&gt;
+		final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+		final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+		final int targetPort = serverSocket.getLocalPort();&lt;br/&gt;
+		Socket connectionSocket = null;&lt;br/&gt;
+&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I&apos;m wondering...consider the `submitRequest` method from the `RestClient`:&lt;br/&gt;
   ```&lt;br/&gt;
   private &amp;lt;P extends ResponseBody&amp;gt; CompletableFuture&amp;lt;P&amp;gt; submitRequest(String targetAddress, int targetPort, Request httpRequest, JavaType responseType) {&lt;br/&gt;
   		final ChannelFuture connectFuture = bootstrap.connect(targetAddress, targetPort);&lt;/p&gt;

&lt;p&gt;   		final CompletableFuture&amp;lt;Channel&amp;gt; channelFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;p&gt;   		connectFuture.addListener(&lt;br/&gt;
   			(ChannelFuture future) -&amp;gt; {&lt;br/&gt;
   				if (future.isSuccess()) &lt;/p&gt;
{
   					channelFuture.complete(future.channel());
   				}
&lt;p&gt; else &lt;/p&gt;
{
   					channelFuture.completeExceptionally(future.cause());
   				}
&lt;p&gt;   			});&lt;/p&gt;

&lt;p&gt;   		return channelFuture&lt;br/&gt;
   			.thenComposeAsync(&lt;br/&gt;
   				channel -&amp;gt; {&lt;br/&gt;
   					ClientHandler handler = channel.pipeline().get(ClientHandler.class);&lt;br/&gt;
   					CompletableFuture&amp;lt;JsonResponse&amp;gt; future = handler.getJsonFuture();&lt;br/&gt;
   					try &lt;/p&gt;
{
   						httpRequest.writeTo(channel);
   					}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
   						return FutureUtils.completedExceptionally(new FlinkException(&quot;Could not write request.&quot;, e));
   					}
&lt;p&gt;   					return future;&lt;br/&gt;
   				},&lt;br/&gt;
   				executor)&lt;br/&gt;
   			.thenComposeAsync(&lt;br/&gt;
   				(JsonResponse rawResponse) -&amp;gt; parseResponse(rawResponse, responseType),&lt;br/&gt;
   executor);&lt;br/&gt;
   ```&lt;/p&gt;

&lt;p&gt;   What happens if the client is shutdown, before the `thenComposeAsync` portions have been run? Then the channelFuture is completed by the listener; and then subsequent stages aren&apos;t executed?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16628511" author="githubbot" created="Wed, 26 Sep 2018 10:08:01 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220502083&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220502083&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestClientTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -89,7 +91,78 @@ public void testInvalidVersionRejection() throws Exception {&lt;br/&gt;
 		} catch (IllegalArgumentException e) &lt;/p&gt;
{
 			// expected
 		}
&lt;p&gt;+	}&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the remote connection closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testConnectionClosedHandling() throws Exception {&lt;br/&gt;
+		final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+		final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+		final int targetPort = serverSocket.getLocalPort();&lt;br/&gt;
+&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;br/&gt;
+				targetAddress,&lt;br/&gt;
+				targetPort,&lt;br/&gt;
+				new TestMessageHeaders(),&lt;br/&gt;
+				EmptyMessageParameters.getInstance(),&lt;br/&gt;
+				EmptyRequestBody.getInstance(),&lt;br/&gt;
+				Collections.emptyList());&lt;br/&gt;
+&lt;br/&gt;
+			// establish connection&lt;br/&gt;
+			final Socket connectionSocket = serverSocket.accept();&lt;br/&gt;
+&lt;br/&gt;
+			// close connection&lt;br/&gt;
+			connectionSocket.close();&lt;br/&gt;
+&lt;br/&gt;
+			try &lt;/p&gt;
{
+				responseFuture.get();
+			}
&lt;p&gt; catch (ExecutionException ee) &lt;/p&gt;
{
+				assertThat(ExceptionUtils.findThrowable(ee, ConnectionClosedException.class).isPresent(), is(true));
+			}
&lt;p&gt;+		} finally &lt;/p&gt;
{
+			serverSocket.close();
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the client closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testRestClientClosedHandling() throws Exception {&lt;br/&gt;
+		final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+		final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+		final int targetPort = serverSocket.getLocalPort();&lt;br/&gt;
+		Socket connectionSocket = null;&lt;br/&gt;
+&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I&apos;m wondering...consider the `submitRequest` method from the `RestClient`:&lt;br/&gt;
   ```&lt;br/&gt;
   private &amp;lt;P extends ResponseBody&amp;gt; CompletableFuture&amp;lt;P&amp;gt; submitRequest(String targetAddress, int targetPort, Request httpRequest, JavaType responseType) {&lt;br/&gt;
   		final ChannelFuture connectFuture = bootstrap.connect(targetAddress, targetPort);&lt;/p&gt;

&lt;p&gt;   		final CompletableFuture&amp;lt;Channel&amp;gt; channelFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;p&gt;   		connectFuture.addListener(&lt;br/&gt;
   			(ChannelFuture future) -&amp;gt; {&lt;br/&gt;
   				if (future.isSuccess()) &lt;/p&gt;
{
   					channelFuture.complete(future.channel());
   				}
&lt;p&gt; else &lt;/p&gt;
{
   					channelFuture.completeExceptionally(future.cause());
   				}
&lt;p&gt;   			});&lt;/p&gt;

&lt;p&gt;   		return channelFuture&lt;br/&gt;
   			.thenComposeAsync(&lt;br/&gt;
   				channel -&amp;gt; {&lt;br/&gt;
   					ClientHandler handler = channel.pipeline().get(ClientHandler.class);&lt;br/&gt;
   					CompletableFuture&amp;lt;JsonResponse&amp;gt; future = handler.getJsonFuture();&lt;br/&gt;
   					try &lt;/p&gt;
{
   						httpRequest.writeTo(channel);
   					}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
   						return FutureUtils.completedExceptionally(new FlinkException(&quot;Could not write request.&quot;, e));
   					}
&lt;p&gt;   					return future;&lt;br/&gt;
   				},&lt;br/&gt;
   				executor)&lt;br/&gt;
   			.thenComposeAsync(&lt;br/&gt;
   				(JsonResponse rawResponse) -&amp;gt; parseResponse(rawResponse, responseType),&lt;br/&gt;
   executor);&lt;br/&gt;
   ```&lt;/p&gt;

&lt;p&gt;   What happens if the client is shutdown, before the `thenComposeAsync` portions have been run? Then the channelFuture is completedExceptionally by the listener; and then subsequent stages aren&apos;t executed?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16628873" author="githubbot" created="Wed, 26 Sep 2018 14:41:36 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220592386&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220592386&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestClientTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -89,7 +91,78 @@ public void testInvalidVersionRejection() throws Exception {&lt;br/&gt;
 		} catch (IllegalArgumentException e) &lt;/p&gt;
{
 			// expected
 		}
&lt;p&gt;+	}&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the remote connection closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testConnectionClosedHandling() throws Exception {&lt;br/&gt;
+		final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+		final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+		final int targetPort = serverSocket.getLocalPort();&lt;br/&gt;
+&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;br/&gt;
+				targetAddress,&lt;br/&gt;
+				targetPort,&lt;br/&gt;
+				new TestMessageHeaders(),&lt;br/&gt;
+				EmptyMessageParameters.getInstance(),&lt;br/&gt;
+				EmptyRequestBody.getInstance(),&lt;br/&gt;
+				Collections.emptyList());&lt;br/&gt;
+&lt;br/&gt;
+			// establish connection&lt;br/&gt;
+			final Socket connectionSocket = serverSocket.accept();&lt;br/&gt;
+&lt;br/&gt;
+			// close connection&lt;br/&gt;
+			connectionSocket.close();&lt;br/&gt;
+&lt;br/&gt;
+			try &lt;/p&gt;
{
+				responseFuture.get();
+			} catch (ExecutionException ee) {
+				assertThat(ExceptionUtils.findThrowable(ee, ConnectionClosedException.class).isPresent(), is(true));
+			}&lt;br/&gt;
+		} finally {
+			serverSocket.close();
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the client closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testRestClientClosedHandling() throws Exception {&lt;br/&gt;
+		final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+		final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+		final int targetPort = serverSocket.getLocalPort();&lt;br/&gt;
+		Socket connectionSocket = null;&lt;br/&gt;
+&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;br/&gt;
+				targetAddress,&lt;br/&gt;
+				targetPort,&lt;br/&gt;
+				new TestMessageHeaders(),&lt;br/&gt;
+				EmptyMessageParameters.getInstance(),&lt;br/&gt;
+				EmptyRequestBody.getInstance(),&lt;br/&gt;
+				Collections.emptyList());&lt;br/&gt;
+&lt;br/&gt;
+			// establish connection&lt;br/&gt;
+			connectionSocket = serverSocket.accept();&lt;br/&gt;
+&lt;br/&gt;
+			restClient.close();&lt;br/&gt;
+&lt;br/&gt;
+			try {+				responseFuture.get();+			}
&lt;p&gt; catch (ExecutionException ee) {&lt;br/&gt;
+				assertThat(ExceptionUtils.findThrowable(ee, ConnectionClosedException.class).isPresent(), is(true));&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   yes, there were actually a bunch of related problems: Channel inactivity and not initialized pipeline.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16628878" author="githubbot" created="Wed, 26 Sep 2018 14:44:54 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220593811&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220593811&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestClientTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -89,7 +91,78 @@ public void testInvalidVersionRejection() throws Exception {&lt;br/&gt;
 		} catch (IllegalArgumentException e) &lt;/p&gt;
{
 			// expected
 		}
&lt;p&gt;+	}&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the remote connection closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testConnectionClosedHandling() throws Exception {&lt;br/&gt;
+		final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+		final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+		final int targetPort = serverSocket.getLocalPort();&lt;br/&gt;
+&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;br/&gt;
+				targetAddress,&lt;br/&gt;
+				targetPort,&lt;br/&gt;
+				new TestMessageHeaders(),&lt;br/&gt;
+				EmptyMessageParameters.getInstance(),&lt;br/&gt;
+				EmptyRequestBody.getInstance(),&lt;br/&gt;
+				Collections.emptyList());&lt;br/&gt;
+&lt;br/&gt;
+			// establish connection&lt;br/&gt;
+			final Socket connectionSocket = serverSocket.accept();&lt;br/&gt;
+&lt;br/&gt;
+			// close connection&lt;br/&gt;
+			connectionSocket.close();&lt;br/&gt;
+&lt;br/&gt;
+			try &lt;/p&gt;
{
+				responseFuture.get();
+			}
&lt;p&gt; catch (ExecutionException ee) &lt;/p&gt;
{
+				assertThat(ExceptionUtils.findThrowable(ee, ConnectionClosedException.class).isPresent(), is(true));
+			}
&lt;p&gt;+		} finally &lt;/p&gt;
{
+			serverSocket.close();
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the client closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testRestClientClosedHandling() throws Exception {&lt;br/&gt;
+		final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+		final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+		final int targetPort = serverSocket.getLocalPort();&lt;br/&gt;
+		Socket connectionSocket = null;&lt;br/&gt;
+&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I think this situation is fine, because an exceptionally completed future won&apos;t trigger the executions of the async stages. Instead it will directly fail the returned future.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16628900" author="githubbot" created="Wed, 26 Sep 2018 14:58:44 +0000"  >&lt;p&gt;tillrohrmann commented on issue #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#issuecomment-424748204&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#issuecomment-424748204&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Thanks for the first review @zentol. I actually added two more commits which handle the idleness of connections and a problem which occurred in tests that the channel pipeline was not properly initialized. These commits would also need a review.&lt;/p&gt;

&lt;p&gt;   I&apos;m not 100% sure about the default value for the `IDLENESS_TIMEOUT` (60s).&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16629096" author="githubbot" created="Wed, 26 Sep 2018 16:40:10 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220638812&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220638812&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestClientTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -89,7 +91,78 @@ public void testInvalidVersionRejection() throws Exception {&lt;br/&gt;
 		} catch (IllegalArgumentException e) &lt;/p&gt;
{
 			// expected
 		}
&lt;p&gt;+	}&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the remote connection closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testConnectionClosedHandling() throws Exception {&lt;br/&gt;
+		final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+		final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+		final int targetPort = serverSocket.getLocalPort();&lt;br/&gt;
+&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;br/&gt;
+				targetAddress,&lt;br/&gt;
+				targetPort,&lt;br/&gt;
+				new TestMessageHeaders(),&lt;br/&gt;
+				EmptyMessageParameters.getInstance(),&lt;br/&gt;
+				EmptyRequestBody.getInstance(),&lt;br/&gt;
+				Collections.emptyList());&lt;br/&gt;
+&lt;br/&gt;
+			// establish connection&lt;br/&gt;
+			final Socket connectionSocket = serverSocket.accept();&lt;br/&gt;
+&lt;br/&gt;
+			// close connection&lt;br/&gt;
+			connectionSocket.close();&lt;br/&gt;
+&lt;br/&gt;
+			try &lt;/p&gt;
{
+				responseFuture.get();
+			}
&lt;p&gt; catch (ExecutionException ee) &lt;/p&gt;
{
+				assertThat(ExceptionUtils.findThrowable(ee, ConnectionClosedException.class).isPresent(), is(true));
+			}
&lt;p&gt;+		} finally &lt;/p&gt;
{
+			serverSocket.close();
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the client closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testRestClientClosedHandling() throws Exception {&lt;br/&gt;
+		final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+		final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+		final int targetPort = serverSocket.getLocalPort();&lt;br/&gt;
+		Socket connectionSocket = null;&lt;br/&gt;
+&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   but it does fail with a different exception, no? although from a user-perspective the same issue happened.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16629119" author="githubbot" created="Wed, 26 Sep 2018 16:54:26 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220642450&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220642450&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -339,12 +338,26 @@ private static Request createRequest(String targetAddress, String targetUrl, Htt&lt;br/&gt;
 			.thenComposeAsync(&lt;br/&gt;
 				channel -&amp;gt; {&lt;br/&gt;
 					ClientHandler handler = channel.pipeline().get(ClientHandler.class);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompletableFuture&amp;lt;JsonResponse&amp;gt; future = handler.getJsonFuture();&lt;br/&gt;
+&lt;br/&gt;
+					CompletableFuture&amp;lt;JsonResponse&amp;gt; future;&lt;br/&gt;
+					boolean success = false;&lt;br/&gt;
+&lt;br/&gt;
 					try {&lt;/li&gt;
	&lt;li&gt;httpRequest.writeTo(channel);&lt;br/&gt;
+						if (handler == null) 
{
+							throw new IOException(&quot;Netty pipeline was not properly initialized.&quot;);
+						}
&lt;p&gt; else &lt;/p&gt;
{
+							httpRequest.writeTo(channel);
+							future = handler.getJsonFuture();
+							success = true;
+						}
&lt;p&gt; 					} catch (IOException e) {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   We should catch all exceptions here, then this issue wouldn&apos;t have occurred in the first place.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16629120" author="githubbot" created="Wed, 26 Sep 2018 16:54:26 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220642737&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220642737&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -339,12 +338,26 @@ private static Request createRequest(String targetAddress, String targetUrl, Htt&lt;br/&gt;
 			.thenComposeAsync(&lt;br/&gt;
 				channel -&amp;gt; {&lt;br/&gt;
 					ClientHandler handler = channel.pipeline().get(ClientHandler.class);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompletableFuture&amp;lt;JsonResponse&amp;gt; future = handler.getJsonFuture();&lt;br/&gt;
+&lt;br/&gt;
+					CompletableFuture&amp;lt;JsonResponse&amp;gt; future;&lt;br/&gt;
+					boolean success = false;&lt;br/&gt;
+&lt;br/&gt;
 					try {&lt;/li&gt;
	&lt;li&gt;httpRequest.writeTo(channel);&lt;br/&gt;
+						if (handler == null) 
{
+							throw new IOException(&quot;Netty pipeline was not properly initialized.&quot;);
+						}
&lt;p&gt; else &lt;/p&gt;
{
+							httpRequest.writeTo(channel);
+							future = handler.getJsonFuture();
+							success = true;
+						}
&lt;p&gt; 					} catch (IOException e) &lt;/p&gt;
{
-						return FutureUtils.completedExceptionally(new FlinkException(&quot;Could not write request.&quot;, e));
+						future = FutureUtils.completedExceptionally(new ConnectionException(&quot;Could not write request.&quot;, e));
+					}
&lt;p&gt; finally {&lt;br/&gt;
+						if (!success) {&lt;br/&gt;
+							channel.close();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   why aren&apos;t we closing the channel in both cases? Not being initialized &lt;em&gt;properly&lt;/em&gt; doesn&apos;t necessarily mean that there&apos;s nothing to clean up.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16629121" author="githubbot" created="Wed, 26 Sep 2018 16:54:26 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220642544&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220642544&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -339,12 +338,26 @@ private static Request createRequest(String targetAddress, String targetUrl, Htt&lt;br/&gt;
 			.thenComposeAsync(&lt;br/&gt;
 				channel -&amp;gt; {&lt;br/&gt;
 					ClientHandler handler = channel.pipeline().get(ClientHandler.class);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompletableFuture&amp;lt;JsonResponse&amp;gt; future = handler.getJsonFuture();&lt;br/&gt;
+&lt;br/&gt;
+					CompletableFuture&amp;lt;JsonResponse&amp;gt; future;&lt;br/&gt;
+					boolean success = false;&lt;br/&gt;
+&lt;br/&gt;
 					try {&lt;/li&gt;
	&lt;li&gt;httpRequest.writeTo(channel);&lt;br/&gt;
+						if (handler == null) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Do we know when/why this happens?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16630474" author="githubbot" created="Thu, 27 Sep 2018 14:02:30 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220935608&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220935608&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -339,12 +338,26 @@ private static Request createRequest(String targetAddress, String targetUrl, Htt&lt;br/&gt;
 			.thenComposeAsync(&lt;br/&gt;
 				channel -&amp;gt; {&lt;br/&gt;
 					ClientHandler handler = channel.pipeline().get(ClientHandler.class);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompletableFuture&amp;lt;JsonResponse&amp;gt; future = handler.getJsonFuture();&lt;br/&gt;
+&lt;br/&gt;
+					CompletableFuture&amp;lt;JsonResponse&amp;gt; future;&lt;br/&gt;
+					boolean success = false;&lt;br/&gt;
+&lt;br/&gt;
 					try {&lt;/li&gt;
	&lt;li&gt;httpRequest.writeTo(channel);&lt;br/&gt;
+						if (handler == null) 
{
+							throw new IOException(&quot;Netty pipeline was not properly initialized.&quot;);
+						}
&lt;p&gt; else &lt;/p&gt;
{
+							httpRequest.writeTo(channel);
+							future = handler.getJsonFuture();
+							success = true;
+						}
&lt;p&gt; 					} catch (IOException e) {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   We retry the send operation if we see an `IOException`. If any other exception occurs (e.g. `RuntimeException`), this might indicate that there is another problem where we don&apos;t want to retry. Therefore, I think it is ok to only catch the `IOException`. The request will also be failed if we see a different exception.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16630476" author="githubbot" created="Thu, 27 Sep 2018 14:03:40 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220936090&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220936090&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -339,12 +338,26 @@ private static Request createRequest(String targetAddress, String targetUrl, Htt&lt;br/&gt;
 			.thenComposeAsync(&lt;br/&gt;
 				channel -&amp;gt; {&lt;br/&gt;
 					ClientHandler handler = channel.pipeline().get(ClientHandler.class);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompletableFuture&amp;lt;JsonResponse&amp;gt; future = handler.getJsonFuture();&lt;br/&gt;
+&lt;br/&gt;
+					CompletableFuture&amp;lt;JsonResponse&amp;gt; future;&lt;br/&gt;
+					boolean success = false;&lt;br/&gt;
+&lt;br/&gt;
 					try {&lt;/li&gt;
	&lt;li&gt;httpRequest.writeTo(channel);&lt;br/&gt;
+						if (handler == null) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   No not really. It happened from time to time when running the `RestClientTest#testConnectionClosedHandling` in a loop. It might be a Netty bug but we should guard against this in order to harden the test case. I don&apos;t think that something bad happens if we fail the request with an `IOException` here.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16630478" author="githubbot" created="Thu, 27 Sep 2018 14:05:09 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220936630&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220936630&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -339,12 +338,26 @@ private static Request createRequest(String targetAddress, String targetUrl, Htt&lt;br/&gt;
 			.thenComposeAsync(&lt;br/&gt;
 				channel -&amp;gt; {&lt;br/&gt;
 					ClientHandler handler = channel.pipeline().get(ClientHandler.class);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompletableFuture&amp;lt;JsonResponse&amp;gt; future = handler.getJsonFuture();&lt;br/&gt;
+&lt;br/&gt;
+					CompletableFuture&amp;lt;JsonResponse&amp;gt; future;&lt;br/&gt;
+					boolean success = false;&lt;br/&gt;
+&lt;br/&gt;
 					try {&lt;/li&gt;
	&lt;li&gt;httpRequest.writeTo(channel);&lt;br/&gt;
+						if (handler == null) 
{
+							throw new IOException(&quot;Netty pipeline was not properly initialized.&quot;);
+						}
&lt;p&gt; else &lt;/p&gt;
{
+							httpRequest.writeTo(channel);
+							future = handler.getJsonFuture();
+							success = true;
+						}
&lt;p&gt; 					} catch (IOException e) &lt;/p&gt;
{
-						return FutureUtils.completedExceptionally(new FlinkException(&quot;Could not write request.&quot;, e));
+						future = FutureUtils.completedExceptionally(new ConnectionException(&quot;Could not write request.&quot;, e));
+					}
&lt;p&gt; finally {&lt;br/&gt;
+						if (!success) {&lt;br/&gt;
+							channel.close();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   We keep the channel open if we managed to send the request to the remote endpoint, because we expect an answer. In all other cases (`!success`) we should close it, because we cannot expect something to return.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16630479" author="githubbot" created="Thu, 27 Sep 2018 14:08:01 +0000"  >&lt;p&gt;tillrohrmann commented on issue #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#issuecomment-425106479&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#issuecomment-425106479&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Thanks again for the review @zentol. I had to add the `IdleStateHandler` because it happened sometimes in `RestClientTest#testConnectionClosedHandling` that the channel would not be closed by Netty after we closed the server socket. So sometimes Netty detects such an event and then calls `channelInactive` and sometimes not. For the latter case, we need to monitor the connection for idleness.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16630480" author="githubbot" created="Thu, 27 Sep 2018 14:08:24 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#discussion_r220937991&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#discussion_r220937991&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -339,12 +338,26 @@ private static Request createRequest(String targetAddress, String targetUrl, Htt&lt;br/&gt;
 			.thenComposeAsync(&lt;br/&gt;
 				channel -&amp;gt; {&lt;br/&gt;
 					ClientHandler handler = channel.pipeline().get(ClientHandler.class);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompletableFuture&amp;lt;JsonResponse&amp;gt; future = handler.getJsonFuture();&lt;br/&gt;
+&lt;br/&gt;
+					CompletableFuture&amp;lt;JsonResponse&amp;gt; future;&lt;br/&gt;
+					boolean success = false;&lt;br/&gt;
+&lt;br/&gt;
 					try {&lt;/li&gt;
	&lt;li&gt;httpRequest.writeTo(channel);&lt;br/&gt;
+						if (handler == null) 
{
+							throw new IOException(&quot;Netty pipeline was not properly initialized.&quot;);
+						}
&lt;p&gt; else &lt;/p&gt;
{
+							httpRequest.writeTo(channel);
+							future = handler.getJsonFuture();
+							success = true;
+						}
&lt;p&gt; 					} catch (IOException e) &lt;/p&gt;
{
-						return FutureUtils.completedExceptionally(new FlinkException(&quot;Could not write request.&quot;, e));
+						future = FutureUtils.completedExceptionally(new ConnectionException(&quot;Could not write request.&quot;, e));
+					}
&lt;p&gt; finally {&lt;br/&gt;
+						if (!success) {&lt;br/&gt;
+							channel.close();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   ah of course &#128077; &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16630530" author="githubbot" created="Thu, 27 Sep 2018 14:33:55 +0000"  >&lt;p&gt;zentol commented on issue #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#issuecomment-425115999&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#issuecomment-425115999&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   urgh, well that&apos;s unfortunate. We may want to increase the idle timeout to a larger value though (maybe 5 minutes?), as it effectively is an upper limit for the timeout that a user may specify.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16630601" author="githubbot" created="Thu, 27 Sep 2018 15:17:23 +0000"  >&lt;p&gt;tillrohrmann commented on issue #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763#issuecomment-425132571&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763#issuecomment-425132571&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Yes, I will increase the idleness timeout to 5 minutes. Merging this PR then.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16631610" author="till.rohrmann" created="Fri, 28 Sep 2018 09:37:01 +0000"  >&lt;p&gt;Fixed via&lt;br/&gt;
1.7.0:&lt;br/&gt;
559b8f14ea9cc873a64f9c7954951882444693ac&lt;br/&gt;
28591f321f90d713b81b4e4428da12cf22109469&lt;br/&gt;
08e25db3326ebf9b9acb022dc5644528d44882ae&lt;br/&gt;
1.6.2:&lt;br/&gt;
91639923e2a8f4dde271b90d3917b1b2e8d6878a&lt;br/&gt;
8a046177dbfff63b3a9285885ad70f85c22c99ca&lt;br/&gt;
c634277c113b6e96a9031ec87805fc5392461458&lt;br/&gt;
1.5.5:&lt;br/&gt;
a7b89bbf22162a61b8b540388fb7994c53cd0b00&lt;br/&gt;
ea01369801af9d4968c559e2864d97d85414ca78&lt;br/&gt;
ce08427e0c5a2f374c361db4476d74faeebf219d&lt;/p&gt;</comment>
                            <comment id="16631611" author="githubbot" created="Fri, 28 Sep 2018 09:37:20 +0000"  >&lt;p&gt;tillrohrmann closed pull request #6763: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10415&quot; title=&quot;RestClient does not react to lost connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10415&quot;&gt;&lt;del&gt;FLINK-10415&lt;/del&gt;&lt;/a&gt; Fail response future if connection closes in RestClient&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6763&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6763&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/docs/_includes/generated/rest_configuration.html b/docs/_includes/generated/rest_configuration.html&lt;br/&gt;
index 1de41654eb7..25da9cfb067 100644&lt;br/&gt;
&amp;#8212; a/docs/_includes/generated/rest_configuration.html&lt;br/&gt;
+++ b/docs/_includes/generated/rest_configuration.html&lt;br/&gt;
@@ -32,6 +32,11 @@&lt;br/&gt;
             &amp;lt;td style=&quot;word-wrap: break-word;&quot;&amp;gt;15000&amp;lt;/td&amp;gt;&lt;br/&gt;
             &amp;lt;td&amp;gt;The maximum time in ms for the client to establish a TCP connection.&amp;lt;/td&amp;gt;&lt;br/&gt;
         &amp;lt;/tr&amp;gt;&lt;br/&gt;
+        &amp;lt;tr&amp;gt;&lt;br/&gt;
+            &amp;lt;td&amp;gt;&amp;lt;h5&amp;gt;rest.idleness-timeout&amp;lt;/h5&amp;gt;&amp;lt;/td&amp;gt;&lt;br/&gt;
+            &amp;lt;td style=&quot;word-wrap: break-word;&quot;&amp;gt;300000&amp;lt;/td&amp;gt;&lt;br/&gt;
+            &amp;lt;td&amp;gt;The maximum time in ms for a connection to stay idle before failing.&amp;lt;/td&amp;gt;&lt;br/&gt;
+        &amp;lt;/tr&amp;gt;&lt;br/&gt;
         &amp;lt;tr&amp;gt;&lt;br/&gt;
             &amp;lt;td&amp;gt;&amp;lt;h5&amp;gt;rest.port&amp;lt;/h5&amp;gt;&amp;lt;/td&amp;gt;&lt;br/&gt;
             &amp;lt;td style=&quot;word-wrap: break-word;&quot;&amp;gt;8081&amp;lt;/td&amp;gt;&lt;br/&gt;
diff --git a/flink-core/src/main/java/org/apache/flink/configuration/RestOptions.java b/flink-core/src/main/java/org/apache/flink/configuration/RestOptions.java&lt;br/&gt;
index 3c2415828d6..c834483d7d0 100644&lt;br/&gt;
&amp;#8212; a/flink-core/src/main/java/org/apache/flink/configuration/RestOptions.java&lt;br/&gt;
+++ b/flink-core/src/main/java/org/apache/flink/configuration/RestOptions.java&lt;br/&gt;
@@ -93,6 +93,14 @@&lt;br/&gt;
 			.defaultValue(15_000L)&lt;br/&gt;
 			.withDescription(&quot;The maximum time in ms for the client to establish a TCP connection.&quot;);&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * The maximum time in ms for a connection to stay idle before failing.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static final ConfigOption&amp;lt;Long&amp;gt; IDLENESS_TIMEOUT =&lt;br/&gt;
+		key(&quot;rest.idleness-timeout&quot;)&lt;br/&gt;
+			.defaultValue(5L * 60L * 1_000L) // 5 minutes&lt;br/&gt;
+			.withDescription(&quot;The maximum time in ms for a connection to stay idle before failing.&quot;);&lt;br/&gt;
+&lt;br/&gt;
 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The maximum content length that the server will handle.&lt;br/&gt;
 	 */&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/ConnectionClosedException.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/ConnectionClosedException.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..339a5493fc3
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;/dev/null&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/ConnectionClosedException.java&lt;br/&gt;
@@ -0,0 +1,39 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Exception which is thrown if the 
{@link RestClient} detects that a connection&lt;br/&gt;
+ * was closed.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ConnectionClosedException extends ConnectionException {&lt;br/&gt;
+	private static final long serialVersionUID = 3802002501688542472L;&lt;br/&gt;
+&lt;br/&gt;
+	public ConnectionClosedException(String message) {
+		super(message);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	public ConnectionClosedException(String message, Throwable cause) {
+		super(message, cause);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	public ConnectionClosedException(Throwable cause) {
+		super(cause);
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/ConnectionException.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/ConnectionException.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..d92c643a0fc&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/ConnectionException.java&lt;br/&gt;
@@ -0,0 +1,42 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Base class for all connection related exception thrown by the&lt;br/&gt;
+ * {@link RestClient}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ConnectionException extends IOException &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {++	private static final long serialVersionUID = -8483133957344173698L;++	public ConnectionException(String message) {
+		super(message);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	public ConnectionException(String message, Throwable cause) {
+		super(message, cause);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	public ConnectionException(Throwable cause) {
+		super(cause);
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/ConnectionIdleException.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/ConnectionIdleException.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..96c335df53a&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/ConnectionIdleException.java&lt;br/&gt;
@@ -0,0 +1,40 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Exception which is thrown by the {@link RestClient} if a connection&lt;br/&gt;
+ * becomes idle.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ConnectionIdleException extends ConnectionException {&lt;br/&gt;
+&lt;br/&gt;
+	private static final long serialVersionUID = 5103778538635217293L;&lt;br/&gt;
+&lt;br/&gt;
+	public ConnectionIdleException(String message) {+		super(message);+	}++	public ConnectionIdleException(String message, Throwable cause) {
+		super(message, cause);
+	}++	public ConnectionIdleException(Throwable cause) {
+		super(cause);
+	}+}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java&lt;br/&gt;
index a8557496b08..d4c5e880bc7 100644&lt;/p&gt;&lt;/li&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClient.java&lt;br/&gt;
@@ -33,7 +33,8 @@&lt;br/&gt;
 import org.apache.flink.runtime.rest.util.RestMapperUtils;&lt;br/&gt;
 import org.apache.flink.runtime.rest.versioning.RestAPIVersion;&lt;br/&gt;
 import org.apache.flink.runtime.util.ExecutorThreadFactory;&lt;br/&gt;
-import org.apache.flink.util.FlinkException;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
+import org.apache.flink.util.ExceptionUtils;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonParser;&lt;br/&gt;
@@ -71,6 +72,8 @@&lt;br/&gt;
 import org.apache.flink.shaded.netty4.io.netty.handler.codec.http.multipart.MemoryAttribute;&lt;br/&gt;
 import org.apache.flink.shaded.netty4.io.netty.handler.ssl.SslHandler;&lt;br/&gt;
 import org.apache.flink.shaded.netty4.io.netty.handler.stream.ChunkedWriteHandler;&lt;br/&gt;
+import org.apache.flink.shaded.netty4.io.netty.handler.timeout.IdleStateEvent;&lt;br/&gt;
+import org.apache.flink.shaded.netty4.io.netty.handler.timeout.IdleStateHandler;&lt;/p&gt;

&lt;p&gt; import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
@@ -86,6 +89,7 @@&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;br/&gt;
 import java.util.concurrent.Executor;&lt;br/&gt;
 import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
 import java.util.stream.Collectors;&lt;/p&gt;

&lt;p&gt; import static org.apache.flink.shaded.netty4.io.netty.handler.codec.http.HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE;&lt;br/&gt;
@@ -93,7 +97,7 @@&lt;br/&gt;
 /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;This client is the counter-part to the 
{@link RestServerEndpoint}
&lt;p&gt;.&lt;br/&gt;
  */&lt;br/&gt;
-public class RestClient {&lt;br/&gt;
+public class RestClient implements AutoCloseableAsync {&lt;br/&gt;
 	private static final Logger LOG = LoggerFactory.getLogger(RestClient.class);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	private static final ObjectMapper objectMapper = RestMapperUtils.getStrictObjectMapper();&lt;br/&gt;
@@ -103,24 +107,35 @@&lt;/p&gt;

&lt;p&gt; 	private final Bootstrap bootstrap;&lt;/p&gt;

&lt;p&gt;+	private final CompletableFuture&amp;lt;Void&amp;gt; terminationFuture;&lt;br/&gt;
+&lt;br/&gt;
+	private final AtomicBoolean isRunning = new AtomicBoolean(true);&lt;br/&gt;
+&lt;br/&gt;
 	public RestClient(RestClientConfiguration configuration, Executor executor) {&lt;br/&gt;
 		Preconditions.checkNotNull(configuration);&lt;br/&gt;
 		this.executor = Preconditions.checkNotNull(executor);&lt;br/&gt;
+		this.terminationFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;p&gt; 		final SSLEngineFactory sslEngineFactory = configuration.getSslEngineFactory();&lt;br/&gt;
 		ChannelInitializer&amp;lt;SocketChannel&amp;gt; initializer = new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {&lt;br/&gt;
 			@Override&lt;br/&gt;
 			protected void initChannel(SocketChannel socketChannel) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// SSL should be the first handler in the pipeline&lt;/li&gt;
	&lt;li&gt;if (sslEngineFactory != null) 
{
-					socketChannel.pipeline().addLast(&quot;ssl&quot;, new SslHandler(sslEngineFactory.createSSLEngine()));
-				}
&lt;p&gt;+				try {&lt;br/&gt;
+					// SSL should be the first handler in the pipeline&lt;br/&gt;
+					if (sslEngineFactory != null) &lt;/p&gt;
{
+						socketChannel.pipeline().addLast(&quot;ssl&quot;, new SslHandler(sslEngineFactory.createSSLEngine()));
+					}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;socketChannel.pipeline()&lt;/li&gt;
	&lt;li&gt;.addLast(new HttpClientCodec())&lt;/li&gt;
	&lt;li&gt;.addLast(new HttpObjectAggregator(configuration.getMaxContentLength()))&lt;/li&gt;
	&lt;li&gt;.addLast(new ChunkedWriteHandler()) // required for multipart-requests&lt;/li&gt;
	&lt;li&gt;.addLast(new ClientHandler());&lt;br/&gt;
+					socketChannel.pipeline()&lt;br/&gt;
+						.addLast(new HttpClientCodec())&lt;br/&gt;
+						.addLast(new HttpObjectAggregator(configuration.getMaxContentLength()))&lt;br/&gt;
+						.addLast(new ChunkedWriteHandler()) // required for multipart-requests&lt;br/&gt;
+						.addLast(new IdleStateHandler(configuration.getIdlenessTimeout(), configuration.getIdlenessTimeout(), configuration.getIdlenessTimeout(), TimeUnit.MILLISECONDS))&lt;br/&gt;
+						.addLast(new ClientHandler());&lt;br/&gt;
+				} catch (Throwable t) 
{
+					t.printStackTrace();
+					ExceptionUtils.rethrow(t);
+				}
&lt;p&gt; 			}&lt;br/&gt;
 		};&lt;br/&gt;
 		NioEventLoopGroup group = new NioEventLoopGroup(1, new ExecutorThreadFactory(&quot;flink-rest-client-netty&quot;));&lt;br/&gt;
@@ -135,30 +150,42 @@ protected void initChannel(SocketChannel socketChannel) &lt;/p&gt;
{
 		LOG.info(&quot;Rest client endpoint started.&quot;);
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	@Override&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() &lt;/p&gt;
{
+		return shutdownInternally(Time.seconds(10L));
+	}
&lt;p&gt;+&lt;br/&gt;
 	public void shutdown(Time timeout) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LOG.info(&quot;Shutting down rest endpoint.&quot;);&lt;/li&gt;
	&lt;li&gt;CompletableFuture&amp;lt;?&amp;gt; groupFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;if (bootstrap != null) {&lt;/li&gt;
	&lt;li&gt;if (bootstrap.group() != null) {&lt;/li&gt;
	&lt;li&gt;bootstrap.group().shutdownGracefully(0L, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)&lt;/li&gt;
	&lt;li&gt;.addListener(finished -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;if (finished.isSuccess()) 
{
-							groupFuture.complete(null);
-						}
&lt;p&gt; else &lt;/p&gt;
{
-							groupFuture.completeExceptionally(finished.cause());
-						}&lt;/li&gt;
	&lt;li&gt;});&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
+		final CompletableFuture&amp;lt;Void&amp;gt; shutDownFuture = shutdownInternally(timeout);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		try &lt;/p&gt;
{
-			groupFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS);
+			shutDownFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS);
 			LOG.info(&quot;Rest endpoint shutdown complete.&quot;);
 		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
 			LOG.warn(&quot;Rest endpoint shutdown failed.&quot;, e);
 		}
&lt;p&gt; 	}&lt;/p&gt;

&lt;p&gt;+	private CompletableFuture&amp;lt;Void&amp;gt; shutdownInternally(Time timeout) {&lt;br/&gt;
+		if (isRunning.compareAndSet(true, false)) {&lt;br/&gt;
+			LOG.info(&quot;Shutting down rest endpoint.&quot;);&lt;br/&gt;
+&lt;br/&gt;
+			if (bootstrap != null) {&lt;br/&gt;
+				if (bootstrap.group() != null) {&lt;br/&gt;
+					bootstrap.group().shutdownGracefully(0L, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)&lt;br/&gt;
+						.addListener(finished -&amp;gt; {&lt;br/&gt;
+							if (finished.isSuccess()) &lt;/p&gt;
{
+								terminationFuture.complete(null);
+							}
&lt;p&gt; else &lt;/p&gt;
{
+								terminationFuture.completeExceptionally(finished.cause());
+							}
&lt;p&gt;+						});&lt;br/&gt;
+				}&lt;br/&gt;
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+		return terminationFuture;&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	public &amp;lt;M extends MessageHeaders&amp;lt;R, P, U&amp;gt;, U extends MessageParameters, R extends RequestBody, P extends ResponseBody&amp;gt; CompletableFuture&amp;lt;P&amp;gt; sendRequest(&lt;br/&gt;
 			String targetAddress,&lt;br/&gt;
 			int targetPort,&lt;br/&gt;
@@ -311,12 +338,26 @@ private static Request createRequest(String targetAddress, String targetUrl, Htt&lt;br/&gt;
 			.thenComposeAsync(&lt;br/&gt;
 				channel -&amp;gt; {&lt;br/&gt;
 					ClientHandler handler = channel.pipeline().get(ClientHandler.class);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompletableFuture&amp;lt;JsonResponse&amp;gt; future = handler.getJsonFuture();&lt;br/&gt;
+&lt;br/&gt;
+					CompletableFuture&amp;lt;JsonResponse&amp;gt; future;&lt;br/&gt;
+					boolean success = false;&lt;br/&gt;
+&lt;br/&gt;
 					try {&lt;/li&gt;
	&lt;li&gt;httpRequest.writeTo(channel);&lt;br/&gt;
+						if (handler == null) 
{
+							throw new IOException(&quot;Netty pipeline was not properly initialized.&quot;);
+						}
&lt;p&gt; else &lt;/p&gt;
{
+							httpRequest.writeTo(channel);
+							future = handler.getJsonFuture();
+							success = true;
+						}
&lt;p&gt; 					} catch (IOException e) &lt;/p&gt;
{
-						return FutureUtils.completedExceptionally(new FlinkException(&quot;Could not write request.&quot;, e));
+						future = FutureUtils.completedExceptionally(new ConnectionException(&quot;Could not write request.&quot;, e));
+					}
&lt;p&gt; finally &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+						if (!success) {
+							channel.close();
+						} 					}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
 					return future;&lt;br/&gt;
 				},&lt;br/&gt;
 				executor)&lt;br/&gt;
@@ -428,6 +469,22 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) &lt;/p&gt;
{
 			ctx.close();
 		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+		@Override&lt;br/&gt;
+		public void channelInactive(ChannelHandlerContext ctx) &lt;/p&gt;
{
+			jsonFuture.completeExceptionally(new ConnectionClosedException(&quot;Channel became inactive.&quot;));
+			ctx.close();
+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {&lt;br/&gt;
+			if (evt instanceof IdleStateEvent) &lt;/p&gt;
{
+				jsonFuture.completeExceptionally(new ConnectionIdleException(&quot;Channel became idle.&quot;));
+				ctx.close();
+			}
&lt;p&gt; else &lt;/p&gt;
{
+				super.userEventTriggered(ctx, evt);
+			}
&lt;p&gt;+		}&lt;br/&gt;
+&lt;br/&gt;
 		@Override&lt;br/&gt;
 		public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable cause) {&lt;br/&gt;
 			if (cause instanceof TooLongFrameException) {&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClientConfiguration.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClientConfiguration.java&lt;br/&gt;
index e09f357ea74..b70b1f81ab3 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClientConfiguration.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestClientConfiguration.java&lt;br/&gt;
@@ -40,15 +40,19 @@&lt;/p&gt;

&lt;p&gt; 	private final long connectionTimeout;&lt;/p&gt;

&lt;p&gt;+	private final long idlenessTimeout;&lt;br/&gt;
+&lt;br/&gt;
 	private final int maxContentLength;&lt;/p&gt;

&lt;p&gt; 	private RestClientConfiguration(&lt;br/&gt;
 			@Nullable final SSLEngineFactory sslEngineFactory,&lt;br/&gt;
 			final long connectionTimeout,&lt;br/&gt;
+			final long idlenessTimeout,&lt;br/&gt;
 			final int maxContentLength) &lt;/p&gt;
{
 		checkArgument(maxContentLength &amp;gt; 0, &quot;maxContentLength must be positive, was: %d&quot;, maxContentLength);
 		this.sslEngineFactory = sslEngineFactory;
 		this.connectionTimeout = connectionTimeout;
+		this.idlenessTimeout = idlenessTimeout;
 		this.maxContentLength = maxContentLength;
 	}

&lt;p&gt;@@ -63,12 +67,19 @@ public SSLEngineFactory getSslEngineFactory() {&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @see RestOptions#CONNECTION_TIMEOUT&lt;br/&gt;
+	 * 
{@see RestOptions#CONNECTION_TIMEOUT}
&lt;p&gt;.&lt;br/&gt;
 	 */&lt;br/&gt;
 	public long getConnectionTimeout() &lt;/p&gt;
{
 		return connectionTimeout;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	/**&lt;br/&gt;
+	 * &lt;/p&gt;
{@see RestOptions#IDLENESS_TIMEOUT}
&lt;p&gt;.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public long getIdlenessTimeout() &lt;/p&gt;
{
+		return idlenessTimeout;
+	}
&lt;p&gt;+&lt;br/&gt;
 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns the max content length that the REST client endpoint could handle.&lt;br/&gt;
 	 *&lt;br/&gt;
@@ -102,8 +113,10 @@ public static RestClientConfiguration fromConfiguration(Configuration config) th&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final long connectionTimeout = config.getLong(RestOptions.CONNECTION_TIMEOUT);&lt;/p&gt;

&lt;p&gt;+		final long idlenessTimeout = config.getLong(RestOptions.IDLENESS_TIMEOUT);&lt;br/&gt;
+&lt;br/&gt;
 		int maxContentLength = config.getInteger(RestOptions.CLIENT_MAX_CONTENT_LENGTH);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return new RestClientConfiguration(sslEngineFactory, connectionTimeout, maxContentLength);&lt;br/&gt;
+		return new RestClientConfiguration(sslEngineFactory, connectionTimeout, idlenessTimeout, maxContentLength);&lt;br/&gt;
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestClientTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestClientTest.java&lt;br/&gt;
index 22cd6f62063..958cca14dd9 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestClientTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestClientTest.java&lt;br/&gt;
@@ -26,8 +26,10 @@&lt;br/&gt;
 import org.apache.flink.runtime.rest.messages.EmptyResponseBody;&lt;br/&gt;
 import org.apache.flink.runtime.rest.messages.MessageHeaders;&lt;br/&gt;
 import org.apache.flink.runtime.rest.versioning.RestAPIVersion;&lt;br/&gt;
+import org.apache.flink.runtime.testingUtils.TestingUtils;&lt;br/&gt;
 import org.apache.flink.util.ExceptionUtils;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
+import org.apache.flink.util.function.CheckedSupplier;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import org.apache.flink.shaded.netty4.io.netty.channel.ConnectTimeoutException;&lt;br/&gt;
 import org.apache.flink.shaded.netty4.io.netty.handler.codec.http.HttpResponseStatus;&lt;br/&gt;
@@ -35,10 +37,14 @@&lt;br/&gt;
 import org.junit.Assert;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+import java.io.IOException;&lt;br/&gt;
+import java.net.ServerSocket;&lt;br/&gt;
+import java.net.Socket;&lt;br/&gt;
 import java.util.Collections;&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;br/&gt;
 import java.util.concurrent.ExecutionException;&lt;br/&gt;
 import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.concurrent.TimeoutException;&lt;/p&gt;

&lt;p&gt; import static org.hamcrest.Matchers.containsString;&lt;br/&gt;
 import static org.hamcrest.Matchers.instanceOf;&lt;br/&gt;
@@ -51,12 +57,13 @@&lt;/p&gt;

&lt;p&gt; 	private static final String unroutableIp = &quot;10.255.255.1&quot;;&lt;/p&gt;

&lt;p&gt;+	private static final long TIMEOUT = 10L;&lt;br/&gt;
+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testConnectionTimeout() throws Exception {&lt;br/&gt;
 		final Configuration config = new Configuration();&lt;br/&gt;
 		config.setLong(RestOptions.CONNECTION_TIMEOUT, 1);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(config), Executors.directExecutor());&lt;/li&gt;
	&lt;li&gt;try {&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(config), Executors.directExecutor())) {&lt;br/&gt;
 			restClient.sendRequest(&lt;br/&gt;
 				unroutableIp,&lt;br/&gt;
 				80,&lt;br/&gt;
@@ -73,9 +80,7 @@ public void testConnectionTimeout() throws Exception {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	@Test&lt;br/&gt;
 	public void testInvalidVersionRejection() throws Exception {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), Executors.directExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;try {&lt;br/&gt;
+		try (final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), Executors.directExecutor())) {&lt;br/&gt;
 			CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; invalidVersionResponse = restClient.sendRequest(&lt;br/&gt;
 				unroutableIp,&lt;br/&gt;
 				80,&lt;br/&gt;
@@ -89,7 +94,104 @@ public void testInvalidVersionRejection() throws Exception {&lt;br/&gt;
 		} catch (IllegalArgumentException e) 
{
 			// expected
 		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the remote connection closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testConnectionClosedHandling() throws Exception {&lt;br/&gt;
+		final Configuration config = new Configuration();&lt;br/&gt;
+		config.setLong(RestOptions.IDLENESS_TIMEOUT, 5000L);&lt;br/&gt;
+		try (final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+			final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(config), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+&lt;br/&gt;
+			final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+			final int targetPort = serverSocket.getLocalPort();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+			// start server&lt;br/&gt;
+			final CompletableFuture&amp;lt;Socket&amp;gt; socketCompletableFuture = CompletableFuture.supplyAsync(CheckedSupplier.unchecked(serverSocket::accept));&lt;br/&gt;
+&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;br/&gt;
+				targetAddress,&lt;br/&gt;
+				targetPort,&lt;br/&gt;
+				new TestMessageHeaders(),&lt;br/&gt;
+				EmptyMessageParameters.getInstance(),&lt;br/&gt;
+				EmptyRequestBody.getInstance(),&lt;br/&gt;
+				Collections.emptyList());&lt;br/&gt;
+&lt;br/&gt;
+			Socket connectionSocket = null;&lt;br/&gt;
+&lt;br/&gt;
+			try &lt;/p&gt;
{
+				connectionSocket = socketCompletableFuture.get(TIMEOUT, TimeUnit.SECONDS);
+			} catch (TimeoutException ignored) {
+				// could not establish a server connection --&amp;gt; see that the response failed
+				socketCompletableFuture.cancel(true);
+			}&lt;br/&gt;
+&lt;br/&gt;
+			if (connectionSocket != null) {
+				// close connection
+				connectionSocket.close();
+			}&lt;br/&gt;
+&lt;br/&gt;
+			try {
+				responseFuture.get();
+			} catch (ExecutionException ee) {&lt;br/&gt;
+				if (!ExceptionUtils.findThrowable(ee, IOException.class).isPresent()) {
+					throw ee;
+				}&lt;br/&gt;
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that we fail the operation if the client closes.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testRestClientClosedHandling() throws Exception {&lt;br/&gt;
+		final Configuration config = new Configuration();&lt;br/&gt;
+		config.setLong(RestOptions.IDLENESS_TIMEOUT, 5000L);&lt;br/&gt;
+&lt;br/&gt;
+		Socket connectionSocket = null;&lt;br/&gt;
+&lt;br/&gt;
+		try (final ServerSocket serverSocket = new ServerSocket(0);&lt;br/&gt;
+			final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(config), TestingUtils.defaultExecutor())) {&lt;br/&gt;
+&lt;br/&gt;
+			final String targetAddress = &quot;localhost&quot;;&lt;br/&gt;
+			final int targetPort = serverSocket.getLocalPort();&lt;br/&gt;
+&lt;br/&gt;
+			// start server&lt;br/&gt;
+			final CompletableFuture&amp;lt;Socket&amp;gt; socketCompletableFuture = CompletableFuture.supplyAsync(CheckedSupplier.unchecked(serverSocket::accept));&lt;br/&gt;
+&lt;br/&gt;
+			final CompletableFuture&amp;lt;EmptyResponseBody&amp;gt; responseFuture = restClient.sendRequest(&lt;br/&gt;
+				targetAddress,&lt;br/&gt;
+				targetPort,&lt;br/&gt;
+				new TestMessageHeaders(),&lt;br/&gt;
+				EmptyMessageParameters.getInstance(),&lt;br/&gt;
+				EmptyRequestBody.getInstance(),&lt;br/&gt;
+				Collections.emptyList());&lt;br/&gt;
+&lt;br/&gt;
+			try {+				connectionSocket = socketCompletableFuture.get(TIMEOUT, TimeUnit.SECONDS);+			}
&lt;p&gt; catch (TimeoutException ignored) &lt;/p&gt;
{
+				// could not establish a server connection --&amp;gt; see that the response failed
+				socketCompletableFuture.cancel(true);
+			}
&lt;p&gt;+&lt;br/&gt;
+			restClient.close();&lt;br/&gt;
+&lt;br/&gt;
+			try &lt;/p&gt;
{
+				responseFuture.get();
+			}
&lt;p&gt; catch (ExecutionException ee) {&lt;br/&gt;
+				if (!ExceptionUtils.findThrowable(ee, IOException.class).isPresent()) &lt;/p&gt;
{
+					throw ee;
+				}
&lt;p&gt;+			}&lt;br/&gt;
+		} finally {&lt;br/&gt;
+			if (connectionSocket != null) &lt;/p&gt;
{
+				connectionSocket.close();
+			}
&lt;p&gt;+		}&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt; 	private static class TestMessageHeaders implements MessageHeaders&amp;lt;EmptyRequestBody, EmptyResponseBody, EmptyMessageParameters&amp;gt; {&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 7 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3ygcf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>