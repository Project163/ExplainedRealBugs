<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:30:41 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-7153] Eager Scheduling can&apos;t allocate source for ExecutionGraph correctly</title>
                <link>https://issues.apache.org/jira/browse/FLINK-7153</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;The ExecutionGraph.scheduleEager() function allocate for ExecutionJobVertex one by one via calling ExecutionJobVertex.allocateResourcesForAll(), here is two problem about it:&lt;/p&gt;

&lt;p&gt;1. The ExecutionVertex.getPreferredLocationsBasedOnInputs will always return empty, cause `sourceSlot` always be null until `ExectionVertex` has been deployed via &apos;Execution.deployToSlot()&apos;. So allocate resource base on prefered location can&apos;t work correctly, we need to set the slot info for `Execution` as soon as Execution.allocateSlotForExecution() called successfully?&lt;/p&gt;

&lt;p&gt;2. Current allocate strategy can&apos;t allocate the slot optimize.  Here is the test case:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;JobVertex v1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; JobVertex(&lt;span class=&quot;code-quote&quot;&gt;&quot;v1&quot;&lt;/span&gt;, jid1);
JobVertex v2 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; JobVertex(&lt;span class=&quot;code-quote&quot;&gt;&quot;v2&quot;&lt;/span&gt;, jid2);

SlotSharingGroup group = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SlotSharingGroup();

v1.setSlotSharingGroup(group);
v2.setSlotSharingGroup(group);

v1.setParallelism(2);
v2.setParallelism(4);

v1.setInvokableClass(BatchTask.class);
v2.setInvokableClass(BatchTask.class);

v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED_BOUNDED);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Currently, after allocate for v1,v2, we got a local partition and three remote partition. But actually, it should be 2 local partition and 2 remote partition. &lt;/p&gt;

&lt;p&gt;The causes of the above problems is becuase that the current allocate strategy is allocate the resource for execution one by one(if the execution can allocate from SlotGroup than get it, Otherwise ask for a new one for it). &lt;/p&gt;

&lt;p&gt;If we change the allocate strategy to two step will solve this problem, below is the Pseudo code:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (ExecutionJobVertex ejv: getVerticesTopologically) {
&lt;span class=&quot;code-comment&quot;&gt;//step 1: &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; to allocate from SlothGroup base on inputs one by one (which only allocate resource base on location).
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;//step 2: allocate &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; the remain execution.
&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
                <environment></environment>
        <key id="13086229">FLINK-7153</key>
            <summary>Eager Scheduling can&apos;t allocate source for ExecutionGraph correctly</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="trohrmann">Till Rohrmann</assignee>
                                    <reporter username="sihuazhou">Sihua Zhou</reporter>
                        <labels>
                    </labels>
                <created>Tue, 11 Jul 2017 11:52:47 +0000</created>
                <updated>Wed, 2 Oct 2019 17:44:24 +0000</updated>
                            <resolved>Thu, 2 Nov 2017 17:02:32 +0000</resolved>
                                    <version>1.3.1</version>
                                    <fixVersion>1.4.0</fixVersion>
                                    <component>Runtime / Coordination</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>11</watches>
                                                                                                                <comments>
                            <comment id="16085038" author="sihuazhou" created="Thu, 13 Jul 2017 01:53:18 +0000"  >&lt;p&gt;Hi, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=fhueske&quot; class=&quot;user-hover&quot; rel=&quot;fhueske&quot;&gt;fhueske&lt;/a&gt; can you help me to verify the problem i posted above, if i&apos;m wrong i will close this issue.&lt;br/&gt;
Thank you.&lt;/p&gt;</comment>
                            <comment id="16085615" author="fhueske" created="Thu, 13 Jul 2017 12:09:56 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sihuazhou&quot; class=&quot;user-hover&quot; rel=&quot;sihuazhou&quot;&gt;sihuazhou&lt;/a&gt;, thanks for reporting this issue. Unfortunately, I&apos;m not very familiar with Flink scheduler.&lt;br/&gt;
I&apos;d recommend to reach out to the dev mailing list to discuss this.&lt;/p&gt;

&lt;p&gt;Thanks, Fabian&lt;/p&gt;</comment>
                            <comment id="16085699" author="stephanewen" created="Thu, 13 Jul 2017 13:30:30 +0000"  >&lt;p&gt;Confirmed this bug. Will look into it and see that we provide a fix ASAP...&lt;/p&gt;</comment>
                            <comment id="16085706" author="sihuazhou" created="Thu, 13 Jul 2017 13:39:47 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; Thanks for you reply, can i contribute to this issue, i&apos;m very interested in flink? Indeed, i have fixed this issue in my fork code. I can show you the revised plan if you like.&lt;/p&gt;</comment>
                            <comment id="16085926" author="stephanewen" created="Thu, 13 Jul 2017 16:11:53 +0000"  >&lt;p&gt;I am happy to look at your suggested fix...&lt;/p&gt;</comment>
                            <comment id="16086915" author="sihuazhou" created="Fri, 14 Jul 2017 06:07:37 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Here is my solution.&lt;/p&gt;

&lt;p&gt;For  problem 1, We need to record the `Future&amp;lt;SimplSlot&amp;gt;` in `Execution` as soon as  `Execution.allocateSlotForExecution()` got a SimpleSlot successfully. So i add a private field `Future&amp;lt;SimpleSlot&amp;gt; assignedFutureResource` with the getter method for `Execution` class, the getter method will be called by `ExecutionVertex.getPreferredLocationsBasedOnInputs()`. After that, problem 1 can be solved. This need to modify `Executioin.class` and `ExecutionVertex.class`.&lt;/p&gt;

&lt;p&gt;For problem 2, i think we need change the allocate strategy into two steps,&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Step 1, Only allocate from SlothGroup base on inputs, in this step every ExectionVertex that can be allocate with local partition will be allocate successfully.&lt;/li&gt;
	&lt;li&gt;Step 2, Do normal allocation for the remain ExecutionVertex.&lt;br/&gt;
With the above two steps, problem 2 can be solved. This need to modify `ExecutionJobVertex.class` , `Scheduler.class`, `SlotSharingGroupAssignment` and `ScheduledUnit.class` which need to carry the `onlyAllocateBasePreferLocation` flag. &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;After all, there are 7 classes need to be modified.&lt;/p&gt;

&lt;p&gt;The bref code looks like this:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;&lt;b&gt;Execution.class&lt;/b&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Execution {

  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;volatile&lt;/span&gt; Future&amp;lt;SimpleSlot&amp;gt; assignedFutureResource; 
  &lt;span class=&quot;code-comment&quot;&gt;//the onlyAllocateBasePreferLocation parameter will be used &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; problem 2.
&lt;/span&gt;  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Future&amp;lt;SimpleSlot&amp;gt; allocateSlotForExecution(SlotProvider slotProvider, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; queued, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; onlyAllocateBasePreferLocation)
			&lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IllegalExecutionStateException {
		/*
		*/
		&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (transitionState(CREATED, SCHEDULED)) {

			ScheduledUnit toSchedule = locationConstraint == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; ?
					&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ScheduledUnit(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;, sharingGroup) :
					&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ScheduledUnit(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;, sharingGroup, locationConstraint);
					
			toSchedule.setOnlyAllocateBasePreferInputs(onlyAllocateBasePreferLocation);

			&lt;span class=&quot;code-comment&quot;&gt;//record the assign info by update assignedFutureResource
&lt;/span&gt;			assignedFutureResource = slotProvider.allocateSlot(toSchedule, queued);
			&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (assignedFutureResource == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
				transitionState(SCHEDULED, CREATED);
			}
			&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; assignedFutureResource;
		}
		/*
		*/
	}
	
	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Future&amp;lt;SimpleSlot&amp;gt; getAllocateFutureSlot() {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; assignedFutureResource;
	}
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;



&lt;ol&gt;
	&lt;li&gt;&lt;b&gt;ExecutionVertex.class&lt;/b&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;ExecutionVertex {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Iterable&amp;lt;TaskManagerLocation&amp;gt; getPreferredLocationsBasedOnInputs() {
		/*
		*/
		&lt;span class=&quot;code-comment&quot;&gt;//&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; to look-up futureSlot &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; getCurrentAssignedResource() &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;
&lt;/span&gt;		SimpleSlot sourceSlot = sources[k].getSource().getProducer().getCurrentAssignedResource();
						
		&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (sourceSlot == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
				Future&amp;lt;SimpleSlot&amp;gt; futureSlot = sources[k].getSource().getProducer().getCurrentExecutionAttempt().getAllocateFutureSlot();
				&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (futureSlot != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
					sourceSlot = futureSlot.get();
				}
		}
		/*
		*/
	}
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;ol&gt;
	&lt;li&gt;&lt;b&gt;ExecutionJobVertex.class&lt;/b&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;ExecutionJobVertex {
	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; ExecutionAndSlot[] allocateResourcesForAll(SlotProvider resourceProvider, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; queued) {
		&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; List&amp;lt;ExecutionAndSlot&amp;gt; slots = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.taskVertices.length);
		&lt;span class=&quot;code-comment&quot;&gt;//step 1
&lt;/span&gt;		slots.addAll(allocateResourcesForAllHepler(resourceProvider, queued, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;));
		&lt;span class=&quot;code-comment&quot;&gt;//step 2
&lt;/span&gt;		slots.addAll(allocateResourcesForAllHepler(resourceProvider, queued, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;));
		&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; slots.toArray(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ExecutionAndSlot[&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.taskVertices.length]);
	}
	
	
	&lt;span class=&quot;code-comment&quot;&gt;//In addition to adding an onlyAllocateBaseOnInputs parameter, it&apos;s similar the old allocateResourcesForAll function.
&lt;/span&gt;	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;ExecutionAndSlot&amp;gt; allocateResourcesForAllHepler(SlotProvider resourceProvider, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; queued, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; onlyAllocateBaseOnInputs) {

		&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; List&amp;lt;ExecutionAndSlot&amp;gt; slots = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(taskVertices.length);
		&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; List&amp;lt;ExecutionVertex&amp;gt; verticeList = Lists.newArrayList(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.taskVertices);
		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; verticeList.size(); ++i) {
			&lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; successful = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
			&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
				&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; ExecutionVertex vertex = verticeList.get(i);
				&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Execution exec = vertex.getCurrentExecutionAttempt();
				&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (exec.getAssignedFutureResource() != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
					successful = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
					&lt;span class=&quot;code-keyword&quot;&gt;continue&lt;/span&gt;;
				}
				Future&amp;lt;SimpleSlot&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt; = exec.allocateSlotForExecution(resourceProvider, queued, onlyAllocateBaseOnInputs);
				&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt; != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
					slots.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ExecutionAndSlot(exec, &lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt;));
				}
				successful = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
			} &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
				&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!successful) {
					&lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; is the &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; an exception was thrown
&lt;/span&gt;					&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (ExecutionAndSlot slot: slots) {
						ExecutionGraphUtils.releaseSlotFuture(slot.slotFuture);
					}
				}
			}
		}

		&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; slots;
	}	
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;ol&gt;
	&lt;li&gt;&lt;b&gt;Scheduler.class&lt;/b&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Scheduler {	
	&lt;span class=&quot;code-comment&quot;&gt;//In scheduleTask(), we need to &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, when &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; to allocate base on inputs failed.
&lt;/span&gt;	&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; scheduleTask(ScheduledUnit task, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; queueIfNoResource) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; NoResourceAvailableException {

		&lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (globalLock) {
			.................			
			&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (sharingUnit != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
				&lt;span class=&quot;code-comment&quot;&gt;//
&lt;/span&gt;				&lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; isOnlyAllocateByPreferInputs = task.getOnlyAllocateByPreferInputs();
				&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; SimpleSlot slotFromGroup;
				&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (constraint == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
					slotFromGroup = assignment.getSlotForTask(vertex, isOnlyAllocateByPreferInputs);
				}
				&lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
					slotFromGroup = assignment.getSlotForTask(vertex, constraint, isOnlyAllocateByPreferInputs);
				}

				&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isOnlyAllocateByPreferInputs &amp;amp;&amp;amp; slotFromGroup == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
					&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
				}
				&lt;span class=&quot;code-comment&quot;&gt;//
&lt;/span&gt;			}
			.......
		}
	}
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;ol&gt;
	&lt;li&gt;&lt;b&gt;SlotSharingGroupAssignment.class&lt;/b&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;SlotSharingGroupAssignment {
  
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; Tuple2&amp;lt;SharedSlot, Locality&amp;gt; getSlotForTaskInternal(AbstractID groupId, Iterable&amp;lt;TaskManagerLocation&amp;gt; preferredLocations, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; localOnly, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; onlyAllocateBaseOnInputs) {	
  /*
  */
  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (preferredLocations != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (TaskManagerLocation location : preferredLocations) {
				&lt;span class=&quot;code-comment&quot;&gt;// set the flag that we failed a preferred location. If one will be found,
&lt;/span&gt;				&lt;span class=&quot;code-comment&quot;&gt;// we &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; early anyways and skip the flag evaluation
&lt;/span&gt;				didNotGetPreferred = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
				SharedSlot slot = removeFromMultiMap(slotsForGroup, location.getResourceID());
				&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (slot != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; slot.isAlive()) {
					&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Tuple2&amp;lt;&amp;gt;(slot, Locality.LOCAL);
				}
			}
		}
       }
       &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (onlyAllocateBaseOnInputs) {
		&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
       }    
  }
  /*
  */
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Thank you very much for your time to review my solution. Can you assign this issue to me, i&apos;m willing to contribute to flink so much.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Sihua ZHou&lt;/p&gt;</comment>
                            <comment id="16091575" author="sihuazhou" created="Tue, 18 Jul 2017 13:57:47 +0000"  >&lt;p&gt;After thinking about is, i found that this issue contains two subproblems. According to the PR template&apos;s guidance, we should&apos;t mix them together. So i created two subtasks under this issue.&lt;br/&gt;
1. &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7218&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;FLINK-7218&lt;/a&gt; address the problem: ExecutionVertex.getPreferredLocationsBasedOnInputs() always return empty.&lt;br/&gt;
2. &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7219&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;FLINK-7219&lt;/a&gt; address the problem: Current allocate strategy cann&#8216;t achieve the optimal effect with input&apos;s location.&lt;/p&gt;</comment>
                            <comment id="16095999" author="aljoscha" created="Fri, 21 Jul 2017 09:06:12 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sihuazhou&quot; class=&quot;user-hover&quot; rel=&quot;sihuazhou&quot;&gt;sihuazhou&lt;/a&gt; Do you think this is going to be fixed in time for 1.3.2? If not we should think about demoting this from &quot;blocker&quot; or moving to 1.3.2.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                            <comment id="16096249" author="sihuazhou" created="Fri, 21 Jul 2017 13:30:40 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=aljoscha&quot; class=&quot;user-hover&quot; rel=&quot;aljoscha&quot;&gt;aljoscha&lt;/a&gt; I issues contains two subproblems, for the first one &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7218&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;FLINK-7218&lt;/a&gt;, i have make a PR &lt;a href=&quot;https://github.com/apache/flink/pull/4369&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt;, but no review has yet been made. For the second one &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7219&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;FLINK-7219&lt;/a&gt;, Although I have fixed this problem in my fork branch, but it just fix &apos;this case&apos;, as Stephan mentioned in &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7219&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;FLINK-7219&lt;/a&gt;, it needs a bit more thought for the future, so i&apos;m not going to make a PR for it.&lt;/p&gt;</comment>
                            <comment id="16205877" author="till.rohrmann" created="Mon, 16 Oct 2017 13:25:35 +0000"  >&lt;p&gt;Why don&apos;t we make the scheduling dependent on the future locations of the input tasks? This would mean that the &lt;tt&gt;ExecutionVertex#getPreferredLocations&lt;/tt&gt; would return a &lt;tt&gt;Collection&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt;&lt;/tt&gt; which contains the future locations of the inputs. When trying to allocate a slot for a given task, the &lt;tt&gt;Scheduler&lt;/tt&gt; will retrieve the future locations of the inputs, and only upon completion it will allocate the slot for the requested task. This will ensure that we have all information needed to calculate the scheduling. I&apos;ve quickly prototyped a working version which you find here &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;The downside of this approach is that we lose the nice property that we only start deploying tasks in eager mode if we are sure that we have enough slots available. The reason is that we have to call &lt;tt&gt;Execution#deployToSlot&lt;/tt&gt; in order to complete the location future of an &lt;tt&gt;Execution&lt;/tt&gt;. We can solve this problem, however, by separating the slot assignment and the actual deploy call into two methods, e.g. &lt;tt&gt;Execution#assignSlot&lt;/tt&gt; and &lt;tt&gt;Execution#deployToSlot&lt;/tt&gt;. I&apos;ve prototyped this version here &lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;. Before calling &lt;tt&gt;Execution#deployToSlot&lt;/tt&gt; one has to call explicitly &lt;tt&gt;Execution#tryAssignSlot&lt;/tt&gt;. This complicates the API a little bit but it will allow us to fail without deploying tasks in the eager deployment mode.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; &lt;a href=&quot;https://github.com/tillrohrmann/flink/tree/fixGroupScheduling&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/tillrohrmann/flink/tree/fixGroupScheduling&lt;/a&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt; &lt;a href=&quot;https://github.com/tillrohrmann/flink/tree/fixGroupScheduling2&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/tillrohrmann/flink/tree/fixGroupScheduling2&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16205895" author="till.rohrmann" created="Mon, 16 Oct 2017 13:37:18 +0000"  >&lt;p&gt;Looking at the code of the &lt;tt&gt;Scheduler#scheduleTask&lt;/tt&gt;, we execute the task scheduling logic under a global lock. This means that partially ordering the task schedulings by introducing input dependencies should not hurt either, because multiple schedulings will be executed in serial order anyway, if I&apos;m not mistaken.&lt;/p&gt;</comment>
                            <comment id="16207212" author="sihuazhou" created="Tue, 17 Oct 2017 09:19:17 +0000"  >&lt;p&gt;I prefer &lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;, it also fix &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7218&quot; title=&quot;ExecutionVertex.getPreferredLocationsBasedOnInputs() will always return empty&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7218&quot;&gt;&lt;del&gt;FLINK-7218&lt;/del&gt;&lt;/a&gt; and do a better job than the current one. But i also have a bit more thought.&lt;br/&gt;
1. For &lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;, after getting the prefer location list, we should count according to location and sort according to the count result, eg. we should turn &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;{location1, location2, location2}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; into &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;{(location2, 2), (location1, 1)}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;, this means we like location2 more that location1.&lt;br/&gt;
2. For a bit more thought, scheduler should not only consider the input of the source, but also consider the location of the state, and the schedule order should determine by ExecuteJobVertex&apos;s weight not just according to creation order.&lt;/p&gt;</comment>
                            <comment id="16209021" author="till.rohrmann" created="Wed, 18 Oct 2017 09:07:02 +0000"  >&lt;p&gt;These are good ideas &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sihuazhou&quot; class=&quot;user-hover&quot; rel=&quot;sihuazhou&quot;&gt;sihuazhou&lt;/a&gt;. I like counting which location should have preference based on how often it appeared. I would actually create a separate issue for that because it is more of an improvement.&lt;/p&gt;

&lt;p&gt;Concerning point 2. you are absolutely right. In fact, there is already the method &lt;tt&gt;ExecutionVertex#getPreferredLocations&lt;/tt&gt; which can switch between preferred locations based on input and on state location.&lt;/p&gt;

&lt;p&gt;A bit off-topic, I would actually unblock the 1.4 release from this issue, because it is not a new bug we introduced but something which is already part of the 1.3 release. Moreover, fixing this issue might be bit more involved since we are touching sensitive components of the system.&lt;/p&gt;</comment>
                            <comment id="16222717" author="githubbot" created="Fri, 27 Oct 2017 17:27:42 +0000"  >&lt;p&gt;GitHub user tillrohrmann opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7153&quot; title=&quot;Eager Scheduling can&amp;#39;t allocate source for ExecutionGraph correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7153&quot;&gt;&lt;del&gt;FLINK-7153&lt;/del&gt;&lt;/a&gt; Re-introduce preferred locations for scheduling&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This PR makes the `TaskManagerLocation` accessible for asynchronous scheduling.&lt;/p&gt;

&lt;p&gt;    Due to changes for Flink 1.3 where we introduced asynchronous scheduling, it was not always guaranteed that the scheduler knew about the scheduling locations of producer tasks. Especially the eager scheduling mode was affected since the slot allocation happened concurrently.&lt;/p&gt;

&lt;p&gt;    In order to fix this problem, this PR adds a `TaskManagerLocationFuture` to each `Execution`. In eager scheduling mode, a slot will only be requested for a task if all its inputs have a slot assigned (e.g. their `TaskManagerLocationFuture` is completed). In lazy scheduling mode, we don&apos;t wait for the completion of all inputs, but take those inputs which are already known.&lt;/p&gt;

&lt;p&gt;    In order to distinguish whether we want to wait for all or take all available task manager locations, we add a `LocationPreferenceConstraint` which has the values `ALL` and `ANY`. `ALL` means that we have to wait for all inputs to have a location assigned, and `ANY` means that we take what&apos;s currently known.&lt;/p&gt;

&lt;p&gt;    In order to not deploy slots prematurely in eager mode, the slot assignment has been factored out into its own step. Before, one had to call `Execution#deployToSlot(SimpleSlot)` which assigned the given slot and started the deployment. Now, one has to call `Execution#tryAssignResource` before one can call `Execution#deploy`.&lt;/p&gt;

&lt;p&gt;    Moreover this PR fixes that the `FailoverRegions` are topologically sorted which is important for non queued scheduling.&lt;/p&gt;

&lt;p&gt;    FYI @StephanEwen &lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Introduce `LocationPreferenceConstraint` to distinguish the waiting behaviour for the preferred locations&lt;/li&gt;
	&lt;li&gt;Split slot assignment and deployment into two separate steps&lt;/li&gt;
	&lt;li&gt;Moved preferred location calculation into the Execution to reduce code duplication between the `Scheduler` and the `SlotPool`&lt;/li&gt;
	&lt;li&gt;Changed preferred location calculation to be blocking if `LocationPreferenceConstraint#ALL` and not all input locations are known&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This change added tests and can be verified as follows:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added `ExecutionTest` to check the correct assigned slot release in case of cancellation and to check the correct preferred location calculation&lt;/li&gt;
	&lt;li&gt;Added `ExecutionGraphDeploymentTest#testEagerSchedulingWaitsOnAllInputPreferredLocations` to check that eager scheduling waits for all inputs to be assigned before scheduling consumer tasks&lt;/li&gt;
	&lt;li&gt;Moreover, the scheduler is being tested by existing tests such as `SchedulerSlotSharingTest`, `ScheduleWithCoLocationHintTest` and many IT cases for lazy scheduling (batch case)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (no)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (no)&lt;/li&gt;
	&lt;li&gt;The serializers: (no)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (no)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (yes)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (no)&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? (not applicable)&lt;/li&gt;
&lt;/ul&gt;




&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/tillrohrmann/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/tillrohrmann/flink&lt;/a&gt; fixGroupScheduling2&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4916&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 32eb1812583b84d80091d1a278d53ed663d8a065&lt;br/&gt;
Author: Till &amp;lt;till.rohrmann@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-10-16T12:04:13Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7153&quot; title=&quot;Eager Scheduling can&amp;#39;t allocate source for ExecutionGraph correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7153&quot;&gt;&lt;del&gt;FLINK-7153&lt;/del&gt;&lt;/a&gt; Re-introduce preferred locations for scheduling&lt;/p&gt;

&lt;p&gt;commit 8c0c9aeaa7ca995247f2b9f9e63723e52d839a12&lt;br/&gt;
Author: Till Rohrmann &amp;lt;trohrmann@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-10-27T07:47:03Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7153&quot; title=&quot;Eager Scheduling can&amp;#39;t allocate source for ExecutionGraph correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7153&quot;&gt;&lt;del&gt;FLINK-7153&lt;/del&gt;&lt;/a&gt; Introduce LocationPreferenceConstraint for scheduling&lt;/p&gt;

&lt;p&gt;    The LocationPreferenceConstraint defines whether all or any preferred locations&lt;br/&gt;
    have to be taken into consideration when scheduling tasks. Especially for batch&lt;br/&gt;
    jobs where we do lazy scheduling not all input locations might be known for a&lt;br/&gt;
    consumer task. Therefore, we set the location preference constraint to any which&lt;br/&gt;
    means that only those location are taken into consideration which are known at&lt;br/&gt;
    scheduling time.&lt;/p&gt;

&lt;p&gt;commit c821e67529deaaed96f183fc22bc0a9fe246fa23&lt;br/&gt;
Author: Till Rohrmann &amp;lt;trohrmann@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-10-26T16:22:43Z&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;hotfix&amp;#93;&lt;/span&gt; Make failover region topological sorted&lt;/p&gt;

&lt;p&gt;commit 67baeade85e26758978bcdf7982576a2f4192aae&lt;br/&gt;
Author: Till Rohrmann &amp;lt;trohrmann@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-10-27T17:08:15Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7153&quot; title=&quot;Eager Scheduling can&amp;#39;t allocate source for ExecutionGraph correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7153&quot;&gt;&lt;del&gt;FLINK-7153&lt;/del&gt;&lt;/a&gt; Add test cases&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16226198" author="githubbot" created="Tue, 31 Oct 2017 03:44:08 +0000"  >&lt;p&gt;Github user summerleafs commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r147889602&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r147889602&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -878,113 +880,70 @@ private void scheduleEager(SlotProvider slotProvider, final Time timeout) {&lt;br/&gt;
     		// that way we do not have any operation that can fail between allocating the slots&lt;br/&gt;
     		// and adding them to the list. If we had a failure in between there, that would&lt;br/&gt;
     		// cause the slots to get lost&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final ArrayList&amp;lt;ExecutionAndSlot[]&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
     		final boolean queued = allowQueuedScheduling;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// we use this flag to handle failures in a &apos;finally&apos; clause&lt;/li&gt;
	&lt;li&gt;// that allows us to not go through clumsy cast-and-rethrow logic&lt;/li&gt;
	&lt;li&gt;boolean successful = false;&lt;br/&gt;
    +		// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
    +		final ArrayList&amp;lt;CompletableFuture&amp;lt;Execution&amp;gt;&amp;gt; allAllocationFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;// collecting all the slots may resize and fail in that operation without slots getting lost&lt;/li&gt;
	&lt;li&gt;final ArrayList&amp;lt;CompletableFuture&amp;lt;SimpleSlot&amp;gt;&amp;gt; slotFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +		// allocate the slots (obtain all their futures&lt;br/&gt;
    +		for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
    +			// these calls are not blocking, they only return futures
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Hi, allocate resources according to the order of topologically, is just to facilitate the optimization of &apos;allocate resource base on prefer input&apos;? it may cause bad result if we allocate base on state.&lt;/p&gt;</comment>
                            <comment id="16226215" author="githubbot" created="Tue, 31 Oct 2017 04:06:30 +0000"  >&lt;p&gt;Github user summerleafs commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r147891494&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r147891494&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java &amp;#8212;&lt;br/&gt;
    @@ -1065,6 +1177,46 @@ private void sendUpdatePartitionInfoRpcCall(&lt;br/&gt;
     	//  Miscellaneous&lt;br/&gt;
     	// --------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * Calculates the preferred locations based on the location preference constraint.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param locationPreferenceConstraint constraint for the location preference&lt;br/&gt;
    +	 * @return Future containing the collection of preferred locations. This might not be completed if not all inputs&lt;br/&gt;
    +	 * 		have been a resource assigned.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@VisibleForTesting&lt;br/&gt;
    +	public CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
    +		final Collection&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs();&lt;br/&gt;
    +		final CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationsFuture;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Hi Till,`getPreferredLocations()` is not invoked here because flink doesn&apos;t yet support reading the checkpoint data locally? I have create a issue for flink reading checkpoint locally &lt;span class=&quot;error&quot;&gt;&amp;#91;here&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7873?filter=-1&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-7873?filter=-1&lt;/a&gt;), when it complete i wonder if we can invoke `getPreferedLocations()` instead of `getPreferredLocationsBasedOnInputs()`.&lt;/p&gt;</comment>
                            <comment id="16233800" author="githubbot" created="Wed, 1 Nov 2017 08:58:31 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148209063&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148209063&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -878,113 +880,70 @@ private void scheduleEager(SlotProvider slotProvider, final Time timeout) {&lt;br/&gt;
     		// that way we do not have any operation that can fail between allocating the slots&lt;br/&gt;
     		// and adding them to the list. If we had a failure in between there, that would&lt;br/&gt;
     		// cause the slots to get lost&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final ArrayList&amp;lt;ExecutionAndSlot[]&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
     		final boolean queued = allowQueuedScheduling;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// we use this flag to handle failures in a &apos;finally&apos; clause&lt;/li&gt;
	&lt;li&gt;// that allows us to not go through clumsy cast-and-rethrow logic&lt;/li&gt;
	&lt;li&gt;boolean successful = false;&lt;br/&gt;
    +		// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
    +		final ArrayList&amp;lt;CompletableFuture&amp;lt;Execution&amp;gt;&amp;gt; allAllocationFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;// collecting all the slots may resize and fail in that operation without slots getting lost&lt;/li&gt;
	&lt;li&gt;final ArrayList&amp;lt;CompletableFuture&amp;lt;SimpleSlot&amp;gt;&amp;gt; slotFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +		// allocate the slots (obtain all their futures&lt;br/&gt;
    +		for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
    +			// these calls are not blocking, they only return futures
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    There is no specific reason why we iterate over the vertices in topological order. We could also choose a completely random order for eager scheduling because the scheduling order will be determined by the preferred location futures (which at the moment is based on inputs only). If we should switch to state location then it basically means that we schedule the individual tasks independently because the vertices don&apos;t depend on the input locations.&lt;/p&gt;</comment>
                            <comment id="16233802" author="githubbot" created="Wed, 1 Nov 2017 09:00:08 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148209318&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148209318&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java &amp;#8212;&lt;br/&gt;
    @@ -1065,6 +1177,46 @@ private void sendUpdatePartitionInfoRpcCall(&lt;br/&gt;
     	//  Miscellaneous&lt;br/&gt;
     	// --------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * Calculates the preferred locations based on the location preference constraint.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param locationPreferenceConstraint constraint for the location preference&lt;br/&gt;
    +	 * @return Future containing the collection of preferred locations. This might not be completed if not all inputs&lt;br/&gt;
    +	 * 		have been a resource assigned.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@VisibleForTesting&lt;br/&gt;
    +	public CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
    +		final Collection&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs();&lt;br/&gt;
    +		final CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationsFuture;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Yes, that is exactly the idea. &lt;/p&gt;</comment>
                            <comment id="16233815" author="githubbot" created="Wed, 1 Nov 2017 09:14:49 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148211942&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148211942&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -878,113 +880,70 @@ private void scheduleEager(SlotProvider slotProvider, final Time timeout) {&lt;br/&gt;
     		// that way we do not have any operation that can fail between allocating the slots&lt;br/&gt;
     		// and adding them to the list. If we had a failure in between there, that would&lt;br/&gt;
     		// cause the slots to get lost&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final ArrayList&amp;lt;ExecutionAndSlot[]&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
     		final boolean queued = allowQueuedScheduling;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// we use this flag to handle failures in a &apos;finally&apos; clause&lt;/li&gt;
	&lt;li&gt;// that allows us to not go through clumsy cast-and-rethrow logic&lt;/li&gt;
	&lt;li&gt;boolean successful = false;&lt;br/&gt;
    +		// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
    +		final ArrayList&amp;lt;CompletableFuture&amp;lt;Execution&amp;gt;&amp;gt; allAllocationFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;// collecting all the slots may resize and fail in that operation without slots getting lost&lt;/li&gt;
	&lt;li&gt;final ArrayList&amp;lt;CompletableFuture&amp;lt;SimpleSlot&amp;gt;&amp;gt; slotFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +		// allocate the slots (obtain all their futures&lt;br/&gt;
    +		for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
    +			// these calls are not blocking, they only return futures
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    If we switch to state location then we can&apos;t allocate resources according to the order of topologically, because stateless vertices may share the same  SlotSharingGroup with stateful vertices, if stateless vertices allocated before the stateful vertices, the result can be bad.  An intuitive way to do this is to allocate resources to stateful vertices firstly.&lt;/p&gt;</comment>
                            <comment id="16233845" author="githubbot" created="Wed, 1 Nov 2017 09:39:57 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148216607&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148216607&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -878,113 +880,70 @@ private void scheduleEager(SlotProvider slotProvider, final Time timeout) {&lt;br/&gt;
     		// that way we do not have any operation that can fail between allocating the slots&lt;br/&gt;
     		// and adding them to the list. If we had a failure in between there, that would&lt;br/&gt;
     		// cause the slots to get lost&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final ArrayList&amp;lt;ExecutionAndSlot[]&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
     		final boolean queued = allowQueuedScheduling;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// we use this flag to handle failures in a &apos;finally&apos; clause&lt;/li&gt;
	&lt;li&gt;// that allows us to not go through clumsy cast-and-rethrow logic&lt;/li&gt;
	&lt;li&gt;boolean successful = false;&lt;br/&gt;
    +		// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
    +		final ArrayList&amp;lt;CompletableFuture&amp;lt;Execution&amp;gt;&amp;gt; allAllocationFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;// collecting all the slots may resize and fail in that operation without slots getting lost&lt;/li&gt;
	&lt;li&gt;final ArrayList&amp;lt;CompletableFuture&amp;lt;SimpleSlot&amp;gt;&amp;gt; slotFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +		// allocate the slots (obtain all their futures&lt;br/&gt;
    +		for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
    +			// these calls are not blocking, they only return futures
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    In that case, it depends a bit on how the scheduler values the state location preference. If it is implemented that it strictly schedules tasks to its previous state location, then it could happen that these tasks don&apos;t end up in the same slot as other tasks with which they shared a slot before.&lt;/p&gt;</comment>
                            <comment id="16233848" author="githubbot" created="Wed, 1 Nov 2017 09:41:20 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148216894&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148216894&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -878,113 +880,70 @@ private void scheduleEager(SlotProvider slotProvider, final Time timeout) {&lt;br/&gt;
     		// that way we do not have any operation that can fail between allocating the slots&lt;br/&gt;
     		// and adding them to the list. If we had a failure in between there, that would&lt;br/&gt;
     		// cause the slots to get lost&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final ArrayList&amp;lt;ExecutionAndSlot[]&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
     		final boolean queued = allowQueuedScheduling;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// we use this flag to handle failures in a &apos;finally&apos; clause&lt;/li&gt;
	&lt;li&gt;// that allows us to not go through clumsy cast-and-rethrow logic&lt;/li&gt;
	&lt;li&gt;boolean successful = false;&lt;br/&gt;
    +		// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
    +		final ArrayList&amp;lt;CompletableFuture&amp;lt;Execution&amp;gt;&amp;gt; allAllocationFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;// collecting all the slots may resize and fail in that operation without slots getting lost&lt;/li&gt;
	&lt;li&gt;final ArrayList&amp;lt;CompletableFuture&amp;lt;SimpleSlot&amp;gt;&amp;gt; slotFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +		// allocate the slots (obtain all their futures&lt;br/&gt;
    +		for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
    +			// these calls are not blocking, they only return futures
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    But be aware that the `allocateAndAssign` call is non-blocking and the actual order depends on the preferred locations futures.&lt;/p&gt;</comment>
                            <comment id="16234604" author="githubbot" created="Wed, 1 Nov 2017 19:20:44 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148358215&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148358215&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -878,113 +880,70 @@ private void scheduleEager(SlotProvider slotProvider, final Time timeout) {&lt;br/&gt;
     		// that way we do not have any operation that can fail between allocating the slots&lt;br/&gt;
     		// and adding them to the list. If we had a failure in between there, that would&lt;br/&gt;
     		// cause the slots to get lost&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final ArrayList&amp;lt;ExecutionAndSlot[]&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
     		final boolean queued = allowQueuedScheduling;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// we use this flag to handle failures in a &apos;finally&apos; clause&lt;/li&gt;
	&lt;li&gt;// that allows us to not go through clumsy cast-and-rethrow logic&lt;/li&gt;
	&lt;li&gt;boolean successful = false;&lt;br/&gt;
    +		// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
    +		final ArrayList&amp;lt;CompletableFuture&amp;lt;Execution&amp;gt;&amp;gt; allAllocationFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;// collecting all the slots may resize and fail in that operation without slots getting lost&lt;/li&gt;
	&lt;li&gt;final ArrayList&amp;lt;CompletableFuture&amp;lt;SimpleSlot&amp;gt;&amp;gt; slotFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +		// allocate the slots (obtain all their futures&lt;br/&gt;
    +		for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
    +			// these calls are not blocking, they only return futures
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Having a scheduling mechanism that tries to satisfy both state locality and input locality could be interesting. Input locality may extend to locality of input partitions (in Kafka for example) as well, which makes it even more complicated.&lt;/p&gt;

&lt;p&gt;    I think the current state of the heuristic is: previous location first (later: state locality first), if that leaves freedom, try to schedule based on inputs.&lt;/p&gt;

&lt;p&gt;    I can see an extended variant where we first collect all vertices with constraints, try to satisfy those. They may in turn add more constraints (or preferences) which should be satisfied next. Repeat until all are satisfied, or it is not possible to satisfy the preferences any more. But that is a pretty big change, that we should discus and design properly, not push it into a bug fix.&lt;/p&gt;</comment>
                            <comment id="16234662" author="githubbot" created="Wed, 1 Nov 2017 20:07:19 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148360739&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148360739&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java &amp;#8212;&lt;br/&gt;
    @@ -220,14 +233,54 @@ public long getGlobalModVersion() &lt;/p&gt;
{
     		return globalModVersion;
     	}

&lt;p&gt;    +	public CompletableFuture&amp;lt;TaskManagerLocation&amp;gt; getTaskManagerLocationFuture() &lt;/p&gt;
{
    +		return taskManagerLocationFuture;
    +	}
&lt;p&gt;    +&lt;br/&gt;
     	public SimpleSlot getAssignedResource() &lt;/p&gt;
{
    -		return assignedResource;
    +		return assignedResource.get();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Tries to assign the given slot to the execution. The assignment works only if the&lt;br/&gt;
    +	 * Execution is in state SCHEDULED. Returns true, if the resource could be assigned.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param slot to assign to this execution&lt;br/&gt;
    +	 * @return true if the slot could be assigned to the execution, otherwise false&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@VisibleForTesting&lt;br/&gt;
    +	boolean tryAssignResource(final SimpleSlot slot) {&lt;br/&gt;
    +		Preconditions.checkNotNull(slot);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Style: This class uses partially `Preconditions.checkX(...)` and partially statically imported `checkX(...)`. Can we make thsi homogeneous?&lt;/p&gt;</comment>
                            <comment id="16234663" author="githubbot" created="Wed, 1 Nov 2017 20:07:19 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148360937&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148360937&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java &amp;#8212;&lt;br/&gt;
    @@ -126,9 +134,11 @@&lt;br/&gt;
     	/** A future that completes once the Execution reaches a terminal ExecutionState */&lt;br/&gt;
     	private final CompletableFuture&amp;lt;ExecutionState&amp;gt; terminationFuture;&lt;/p&gt;

&lt;p&gt;    +	private final CompletableFuture&amp;lt;TaskManagerLocation&amp;gt; taskManagerLocationFuture;&lt;br/&gt;
    +&lt;br/&gt;
     	private volatile ExecutionState state = CREATED;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private volatile SimpleSlot assignedResource;     // once assigned, never changes until the execution is archived&lt;br/&gt;
    +	private final AtomicReference&amp;lt;SimpleSlot&amp;gt; assignedResource;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Minor comment: Since the resource is accessed quite frequently, using a volatile variable with an  `AtomicReferenceFieldUpdater` could be good here.&lt;/p&gt;</comment>
                            <comment id="16234664" author="githubbot" created="Wed, 1 Nov 2017 20:07:20 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148366296&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148366296&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java &amp;#8212;&lt;br/&gt;
    @@ -476,14 +482,13 @@ else if (numSources &amp;lt; parallelism) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@return The preferred locations based in input streams, or an empty iterable,&lt;/li&gt;
	&lt;li&gt;if there is no input-based preference.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public Iterable&amp;lt;TaskManagerLocation&amp;gt; getPreferredLocationsBasedOnInputs() {&lt;br/&gt;
    +	public Collection&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; getPreferredLocationsBasedOnInputs() {&lt;br/&gt;
     		// otherwise, base the preferred locations on the input connections&lt;br/&gt;
     		if (inputEdges == null) 
{
     			return Collections.emptySet();
     		}
&lt;p&gt;     		else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;Set&amp;lt;TaskManagerLocation&amp;gt; locations = new HashSet&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;Set&amp;lt;TaskManagerLocation&amp;gt; inputLocations = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
    +			Set&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; inputLocations = new HashSet&amp;lt;&amp;gt;(4);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The code here changes some semantics:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Originally: Determine preferred input location per input gate. If one gate has too many candidates, and one gate as few candidates, then these few candidates are the preference. Example: a broadcast join where one input if &lt;b&gt;broadcast&lt;/b&gt;, the other is &lt;b&gt;forward&lt;/b&gt;. The code would pick the locality preference for the &quot;forward&quot; input.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Now: All input channels contribute to the same locality preference pool. If one input has too many candidates, no locality preferences exist at all. In the broadcast join case, the forward input is not taken into account any more.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Is that intended? I think the broadcast join case is a good example why the per-input(gate) treatment is helpful.&lt;/p&gt;</comment>
                            <comment id="16234665" author="githubbot" created="Wed, 1 Nov 2017 20:07:20 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148366967&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148366967&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/Scheduler.java &amp;#8212;&lt;br/&gt;
    @@ -133,32 +133,33 @@ public void shutdown() {&lt;/p&gt;


&lt;p&gt;     	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public CompletableFuture&amp;lt;SimpleSlot&amp;gt; allocateSlot(ScheduledUnit task, boolean allowQueued) {&lt;br/&gt;
    +	public CompletableFuture&amp;lt;SimpleSlot&amp;gt; allocateSlot(&lt;br/&gt;
    +			ScheduledUnit task,&lt;br/&gt;
    +			boolean allowQueued,&lt;br/&gt;
    +			Collection&amp;lt;TaskManagerLocation&amp;gt; preferredLocations) {&lt;br/&gt;
    +&lt;br/&gt;
     		try {&lt;/li&gt;
	&lt;li&gt;final Object ret = scheduleTask(task, allowQueued);&lt;br/&gt;
    +			final Object ret = scheduleTask(task, allowQueued, preferredLocations);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     			if (ret instanceof SimpleSlot) &lt;/p&gt;
{
     				return CompletableFuture.completedFuture((SimpleSlot) ret);
    -			}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;else if (ret instanceof CompletableFuture) 
{
    +			}
&lt;p&gt; else if (ret instanceof CompletableFuture) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Ah, all the nice spacey-easy-to-parse formatting going away here...&lt;/p&gt;</comment>
                            <comment id="16234666" author="githubbot" created="Wed, 1 Nov 2017 20:07:20 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148364165&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148364165&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java &amp;#8212;&lt;br/&gt;
    @@ -1065,6 +1177,46 @@ private void sendUpdatePartitionInfoRpcCall(&lt;br/&gt;
     	//  Miscellaneous&lt;br/&gt;
     	// --------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * Calculates the preferred locations based on the location preference constraint.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param locationPreferenceConstraint constraint for the location preference&lt;br/&gt;
    +	 * @return Future containing the collection of preferred locations. This might not be completed if not all inputs&lt;br/&gt;
    +	 * 		have been a resource assigned.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@VisibleForTesting&lt;br/&gt;
    +	public CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
    +		final Collection&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs();&lt;br/&gt;
    +		final CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationsFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +		switch(locationPreferenceConstraint) {&lt;br/&gt;
    +			case ALL:&lt;br/&gt;
    +				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures);&lt;br/&gt;
    +				break;&lt;br/&gt;
    +			case ANY:&lt;br/&gt;
    +				final ArrayList&amp;lt;TaskManagerLocation&amp;gt; completedTaskManagerLocations = new ArrayList&amp;lt;&amp;gt;(1);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Is the intention to return the first result available here (assuming from the size 1 initialization of the array list)?&lt;br/&gt;
    If yes, should the loop below break after the input with a completed location future?&lt;/p&gt;</comment>
                            <comment id="16234667" author="githubbot" created="Wed, 1 Nov 2017 20:07:20 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148367405&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148367405&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/resources/log4j-test.properties &amp;#8212;&lt;br/&gt;
    @@ -16,7 +16,7 @@&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
     ################################################################################&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    -log4j.rootLogger=OFF, console&lt;br/&gt;
    +log4j.rootLogger=INFO, console&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Undo log level setting&lt;/p&gt;</comment>
                            <comment id="16234668" author="githubbot" created="Wed, 1 Nov 2017 20:07:20 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148363944&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148363944&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java &amp;#8212;&lt;br/&gt;
    @@ -1065,6 +1177,46 @@ private void sendUpdatePartitionInfoRpcCall(&lt;br/&gt;
     	//  Miscellaneous&lt;br/&gt;
     	// --------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * Calculates the preferred locations based on the location preference constraint.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param locationPreferenceConstraint constraint for the location preference&lt;br/&gt;
    +	 * @return Future containing the collection of preferred locations. This might not be completed if not all inputs&lt;br/&gt;
    +	 * 		have been a resource assigned.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@VisibleForTesting&lt;br/&gt;
    +	public CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
    +		final Collection&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs();&lt;br/&gt;
    +		final CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationsFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +		switch(locationPreferenceConstraint) {&lt;br/&gt;
    +			case ALL:&lt;br/&gt;
    +				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures);&lt;br/&gt;
    +				break;&lt;br/&gt;
    +			case ANY:&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    If I read it correctly, case `ANY` can complete without any input being ready (all being not yet done), returning a completed future with an empty collection. Is that intended semantics?&lt;/p&gt;</comment>
                            <comment id="16235103" author="githubbot" created="Thu, 2 Nov 2017 03:02:56 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148434074&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148434074&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -878,113 +880,70 @@ private void scheduleEager(SlotProvider slotProvider, final Time timeout) {&lt;br/&gt;
     		// that way we do not have any operation that can fail between allocating the slots&lt;br/&gt;
     		// and adding them to the list. If we had a failure in between there, that would&lt;br/&gt;
     		// cause the slots to get lost&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final ArrayList&amp;lt;ExecutionAndSlot[]&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
     		final boolean queued = allowQueuedScheduling;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// we use this flag to handle failures in a &apos;finally&apos; clause&lt;/li&gt;
	&lt;li&gt;// that allows us to not go through clumsy cast-and-rethrow logic&lt;/li&gt;
	&lt;li&gt;boolean successful = false;&lt;br/&gt;
    +		// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
    +		final ArrayList&amp;lt;CompletableFuture&amp;lt;Execution&amp;gt;&amp;gt; allAllocationFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;// collecting all the slots may resize and fail in that operation without slots getting lost&lt;/li&gt;
	&lt;li&gt;final ArrayList&amp;lt;CompletableFuture&amp;lt;SimpleSlot&amp;gt;&amp;gt; slotFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +		// allocate the slots (obtain all their futures&lt;br/&gt;
    +		for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
    +			// these calls are not blocking, they only return futures
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Aha, just by the way, scheduling according to the weight maybe not a bad choice. For both state and inputs, we can weigh them (maybe can weigh state according to it&apos;s size and weigh inputs according to it&apos;s throughput), then schedule according to the weight. &lt;/p&gt;

&lt;p&gt;    This method can be easy to extend for other factors that we want to take account in scheduler.&lt;/p&gt;</comment>
                            <comment id="16235130" author="githubbot" created="Thu, 2 Nov 2017 03:40:43 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148437379&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148437379&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java &amp;#8212;&lt;br/&gt;
    @@ -476,14 +482,13 @@ else if (numSources &amp;lt; parallelism) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@return The preferred locations based in input streams, or an empty iterable,&lt;/li&gt;
	&lt;li&gt;if there is no input-based preference.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public Iterable&amp;lt;TaskManagerLocation&amp;gt; getPreferredLocationsBasedOnInputs() {&lt;br/&gt;
    +	public Collection&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; getPreferredLocationsBasedOnInputs() {&lt;br/&gt;
     		// otherwise, base the preferred locations on the input connections&lt;br/&gt;
     		if (inputEdges == null) 
{
     			return Collections.emptySet();
     		}
&lt;p&gt;     		else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;Set&amp;lt;TaskManagerLocation&amp;gt; locations = new HashSet&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;Set&amp;lt;TaskManagerLocation&amp;gt; inputLocations = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
    +			Set&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; inputLocations = new HashSet&amp;lt;&amp;gt;(4);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I think if we weigh inputs in scheduler maybe this problem can be solved. In above example, imagine that, a is &quot;broadcast&quot; and it downstream&#8216;s parallelism is 10, and b is &quot;forward&quot; , then every ExecutionEdge for a&apos;s weight is ```a-total-weight / 10``` and ExecutionEdge of b&apos;s weight is ```b-total-weight / 1```, we can evaluate total weight according to vertex&apos;s throughput, currently, all vertex&apos;s total weight are equal, so location of b&apos;s input will be picked.&lt;/p&gt;</comment>
                            <comment id="16235426" author="githubbot" created="Thu, 2 Nov 2017 09:06:31 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148473280&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148473280&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java &amp;#8212;&lt;br/&gt;
    @@ -126,9 +134,11 @@&lt;br/&gt;
     	/** A future that completes once the Execution reaches a terminal ExecutionState */&lt;br/&gt;
     	private final CompletableFuture&amp;lt;ExecutionState&amp;gt; terminationFuture;&lt;/p&gt;

&lt;p&gt;    +	private final CompletableFuture&amp;lt;TaskManagerLocation&amp;gt; taskManagerLocationFuture;&lt;br/&gt;
    +&lt;br/&gt;
     	private volatile ExecutionState state = CREATED;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private volatile SimpleSlot assignedResource;     // once assigned, never changes until the execution is archived&lt;br/&gt;
    +	private final AtomicReference&amp;lt;SimpleSlot&amp;gt; assignedResource;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Good point. I&apos;ll change it.&lt;/p&gt;</comment>
                            <comment id="16235427" author="githubbot" created="Thu, 2 Nov 2017 09:07:10 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148473363&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148473363&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java &amp;#8212;&lt;br/&gt;
    @@ -220,14 +233,54 @@ public long getGlobalModVersion() &lt;/p&gt;
{
     		return globalModVersion;
     	}

&lt;p&gt;    +	public CompletableFuture&amp;lt;TaskManagerLocation&amp;gt; getTaskManagerLocationFuture() &lt;/p&gt;
{
    +		return taskManagerLocationFuture;
    +	}
&lt;p&gt;    +&lt;br/&gt;
     	public SimpleSlot getAssignedResource() &lt;/p&gt;
{
    -		return assignedResource;
    +		return assignedResource.get();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Tries to assign the given slot to the execution. The assignment works only if the&lt;br/&gt;
    +	 * Execution is in state SCHEDULED. Returns true, if the resource could be assigned.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param slot to assign to this execution&lt;br/&gt;
    +	 * @return true if the slot could be assigned to the execution, otherwise false&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@VisibleForTesting&lt;br/&gt;
    +	boolean tryAssignResource(final SimpleSlot slot) {&lt;br/&gt;
    +		Preconditions.checkNotNull(slot);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Sure, will reformat it accordingly.&lt;/p&gt;</comment>
                            <comment id="16235429" author="githubbot" created="Thu, 2 Nov 2017 09:09:42 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148473906&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148473906&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java &amp;#8212;&lt;br/&gt;
    @@ -1065,6 +1177,46 @@ private void sendUpdatePartitionInfoRpcCall(&lt;br/&gt;
     	//  Miscellaneous&lt;br/&gt;
     	// --------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * Calculates the preferred locations based on the location preference constraint.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param locationPreferenceConstraint constraint for the location preference&lt;br/&gt;
    +	 * @return Future containing the collection of preferred locations. This might not be completed if not all inputs&lt;br/&gt;
    +	 * 		have been a resource assigned.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@VisibleForTesting&lt;br/&gt;
    +	public CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
    +		final Collection&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs();&lt;br/&gt;
    +		final CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationsFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +		switch(locationPreferenceConstraint) {&lt;br/&gt;
    +			case ALL:&lt;br/&gt;
    +				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures);&lt;br/&gt;
    +				break;&lt;br/&gt;
    +			case ANY:&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Yes that is the semantics of `ANY` at the moment. You basically do the scheduling decision based on what you currently know. In the worst case, you don&apos;t know any input location yet. I had to introduce this mode for lazy scheduling. In this case, however, you should always know at least one input location.&lt;/p&gt;</comment>
                            <comment id="16235434" author="githubbot" created="Thu, 2 Nov 2017 09:12:20 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148474427&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148474427&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java &amp;#8212;&lt;br/&gt;
    @@ -1065,6 +1177,46 @@ private void sendUpdatePartitionInfoRpcCall(&lt;br/&gt;
     	//  Miscellaneous&lt;br/&gt;
     	// --------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * Calculates the preferred locations based on the location preference constraint.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param locationPreferenceConstraint constraint for the location preference&lt;br/&gt;
    +	 * @return Future containing the collection of preferred locations. This might not be completed if not all inputs&lt;br/&gt;
    +	 * 		have been a resource assigned.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@VisibleForTesting&lt;br/&gt;
    +	public CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
    +		final Collection&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs();&lt;br/&gt;
    +		final CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationsFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +		switch(locationPreferenceConstraint) {&lt;br/&gt;
    +			case ALL:&lt;br/&gt;
    +				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures);&lt;br/&gt;
    +				break;&lt;br/&gt;
    +			case ANY:&lt;br/&gt;
    +				final ArrayList&amp;lt;TaskManagerLocation&amp;gt; completedTaskManagerLocations = new ArrayList&amp;lt;&amp;gt;(1);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    No, the intention is to return all currently known locations here. Usually there will only be one input because `ANY` is used by lazy scheduling. Initializing it with size 1 is a compromise between size and resizing costs. We could also initialize it with the number of inputs (since this is a small number) but in most cases not all inputs will be known for `ANY`.&lt;/p&gt;</comment>
                            <comment id="16235435" author="githubbot" created="Thu, 2 Nov 2017 09:13:02 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148474569&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148474569&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/resources/log4j-test.properties &amp;#8212;&lt;br/&gt;
    @@ -16,7 +16,7 @@&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
     ################################################################################&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    -log4j.rootLogger=OFF, console&lt;br/&gt;
    +log4j.rootLogger=INFO, console&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Good catch. Will revert it.&lt;/p&gt;</comment>
                            <comment id="16235436" author="githubbot" created="Thu, 2 Nov 2017 09:13:34 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148474674&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148474674&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/Scheduler.java &amp;#8212;&lt;br/&gt;
    @@ -133,32 +133,33 @@ public void shutdown() {&lt;/p&gt;


&lt;p&gt;     	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public CompletableFuture&amp;lt;SimpleSlot&amp;gt; allocateSlot(ScheduledUnit task, boolean allowQueued) {&lt;br/&gt;
    +	public CompletableFuture&amp;lt;SimpleSlot&amp;gt; allocateSlot(&lt;br/&gt;
    +			ScheduledUnit task,&lt;br/&gt;
    +			boolean allowQueued,&lt;br/&gt;
    +			Collection&amp;lt;TaskManagerLocation&amp;gt; preferredLocations) {&lt;br/&gt;
    +&lt;br/&gt;
     		try {&lt;/li&gt;
	&lt;li&gt;final Object ret = scheduleTask(task, allowQueued);&lt;br/&gt;
    +			final Object ret = scheduleTask(task, allowQueued, preferredLocations);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     			if (ret instanceof SimpleSlot) &lt;/p&gt;
{
     				return CompletableFuture.completedFuture((SimpleSlot) ret);
    -			}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;else if (ret instanceof CompletableFuture) 
{
    +			}
&lt;p&gt; else if (ret instanceof CompletableFuture) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Beauty lies in the eye of the bee holder &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I&apos;ll revert it.&lt;/p&gt;</comment>
                            <comment id="16235445" author="githubbot" created="Thu, 2 Nov 2017 09:25:08 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148477247&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148477247&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java &amp;#8212;&lt;br/&gt;
    @@ -476,14 +482,13 @@ else if (numSources &amp;lt; parallelism) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@return The preferred locations based in input streams, or an empty iterable,&lt;/li&gt;
	&lt;li&gt;if there is no input-based preference.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public Iterable&amp;lt;TaskManagerLocation&amp;gt; getPreferredLocationsBasedOnInputs() {&lt;br/&gt;
    +	public Collection&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; getPreferredLocationsBasedOnInputs() {&lt;br/&gt;
     		// otherwise, base the preferred locations on the input connections&lt;br/&gt;
     		if (inputEdges == null) 
{
     			return Collections.emptySet();
     		}
&lt;p&gt;     		else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;Set&amp;lt;TaskManagerLocation&amp;gt; locations = new HashSet&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;Set&amp;lt;TaskManagerLocation&amp;gt; inputLocations = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
    +			Set&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; inputLocations = new HashSet&amp;lt;&amp;gt;(4);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This change was not entirely intended and the previous code makes totally sense with your explanation. I&apos;m actually in favour of reverting my changes to not change the semantics for the moment.&lt;/p&gt;

&lt;p&gt;    However, for the future, I&apos;m wondering whether this kind of decision should be made by the `ExecutionVertex` or whether it shouldn&apos;t rather be the task of the `Scheduler` to make this kind of decision. &lt;/p&gt;

&lt;p&gt;    For example, what if a task has multiple input gates and one of them with exactly one producer. Then it will only return the location of this single producer. Now if this TM has no more slots left, then we would basically randomly pick another slot even though there might be other TMs one which another producer for this task would run.&lt;/p&gt;</comment>
                            <comment id="16235458" author="githubbot" created="Thu, 2 Nov 2017 09:36:26 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148479985&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148479985&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java &amp;#8212;&lt;br/&gt;
    @@ -476,14 +482,13 @@ else if (numSources &amp;lt; parallelism) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@return The preferred locations based in input streams, or an empty iterable,&lt;/li&gt;
	&lt;li&gt;if there is no input-based preference.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public Iterable&amp;lt;TaskManagerLocation&amp;gt; getPreferredLocationsBasedOnInputs() {&lt;br/&gt;
    +	public Collection&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; getPreferredLocationsBasedOnInputs() {&lt;br/&gt;
     		// otherwise, base the preferred locations on the input connections&lt;br/&gt;
     		if (inputEdges == null) 
{
     			return Collections.emptySet();
     		}
&lt;p&gt;     		else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;Set&amp;lt;TaskManagerLocation&amp;gt; locations = new HashSet&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;Set&amp;lt;TaskManagerLocation&amp;gt; inputLocations = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
    +			Set&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; inputLocations = new HashSet&amp;lt;&amp;gt;(4);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    For example in the case of the broadcast join with lazy scheduling, it could be the case that the broadcasting operator produces first and thus triggers the `scheduleOrUpdateConsumers` call on the `ExecutionGraph`. This will then trigger the scheduling of the join operator. At this time, there might only be the location of the broadcast operator known. However, since we only return the forward operator&apos;s location future which has not been completed, the lazy scheduling will schedule without location preference because the `LocationPreferenceConstraint` is `ANY`.&lt;/p&gt;</comment>
                            <comment id="16235468" author="githubbot" created="Thu, 2 Nov 2017 09:48:28 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148482755&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148482755&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java &amp;#8212;&lt;br/&gt;
    @@ -1065,6 +1177,46 @@ private void sendUpdatePartitionInfoRpcCall(&lt;br/&gt;
     	//  Miscellaneous&lt;br/&gt;
     	// --------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * Calculates the preferred locations based on the location preference constraint.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param locationPreferenceConstraint constraint for the location preference&lt;br/&gt;
    +	 * @return Future containing the collection of preferred locations. This might not be completed if not all inputs&lt;br/&gt;
    +	 * 		have been a resource assigned.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@VisibleForTesting&lt;br/&gt;
    +	public CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
    +		final Collection&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs();&lt;br/&gt;
    +		final CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationsFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +		switch(locationPreferenceConstraint) {&lt;br/&gt;
    +			case ALL:&lt;br/&gt;
    +				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures);&lt;br/&gt;
    +				break;&lt;br/&gt;
    +			case ANY:&lt;br/&gt;
    +				final ArrayList&amp;lt;TaskManagerLocation&amp;gt; completedTaskManagerLocations = new ArrayList&amp;lt;&amp;gt;(1);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Maybe it&apos;s better to initialize the array with the number of returned futures to avoid resizing completely.&lt;/p&gt;</comment>
                            <comment id="16235477" author="githubbot" created="Thu, 2 Nov 2017 09:59:27 +0000"  >&lt;p&gt;Github user tillrohrmann commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks a lot for your review @StephanEwen and @sihuazhou. I&apos;ve addressed all your comments @StephanEwen. &lt;/p&gt;

&lt;p&gt;    Next thing I&apos;ll do is to rebase onto the latest master and if Travis gives green light and you have no further objections, then I would like to merge it.&lt;/p&gt;</comment>
                            <comment id="16235689" author="githubbot" created="Thu, 2 Nov 2017 13:06:33 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148526103&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148526103&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java &amp;#8212;&lt;br/&gt;
    @@ -1065,6 +1177,46 @@ private void sendUpdatePartitionInfoRpcCall(&lt;br/&gt;
     	//  Miscellaneous&lt;br/&gt;
     	// --------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * Calculates the preferred locations based on the location preference constraint.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param locationPreferenceConstraint constraint for the location preference&lt;br/&gt;
    +	 * @return Future containing the collection of preferred locations. This might not be completed if not all inputs&lt;br/&gt;
    +	 * 		have been a resource assigned.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@VisibleForTesting&lt;br/&gt;
    +	public CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; calculatePreferredLocations(LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
    +		final Collection&amp;lt;CompletableFuture&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationFutures = getVertex().getPreferredLocationsBasedOnInputs();&lt;br/&gt;
    +		final CompletableFuture&amp;lt;Collection&amp;lt;TaskManagerLocation&amp;gt;&amp;gt; preferredLocationsFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +		switch(locationPreferenceConstraint) {&lt;br/&gt;
    +			case ALL:&lt;br/&gt;
    +				preferredLocationsFuture = FutureUtils.combineAll(preferredLocationFutures);&lt;br/&gt;
    +				break;&lt;br/&gt;
    +			case ANY:&lt;br/&gt;
    +				final ArrayList&amp;lt;TaskManagerLocation&amp;gt; completedTaskManagerLocations = new ArrayList&amp;lt;&amp;gt;(1);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I would almost leave it at `1` or at the default `10`, so as to not have large unused arrays lying around.&lt;/p&gt;</comment>
                            <comment id="16235690" author="githubbot" created="Thu, 2 Nov 2017 13:06:56 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916#discussion_r148526210&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916#discussion_r148526210&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/Scheduler.java &amp;#8212;&lt;br/&gt;
    @@ -133,32 +133,33 @@ public void shutdown() {&lt;/p&gt;


&lt;p&gt;     	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public CompletableFuture&amp;lt;SimpleSlot&amp;gt; allocateSlot(ScheduledUnit task, boolean allowQueued) {&lt;br/&gt;
    +	public CompletableFuture&amp;lt;SimpleSlot&amp;gt; allocateSlot(&lt;br/&gt;
    +			ScheduledUnit task,&lt;br/&gt;
    +			boolean allowQueued,&lt;br/&gt;
    +			Collection&amp;lt;TaskManagerLocation&amp;gt; preferredLocations) {&lt;br/&gt;
    +&lt;br/&gt;
     		try {&lt;/li&gt;
	&lt;li&gt;final Object ret = scheduleTask(task, allowQueued);&lt;br/&gt;
    +			final Object ret = scheduleTask(task, allowQueued, preferredLocations);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     			if (ret instanceof SimpleSlot) &lt;/p&gt;
{
     				return CompletableFuture.completedFuture((SimpleSlot) ret);
    -			}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;else if (ret instanceof CompletableFuture) 
{
    +			}
&lt;p&gt; else if (ret instanceof CompletableFuture) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    No worries, just teasing here &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16235780" author="githubbot" created="Thu, 2 Nov 2017 14:02:46 +0000"  >&lt;p&gt;Github user StephanEwen commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for the follow-up!&lt;/p&gt;

&lt;p&gt;    +1 to merge this&lt;/p&gt;</comment>
                            <comment id="16236125" author="till.rohrmann" created="Thu, 2 Nov 2017 17:02:32 +0000"  >&lt;p&gt;Fixed via 3b0fb26bfb779a98f8dcadbb4a7ba206e11f9c2c&lt;/p&gt;</comment>
                            <comment id="16236126" author="githubbot" created="Thu, 2 Nov 2017 17:02:41 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4916&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4916&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310361">
                    <name>Blocked</name>
                                            <outwardlinks description="Blocked">
                                        <issuelink>
            <issuekey id="13087937">FLINK-7218</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13087939">FLINK-7219</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="13110238">FLINK-7866</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 2 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3hd8v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>