<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:30:23 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-7757] RocksDB lock is too strict and can block snapshots in synchronous phase</title>
                <link>https://issues.apache.org/jira/browse/FLINK-7757</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;&lt;tt&gt;RocksDBKeyedStateBackend&lt;/tt&gt; uses a lock to guard the db instance against disposal of the native resources while some parallel threads might still access db, which might otherwise lead to segfaults.&lt;/p&gt;

&lt;p&gt;Unfortunately, this locking is a bit to strict and can lead to situations where snapshots block the pipeline. This can happen when a snapshot s1 is running and somewhere blocking in IO while holding the guarding lock. A second snapshot s2 can be triggered in parallel and requires to hold the lock in the synchronous part to get a snapshot from db. As s1 is still holding on to the lock, s2 can block here and stop the operator from processing further elements.&lt;/p&gt;

&lt;p&gt;A simple solution could remove lock acquisition from the synchronous phase, because both, synchronous phase and disposing the backend are only allowed to be triggered from the thread that also drives element processing.&lt;/p&gt;

&lt;p&gt;A better solution would be to remove long sections under the lock all together, because as of now they will always prevent the possibility of parallel checkpointing. I think a guard for the rocksdb instance would be sufficient that blocks disposal for as long as there are still clients potentially accessing the instance in parallel. This could be realized by keeping a synchronized counter for active clients and block disposal until the client count drops to zero.&lt;/p&gt;

&lt;p&gt;This approach could also be integrated with triggering timers, which have always been problematic in the disposal phase are currently unregulated. In the new model, they could register as yet another client.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13106701">FLINK-7757</key>
            <summary>RocksDB lock is too strict and can block snapshots in synchronous phase</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="srichter">Stefan Richter</assignee>
                                    <reporter username="srichter">Stefan Richter</reporter>
                        <labels>
                    </labels>
                <created>Tue, 3 Oct 2017 13:47:59 +0000</created>
                <updated>Wed, 18 Oct 2017 10:25:24 +0000</updated>
                            <resolved>Wed, 18 Oct 2017 10:25:24 +0000</resolved>
                                    <version>1.2.2</version>
                    <version>1.3.2</version>
                                    <fixVersion>1.4.0</fixVersion>
                                    <component>Runtime / State Backends</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="16189864" author="githubbot" created="Tue, 3 Oct 2017 15:35:49 +0000"  >&lt;p&gt;GitHub user StefanRRichter opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7757&quot; title=&quot;RocksDB lock is too strict and can block snapshots in synchronous phase&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7757&quot;&gt;&lt;del&gt;FLINK-7757&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;checkpointing&amp;#93;&lt;/span&gt; Introduce resource guard for RocksDBKeye&#8230;&lt;/p&gt;

&lt;p&gt;    &#8230;dStateBackend to reduce locking and avoid blocking behavior.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    `RocksDBKeyedStateBackend` uses a lock to guard the db instance against disposal of the native resources while some parallel threads might still access db, which might otherwise lead to segfaults.&lt;/p&gt;

&lt;p&gt;    Unfortunately, this locking is a bit to strict and can lead to situations where snapshots block the pipeline. This can happen when a snapshot s1 is running and somewhere blocking in IO while holding the guarding lock. A second snapshot s2 can be triggered in parallel and requires to hold the lock in the synchronous part to get a snapshot from db. As s1 is still holding on to the lock, s2 can block here and stop the operator from processing further elements.&lt;br/&gt;
    A simple solution could remove lock acquisition from the synchronous phase, because both, synchronous phase and disposing the backend are only allowed to be triggered from the thread that also drives element processing.&lt;/p&gt;

&lt;p&gt;    This PR removes long sections under the lock all together, to open up the possibility of parallel checkpointing. The change introduces a guard for the rocksdb instance that blocks disposal for as long as there are still clients potentially accessing the instance in parallel. This is realized by keeping a synchronized counter for active clients and block disposal until the client count drops to zero.&lt;/p&gt;

&lt;p&gt;    This approach could also be integrated with triggering timers, which have always been problematic in the disposal phase are currently unregulated. In the new model, they could register as yet another client.&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;b&gt;Introduce a class `ResourceGuard` as client counter&lt;/b&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Replaced use of `asyncSnapshotLock` with the guard&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This change is mostly covered by existing tests.&lt;/p&gt;

&lt;p&gt;    I added unit test `ResourceGuardTest` and `StateBackendTestBase::testParallelAsyncSnapshots` to ensure that parallel snapshots work.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (no)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (no)&lt;/li&gt;
	&lt;li&gt;The serializers: (no)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (no)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (yes)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (no)&lt;/li&gt;
&lt;/ul&gt;




&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/StefanRRichter/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/StefanRRichter/flink&lt;/a&gt; rocksdb-guard&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4764&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 13824b726dfdae2954840baf4d114ccc7963f484&lt;br/&gt;
Author: Stefan Richter &amp;lt;s.richter@data-artisans.com&amp;gt;&lt;br/&gt;
Date:   2017-10-03T13:37:58Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7757&quot; title=&quot;RocksDB lock is too strict and can block snapshots in synchronous phase&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7757&quot;&gt;&lt;del&gt;FLINK-7757&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;checkpointing&amp;#93;&lt;/span&gt; Introduce resource guard for RocksDBKeyedStateBackend to reduce locking and avoid blocking behavior.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16189867" author="githubbot" created="Tue, 3 Oct 2017 15:36:59 +0000"  >&lt;p&gt;Github user StefanRRichter commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    CC @aljoscha &lt;/p&gt;</comment>
                            <comment id="16190149" author="githubbot" created="Tue, 3 Oct 2017 18:54:07 +0000"  >&lt;p&gt;Github user GJL commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r142490404&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r142490404&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/util/ResourceGuard.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,130 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.util;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.io.Serializable;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * This class is a guard for shared resources with the following invariants. The resource can be acquired by multiple&lt;br/&gt;
    + * clients in parallel through the &lt;/p&gt;
{@link #acquireResource()} call. Clients must release the resource after usage&lt;br/&gt;
    + * with a matching call to {@link #releaseResource()}. The resource can only be disposed once the guard is closed, but&lt;br/&gt;
    + * the guard can only be closed once all clients that acquired the resource have released it. Before this is happened,&lt;br/&gt;
    + * the call to {@link #close()} will block until the condition is triggered. After the guard is closed, calls to&lt;br/&gt;
    + * {@link #acquireResource()}
&lt;p&gt; will fail with exception. Notice that, obviously clients are responsible to release the&lt;br/&gt;
    + * resource after usage. All clients are considered equal, i.e. there is only a global count maintained how many&lt;br/&gt;
    + * times the resource was acquired but not by whom.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class ResourceGuard implements AutoCloseable, Serializable {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final long serialVersionUID = 1L;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Introduced additional checks of invariants.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private static final boolean STRICT_CHECKS = true;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * The object that serves as lock for count and the closed-flag.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private final SerializableObject lock;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Number of clients that have ongoing access to the resource.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private int clientCount;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This flag indicated if it is still possible to acquire access to the resource.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private volatile boolean closed;&lt;br/&gt;
    +&lt;br/&gt;
    +	public ResourceGuard() &lt;/p&gt;
{
    +		this.lock = new SerializableObject();
    +		this.clientCount = 0;
    +		this.closed = false;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Acquired access from one new client for the guarded resource.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @throws IOException when the resource guard is already closed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void acquireResource() throws IOException {&lt;br/&gt;
    +&lt;br/&gt;
    +		synchronized (lock) {&lt;br/&gt;
    +&lt;br/&gt;
    +			if (closed) &lt;/p&gt;
{
    +				throw new IOException(&quot;Resource guard was already closed.&quot;);
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			++clientCount;&lt;br/&gt;
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Releases access for one client of the guarded resource. This method must only be called after a matching call to&lt;br/&gt;
    +	 * &lt;/p&gt;
{@link #acquireResource()}.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void releaseResource() {&lt;br/&gt;
    +&lt;br/&gt;
    +		synchronized (lock) {&lt;br/&gt;
    +&lt;br/&gt;
    +			if (STRICT_CHECKS &amp;amp;&amp;amp; clientCount &amp;lt;= 0) {
    +				throw new IllegalStateException(&quot;Resource guard was released more times than it has been acquired!&quot;);
    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +			--clientCount;&lt;br/&gt;
    +&lt;br/&gt;
    +			if (closed &amp;amp;&amp;amp; clientCount == 0) {
    +				lock.notifyAll();
    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Closed the resource guard. This method will block until all calls to {@link #acquireResource()}
&lt;p&gt; have seen their&lt;br/&gt;
    +	 * matching call to &lt;/p&gt;
{@link #releaseResource()}
&lt;p&gt;.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void close() {&lt;br/&gt;
    +&lt;br/&gt;
    +		synchronized (lock) {&lt;br/&gt;
    +&lt;br/&gt;
    +			closed = true;&lt;br/&gt;
    +&lt;br/&gt;
    +			while (clientCount &amp;gt; 0) {&lt;br/&gt;
    +&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					lock.wait();
    +				}
&lt;p&gt; catch (InterruptedException e) {&lt;br/&gt;
    +					Thread.interrupted();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This line caught my eye.&lt;br/&gt;
    ```&lt;br/&gt;
    public static boolean interrupted()&lt;br/&gt;
    ```&lt;br/&gt;
    &amp;gt; Tests whether the current thread has been interrupted. &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;    The boolean result is not used and when `InterruptedException` is thrown, the interrupt flag is cleared, so the method should return `false` here.&lt;/p&gt;

&lt;p&gt;    Did you intend to call `Thread.currentThread().interrupt()` and exit the `while` loop prematurely?&lt;/p&gt;</comment>
                            <comment id="16190155" author="githubbot" created="Tue, 3 Oct 2017 18:59:49 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r142492040&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r142492040&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/util/ResourceGuard.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,130 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.util;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.io.Serializable;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * This class is a guard for shared resources with the following invariants. The resource can be acquired by multiple&lt;br/&gt;
    + * clients in parallel through the &lt;/p&gt;
{@link #acquireResource()} call. Clients must release the resource after usage&lt;br/&gt;
    + * with a matching call to {@link #releaseResource()}. The resource can only be disposed once the guard is closed, but&lt;br/&gt;
    + * the guard can only be closed once all clients that acquired the resource have released it. Before this is happened,&lt;br/&gt;
    + * the call to {@link #close()} will block until the condition is triggered. After the guard is closed, calls to&lt;br/&gt;
    + * {@link #acquireResource()}
&lt;p&gt; will fail with exception. Notice that, obviously clients are responsible to release the&lt;br/&gt;
    + * resource after usage. All clients are considered equal, i.e. there is only a global count maintained how many&lt;br/&gt;
    + * times the resource was acquired but not by whom.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class ResourceGuard implements AutoCloseable, Serializable {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final long serialVersionUID = 1L;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Introduced additional checks of invariants.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private static final boolean STRICT_CHECKS = true;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * The object that serves as lock for count and the closed-flag.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private final SerializableObject lock;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Number of clients that have ongoing access to the resource.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private int clientCount;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This flag indicated if it is still possible to acquire access to the resource.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private volatile boolean closed;&lt;br/&gt;
    +&lt;br/&gt;
    +	public ResourceGuard() &lt;/p&gt;
{
    +		this.lock = new SerializableObject();
    +		this.clientCount = 0;
    +		this.closed = false;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Acquired access from one new client for the guarded resource.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @throws IOException when the resource guard is already closed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void acquireResource() throws IOException {&lt;br/&gt;
    +&lt;br/&gt;
    +		synchronized (lock) {&lt;br/&gt;
    +&lt;br/&gt;
    +			if (closed) &lt;/p&gt;
{
    +				throw new IOException(&quot;Resource guard was already closed.&quot;);
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			++clientCount;&lt;br/&gt;
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Releases access for one client of the guarded resource. This method must only be called after a matching call to&lt;br/&gt;
    +	 * &lt;/p&gt;
{@link #acquireResource()}.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void releaseResource() {&lt;br/&gt;
    +&lt;br/&gt;
    +		synchronized (lock) {&lt;br/&gt;
    +&lt;br/&gt;
    +			if (STRICT_CHECKS &amp;amp;&amp;amp; clientCount &amp;lt;= 0) {
    +				throw new IllegalStateException(&quot;Resource guard was released more times than it has been acquired!&quot;);
    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +			--clientCount;&lt;br/&gt;
    +&lt;br/&gt;
    +			if (closed &amp;amp;&amp;amp; clientCount == 0) {
    +				lock.notifyAll();
    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Closed the resource guard. This method will block until all calls to {@link #acquireResource()}
&lt;p&gt; have seen their&lt;br/&gt;
    +	 * matching call to &lt;/p&gt;
{@link #releaseResource()}
&lt;p&gt;.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void close() {&lt;br/&gt;
    +&lt;br/&gt;
    +		synchronized (lock) {&lt;br/&gt;
    +&lt;br/&gt;
    +			closed = true;&lt;br/&gt;
    +&lt;br/&gt;
    +			while (clientCount &amp;gt; 0) {&lt;br/&gt;
    +&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					lock.wait();
    +				}
&lt;p&gt; catch (InterruptedException e) {&lt;br/&gt;
    +					Thread.interrupted();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    No, exactly this method was my intention. The API is very bad, but I am not interested in the result (because it is already clear here). What I am interested in is the side effect to clear the interrupted flag. If this is not cleared, future calls to `wait` trigger the interrupted exception again.&lt;/p&gt;</comment>
                            <comment id="16190167" author="githubbot" created="Tue, 3 Oct 2017 19:07:44 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r142493960&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r142493960&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/util/ResourceGuard.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,130 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.util;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.io.Serializable;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * This class is a guard for shared resources with the following invariants. The resource can be acquired by multiple&lt;br/&gt;
    + * clients in parallel through the &lt;/p&gt;
{@link #acquireResource()} call. Clients must release the resource after usage&lt;br/&gt;
    + * with a matching call to {@link #releaseResource()}. The resource can only be disposed once the guard is closed, but&lt;br/&gt;
    + * the guard can only be closed once all clients that acquired the resource have released it. Before this is happened,&lt;br/&gt;
    + * the call to {@link #close()} will block until the condition is triggered. After the guard is closed, calls to&lt;br/&gt;
    + * {@link #acquireResource()}
&lt;p&gt; will fail with exception. Notice that, obviously clients are responsible to release the&lt;br/&gt;
    + * resource after usage. All clients are considered equal, i.e. there is only a global count maintained how many&lt;br/&gt;
    + * times the resource was acquired but not by whom.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class ResourceGuard implements AutoCloseable, Serializable {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final long serialVersionUID = 1L;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Introduced additional checks of invariants.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private static final boolean STRICT_CHECKS = true;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * The object that serves as lock for count and the closed-flag.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private final SerializableObject lock;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Number of clients that have ongoing access to the resource.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private int clientCount;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This flag indicated if it is still possible to acquire access to the resource.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private volatile boolean closed;&lt;br/&gt;
    +&lt;br/&gt;
    +	public ResourceGuard() &lt;/p&gt;
{
    +		this.lock = new SerializableObject();
    +		this.clientCount = 0;
    +		this.closed = false;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Acquired access from one new client for the guarded resource.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @throws IOException when the resource guard is already closed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void acquireResource() throws IOException {&lt;br/&gt;
    +&lt;br/&gt;
    +		synchronized (lock) {&lt;br/&gt;
    +&lt;br/&gt;
    +			if (closed) &lt;/p&gt;
{
    +				throw new IOException(&quot;Resource guard was already closed.&quot;);
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			++clientCount;&lt;br/&gt;
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Releases access for one client of the guarded resource. This method must only be called after a matching call to&lt;br/&gt;
    +	 * &lt;/p&gt;
{@link #acquireResource()}.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void releaseResource() {&lt;br/&gt;
    +&lt;br/&gt;
    +		synchronized (lock) {&lt;br/&gt;
    +&lt;br/&gt;
    +			if (STRICT_CHECKS &amp;amp;&amp;amp; clientCount &amp;lt;= 0) {
    +				throw new IllegalStateException(&quot;Resource guard was released more times than it has been acquired!&quot;);
    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +			--clientCount;&lt;br/&gt;
    +&lt;br/&gt;
    +			if (closed &amp;amp;&amp;amp; clientCount == 0) {
    +				lock.notifyAll();
    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Closed the resource guard. This method will block until all calls to {@link #acquireResource()}
&lt;p&gt; have seen their&lt;br/&gt;
    +	 * matching call to &lt;/p&gt;
{@link #releaseResource()}
&lt;p&gt;.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void close() {&lt;br/&gt;
    +&lt;br/&gt;
    +		synchronized (lock) {&lt;br/&gt;
    +&lt;br/&gt;
    +			closed = true;&lt;br/&gt;
    +&lt;br/&gt;
    +			while (clientCount &amp;gt; 0) {&lt;br/&gt;
    +&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					lock.wait();
    +				}
&lt;p&gt; catch (InterruptedException e) {&lt;br/&gt;
    +					Thread.interrupted();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Just double checked, seems like I remembered incorrectly and this call is not needed here because the flag is reset already by the triggered exception.&lt;/p&gt;</comment>
                            <comment id="16190804" author="githubbot" created="Wed, 4 Oct 2017 04:43:31 +0000"  >&lt;p&gt;Github user bowenli86 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r142579521&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r142579521&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -356,28 +354,26 @@ public int getKeyGroupPrefixBytes() {&lt;br/&gt;
     		final long checkpointTimestamp,&lt;br/&gt;
     		final CheckpointStreamFactory checkpointStreamFactory) throws Exception {&lt;/p&gt;

&lt;p&gt;    +		if (db == null) {&lt;br/&gt;
    +			throw new IOException(&quot;RocksDB closed.&quot;);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This exception message looks a bit odd to me. Can you please enrich the message? E.g. &quot;RocksDB has been closed expected. &amp;lt;suggestion for a solution&amp;gt;&quot;?&lt;/p&gt;</comment>
                            <comment id="16190813" author="githubbot" created="Wed, 4 Oct 2017 04:52:32 +0000"  >&lt;p&gt;Github user bowenli86 commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    The implementation of having s2 `acquire()` a lock while s1 still holds that lock seems problematic to me. Why not making it a `tryAcquire()`, as that in java semaphore? &lt;/p&gt;</comment>
                            <comment id="16190837" author="githubbot" created="Wed, 4 Oct 2017 05:34:06 +0000"  >&lt;p&gt;Github user StefanRRichter commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @bowenli86 Can you go into detail what kind of problem you have in mind? This class does not work like a semaphore, i.e. `acquire` never truly blocks. It is just incrementing a count and does not represent a lock that can be held long time.&lt;/p&gt;</comment>
                            <comment id="16190872" author="githubbot" created="Wed, 4 Oct 2017 06:21:17 +0000"  >&lt;p&gt;Github user bowenli86 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r142588647&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r142588647&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/util/ResourceGuard.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,129 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.util;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.io.Serializable;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * This class is a guard for shared resources with the following invariants. The resource can be acquired by multiple&lt;br/&gt;
    + * clients in parallel through the &lt;/p&gt;
{@link #acquireResource()} call. Clients must release the resource after usage&lt;br/&gt;
    + * with a matching call to {@link #releaseResource()}. The resource can only be disposed once the guard is closed, but&lt;br/&gt;
    + * the guard can only be closed once all clients that acquired the resource have released it. Before this is happened,&lt;br/&gt;
    + * the call to {@link #close()} will block until the condition is triggered. After the guard is closed, calls to&lt;br/&gt;
    + * {@link #acquireResource()}
&lt;p&gt; will fail with exception. Notice that, obviously clients are responsible to release the&lt;br/&gt;
    + * resource after usage. All clients are considered equal, i.e. there is only a global count maintained how many&lt;br/&gt;
    + * times the resource was acquired but not by whom.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class ResourceGuard implements AutoCloseable, Serializable {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final long serialVersionUID = 1L;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Introduced additional checks of invariants.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private static final boolean STRICT_CHECKS = true;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * The object that serves as lock for count and the closed-flag.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private final SerializableObject lock;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Number of clients that have ongoing access to the resource.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private int clientCount;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This flag indicated if it is still possible to acquire access to the resource.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private volatile boolean closed;&lt;br/&gt;
    +&lt;br/&gt;
    +	public ResourceGuard() &lt;/p&gt;
{
    +		this.lock = new SerializableObject();
    +		this.clientCount = 0;
    +		this.closed = false;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Acquired access from one new client for the guarded resource.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @throws IOException when the resource guard is already closed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void acquireResource() throws IOException {&lt;br/&gt;
    +&lt;br/&gt;
    +		synchronized (lock) {&lt;br/&gt;
    +&lt;br/&gt;
    +			if (closed) &lt;/p&gt;
{
    +				throw new IOException(&quot;Resource guard was already closed.&quot;);
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			++clientCount;&lt;br/&gt;
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Releases access for one client of the guarded resource. This method must only be called after a matching call to&lt;br/&gt;
    +	 * &lt;/p&gt;
{@link #acquireResource()}
&lt;p&gt;.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void releaseResource() {&lt;br/&gt;
    +&lt;br/&gt;
    +		synchronized (lock) {&lt;br/&gt;
    +&lt;br/&gt;
    +			if (STRICT_CHECKS &amp;amp;&amp;amp; clientCount &amp;lt;= 0) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    What is the `STRICT_CHECKS` used for here? sorry, I haven&apos;t used invariant much in promgramming before&lt;/p&gt;</comment>
                            <comment id="16190874" author="githubbot" created="Wed, 4 Oct 2017 06:25:29 +0000"  >&lt;p&gt;Github user bowenli86 commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I was commenting on the scenario described in `What is the purpose of the change`. In that case, we want to either fail s2 or remove the lock for s2 as you did. Since we are required to support parallel snapshots, the latter should be the way to go.&lt;/p&gt;

&lt;p&gt;    LGTM &#128077; &lt;/p&gt;</comment>
                            <comment id="16190885" author="githubbot" created="Wed, 4 Oct 2017 06:53:20 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r142592523&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r142592523&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/util/ResourceGuard.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,129 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.util;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.io.Serializable;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * This class is a guard for shared resources with the following invariants. The resource can be acquired by multiple&lt;br/&gt;
    + * clients in parallel through the &lt;/p&gt;
{@link #acquireResource()} call. Clients must release the resource after usage&lt;br/&gt;
    + * with a matching call to {@link #releaseResource()}. The resource can only be disposed once the guard is closed, but&lt;br/&gt;
    + * the guard can only be closed once all clients that acquired the resource have released it. Before this is happened,&lt;br/&gt;
    + * the call to {@link #close()} will block until the condition is triggered. After the guard is closed, calls to&lt;br/&gt;
    + * {@link #acquireResource()}
&lt;p&gt; will fail with exception. Notice that, obviously clients are responsible to release the&lt;br/&gt;
    + * resource after usage. All clients are considered equal, i.e. there is only a global count maintained how many&lt;br/&gt;
    + * times the resource was acquired but not by whom.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class ResourceGuard implements AutoCloseable, Serializable {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final long serialVersionUID = 1L;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Introduced additional checks of invariants.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private static final boolean STRICT_CHECKS = true;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * The object that serves as lock for count and the closed-flag.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private final SerializableObject lock;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Number of clients that have ongoing access to the resource.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private int clientCount;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This flag indicated if it is still possible to acquire access to the resource.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private volatile boolean closed;&lt;br/&gt;
    +&lt;br/&gt;
    +	public ResourceGuard() &lt;/p&gt;
{
    +		this.lock = new SerializableObject();
    +		this.clientCount = 0;
    +		this.closed = false;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Acquired access from one new client for the guarded resource.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @throws IOException when the resource guard is already closed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void acquireResource() throws IOException {&lt;br/&gt;
    +&lt;br/&gt;
    +		synchronized (lock) {&lt;br/&gt;
    +&lt;br/&gt;
    +			if (closed) &lt;/p&gt;
{
    +				throw new IOException(&quot;Resource guard was already closed.&quot;);
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			++clientCount;&lt;br/&gt;
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Releases access for one client of the guarded resource. This method must only be called after a matching call to&lt;br/&gt;
    +	 * &lt;/p&gt;
{@link #acquireResource()}
&lt;p&gt;.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void releaseResource() {&lt;br/&gt;
    +&lt;br/&gt;
    +		synchronized (lock) {&lt;br/&gt;
    +&lt;br/&gt;
    +			if (STRICT_CHECKS &amp;amp;&amp;amp; clientCount &amp;lt;= 0) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    It is just a flag, whether or not to check that there cannot be more calls to `release()` than previous calls to `acquire`. Through the `static final boolean` in the condition, the jitter can eliminate the branch if it is deactivated.&lt;/p&gt;</comment>
                            <comment id="16198476" author="githubbot" created="Tue, 10 Oct 2017 10:23:49 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r143686824&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r143686824&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java &amp;#8212;&lt;br/&gt;
    @@ -66,14 +66,13 @@&lt;br/&gt;
     import org.apache.flink.runtime.state.internal.InternalReducingState;&lt;br/&gt;
     import org.apache.flink.runtime.state.internal.InternalValueState;&lt;br/&gt;
     import org.apache.flink.runtime.util.BlockerCheckpointStreamFactory;&lt;br/&gt;
    +import org.apache.flink.shaded.guava18.com.google.common.base.Joiner;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I don&apos;t think this will pass check style checks, if not, we still don&apos;t allow this usually. (I know that the import was already there previously &#128517; )&lt;/p&gt;</comment>
                            <comment id="16198477" author="githubbot" created="Tue, 10 Oct 2017 10:23:49 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r143685204&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r143685204&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -618,19 +600,8 @@ public void releaseSnapshotResources() &lt;/p&gt;
{
     				IOUtils.closeQuietly(readOptions);
     				readOptions = null;
     			}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Drop the created snapshot if we have ben cancelled.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public void dropSnapshotResult() {&lt;/li&gt;
	&lt;li&gt;if (null != snapshotResultStateHandle) {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;snapshotResultStateHandle.discardState();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Cleanup is now handled somewhere else?&lt;/p&gt;</comment>
                            <comment id="16198478" author="githubbot" created="Tue, 10 Oct 2017 10:23:49 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r143685630&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r143685630&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBStateBackendTest.java &amp;#8212;&lt;br/&gt;
    @@ -215,46 +215,6 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void testRunningSnapshotAfterBackendClosed() throws Exception {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This test doesn&apos;t make sense anymore because a running snapshot operation will keep the backend form closing?&lt;/p&gt;</comment>
                            <comment id="16198479" author="githubbot" created="Tue, 10 Oct 2017 10:23:49 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r143685852&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r143685852&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/util/ResourceGuard.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,152 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.util;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.io.Serializable;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * This class is a guard for shared resources with the following invariants. The resource can be acquired by multiple&lt;br/&gt;
    + * clients in parallel through the &lt;/p&gt;
{@link #acquireResource()}
&lt;p&gt; call. As a result of the call, each client gets a&lt;br/&gt;
    + * &lt;/p&gt;
{@link Lease}
&lt;p&gt;. The &lt;/p&gt;
{@link #close()} method of the lease releases the resources and reduces the client count in&lt;br/&gt;
    + * the {@link ResourceGuard} object.&lt;br/&gt;
    + * The protected resource should only be disposed once the corresponding resource guard is successfully closed, but&lt;br/&gt;
    + * the guard can only be closed once all clients that acquired a lease for the guarded resource have released it.&lt;br/&gt;
    + * Before this is happened, the call to {@link #close()}
&lt;p&gt; will block until the zero-open-leases condition is triggered.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    nit &quot;Before this has happened&quot;&lt;/p&gt;</comment>
                            <comment id="16198480" author="githubbot" created="Tue, 10 Oct 2017 10:23:49 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r143686389&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r143686389&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/test/java/org/apache/flink/util/ResourceGuardTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,135 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.util;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    +&lt;br/&gt;
    +public class ResourceGuardTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testClose() {&lt;br/&gt;
    +		ResourceGuard resourceGuard = new ResourceGuard();&lt;br/&gt;
    +		Assert.assertFalse(resourceGuard.isClosed());&lt;br/&gt;
    +		resourceGuard.close();&lt;br/&gt;
    +		Assert.assertTrue(resourceGuard.isClosed());&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			resourceGuard.acquireResource();
    +			Assert.fail();
    +		}
&lt;p&gt; catch (IOException ignore) &lt;/p&gt;
{
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAcquireReleaseClose() throws IOException &lt;/p&gt;
{
    +		ResourceGuard resourceGuard = new ResourceGuard();
    +		ResourceGuard.Lease lease = resourceGuard.acquireResource();
    +		Assert.assertEquals(1, resourceGuard.getLeaseCount());
    +		lease.close();
    +		Assert.assertEquals(0, resourceGuard.getLeaseCount());
    +		resourceGuard.close();
    +		Assert.assertTrue(resourceGuard.isClosed());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testCloseBlockIfAcquired() throws Exception {&lt;br/&gt;
    +		ResourceGuard resourceGuard = new ResourceGuard();&lt;br/&gt;
    +		ResourceGuard.Lease lease_1 = resourceGuard.acquireResource();&lt;br/&gt;
    +		AtomicBoolean checker = new AtomicBoolean(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		Thread closerThread = new Thread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void run() {&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					// this line should block until all acquires are matched by releases.
    +					resourceGuard.close();
    +					checker.set(false);
    +				}
&lt;p&gt; catch (Exception ignore) &lt;/p&gt;
{
    +					checker.set(false);
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		closerThread.start();&lt;br/&gt;
    +&lt;br/&gt;
    +		ResourceGuard.Lease lease_2 = resourceGuard.acquireResource();&lt;br/&gt;
    +		lease_2.close();&lt;br/&gt;
    +		Thread.sleep(50);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I don&apos;t like sleep in tests but I don&apos;t see what else to do. &lt;/p&gt;</comment>
                            <comment id="16198481" author="githubbot" created="Tue, 10 Oct 2017 10:23:49 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r143681902&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r143681902&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/FlinkKafkaProducerBase.java &amp;#8212;&lt;br/&gt;
    @@ -33,6 +32,7 @@&lt;br/&gt;
     import org.apache.flink.streaming.connectors.kafka.partitioner.FlinkKafkaPartitioner;&lt;br/&gt;
     import org.apache.flink.streaming.util.serialization.KeyedSerializationSchema;&lt;br/&gt;
     import org.apache.flink.util.NetUtils;&lt;br/&gt;
    +import org.apache.flink.util.SerializableObject;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    nit: unrelated change&lt;/p&gt;</comment>
                            <comment id="16208947" author="githubbot" created="Wed, 18 Oct 2017 08:04:40 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r145341268&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r145341268&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -618,19 +600,8 @@ public void releaseSnapshotResources() &lt;/p&gt;
{
     				IOUtils.closeQuietly(readOptions);
     				readOptions = null;
     			}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Drop the created snapshot if we have ben cancelled.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public void dropSnapshotResult() {&lt;/li&gt;
	&lt;li&gt;if (null != snapshotResultStateHandle) {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;snapshotResultStateHandle.discardState();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Yes, the method was already unused before. Cleanup either happens already in the plain `close()` method of the checkpoint output stream, or in the `AsyncCheckpointRunnable::cleanup()` if ownership of a complete state handle was already transferred from the backend to the runnable.&lt;/p&gt;</comment>
                            <comment id="16208948" author="githubbot" created="Wed, 18 Oct 2017 08:04:57 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r145341323&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r145341323&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBStateBackendTest.java &amp;#8212;&lt;br/&gt;
    @@ -215,46 +215,6 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void testRunningSnapshotAfterBackendClosed() throws Exception {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Exactly.&lt;/p&gt;</comment>
                            <comment id="16208951" author="githubbot" created="Wed, 18 Oct 2017 08:05:27 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r145341403&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r145341403&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java &amp;#8212;&lt;br/&gt;
    @@ -66,14 +66,13 @@&lt;br/&gt;
     import org.apache.flink.runtime.state.internal.InternalReducingState;&lt;br/&gt;
     import org.apache.flink.runtime.state.internal.InternalValueState;&lt;br/&gt;
     import org.apache.flink.runtime.util.BlockerCheckpointStreamFactory;&lt;br/&gt;
    +import org.apache.flink.shaded.guava18.com.google.common.base.Joiner;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    IIRC, checkstyle actually &lt;em&gt;forced&lt;/em&gt; me to position the import there.&lt;/p&gt;</comment>
                            <comment id="16208953" author="githubbot" created="Wed, 18 Oct 2017 08:08:34 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764#discussion_r145341988&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764#discussion_r145341988&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/test/java/org/apache/flink/util/ResourceGuardTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,135 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.util;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    +&lt;br/&gt;
    +public class ResourceGuardTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testClose() {&lt;br/&gt;
    +		ResourceGuard resourceGuard = new ResourceGuard();&lt;br/&gt;
    +		Assert.assertFalse(resourceGuard.isClosed());&lt;br/&gt;
    +		resourceGuard.close();&lt;br/&gt;
    +		Assert.assertTrue(resourceGuard.isClosed());&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			resourceGuard.acquireResource();
    +			Assert.fail();
    +		}
&lt;p&gt; catch (IOException ignore) &lt;/p&gt;
{
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAcquireReleaseClose() throws IOException &lt;/p&gt;
{
    +		ResourceGuard resourceGuard = new ResourceGuard();
    +		ResourceGuard.Lease lease = resourceGuard.acquireResource();
    +		Assert.assertEquals(1, resourceGuard.getLeaseCount());
    +		lease.close();
    +		Assert.assertEquals(0, resourceGuard.getLeaseCount());
    +		resourceGuard.close();
    +		Assert.assertTrue(resourceGuard.isClosed());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testCloseBlockIfAcquired() throws Exception {&lt;br/&gt;
    +		ResourceGuard resourceGuard = new ResourceGuard();&lt;br/&gt;
    +		ResourceGuard.Lease lease_1 = resourceGuard.acquireResource();&lt;br/&gt;
    +		AtomicBoolean checker = new AtomicBoolean(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		Thread closerThread = new Thread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void run() {&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					// this line should block until all acquires are matched by releases.
    +					resourceGuard.close();
    +					checker.set(false);
    +				}
&lt;p&gt; catch (Exception ignore) &lt;/p&gt;
{
    +					checker.set(false);
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		closerThread.start();&lt;br/&gt;
    +&lt;br/&gt;
    +		ResourceGuard.Lease lease_2 = resourceGuard.acquireResource();&lt;br/&gt;
    +		lease_2.close();&lt;br/&gt;
    +		Thread.sleep(50);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I don&apos;t like them either. I will drop them because they are not actually adding real value and the test is clearer without them.&lt;/p&gt;</comment>
                            <comment id="16208955" author="githubbot" created="Wed, 18 Oct 2017 08:09:31 +0000"  >&lt;p&gt;Github user StefanRRichter commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for the reviews @aljoscha @bowenli86 and @GJL . I addressed all points and will merge this now.&lt;/p&gt;</comment>
                            <comment id="16209112" author="githubbot" created="Wed, 18 Oct 2017 10:23:43 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4764&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4764&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16209114" author="srichter" created="Wed, 18 Oct 2017 10:25:24 +0000"  >&lt;p&gt;Fixed in 7d026aa728.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 4 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3ktqv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>