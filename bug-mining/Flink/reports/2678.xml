<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:35:34 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-10309] Cancel with savepoint fails with java.net.ConnectException when using the per job-mode</title>
                <link>https://issues.apache.org/jira/browse/FLINK-10309</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;The problem occurs when using the Yarn per-job detached mode. Trying to cancel with savepoint fails with the following exception before being able to retrieve the savepoint path:&lt;/p&gt;

&lt;p&gt;exception stack trace :&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
org.apache.flink.util.FlinkException: Could not cancel job xxxx.
&#160; &#160; &#160; &#160; at org.apache.flink.client.cli.CliFrontend.lambda$cancel$4(CliFrontend.java:585)
&#160; &#160; &#160; &#160; at org.apache.flink.client.cli.CliFrontend.runClusterAction(CliFrontend.java:960)
&#160; &#160; &#160; &#160; at org.apache.flink.client.cli.CliFrontend.cancel(CliFrontend.java:577)
&#160; &#160; &#160; &#160; at org.apache.flink.client.cli.CliFrontend.parseParameters(CliFrontend.java:1034)
&#160; &#160; &#160; &#160; at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:748)
Caused by: java.util.concurrent.ExecutionException: org.apache.flink.runtime.concurrent.FutureUtils$RetryException: Could not complete the operation. &lt;span class=&quot;code-object&quot;&gt;Number&lt;/span&gt; of retries has been exhausted.
&#160; &#160; &#160; &#160; at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:357)
&#160; &#160; &#160; &#160; at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1895)
&#160; &#160; &#160; &#160; at org.apache.flink.client.program.&lt;span class=&quot;code-keyword&quot;&gt;rest&lt;/span&gt;.RestClusterClient.cancelWithSavepoint(RestClusterClient.java:398)
&#160; &#160; &#160; &#160; at org.apache.flink.client.cli.CliFrontend.lambda$cancel$4(CliFrontend.java:583)
&#160; &#160; &#160; &#160; ... 6 more
Caused by: org.apache.flink.runtime.concurrent.FutureUtils$RetryException: Could not complete the operation. &lt;span class=&quot;code-object&quot;&gt;Number&lt;/span&gt; of retries has been exhausted.
&#160; &#160; &#160; &#160; at org.apache.flink.runtime.concurrent.FutureUtils.lambda$retryOperationWithDelay$5(FutureUtils.java:213)
&#160; &#160; &#160; &#160; at java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:760)
&#160; &#160; &#160; &#160; at java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:736)
&#160; &#160; &#160; &#160; at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:474)
&#160; &#160; &#160; &#160; at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1977)
&#160; &#160; &#160; &#160; at org.apache.flink.runtime.&lt;span class=&quot;code-keyword&quot;&gt;rest&lt;/span&gt;.RestClient.lambda$submitRequest$1(RestClient.java:274)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:603)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:563)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:424)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:268)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:284)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:528)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
&#160; &#160; &#160; &#160; ... 1 more
Caused by: java.util.concurrent.CompletionException: java.net.ConnectException: Connect refuse: xxx/xxx.xxx.xxx.xxx:xxx
&#160; &#160; &#160; &#160; at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:292)
&#160; &#160; &#160; &#160; at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:308)
&#160; &#160; &#160; &#160; at java.util.concurrent.CompletableFuture.uniCompose(CompletableFuture.java:943)
&#160; &#160; &#160; &#160; at java.util.concurrent.CompletableFuture$UniCompose.tryFire(CompletableFuture.java:926)
&#160; &#160; &#160; &#160; ... 16 more
Caused by: java.net.ConnectException: Connect refuse: xxx/xxx.xxx.xxx.xxx:xxx
&#160; &#160; &#160; &#160; at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
&#160; &#160; &#160; &#160; at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:717)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:224)
&#160; &#160; &#160; &#160; at org.apache.flink.shaded.netty4.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:281)
&#160; &#160; &#160; &#160; ... 7 more

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;some&#160;discussion in mailing list&#160;:&#160;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://apache-flink-mailing-list-archive.1008284.n3.nabble.com/Cancel-flink-job-occur-exception-td24056.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://apache-flink-mailing-list-archive.1008284.n3.nabble.com/Cancel-flink-job-occur-exception-td24056.html&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="13183871">FLINK-10309</key>
            <summary>Cancel with savepoint fails with java.net.ConnectException when using the per job-mode</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="gjy">Gary Yao</assignee>
                                    <reporter username="yanghua">vinoyang</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Sun, 9 Sep 2018 07:54:05 +0000</created>
                <updated>Wed, 21 Nov 2018 17:05:18 +0000</updated>
                            <resolved>Wed, 21 Nov 2018 17:05:18 +0000</resolved>
                                    <version>1.5.3</version>
                    <version>1.6.0</version>
                    <version>1.7.0</version>
                                    <fixVersion>1.5.6</fixVersion>
                    <fixVersion>1.6.3</fixVersion>
                    <fixVersion>1.7.0</fixVersion>
                                    <component>Runtime / Coordination</component>
                    <component>Runtime / REST</component>
                        <due></due>
                            <votes>2</votes>
                                    <watches>7</watches>
                                                                                                                <comments>
                            <comment id="16608787" author="till.rohrmann" created="Mon, 10 Sep 2018 06:39:29 +0000"  >&lt;p&gt;I think one way to solve this problem is to block on unserved results when shutting down the REST endpoint. This applies not only to the savepoint path but also the job result.&lt;/p&gt;</comment>
                            <comment id="16608790" author="gjy" created="Mon, 10 Sep 2018 06:41:34 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=till.rohrmann&quot; class=&quot;user-hover&quot; rel=&quot;till.rohrmann&quot;&gt;till.rohrmann&lt;/a&gt; For job result the problem is solved in the MiniDispatcher.&lt;/p&gt;</comment>
                            <comment id="16617151" author="paul lin" created="Mon, 17 Sep 2018 07:01:30 +0000"  >&lt;p&gt;It seems like the unserved results are&#160;part of the states of the handlers and there&apos;s plenty of work to change the interfaces and make&#160;the states exposed to the&#160;REST endpoint.&#160;&lt;/p&gt;

&lt;p&gt;I fixed this by adding a `closeTimeWait` option to block the rest server before its shutting down. Maybe not the best solution, but a&#160;simple one. FYI.&lt;/p&gt;</comment>
                            <comment id="16617298" author="till.rohrmann" created="Mon, 17 Sep 2018 09:34:23 +0000"  >&lt;p&gt;I think it is not all that much of work to change it. For example, we could add a &lt;tt&gt;closeAsync&lt;/tt&gt; method to &lt;tt&gt;AbstractRestHandler&lt;/tt&gt; which by default returns a completed future. For all handlers which have state, we can return a future which is completed once all responses have been served. Then we can wait for some time on the future to complete. This would give the same behaviour as what &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=Paul+Lin&quot; class=&quot;user-hover&quot; rel=&quot;Paul Lin&quot;&gt;Paul Lin&lt;/a&gt; did with &lt;tt&gt;closeTimeWait&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="16619999" author="paul lin" created="Wed, 19 Sep 2018 02:36:34 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=till.rohrmann&quot; class=&quot;user-hover&quot; rel=&quot;till.rohrmann&quot;&gt;till.rohrmann&lt;/a&gt; &apos;s&#160;approach is obviously better. I will move to it when it&apos;s released.&lt;/p&gt;</comment>
                            <comment id="16635282" author="githubbot" created="Tue, 2 Oct 2018 10:56:22 +0000"  >&lt;p&gt;GJL opened a new pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   &lt;b&gt;Wait for the result of asynchronous operations to be served before shutting down the cluster.  This is necessary for the &lt;em&gt;&quot;cancel with savepoint&quot;&lt;/em&gt; operation. If we do not wait for the result to be accessed by the client, we may shutdown the cluster, and the client gets a `ConnectionException`.&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;   cc: @zentol @tillrohrmann &lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;b&gt;Before shutting down cluster, wait for asynchronous operations.&lt;/b&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Log stacktrace if checkpoint cannot be ack&apos;ed.&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   This change added tests and can be verified as follows:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;b&gt;Added test to `RestServerEndpointITCase` to verify that handlers are closed first.&lt;/b&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Added unit tests for `CompletedOperationCache`.&lt;/b&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Verified the changes by submitting and cancelling with savepoint of a job in a loop.&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;The serializers: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (*&lt;b&gt;yes&lt;/b&gt;* / no / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? (*&lt;b&gt;not applicable&lt;/b&gt;* / docs / JavaDocs / not documented)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635378" author="githubbot" created="Tue, 2 Oct 2018 12:19:16 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221919360&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221919360&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/AbstractRestHandler.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -120,4 +122,8 @@ protected AbstractRestHandler(&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@throws RestHandlerException if the handling failed&lt;br/&gt;
 	 */&lt;br/&gt;
 	protected abstract CompletableFuture&amp;lt;P&amp;gt; handleRequest(@Nonnull HandlerRequest&amp;lt;R, M&amp;gt; request, @Nonnull T gateway) throws RestHandlerException;&lt;br/&gt;
+&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   `@Override`&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635379" author="githubbot" created="Tue, 2 Oct 2018 12:19:16 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221920986&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221920986&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,202 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.types.Either;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.base.Ticker;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.Cache;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.CacheBuilder;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.RemovalListener;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.ThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.stream.Collectors;&lt;br/&gt;
+import java.util.stream.Stream;&lt;br/&gt;
+&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Cache to manage ongoing operations.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;The cache allows to register ongoing operations by calling&lt;br/&gt;
+ * &lt;/p&gt;
{@link #registerOngoingOperation(K, CompletableFuture)}
&lt;p&gt;, where the&lt;br/&gt;
+ * &lt;/p&gt;
{@code CompletableFuture} contains the operation result. Completed operations will be&lt;br/&gt;
+ * removed from the cache automatically after a fixed timeout.&lt;br/&gt;
+ */&lt;br/&gt;
+@ThreadSafe&lt;br/&gt;
+class CompletedOperationCache&amp;lt;K extends OperationKey, R&amp;gt; implements AutoCloseableAsync {&lt;br/&gt;
+&lt;br/&gt;
+	private static final long COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS = 300L;&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * In-progress asynchronous operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Map&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; registeredOperationTriggers = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Caches the result of completed operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Cache&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; completedOperations;&lt;br/&gt;
+&lt;br/&gt;
+	CompletedOperationCache() {
+		this(Ticker.systemTicker());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	CompletedOperationCache(final Ticker ticker) {&lt;br/&gt;
+		completedOperations = CacheBuilder.newBuilder()&lt;br/&gt;
+			.expireAfterWrite(COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS, TimeUnit.SECONDS)&lt;br/&gt;
+			.removalListener((RemovalListener&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt;) removalNotification -&amp;gt; {&lt;br/&gt;
+				if (removalNotification.wasEvicted()) {
+					Preconditions.checkState(removalNotification.getValue() != null);
+					removalNotification.getValue().markAccessed();
+				}&lt;br/&gt;
+			})&lt;br/&gt;
+			.ticker(ticker)&lt;br/&gt;
+			.build();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Registers an ongoing operation with the cache.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param operationResultFuture A future containing the operation result.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public void registerOngoingOperation(&lt;br/&gt;
+			final K operationKey,&lt;br/&gt;
+			final CompletableFuture&amp;lt;R&amp;gt; operationResultFuture) {&lt;br/&gt;
+		final ResultAccessTracker&amp;lt;R&amp;gt; inProgress = ResultAccessTracker.inProgress();&lt;br/&gt;
+		registeredOperationTriggers.put(operationKey, inProgress);&lt;br/&gt;
+		operationResultFuture.whenComplete((result, error) -&amp;gt; {&lt;br/&gt;
+			if (error == null) {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Right(result)));
+			} else {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Left(error)));
+			}&lt;br/&gt;
+			registeredOperationTriggers.remove(operationKey);&lt;br/&gt;
+		});&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the operation result or a {@code Throwable} if the {@code CompletableFuture}
&lt;p&gt;+	 * finished, otherwise &lt;/p&gt;
{@code null}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @throws UnknownOperationKeyException If the operation is not found, and there is no ongoing&lt;br/&gt;
+	 *                                      operation under the provided key.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public Either&amp;lt;Throwable, R&amp;gt; get(&lt;br/&gt;
+			final K operationKey) throws UnknownOperationKeyException {&lt;br/&gt;
+		ResultAccessTracker&amp;lt;R&amp;gt; operationResultOrError;&lt;br/&gt;
+		if ((operationResultOrError = registeredOperationTriggers.get(operationKey)) == null&lt;br/&gt;
+			&amp;amp;&amp;amp; (operationResultOrError = completedOperations.getIfPresent(operationKey)) == null) &lt;/p&gt;
{
+			throw new UnknownOperationKeyException(operationKey);
+		}
&lt;p&gt;+&lt;br/&gt;
+		return operationResultOrError.accessOperationResultOrError();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;br/&gt;
+		return FutureUtils.orTimeout(&lt;br/&gt;
+			asyncWaitForResultsToBeAccessed(),&lt;br/&gt;
+			COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS,&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Have you considered making this configurable?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635380" author="githubbot" created="Tue, 2 Oct 2018 12:19:16 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221921902&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221921902&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,202 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.types.Either;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.base.Ticker;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.Cache;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.CacheBuilder;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.RemovalListener;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.ThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.stream.Collectors;&lt;br/&gt;
+import java.util.stream.Stream;&lt;br/&gt;
+&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Cache to manage ongoing operations.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;The cache allows to register ongoing operations by calling&lt;br/&gt;
+ * &lt;/p&gt;
{@link #registerOngoingOperation(K, CompletableFuture)}
&lt;p&gt;, where the&lt;br/&gt;
+ * &lt;/p&gt;
{@code CompletableFuture} contains the operation result. Completed operations will be&lt;br/&gt;
+ * removed from the cache automatically after a fixed timeout.&lt;br/&gt;
+ */&lt;br/&gt;
+@ThreadSafe&lt;br/&gt;
+class CompletedOperationCache&amp;lt;K extends OperationKey, R&amp;gt; implements AutoCloseableAsync {&lt;br/&gt;
+&lt;br/&gt;
+	private static final long COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS = 300L;&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * In-progress asynchronous operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Map&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; registeredOperationTriggers = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Caches the result of completed operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Cache&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; completedOperations;&lt;br/&gt;
+&lt;br/&gt;
+	CompletedOperationCache() {
+		this(Ticker.systemTicker());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	CompletedOperationCache(final Ticker ticker) {&lt;br/&gt;
+		completedOperations = CacheBuilder.newBuilder()&lt;br/&gt;
+			.expireAfterWrite(COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS, TimeUnit.SECONDS)&lt;br/&gt;
+			.removalListener((RemovalListener&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt;) removalNotification -&amp;gt; {&lt;br/&gt;
+				if (removalNotification.wasEvicted()) {
+					Preconditions.checkState(removalNotification.getValue() != null);
+					removalNotification.getValue().markAccessed();
+				}&lt;br/&gt;
+			})&lt;br/&gt;
+			.ticker(ticker)&lt;br/&gt;
+			.build();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Registers an ongoing operation with the cache.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param operationResultFuture A future containing the operation result.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public void registerOngoingOperation(&lt;br/&gt;
+			final K operationKey,&lt;br/&gt;
+			final CompletableFuture&amp;lt;R&amp;gt; operationResultFuture) {&lt;br/&gt;
+		final ResultAccessTracker&amp;lt;R&amp;gt; inProgress = ResultAccessTracker.inProgress();&lt;br/&gt;
+		registeredOperationTriggers.put(operationKey, inProgress);&lt;br/&gt;
+		operationResultFuture.whenComplete((result, error) -&amp;gt; {&lt;br/&gt;
+			if (error == null) {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Right(result)));
+			} else {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Left(error)));
+			}&lt;br/&gt;
+			registeredOperationTriggers.remove(operationKey);&lt;br/&gt;
+		});&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the operation result or a {@code Throwable} if the {@code CompletableFuture}
&lt;p&gt;+	 * finished, otherwise &lt;/p&gt;
{@code null}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @throws UnknownOperationKeyException If the operation is not found, and there is no ongoing&lt;br/&gt;
+	 *                                      operation under the provided key.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public Either&amp;lt;Throwable, R&amp;gt; get(&lt;br/&gt;
+			final K operationKey) throws UnknownOperationKeyException {&lt;br/&gt;
+		ResultAccessTracker&amp;lt;R&amp;gt; operationResultOrError;&lt;br/&gt;
+		if ((operationResultOrError = registeredOperationTriggers.get(operationKey)) == null&lt;br/&gt;
+			&amp;amp;&amp;amp; (operationResultOrError = completedOperations.getIfPresent(operationKey)) == null) &lt;/p&gt;
{
+			throw new UnknownOperationKeyException(operationKey);
+		}
&lt;p&gt;+&lt;br/&gt;
+		return operationResultOrError.accessOperationResultOrError();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;br/&gt;
+		return FutureUtils.orTimeout(&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   what happens if a new operation is started after `closeAsync` was called? I.e. are we blocking new requests from being accepted anywhere? Would it then not be contained in this future?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635381" author="githubbot" created="Tue, 2 Oct 2018 12:19:16 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221919990&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221919990&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,202 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.types.Either;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.base.Ticker;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.Cache;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.CacheBuilder;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.RemovalListener;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.ThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.stream.Collectors;&lt;br/&gt;
+import java.util.stream.Stream;&lt;br/&gt;
+&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Cache to manage ongoing operations.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;The cache allows to register ongoing operations by calling&lt;br/&gt;
+ * &lt;/p&gt;
{@link #registerOngoingOperation(K, CompletableFuture)}
&lt;p&gt;, where the&lt;br/&gt;
+ * &lt;/p&gt;
{@code CompletableFuture}
&lt;p&gt; contains the operation result. Completed operations will be&lt;br/&gt;
+ * removed from the cache automatically after a fixed timeout.&lt;br/&gt;
+ */&lt;br/&gt;
+@ThreadSafe&lt;br/&gt;
+class CompletedOperationCache&amp;lt;K extends OperationKey, R&amp;gt; implements AutoCloseableAsync {&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   When making extensive changes to a class along wit moving it somewhere else please do so in separate commits. Now i have to create my own diff which shouldn&apos;t be necessary.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635382" author="githubbot" created="Tue, 2 Oct 2018 12:19:16 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221923131&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221923131&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/job/AsynchronousJobOperationKey.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -33,7 +33,7 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A pair of 
{@link JobID}
&lt;p&gt; and &lt;/p&gt;
{@link TriggerId}
&lt;p&gt; used as a key to a hash based&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;collection.&lt;br/&gt;
  *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @see AbstractAsynchronousOperationHandlers.CompletedOperationCache&lt;br/&gt;
+ * @see AbstractAsynchronousOperationHandlers&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   This reference wasn&apos;t updated properly as it no longer points to the cache.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635383" author="githubbot" created="Tue, 2 Oct 2018 12:19:16 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221926520&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221926520&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,202 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.types.Either;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.base.Ticker;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.Cache;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.CacheBuilder;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.RemovalListener;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.ThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.stream.Collectors;&lt;br/&gt;
+import java.util.stream.Stream;&lt;br/&gt;
+&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Cache to manage ongoing operations.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;The cache allows to register ongoing operations by calling&lt;br/&gt;
+ * &lt;/p&gt;
{@link #registerOngoingOperation(K, CompletableFuture)}
&lt;p&gt;, where the&lt;br/&gt;
+ * &lt;/p&gt;
{@code CompletableFuture}
&lt;p&gt; contains the operation result. Completed operations will be&lt;br/&gt;
+ * removed from the cache automatically after a fixed timeout.&lt;br/&gt;
+ */&lt;br/&gt;
+@ThreadSafe&lt;br/&gt;
+class CompletedOperationCache&amp;lt;K extends OperationKey, R&amp;gt; implements AutoCloseableAsync {&lt;br/&gt;
+&lt;br/&gt;
+	private static final long COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS = 300L;&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * In-progress asynchronous operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Map&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; registeredOperationTriggers = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Caches the result of completed operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Cache&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; completedOperations;&lt;br/&gt;
+&lt;br/&gt;
+	CompletedOperationCache() &lt;/p&gt;
{
+		this(Ticker.systemTicker());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	CompletedOperationCache(final Ticker ticker) {&lt;br/&gt;
+		completedOperations = CacheBuilder.newBuilder()&lt;br/&gt;
+			.expireAfterWrite(COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS, TimeUnit.SECONDS)&lt;br/&gt;
+			.removalListener((RemovalListener&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt;) removalNotification -&amp;gt; {&lt;br/&gt;
+				if (removalNotification.wasEvicted()) {&lt;br/&gt;
+					Preconditions.checkState(removalNotification.getValue() != null);&lt;br/&gt;
+					removalNotification.getValue().markAccessed();&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I take it this is done so that the shutdown doesn&apos;t block indefinitely, since it snapshots the current set of operations? Please add a comment for this if that is the case.&lt;/p&gt;

&lt;p&gt;   Do we log anywhere that this result has expired?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635433" author="githubbot" created="Tue, 2 Oct 2018 12:54:53 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221938209&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221938209&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,202 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.types.Either;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.base.Ticker;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.Cache;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.CacheBuilder;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.RemovalListener;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.ThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.stream.Collectors;&lt;br/&gt;
+import java.util.stream.Stream;&lt;br/&gt;
+&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Cache to manage ongoing operations.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;The cache allows to register ongoing operations by calling&lt;br/&gt;
+ * &lt;/p&gt;
{@link #registerOngoingOperation(K, CompletableFuture)}
&lt;p&gt;, where the&lt;br/&gt;
+ * &lt;/p&gt;
{@code CompletableFuture} contains the operation result. Completed operations will be&lt;br/&gt;
+ * removed from the cache automatically after a fixed timeout.&lt;br/&gt;
+ */&lt;br/&gt;
+@ThreadSafe&lt;br/&gt;
+class CompletedOperationCache&amp;lt;K extends OperationKey, R&amp;gt; implements AutoCloseableAsync {&lt;br/&gt;
+&lt;br/&gt;
+	private static final long COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS = 300L;&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * In-progress asynchronous operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Map&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; registeredOperationTriggers = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Caches the result of completed operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Cache&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; completedOperations;&lt;br/&gt;
+&lt;br/&gt;
+	CompletedOperationCache() {
+		this(Ticker.systemTicker());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	CompletedOperationCache(final Ticker ticker) {&lt;br/&gt;
+		completedOperations = CacheBuilder.newBuilder()&lt;br/&gt;
+			.expireAfterWrite(COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS, TimeUnit.SECONDS)&lt;br/&gt;
+			.removalListener((RemovalListener&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt;) removalNotification -&amp;gt; {&lt;br/&gt;
+				if (removalNotification.wasEvicted()) {
+					Preconditions.checkState(removalNotification.getValue() != null);
+					removalNotification.getValue().markAccessed();
+				}&lt;br/&gt;
+			})&lt;br/&gt;
+			.ticker(ticker)&lt;br/&gt;
+			.build();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Registers an ongoing operation with the cache.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param operationResultFuture A future containing the operation result.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public void registerOngoingOperation(&lt;br/&gt;
+			final K operationKey,&lt;br/&gt;
+			final CompletableFuture&amp;lt;R&amp;gt; operationResultFuture) {&lt;br/&gt;
+		final ResultAccessTracker&amp;lt;R&amp;gt; inProgress = ResultAccessTracker.inProgress();&lt;br/&gt;
+		registeredOperationTriggers.put(operationKey, inProgress);&lt;br/&gt;
+		operationResultFuture.whenComplete((result, error) -&amp;gt; {&lt;br/&gt;
+			if (error == null) {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Right(result)));
+			} else {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Left(error)));
+			}&lt;br/&gt;
+			registeredOperationTriggers.remove(operationKey);&lt;br/&gt;
+		});&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the operation result or a {@code Throwable} if the {@code CompletableFuture}
&lt;p&gt;+	 * finished, otherwise &lt;/p&gt;
{@code null}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @throws UnknownOperationKeyException If the operation is not found, and there is no ongoing&lt;br/&gt;
+	 *                                      operation under the provided key.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public Either&amp;lt;Throwable, R&amp;gt; get(&lt;br/&gt;
+			final K operationKey) throws UnknownOperationKeyException {&lt;br/&gt;
+		ResultAccessTracker&amp;lt;R&amp;gt; operationResultOrError;&lt;br/&gt;
+		if ((operationResultOrError = registeredOperationTriggers.get(operationKey)) == null&lt;br/&gt;
+			&amp;amp;&amp;amp; (operationResultOrError = completedOperations.getIfPresent(operationKey)) == null) &lt;/p&gt;
{
+			throw new UnknownOperationKeyException(operationKey);
+		}
&lt;p&gt;+&lt;br/&gt;
+		return operationResultOrError.accessOperationResultOrError();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;br/&gt;
+		return FutureUtils.orTimeout(&lt;br/&gt;
+			asyncWaitForResultsToBeAccessed(),&lt;br/&gt;
+			COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS,&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I prefer not to do make it configurable now because it was not configurable before. Should be a follow up.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635436" author="githubbot" created="Tue, 2 Oct 2018 12:58:42 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221939470&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221939470&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/job/AsynchronousJobOperationKey.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -33,7 +33,7 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A pair of 
{@link JobID}
&lt;p&gt; and &lt;/p&gt;
{@link TriggerId}
&lt;p&gt; used as a key to a hash based&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;collection.&lt;br/&gt;
  *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @see AbstractAsynchronousOperationHandlers.CompletedOperationCache&lt;br/&gt;
+ * @see AbstractAsynchronousOperationHandlers&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   It&apos;s not possible to reference the cache anymore because it has default visibility now. I also don&apos;t think it is necessary to reference it here to understand how `AsynchronousJobOperationKey` is used.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635437" author="githubbot" created="Tue, 2 Oct 2018 12:59:05 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221939603&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221939603&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/AbstractRestHandler.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -120,4 +122,8 @@ protected AbstractRestHandler(&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@throws RestHandlerException if the handling failed&lt;br/&gt;
 	 */&lt;br/&gt;
 	protected abstract CompletableFuture&amp;lt;P&amp;gt; handleRequest(@Nonnull HandlerRequest&amp;lt;R, M&amp;gt; request, @Nonnull T gateway) throws RestHandlerException;&lt;br/&gt;
+&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Fixed.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635438" author="githubbot" created="Tue, 2 Oct 2018 12:59:13 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221939603&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221939603&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/AbstractRestHandler.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -120,4 +122,8 @@ protected AbstractRestHandler(&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@throws RestHandlerException if the handling failed&lt;br/&gt;
 	 */&lt;br/&gt;
 	protected abstract CompletableFuture&amp;lt;P&amp;gt; handleRequest(@Nonnull HandlerRequest&amp;lt;R, M&amp;gt; request, @Nonnull T gateway) throws RestHandlerException;&lt;br/&gt;
+&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Good catch. Fixed.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635459" author="githubbot" created="Tue, 2 Oct 2018 13:12:14 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221943917&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221943917&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,202 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.types.Either;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.base.Ticker;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.Cache;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.CacheBuilder;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.RemovalListener;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.ThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.stream.Collectors;&lt;br/&gt;
+import java.util.stream.Stream;&lt;br/&gt;
+&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Cache to manage ongoing operations.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;The cache allows to register ongoing operations by calling&lt;br/&gt;
+ * &lt;/p&gt;
{@link #registerOngoingOperation(K, CompletableFuture)}
&lt;p&gt;, where the&lt;br/&gt;
+ * &lt;/p&gt;
{@code CompletableFuture} contains the operation result. Completed operations will be&lt;br/&gt;
+ * removed from the cache automatically after a fixed timeout.&lt;br/&gt;
+ */&lt;br/&gt;
+@ThreadSafe&lt;br/&gt;
+class CompletedOperationCache&amp;lt;K extends OperationKey, R&amp;gt; implements AutoCloseableAsync {&lt;br/&gt;
+&lt;br/&gt;
+	private static final long COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS = 300L;&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * In-progress asynchronous operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Map&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; registeredOperationTriggers = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Caches the result of completed operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Cache&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; completedOperations;&lt;br/&gt;
+&lt;br/&gt;
+	CompletedOperationCache() {
+		this(Ticker.systemTicker());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	CompletedOperationCache(final Ticker ticker) {&lt;br/&gt;
+		completedOperations = CacheBuilder.newBuilder()&lt;br/&gt;
+			.expireAfterWrite(COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS, TimeUnit.SECONDS)&lt;br/&gt;
+			.removalListener((RemovalListener&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt;) removalNotification -&amp;gt; {&lt;br/&gt;
+				if (removalNotification.wasEvicted()) {
+					Preconditions.checkState(removalNotification.getValue() != null);
+					removalNotification.getValue().markAccessed();
+				}&lt;br/&gt;
+			})&lt;br/&gt;
+			.ticker(ticker)&lt;br/&gt;
+			.build();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Registers an ongoing operation with the cache.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param operationResultFuture A future containing the operation result.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public void registerOngoingOperation(&lt;br/&gt;
+			final K operationKey,&lt;br/&gt;
+			final CompletableFuture&amp;lt;R&amp;gt; operationResultFuture) {&lt;br/&gt;
+		final ResultAccessTracker&amp;lt;R&amp;gt; inProgress = ResultAccessTracker.inProgress();&lt;br/&gt;
+		registeredOperationTriggers.put(operationKey, inProgress);&lt;br/&gt;
+		operationResultFuture.whenComplete((result, error) -&amp;gt; {&lt;br/&gt;
+			if (error == null) {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Right(result)));
+			} else {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Left(error)));
+			}&lt;br/&gt;
+			registeredOperationTriggers.remove(operationKey);&lt;br/&gt;
+		});&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the operation result or a {@code Throwable} if the {@code CompletableFuture}
&lt;p&gt;+	 * finished, otherwise &lt;/p&gt;
{@code null}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @throws UnknownOperationKeyException If the operation is not found, and there is no ongoing&lt;br/&gt;
+	 *                                      operation under the provided key.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public Either&amp;lt;Throwable, R&amp;gt; get(&lt;br/&gt;
+			final K operationKey) throws UnknownOperationKeyException {&lt;br/&gt;
+		ResultAccessTracker&amp;lt;R&amp;gt; operationResultOrError;&lt;br/&gt;
+		if ((operationResultOrError = registeredOperationTriggers.get(operationKey)) == null&lt;br/&gt;
+			&amp;amp;&amp;amp; (operationResultOrError = completedOperations.getIfPresent(operationKey)) == null) &lt;/p&gt;
{
+			throw new UnknownOperationKeyException(operationKey);
+		}
&lt;p&gt;+&lt;br/&gt;
+		return operationResultOrError.accessOperationResultOrError();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;br/&gt;
+		return FutureUtils.orTimeout(&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   If the client triggers more operations after an initiated cluster shutdown, we&lt;br/&gt;
   would not wait for that operation to complete, or for the result to be served&lt;br/&gt;
   to the client. The client would likely see a timeout while polling for the&lt;br/&gt;
   result. I am ok with such semantics. Alternatively, we can answer the requests&lt;br/&gt;
   against the `TriggerHandler` with status code 503.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635461" author="githubbot" created="Tue, 2 Oct 2018 13:12:22 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221943917&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221943917&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,202 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.types.Either;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.base.Ticker;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.Cache;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.CacheBuilder;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.RemovalListener;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.ThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.stream.Collectors;&lt;br/&gt;
+import java.util.stream.Stream;&lt;br/&gt;
+&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Cache to manage ongoing operations.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;The cache allows to register ongoing operations by calling&lt;br/&gt;
+ * &lt;/p&gt;
{@link #registerOngoingOperation(K, CompletableFuture)}
&lt;p&gt;, where the&lt;br/&gt;
+ * &lt;/p&gt;
{@code CompletableFuture} contains the operation result. Completed operations will be&lt;br/&gt;
+ * removed from the cache automatically after a fixed timeout.&lt;br/&gt;
+ */&lt;br/&gt;
+@ThreadSafe&lt;br/&gt;
+class CompletedOperationCache&amp;lt;K extends OperationKey, R&amp;gt; implements AutoCloseableAsync {&lt;br/&gt;
+&lt;br/&gt;
+	private static final long COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS = 300L;&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * In-progress asynchronous operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Map&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; registeredOperationTriggers = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Caches the result of completed operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Cache&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; completedOperations;&lt;br/&gt;
+&lt;br/&gt;
+	CompletedOperationCache() {
+		this(Ticker.systemTicker());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	CompletedOperationCache(final Ticker ticker) {&lt;br/&gt;
+		completedOperations = CacheBuilder.newBuilder()&lt;br/&gt;
+			.expireAfterWrite(COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS, TimeUnit.SECONDS)&lt;br/&gt;
+			.removalListener((RemovalListener&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt;) removalNotification -&amp;gt; {&lt;br/&gt;
+				if (removalNotification.wasEvicted()) {
+					Preconditions.checkState(removalNotification.getValue() != null);
+					removalNotification.getValue().markAccessed();
+				}&lt;br/&gt;
+			})&lt;br/&gt;
+			.ticker(ticker)&lt;br/&gt;
+			.build();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Registers an ongoing operation with the cache.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param operationResultFuture A future containing the operation result.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public void registerOngoingOperation(&lt;br/&gt;
+			final K operationKey,&lt;br/&gt;
+			final CompletableFuture&amp;lt;R&amp;gt; operationResultFuture) {&lt;br/&gt;
+		final ResultAccessTracker&amp;lt;R&amp;gt; inProgress = ResultAccessTracker.inProgress();&lt;br/&gt;
+		registeredOperationTriggers.put(operationKey, inProgress);&lt;br/&gt;
+		operationResultFuture.whenComplete((result, error) -&amp;gt; {&lt;br/&gt;
+			if (error == null) {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Right(result)));
+			} else {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Left(error)));
+			}&lt;br/&gt;
+			registeredOperationTriggers.remove(operationKey);&lt;br/&gt;
+		});&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the operation result or a {@code Throwable} if the {@code CompletableFuture}
&lt;p&gt;+	 * finished, otherwise &lt;/p&gt;
{@code null}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @throws UnknownOperationKeyException If the operation is not found, and there is no ongoing&lt;br/&gt;
+	 *                                      operation under the provided key.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public Either&amp;lt;Throwable, R&amp;gt; get(&lt;br/&gt;
+			final K operationKey) throws UnknownOperationKeyException {&lt;br/&gt;
+		ResultAccessTracker&amp;lt;R&amp;gt; operationResultOrError;&lt;br/&gt;
+		if ((operationResultOrError = registeredOperationTriggers.get(operationKey)) == null&lt;br/&gt;
+			&amp;amp;&amp;amp; (operationResultOrError = completedOperations.getIfPresent(operationKey)) == null) &lt;/p&gt;
{
+			throw new UnknownOperationKeyException(operationKey);
+		}
&lt;p&gt;+&lt;br/&gt;
+		return operationResultOrError.accessOperationResultOrError();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;br/&gt;
+		return FutureUtils.orTimeout(&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   If the client triggers more operations after an initiated cluster shutdown, we&lt;br/&gt;
   would not wait for that operation to complete, or for the result to be served&lt;br/&gt;
   to the client. The client would likely see a timeout while polling for the&lt;br/&gt;
   result. I am ok with such semantics. Alternatively, we can answer the requests&lt;br/&gt;
   against the `TriggerHandler` with status code 503. What do you think?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635483" author="githubbot" created="Tue, 2 Oct 2018 13:33:48 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221951599&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221951599&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,202 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.types.Either;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.base.Ticker;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.Cache;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.CacheBuilder;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.RemovalListener;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.ThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.stream.Collectors;&lt;br/&gt;
+import java.util.stream.Stream;&lt;br/&gt;
+&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Cache to manage ongoing operations.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;The cache allows to register ongoing operations by calling&lt;br/&gt;
+ * &lt;/p&gt;
{@link #registerOngoingOperation(K, CompletableFuture)}
&lt;p&gt;, where the&lt;br/&gt;
+ * &lt;/p&gt;
{@code CompletableFuture} contains the operation result. Completed operations will be&lt;br/&gt;
+ * removed from the cache automatically after a fixed timeout.&lt;br/&gt;
+ */&lt;br/&gt;
+@ThreadSafe&lt;br/&gt;
+class CompletedOperationCache&amp;lt;K extends OperationKey, R&amp;gt; implements AutoCloseableAsync {&lt;br/&gt;
+&lt;br/&gt;
+	private static final long COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS = 300L;&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * In-progress asynchronous operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Map&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; registeredOperationTriggers = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Caches the result of completed operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Cache&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; completedOperations;&lt;br/&gt;
+&lt;br/&gt;
+	CompletedOperationCache() {
+		this(Ticker.systemTicker());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	CompletedOperationCache(final Ticker ticker) {&lt;br/&gt;
+		completedOperations = CacheBuilder.newBuilder()&lt;br/&gt;
+			.expireAfterWrite(COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS, TimeUnit.SECONDS)&lt;br/&gt;
+			.removalListener((RemovalListener&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt;) removalNotification -&amp;gt; {&lt;br/&gt;
+				if (removalNotification.wasEvicted()) {
+					Preconditions.checkState(removalNotification.getValue() != null);
+					removalNotification.getValue().markAccessed();
+				}&lt;br/&gt;
+			})&lt;br/&gt;
+			.ticker(ticker)&lt;br/&gt;
+			.build();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Registers an ongoing operation with the cache.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param operationResultFuture A future containing the operation result.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public void registerOngoingOperation(&lt;br/&gt;
+			final K operationKey,&lt;br/&gt;
+			final CompletableFuture&amp;lt;R&amp;gt; operationResultFuture) {&lt;br/&gt;
+		final ResultAccessTracker&amp;lt;R&amp;gt; inProgress = ResultAccessTracker.inProgress();&lt;br/&gt;
+		registeredOperationTriggers.put(operationKey, inProgress);&lt;br/&gt;
+		operationResultFuture.whenComplete((result, error) -&amp;gt; {&lt;br/&gt;
+			if (error == null) {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Right(result)));
+			} else {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Left(error)));
+			}&lt;br/&gt;
+			registeredOperationTriggers.remove(operationKey);&lt;br/&gt;
+		});&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the operation result or a {@code Throwable} if the {@code CompletableFuture}
&lt;p&gt;+	 * finished, otherwise &lt;/p&gt;
{@code null}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @throws UnknownOperationKeyException If the operation is not found, and there is no ongoing&lt;br/&gt;
+	 *                                      operation under the provided key.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public Either&amp;lt;Throwable, R&amp;gt; get(&lt;br/&gt;
+			final K operationKey) throws UnknownOperationKeyException {&lt;br/&gt;
+		ResultAccessTracker&amp;lt;R&amp;gt; operationResultOrError;&lt;br/&gt;
+		if ((operationResultOrError = registeredOperationTriggers.get(operationKey)) == null&lt;br/&gt;
+			&amp;amp;&amp;amp; (operationResultOrError = completedOperations.getIfPresent(operationKey)) == null) &lt;/p&gt;
{
+			throw new UnknownOperationKeyException(operationKey);
+		}
&lt;p&gt;+&lt;br/&gt;
+		return operationResultOrError.accessOperationResultOrError();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;br/&gt;
+		return FutureUtils.orTimeout(&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   hmm...I &lt;em&gt;think&lt;/em&gt; I&apos;d prefer returning 503. However, the PR is still an improvement over the current state so I wouldn&apos;t block it on this.&lt;/p&gt;

&lt;p&gt;   We probably want a separate discussion for this as there are other considerations to make as well; for example shouldn&apos;t job submissions also be rejected during a shutdown?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635489" author="githubbot" created="Tue, 2 Oct 2018 13:39:32 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221953953&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221953953&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,202 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.types.Either;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.base.Ticker;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.Cache;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.CacheBuilder;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.RemovalListener;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.ThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.stream.Collectors;&lt;br/&gt;
+import java.util.stream.Stream;&lt;br/&gt;
+&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Cache to manage ongoing operations.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;The cache allows to register ongoing operations by calling&lt;br/&gt;
+ * &lt;/p&gt;
{@link #registerOngoingOperation(K, CompletableFuture)}
&lt;p&gt;, where the&lt;br/&gt;
+ * &lt;/p&gt;
{@code CompletableFuture}
&lt;p&gt; contains the operation result. Completed operations will be&lt;br/&gt;
+ * removed from the cache automatically after a fixed timeout.&lt;br/&gt;
+ */&lt;br/&gt;
+@ThreadSafe&lt;br/&gt;
+class CompletedOperationCache&amp;lt;K extends OperationKey, R&amp;gt; implements AutoCloseableAsync {&lt;br/&gt;
+&lt;br/&gt;
+	private static final long COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS = 300L;&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * In-progress asynchronous operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Map&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; registeredOperationTriggers = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Caches the result of completed operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Cache&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; completedOperations;&lt;br/&gt;
+&lt;br/&gt;
+	CompletedOperationCache() &lt;/p&gt;
{
+		this(Ticker.systemTicker());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	CompletedOperationCache(final Ticker ticker) {&lt;br/&gt;
+		completedOperations = CacheBuilder.newBuilder()&lt;br/&gt;
+			.expireAfterWrite(COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS, TimeUnit.SECONDS)&lt;br/&gt;
+			.removalListener((RemovalListener&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt;) removalNotification -&amp;gt; {&lt;br/&gt;
+				if (removalNotification.wasEvicted()) {&lt;br/&gt;
+					Preconditions.checkState(removalNotification.getValue() != null);&lt;br/&gt;
+					removalNotification.getValue().markAccessed();&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Exactly, we might evict a result while we wait for it to be accessed. &lt;/p&gt;

&lt;p&gt;   I added a comment and a log statement if items get evicted.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16635490" author="githubbot" created="Tue, 2 Oct 2018 13:39:45 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r221954026&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r221954026&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,202 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.types.Either;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.base.Ticker;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.Cache;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.CacheBuilder;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.RemovalListener;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.ThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.stream.Collectors;&lt;br/&gt;
+import java.util.stream.Stream;&lt;br/&gt;
+&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Cache to manage ongoing operations.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;The cache allows to register ongoing operations by calling&lt;br/&gt;
+ * &lt;/p&gt;
{@link #registerOngoingOperation(K, CompletableFuture)}
&lt;p&gt;, where the&lt;br/&gt;
+ * &lt;/p&gt;
{@code CompletableFuture}
&lt;p&gt; contains the operation result. Completed operations will be&lt;br/&gt;
+ * removed from the cache automatically after a fixed timeout.&lt;br/&gt;
+ */&lt;br/&gt;
+@ThreadSafe&lt;br/&gt;
+class CompletedOperationCache&amp;lt;K extends OperationKey, R&amp;gt; implements AutoCloseableAsync {&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Ok next time.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16637935" author="githubbot" created="Thu, 4 Oct 2018 08:31:53 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r222580198&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r222580198&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,202 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.types.Either;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.base.Ticker;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.Cache;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.CacheBuilder;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.RemovalListener;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.ThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.stream.Collectors;&lt;br/&gt;
+import java.util.stream.Stream;&lt;br/&gt;
+&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Cache to manage ongoing operations.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;The cache allows to register ongoing operations by calling&lt;br/&gt;
+ * &lt;/p&gt;
{@link #registerOngoingOperation(K, CompletableFuture)}
&lt;p&gt;, where the&lt;br/&gt;
+ * &lt;/p&gt;
{@code CompletableFuture} contains the operation result. Completed operations will be&lt;br/&gt;
+ * removed from the cache automatically after a fixed timeout.&lt;br/&gt;
+ */&lt;br/&gt;
+@ThreadSafe&lt;br/&gt;
+class CompletedOperationCache&amp;lt;K extends OperationKey, R&amp;gt; implements AutoCloseableAsync {&lt;br/&gt;
+&lt;br/&gt;
+	private static final long COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS = 300L;&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * In-progress asynchronous operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Map&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; registeredOperationTriggers = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Caches the result of completed operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Cache&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; completedOperations;&lt;br/&gt;
+&lt;br/&gt;
+	CompletedOperationCache() {
+		this(Ticker.systemTicker());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	CompletedOperationCache(final Ticker ticker) {&lt;br/&gt;
+		completedOperations = CacheBuilder.newBuilder()&lt;br/&gt;
+			.expireAfterWrite(COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS, TimeUnit.SECONDS)&lt;br/&gt;
+			.removalListener((RemovalListener&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt;) removalNotification -&amp;gt; {&lt;br/&gt;
+				if (removalNotification.wasEvicted()) {
+					Preconditions.checkState(removalNotification.getValue() != null);
+					removalNotification.getValue().markAccessed();
+				}&lt;br/&gt;
+			})&lt;br/&gt;
+			.ticker(ticker)&lt;br/&gt;
+			.build();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Registers an ongoing operation with the cache.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param operationResultFuture A future containing the operation result.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public void registerOngoingOperation(&lt;br/&gt;
+			final K operationKey,&lt;br/&gt;
+			final CompletableFuture&amp;lt;R&amp;gt; operationResultFuture) {&lt;br/&gt;
+		final ResultAccessTracker&amp;lt;R&amp;gt; inProgress = ResultAccessTracker.inProgress();&lt;br/&gt;
+		registeredOperationTriggers.put(operationKey, inProgress);&lt;br/&gt;
+		operationResultFuture.whenComplete((result, error) -&amp;gt; {&lt;br/&gt;
+			if (error == null) {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Right(result)));
+			} else {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Left(error)));
+			}&lt;br/&gt;
+			registeredOperationTriggers.remove(operationKey);&lt;br/&gt;
+		});&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the operation result or a {@code Throwable} if the {@code CompletableFuture}
&lt;p&gt;+	 * finished, otherwise &lt;/p&gt;
{@code null}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @throws UnknownOperationKeyException If the operation is not found, and there is no ongoing&lt;br/&gt;
+	 *                                      operation under the provided key.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public Either&amp;lt;Throwable, R&amp;gt; get(&lt;br/&gt;
+			final K operationKey) throws UnknownOperationKeyException {&lt;br/&gt;
+		ResultAccessTracker&amp;lt;R&amp;gt; operationResultOrError;&lt;br/&gt;
+		if ((operationResultOrError = registeredOperationTriggers.get(operationKey)) == null&lt;br/&gt;
+			&amp;amp;&amp;amp; (operationResultOrError = completedOperations.getIfPresent(operationKey)) == null) &lt;/p&gt;
{
+			throw new UnknownOperationKeyException(operationKey);
+		}
&lt;p&gt;+&lt;br/&gt;
+		return operationResultOrError.accessOperationResultOrError();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;br/&gt;
+		return FutureUtils.orTimeout(&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Agree not to block on this for now.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16637937" author="githubbot" created="Thu, 4 Oct 2018 08:34:39 +0000"  >&lt;p&gt;GJL commented on issue #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#issuecomment-426932334&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#issuecomment-426932334&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Fixed a checkstyle violation.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16638144" author="githubbot" created="Thu, 4 Oct 2018 12:25:32 +0000"  >&lt;p&gt;GJL commented on issue #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#issuecomment-426998950&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#issuecomment-426998950&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   There are some test failures that I have to look into.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16641836" author="githubbot" created="Mon, 8 Oct 2018 13:33:34 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r223364545&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r223364545&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/AbstractRestHandler.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -75,19 +82,19 @@ protected AbstractRestHandler(&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	protected CompletableFuture&amp;lt;Void&amp;gt; respondToRequest(ChannelHandlerContext ctx, HttpRequest httpRequest, HandlerRequest&amp;lt;R, M&amp;gt; handlerRequest, T gateway) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompletableFuture&amp;lt;P&amp;gt; response;&lt;br/&gt;
+		final CompletableFuture&amp;lt;P&amp;gt; response = handleRequestInternal(handlerRequest, gateway);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try 
{
-			response = handleRequest(handlerRequest, gateway);
-		}
&lt;p&gt; catch (RestHandlerException e) &lt;/p&gt;
{
-			response = FutureUtils.completedExceptionally(e);
-		}
&lt;p&gt;+		return response.whenCompleteAsync((P resp, Throwable throwable) -&amp;gt; {&lt;br/&gt;
+				inFlightRequestTracker.deregisterRequest();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return response.whenComplete((P resp, Throwable throwable) -&amp;gt; 
{
-			Tuple2&amp;lt;ResponseBody, HttpResponseStatus&amp;gt; r = throwable != null ?
-				errorResponse(throwable) : Tuple2.of(resp, messageHeaders.getResponseStatusCode());
-			HandlerUtils.sendResponse(ctx, httpRequest, r.f0, r.f1, responseHeaders);
-		}
&lt;p&gt;).thenApply(ignored -&amp;gt; null);&lt;br/&gt;
+				Tuple2&amp;lt;ResponseBody, HttpResponseStatus&amp;gt; r = throwable != null ?&lt;br/&gt;
+					errorResponse(throwable) : Tuple2.of(resp, messageHeaders.getResponseStatusCode());&lt;br/&gt;
+				HandlerUtils.sendResponse(ctx, httpRequest, r.f0, r.f1, responseHeaders);&lt;br/&gt;
+			},&lt;br/&gt;
+			// send response from Netty&apos;s EventExecutor so that the server channel&lt;br/&gt;
+			// does not close while we are responding to in-flight requests&lt;br/&gt;
+			ctx.executor())&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   under what circumstances would the server channel close? Does it simply close after a set or timeout or ...?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16641837" author="githubbot" created="Mon, 8 Oct 2018 13:33:34 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r223357493&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r223357493&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/component/DispatcherResourceManagerComponent.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -126,15 +125,36 @@ public T getDispatcher() &lt;/p&gt;
{
 		return webMonitorEndpoint;
 	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Deregister the Flink application from the resource management system by signalling&lt;br/&gt;
+	 * the 
{@link ResourceManager}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param applicationStatus to terminate the application with&lt;br/&gt;
+	 * @param diagnostics additional information about the shut down, can be &lt;/p&gt;
{@code null}
&lt;p&gt;+	 * @return Future which is completed once the shut down&lt;br/&gt;
+	 */&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; deregisterApplicationAndClose(&lt;br/&gt;
+			final ApplicationStatus applicationStatus,&lt;br/&gt;
+			final @Nullable String diagnostics) {&lt;br/&gt;
+&lt;br/&gt;
 		if (isRunning.compareAndSet(true, false)) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;return FutureUtils.composeAfterwards(webMonitorEndpoint.closeAsync(), this::closeAsyncInternal);&lt;br/&gt;
+			final CompletableFuture&amp;lt;Void&amp;gt; closeWebMonitorAndRegisterAppFuture =&lt;br/&gt;
+				FutureUtils.composeAfterwards(webMonitorEndpoint.closeAsync(), () -&amp;gt; deregisterApplication(applicationStatus, diagnostics));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   are you intentionally changing the shutdown order? (Previous: webmonitor -&amp;gt; this::closeAsync -&amp;gt; deregister; now: webmonitor -&amp;gt; deregister -&amp;gt; this::closeAsync)&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16641838" author="githubbot" created="Mon, 8 Oct 2018 13:33:34 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r223363092&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r223363092&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/AbstractRestHandler.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -106,6 +113,21 @@ protected AbstractRestHandler(&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	private CompletableFuture&amp;lt;P&amp;gt; handleRequestInternal(final HandlerRequest&amp;lt;R, M&amp;gt; handlerRequest, final T gateway) {&lt;br/&gt;
+		inFlightRequestTracker.registerRequest();&lt;br/&gt;
+&lt;br/&gt;
+		CompletableFuture&amp;lt;P&amp;gt; response;&lt;br/&gt;
+		try &lt;/p&gt;
{
+			response = handleRequest(handlerRequest, gateway);
+		}
&lt;p&gt; catch (RestHandlerException e) &lt;/p&gt;
{
+			response = FutureUtils.completedExceptionally(e);
+		}
&lt;p&gt; catch (Throwable t) {&lt;br/&gt;
+			inFlightRequestTracker.deregisterRequest();&lt;br/&gt;
+			throw t;&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   you could fail the future here, then we wouldn&apos;t call `deregisterRequest` from 2 places&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16641839" author="githubbot" created="Mon, 8 Oct 2018 13:33:35 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r223359551&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r223359551&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/InFlightRequestTrackerTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,62 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler;&lt;br/&gt;
+&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertFalse;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tests for &lt;/p&gt;
{@link InFlightRequestTracker}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class InFlightRequestTrackerTest {&lt;br/&gt;
+&lt;br/&gt;
+	private InFlightRequestTracker inFlightRequestTracker;&lt;br/&gt;
+&lt;br/&gt;
+	@Before&lt;br/&gt;
+	public void setUp() &lt;/p&gt;
{
+		inFlightRequestTracker = new InFlightRequestTracker();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testShouldFinishAwaitAsyncImmediatelyIfNoRequests() &lt;/p&gt;
{
+		assertTrue(inFlightRequestTracker.awaitAsync().isDone());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testShouldFinishAwaitAsyncIffAllRequestsDeregistered() &lt;/p&gt;
{
+		inFlightRequestTracker.registerRequest();
+
+		final CompletableFuture&amp;lt;Void&amp;gt; closeFuture = inFlightRequestTracker.awaitAsync();
+		assertFalse(closeFuture.isDone());
+
+		inFlightRequestTracker.deregisterRequest();
+		assertTrue(closeFuture.isDone());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testAwaitAsyncIsIdempotent() {&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   also add a test for `register` calls after `awaitAsync().isDone()` returned true. The call shouldn&apos;t fail and the future be completed immediately.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16644697" author="githubbot" created="Wed, 10 Oct 2018 09:14:03 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r223996551&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r223996551&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/component/DispatcherResourceManagerComponent.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -126,15 +125,36 @@ public T getDispatcher() &lt;/p&gt;
{
 		return webMonitorEndpoint;
 	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Deregister the Flink application from the resource management system by signalling&lt;br/&gt;
+	 * the 
{@link ResourceManager}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param applicationStatus to terminate the application with&lt;br/&gt;
+	 * @param diagnostics additional information about the shut down, can be &lt;/p&gt;
{@code null}
&lt;p&gt;+	 * @return Future which is completed once the shut down&lt;br/&gt;
+	 */&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; deregisterApplicationAndClose(&lt;br/&gt;
+			final ApplicationStatus applicationStatus,&lt;br/&gt;
+			final @Nullable String diagnostics) {&lt;br/&gt;
+&lt;br/&gt;
 		if (isRunning.compareAndSet(true, false)) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;return FutureUtils.composeAfterwards(webMonitorEndpoint.closeAsync(), this::closeAsyncInternal);&lt;br/&gt;
+			final CompletableFuture&amp;lt;Void&amp;gt; closeWebMonitorAndRegisterAppFuture =&lt;br/&gt;
+				FutureUtils.composeAfterwards(webMonitorEndpoint.closeAsync(), () -&amp;gt; deregisterApplication(applicationStatus, diagnostics));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Yes, because deregister is an RPC. If you shutdown the ResourceManager before deregistration, the message is lost.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16644792" author="githubbot" created="Wed, 10 Oct 2018 10:35:27 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r224022949&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r224022949&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/InFlightRequestTrackerTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,62 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler;&lt;br/&gt;
+&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertFalse;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tests for &lt;/p&gt;
{@link InFlightRequestTracker}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class InFlightRequestTrackerTest {&lt;br/&gt;
+&lt;br/&gt;
+	private InFlightRequestTracker inFlightRequestTracker;&lt;br/&gt;
+&lt;br/&gt;
+	@Before&lt;br/&gt;
+	public void setUp() &lt;/p&gt;
{
+		inFlightRequestTracker = new InFlightRequestTracker();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testShouldFinishAwaitAsyncImmediatelyIfNoRequests() &lt;/p&gt;
{
+		assertTrue(inFlightRequestTracker.awaitAsync().isDone());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testShouldFinishAwaitAsyncIffAllRequestsDeregistered() &lt;/p&gt;
{
+		inFlightRequestTracker.registerRequest();
+
+		final CompletableFuture&amp;lt;Void&amp;gt; closeFuture = inFlightRequestTracker.awaitAsync();
+		assertFalse(closeFuture.isDone());
+
+		inFlightRequestTracker.deregisterRequest();
+		assertTrue(closeFuture.isDone());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testAwaitAsyncIsIdempotent() {&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Added test `testShouldTolerateRegisterAfterAwaitAsync`&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16644793" author="githubbot" created="Wed, 10 Oct 2018 10:35:47 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r224023036&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r224023036&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/AbstractRestHandler.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -106,6 +113,21 @@ protected AbstractRestHandler(&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	private CompletableFuture&amp;lt;P&amp;gt; handleRequestInternal(final HandlerRequest&amp;lt;R, M&amp;gt; handlerRequest, final T gateway) {&lt;br/&gt;
+		inFlightRequestTracker.registerRequest();&lt;br/&gt;
+&lt;br/&gt;
+		CompletableFuture&amp;lt;P&amp;gt; response;&lt;br/&gt;
+		try &lt;/p&gt;
{
+			response = handleRequest(handlerRequest, gateway);
+		}
&lt;p&gt; catch (RestHandlerException e) &lt;/p&gt;
{
+			response = FutureUtils.completedExceptionally(e);
+		}
&lt;p&gt; catch (Throwable t) {&lt;br/&gt;
+			inFlightRequestTracker.deregisterRequest();&lt;br/&gt;
+			throw t;&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Logic extracted to superclass. &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16644861" author="githubbot" created="Wed, 10 Oct 2018 11:39:35 +0000"  >&lt;p&gt;zentol commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r224037914&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r224037914&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/InFlightRequestTrackerTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -59,4 +59,10 @@ public void testAwaitAsyncIsIdempotent() &lt;/p&gt;
{
 		assertTrue(inFlightRequestTracker.awaitAsync().isDone());
 		assertTrue(inFlightRequestTracker.awaitAsync().isDone());
 	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testShouldTolerateRegisterAfterAwaitAsync() {&lt;br/&gt;
+		assertTrue(inFlightRequestTracker.awaitAsync().isDone());&lt;br/&gt;
+		inFlightRequestTracker.registerRequest();&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I would add `assertTrue(inFlightRequestTracker.awaitAsync().isDone());` after the registration to ensure that the tracker doesn&apos;t reset or anything.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16644869" author="githubbot" created="Wed, 10 Oct 2018 11:45:50 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r224041393&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r224041393&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/InFlightRequestTrackerTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -59,4 +59,10 @@ public void testAwaitAsyncIsIdempotent() &lt;/p&gt;
{
 		assertTrue(inFlightRequestTracker.awaitAsync().isDone());
 		assertTrue(inFlightRequestTracker.awaitAsync().isDone());
 	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testShouldTolerateRegisterAfterAwaitAsync() {&lt;br/&gt;
+		assertTrue(inFlightRequestTracker.awaitAsync().isDone());&lt;br/&gt;
+		inFlightRequestTracker.registerRequest();&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   will add&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16644888" author="githubbot" created="Wed, 10 Oct 2018 12:02:02 +0000"  >&lt;p&gt;GJL commented on issue #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#issuecomment-428545227&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#issuecomment-428545227&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Merging when Travis gives green light.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16645056" author="githubbot" created="Wed, 10 Oct 2018 14:36:54 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r224104240&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r224104240&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/component/DispatcherResourceManagerComponent.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -126,65 +125,77 @@ public T getDispatcher() &lt;/p&gt;
{
 		return webMonitorEndpoint;
 	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Deregister the Flink application from the resource management system by signalling&lt;br/&gt;
+	 * the 
{@link ResourceManager}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param applicationStatus to terminate the application with&lt;br/&gt;
+	 * @param diagnostics additional information about the shut down, can be &lt;/p&gt;
{@code null}
&lt;p&gt;+	 * @return Future which is completed once the shut down&lt;br/&gt;
+	 */&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; deregisterApplicationAndClose(&lt;br/&gt;
+			final ApplicationStatus applicationStatus,&lt;br/&gt;
+			final @Nullable String diagnostics) {&lt;br/&gt;
+&lt;br/&gt;
 		if (isRunning.compareAndSet(true, false)) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;Exception exception = null;&lt;br/&gt;
+			final CompletableFuture&amp;lt;Void&amp;gt; closeWebMonitorAndRegisterAppFuture =&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   typo: &lt;em&gt;DeregisterApp&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16653479" author="githubbot" created="Wed, 17 Oct 2018 12:48:27 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#discussion_r225912353&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#discussion_r225912353&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestServerEndpointITCase.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -661,12 +657,10 @@ protected void startInternal() {}&lt;br/&gt;
 				// Intentionally schedule the work on a different thread. This is to simulate&lt;br/&gt;
 				// handlers where the CompletableFuture is finished by the RPC framework.&lt;br/&gt;
 				return CompletableFuture.supplyAsync(() -&amp;gt; {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;synchronized (LOCK) {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;LOCK.notifyAll();&lt;/li&gt;
	&lt;li&gt;LOCK.wait();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Replaced with `CountDownLatch` because there can be spurious wakeups:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1050592/do-spurious-wakeups-in-java-actually-happen&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://stackoverflow.com/questions/1050592/do-spurious-wakeups-in-java-actually-happen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16654844" author="githubbot" created="Thu, 18 Oct 2018 08:16:50 +0000"  >&lt;p&gt;zentol commented on issue #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#issuecomment-430917987&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#issuecomment-430917987&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Can we separate the refactorings to the `RestServerEndpointITCase` (which are good!) and the remaining changes? This will get a mess of a commit otherwise.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16655553" author="githubbot" created="Thu, 18 Oct 2018 16:39:03 +0000"  >&lt;p&gt;GJL commented on issue #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785#issuecomment-431078873&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785#issuecomment-431078873&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   @zentol Thanks for reviewing. I will keep the refactoring in a separate commit.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16656373" author="githubbot" created="Fri, 19 Oct 2018 07:35:34 +0000"  >&lt;p&gt;asfgit closed pull request #6785: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10309&quot; title=&quot;Cancel with savepoint fails with java.net.ConnectException when using the per job-mode&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10309&quot;&gt;&lt;del&gt;FLINK-10309&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;rest&amp;#93;&lt;/span&gt; Before shutting down cluster, wait for asynchronous operations&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6785&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6785&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java&lt;br/&gt;
index 9eaef34a33a..b2d6d150561 100755&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java&lt;br/&gt;
@@ -445,9 +445,7 @@ private Configuration generateClusterConfiguration(Configuration configuration)&lt;br/&gt;
 	private CompletableFuture&amp;lt;Void&amp;gt; closeClusterComponent(ApplicationStatus applicationStatus, @Nullable String diagnostics) {&lt;br/&gt;
 		synchronized (lock) {&lt;br/&gt;
 			if (clusterComponent != null) &lt;/p&gt;
{
-				final CompletableFuture&amp;lt;Void&amp;gt; deregisterApplicationFuture = clusterComponent.deregisterApplication(applicationStatus, diagnostics);
-
-				return FutureUtils.runAfterwards(deregisterApplicationFuture, clusterComponent::closeAsync);
+				return clusterComponent.deregisterApplicationAndClose(applicationStatus, diagnostics);
 			}
&lt;p&gt; else &lt;/p&gt;
{
 				return CompletableFuture.completedFuture(null);
 			}
&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/component/DispatcherResourceManagerComponent.java b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/component/DispatcherResourceManagerComponent.java&lt;br/&gt;
index b07095c2b6d..6e28ab6c6b0 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/component/DispatcherResourceManagerComponent.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/component/DispatcherResourceManagerComponent.java&lt;br/&gt;
@@ -26,7 +26,6 @@&lt;br/&gt;
 import org.apache.flink.runtime.resourcemanager.ResourceManager;&lt;br/&gt;
 import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;&lt;br/&gt;
 import org.apache.flink.runtime.webmonitor.WebMonitorEndpoint;&lt;br/&gt;
-import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
 import org.apache.flink.util.ExceptionUtils;&lt;/p&gt;

&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
@@ -41,7 +40,7 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Component which starts a 
{@link Dispatcher}
&lt;p&gt;, &lt;/p&gt;
{@link ResourceManager} and {@link WebMonitorEndpoint}&lt;br/&gt;
  * in the same process.&lt;br/&gt;
  */&lt;br/&gt;
-public class DispatcherResourceManagerComponent&amp;lt;T extends Dispatcher&amp;gt; implements AutoCloseableAsync {&lt;br/&gt;
+public class DispatcherResourceManagerComponent&amp;lt;T extends Dispatcher&amp;gt; {&lt;br/&gt;
 &lt;br/&gt;
 	@Nonnull&lt;br/&gt;
 	private final T dispatcher;&lt;br/&gt;
@@ -126,65 +125,77 @@ public T getDispatcher() {
 		return webMonitorEndpoint;
 	}&lt;br/&gt;
 &lt;br/&gt;
-	@Override&lt;br/&gt;
-	public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() {&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Deregister the Flink application from the resource management system by signalling&lt;br/&gt;
+	 * the {@link ResourceManager}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param applicationStatus to terminate the application with&lt;br/&gt;
+	 * @param diagnostics additional information about the shut down, can be &lt;/p&gt;
{@code null}&lt;br/&gt;
+	 * @return Future which is completed once the shut down&lt;br/&gt;
+	 */&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; deregisterApplicationAndClose(&lt;br/&gt;
+			final ApplicationStatus applicationStatus,&lt;br/&gt;
+			final @Nullable String diagnostics) {&lt;br/&gt;
+&lt;br/&gt;
 		if (isRunning.compareAndSet(true, false)) {
-			Exception exception = null;
+			final CompletableFuture&amp;lt;Void&amp;gt; closeWebMonitorAndDeregisterAppFuture =
+				FutureUtils.composeAfterwards(webMonitorEndpoint.closeAsync(), () -&amp;gt; deregisterApplication(applicationStatus, diagnostics));
 
-			final Collection&amp;lt;CompletableFuture&amp;lt;Void&amp;gt;&amp;gt; terminationFutures = new ArrayList&amp;lt;&amp;gt;(4);
+			return FutureUtils.composeAfterwards(closeWebMonitorAndDeregisterAppFuture, this::closeAsyncInternal);
+		} else {
+			return terminationFuture;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
 &lt;br/&gt;
-			try {
-				dispatcherLeaderRetrievalService.stop();
-			} catch (Exception e) {
-				exception = ExceptionUtils.firstOrSuppressed(e, exception);
-			}&lt;br/&gt;
+	private CompletableFuture&amp;lt;Void&amp;gt; deregisterApplication(&lt;br/&gt;
+			final ApplicationStatus applicationStatus,&lt;br/&gt;
+			final @Nullable String diagnostics) {&lt;br/&gt;
 &lt;br/&gt;
-			try {
-				resourceManagerRetrievalService.stop();
-			} catch (Exception e) {-				exception = ExceptionUtils.firstOrSuppressed(e, exception);-			}&lt;br/&gt;
+		final ResourceManagerGateway selfGateway = resourceManager.getSelfGateway(ResourceManagerGateway.class);&lt;br/&gt;
+		return selfGateway.deregisterApplication(applicationStatus, diagnostics).thenApply(ack -&amp;gt; null);&lt;br/&gt;
+	}&lt;br/&gt;
 &lt;br/&gt;
-			terminationFutures.add(webMonitorEndpoint.closeAsync());&lt;br/&gt;
+	private CompletableFuture&amp;lt;Void&amp;gt; closeAsyncInternal() {&lt;br/&gt;
+		Exception exception = null;&lt;br/&gt;
 &lt;br/&gt;
-			dispatcher.shutDown();&lt;br/&gt;
-			terminationFutures.add(dispatcher.getTerminationFuture());&lt;br/&gt;
+		final Collection&amp;lt;CompletableFuture&amp;lt;Void&amp;gt;&amp;gt; terminationFutures = new ArrayList&amp;lt;&amp;gt;(3);&lt;br/&gt;
 &lt;br/&gt;
-			resourceManager.shutDown();&lt;br/&gt;
-			terminationFutures.add(resourceManager.getTerminationFuture());&lt;br/&gt;
+		try {
+			dispatcherLeaderRetrievalService.stop();
+		} catch (Exception e) {
+			exception = ExceptionUtils.firstOrSuppressed(e, exception);
+		}&lt;br/&gt;
 &lt;br/&gt;
-			if (exception != null) {
-				terminationFutures.add(FutureUtils.completedExceptionally(exception));
-			}&lt;br/&gt;
+		try {
+			resourceManagerRetrievalService.stop();
+		} catch (Exception e) {+			exception = ExceptionUtils.firstOrSuppressed(e, exception);+		}&lt;br/&gt;
 &lt;br/&gt;
-			final CompletableFuture&amp;lt;Void&amp;gt; componentTerminationFuture = FutureUtils.completeAll(terminationFutures);&lt;br/&gt;
+		dispatcher.shutDown();&lt;br/&gt;
+		terminationFutures.add(dispatcher.getTerminationFuture());&lt;br/&gt;
 &lt;br/&gt;
-			final CompletableFuture&amp;lt;Void&amp;gt; metricGroupTerminationFuture = FutureUtils.runAfterwards(&lt;br/&gt;
-				componentTerminationFuture,&lt;br/&gt;
-				jobManagerMetricGroup::close);&lt;br/&gt;
+		resourceManager.shutDown();&lt;br/&gt;
+		terminationFutures.add(resourceManager.getTerminationFuture());&lt;br/&gt;
 &lt;br/&gt;
-			metricGroupTerminationFuture.whenComplete((aVoid, throwable) -&amp;gt; {&lt;br/&gt;
-				if (throwable != null) {
-					terminationFuture.completeExceptionally(throwable);
-				} else {
-					terminationFuture.complete(aVoid);
-				}&lt;br/&gt;
-			});&lt;br/&gt;
+		if (exception != null) {
+			terminationFutures.add(FutureUtils.completedExceptionally(exception));
 		}&lt;br/&gt;
 &lt;br/&gt;
-		return terminationFuture;&lt;br/&gt;
-	}&lt;br/&gt;
+		final CompletableFuture&amp;lt;Void&amp;gt; componentTerminationFuture = FutureUtils.completeAll(terminationFutures);&lt;br/&gt;
 &lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Deregister the Flink application from the resource management system by signalling&lt;br/&gt;
-	 * the {@link ResourceManager}.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param applicationStatus to terminate the application with&lt;br/&gt;
-	 * @param diagnostics additional information about the shut down, can be {@code null}&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @return Future which is completed once the shut down&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public CompletableFuture&amp;lt;Void&amp;gt; deregisterApplication(ApplicationStatus applicationStatus, @Nullable String diagnostics) {&lt;/li&gt;
	&lt;li&gt;final ResourceManagerGateway selfGateway = resourceManager.getSelfGateway(ResourceManagerGateway.class);&lt;/li&gt;
	&lt;li&gt;return selfGateway.deregisterApplication(applicationStatus, diagnostics).thenApply(ack -&amp;gt; null);&lt;br/&gt;
+		final CompletableFuture&amp;lt;Void&amp;gt; metricGroupTerminationFuture = FutureUtils.runAfterwards(&lt;br/&gt;
+			componentTerminationFuture,&lt;br/&gt;
+			jobManagerMetricGroup::close);&lt;br/&gt;
+&lt;br/&gt;
+		metricGroupTerminationFuture.whenComplete((aVoid, throwable) -&amp;gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			if (throwable != null) {
+				terminationFuture.completeExceptionally(throwable);
+			} else {
+				terminationFuture.complete(aVoid);
+			}+		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;br/&gt;
+&lt;br/&gt;
+		return terminationFuture;&lt;br/&gt;
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java&lt;br/&gt;
index 31c6a97124b..5d2d363cf71 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java&lt;br/&gt;
@@ -679,7 +679,7 @@ public void acknowledgeCheckpoint(&lt;br/&gt;
 				try 
{
 					checkpointCoordinator.receiveAcknowledgeMessage(ackMessage);
 				}
&lt;p&gt; catch (Throwable t) &lt;/p&gt;
{
-					log.warn(&quot;Error while processing checkpoint acknowledgement message&quot;);
+					log.warn(&quot;Error while processing checkpoint acknowledgement message&quot;, t);
 				}
&lt;p&gt; 			});&lt;br/&gt;
 		} else {&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestServerEndpoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestServerEndpoint.java&lt;br/&gt;
index 43636dd8f9e..068192cf794 100644&lt;/p&gt;&lt;/li&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestServerEndpoint.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestServerEndpoint.java&lt;br/&gt;
@@ -63,6 +63,7 @@&lt;br/&gt;
 import java.util.Map;&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;br/&gt;
 import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.stream.Collectors;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;An abstract class for netty-based REST server endpoints.&lt;br/&gt;
@@ -85,6 +86,7 @@&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	private final CompletableFuture&amp;lt;Void&amp;gt; terminationFuture;&lt;/p&gt;

&lt;p&gt;+	private List&amp;lt;Tuple2&amp;lt;RestHandlerSpecification, ChannelInboundHandler&amp;gt;&amp;gt; handlers;&lt;br/&gt;
 	private ServerBootstrap bootstrap;&lt;br/&gt;
 	private Channel serverChannel;&lt;br/&gt;
 	private String restBaseUrl;&lt;br/&gt;
@@ -131,7 +133,7 @@ public final void start() throws Exception {&lt;br/&gt;
 			final Router router = new Router();&lt;br/&gt;
 			final CompletableFuture&amp;lt;String&amp;gt; restAddressFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;List&amp;lt;Tuple2&amp;lt;RestHandlerSpecification, ChannelInboundHandler&amp;gt;&amp;gt; handlers = initializeHandlers(restAddressFuture);&lt;br/&gt;
+			handlers = initializeHandlers(restAddressFuture);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			/* sort the handlers such that they are ordered the following:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/jobs&lt;br/&gt;
@@ -265,10 +267,13 @@ public String getRestBaseUrl() {&lt;br/&gt;
 			log.info(&quot;Shutting down rest endpoint.&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			if (state == State.RUNNING) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;Void&amp;gt; shutDownFuture = shutDownInternal();&lt;br/&gt;
+				final CompletableFuture&amp;lt;Void&amp;gt; shutDownFuture = FutureUtils.composeAfterwards(&lt;br/&gt;
+					closeHandlersAsync(),&lt;br/&gt;
+					this::shutDownInternal);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 				shutDownFuture.whenComplete(&lt;br/&gt;
 					(Void ignored, Throwable throwable) -&amp;gt; {&lt;br/&gt;
+						log.info(&quot;Shut down complete.&quot;);&lt;br/&gt;
 						if (throwable != null) &lt;/p&gt;
{
 							terminationFuture.completeExceptionally(throwable);
 						}
&lt;p&gt; else {&lt;br/&gt;
@@ -285,6 +290,14 @@ public String getRestBaseUrl() {&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	private FutureUtils.ConjunctFuture&amp;lt;Void&amp;gt; closeHandlersAsync() &lt;/p&gt;
{
+		return FutureUtils.waitForAll(handlers.stream()
+			.map(tuple -&amp;gt; tuple.f1)
+			.filter(handler -&amp;gt; handler instanceof AutoCloseableAsync)
+			.map(handler -&amp;gt; ((AutoCloseableAsync) handler).closeAsync())
+			.collect(Collectors.toList()));
+	}
&lt;p&gt;+&lt;br/&gt;
 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Stops this REST server endpoint.&lt;br/&gt;
 	 *&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/AbstractHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/AbstractHandler.java&lt;br/&gt;
similarity index 87%&lt;br/&gt;
rename from flink-runtime/src/main/java/org/apache/flink/runtime/rest/AbstractHandler.java&lt;br/&gt;
rename to flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/AbstractHandler.java&lt;br/&gt;
index 3d1ec9d0066..5a1c371d5a6 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/AbstractHandler.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/AbstractHandler.java&lt;br/&gt;
@@ -16,14 +16,11 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
  */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-package org.apache.flink.runtime.rest;&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler;&lt;/p&gt;

&lt;p&gt; import org.apache.flink.api.common.time.Time;&lt;br/&gt;
-import org.apache.flink.runtime.rest.handler.FileUploads;&lt;br/&gt;
-import org.apache.flink.runtime.rest.handler.HandlerRequest;&lt;br/&gt;
-import org.apache.flink.runtime.rest.handler.HandlerRequestException;&lt;br/&gt;
-import org.apache.flink.runtime.rest.handler.RedirectHandler;&lt;br/&gt;
-import org.apache.flink.runtime.rest.handler.RestHandlerException;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.runtime.rest.FileUploadHandler;&lt;br/&gt;
 import org.apache.flink.runtime.rest.handler.router.RoutedRequest;&lt;br/&gt;
 import org.apache.flink.runtime.rest.handler.util.HandlerUtils;&lt;br/&gt;
 import org.apache.flink.runtime.rest.messages.ErrorResponseBody;&lt;br/&gt;
@@ -33,6 +30,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.rest.util.RestMapperUtils;&lt;br/&gt;
 import org.apache.flink.runtime.webmonitor.RestfulGateway;&lt;br/&gt;
 import org.apache.flink.runtime.webmonitor.retriever.GatewayRetriever;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;/p&gt;

&lt;p&gt; import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonParseException;&lt;br/&gt;
@@ -64,7 +62,7 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param &amp;lt;R&amp;gt; type of the incoming request&lt;/li&gt;
	&lt;li&gt;@param &amp;lt;M&amp;gt; type of the message parameters&lt;br/&gt;
  */&lt;br/&gt;
-public abstract class AbstractHandler&amp;lt;T extends RestfulGateway, R extends RequestBody, M extends MessageParameters&amp;gt; extends RedirectHandler&amp;lt;T&amp;gt; {&lt;br/&gt;
+public abstract class AbstractHandler&amp;lt;T extends RestfulGateway, R extends RequestBody, M extends MessageParameters&amp;gt; extends RedirectHandler&amp;lt;T&amp;gt; implements AutoCloseableAsync 
{
 
 	protected final Logger log = LoggerFactory.getLogger(getClass());
 
@@ -72,6 +70,11 @@
 
 	private final UntypedResponseMessageHeaders&amp;lt;R, M&amp;gt; untypedResponseMessageHeaders;
 
+	/**
+	 * Used to ensure that the handler is not closed while there are still in-flight requests.
+	 */
+	private final InFlightRequestTracker inFlightRequestTracker;
+
 	protected AbstractHandler(
 			@Nonnull CompletableFuture&amp;lt;String&amp;gt; localAddressFuture,
 			@Nonnull GatewayRetriever&amp;lt;? extends T&amp;gt; leaderRetriever,
@@ -81,6 +84,7 @@ protected AbstractHandler(
 		super(localAddressFuture, leaderRetriever, timeout, responseHeaders);
 
 		this.untypedResponseMessageHeaders = Preconditions.checkNotNull(untypedResponseMessageHeaders);
+		this.inFlightRequestTracker = new InFlightRequestTracker();
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	@Override&lt;br/&gt;
@@ -92,6 +96,7 @@ protected void respondAsLeader(ChannelHandlerContext ctx, RoutedRequest routedRe&lt;/p&gt;

&lt;p&gt; 		FileUploads uploadedFiles = null;&lt;br/&gt;
 		try {&lt;br/&gt;
+			inFlightRequestTracker.registerRequest();&lt;br/&gt;
 			if (!(httpRequest instanceof FullHttpRequest)) {&lt;br/&gt;
 				// The RestServerEndpoint defines a HttpObjectAggregator in the pipeline that always returns&lt;br/&gt;
 				// FullHttpRequests.&lt;br/&gt;
@@ -154,8 +159,12 @@ protected void respondAsLeader(ChannelHandlerContext ctx, RoutedRequest routedRe&lt;/p&gt;

&lt;p&gt; 			final FileUploads finalUploadedFiles = uploadedFiles;&lt;br/&gt;
 			requestProcessingFuture&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;.whenComplete((Void ignored, Throwable throwable) -&amp;gt; cleanupFileUploads(finalUploadedFiles));&lt;br/&gt;
+				.whenComplete((Void ignored, Throwable throwable) -&amp;gt; 
{
+					inFlightRequestTracker.deregisterRequest();
+					cleanupFileUploads(finalUploadedFiles);
+				}
&lt;p&gt;);&lt;br/&gt;
 		} catch (RestHandlerException rhe) &lt;/p&gt;
{
+			inFlightRequestTracker.deregisterRequest();
 			HandlerUtils.sendErrorResponse(
 				ctx,
 				httpRequest,
@@ -164,6 +173,7 @@ protected void respondAsLeader(ChannelHandlerContext ctx, RoutedRequest routedRe
 				responseHeaders);
 			cleanupFileUploads(uploadedFiles);
 		}
&lt;p&gt; catch (Throwable e) &lt;/p&gt;
{
+			inFlightRequestTracker.deregisterRequest();
 			log.error(&quot;Request processing failed.&quot;, e);
 			HandlerUtils.sendErrorResponse(
 				ctx,
@@ -175,6 +185,15 @@ protected void respondAsLeader(ChannelHandlerContext ctx, RoutedRequest routedRe
 		}
&lt;p&gt; 	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	@Override&lt;br/&gt;
+	public final CompletableFuture&amp;lt;Void&amp;gt; closeAsync() &lt;/p&gt;
{
+		return FutureUtils.composeAfterwards(closeHandlerAsync(), inFlightRequestTracker::awaitAsync);
+	}
&lt;p&gt;+&lt;br/&gt;
+	protected CompletableFuture&amp;lt;Void&amp;gt; closeHandlerAsync() &lt;/p&gt;
{
+		return CompletableFuture.completedFuture(null);
+	}
&lt;p&gt;+&lt;br/&gt;
 	private void cleanupFileUploads(@Nullable FileUploads uploadedFiles) {&lt;br/&gt;
 		if (uploadedFiles != null) {&lt;br/&gt;
 			try &lt;/p&gt;
{
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/AbstractRestHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/AbstractRestHandler.java
index 9cfb58e98a8..0397cb875f2 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/AbstractRestHandler.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/AbstractRestHandler.java
@@ -21,7 +21,6 @@
 import org.apache.flink.api.common.time.Time;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.concurrent.FutureUtils;
-import org.apache.flink.runtime.rest.AbstractHandler;
 import org.apache.flink.runtime.rest.handler.util.HandlerUtils;
 import org.apache.flink.runtime.rest.messages.ErrorResponseBody;
 import org.apache.flink.runtime.rest.messages.MessageHeaders;
@@ -81,11 +80,9 @@ protected AbstractRestHandler(
 			response = FutureUtils.completedExceptionally(e);
 		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return response.whenComplete((P resp, Throwable throwable) -&amp;gt; 
{
-			Tuple2&amp;lt;ResponseBody, HttpResponseStatus&amp;gt; r = throwable != null ?
-				errorResponse(throwable) : Tuple2.of(resp, messageHeaders.getResponseStatusCode());
-			HandlerUtils.sendResponse(ctx, httpRequest, r.f0, r.f1, responseHeaders);
-		}
&lt;p&gt;).thenApply(ignored -&amp;gt; null);&lt;br/&gt;
+		return response.handle((resp, throwable) -&amp;gt; throwable != null ?&lt;br/&gt;
+			errorResponse(throwable) : Tuple2.of(resp, messageHeaders.getResponseStatusCode()))&lt;br/&gt;
+			.thenCompose(r -&amp;gt; HandlerUtils.sendResponse(ctx, httpRequest, r.f0, r.f1, responseHeaders));&lt;br/&gt;
 	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	private Tuple2&amp;lt;ResponseBody, HttpResponseStatus&amp;gt; errorResponse(Throwable throwable) {&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/InFlightRequestTracker.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/InFlightRequestTracker.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..92478b1886f&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/InFlightRequestTracker.java&lt;br/&gt;
@@ -0,0 +1,66 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.concurrent.ThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.Phaser;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tracks in-flight client requests.&lt;br/&gt;
+ *&lt;br/&gt;
+ * @see AbstractHandler&lt;br/&gt;
+ */&lt;br/&gt;
+@ThreadSafe&lt;br/&gt;
+class InFlightRequestTracker {&lt;br/&gt;
+&lt;br/&gt;
+	private final CompletableFuture&amp;lt;Void&amp;gt; terminationFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+	private final Phaser phaser = new Phaser(1) {&lt;br/&gt;
+		@Override&lt;br/&gt;
+		protected boolean onAdvance(final int phase, final int registeredParties) &lt;/p&gt;
{
+			terminationFuture.complete(null);
+			return true;
+		}
&lt;p&gt;+	};&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Registers an in-flight request.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public void registerRequest() &lt;/p&gt;
{
+		phaser.register();
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Deregisters an in-flight request.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public void deregisterRequest() &lt;/p&gt;
{
+		phaser.arriveAndDeregister();
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns a future that completes when the in-flight requests that were registered prior to&lt;br/&gt;
+	 * calling this method are deregistered.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; awaitAsync() &lt;/p&gt;
{
+		phaser.arriveAndDeregister();
+		return terminationFuture;
+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/AbstractAsynchronousOperationHandlers.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/AbstractAsynchronousOperationHandlers.java&lt;br/&gt;
index e0c3fbec152..32b04921e42 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/AbstractAsynchronousOperationHandlers.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/AbstractAsynchronousOperationHandlers.java&lt;br/&gt;
@@ -18,7 +18,6 @@&lt;/p&gt;

&lt;p&gt; package org.apache.flink.runtime.rest.handler.async;&lt;/p&gt;

&lt;p&gt;-import org.apache.flink.api.common.JobID;&lt;br/&gt;
 import org.apache.flink.api.common.time.Time;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
 import org.apache.flink.runtime.rest.NotFoundException;&lt;br/&gt;
@@ -29,24 +28,14 @@&lt;br/&gt;
 import org.apache.flink.runtime.rest.messages.MessageHeaders;&lt;br/&gt;
 import org.apache.flink.runtime.rest.messages.MessageParameters;&lt;br/&gt;
 import org.apache.flink.runtime.rest.messages.RequestBody;&lt;br/&gt;
-import org.apache.flink.runtime.rest.messages.TriggerId;&lt;br/&gt;
 import org.apache.flink.runtime.webmonitor.RestfulGateway;&lt;br/&gt;
 import org.apache.flink.runtime.webmonitor.retriever.GatewayRetriever;&lt;br/&gt;
 import org.apache.flink.types.Either;&lt;br/&gt;
-import org.apache.flink.util.FlinkException;&lt;br/&gt;
-&lt;br/&gt;
-import org.apache.flink.shaded.guava18.com.google.common.cache.Cache;&lt;br/&gt;
-import org.apache.flink.shaded.guava18.com.google.common.cache.CacheBuilder;&lt;/p&gt;

&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
-import javax.annotation.Nullable;&lt;br/&gt;
-import javax.annotation.concurrent.ThreadSafe;&lt;/p&gt;

&lt;p&gt; import java.util.Map;&lt;br/&gt;
-import java.util.Set;&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;br/&gt;
-import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
-import java.util.concurrent.TimeUnit;&lt;/p&gt;

&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;HTTP handlers for asynchronous operations.&lt;br/&gt;
@@ -176,7 +165,7 @@ protected StatusHandler(&lt;br/&gt;
 			final Either&amp;lt;Throwable, R&amp;gt; operationResultOrError;&lt;br/&gt;
 			try 
{
 				operationResultOrError = completedOperationCache.get(key);
-			}
&lt;p&gt; catch (UnknownOperationKey e) &lt;/p&gt;
{
+			}
&lt;p&gt; catch (UnknownOperationKeyException e) &lt;/p&gt;
{
 				return FutureUtils.completedExceptionally(
 					new NotFoundException(&quot;Operation not found under key: &quot; + key, e));
 			}
&lt;p&gt;@@ -194,6 +183,11 @@ protected StatusHandler(&lt;br/&gt;
 			}&lt;br/&gt;
 		}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+		@Override&lt;br/&gt;
+		public CompletableFuture&amp;lt;Void&amp;gt; closeHandlerAsync() &lt;/p&gt;
{
+			return completedOperationCache.closeAsync();
+		}
&lt;p&gt;+&lt;br/&gt;
 		/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Extract the operation key under which the operation result future is stored.&lt;br/&gt;
 		 *&lt;br/&gt;
@@ -220,79 +214,4 @@ protected StatusHandler(&lt;br/&gt;
 		protected abstract V operationResultResponse(R operationResult);&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Cache to manage ongoing operations.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;The cache allows to register ongoing operations by calling&lt;/li&gt;
	&lt;li&gt;* 
{@link #registerOngoingOperation(K, CompletableFuture)}, where the&lt;br/&gt;
-	 * {@code CompletableFuture} contains the operation result. Completed operations will be&lt;br/&gt;
-	 * removed from the cache automatically after a fixed timeout.&lt;br/&gt;
-	 */&lt;br/&gt;
-	@ThreadSafe&lt;br/&gt;
-	protected static class CompletedOperationCache&amp;lt;K, R&amp;gt; {&lt;br/&gt;
-&lt;br/&gt;
-		private static final long COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS = 300L;&lt;br/&gt;
-&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * Stores SavepointKeys of ongoing savepoint.&lt;br/&gt;
-		 * If the savepoint completes, it will be moved to {@link #completedOperations}.&lt;br/&gt;
-		 */&lt;br/&gt;
-		private final Set&amp;lt;K&amp;gt; registeredOperationTriggers = ConcurrentHashMap.newKeySet();&lt;br/&gt;
-&lt;br/&gt;
-		/** Caches the location of completed operations. */&lt;br/&gt;
-		private final Cache&amp;lt;K, Either&amp;lt;Throwable, R&amp;gt;&amp;gt; completedOperations =&lt;br/&gt;
-			CacheBuilder.newBuilder()&lt;br/&gt;
-				.expireAfterWrite(COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS, TimeUnit.SECONDS)&lt;br/&gt;
-				.build();&lt;br/&gt;
-&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * Registers an ongoing operation with the cache.&lt;br/&gt;
-		 *&lt;br/&gt;
-		 * @param operationResultFuture A future containing the operation result.&lt;br/&gt;
-		 */&lt;br/&gt;
-		public void registerOngoingOperation(&lt;br/&gt;
-			final K operationKey,&lt;br/&gt;
-			final CompletableFuture&amp;lt;R&amp;gt; operationResultFuture) {&lt;br/&gt;
-			registeredOperationTriggers.add(operationKey);&lt;br/&gt;
-			operationResultFuture.whenComplete((savepointLocation, error) -&amp;gt; {&lt;br/&gt;
-				if (error == null) {
-					completedOperations.put(operationKey, Either.Right(savepointLocation));
-				} else {
-					completedOperations.put(operationKey, Either.Left(error));
-				}&lt;br/&gt;
-				registeredOperationTriggers.remove(operationKey);&lt;br/&gt;
-			});&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * Returns the operation result or a {@code Throwable} if the {@code CompletableFuture}&lt;br/&gt;
-		 * finished, otherwise {@code null}.&lt;br/&gt;
-		 *&lt;br/&gt;
-		 * @throws UnknownOperationKey If the operation is not found, and there is no ongoing&lt;br/&gt;
-		 *                                   operation under the provided key.&lt;br/&gt;
-		 */&lt;br/&gt;
-		@Nullable&lt;br/&gt;
-		public Either&amp;lt;Throwable, R&amp;gt; get(&lt;br/&gt;
-			final K operationKey) throws UnknownOperationKey {&lt;br/&gt;
-			Either&amp;lt;Throwable, R&amp;gt; operationResultOrError = null;&lt;br/&gt;
-			if (!registeredOperationTriggers.contains(operationKey)&lt;br/&gt;
-				&amp;amp;&amp;amp; (operationResultOrError = completedOperations.getIfPresent(operationKey)) == null) {
-				throw new UnknownOperationKey(operationKey);
-			}&lt;br/&gt;
-			return operationResultOrError;&lt;br/&gt;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Exception that indicates that there is no ongoing or completed savepoint for a given&lt;br/&gt;
-	 * {@link JobID} and {@link TriggerId} pair.&lt;br/&gt;
-	 */&lt;br/&gt;
-	static class UnknownOperationKey extends FlinkException {&lt;br/&gt;
-		private static final long serialVersionUID = 1L;&lt;br/&gt;
-&lt;br/&gt;
-		UnknownOperationKey(final Object operationKey) {
-			super(&quot;No ongoing operation for &quot; + operationKey);
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..95bb2239fb2&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java&lt;br/&gt;
@@ -0,0 +1,216 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
+import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
+import org.apache.flink.types.Either;&lt;br/&gt;
+import org.apache.flink.util.AutoCloseableAsync;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.base.Ticker;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.Cache;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.CacheBuilder;&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.cache.RemovalListener;&lt;br/&gt;
+&lt;br/&gt;
+import org.slf4j.Logger;&lt;br/&gt;
+import org.slf4j.LoggerFactory;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.ThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.stream.Collectors;&lt;br/&gt;
+import java.util.stream.Stream;&lt;br/&gt;
+&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkState;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Cache to manage ongoing operations.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;The cache allows to register ongoing operations by calling&lt;br/&gt;
+ * {@link #registerOngoingOperation(K, CompletableFuture)}
&lt;p&gt;, where the&lt;br/&gt;
+ * &lt;/p&gt;
{@code CompletableFuture} contains the operation result. Completed operations will be&lt;br/&gt;
+ * removed from the cache automatically after a fixed timeout.&lt;br/&gt;
+ */&lt;br/&gt;
+@ThreadSafe&lt;br/&gt;
+class CompletedOperationCache&amp;lt;K extends OperationKey, R&amp;gt; implements AutoCloseableAsync {&lt;br/&gt;
+&lt;br/&gt;
+	private static final long COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS = 300L;&lt;br/&gt;
+&lt;br/&gt;
+	private static final Logger LOGGER = LoggerFactory.getLogger(CompletedOperationCache.class);&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * In-progress asynchronous operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Map&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; registeredOperationTriggers = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Caches the result of completed operations.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private final Cache&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt; completedOperations;&lt;br/&gt;
+&lt;br/&gt;
+	CompletedOperationCache() {
+		this(Ticker.systemTicker());
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	CompletedOperationCache(final Ticker ticker) {&lt;br/&gt;
+		completedOperations = CacheBuilder.newBuilder()&lt;br/&gt;
+			.expireAfterWrite(COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS, TimeUnit.SECONDS)&lt;br/&gt;
+			.removalListener((RemovalListener&amp;lt;K, ResultAccessTracker&amp;lt;R&amp;gt;&amp;gt;) removalNotification -&amp;gt; {&lt;br/&gt;
+				if (removalNotification.wasEvicted()) {&lt;br/&gt;
+					Preconditions.checkState(removalNotification.getKey() != null);&lt;br/&gt;
+					Preconditions.checkState(removalNotification.getValue() != null);&lt;br/&gt;
+&lt;br/&gt;
+					// When shutting down the cache, we wait until all results are accessed.&lt;br/&gt;
+					// When a result gets evicted from the cache, it will not be possible to access&lt;br/&gt;
+					// it any longer, and we might be in the process of shutting down, so we mark&lt;br/&gt;
+					// the result as accessed to avoid waiting indefinitely.&lt;br/&gt;
+					removalNotification.getValue().markAccessed();&lt;br/&gt;
+&lt;br/&gt;
+					LOGGER.info(&quot;Evicted result with trigger id {} because its TTL of {}s has expired.&quot;,&lt;br/&gt;
+						removalNotification.getKey().getTriggerId(),&lt;br/&gt;
+						COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS);&lt;br/&gt;
+				}&lt;br/&gt;
+			})&lt;br/&gt;
+			.ticker(ticker)&lt;br/&gt;
+			.build();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Registers an ongoing operation with the cache.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param operationResultFuture A future containing the operation result.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public void registerOngoingOperation(&lt;br/&gt;
+			final K operationKey,&lt;br/&gt;
+			final CompletableFuture&amp;lt;R&amp;gt; operationResultFuture) {&lt;br/&gt;
+		final ResultAccessTracker&amp;lt;R&amp;gt; inProgress = ResultAccessTracker.inProgress();&lt;br/&gt;
+		registeredOperationTriggers.put(operationKey, inProgress);&lt;br/&gt;
+		operationResultFuture.whenComplete((result, error) -&amp;gt; {&lt;br/&gt;
+			if (error == null) {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Right(result)));
+			} else {
+				completedOperations.put(operationKey, inProgress.finishOperation(Either.Left(error)));
+			}&lt;br/&gt;
+			registeredOperationTriggers.remove(operationKey);&lt;br/&gt;
+		});&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the operation result or a {@code Throwable} if the {@code CompletableFuture}
&lt;p&gt;+	 * finished, otherwise &lt;/p&gt;
{@code null}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @throws UnknownOperationKeyException If the operation is not found, and there is no ongoing&lt;br/&gt;
+	 *                                      operation under the provided key.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public Either&amp;lt;Throwable, R&amp;gt; get(&lt;br/&gt;
+			final K operationKey) throws UnknownOperationKeyException &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		ResultAccessTracker&amp;lt;R&amp;gt; resultAccessTracker;+		if ((resultAccessTracker = registeredOperationTriggers.get(operationKey)) == null+			&amp;amp;&amp;amp; (resultAccessTracker = completedOperations.getIfPresent(operationKey)) == null) {
+			throw new UnknownOperationKeyException(operationKey);
+		}++		return resultAccessTracker.accessOperationResultOrError();+	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public CompletableFuture&amp;lt;Void&amp;gt; closeAsync() &lt;/p&gt;
{
+		return FutureUtils.orTimeout(
+			asyncWaitForResultsToBeAccessed(),
+			COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS,
+			TimeUnit.SECONDS);
+	}
&lt;p&gt;+&lt;br/&gt;
+	private CompletableFuture&amp;lt;Void&amp;gt; asyncWaitForResultsToBeAccessed() &lt;/p&gt;
{
+		return FutureUtils.waitForAll(
+			Stream.concat(registeredOperationTriggers.values().stream(), completedOperations.asMap().values().stream())
+				.map(ResultAccessTracker::getAccessedFuture)
+				.collect(Collectors.toList()));
+	}
&lt;p&gt;+&lt;br/&gt;
+	@VisibleForTesting&lt;br/&gt;
+	void cleanUp() &lt;/p&gt;
{
+		completedOperations.cleanUp();
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Stores the result of an asynchronous operation, and tracks accesses to it.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private static class ResultAccessTracker&amp;lt;R&amp;gt; {&lt;br/&gt;
+&lt;br/&gt;
+		/** Result of an asynchronous operation. Null if operation is in progress. */&lt;br/&gt;
+		@Nullable&lt;br/&gt;
+		private final Either&amp;lt;Throwable, R&amp;gt; operationResultOrError;&lt;br/&gt;
+&lt;br/&gt;
+		/** Future that completes if a non-null &lt;/p&gt;
{@link #operationResultOrError}
&lt;p&gt; is accessed. */&lt;br/&gt;
+		private final CompletableFuture&amp;lt;Void&amp;gt; accessed;&lt;br/&gt;
+&lt;br/&gt;
+		private static &amp;lt;R&amp;gt; ResultAccessTracker&amp;lt;R&amp;gt; inProgress() &lt;/p&gt;
{
+			return new ResultAccessTracker&amp;lt;&amp;gt;();
+		}
&lt;p&gt;+&lt;br/&gt;
+		private ResultAccessTracker() &lt;/p&gt;
{
+			this.operationResultOrError = null;
+			this.accessed = new CompletableFuture&amp;lt;&amp;gt;();
+		}
&lt;p&gt;+&lt;br/&gt;
+		private ResultAccessTracker(final Either&amp;lt;Throwable, R&amp;gt; operationResultOrError, final CompletableFuture&amp;lt;Void&amp;gt; accessed) &lt;/p&gt;
{
+			this.operationResultOrError = checkNotNull(operationResultOrError);
+			this.accessed = checkNotNull(accessed);
+		}
&lt;p&gt;+&lt;br/&gt;
+		/**&lt;br/&gt;
+		 * Creates a new instance of the tracker with the result of the asynchronous operation set.&lt;br/&gt;
+		 */&lt;br/&gt;
+		public ResultAccessTracker&amp;lt;R&amp;gt; finishOperation(final Either&amp;lt;Throwable, R&amp;gt; operationResultOrError) &lt;/p&gt;
{
+			checkState(this.operationResultOrError == null);
+
+			return new ResultAccessTracker&amp;lt;&amp;gt;(checkNotNull(operationResultOrError), this.accessed);
+		}
&lt;p&gt;+&lt;br/&gt;
+		/**&lt;br/&gt;
+		 * If present, returns the result of the asynchronous operation, and marks the result as&lt;br/&gt;
+		 * accessed. If the result is not present, this method returns null.&lt;br/&gt;
+		 */&lt;br/&gt;
+		@Nullable&lt;br/&gt;
+		public Either&amp;lt;Throwable, R&amp;gt; accessOperationResultOrError() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			if (operationResultOrError != null) {
+				markAccessed();
+			}+			return operationResultOrError;+		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+		public CompletableFuture&amp;lt;Void&amp;gt; getAccessedFuture() &lt;/p&gt;
{
+			return accessed;
+		}
&lt;p&gt;+&lt;br/&gt;
+		private void markAccessed() &lt;/p&gt;
{
+			accessed.complete(null);
+		}
&lt;p&gt;+&lt;br/&gt;
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/UnknownOperationKeyException.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/UnknownOperationKeyException.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..962b80fe5e6&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;/dev/null&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/UnknownOperationKeyException.java&lt;br/&gt;
@@ -0,0 +1,35 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.JobID;&lt;br/&gt;
+import org.apache.flink.runtime.rest.messages.TriggerId;&lt;br/&gt;
+import org.apache.flink.util.FlinkException;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Exception that indicates that there is no ongoing or completed savepoint for a given&lt;br/&gt;
+ * 
{@link JobID} and {@link TriggerId} pair.&lt;br/&gt;
+ */&lt;br/&gt;
+class UnknownOperationKeyException extends FlinkException {&lt;br/&gt;
+	private static final long serialVersionUID = 1L;&lt;br/&gt;
+&lt;br/&gt;
+	UnknownOperationKeyException(final Object operationKey) {
+		super(&quot;No ongoing operation for &quot; + operationKey);
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/job/AsynchronousJobOperationKey.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/job/AsynchronousJobOperationKey.java&lt;br/&gt;
index 4bb473e9ceb..e773702274f 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/job/AsynchronousJobOperationKey.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/job/AsynchronousJobOperationKey.java&lt;br/&gt;
@@ -33,7 +33,7 @@&lt;br/&gt;
  * A pair of {@link JobID}
&lt;p&gt; and &lt;/p&gt;
{@link TriggerId}
&lt;p&gt; used as a key to a hash based&lt;/p&gt;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;collection.&lt;br/&gt;
  *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @see AbstractAsynchronousOperationHandlers.CompletedOperationCache&lt;br/&gt;
+ * @see AbstractAsynchronousOperationHandlers&lt;br/&gt;
  */&lt;br/&gt;
 @Immutable&lt;br/&gt;
 public class AsynchronousJobOperationKey extends OperationKey 
{
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/taskmanager/AbstractTaskManagerFileHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/taskmanager/AbstractTaskManagerFileHandler.java
index 4c7ac9406b1..8a20868ce37 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/taskmanager/AbstractTaskManagerFileHandler.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/taskmanager/AbstractTaskManagerFileHandler.java
@@ -24,7 +24,7 @@
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;
 import org.apache.flink.runtime.resourcemanager.exceptions.UnknownTaskExecutorException;
-import org.apache.flink.runtime.rest.AbstractHandler;
+import org.apache.flink.runtime.rest.handler.AbstractHandler;
 import org.apache.flink.runtime.rest.handler.HandlerRequest;
 import org.apache.flink.runtime.rest.handler.RestHandlerException;
 import org.apache.flink.runtime.rest.handler.util.HandlerUtils;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/util/HandlerUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/util/HandlerUtils.java
index b407ada46e6..b60afbb5948 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/util/HandlerUtils.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/util/HandlerUtils.java
@@ -45,6 +45,7 @@
 import java.io.IOException;
 import java.io.StringWriter;
 import java.util.Map;
+import java.util.concurrent.CompletableFuture;
 
 import static org.apache.flink.shaded.netty4.io.netty.handler.codec.http.HttpHeaders.Names.CONNECTION;
 import static org.apache.flink.shaded.netty4.io.netty.handler.codec.http.HttpHeaders.Names.CONTENT_TYPE;
@@ -69,7 +70,7 @@
 	 * @param headers additional header values
 	 * @param &amp;lt;P&amp;gt; type of the response
 	 */
-	public static &amp;lt;P extends ResponseBody&amp;gt; void sendResponse(
+	public static &amp;lt;P extends ResponseBody&amp;gt; CompletableFuture&amp;lt;Void&amp;gt; sendResponse(
 			ChannelHandlerContext channelHandlerContext,
 			HttpRequest httpRequest,
 			P response,
@@ -80,15 +81,14 @@
 			mapper.writeValue(sw, response);
 		}
&lt;p&gt; catch (IOException ioe) &lt;/p&gt;
{
 			LOG.error(&quot;Internal server error. Could not map response to JSON.&quot;, ioe);
-			sendErrorResponse(
+			return sendErrorResponse(
 				channelHandlerContext,
 				httpRequest,
 				new ErrorResponseBody(&quot;Internal server error. Could not map response to JSON.&quot;),
 				HttpResponseStatus.INTERNAL_SERVER_ERROR,
 				headers);
-			return;
 		}&lt;/li&gt;
	&lt;li&gt;sendResponse(&lt;br/&gt;
+		return sendResponse(&lt;br/&gt;
 			channelHandlerContext,&lt;br/&gt;
 			httpRequest,&lt;br/&gt;
 			sw.toString(),&lt;br/&gt;
@@ -105,14 +105,14 @@&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@param statusCode of the message to send&lt;/li&gt;
	&lt;li&gt;@param headers additional header values&lt;br/&gt;
 	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static void sendErrorResponse(&lt;br/&gt;
+	public static CompletableFuture&amp;lt;Void&amp;gt; sendErrorResponse(&lt;br/&gt;
 			ChannelHandlerContext channelHandlerContext,&lt;br/&gt;
 			HttpRequest httpRequest,&lt;br/&gt;
 			ErrorResponseBody errorMessage,&lt;br/&gt;
 			HttpResponseStatus statusCode,&lt;br/&gt;
 			Map&amp;lt;String, String&amp;gt; headers) 
{
 
-		sendErrorResponse(
+		return sendErrorResponse(
 			channelHandlerContext,
 			HttpHeaders.isKeepAlive(httpRequest),
 			errorMessage,
@@ -129,7 +129,7 @@ public static void sendErrorResponse(
 	 * @param statusCode of the message to send
 	 * @param headers additional header values
 	 */
-	public static void sendErrorResponse(
+	public static CompletableFuture&amp;lt;Void&amp;gt; sendErrorResponse(
 			ChannelHandlerContext channelHandlerContext,
 			boolean keepAlive,
 			ErrorResponseBody errorMessage,
@@ -142,14 +142,14 @@ public static void sendErrorResponse(
 		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
 			// this should never happen
 			LOG.error(&quot;Internal server error. Could not map error response to JSON.&quot;, e);
-			sendResponse(
+			return sendResponse(
 				channelHandlerContext,
 				keepAlive,
 				&quot;Internal server error. Could not map error response to JSON.&quot;,
 				HttpResponseStatus.INTERNAL_SERVER_ERROR,
 				headers);
 		}&lt;/li&gt;
	&lt;li&gt;sendResponse(&lt;br/&gt;
+		return sendResponse(&lt;br/&gt;
 			channelHandlerContext,&lt;br/&gt;
 			keepAlive,&lt;br/&gt;
 			sw.toString(),&lt;br/&gt;
@@ -166,14 +166,14 @@ public static void sendErrorResponse(&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@param statusCode of the message to send&lt;/li&gt;
	&lt;li&gt;@param headers additional header values&lt;br/&gt;
 	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static void sendResponse(&lt;br/&gt;
+	public static CompletableFuture&amp;lt;Void&amp;gt; sendResponse(&lt;br/&gt;
 			@Nonnull ChannelHandlerContext channelHandlerContext,&lt;br/&gt;
 			@Nonnull HttpRequest httpRequest,&lt;br/&gt;
 			@Nonnull String message,&lt;br/&gt;
 			@Nonnull HttpResponseStatus statusCode,&lt;br/&gt;
 			@Nonnull Map&amp;lt;String, String&amp;gt; headers) {&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;sendResponse(&lt;br/&gt;
+		return sendResponse(&lt;br/&gt;
 			channelHandlerContext,&lt;br/&gt;
 			HttpHeaders.isKeepAlive(httpRequest),&lt;br/&gt;
 			message,&lt;br/&gt;
@@ -190,7 +190,7 @@ public static void sendResponse(&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@param statusCode of the message to send&lt;/li&gt;
	&lt;li&gt;@param headers additional header values&lt;br/&gt;
 	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static void sendResponse(&lt;br/&gt;
+	public static CompletableFuture&amp;lt;Void&amp;gt; sendResponse(&lt;br/&gt;
 			@Nonnull ChannelHandlerContext channelHandlerContext,&lt;br/&gt;
 			boolean keepAlive,&lt;br/&gt;
 			@Nonnull String message,&lt;br/&gt;
@@ -223,5 +223,19 @@ public static void sendResponse(&lt;br/&gt;
 		if (!keepAlive) 
{
 			lastContentFuture.addListener(ChannelFutureListener.CLOSE);
 		}
&lt;p&gt;+&lt;br/&gt;
+		return toCompletableFuture(lastContentFuture);&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private static CompletableFuture&amp;lt;Void&amp;gt; toCompletableFuture(final ChannelFuture channelFuture) {&lt;br/&gt;
+		final CompletableFuture&amp;lt;Void&amp;gt; completableFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
+		channelFuture.addListener(future -&amp;gt; &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			if (future.isSuccess()) {
+				completableFuture.complete(null);
+			} else {
+				completableFuture.completeExceptionally(future.cause());
+			}+		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;br/&gt;
+		return completableFuture;&lt;br/&gt;
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/FileArchivedExecutionGraphStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/FileArchivedExecutionGraphStoreTest.java&lt;br/&gt;
index c289634bc07..cc116dd7714 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/FileArchivedExecutionGraphStoreTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/FileArchivedExecutionGraphStoreTest.java&lt;br/&gt;
@@ -27,6 +27,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.messages.webmonitor.JobsOverview;&lt;br/&gt;
 import org.apache.flink.runtime.rest.handler.legacy.utils.ArchivedExecutionGraphBuilder;&lt;br/&gt;
 import org.apache.flink.runtime.testingUtils.TestingUtils;&lt;br/&gt;
+import org.apache.flink.runtime.util.ManualTicker;&lt;br/&gt;
 import org.apache.flink.runtime.webmonitor.WebMonitorUtils;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;br/&gt;
@@ -281,20 +282,6 @@ private FileArchivedExecutionGraphStore createDefaultExecutionGraphStore(File st&lt;br/&gt;
 			Ticker.systemTicker());&lt;br/&gt;
 	}&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final class ManualTicker extends Ticker {&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private long currentTime = 0;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public long read() 
{
-			return currentTime;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;void advanceTime(long duration, TimeUnit timeUnit) 
{
-			currentTime += timeUnit.toNanos(duration);
-		}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;br/&gt;
 	private static final class PartialArchivedExecutionGraphMatcher extends BaseMatcher&amp;lt;ArchivedExecutionGraph&amp;gt; {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		private final ArchivedExecutionGraph archivedExecutionGraph;&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestServerEndpointITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestServerEndpointITCase.java&lt;br/&gt;
index 430bfad38fd..0c28745518e 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestServerEndpointITCase.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/RestServerEndpointITCase.java&lt;br/&gt;
@@ -91,14 +91,18 @@&lt;br/&gt;
 import java.util.Collections;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.CountDownLatch;&lt;br/&gt;
 import java.util.concurrent.ExecutionException;&lt;br/&gt;
 import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.function.Function;&lt;br/&gt;
 import java.util.stream.Collectors;&lt;/p&gt;

&lt;p&gt; import static java.util.Objects.requireNonNull;&lt;br/&gt;
+import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
 import static org.hamcrest.CoreMatchers.hasItems;&lt;br/&gt;
 import static org.hamcrest.Matchers.containsString;&lt;br/&gt;
 import static org.hamcrest.Matchers.instanceOf;&lt;br/&gt;
+import static org.hamcrest.Matchers.is;&lt;br/&gt;
 import static org.junit.Assert.assertEquals;&lt;br/&gt;
 import static org.junit.Assert.assertThat;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;br/&gt;
@@ -131,6 +135,8 @@&lt;br/&gt;
 	private SSLContext defaultSSLContext;&lt;br/&gt;
 	private SSLSocketFactory defaultSSLSocketFactory;&lt;/p&gt;

&lt;p&gt;+	private TestHandler testHandler;&lt;br/&gt;
+&lt;br/&gt;
 	public RestServerEndpointITCase(final Configuration config) &lt;/p&gt;
{
 		this.config = requireNonNull(config);
 	}
&lt;p&gt;@@ -194,7 +200,7 @@ public void setup() throws Exception {&lt;br/&gt;
 		final GatewayRetriever&amp;lt;RestfulGateway&amp;gt; mockGatewayRetriever = () -&amp;gt;&lt;br/&gt;
 			CompletableFuture.completedFuture(mockRestfulGateway);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TestHandler testHandler = new TestHandler(&lt;br/&gt;
+		testHandler = new TestHandler(&lt;br/&gt;
 			CompletableFuture.completedFuture(restAddress),&lt;br/&gt;
 			mockGatewayRetriever,&lt;br/&gt;
 			RpcUtils.INF_TIMEOUT);&lt;br/&gt;
@@ -253,7 +259,7 @@ public void teardown() throws Exception {&lt;br/&gt;
 		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		if (serverEndpoint != null) &lt;/p&gt;
{
-			serverEndpoint.close();
+			serverEndpoint.closeAsync().get(timeout.getSize(), timeout.getUnit());
 			serverEndpoint = null;
 		}
&lt;p&gt; 	}&lt;br/&gt;
@@ -264,37 +270,25 @@ public void teardown() throws Exception {&lt;br/&gt;
 	 */&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testRequestInterleaving() throws Exception {&lt;br/&gt;
-&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TestParameters parameters = new TestParameters();&lt;/li&gt;
	&lt;li&gt;parameters.jobIDPathParameter.resolve(PATH_JOB_ID);&lt;/li&gt;
	&lt;li&gt;parameters.jobIDQueryParameter.resolve(Collections.singletonList(QUERY_JOB_ID));&lt;br/&gt;
+		final HandlerBlocker handlerBlocker = new HandlerBlocker(timeout);&lt;br/&gt;
+		testHandler.handlerBody = id -&amp;gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			if (id == 1) {
+				handlerBlocker.arriveAndBlock();
+			}+			return CompletableFuture.completedFuture(new TestResponse(id));+		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// send first request and wait until the handler blocks&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompletableFuture&amp;lt;TestResponse&amp;gt; response1;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;synchronized (TestHandler.LOCK) 
{
-			response1 = restClient.sendRequest(
-				serverAddress.getHostName(),
-				serverAddress.getPort(),
-				new TestHeaders(),
-				parameters,
-				new TestRequest(1));
-			TestHandler.LOCK.wait();
-		}
&lt;p&gt;+		final CompletableFuture&amp;lt;TestResponse&amp;gt; response1 = sendRequestToTestHandler(new TestRequest(1));&lt;br/&gt;
+		handlerBlocker.awaitRequestToArrive();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// send second request and verify response&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompletableFuture&amp;lt;TestResponse&amp;gt; response2 = restClient.sendRequest(&lt;/li&gt;
	&lt;li&gt;serverAddress.getHostName(),&lt;/li&gt;
	&lt;li&gt;serverAddress.getPort(),&lt;/li&gt;
	&lt;li&gt;new TestHeaders(),&lt;/li&gt;
	&lt;li&gt;parameters,&lt;/li&gt;
	&lt;li&gt;new TestRequest(2));&lt;br/&gt;
+		final CompletableFuture&amp;lt;TestResponse&amp;gt; response2 = sendRequestToTestHandler(new TestRequest(2));&lt;br/&gt;
 		assertEquals(2, response2.get().id);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// wake up blocked handler&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;synchronized (TestHandler.LOCK) 
{
-			TestHandler.LOCK.notifyAll();
-		}
&lt;p&gt;+		handlerBlocker.unblockRequest();&lt;br/&gt;
+&lt;br/&gt;
 		// verify response to first request&lt;br/&gt;
 		assertEquals(1, response1.get().id);&lt;br/&gt;
 	}&lt;br/&gt;
@@ -335,41 +329,34 @@ public void testBadHandlerRequest() throws Exception {&lt;br/&gt;
 	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Tests that requests and responses larger than 
{@link #TEST_REST_MAX_CONTENT_LENGTH}&lt;br/&gt;
-	 * are rejected by the server and client, respectively.&lt;br/&gt;
+	 * Tests that requests larger than {@link #TEST_REST_MAX_CONTENT_LENGTH}
&lt;p&gt; are rejected.&lt;br/&gt;
 	 */&lt;br/&gt;
 	@Test&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public void testMaxContentLengthLimit() throws Exception {&lt;/li&gt;
	&lt;li&gt;final TestParameters parameters = new TestParameters();&lt;/li&gt;
	&lt;li&gt;parameters.jobIDPathParameter.resolve(PATH_JOB_ID);&lt;/li&gt;
	&lt;li&gt;parameters.jobIDQueryParameter.resolve(Collections.singletonList(QUERY_JOB_ID));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;CompletableFuture&amp;lt;TestResponse&amp;gt; response;&lt;/li&gt;
	&lt;li&gt;response = restClient.sendRequest(&lt;/li&gt;
	&lt;li&gt;serverAddress.getHostName(),&lt;/li&gt;
	&lt;li&gt;serverAddress.getPort(),&lt;/li&gt;
	&lt;li&gt;new TestHeaders(),&lt;/li&gt;
	&lt;li&gt;parameters,&lt;/li&gt;
	&lt;li&gt;new TestRequest(2, createStringOfSize(TEST_REST_MAX_CONTENT_LENGTH)));&lt;br/&gt;
+	public void testShouldRespectMaxContentLengthLimitForRequests() throws Exception {&lt;br/&gt;
+		testHandler.handlerBody = id -&amp;gt; 
{
+			throw new AssertionError(&quot;Request should not arrive at server.&quot;);
+		}
&lt;p&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		try &lt;/p&gt;
{
-			response.get();
+			sendRequestToTestHandler(new TestRequest(2, createStringOfSize(TEST_REST_MAX_CONTENT_LENGTH))).get();
 			fail(&quot;Expected exception not thrown&quot;);
 		}
&lt;p&gt; catch (final ExecutionException e) &lt;/p&gt;
{
 			final Throwable throwable = ExceptionUtils.stripExecutionException(e);
 			assertThat(throwable, instanceOf(RestClientException.class));
 			assertThat(throwable.getMessage(), containsString(&quot;Try to raise&quot;));
 		}
&lt;p&gt;+	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;response = restClient.sendRequest(&lt;/li&gt;
	&lt;li&gt;serverAddress.getHostName(),&lt;/li&gt;
	&lt;li&gt;serverAddress.getPort(),&lt;/li&gt;
	&lt;li&gt;new TestHeaders(),&lt;/li&gt;
	&lt;li&gt;parameters,&lt;/li&gt;
	&lt;li&gt;new TestRequest(TestHandler.LARGE_RESPONSE_BODY_ID));&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that responses larger than 
{@link #TEST_REST_MAX_CONTENT_LENGTH}
&lt;p&gt; are rejected.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testShouldRespectMaxContentLengthLimitForResponses() throws Exception {&lt;br/&gt;
+		testHandler.handlerBody = id -&amp;gt; CompletableFuture.completedFuture(&lt;br/&gt;
+			new TestResponse(id, createStringOfSize(TEST_REST_MAX_CONTENT_LENGTH)));&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		try &lt;/p&gt;
{
-			response.get();
+			sendRequestToTestHandler(new TestRequest(1)).get();
 			fail(&quot;Expected exception not thrown&quot;);
 		}
&lt;p&gt; catch (final ExecutionException e) {&lt;br/&gt;
 			final Throwable throwable = ExceptionUtils.stripExecutionException(e);&lt;br/&gt;
@@ -545,6 +532,43 @@ public void testNonSslRedirectForEnabledSsl() throws Exception {&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * Tests that after calling &lt;/p&gt;
{@link RestServerEndpoint#closeAsync()}
&lt;p&gt;, the handlers are closed&lt;br/&gt;
+	 * first, and we wait for in-flight requests to finish. As long as not all handlers are closed,&lt;br/&gt;
+	 * HTTP requests should be served.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testShouldWaitForHandlersWhenClosing() throws Exception {&lt;br/&gt;
+		testHandler.closeFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
+		final HandlerBlocker handlerBlocker = new HandlerBlocker(timeout);&lt;br/&gt;
+		testHandler.handlerBody = id -&amp;gt; {&lt;br/&gt;
+			// Intentionally schedule the work on a different thread. This is to simulate&lt;br/&gt;
+			// handlers where the CompletableFuture is finished by the RPC framework.&lt;br/&gt;
+			return CompletableFuture.supplyAsync(() -&amp;gt; &lt;/p&gt;
{
+				handlerBlocker.arriveAndBlock();
+				return new TestResponse(id);
+			}
&lt;p&gt;);&lt;br/&gt;
+		};&lt;br/&gt;
+&lt;br/&gt;
+		// Initiate closing RestServerEndpoint but the test handler should block.&lt;br/&gt;
+		final CompletableFuture&amp;lt;Void&amp;gt; closeRestServerEndpointFuture = serverEndpoint.closeAsync();&lt;br/&gt;
+		assertThat(closeRestServerEndpointFuture.isDone(), is(false));&lt;br/&gt;
+&lt;br/&gt;
+		final CompletableFuture&amp;lt;TestResponse&amp;gt; request = sendRequestToTestHandler(new TestRequest(1));&lt;br/&gt;
+		handlerBlocker.awaitRequestToArrive();&lt;br/&gt;
+&lt;br/&gt;
+		// Allow handler to close but there is still one in-flight request which should prevent&lt;br/&gt;
+		// the RestServerEndpoint from closing.&lt;br/&gt;
+		testHandler.closeFuture.complete(null);&lt;br/&gt;
+		assertThat(closeRestServerEndpointFuture.isDone(), is(false));&lt;br/&gt;
+&lt;br/&gt;
+		// Finish the in-flight request.&lt;br/&gt;
+		handlerBlocker.unblockRequest();&lt;br/&gt;
+&lt;br/&gt;
+		request.get(timeout.getSize(), timeout.getUnit());&lt;br/&gt;
+		closeRestServerEndpointFuture.get(timeout.getSize(), timeout.getUnit());&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	private HttpURLConnection openHttpConnectionForUpload(final String boundary) throws IOException {&lt;br/&gt;
 		final HttpURLConnection connection =&lt;br/&gt;
 			(HttpURLConnection) new URL(serverEndpoint.getRestBaseUrl() + &quot;/upload&quot;).openConnection();&lt;br/&gt;
@@ -587,9 +611,9 @@ protected void startInternal() {}&lt;/p&gt;

&lt;p&gt; 	private static class TestHandler extends AbstractRestHandler&amp;lt;RestfulGateway, TestRequest, TestResponse, TestParameters&amp;gt; {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final Object LOCK = new Object();&lt;br/&gt;
+		private CompletableFuture&amp;lt;Void&amp;gt; closeFuture = CompletableFuture.completedFuture(null);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final int LARGE_RESPONSE_BODY_ID = 3;&lt;br/&gt;
+		private Function&amp;lt;Integer, CompletableFuture&amp;lt;TestResponse&amp;gt;&amp;gt; handlerBody;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		TestHandler(&lt;br/&gt;
 				CompletableFuture&amp;lt;String&amp;gt; localAddressFuture,&lt;br/&gt;
@@ -604,25 +628,89 @@ protected void startInternal() {}&lt;br/&gt;
 		}&lt;/p&gt;

&lt;p&gt; 		@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected CompletableFuture&amp;lt;TestResponse&amp;gt; handleRequest(@Nonnull HandlerRequest&amp;lt;TestRequest, TestParameters&amp;gt; request, RestfulGateway gateway) throws RestHandlerException {&lt;br/&gt;
+		protected CompletableFuture&amp;lt;TestResponse&amp;gt; handleRequest(@Nonnull HandlerRequest&amp;lt;TestRequest, TestParameters&amp;gt; request, RestfulGateway gateway) {&lt;br/&gt;
 			assertEquals(request.getPathParameter(JobIDPathParameter.class), PATH_JOB_ID);&lt;br/&gt;
 			assertEquals(request.getQueryParameter(JobIDQueryParameter.class).get(0), QUERY_JOB_ID);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			final int id = request.getRequestBody().id;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (id == 1) {&lt;/li&gt;
	&lt;li&gt;synchronized (LOCK) {&lt;/li&gt;
	&lt;li&gt;try 
{
-						LOCK.notifyAll();
-						LOCK.wait();
-					}
&lt;p&gt; catch (InterruptedException ignored) &lt;/p&gt;
{
-					}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;} else if (id == LARGE_RESPONSE_BODY_ID) 
{
-				return CompletableFuture.completedFuture(new TestResponse(
-					id,
-					createStringOfSize(TEST_REST_MAX_CONTENT_LENGTH)));
+			return handlerBody.apply(id);
+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public CompletableFuture&amp;lt;Void&amp;gt; closeHandlerAsync() &lt;/p&gt;
{
+			return closeFuture;
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	private CompletableFuture&amp;lt;TestResponse&amp;gt; sendRequestToTestHandler(final TestRequest testRequest) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		try {
+			return restClient.sendRequest(
+				serverAddress.getHostName(),
+				serverAddress.getPort(),
+				new TestHeaders(),
+				createTestParameters(),
+				testRequest);
+		} catch (final IOException e) {
+			throw new RuntimeException(e);
+		}+	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+	private static TestParameters createTestParameters() &lt;/p&gt;
{
+		final TestParameters parameters = new TestParameters();
+		parameters.jobIDPathParameter.resolve(PATH_JOB_ID);
+		parameters.jobIDQueryParameter.resolve(Collections.singletonList(QUERY_JOB_ID));
+		return parameters;
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This is a helper class for tests that require to have fine-grained control over HTTP&lt;br/&gt;
+	 * requests so that they are not dispatched immediately.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private static class HandlerBlocker {&lt;br/&gt;
+&lt;br/&gt;
+		private final Time timeout;&lt;br/&gt;
+&lt;br/&gt;
+		private final CountDownLatch requestArrivedLatch = new CountDownLatch(1);&lt;br/&gt;
+&lt;br/&gt;
+		private final CountDownLatch finishRequestLatch = new CountDownLatch(1);&lt;br/&gt;
+&lt;br/&gt;
+		private HandlerBlocker(final Time timeout) &lt;/p&gt;
{
+			this.timeout = checkNotNull(timeout);
+		}
&lt;p&gt;+&lt;br/&gt;
+		/**&lt;br/&gt;
+		 * Waits until &lt;/p&gt;
{@link #arriveAndBlock()}
&lt;p&gt; is called.&lt;br/&gt;
+		 */&lt;br/&gt;
+		public void awaitRequestToArrive() {&lt;br/&gt;
+			try &lt;/p&gt;
{
+				assertTrue(requestArrivedLatch.await(timeout.getSize(), timeout.getUnit()));
+			}
&lt;p&gt; catch (final InterruptedException e) &lt;/p&gt;
{
+				Thread.currentThread().interrupt();
 			}&lt;/li&gt;
	&lt;li&gt;return CompletableFuture.completedFuture(new TestResponse(id));&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		/**&lt;br/&gt;
+		 * Signals that the request arrived. This method blocks until 
{@link #unblockRequest()}
&lt;p&gt; is&lt;br/&gt;
+		 * called.&lt;br/&gt;
+		 */&lt;br/&gt;
+		public void arriveAndBlock() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			markRequestArrived();+			try {
+				assertTrue(finishRequestLatch.await(timeout.getSize(), timeout.getUnit()));
+			} catch (final InterruptedException e) {
+				Thread.currentThread().interrupt();
+			}+		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+		/**&lt;br/&gt;
+		 * @see #arriveAndBlock()&lt;br/&gt;
+		 */&lt;br/&gt;
+		public void unblockRequest() &lt;/p&gt;
{
+			finishRequestLatch.countDown();
+		}
&lt;p&gt;+&lt;br/&gt;
+		private void markRequestArrived() &lt;/p&gt;
{
+			requestArrivedLatch.countDown();
 		}
&lt;p&gt; 	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/AbstractHandlerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/AbstractHandlerTest.java&lt;br/&gt;
similarity index 96%&lt;br/&gt;
rename from flink-runtime/src/test/java/org/apache/flink/runtime/rest/AbstractHandlerTest.java&lt;br/&gt;
rename to flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/AbstractHandlerTest.java&lt;br/&gt;
index 607c1c4bb06..ebb6656fdcd 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/AbstractHandlerTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/AbstractHandlerTest.java&lt;br/&gt;
@@ -16,11 +16,9 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
  */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-package org.apache.flink.runtime.rest;&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler;&lt;/p&gt;

&lt;p&gt;-import org.apache.flink.runtime.rest.handler.FileUploads;&lt;br/&gt;
-import org.apache.flink.runtime.rest.handler.HandlerRequest;&lt;br/&gt;
-import org.apache.flink.runtime.rest.handler.RestHandlerException;&lt;br/&gt;
+import org.apache.flink.runtime.rest.HttpMethodWrapper;&lt;br/&gt;
 import org.apache.flink.runtime.rest.handler.router.RouteResult;&lt;br/&gt;
 import org.apache.flink.runtime.rest.handler.router.RoutedRequest;&lt;br/&gt;
 import org.apache.flink.runtime.rest.messages.EmptyMessageParameters;&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/InFlightRequestTrackerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/InFlightRequestTrackerTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..c486571d9cf&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/InFlightRequestTrackerTest.java&lt;br/&gt;
@@ -0,0 +1,81 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler;&lt;br/&gt;
+&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertFalse;&lt;br/&gt;
+import static org.junit.Assert.assertSame;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tests for &lt;/p&gt;
{@link InFlightRequestTracker}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class InFlightRequestTrackerTest {&lt;br/&gt;
+&lt;br/&gt;
+	private InFlightRequestTracker inFlightRequestTracker;&lt;br/&gt;
+&lt;br/&gt;
+	@Before&lt;br/&gt;
+	public void setUp() &lt;/p&gt;
{
+		inFlightRequestTracker = new InFlightRequestTracker();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testShouldFinishAwaitAsyncImmediatelyIfNoRequests() &lt;/p&gt;
{
+		assertTrue(inFlightRequestTracker.awaitAsync().isDone());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testShouldFinishAwaitAsyncIffAllRequestsDeregistered() &lt;/p&gt;
{
+		inFlightRequestTracker.registerRequest();
+
+		final CompletableFuture&amp;lt;Void&amp;gt; awaitFuture = inFlightRequestTracker.awaitAsync();
+		assertFalse(awaitFuture.isDone());
+
+		inFlightRequestTracker.deregisterRequest();
+		assertTrue(awaitFuture.isDone());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testAwaitAsyncIsIdempotent() &lt;/p&gt;
{
+		final CompletableFuture&amp;lt;Void&amp;gt; awaitFuture = inFlightRequestTracker.awaitAsync();
+		assertTrue(awaitFuture.isDone());
+
+		assertSame(
+			&quot;The reference to the future must not change&quot;,
+			awaitFuture,
+			inFlightRequestTracker.awaitAsync());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testShouldTolerateRegisterAfterAwaitAsync() &lt;/p&gt;
{
+		final CompletableFuture&amp;lt;Void&amp;gt; awaitFuture = inFlightRequestTracker.awaitAsync();
+		assertTrue(awaitFuture.isDone());
+
+		inFlightRequestTracker.registerRequest();
+
+		assertSame(
+			&quot;The reference to the future must not change&quot;,
+			awaitFuture,
+			inFlightRequestTracker.awaitAsync());
+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/async/AbstractAsynchronousOperationHandlersTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/async/AbstractAsynchronousOperationHandlersTest.java&lt;br/&gt;
index eeb41a829b8..fb384a938d1 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/async/AbstractAsynchronousOperationHandlersTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/async/AbstractAsynchronousOperationHandlersTest.java&lt;br/&gt;
@@ -179,6 +179,32 @@ public void testUnknownTriggerId() throws Exception {&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * Tests that the future returned by &lt;/p&gt;
{@link AbstractAsynchronousOperationHandlers.StatusHandler#closeAsync()}
&lt;p&gt;+	 * completes when the result of the asynchronous operation is served.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testCloseShouldFinishOnFirstServedResult() throws Exception &lt;/p&gt;
{
+		final CompletableFuture&amp;lt;String&amp;gt; savepointFuture = new CompletableFuture&amp;lt;&amp;gt;();
+		final TestingRestfulGateway testingRestfulGateway = new TestingRestfulGateway.Builder()
+			.setTriggerSavepointFunction((JobID jobId, String directory) -&amp;gt; savepointFuture)
+			.build();
+
+		final TriggerId triggerId = testingTriggerHandler.handleRequest(
+			triggerOperationRequest(),
+			testingRestfulGateway).get().getTriggerId();
+		final CompletableFuture&amp;lt;Void&amp;gt; closeFuture = testingStatusHandler.closeAsync();
+
+		testingStatusHandler.handleRequest(statusOperationRequest(triggerId), testingRestfulGateway).get();
+
+		assertThat(closeFuture.isDone(), is(false));
+
+		savepointFuture.complete(&quot;foobar&quot;);
+		testingStatusHandler.handleRequest(statusOperationRequest(triggerId), testingRestfulGateway).get();
+
+		assertThat(closeFuture.isDone(), is(true));
+	}
&lt;p&gt;+&lt;br/&gt;
 	private static HandlerRequest&amp;lt;EmptyRequestBody, EmptyMessageParameters&amp;gt; triggerOperationRequest() throws HandlerRequestException &lt;/p&gt;
{
 		return new HandlerRequest&amp;lt;&amp;gt;(EmptyRequestBody.getInstance(), EmptyMessageParameters.getInstance());
 	}
&lt;p&gt;diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCacheTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCacheTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..2d13780f956&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCacheTest.java&lt;br/&gt;
@@ -0,0 +1,80 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.rest.handler.async;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.runtime.rest.messages.TriggerId;&lt;br/&gt;
+import org.apache.flink.runtime.util.ManualTicker;&lt;br/&gt;
+import org.apache.flink.types.Either;&lt;br/&gt;
+import org.apache.flink.util.TestLogger;&lt;br/&gt;
+&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.concurrent.CompletableFuture;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+&lt;br/&gt;
+import static org.hamcrest.Matchers.equalTo;&lt;br/&gt;
+import static org.hamcrest.Matchers.is;&lt;br/&gt;
+import static org.hamcrest.Matchers.notNullValue;&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tests for &lt;/p&gt;
{@link CompletedOperationCache}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public class CompletedOperationCacheTest extends TestLogger {&lt;br/&gt;
+&lt;br/&gt;
+	private static final OperationKey TEST_OPERATION_KEY = new OperationKey(new TriggerId());&lt;br/&gt;
+&lt;br/&gt;
+	private static final CompletableFuture&amp;lt;String&amp;gt; TEST_OPERATION_RESULT = CompletableFuture.completedFuture(&quot;foo&quot;);&lt;br/&gt;
+&lt;br/&gt;
+	private ManualTicker manualTicker;&lt;br/&gt;
+&lt;br/&gt;
+	private CompletedOperationCache&amp;lt;OperationKey, String&amp;gt; completedOperationCache;&lt;br/&gt;
+&lt;br/&gt;
+	@Before&lt;br/&gt;
+	public void setUp() &lt;/p&gt;
{
+		manualTicker = new ManualTicker();
+		completedOperationCache = new CompletedOperationCache&amp;lt;&amp;gt;(manualTicker);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testShouldFinishClosingCacheIfAllResultsAreEvicted() &lt;/p&gt;
{
+		completedOperationCache.registerOngoingOperation(TEST_OPERATION_KEY, TEST_OPERATION_RESULT);
+		final CompletableFuture&amp;lt;Void&amp;gt; closeCacheFuture = completedOperationCache.closeAsync();
+		assertThat(closeCacheFuture.isDone(), is(false));
+
+		manualTicker.advanceTime(300, TimeUnit.SECONDS);
+		completedOperationCache.cleanUp();
+
+		assertThat(closeCacheFuture.isDone(), is(true));
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testShouldFinishClosingCacheIfAllResultsAccessed() throws Exception &lt;/p&gt;
{
+		completedOperationCache.registerOngoingOperation(TEST_OPERATION_KEY, TEST_OPERATION_RESULT);
+		final CompletableFuture&amp;lt;Void&amp;gt; closeCacheFuture = completedOperationCache.closeAsync();
+		assertThat(closeCacheFuture.isDone(), is(false));
+
+		final Either&amp;lt;Throwable, String&amp;gt; operationResultOrError = completedOperationCache.get(TEST_OPERATION_KEY);
+
+		assertThat(operationResultOrError, is(notNullValue()));
+		assertThat(operationResultOrError.right(), is(equalTo(TEST_OPERATION_RESULT.get())));
+		assertThat(closeCacheFuture.isDone(), is(true));
+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/util/ManualTicker.java b/flink-runtime/src/test/java/org/apache/flink/runtime/util/ManualTicker.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..d2e2e1d7bea&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/util/ManualTicker.java&lt;br/&gt;
@@ -0,0 +1,40 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.util;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.shaded.guava18.com.google.common.base.Ticker;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Controllable &lt;/p&gt;
{@link Ticker}
&lt;p&gt; implementation for tests.&lt;br/&gt;
+ */&lt;br/&gt;
+public final class ManualTicker extends Ticker {&lt;br/&gt;
+&lt;br/&gt;
+	private long currentTime;&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public long read() &lt;/p&gt;
{
+		return currentTime;
+	}
&lt;p&gt;+&lt;br/&gt;
+	public void advanceTime(final long duration, final TimeUnit timeUnit) &lt;/p&gt;
{
+		currentTime += timeUnit.toNanos(duration);
+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-tests/src/test/java/org/apache/flink/test/recovery/ProcessFailureCancelingITCase.java b/flink-tests/src/test/java/org/apache/flink/test/recovery/ProcessFailureCancelingITCase.java&lt;br/&gt;
index afca8f12100..c5ec1b5f914 100644&lt;br/&gt;
&amp;#8212; a/flink-tests/src/test/java/org/apache/flink/test/recovery/ProcessFailureCancelingITCase.java&lt;br/&gt;
+++ b/flink-tests/src/test/java/org/apache/flink/test/recovery/ProcessFailureCancelingITCase.java&lt;br/&gt;
@@ -33,6 +33,7 @@&lt;br/&gt;
 import org.apache.flink.configuration.JobManagerOptions;&lt;br/&gt;
 import org.apache.flink.configuration.RestOptions;&lt;br/&gt;
 import org.apache.flink.runtime.client.JobStatusMessage;&lt;br/&gt;
+import org.apache.flink.runtime.clusterframework.ApplicationStatus;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
 import org.apache.flink.runtime.dispatcher.DispatcherGateway;&lt;br/&gt;
 import org.apache.flink.runtime.dispatcher.DispatcherId;&lt;br/&gt;
@@ -249,7 +250,7 @@ public Long map(Long value) throws Exception &lt;/p&gt;
{
 				clusterClient.shutdown();
 			}
&lt;p&gt; 			if (dispatcherResourceManagerComponent != null) &lt;/p&gt;
{
-				dispatcherResourceManagerComponent.close();
+				dispatcherResourceManagerComponent.deregisterApplicationAndClose(ApplicationStatus.SUCCEEDED, null);
 			}

&lt;p&gt; 			fatalErrorHandler.rethrowError();&lt;br/&gt;
diff --git a/flink-yarn-tests/src/test/resources/log4j-test.properties b/flink-yarn-tests/src/test/resources/log4j-test.properties&lt;br/&gt;
index 8f56c1fa9a5..42ae7ddf08e 100644&lt;br/&gt;
&amp;#8212; a/flink-yarn-tests/src/test/resources/log4j-test.properties&lt;br/&gt;
+++ b/flink-yarn-tests/src/test/resources/log4j-test.properties&lt;br/&gt;
@@ -35,7 +35,7 @@ log4j.logger.org.apache.flink.runtime.leaderelection=INFO&lt;br/&gt;
 log4j.logger.org.apache.flink.runtime.leaderretrieval=INFO&lt;/p&gt;

&lt;p&gt; log4j.logger.org.apache.directory=OFF&lt;br/&gt;
-log4j.logger.org.mortbay.log=OFF, testlogger&lt;br/&gt;
+log4j.logger.org.mortbay.log=OFF&lt;br/&gt;
 log4j.logger.net.sf.ehcache=OFF&lt;br/&gt;
 log4j.logger.org.apache.hadoop.metrics2=OFF&lt;br/&gt;
 log4j.logger.org.apache.hadoop.conf.Configuration=OFF&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16656793" author="gjy" created="Fri, 19 Oct 2018 13:16:35 +0000"  >&lt;p&gt;1.5: 00d75633c10b511094f5ef0bbd5deb129eeba188&lt;br/&gt;
1.6: 23871b338d9234f9ab6a170978989d0febb1cec8&lt;br/&gt;
1.7: d850e79cb68cd4dba5a531d01f8a20b1fba05278&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13192862">FLINK-10615</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 4 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3xvtz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>