<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:29:18 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-7216] ExecutionGraph can perform concurrent global restarts to scheduling</title>
                <link>https://issues.apache.org/jira/browse/FLINK-7216</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;Because ExecutionGraph restarts happen asynchronously and possibly delayed, it can happen in rare corner cases that two restarts are attempted concurrently, in which case some structures on the Execution Graph undergo a concurrent access:&lt;/p&gt;

&lt;p&gt;Sample stack trace:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;WARN  org.apache.flink.runtime.executiongraph.ExecutionGraph        - Failed to restart the job.
java.lang.IllegalStateException: SlotSharingGroup cannot clear task assignment, group still has allocated resources.
    at org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup.clearTaskAssignment(SlotSharingGroup.java:78)
    at org.apache.flink.runtime.executiongraph.ExecutionJobVertex.resetForNewExecution(ExecutionJobVertex.java:535)
    at org.apache.flink.runtime.executiongraph.ExecutionGraph.restart(ExecutionGraph.java:1151)
    at org.apache.flink.runtime.executiongraph.restart.ExecutionGraphRestarter$1.call(ExecutionGraphRestarter.java:40)
    at akka.dispatch.Futures$$anonfun$&lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt;$1.apply(Future.scala:95)
    at scala.concurrent.impl.Future$PromiseCompletingRunnable.liftedTree1$1(Future.scala:24)
    at scala.concurrent.impl.Future$PromiseCompletingRunnable.run(Future.scala:24)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:748)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The solution is to strictly guard against &quot;subsumed&quot; restarts via the &lt;tt&gt;globalModVersion&lt;/tt&gt; in a similar way as we fence local restarts against global restarts.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13087706">FLINK-7216</key>
            <summary>ExecutionGraph can perform concurrent global restarts to scheduling</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="sewen">Stephan Ewen</assignee>
                                    <reporter username="sewen">Stephan Ewen</reporter>
                        <labels>
                    </labels>
                <created>Mon, 17 Jul 2017 19:33:10 +0000</created>
                <updated>Wed, 8 Nov 2017 13:30:57 +0000</updated>
                            <resolved>Wed, 8 Nov 2017 13:30:57 +0000</resolved>
                                    <version>1.2.1</version>
                    <version>1.3.1</version>
                                    <fixVersion>1.3.2</fixVersion>
                    <fixVersion>1.4.0</fixVersion>
                                    <component>Runtime / Coordination</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="16092788" author="githubbot" created="Wed, 19 Jul 2017 08:33:45 +0000"  >&lt;p&gt;GitHub user StephanEwen opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7216&quot; title=&quot;ExecutionGraph can perform concurrent global restarts to scheduling&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7216&quot;&gt;&lt;del&gt;FLINK-7216&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;distr. coordination&amp;#93;&lt;/span&gt; Guard against concurrent global failover&lt;/p&gt;

&lt;p&gt;    *&lt;b&gt;This is one of the blocker issues for the 1.3.2 release.&lt;/b&gt;*&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This fixed the bug &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7216&quot; title=&quot;ExecutionGraph can perform concurrent global restarts to scheduling&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7216&quot;&gt;&lt;del&gt;FLINK-7216&lt;/del&gt;&lt;/a&gt;(&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7216&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-7216&lt;/a&gt;) where some race conditions can trigger concurrent failovers, triggering a restart-storm.&lt;/p&gt;

&lt;p&gt;    The heart of the bug is the fact that we allow initiating another restart while already being in state `RESTARTING`. That was introduced as a safety net to catch exceptions (implementation bugs) that are reported in that state and need a full recovery to ensure consistency.&lt;/p&gt;

&lt;p&gt;    However, this means that accidentally, multiple restarts may be triggered/queued and then execute after another. While one attempt is executing the failover, the next one will interfere or abort (as detected conflicting) and schedule another recovery, leading to the above mentioned restart storm. The restart storm subsides once one restart attempt makes enough progress (before the other interferes) to actually finish the scheduling phase.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This contains three issues, because the first two were needed for a preparing the fix.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6665&quot; title=&quot;Pass a ScheduledExecutorService to the RestartStrategy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-6665&quot;&gt;&lt;del&gt;FLINK-6665&lt;/del&gt;&lt;/a&gt;(&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6665&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-6665&lt;/a&gt;) and &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6667&quot; title=&quot;Pass a callback type to the RestartStrategy, rather than the full ExecutionGraph&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-6667&quot;&gt;&lt;del&gt;FLINK-6667&lt;/del&gt;&lt;/a&gt;(&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6667&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-6667&lt;/a&gt;) introduce an indirection where the `RestartStrategy` does no longer call `restart()` on the `ExecutionGraph` directly. Instead, they call a callback to initiate the restart.&lt;/li&gt;
	&lt;li&gt;The actual fix makes sure that the `globalModVersion` (which tracks global changes such as full restarts in the ExecutionGraph) is unchanged between triggering the restart and executing it. When scheduling multiple restart requests, only one will actually take effect, while the others detect being subsumed.&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This change added the following tests:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;`ExecutionGraphRestartTest#testConcurrentGlobalFailAndRestarts()` tests explicitly that setting&lt;/li&gt;
	&lt;li&gt;`ExecutionGraphRestartTest#testConcurrentLocalFailAndRestart()` tests a similar setup&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The general working of that mechanism is also covered by various existing test in `org.apache.flink.runtime.executiongraph.restart`&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The serializers: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: *&lt;b&gt;yes&lt;/b&gt;*:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It the change affects the restart logic on the `JobManager`.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? *&lt;b&gt;not applicable&lt;/b&gt;*&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/StephanEwen/incubator-flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/StephanEwen/incubator-flink&lt;/a&gt; concurrent_restarts_13&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4364&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 1abb816d664bdac9d8b9af438769b9f685e768ce&lt;br/&gt;
Author: zjureel &amp;lt;zjureel@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-07-18T17:27:56Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6665&quot; title=&quot;Pass a ScheduledExecutorService to the RestartStrategy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-6665&quot;&gt;&lt;del&gt;FLINK-6665&lt;/del&gt;&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6667&quot; title=&quot;Pass a callback type to the RestartStrategy, rather than the full ExecutionGraph&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-6667&quot;&gt;&lt;del&gt;FLINK-6667&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;distributed coordination&amp;#93;&lt;/span&gt; Use a callback and a ScheduledExecutor for ExecutionGraph restarts&lt;/p&gt;

&lt;p&gt;    Initial work by zjureel@gmail.com , improved by sewen@apache.org.&lt;/p&gt;

&lt;p&gt;commit ef88524c808766e08d990f3bb69c45b04807c7c2&lt;br/&gt;
Author: Stephan Ewen &amp;lt;sewen@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-07-18T17:49:56Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7216&quot; title=&quot;ExecutionGraph can perform concurrent global restarts to scheduling&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7216&quot;&gt;&lt;del&gt;FLINK-7216&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;distr. coordination&amp;#93;&lt;/span&gt; Guard against concurrent global failover&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16092842" author="githubbot" created="Wed, 19 Jul 2017 09:28:16 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128196611&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128196611&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/restart/ExecutionGraphRestartCallback.java &amp;#8212;&lt;br/&gt;
    @@ -19,27 +19,33 @@&lt;br/&gt;
     package org.apache.flink.runtime.executiongraph.restart;&lt;/p&gt;

&lt;p&gt;     import org.apache.flink.runtime.executiongraph.ExecutionGraph;&lt;br/&gt;
    -import org.slf4j.Logger;&lt;br/&gt;
    -import org.slf4j.LoggerFactory;&lt;br/&gt;
    -&lt;br/&gt;
    -import java.util.concurrent.Callable;&lt;br/&gt;
    -&lt;br/&gt;
    -class ExecutionGraphRestarter {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final Logger LOG = LoggerFactory.getLogger(ExecutionGraphRestarter.class);&lt;/li&gt;
	&lt;li&gt;public static Callable&amp;lt;Object&amp;gt; restartWithDelay(final ExecutionGraph executionGraph, final long delayBetweenRestartAttemptsInMillis) {&lt;/li&gt;
	&lt;li&gt;return new Callable&amp;lt;Object&amp;gt;() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public Object call() throws Exception {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;LOG.info(&quot;Delaying retry of job execution for {} ms ...&quot;, delayBetweenRestartAttemptsInMillis);&lt;/li&gt;
	&lt;li&gt;// do the delay&lt;/li&gt;
	&lt;li&gt;Thread.sleep(delayBetweenRestartAttemptsInMillis);&lt;/li&gt;
	&lt;li&gt;} catch(InterruptedException e) 
{
    -					// should only happen on shutdown
    -				}&lt;/li&gt;
	&lt;li&gt;executionGraph.restart();&lt;/li&gt;
	&lt;li&gt;return null;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;};&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * A 
{@link RestartCallback}
&lt;p&gt; that abstracts restart calls on an &lt;/p&gt;
{@link ExecutionGraph}
&lt;p&gt;. &lt;br/&gt;
    + * &lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Please remove the trailing space.&lt;/p&gt;</comment>
                            <comment id="16092843" author="githubbot" created="Wed, 19 Jul 2017 09:28:16 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128196559&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128196559&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/restart/ExecutionGraphRestartCallback.java &amp;#8212;&lt;br/&gt;
    @@ -19,27 +19,33 @@&lt;br/&gt;
     package org.apache.flink.runtime.executiongraph.restart;&lt;/p&gt;

&lt;p&gt;     import org.apache.flink.runtime.executiongraph.ExecutionGraph;&lt;br/&gt;
    -import org.slf4j.Logger;&lt;br/&gt;
    -import org.slf4j.LoggerFactory;&lt;br/&gt;
    -&lt;br/&gt;
    -import java.util.concurrent.Callable;&lt;br/&gt;
    -&lt;br/&gt;
    -class ExecutionGraphRestarter {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final Logger LOG = LoggerFactory.getLogger(ExecutionGraphRestarter.class);&lt;/li&gt;
	&lt;li&gt;public static Callable&amp;lt;Object&amp;gt; restartWithDelay(final ExecutionGraph executionGraph, final long delayBetweenRestartAttemptsInMillis) {&lt;/li&gt;
	&lt;li&gt;return new Callable&amp;lt;Object&amp;gt;() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public Object call() throws Exception {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;LOG.info(&quot;Delaying retry of job execution for {} ms ...&quot;, delayBetweenRestartAttemptsInMillis);&lt;/li&gt;
	&lt;li&gt;// do the delay&lt;/li&gt;
	&lt;li&gt;Thread.sleep(delayBetweenRestartAttemptsInMillis);&lt;/li&gt;
	&lt;li&gt;} catch(InterruptedException e) 
{
    -					// should only happen on shutdown
    -				}&lt;/li&gt;
	&lt;li&gt;executionGraph.restart();&lt;/li&gt;
	&lt;li&gt;return null;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;};&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * A 
{@link RestartCallback}
&lt;p&gt; that abstracts restart calls on an &lt;/p&gt;
{@link ExecutionGraph}
&lt;p&gt;. &lt;br/&gt;
    + * &lt;br/&gt;
    + * &amp;lt;p&amp;gt;This callback implementation is one-shot; it can only be used once.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class ExecutionGraphRestartCallback implements RestartCallback {&lt;br/&gt;
    +&lt;br/&gt;
    +	/** The ExecutionGraph to restart */&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Please add a period here.&lt;/p&gt;</comment>
                            <comment id="16092844" author="githubbot" created="Wed, 19 Jul 2017 09:28:16 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128196537&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128196537&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/restart/ExecutionGraphRestartCallback.java &amp;#8212;&lt;br/&gt;
    @@ -19,27 +19,33 @@&lt;br/&gt;
     package org.apache.flink.runtime.executiongraph.restart;&lt;/p&gt;

&lt;p&gt;     import org.apache.flink.runtime.executiongraph.ExecutionGraph;&lt;br/&gt;
    -import org.slf4j.Logger;&lt;br/&gt;
    -import org.slf4j.LoggerFactory;&lt;br/&gt;
    -&lt;br/&gt;
    -import java.util.concurrent.Callable;&lt;br/&gt;
    -&lt;br/&gt;
    -class ExecutionGraphRestarter {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final Logger LOG = LoggerFactory.getLogger(ExecutionGraphRestarter.class);&lt;/li&gt;
	&lt;li&gt;public static Callable&amp;lt;Object&amp;gt; restartWithDelay(final ExecutionGraph executionGraph, final long delayBetweenRestartAttemptsInMillis) {&lt;/li&gt;
	&lt;li&gt;return new Callable&amp;lt;Object&amp;gt;() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public Object call() throws Exception {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;LOG.info(&quot;Delaying retry of job execution for {} ms ...&quot;, delayBetweenRestartAttemptsInMillis);&lt;/li&gt;
	&lt;li&gt;// do the delay&lt;/li&gt;
	&lt;li&gt;Thread.sleep(delayBetweenRestartAttemptsInMillis);&lt;/li&gt;
	&lt;li&gt;} catch(InterruptedException e) 
{
    -					// should only happen on shutdown
    -				}&lt;/li&gt;
	&lt;li&gt;executionGraph.restart();&lt;/li&gt;
	&lt;li&gt;return null;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;};&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.util.Preconditions.checkNotNull;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * A 
{@link RestartCallback}
&lt;p&gt; that abstracts restart calls on an &lt;/p&gt;
{@link ExecutionGraph}
&lt;p&gt;. &lt;br/&gt;
    + * &lt;br/&gt;
    + * &amp;lt;p&amp;gt;This callback implementation is one-shot; it can only be used once.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class ExecutionGraphRestartCallback implements RestartCallback {&lt;br/&gt;
    +&lt;br/&gt;
    +	/** The ExecutionGraph to restart */&lt;br/&gt;
    +	private final ExecutionGraph execGraph;&lt;br/&gt;
    +&lt;br/&gt;
    +	/** Atomic flag to make sure this is used only once */&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Please add a period here.&lt;/p&gt;</comment>
                            <comment id="16092845" author="githubbot" created="Wed, 19 Jul 2017 09:28:16 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128196982&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128196982&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/restart/RestartStrategy.java &amp;#8212;&lt;br/&gt;
    @@ -33,9 +34,14 @@&lt;br/&gt;
     	boolean canRestart();&lt;/p&gt;

&lt;p&gt;     	/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Restarts the given 
{@link ExecutionGraph}
&lt;p&gt;.&lt;br/&gt;
    +	 * Called by the ExecutionGraph to eventually trigger a full recovery.&lt;br/&gt;
    +	 * The recovery must be triggered on the given callback object, and may be delayed&lt;br/&gt;
    +	 * with the help of the given scheduled executor.&lt;br/&gt;
    +	 * &lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Please remove the trailing space.&lt;/p&gt;</comment>
                            <comment id="16092849" author="githubbot" created="Wed, 19 Jul 2017 09:29:23 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128197299&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128197299&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/restart/ExecutionGraphRestartCallback.java &amp;#8212;&lt;br/&gt;
    @@ -37,15 +37,26 @@&lt;br/&gt;
     	/** Atomic flag to make sure this is used only once */&lt;br/&gt;
     	private final AtomicBoolean used;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public ExecutionGraphRestartCallback(ExecutionGraph execGraph) {&lt;br/&gt;
    +	/** The globalModVersion that the ExecutionGraph needs to have for the restart to go through */
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Please add a period.&lt;/p&gt;</comment>
                            <comment id="16092980" author="githubbot" created="Wed, 19 Jul 2017 12:12:32 +0000"  >&lt;p&gt;Github user StephanEwen commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Concerning the &apos;period&apos; check style rule:&lt;/p&gt;

&lt;p&gt;    I think that the common language rules (not JavaDoc specific) are to add a period after complete sentences. That would mean that parameter descriptions, when not complete sentences, are not terminated by a period.&lt;/p&gt;

&lt;p&gt;    Are we rolling a rule that every text line has to be terminated in a period/fullstop?&lt;/p&gt;</comment>
                            <comment id="16092992" author="githubbot" created="Wed, 19 Jul 2017 12:25:00 +0000"  >&lt;p&gt;Github user zentol commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    With the current rules, the first sentence of any *&lt;b&gt;javadoc&lt;/b&gt;* must end in a period.&lt;/p&gt;

&lt;p&gt;    So, this is invalid:&lt;br/&gt;
    ```&lt;br/&gt;
    /** some parameter */&lt;br/&gt;
    private final int myParameter&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    But, this is fine:&lt;br/&gt;
    ```&lt;br/&gt;
    // some parameter&lt;br/&gt;
    private final int myParamter&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="16093296" author="githubbot" created="Wed, 19 Jul 2017 15:45:22 +0000"  >&lt;p&gt;Github user StephanEwen commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Okay, will update the periods. The linguist in my heart cries a bit, but I guess it makes sense that we cannot expect checkstyle to figure out if a sentence is a complete sentence or not...&lt;/p&gt;</comment>
                            <comment id="16094579" author="githubbot" created="Thu, 20 Jul 2017 11:55:11 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128480263&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128480263&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java &amp;#8212;&lt;br/&gt;
    @@ -581,6 +565,106 @@ public void testSuspendWhileRestarting() throws Exception &lt;/p&gt;
{
     		assertEquals(JobStatus.SUSPENDED, eg.getState());
     	}

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testConcurrentLocalFailAndRestart() throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This only verifies that we don&apos;t break the existing and working local failover, right? This test should also succeed on the current master and I checked and it indeed does.&lt;/p&gt;</comment>
                            <comment id="16094580" author="githubbot" created="Thu, 20 Jul 2017 11:55:11 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128476571&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128476571&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -1120,10 +1125,16 @@ public void accept(Void value) {&lt;br/&gt;
     		}&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void restart() {&lt;br/&gt;
    +	public void restart(long expectedGlobalVersion) {&lt;br/&gt;
     		try {&lt;br/&gt;
     			synchronized (progressLock) {&lt;/li&gt;
	&lt;li&gt;JobStatus current = state;&lt;br/&gt;
    +				// check and increment the global version to move this recovery up
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    &quot;check the current global version to determine whether our recovery attempt is still current&quot;?&lt;/p&gt;

&lt;p&gt;    It&apos;s not incrementing the global version here.&lt;/p&gt;</comment>
                            <comment id="16094581" author="githubbot" created="Thu, 20 Jul 2017 11:55:11 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128474733&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128474733&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java &amp;#8212;&lt;br/&gt;
    @@ -159,34 +161,6 @@ public void testRestartAutomatically() throws Exception {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void taskShouldFailWhenFailureRateLimitExceeded() throws Exception {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    These tests are superseded by the newly added tests in `FailureRateRestartStrategyTest`?&lt;/p&gt;</comment>
                            <comment id="16094582" author="githubbot" created="Thu, 20 Jul 2017 11:55:11 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128491763&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128491763&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java &amp;#8212;&lt;br/&gt;
    @@ -581,6 +565,106 @@ public void testSuspendWhileRestarting() throws Exception &lt;/p&gt;
{
     		assertEquals(JobStatus.SUSPENDED, eg.getState());
     	}

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testConcurrentLocalFailAndRestart() throws Exception {&lt;br/&gt;
    +		final ExecutionGraph eg = createSimpleTestGraph(new FixedDelayRestartStrategy(10, 0L));&lt;br/&gt;
    +		eg.setScheduleMode(ScheduleMode.EAGER);&lt;br/&gt;
    +		eg.scheduleForExecution();&lt;br/&gt;
    +&lt;br/&gt;
    +		waitUntilDeployedAndSwitchToRunning(eg, 1000);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ExecutionJobVertex vertex = eg.getVerticesTopologically().iterator().next();&lt;br/&gt;
    +		final Execution first = vertex.getTaskVertices()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.getCurrentExecutionAttempt();&lt;br/&gt;
    +		final Execution last = vertex.getTaskVertices()&lt;span class=&quot;error&quot;&gt;&amp;#91;vertex.getParallelism() - 1&amp;#93;&lt;/span&gt;.getCurrentExecutionAttempt();&lt;br/&gt;
    +&lt;br/&gt;
    +		final OneShotLatch failTrigger = new OneShotLatch();&lt;br/&gt;
    +		final CountDownLatch readyLatch = new CountDownLatch(2);&lt;br/&gt;
    +&lt;br/&gt;
    +		Thread failure1 = new Thread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void run() {&lt;br/&gt;
    +				readyLatch.countDown();&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					failTrigger.await();
    +				} catch (InterruptedException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +				first.fail(new Exception(&quot;intended test failure 1&quot;));&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		Thread failure2 = new Thread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void run() {&lt;br/&gt;
    +				readyLatch.countDown();&lt;br/&gt;
    +				try {    +					failTrigger.await();    +				}
&lt;p&gt; catch (InterruptedException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +				last.fail(new Exception(&quot;intended test failure 2&quot;));&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		// make sure both threads start simultaneously&lt;br/&gt;
    +		failure1.start();&lt;br/&gt;
    +		failure2.start();&lt;br/&gt;
    +		readyLatch.await();&lt;br/&gt;
    +		failTrigger.trigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		waitUntilJobStatus(eg, JobStatus.FAILING, 1000);&lt;br/&gt;
    +		completeCancellingForAllVertices(eg);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    By the way, I noticed that `completeCancellingForAllVertices()` and `finishAllVertices()` have slightly misleading Javadoc. That threw me off a bit when reviewing.&lt;/p&gt;</comment>
                            <comment id="16094583" author="githubbot" created="Thu, 20 Jul 2017 11:55:11 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128477775&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128477775&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphTestUtils.java &amp;#8212;&lt;br/&gt;
    @@ -189,6 +189,35 @@ public static void finishAllVertices(ExecutionGraph eg) {&lt;br/&gt;
     		}&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * Turns a newly scheduled execution graph into a state where all vertices run.&lt;br/&gt;
    +	 * This waits until all executions have reached state &apos;DEPLOYING&apos; and then switches them to running.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static void waitUntilDeployedAndSwitchToRunning(ExecutionGraph eg, long timeout) throws TimeoutException {&lt;br/&gt;
    +		// wait until everything is running&lt;br/&gt;
    +		for (ExecutionVertex ev : eg.getAllExecutionVertices()) &lt;/p&gt;
{
    +			final Execution exec = ev.getCurrentExecutionAttempt();
    +			waitUntilExecutionState(exec, ExecutionState.DEPLOYING, timeout);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// Note: As ugly as it is, we need this minor sleep, because between switching&lt;br/&gt;
    +		// to &apos;DEPLOYED&apos; and when the &apos;switchToRunning()&apos; may be called lies a race check&lt;br/&gt;
    +		// against concurrent modifications (cancel / fail). We can only switch this to running&lt;br/&gt;
    +		// once that check is passed. For the actual runtime, this switch is triggered by a callback&lt;br/&gt;
    +		// from the TaskManager, which comes strictly after that. For tests, we use mock TaskManagers&lt;br/&gt;
    +		// which cannot easily tell us when that condition has happened, unfortunately.&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			Thread.sleep(2);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &#128546; but it seems there&apos;s no way around it. Could this lead to flaky tests?&lt;/p&gt;</comment>
                            <comment id="16094584" author="githubbot" created="Thu, 20 Jul 2017 11:55:11 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128494097&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128494097&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java &amp;#8212;&lt;br/&gt;
    @@ -581,6 +565,106 @@ public void testSuspendWhileRestarting() throws Exception &lt;/p&gt;
{
     		assertEquals(JobStatus.SUSPENDED, eg.getState());
     	}

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testConcurrentLocalFailAndRestart() throws Exception {&lt;br/&gt;
    +		final ExecutionGraph eg = createSimpleTestGraph(new FixedDelayRestartStrategy(10, 0L));&lt;br/&gt;
    +		eg.setScheduleMode(ScheduleMode.EAGER);&lt;br/&gt;
    +		eg.scheduleForExecution();&lt;br/&gt;
    +&lt;br/&gt;
    +		waitUntilDeployedAndSwitchToRunning(eg, 1000);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ExecutionJobVertex vertex = eg.getVerticesTopologically().iterator().next();&lt;br/&gt;
    +		final Execution first = vertex.getTaskVertices()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.getCurrentExecutionAttempt();&lt;br/&gt;
    +		final Execution last = vertex.getTaskVertices()&lt;span class=&quot;error&quot;&gt;&amp;#91;vertex.getParallelism() - 1&amp;#93;&lt;/span&gt;.getCurrentExecutionAttempt();&lt;br/&gt;
    +&lt;br/&gt;
    +		final OneShotLatch failTrigger = new OneShotLatch();&lt;br/&gt;
    +		final CountDownLatch readyLatch = new CountDownLatch(2);&lt;br/&gt;
    +&lt;br/&gt;
    +		Thread failure1 = new Thread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void run() {&lt;br/&gt;
    +				readyLatch.countDown();&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					failTrigger.await();
    +				} catch (InterruptedException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +				first.fail(new Exception(&quot;intended test failure 1&quot;));&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		Thread failure2 = new Thread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void run() {&lt;br/&gt;
    +				readyLatch.countDown();&lt;br/&gt;
    +				try {    +					failTrigger.await();    +				}
&lt;p&gt; catch (InterruptedException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +				last.fail(new Exception(&quot;intended test failure 2&quot;));&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		// make sure both threads start simultaneously&lt;br/&gt;
    +		failure1.start();&lt;br/&gt;
    +		failure2.start();&lt;br/&gt;
    +		readyLatch.await();&lt;br/&gt;
    +		failTrigger.trigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		waitUntilJobStatus(eg, JobStatus.FAILING, 1000);&lt;br/&gt;
    +		completeCancellingForAllVertices(eg);&lt;br/&gt;
    +&lt;br/&gt;
    +		waitUntilJobStatus(eg, JobStatus.RUNNING, 1000);&lt;br/&gt;
    +		waitUntilDeployedAndSwitchToRunning(eg, 1000);&lt;br/&gt;
    +		finishAllVertices(eg);&lt;br/&gt;
    +&lt;br/&gt;
    +		eg.waitUntilTerminal();&lt;br/&gt;
    +		assertEquals(JobStatus.FINISHED, eg.getState());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testConcurrentGlobalFailAndRestarts() throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I tried running this on current master and the test failed but I didn&apos;t see a &quot;storm of restarts&quot;&lt;/p&gt;</comment>
                            <comment id="16094585" author="githubbot" created="Thu, 20 Jul 2017 11:55:11 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128477515&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128477515&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java &amp;#8212;&lt;br/&gt;
    @@ -727,4 +837,46 @@ private static void haltExecution(ExecutionGraph eg) &lt;/p&gt;
{
     
     		assertEquals(JobStatus.FINISHED, eg.getState());
     	}
&lt;p&gt;    +&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * A TaskManager gateway that does not ack cancellations.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private static final class NotCancelAckingTaskGateway extends SimpleAckingTaskManagerGateway {&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public org.apache.flink.runtime.concurrent.Future&amp;lt;Acknowledge&amp;gt; cancelTask(ExecutionAttemptID executionAttemptID, Time timeout) &lt;/p&gt;
{
    +			return new FlinkCompletableFuture&amp;lt;&amp;gt;();
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final class TriggeredRestartStrategy implements RestartStrategy {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &quot;A &lt;/p&gt;
{@link RestartStrategy}
&lt;p&gt; that blocks restarting on a given &lt;/p&gt;
{@link OneShotLatch}
&lt;p&gt;.&quot;?&lt;/p&gt;</comment>
                            <comment id="16094586" author="githubbot" created="Thu, 20 Jul 2017 11:55:11 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128475216&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128475216&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/restart/FailureRateRestartStrategyTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,128 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.runtime.executiongraph.restart;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.time.Time;&lt;br/&gt;
    +import org.apache.flink.core.testutils.OneShotLatch;&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.ScheduledExecutor;&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.ScheduledExecutorServiceAdapter;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.After;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.ScheduledExecutorService;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertFalse;&lt;br/&gt;
    +import static org.junit.Assert.assertTrue;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Unit test for the &lt;/p&gt;
{@link FailureRateRestartStrategy}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class FailureRateRestartStrategyTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	public final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(4);&lt;br/&gt;
    +&lt;br/&gt;
    +	public final ScheduledExecutor executor = new ScheduledExecutorServiceAdapter(executorService);&lt;br/&gt;
    +&lt;br/&gt;
    +	@After&lt;br/&gt;
    +	public void shutdownExecutor() &lt;/p&gt;
{
    +		executorService.shutdownNow();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testManyFailuresWithinRate() throws Exception {&lt;br/&gt;
    +		final int numAttempts = 10;&lt;br/&gt;
    +		final int intervalMillis = 1;&lt;br/&gt;
    +&lt;br/&gt;
    +		final FailureRateRestartStrategy restartStrategy =&lt;br/&gt;
    +				new FailureRateRestartStrategy(1, Time.milliseconds(intervalMillis), Time.milliseconds(0));&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int attempsLeft = numAttempts; attempsLeft &amp;gt; 0; --attempsLeft) &lt;/p&gt;
{
    +			assertTrue(restartStrategy.canRestart());
    +			restartStrategy.restart(new NoOpRestarter(), executor);
    +			sleepGuaranteed(2 * intervalMillis);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		assertTrue(restartStrategy.canRestart());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testFailuresExceedingRate() throws Exception {&lt;br/&gt;
    +		final int numFailures = 3;&lt;br/&gt;
    +		final int intervalMillis = 10_000;&lt;br/&gt;
    +&lt;br/&gt;
    +		final FailureRateRestartStrategy restartStrategy =&lt;br/&gt;
    +				new FailureRateRestartStrategy(numFailures, Time.milliseconds(intervalMillis), Time.milliseconds(0));&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int failuresLeft = numFailures; failuresLeft &amp;gt; 0; --failuresLeft) &lt;/p&gt;
{
    +			assertTrue(restartStrategy.canRestart());
    +			restartStrategy.restart(new NoOpRestarter(), executor);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// now the rate should be exceeded&lt;br/&gt;
    +		assertFalse(restartStrategy.canRestart());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testDelay() throws Exception {&lt;br/&gt;
    +		final long restartDelay = 2;&lt;br/&gt;
    +		final int numberRestarts = 10;&lt;br/&gt;
    +&lt;br/&gt;
    +		final FailureRateRestartStrategy strategy =&lt;br/&gt;
    +			new FailureRateRestartStrategy(numberRestarts + 1, Time.milliseconds(1), Time.milliseconds(restartDelay));&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int restartsLeft = numberRestarts; restartsLeft &amp;gt; 0; --restartsLeft) &lt;/p&gt;
{
    +			assertTrue(strategy.canRestart());
    +
    +			final OneShotLatch sync = new OneShotLatch();
    +			final RestartCallback restarter = new LatchedRestarter(sync);
    +
    +			final long time = System.nanoTime();
    +			strategy.restart(restarter, executor);
    +			sync.await();
    +
    +			final long elapsed = System.nanoTime() - time;
    +			assertTrue(&quot;Not enough delay&quot;, elapsed &amp;gt;= restartDelay * 1_000_000);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This method makes sure that the actual interval and is not spuriously waking up.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &quot;This method makes sure to sleep for the required interval and that we don&apos;t spuriously wake up.&quot;?&lt;/p&gt;

&lt;p&gt;    Also, what happens if `Thread.sleep()` is interrupted?&lt;/p&gt;</comment>
                            <comment id="16094653" author="githubbot" created="Thu, 20 Jul 2017 13:11:40 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128509787&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128509787&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java &amp;#8212;&lt;br/&gt;
    @@ -159,34 +161,6 @@ public void testRestartAutomatically() throws Exception {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void taskShouldFailWhenFailureRateLimitExceeded() throws Exception {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Yes, as part of introducing the &quot;callback&quot; indirection, we can now also test the restart strategies much better, without always setting up a full ExecutionGraph. I added it to the refactoring.&lt;/p&gt;</comment>
                            <comment id="16094654" author="githubbot" created="Thu, 20 Jul 2017 13:11:53 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128509863&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128509863&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java &amp;#8212;&lt;br/&gt;
    @@ -581,6 +565,106 @@ public void testSuspendWhileRestarting() throws Exception &lt;/p&gt;
{
     		assertEquals(JobStatus.SUSPENDED, eg.getState());
     	}

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testConcurrentLocalFailAndRestart() throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Right, this one was a test that should have been there in the first place and I took this chance to add it.&lt;/p&gt;</comment>
                            <comment id="16094663" author="githubbot" created="Thu, 20 Jul 2017 13:15:45 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128510738&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128510738&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java &amp;#8212;&lt;br/&gt;
    @@ -581,6 +565,106 @@ public void testSuspendWhileRestarting() throws Exception &lt;/p&gt;
{
     		assertEquals(JobStatus.SUSPENDED, eg.getState());
     	}

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testConcurrentLocalFailAndRestart() throws Exception {&lt;br/&gt;
    +		final ExecutionGraph eg = createSimpleTestGraph(new FixedDelayRestartStrategy(10, 0L));&lt;br/&gt;
    +		eg.setScheduleMode(ScheduleMode.EAGER);&lt;br/&gt;
    +		eg.scheduleForExecution();&lt;br/&gt;
    +&lt;br/&gt;
    +		waitUntilDeployedAndSwitchToRunning(eg, 1000);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ExecutionJobVertex vertex = eg.getVerticesTopologically().iterator().next();&lt;br/&gt;
    +		final Execution first = vertex.getTaskVertices()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.getCurrentExecutionAttempt();&lt;br/&gt;
    +		final Execution last = vertex.getTaskVertices()&lt;span class=&quot;error&quot;&gt;&amp;#91;vertex.getParallelism() - 1&amp;#93;&lt;/span&gt;.getCurrentExecutionAttempt();&lt;br/&gt;
    +&lt;br/&gt;
    +		final OneShotLatch failTrigger = new OneShotLatch();&lt;br/&gt;
    +		final CountDownLatch readyLatch = new CountDownLatch(2);&lt;br/&gt;
    +&lt;br/&gt;
    +		Thread failure1 = new Thread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void run() {&lt;br/&gt;
    +				readyLatch.countDown();&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					failTrigger.await();
    +				} catch (InterruptedException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +				first.fail(new Exception(&quot;intended test failure 1&quot;));&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		Thread failure2 = new Thread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void run() {&lt;br/&gt;
    +				readyLatch.countDown();&lt;br/&gt;
    +				try {    +					failTrigger.await();    +				}
&lt;p&gt; catch (InterruptedException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +				last.fail(new Exception(&quot;intended test failure 2&quot;));&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		// make sure both threads start simultaneously&lt;br/&gt;
    +		failure1.start();&lt;br/&gt;
    +		failure2.start();&lt;br/&gt;
    +		readyLatch.await();&lt;br/&gt;
    +		failTrigger.trigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		waitUntilJobStatus(eg, JobStatus.FAILING, 1000);&lt;br/&gt;
    +		completeCancellingForAllVertices(eg);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    True, those docs are copy/paste wrong &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I fixed them...&lt;/p&gt;</comment>
                            <comment id="16094668" author="githubbot" created="Thu, 20 Jul 2017 13:21:00 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128511963&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128511963&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java &amp;#8212;&lt;br/&gt;
    @@ -581,6 +565,106 @@ public void testSuspendWhileRestarting() throws Exception &lt;/p&gt;
{
     		assertEquals(JobStatus.SUSPENDED, eg.getState());
     	}

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testConcurrentLocalFailAndRestart() throws Exception {&lt;br/&gt;
    +		final ExecutionGraph eg = createSimpleTestGraph(new FixedDelayRestartStrategy(10, 0L));&lt;br/&gt;
    +		eg.setScheduleMode(ScheduleMode.EAGER);&lt;br/&gt;
    +		eg.scheduleForExecution();&lt;br/&gt;
    +&lt;br/&gt;
    +		waitUntilDeployedAndSwitchToRunning(eg, 1000);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ExecutionJobVertex vertex = eg.getVerticesTopologically().iterator().next();&lt;br/&gt;
    +		final Execution first = vertex.getTaskVertices()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.getCurrentExecutionAttempt();&lt;br/&gt;
    +		final Execution last = vertex.getTaskVertices()&lt;span class=&quot;error&quot;&gt;&amp;#91;vertex.getParallelism() - 1&amp;#93;&lt;/span&gt;.getCurrentExecutionAttempt();&lt;br/&gt;
    +&lt;br/&gt;
    +		final OneShotLatch failTrigger = new OneShotLatch();&lt;br/&gt;
    +		final CountDownLatch readyLatch = new CountDownLatch(2);&lt;br/&gt;
    +&lt;br/&gt;
    +		Thread failure1 = new Thread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void run() {&lt;br/&gt;
    +				readyLatch.countDown();&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					failTrigger.await();
    +				} catch (InterruptedException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +				first.fail(new Exception(&quot;intended test failure 1&quot;));&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		Thread failure2 = new Thread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void run() {&lt;br/&gt;
    +				readyLatch.countDown();&lt;br/&gt;
    +				try {    +					failTrigger.await();    +				}
&lt;p&gt; catch (InterruptedException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +				last.fail(new Exception(&quot;intended test failure 2&quot;));&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		// make sure both threads start simultaneously&lt;br/&gt;
    +		failure1.start();&lt;br/&gt;
    +		failure2.start();&lt;br/&gt;
    +		readyLatch.await();&lt;br/&gt;
    +		failTrigger.trigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		waitUntilJobStatus(eg, JobStatus.FAILING, 1000);&lt;br/&gt;
    +		completeCancellingForAllVertices(eg);&lt;br/&gt;
    +&lt;br/&gt;
    +		waitUntilJobStatus(eg, JobStatus.RUNNING, 1000);&lt;br/&gt;
    +		waitUntilDeployedAndSwitchToRunning(eg, 1000);&lt;br/&gt;
    +		finishAllVertices(eg);&lt;br/&gt;
    +&lt;br/&gt;
    +		eg.waitUntilTerminal();&lt;br/&gt;
    +		assertEquals(JobStatus.FINISHED, eg.getState());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testConcurrentGlobalFailAndRestarts() throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    From the offline chat: I think you are missing the asynchrony in the restarting, leading to a lock in the cherrypicked code.&lt;/p&gt;</comment>
                            <comment id="16094670" author="githubbot" created="Thu, 20 Jul 2017 13:21:55 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128512192&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128512192&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/restart/FailureRateRestartStrategyTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,128 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.runtime.executiongraph.restart;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.time.Time;&lt;br/&gt;
    +import org.apache.flink.core.testutils.OneShotLatch;&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.ScheduledExecutor;&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.ScheduledExecutorServiceAdapter;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.After;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.ScheduledExecutorService;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertFalse;&lt;br/&gt;
    +import static org.junit.Assert.assertTrue;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Unit test for the &lt;/p&gt;
{@link FailureRateRestartStrategy}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class FailureRateRestartStrategyTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	public final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(4);&lt;br/&gt;
    +&lt;br/&gt;
    +	public final ScheduledExecutor executor = new ScheduledExecutorServiceAdapter(executorService);&lt;br/&gt;
    +&lt;br/&gt;
    +	@After&lt;br/&gt;
    +	public void shutdownExecutor() &lt;/p&gt;
{
    +		executorService.shutdownNow();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testManyFailuresWithinRate() throws Exception {&lt;br/&gt;
    +		final int numAttempts = 10;&lt;br/&gt;
    +		final int intervalMillis = 1;&lt;br/&gt;
    +&lt;br/&gt;
    +		final FailureRateRestartStrategy restartStrategy =&lt;br/&gt;
    +				new FailureRateRestartStrategy(1, Time.milliseconds(intervalMillis), Time.milliseconds(0));&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int attempsLeft = numAttempts; attempsLeft &amp;gt; 0; --attempsLeft) &lt;/p&gt;
{
    +			assertTrue(restartStrategy.canRestart());
    +			restartStrategy.restart(new NoOpRestarter(), executor);
    +			sleepGuaranteed(2 * intervalMillis);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		assertTrue(restartStrategy.canRestart());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testFailuresExceedingRate() throws Exception {&lt;br/&gt;
    +		final int numFailures = 3;&lt;br/&gt;
    +		final int intervalMillis = 10_000;&lt;br/&gt;
    +&lt;br/&gt;
    +		final FailureRateRestartStrategy restartStrategy =&lt;br/&gt;
    +				new FailureRateRestartStrategy(numFailures, Time.milliseconds(intervalMillis), Time.milliseconds(0));&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int failuresLeft = numFailures; failuresLeft &amp;gt; 0; --failuresLeft) &lt;/p&gt;
{
    +			assertTrue(restartStrategy.canRestart());
    +			restartStrategy.restart(new NoOpRestarter(), executor);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// now the rate should be exceeded&lt;br/&gt;
    +		assertFalse(restartStrategy.canRestart());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testDelay() throws Exception {&lt;br/&gt;
    +		final long restartDelay = 2;&lt;br/&gt;
    +		final int numberRestarts = 10;&lt;br/&gt;
    +&lt;br/&gt;
    +		final FailureRateRestartStrategy strategy =&lt;br/&gt;
    +			new FailureRateRestartStrategy(numberRestarts + 1, Time.milliseconds(1), Time.milliseconds(restartDelay));&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int restartsLeft = numberRestarts; restartsLeft &amp;gt; 0; --restartsLeft) &lt;/p&gt;
{
    +			assertTrue(strategy.canRestart());
    +
    +			final OneShotLatch sync = new OneShotLatch();
    +			final RestartCallback restarter = new LatchedRestarter(sync);
    +
    +			final long time = System.nanoTime();
    +			strategy.restart(restarter, executor);
    +			sync.await();
    +
    +			final long elapsed = System.nanoTime() - time;
    +			assertTrue(&quot;Not enough delay&quot;, elapsed &amp;gt;= restartDelay * 1_000_000);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This method makes sure that the actual interval and is not spuriously waking up.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Then the whole method and test anyways aborts exceptionally.&lt;/p&gt;</comment>
                            <comment id="16094676" author="githubbot" created="Thu, 20 Jul 2017 13:24:19 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128512830&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128512830&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphTestUtils.java &amp;#8212;&lt;br/&gt;
    @@ -189,6 +189,35 @@ public static void finishAllVertices(ExecutionGraph eg) {&lt;br/&gt;
     		}&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * Turns a newly scheduled execution graph into a state where all vertices run.&lt;br/&gt;
    +	 * This waits until all executions have reached state &apos;DEPLOYING&apos; and then switches them to running.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static void waitUntilDeployedAndSwitchToRunning(ExecutionGraph eg, long timeout) throws TimeoutException {&lt;br/&gt;
    +		// wait until everything is running&lt;br/&gt;
    +		for (ExecutionVertex ev : eg.getAllExecutionVertices()) &lt;/p&gt;
{
    +			final Execution exec = ev.getCurrentExecutionAttempt();
    +			waitUntilExecutionState(exec, ExecutionState.DEPLOYING, timeout);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// Note: As ugly as it is, we need this minor sleep, because between switching&lt;br/&gt;
    +		// to &apos;DEPLOYED&apos; and when the &apos;switchToRunning()&apos; may be called lies a race check&lt;br/&gt;
    +		// against concurrent modifications (cancel / fail). We can only switch this to running&lt;br/&gt;
    +		// once that check is passed. For the actual runtime, this switch is triggered by a callback&lt;br/&gt;
    +		// from the TaskManager, which comes strictly after that. For tests, we use mock TaskManagers&lt;br/&gt;
    +		// which cannot easily tell us when that condition has happened, unfortunately.&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			Thread.sleep(2);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    In very rare cases, it might. I want to change the `Execution` a bit on the `master` to make this unnecessary.&lt;/p&gt;

&lt;p&gt;    However, that is too much surgery in a critical part for a bugfix release, so I decided to be conservative in the runtime code and rather pay this price in the tests.&lt;/p&gt;
</comment>
                            <comment id="16094678" author="githubbot" created="Thu, 20 Jul 2017 13:24:44 +0000"  >&lt;p&gt;Github user StephanEwen commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for the reviews. Addressing the comments, rerunning tests, and merging...&lt;/p&gt;</comment>
                            <comment id="16094691" author="githubbot" created="Thu, 20 Jul 2017 13:35:29 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128515593&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128515593&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java &amp;#8212;&lt;br/&gt;
    @@ -581,6 +565,106 @@ public void testSuspendWhileRestarting() throws Exception &lt;/p&gt;
{
     		assertEquals(JobStatus.SUSPENDED, eg.getState());
     	}

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testConcurrentLocalFailAndRestart() throws Exception {&lt;br/&gt;
    +		final ExecutionGraph eg = createSimpleTestGraph(new FixedDelayRestartStrategy(10, 0L));&lt;br/&gt;
    +		eg.setScheduleMode(ScheduleMode.EAGER);&lt;br/&gt;
    +		eg.scheduleForExecution();&lt;br/&gt;
    +&lt;br/&gt;
    +		waitUntilDeployedAndSwitchToRunning(eg, 1000);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ExecutionJobVertex vertex = eg.getVerticesTopologically().iterator().next();&lt;br/&gt;
    +		final Execution first = vertex.getTaskVertices()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.getCurrentExecutionAttempt();&lt;br/&gt;
    +		final Execution last = vertex.getTaskVertices()&lt;span class=&quot;error&quot;&gt;&amp;#91;vertex.getParallelism() - 1&amp;#93;&lt;/span&gt;.getCurrentExecutionAttempt();&lt;br/&gt;
    +&lt;br/&gt;
    +		final OneShotLatch failTrigger = new OneShotLatch();&lt;br/&gt;
    +		final CountDownLatch readyLatch = new CountDownLatch(2);&lt;br/&gt;
    +&lt;br/&gt;
    +		Thread failure1 = new Thread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void run() {&lt;br/&gt;
    +				readyLatch.countDown();&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					failTrigger.await();
    +				} catch (InterruptedException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +				first.fail(new Exception(&quot;intended test failure 1&quot;));&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		Thread failure2 = new Thread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void run() {&lt;br/&gt;
    +				readyLatch.countDown();&lt;br/&gt;
    +				try {    +					failTrigger.await();    +				}
&lt;p&gt; catch (InterruptedException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +				last.fail(new Exception(&quot;intended test failure 2&quot;));&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		// make sure both threads start simultaneously&lt;br/&gt;
    +		failure1.start();&lt;br/&gt;
    +		failure2.start();&lt;br/&gt;
    +		readyLatch.await();&lt;br/&gt;
    +		failTrigger.trigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		waitUntilJobStatus(eg, JobStatus.FAILING, 1000);&lt;br/&gt;
    +		completeCancellingForAllVertices(eg);&lt;br/&gt;
    +&lt;br/&gt;
    +		waitUntilJobStatus(eg, JobStatus.RUNNING, 1000);&lt;br/&gt;
    +		waitUntilDeployedAndSwitchToRunning(eg, 1000);&lt;br/&gt;
    +		finishAllVertices(eg);&lt;br/&gt;
    +&lt;br/&gt;
    +		eg.waitUntilTerminal();&lt;br/&gt;
    +		assertEquals(JobStatus.FINISHED, eg.getState());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testConcurrentGlobalFailAndRestarts() throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Jip, I think so too.&lt;/p&gt;</comment>
                            <comment id="16094694" author="githubbot" created="Thu, 20 Jul 2017 13:36:25 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364#discussion_r128515844&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364#discussion_r128515844&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/restart/FailureRateRestartStrategyTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,128 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.runtime.executiongraph.restart;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.time.Time;&lt;br/&gt;
    +import org.apache.flink.core.testutils.OneShotLatch;&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.ScheduledExecutor;&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.ScheduledExecutorServiceAdapter;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.After;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.ScheduledExecutorService;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertFalse;&lt;br/&gt;
    +import static org.junit.Assert.assertTrue;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Unit test for the &lt;/p&gt;
{@link FailureRateRestartStrategy}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class FailureRateRestartStrategyTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	public final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(4);&lt;br/&gt;
    +&lt;br/&gt;
    +	public final ScheduledExecutor executor = new ScheduledExecutorServiceAdapter(executorService);&lt;br/&gt;
    +&lt;br/&gt;
    +	@After&lt;br/&gt;
    +	public void shutdownExecutor() &lt;/p&gt;
{
    +		executorService.shutdownNow();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testManyFailuresWithinRate() throws Exception {&lt;br/&gt;
    +		final int numAttempts = 10;&lt;br/&gt;
    +		final int intervalMillis = 1;&lt;br/&gt;
    +&lt;br/&gt;
    +		final FailureRateRestartStrategy restartStrategy =&lt;br/&gt;
    +				new FailureRateRestartStrategy(1, Time.milliseconds(intervalMillis), Time.milliseconds(0));&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int attempsLeft = numAttempts; attempsLeft &amp;gt; 0; --attempsLeft) &lt;/p&gt;
{
    +			assertTrue(restartStrategy.canRestart());
    +			restartStrategy.restart(new NoOpRestarter(), executor);
    +			sleepGuaranteed(2 * intervalMillis);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		assertTrue(restartStrategy.canRestart());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testFailuresExceedingRate() throws Exception {&lt;br/&gt;
    +		final int numFailures = 3;&lt;br/&gt;
    +		final int intervalMillis = 10_000;&lt;br/&gt;
    +&lt;br/&gt;
    +		final FailureRateRestartStrategy restartStrategy =&lt;br/&gt;
    +				new FailureRateRestartStrategy(numFailures, Time.milliseconds(intervalMillis), Time.milliseconds(0));&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int failuresLeft = numFailures; failuresLeft &amp;gt; 0; --failuresLeft) &lt;/p&gt;
{
    +			assertTrue(restartStrategy.canRestart());
    +			restartStrategy.restart(new NoOpRestarter(), executor);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// now the rate should be exceeded&lt;br/&gt;
    +		assertFalse(restartStrategy.canRestart());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testDelay() throws Exception {&lt;br/&gt;
    +		final long restartDelay = 2;&lt;br/&gt;
    +		final int numberRestarts = 10;&lt;br/&gt;
    +&lt;br/&gt;
    +		final FailureRateRestartStrategy strategy =&lt;br/&gt;
    +			new FailureRateRestartStrategy(numberRestarts + 1, Time.milliseconds(1), Time.milliseconds(restartDelay));&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int restartsLeft = numberRestarts; restartsLeft &amp;gt; 0; --restartsLeft) &lt;/p&gt;
{
    +			assertTrue(strategy.canRestart());
    +
    +			final OneShotLatch sync = new OneShotLatch();
    +			final RestartCallback restarter = new LatchedRestarter(sync);
    +
    +			final long time = System.nanoTime();
    +			strategy.restart(restarter, executor);
    +			sync.await();
    +
    +			final long elapsed = System.nanoTime() - time;
    +			assertTrue(&quot;Not enough delay&quot;, elapsed &amp;gt;= restartDelay * 1_000_000);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This method makes sure that the actual interval and is not spuriously waking up.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Perfect&lt;/p&gt;</comment>
                            <comment id="16094698" author="githubbot" created="Thu, 20 Jul 2017 13:37:01 +0000"  >&lt;p&gt;Github user aljoscha commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    +1 for merging!&lt;/p&gt;</comment>
                            <comment id="16098093" author="githubbot" created="Mon, 24 Jul 2017 08:48:09 +0000"  >&lt;p&gt;Github user StephanEwen closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4364&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4364&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16243929" author="aljoscha" created="Wed, 8 Nov 2017 13:30:49 +0000"  >&lt;p&gt;Reopen to fix release note.&lt;/p&gt;</comment>
                            <comment id="16243930" author="aljoscha" created="Wed, 8 Nov 2017 13:30:57 +0000"  >&lt;p&gt;Fixed in &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;1.4.0 via 74a6cbab4e736cdb353d100cdd29f51809325796&lt;/li&gt;
	&lt;li&gt;1.3.2 via e6348fbde1fc0ee8ea682063a4d6503ba3b68864&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="13073976">FLINK-6667</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 1 week, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3hmb3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>