<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:48:46 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-16510] Task manager safeguard shutdown may not be reliable</title>
                <link>https://issues.apache.org/jira/browse/FLINK-16510</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;The &lt;tt&gt;JvmShutdownSafeguard&lt;/tt&gt; does not always succeed but can hang when multiple threads attempt to shutdown the JVM. Apparently mixing &lt;tt&gt;System.exit()&lt;/tt&gt; with ShutdownHooks and forcefully terminating the JVM via &lt;tt&gt;Runtime.halt()&lt;/tt&gt; does not play together well:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;&quot;Jvm Terminator&quot; #22 daemon prio=5 os_prio=0 tid=0x00007fb8e82f2800 nid=0x5a96 runnable [0x00007fb35cffb000]
   java.lang.Thread.State: RUNNABLE
	at java.lang.Shutdown.$$YJP$$halt0(Native Method)
	at java.lang.Shutdown.halt0(Shutdown.java)
	at java.lang.Shutdown.halt(Shutdown.java:139)
	- locked &amp;lt;0x000000047ed67638&amp;gt; (a java.lang.Shutdown$Lock)
	at java.lang.Runtime.halt(Runtime.java:276)
	at org.apache.flink.runtime.util.JvmShutdownSafeguard$DelayedTerminator.run(JvmShutdownSafeguard.java:86)
	at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
	- None

&quot;FlinkCompletableFutureDelayScheduler-thread-1&quot; #18154 daemon prio=5 os_prio=0 tid=0x00007fb708a7d000 nid=0x5a8a waiting for monitor entry [0x00007fb289d49000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at java.lang.Shutdown.halt(Shutdown.java:139)
	- waiting to lock &amp;lt;0x000000047ed67638&amp;gt; (a java.lang.Shutdown$Lock)
	at java.lang.Shutdown.exit(Shutdown.java:213)
	- locked &amp;lt;0x000000047edb7348&amp;gt; (a java.lang.Class for java.lang.Shutdown)
	at java.lang.Runtime.exit(Runtime.java:110)
	at java.lang.System.exit(System.java:973)
	at org.apache.flink.runtime.taskexecutor.TaskManagerRunner.terminateJVM(TaskManagerRunner.java:266)
	at org.apache.flink.runtime.taskexecutor.TaskManagerRunner.lambda$onFatalError$1(TaskManagerRunner.java:260)
	at org.apache.flink.runtime.taskexecutor.TaskManagerRunner$$Lambda$27464/1464672548.accept(Unknown Source)
	at java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:774)
	at java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:750)
	at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:488)
	at java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:1990)
	at org.apache.flink.runtime.concurrent.FutureUtils$Timeout.run(FutureUtils.java:943)
	at org.apache.flink.runtime.concurrent.DirectExecutorService.execute(DirectExecutorService.java:211)
	at org.apache.flink.runtime.concurrent.FutureUtils.lambda$orTimeout$11(FutureUtils.java:361)
	at org.apache.flink.runtime.concurrent.FutureUtils$$Lambda$27435/159015392.run(Unknown Source)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
	- &amp;lt;0x00000006d5e56bd0&amp;gt; (a java.util.concurrent.ThreadPoolExecutor$Worker)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note that under this condition the JVM should terminate but it still hangs. Sometimes it quits after several minutes.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13290629">FLINK-16510</key>
            <summary>Task manager safeguard shutdown may not be reliable</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mxm">Maximilian Michels</assignee>
                                    <reporter username="mxm">Maximilian Michels</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Mon, 9 Mar 2020 20:02:35 +0000</created>
                <updated>Fri, 7 Aug 2020 10:30:36 +0000</updated>
                            <resolved>Fri, 7 Aug 2020 10:30:36 +0000</resolved>
                                    <version>1.10.1</version>
                    <version>1.11.1</version>
                    <version>1.12.0</version>
                                    <fixVersion>1.10.2</fixVersion>
                    <fixVersion>1.11.2</fixVersion>
                    <fixVersion>1.12.0</fixVersion>
                                    <component>Runtime / Task</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="17055809" author="stephanewen" created="Tue, 10 Mar 2020 10:45:57 +0000"  >&lt;p&gt;Do you know what exactly is happening there? It does not look like a deadlock.&lt;br/&gt;
Is the &lt;tt&gt;java.lang.Shutdown.$$YJP$$halt0&lt;/tt&gt; call simply stuck?&lt;/p&gt;</comment>
                            <comment id="17055832" author="mxm" created="Tue, 10 Mar 2020 11:15:48 +0000"  >&lt;p&gt;Yes, indeed no deadlock. The thread which calls halt0 is in RUNNABLE state. Unfortunately, I have not been able to find out what it is doing but I suspect that multiple threads triggering the shutdown causes the JVM to choke.&lt;/p&gt;

&lt;p&gt;I&apos;ll try to use strace next time I&apos;m seeing this. &lt;/p&gt;</comment>
                            <comment id="17057885" author="mxm" created="Thu, 12 Mar 2020 12:38:12 +0000"  >&lt;p&gt;We haven&apos;t seen this particular problem after we replaced all graceful shutdowns with hard exists. However, we&apos;ve seen task managers freezing. Looks like this is caused by lack of metaspace (we restrict it to 2GB). The meta space fills up after many restarts due to lingering threads which hold on to the classloader. &lt;/p&gt;</comment>
                            <comment id="17057943" author="stephanewen" created="Thu, 12 Mar 2020 13:57:50 +0000"  >&lt;p&gt;Have you looked into &quot;application&quot;/&quot;per job&quot; deployment? That eliminates all dynamic class loading in the first place.&lt;br/&gt;
Using &quot;sessions&quot; mode for only a single job may be a non-ideal setup.&lt;/p&gt;</comment>
                            <comment id="17058026" author="mxm" created="Thu, 12 Mar 2020 15:43:06 +0000"  >&lt;p&gt;I&apos;m constrained by what Lyft&apos;s k8s operator offers. At this point it brings up a &quot;session&quot; cluster and submits the job against it. I agree that this is suboptimal. Note that we would still have the problem of lingering threads like in &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-16573&quot; title=&quot;Kinesis consumer does not properly shutdown RecordFetcher threads&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-16573&quot;&gt;&lt;del&gt;FLINK-16573&lt;/del&gt;&lt;/a&gt; which could eat up memory, even though meta space would not be affected.&lt;/p&gt;</comment>
                            <comment id="17153813" author="thw" created="Wed, 8 Jul 2020 17:54:32 +0000"  >&lt;p&gt;We are not able to reliably run our applications on k8s when pods get stuck during termination on a fatal task manager error. When pods don&apos;t exit our infrastructure cannot replace the task manager and applications cannot recover. We have seen this issue many times and we were able to reproduce it with benchmarks that produce intermittent OOMs. Based on the analysis from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mxm&quot; class=&quot;user-hover&quot; rel=&quot;mxm&quot;&gt;mxm&lt;/a&gt;&#160;we have applied this change to our fork:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/lyft/flink/commit/4787e4d638c5b299164b85e7e492967bf573c400&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/lyft/flink/commit/4787e4d638c5b299164b85e7e492967bf573c400&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We would like to address this issue upstream though. When a fatal error occurs, the process should safely terminate. Triggering shutdown hooks is unlikely to succeed. It is important that we get a fresh TM deployed to allow for job recovery and forward progress (avoid extended downtime and need for manual intervention).&lt;/p&gt;

&lt;p&gt;Do you see any downside using the hard stop instead of System.exit?&lt;/p&gt;

&lt;p&gt;Currently, there are multiple occurrences of System.exit - for everything that aims to &quot;exitOnFatalError&quot; it would be nice to centralize.&#160;&lt;/p&gt;</comment>
                            <comment id="17154416" author="stephanewen" created="Thu, 9 Jul 2020 10:13:26 +0000"  >&lt;p&gt;The current approach in Flink is the following:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fatal errors initiall call System.exit(), which allows shutdown hooks to run and to clean up stuff (local files)&lt;/li&gt;
	&lt;li&gt;one of the Shutdown hooks has a timer that calls Runtime.halt() if the JVM is not terminated after 10 seconds.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The change you proposed would mean that Flink never attempts to clean up.&lt;/p&gt;

&lt;p&gt;For some reason, the shutdown hooks seem to not work reliably on some JVM / Kernel versions. Could you confirm whether you might be affected by the same issue as &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-17470&quot; title=&quot;Flink task executor process permanently hangs on `flink-daemon.sh stop`, deletes PID file&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-17470&quot;&gt;&lt;del&gt;FLINK-17470&lt;/del&gt;&lt;/a&gt; ?&lt;/p&gt;

&lt;p&gt;If yes, could we try and find another way to go for the &quot;graceful exit first, hard exit if unsuccessful&quot; approach?&lt;/p&gt;
</comment>
                            <comment id="17154445" author="mxm" created="Thu, 9 Jul 2020 11:31:02 +0000"  >&lt;p&gt;If you look at the stacktrace in the description, you can see that the presence of a graceful shutdown including shutdown hooks can block a forceful shutdown via &lt;tt&gt;System.getRuntime().halt()&lt;/tt&gt;. We had applied the fix that Thomas linked to our Flink 1.8 version, once we moved to Flink 1.10, we hadn&apos;t reapplied the fix and were running into this issue again. Hence, we reverted back to always using Runtime#halt(). It is crucial for us that the shutdown always succeeds, no matter what, otherwise the hosting K8s pod won&apos;t terminate and we are in an idle state.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-17470&quot; title=&quot;Flink task executor process permanently hangs on `flink-daemon.sh stop`, deletes PID file&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-17470&quot;&gt;&lt;del&gt;FLINK-17470&lt;/del&gt;&lt;/a&gt; is unrelated because we do not use the bash scripts to stop the node. Rather, the problem is that the TaskManager does not terminate itself during fatal errors, OOM in our case. I noticed that there is a configuration value &lt;tt&gt;&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-stable/ops/config.html#taskmanager-jvm-exit-on-oom&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://ci.apache.org/projects/flink/flink-docs-stable/ops/config.html#taskmanager-jvm-exit-on-oom&lt;/a&gt;&lt;/tt&gt; but I don&apos;t think it is effective because an OOM can potentially be thrown at non Task-related places where it won&apos;t lead to a forceful shutdown.&lt;/p&gt;

&lt;p&gt;Would it make sense to have something like &lt;tt&gt;taskmanager.jvm-exit-on-error&lt;/tt&gt; which always forcefully exit on fatal errors if set to &lt;tt&gt;true&lt;/tt&gt;?&lt;/p&gt;</comment>
                            <comment id="17154446" author="mxm" created="Thu, 9 Jul 2020 11:31:18 +0000"  >&lt;p&gt;As for the Java version, we are using the following which does look like the &quot;newest&quot; 1.8 version:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;openjdk version &quot;1.8.0_252&quot;
OpenJDK Runtime Environment (build 1.8.0_252-8u252-b09-1~18.04-b09)
OpenJDK 64-Bit Server VM (build 25.252-b09, mixed mode)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="17156868" author="zentol" created="Mon, 13 Jul 2020 17:39:47 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mxm&quot; class=&quot;user-hover&quot; rel=&quot;mxm&quot;&gt;mxm&lt;/a&gt; Do you know what other threads have been doing when the JVM was stuck? I found a &lt;a href=&quot;https://bugs.eclipse.org/bugs/show_bug.cgi?id=348487&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;similar case&lt;/a&gt; with a thread being stuck within Runtime#halt, due to a non-daemon thread lingering around. Various shutdown hooks we have create non-daemon threads via ShutdownHookUtil#addShutdownHook; maybe one of them got stuck? This would also explain while calling Runtime#halt immediately fixes the issue; the shutdown hooks are never started.&lt;/p&gt;</comment>
                            <comment id="17163813" author="mxm" created="Thu, 23 Jul 2020 17:38:44 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=chesnay&quot; class=&quot;user-hover&quot; rel=&quot;chesnay&quot;&gt;chesnay&lt;/a&gt; Here a stack dump from the stuck task manager: &lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/13008296/13008296_stack2-1.txt&quot; title=&quot;stack2-1.txt attached to FLINK-16510&quot;&gt;stack2-1.txt&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;. &lt;/p&gt;

&lt;p&gt;Note the common pattern that after an OOM, all the threads get stuck in native methods like &lt;tt&gt;sun.misc.Unsafe.defineAnonymousClass&lt;/tt&gt; or &lt;tt&gt;java.lang.Class.getDeclaredConstructors0&lt;/tt&gt;. There does not seem a graceful way to get out of this situation other than immediately halting the JVM.&lt;/p&gt;

&lt;p&gt;I would like to introduce an option to always forcefully terminate the task manager in case of unrecoverable errors. That&apos;s what we have been doing and it&apos;s the only way we have been able to reliably operate Flink in our k8s deployments in case of OOM errors. &lt;/p&gt;</comment>
                            <comment id="17164313" author="zentol" created="Fri, 24 Jul 2020 09:31:49 +0000"  >&lt;p&gt;Maybe we can store all shutdown hook threads that we create in &lt;tt&gt;org.apache.flink.util.ShutdownHookUtil#addShutdownHook&lt;/tt&gt;, and trigger an interrupt before calling &lt;tt&gt;Runtime#halt&lt;/tt&gt; in the backup shutdown hook?&lt;br/&gt;
Hell, maybe we could even iterate over all threads and interrupt everything that isn&apos;t the halting shutdown hook.&lt;/p&gt;

&lt;p&gt;While we could &lt;em&gt;maybe&lt;/em&gt; fix shutdown hooks getting stuck by removing all usages of anonymous classes, this seems like quite the effort since we&apos;d have to cover &lt;em&gt;all&lt;/em&gt; code-paths...&lt;/p&gt;</comment>
                            <comment id="17164358" author="till.rohrmann" created="Fri, 24 Jul 2020 10:36:06 +0000"  >&lt;p&gt;Thanks for providing the stack trace &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mxm&quot; class=&quot;user-hover&quot; rel=&quot;mxm&quot;&gt;mxm&lt;/a&gt;. I assume that this problem is somewhat reproducible, right? I am asking because it would be helpful to obtain the mixed stack trace via &lt;tt&gt;jstack -m&lt;/tt&gt; which contains the JVM threads and also the C/C++ threads. Moreover, in order to better understand the problem, it would also be helpful to see the exact command with which you start the JVM process.&lt;/p&gt;

&lt;p&gt;I agree that an easy solution would be to make Flink&apos;s exit behaviour configurable (per default &lt;tt&gt;System.exit()&lt;/tt&gt; but if users wish then to use &lt;tt&gt;Runtime.halt()&lt;/tt&gt;). However, before doing this, I would really like to better understand why the system gets stuck in your case because &lt;tt&gt;Runtime.halt()&lt;/tt&gt; is actually being called in your case:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt; 18575: (state = BLOCKED)
 - java.lang.Shutdown.$$YJP$$halt0(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;) @bci=0 (Interpreted frame)
 - java.lang.Shutdown.halt0(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;) @bci=14 (Interpreted frame)
 - java.lang.Shutdown.halt(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;) @bci=30, line=139 (Interpreted frame)
 - java.lang.&lt;span class=&quot;code-object&quot;&gt;Runtime&lt;/span&gt;.halt(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;) @bci=57, line=275 (Interpreted frame)
 - org.apache.flink.runtime.util.JvmShutdownSafeguard$DelayedTerminator.run() @bci=59, line=86 (Interpreted frame)
 - java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run() @bci=49, line=748 (Compiled frame)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The problem seems to be that all Java threads are currently being &lt;tt&gt;BLOCKED&lt;/tt&gt;. Maybe it&apos;s because a safepoint has been reached and there is some problem coming back from it. The following JVM options could help with the debugging:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&lt;tt&gt;-XX:+PrintGCApplicationStoppedTime&lt;/tt&gt; &#8211; this will actually report pause time for all safepoints (GC related or not). Unfortunately output from this option lacks timestamps, but it is still useful to narrow down problem to safepoints.&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;-XX:+PrintSafepointStatistics &#8211;XX:PrintSafepointStatisticsCount=1&lt;/tt&gt; &#8211; this two options will force JVM to report reason and timings after each safepoint (it will be reported to stdout, not GC log).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Reference: &lt;a href=&quot;http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17164366" author="till.rohrmann" created="Fri, 24 Jul 2020 10:40:22 +0000"  >&lt;p&gt;I&apos;m posting this for reference: There seems to be a problem in the JDK 12 where the JVM might deadlock if it starts a concurrent G1 cycle while shutting down: &lt;a href=&quot;https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8210706&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8210706&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="17164375" author="zentol" created="Fri, 24 Jul 2020 11:17:40 +0000"  >&lt;p&gt;The GC one can&apos;t be fixed in any case though, right?&lt;/p&gt;</comment>
                            <comment id="17164508" author="till.rohrmann" created="Fri, 24 Jul 2020 16:10:13 +0000"  >&lt;p&gt;Jup, if it is a GC bug, then this is a JVM problem. Moreover, this problem should then also occur when only using &lt;tt&gt;Runtime.halt()&lt;/tt&gt;. But maybe it is more likely to be triggered when running additional shut down hooks which create some lambdas. But let&apos;s first try to figure out whether it is really this problem.&lt;/p&gt;</comment>
                            <comment id="17164511" author="thw" created="Fri, 24 Jul 2020 16:20:24 +0000"  >&lt;p&gt;I think there are 2 interests involved here:&lt;/p&gt;

&lt;p&gt;1. How to ensure that the task manager JVM gets safely terminated on a fatal error, regardless of the behavior of user code and other dependencies&lt;br/&gt;
2. Why execution of shutdown hooks can cause the JVM to get stuck&lt;/p&gt;

&lt;p&gt;We at Lyft need the option to safely terminate the VMs so that pods are replaced immediately. We are not interested in executing of shutdown hooks when the JVM is already in a problematic state.&lt;/p&gt;</comment>
                            <comment id="17165513" author="till.rohrmann" created="Mon, 27 Jul 2020 07:51:19 +0000"  >&lt;p&gt;I think it is a reasonable request to be able to safely terminate a Flink process in case of fatal errors &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=thw&quot; class=&quot;user-hover&quot; rel=&quot;thw&quot;&gt;thw&lt;/a&gt;. However, I&apos;m not entirely sure whether we can already jump to the conclusion that it is caused by running the shutdown hooks. If we want to ensure that 1. works, then I believe we should also try to understand why the JVM got stuck in the first place (e.g. it could be caused by a garbage collector which could make &lt;tt&gt;Runtime.halt&lt;/tt&gt; also susceptible).&lt;/p&gt;

&lt;p&gt;What wouldn&apos;t hurt is to already centralize the fatal error handling so that one could make it more easily configurable.&lt;/p&gt;</comment>
                            <comment id="17166288" author="till.rohrmann" created="Tue, 28 Jul 2020 09:13:51 +0000"  >&lt;p&gt;In order to point this out because it might have gotten lost in the discussion: Per default Flink will call &lt;tt&gt;Runtime.halt&lt;/tt&gt; via the &lt;tt&gt;JvmShutdownSafeguard.DelayedTerminator&lt;/tt&gt; which is also being executed in the stack trace Max posted. According to the JavaDocs of this method, it will also interrupt possibly running shut down hooks.&lt;/p&gt;</comment>
                            <comment id="17166293" author="zentol" created="Tue, 28 Jul 2020 09:24:32 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trohrmann&quot; class=&quot;user-hover&quot; rel=&quot;trohrmann&quot;&gt;trohrmann&lt;/a&gt; I cannot find a mention of interrupts in the JavaDocs of &lt;tt&gt;Runtime#halt&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="17166302" author="till.rohrmann" created="Tue, 28 Jul 2020 09:42:08 +0000"  >&lt;p&gt;The JavaDoc says &quot;If the shutdown sequence has already been initiated then this method does not wait for any running shutdown hooks or finalizers to finish their work.&quot;.&lt;/p&gt;</comment>
                            <comment id="17166669" author="mxm" created="Tue, 28 Jul 2020 20:06:04 +0000"  >&lt;p&gt;Here is the requested information (without changing the JVM arguments):&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;jstack -F -m 1&lt;/tt&gt;:  &lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/13008620/13008620_stack3-mixed.txt&quot; title=&quot;stack3-mixed.txt attached to FLINK-16510&quot;&gt;stack3-mixed.txt&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt; (same error without -F)&lt;br/&gt;
&lt;tt&gt;jstack -F 1&lt;/tt&gt;:  &lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/13008621/13008621_stack3.txt&quot; title=&quot;stack3.txt attached to FLINK-16510&quot;&gt;stack3.txt&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;
Command:  &lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/13008622/13008622_command.txt&quot; title=&quot;command.txt attached to FLINK-16510&quot;&gt;command.txt&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;Interestingly, the originally reported behavior of hanging in the shutdown hooks is not visible in the stack trace. Still, the problem is not reproducible if &lt;tt&gt;halt&lt;/tt&gt; will be immediately called on fatal errors without running shutdown hooks.&lt;/p&gt;</comment>
                            <comment id="17167055" author="till.rohrmann" created="Wed, 29 Jul 2020 08:36:37 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mxm&quot; class=&quot;user-hover&quot; rel=&quot;mxm&quot;&gt;mxm&lt;/a&gt;. It looks indeed as if the JVM is doing some Garbage collection:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
0x00007ff70aacdf93	_ZN9CodeCache8blobs_doEP15CodeBlobClosure + 0x93
0x00007ff70ac2c82d	_ZN15G1RootProcessor17process_all_rootsEP10OopClosureP10CLDClosureP15CodeBlobClosure + 0xdd
0x00007ff70ac2305c	_ZN11G1MarkSweep17mark_sweep_phase3Ev + 0xbc
0x00007ff70ac231f4	_ZN11G1MarkSweep19invoke_at_safepointEP18ReferenceProcessorb + 0xf4
0x00007ff70ac06d08	_ZN15G1CollectedHeap13do_collectionEbbm.part.286 + 0x558
0x00007ff70ac07735	_ZN15G1CollectedHeap25satisfy_failed_allocationEmhPb + 0x75
0x00007ff70b13b46f	_ZN25VM_G1CollectForAllocation4doitEv + 0x7f
0x00007ff70b13a446	_ZN12VM_Operation8evaluateEv + 0x46
0x00007ff70b1386f5	_ZN8VMThread18evaluate_operationEP12VM_Operation + 0xe5
0x00007ff70b138fce	_ZN8VMThread4loopEv + 0x3be
0x00007ff70b139428	_ZN8VMThread3runEv + 0xb8
0x00007ff70af6ae62	_ZL10java_startP6Thread + 0x102
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It does not seem blocked though from the stack trace. If the problem is reproducible, does it also occur if you change G1 to parallel GC via replacing &lt;tt&gt;-XX:+UseG1GC&lt;/tt&gt; with &lt;tt&gt;-XX:+UseParallelGC&lt;/tt&gt;?&lt;/p&gt;</comment>
                            <comment id="17167057" author="stephanewen" created="Wed, 29 Jul 2020 08:37:33 +0000"  >&lt;p&gt;This looks consistent with Till&apos;s analysis of GC-related deadlocks. If that is the case, then calling &lt;tt&gt;Runtime.halt()&lt;/tt&gt; has a lot lower risk of running into that JVM bug, but not zero risk.&lt;/p&gt;

&lt;p&gt;I any case, we can try to make the exit behavior configurable:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;default is exit() with delayed halt()&lt;/li&gt;
	&lt;li&gt;users can configure that halt() is called directly&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A bit tricky is that we somehow need to push this configuration option through to many places, like when the UncaughtExceptionHandlers for service threads are created.&lt;/p&gt;</comment>
                            <comment id="17167063" author="till.rohrmann" created="Wed, 29 Jul 2020 08:43:41 +0000"  >&lt;p&gt;The stack trace is indeed interesting. I cannot see any activity from the JVM to shut itself down. Did the logs contain some informative logging statements?&lt;/p&gt;</comment>
                            <comment id="17167172" author="mxm" created="Wed, 29 Jul 2020 12:03:52 +0000"  >&lt;blockquote&gt;
&lt;p&gt;does it also occur if you change G1 to parallel GC via replacing -XX:+UseG1GC with -XX:+UseParallelGC?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trohrmann&quot; class=&quot;user-hover&quot; rel=&quot;trohrmann&quot;&gt;trohrmann&lt;/a&gt; I&apos;ll check!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Did the logs contain some informative logging statements?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trohrmann&quot; class=&quot;user-hover&quot; rel=&quot;trohrmann&quot;&gt;trohrmann&lt;/a&gt; Frankly, I haven&apos;t been able yet to reproduce the freeze when I have the safepoint JVM arguments set you suggested. It could be a Heisenberg effect because the args effect the runtime behavior.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I any case, we can try to make the exit behavior configurable:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;default is exit() with delayed halt()&lt;/li&gt;
	&lt;li&gt;users can configure that halt() is called directly&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A bit tricky is that we somehow need to push this configuration option through to many places, like when the UncaughtExceptionHandlers for service threads are created.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; That&apos;s exactly what I had in mind. I&apos;ll try to see whether we can do this in the least obtrusive way. If I&apos;m not mistaken &lt;tt&gt;GlobalConfiguration&lt;/tt&gt; is generally accessible everywhere. If we go that route, we would just have to ensure that we only load the configuration value once to construct the exception handler.&lt;/p&gt;</comment>
                            <comment id="17167179" author="till.rohrmann" created="Wed, 29 Jul 2020 12:19:47 +0000"  >&lt;p&gt;I think &lt;tt&gt;GlobalConfiguration&lt;/tt&gt; is more of utility class to load a &lt;tt&gt;Configuration&lt;/tt&gt;. It is not recommended to do this at arbitrary places because one might miss overridden configuration values which have been passed in as dynamic properties, for example.&lt;/p&gt;

&lt;p&gt;Maybe we could leverage &lt;tt&gt;Thread.setDefaultUncaughtExceptionHandler&lt;/tt&gt; for this purpose. We only have to make sure that we clear all the explicitly configured &lt;tt&gt;UncaughtExceptionHandlers&lt;/tt&gt; which are not configurable wrt their exit behaviour.&lt;/p&gt;</comment>
                            <comment id="17167743" author="mxm" created="Thu, 30 Jul 2020 08:22:08 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trohrmann&quot; class=&quot;user-hover&quot; rel=&quot;trohrmann&quot;&gt;trohrmann&lt;/a&gt; I think it is safe to say that the problem is not reproducible with G1 being disabled. I&apos;ve run the test for more than 20 hours. Usually the problem would occurs within 30 minutes, or even faster with more memory pressure.&lt;/p&gt;

&lt;p&gt;Global state can be dangerous if it is mutable (which the config shouldn&apos;t be). I wasn&apos;t aware of properties which modify the config but since those are also global I don&apos;t see a reason why we wouldn&apos;t be able to resolve them in GlobalConfiguration. &lt;/p&gt;

&lt;p&gt;Preferably, we should resolve the config only once per task manager and initialize the exception handler at the same place, or pass through the config value. I&apos;ll have a look.&lt;/p&gt;</comment>
                            <comment id="17168099" author="mxm" created="Thu, 30 Jul 2020 17:34:45 +0000"  >&lt;p&gt;I ran another test with the existing &lt;tt&gt;taskmanager.jvm-exit-on-oom&lt;/tt&gt; option enabled which does a halt in the task thread on OOM errors. So far it looks like the pods get killed as expected. Apparently, the odds are low that the OOM errors occurs outside the Task thread. Still, it is possible that we get the error elsewhere in the TaskManager. I wonder whether we should deprecate this option in favor of a more general &lt;tt&gt;taskmanager.jvm-exit-on-fatal-error&lt;/tt&gt; which would include OOM errors? The alternative would be to add it as an additional option.&lt;/p&gt;</comment>
                            <comment id="17168487" author="till.rohrmann" created="Fri, 31 Jul 2020 07:20:10 +0000"  >&lt;p&gt;I think the current contract is that we terminate the Flink process when encountering a fatal error. &lt;tt&gt;taskmanager.jvm-exit-on-oom&lt;/tt&gt; basically says whether an OOM originating from the user code should be considered a fatal error or not. Hence, I am not entirely sure what the meaning of &lt;tt&gt;taskmanager.jvm-exit-on-fatal-error&lt;/tt&gt; would be.&lt;/p&gt;

&lt;p&gt;What I would suggest is to make the exit behaviour configurable. One could introduce &lt;tt&gt;cluster.clean-up-on-fatal-error&lt;/tt&gt;/&lt;tt&gt;cluster.fatal-error-behaviour&lt;/tt&gt;/&lt;tt&gt;cluster.halt-jvm-on-fatal-exit&lt;/tt&gt; to make the behaviour controllable.&lt;/p&gt;</comment>
                            <comment id="17168547" author="mxm" created="Fri, 31 Jul 2020 09:11:18 +0000"  >&lt;p&gt;It might be helpful to define &quot;fatal error&quot;. An OOM error can be a fatal error because we are not guaranteed to be able to recover from it. We currently do not treat OOM errors as fatal, except when it&apos;s thrown from the Task thread when &lt;tt&gt;taskmanager.jvm-exit-on-oom&lt;/tt&gt; is set to true. In this case we do not stick to the regular &lt;tt&gt;System.exit()&lt;/tt&gt; routine but we issue a &lt;tt&gt;Runtime.halt()&lt;/tt&gt;. In the recent tests I ran, this behavior prevented the problem reported here. I guess the configuration option has value on its own and we should not touch it for now.&lt;/p&gt;

&lt;p&gt;I&apos;ll proceed with the solution discussed here, i.e. adding an option to configure forceful exists instead of the default graceful exit.&lt;/p&gt;</comment>
                            <comment id="17173050" author="till.rohrmann" created="Fri, 7 Aug 2020 10:30:36 +0000"  >&lt;p&gt;Fixed via&lt;/p&gt;

&lt;p&gt;master: 182be5145b5b45cfedc65abca5dfe723651aa38e&lt;br/&gt;
1.11.2: 6782254aadad50d2879a626eb39efeafc93fae13&lt;br/&gt;
1.10.2: 8c134867dfab5c330da9458c3db9a54ed324ccab&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13301908">FLINK-17470</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13291304">FLINK-16573</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13203039">FLINK-11103</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13290632">FLINK-16511</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="13008622" name="command.txt" size="977" author="mxm" created="Tue, 28 Jul 2020 19:58:28 +0000"/>
                            <attachment id="13008296" name="stack2-1.txt" size="341819" author="mxm" created="Thu, 23 Jul 2020 17:31:10 +0000"/>
                            <attachment id="13008620" name="stack3-mixed.txt" size="33866" author="mxm" created="Tue, 28 Jul 2020 19:57:24 +0000"/>
                            <attachment id="13008621" name="stack3.txt" size="624822" author="mxm" created="Tue, 28 Jul 2020 19:58:03 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 14 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z0ccew:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>