<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:27:16 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-5937] Add documentation about the task lifecycle.</title>
                <link>https://issues.apache.org/jira/browse/FLINK-5937</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description></description>
                <environment></environment>
        <key id="13046995">FLINK-5937</key>
            <summary>Add documentation about the task lifecycle.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kkl0u">Kostas Kloudas</assignee>
                                    <reporter username="kkl0u">Kostas Kloudas</reporter>
                        <labels>
                    </labels>
                <created>Tue, 28 Feb 2017 15:15:57 +0000</created>
                <updated>Fri, 3 Mar 2017 12:44:05 +0000</updated>
                            <resolved>Fri, 3 Mar 2017 12:44:05 +0000</resolved>
                                    <version>1.3.0</version>
                                    <fixVersion>1.3.0</fixVersion>
                                    <component>Documentation</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="15888247" author="githubbot" created="Tue, 28 Feb 2017 15:36:13 +0000"  >&lt;p&gt;GitHub user kl0u opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5937&quot; title=&quot;Add documentation about the task lifecycle.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5937&quot;&gt;&lt;del&gt;FLINK-5937&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;doc&amp;#93;&lt;/span&gt; Add documentation about the stream task lifecycle&lt;/p&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/kl0u/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/kl0u/flink&lt;/a&gt; task-doc&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #3429&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 34673d63af17a414d47a842720fbab3ff4b753d0&lt;br/&gt;
Author: kl0u &amp;lt;kkloudas@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-02-28T14:41:37Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5937&quot; title=&quot;Add documentation about the task lifecycle.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5937&quot;&gt;&lt;del&gt;FLINK-5937&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;doc&amp;#93;&lt;/span&gt; Add documentation about the stream task lifecycle&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15888302" author="githubbot" created="Tue, 28 Feb 2017 16:01:38 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103482237&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103482237&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    +opening the user-defined function in the case of the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process fresh incoming data. This is done by invoking the `processElement()` and `processWatermark()` methods which&lt;br/&gt;
    +contain the logic for processing elements and watermark respectively.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is reached), the `close()` method is called to &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &quot;in case of &lt;b&gt;a&lt;/b&gt; normal, ...&quot;&lt;/p&gt;</comment>
                            <comment id="15888303" author="githubbot" created="Tue, 28 Feb 2017 16:01:38 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103482158&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103482158&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    +opening the user-defined function in the case of the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process fresh incoming data. This is done by invoking the `processElement()` and `processWatermark()` methods which&lt;br/&gt;
    +contain the logic for processing elements and watermark respectively.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    insert comma before &quot;respectively&quot;&lt;/p&gt;</comment>
                            <comment id="15888304" author="githubbot" created="Tue, 28 Feb 2017 16:01:38 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103483914&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103483914&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    +opening the user-defined function in the case of the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process fresh incoming data. This is done by invoking the `processElement()` and `processWatermark()` methods which&lt;br/&gt;
    +contain the logic for processing elements and watermark respectively.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is reached), the `close()` method is called to &lt;br/&gt;
    +perform any final bookkeeping action required by the operator&apos;s logic, and the `dispose()` is called after that to free any resources held by the operator. &lt;br/&gt;
    +&lt;br/&gt;
    +In the case of termination due to a failure or due to manual cancellation, the execution jumps directly to the `dispose()`, and skips any intermediate phases between&lt;br/&gt;
    +the phase the operator was in when the failure happened and the `dispose` one.&lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Checkpoints:&lt;/b&gt;* The `snapshotState()` method of the operator is called asynchronously to the rest of the methods described above, whenever a checkpoint barrier is received. &lt;br/&gt;
    +Its responsibility is to store the current state of the operator to the specified &lt;span class=&quot;error&quot;&gt;&amp;#91;state backend&amp;#93;&lt;/span&gt;({{ site.baseurl }}/ops/state_backends.html) from where it is going to be &lt;br/&gt;
    +retrieved when the job resumes execution after a failure. For a bried description of Flink&apos;s checkpointing mechanism please keep on reading, and for a more detailed discussion &lt;br/&gt;
    +on the principles around checkpointing in Flink please read the corresponding documentation: &lt;span class=&quot;error&quot;&gt;&amp;#91;Data Streaming Fault Tolerance&amp;#93;&lt;/span&gt;({{ site.baseurl }}/internals/stream_checkpointing.html).&lt;br/&gt;
    +&lt;br/&gt;
    +## Task Lifecycle&lt;br/&gt;
    +&lt;br/&gt;
    +Given the above brief introduction on the operator&apos;s main phases, this section describes in more detail how a task calls them during its execution on a cluster. The sequence &lt;br/&gt;
    +of the phases described here is mainly included in the `invoke()` method of the `StreamTask`. The remainder of this document is split into two subsections, one describing the &lt;br/&gt;
    +phases during a regular, fault-free execution of a task (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Normal Execution&amp;#93;&lt;/span&gt;(#normal-execution)), and (a shorter) one describing the different sequence followed in case &lt;br/&gt;
    +the task is cancelled (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Interrupted Execution&amp;#93;&lt;/span&gt;(#interrupted-execution)), &lt;br/&gt;
    +either manually, or due some other reason, &lt;b&gt;e.g.&lt;/b&gt; an exception thrown during execution.&lt;br/&gt;
    +&lt;br/&gt;
    +### Normal Execution&lt;br/&gt;
    +&lt;br/&gt;
    +The steps a task goes through when executed until completion without being interrupted are illustrated below:&lt;br/&gt;
    +&lt;br/&gt;
    +	setInitialState()&lt;br/&gt;
    +	invoke()&lt;br/&gt;
    +		Create basic utils (config, etc) and load the chain of operators&lt;br/&gt;
    +		setup-operators()&lt;br/&gt;
    + 		task specific init()&lt;br/&gt;
    + 		initialize-operator-states()&lt;br/&gt;
    + 		open-operators()&lt;br/&gt;
    + 		run()&lt;br/&gt;
    + 		close-operators()&lt;br/&gt;
    + 		dispose-operators()&lt;br/&gt;
    + 		task specific cleanup()&lt;br/&gt;
    + 		common cleanup&lt;br/&gt;
    +&lt;br/&gt;
    +As shown above, after recovering the task configuration and initializing some important runtime parameters, the very first step for the task is to retrieve its initial, &lt;br/&gt;
    +task-wide state. This is done in the `setInitialState()`, and it is particularly important in two cases:&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    IMO, this should be briefly mentioned before&lt;/p&gt;</comment>
                            <comment id="15888305" author="githubbot" created="Tue, 28 Feb 2017 16:01:38 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103481746&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103481746&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Runtim*&lt;b&gt;E&lt;/b&gt;*Context&lt;/p&gt;</comment>
                            <comment id="15888306" author="githubbot" created="Tue, 28 Feb 2017 16:01:38 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103483353&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103483353&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    +opening the user-defined function in the case of the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process fresh incoming data. This is done by invoking the `processElement()` and `processWatermark()` methods which&lt;br/&gt;
    +contain the logic for processing elements and watermark respectively.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is reached), the `close()` method is called to &lt;br/&gt;
    +perform any final bookkeeping action required by the operator&apos;s logic, and the `dispose()` is called after that to free any resources held by the operator. &lt;br/&gt;
    +&lt;br/&gt;
    +In the case of termination due to a failure or due to manual cancellation, the execution jumps directly to the `dispose()`, and skips any intermediate phases between&lt;br/&gt;
    +the phase the operator was in when the failure happened and the `dispose` one.&lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Checkpoints:&lt;/b&gt;* The `snapshotState()` method of the operator is called asynchronously to the rest of the methods described above, whenever a checkpoint barrier is received. &lt;br/&gt;
    +Its responsibility is to store the current state of the operator to the specified &lt;span class=&quot;error&quot;&gt;&amp;#91;state backend&amp;#93;&lt;/span&gt;({{ site.baseurl }}/ops/state_backends.html) from where it is going to be &lt;br/&gt;
    +retrieved when the job resumes execution after a failure. For a bried description of Flink&apos;s checkpointing mechanism please keep on reading, and for a more detailed discussion &lt;br/&gt;
    +on the principles around checkpointing in Flink please read the corresponding documentation: &lt;span class=&quot;error&quot;&gt;&amp;#91;Data Streaming Fault Tolerance&amp;#93;&lt;/span&gt;({{ site.baseurl }}/internals/stream_checkpointing.html).&lt;br/&gt;
    +&lt;br/&gt;
    +## Task Lifecycle&lt;br/&gt;
    +&lt;br/&gt;
    +Given the above brief introduction on the operator&apos;s main phases, this section describes in more detail how a task calls them during its execution on a cluster. The sequence &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &quot;calls them&quot; -&amp;gt; &quot;calls the respective methods&quot;&lt;/p&gt;</comment>
                            <comment id="15888307" author="githubbot" created="Tue, 28 Feb 2017 16:01:38 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103481621&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103481621&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Does initialization also include restoring previous state?&lt;/p&gt;</comment>
                            <comment id="15888308" author="githubbot" created="Tue, 28 Feb 2017 16:01:39 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103482954&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103482954&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    +opening the user-defined function in the case of the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process fresh incoming data. This is done by invoking the `processElement()` and `processWatermark()` methods which&lt;br/&gt;
    +contain the logic for processing elements and watermark respectively.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is reached), the `close()` method is called to &lt;br/&gt;
    +perform any final bookkeeping action required by the operator&apos;s logic, and the `dispose()` is called after that to free any resources held by the operator. &lt;br/&gt;
    +&lt;br/&gt;
    +In the case of termination due to a failure or due to manual cancellation, the execution jumps directly to the `dispose()`, and skips any intermediate phases between&lt;br/&gt;
    +the phase the operator was in when the failure happened and the `dispose` one.&lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Checkpoints:&lt;/b&gt;* The `snapshotState()` method of the operator is called asynchronously to the rest of the methods described above, whenever a checkpoint barrier is received. &lt;br/&gt;
    +Its responsibility is to store the current state of the operator to the specified &lt;span class=&quot;error&quot;&gt;&amp;#91;state backend&amp;#93;&lt;/span&gt;({{ site.baseurl }}/ops/state_backends.html) from where it is going to be &lt;br/&gt;
    +retrieved when the job resumes execution after a failure. For a bried description of Flink&apos;s checkpointing mechanism please keep on reading, and for a more detailed discussion &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &quot;bried&quot; -&amp;gt; &quot;brief&quot;&lt;/p&gt;</comment>
                            <comment id="15888309" author="githubbot" created="Tue, 28 Feb 2017 16:01:39 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103486170&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103486170&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    +opening the user-defined function in the case of the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process fresh incoming data. This is done by invoking the `processElement()` and `processWatermark()` methods which&lt;br/&gt;
    +contain the logic for processing elements and watermark respectively.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is reached), the `close()` method is called to &lt;br/&gt;
    +perform any final bookkeeping action required by the operator&apos;s logic, and the `dispose()` is called after that to free any resources held by the operator. &lt;br/&gt;
    +&lt;br/&gt;
    +In the case of termination due to a failure or due to manual cancellation, the execution jumps directly to the `dispose()`, and skips any intermediate phases between&lt;br/&gt;
    +the phase the operator was in when the failure happened and the `dispose` one.&lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Checkpoints:&lt;/b&gt;* The `snapshotState()` method of the operator is called asynchronously to the rest of the methods described above, whenever a checkpoint barrier is received. &lt;br/&gt;
    +Its responsibility is to store the current state of the operator to the specified &lt;span class=&quot;error&quot;&gt;&amp;#91;state backend&amp;#93;&lt;/span&gt;({{ site.baseurl }}/ops/state_backends.html) from where it is going to be &lt;br/&gt;
    +retrieved when the job resumes execution after a failure. For a bried description of Flink&apos;s checkpointing mechanism please keep on reading, and for a more detailed discussion &lt;br/&gt;
    +on the principles around checkpointing in Flink please read the corresponding documentation: &lt;span class=&quot;error&quot;&gt;&amp;#91;Data Streaming Fault Tolerance&amp;#93;&lt;/span&gt;({{ site.baseurl }}/internals/stream_checkpointing.html).&lt;br/&gt;
    +&lt;br/&gt;
    +## Task Lifecycle&lt;br/&gt;
    +&lt;br/&gt;
    +Given the above brief introduction on the operator&apos;s main phases, this section describes in more detail how a task calls them during its execution on a cluster. The sequence &lt;br/&gt;
    +of the phases described here is mainly included in the `invoke()` method of the `StreamTask`. The remainder of this document is split into two subsections, one describing the &lt;br/&gt;
    +phases during a regular, fault-free execution of a task (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Normal Execution&amp;#93;&lt;/span&gt;(#normal-execution)), and (a shorter) one describing the different sequence followed in case &lt;br/&gt;
    +the task is cancelled (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Interrupted Execution&amp;#93;&lt;/span&gt;(#interrupted-execution)), &lt;br/&gt;
    +either manually, or due some other reason, &lt;b&gt;e.g.&lt;/b&gt; an exception thrown during execution.&lt;br/&gt;
    +&lt;br/&gt;
    +### Normal Execution&lt;br/&gt;
    +&lt;br/&gt;
    +The steps a task goes through when executed until completion without being interrupted are illustrated below:&lt;br/&gt;
    +&lt;br/&gt;
    +	setInitialState()&lt;br/&gt;
    +	invoke()&lt;br/&gt;
    +		Create basic utils (config, etc) and load the chain of operators&lt;br/&gt;
    +		setup-operators()&lt;br/&gt;
    + 		task specific init()&lt;br/&gt;
    + 		initialize-operator-states()&lt;br/&gt;
    + 		open-operators()&lt;br/&gt;
    + 		run()&lt;br/&gt;
    + 		close-operators()&lt;br/&gt;
    + 		dispose-operators()&lt;br/&gt;
    + 		task specific cleanup()&lt;br/&gt;
    + 		common cleanup&lt;br/&gt;
    +&lt;br/&gt;
    +As shown above, after recovering the task configuration and initializing some important runtime parameters, the very first step for the task is to retrieve its initial, &lt;br/&gt;
    +task-wide state. This is done in the `setInitialState()`, and it is particularly important in two cases:&lt;br/&gt;
    +&lt;br/&gt;
    +1. when the task is recovering from a failure and restarts from the last successful checkpoint, and&lt;br/&gt;
    +2. when resuming from a &lt;span class=&quot;error&quot;&gt;&amp;#91;savepoint&amp;#93;&lt;/span&gt;({{ site.baseurl }}/setup/savepoints.html). &lt;br/&gt;
    +&lt;br/&gt;
    +If it is the first time the task is executed, the initial task state is empty. &lt;br/&gt;
    +&lt;br/&gt;
    +After recovering any initial state, the task goes into its `invoke()` method. There, it first initializes the operators involved in the local computation by calling &lt;br/&gt;
    +the `setup()` method of each one of them and then performs its task-specific initialization by calling the local `init()` method. By task-specific, we mean that &lt;br/&gt;
    +depending on the type of the task (`SourceTask`, `OneInputStreamTask` or `TwoInputStreamTask`, etc), this step may differ, but in any case, here is where the necessary &lt;br/&gt;
    +task-wide resources are acquired. As an example, the `OneInputStreamTask` which represents a task that expects to have a single input stream, initializes the connection(s) &lt;br/&gt;
    +to the location(s) of the different partitions of the input stream that are relevant to the local task.&lt;br/&gt;
    +&lt;br/&gt;
    +Having acquired the necessary resources, it is time for the different operators and user-defined functions to acquire their individual state from the task-wide state &lt;br/&gt;
    +retrieved above. This is done in the `initializeState()` method, which calls the `initializeState()` of each individual operator. This method should be overriden by &lt;br/&gt;
    +every stateful operator and should contain the state initialization logic, both for the first time a job is executed, but also for the case when the task recovers from &lt;br/&gt;
    +a failure or using a savepoint.&lt;br/&gt;
    +&lt;br/&gt;
    +Now that all operators in the task have been initialized, the `open()` method of each individual operator is called by the `openAllOperators()` method of the `StreamTask`. &lt;br/&gt;
    +This is the place that implements all the operational initialization, such as register any retrieved timers with the timer service. A single task may be executing multiple &lt;br/&gt;
    +operators with one consuming the output of its predecessor. In this case, the `open()` method is called from the last operator, &lt;b&gt;i.e.&lt;/b&gt; the one whose output is also the output &lt;br/&gt;
    +of the task itself, to the first. This is done so that when the first operator starts processing the task&apos;s input, all downstream operators are ready to receive its output.&lt;br/&gt;
    +&lt;br/&gt;
    +Now the task can resume execution, and operators can start processing fresh input data. This is the place where the task-specific `run()` mehtod is called. This method will &lt;br/&gt;
    +run until either there is no more input data (finite stream), or the task is cancelled (manually or not). Here is where the operator specific `processElement()` and &lt;br/&gt;
    +`processWatermark()` methods are called.&lt;br/&gt;
    +&lt;br/&gt;
    +In the case of running till completion, &lt;b&gt;i.e.&lt;/b&gt; there is no more input data to process, after exiting from the `run()` method, the task enters its shutdown process. &lt;br/&gt;
    +Initially, the timer service stops registering any new timers (e.g. from fired timers that are being executed), clears all the not yet started timers, and awaits the &lt;br/&gt;
    +completion of currently executing ones. Then the `closeAllOperators()` tries to gracefully close the operators involved in the computation by calling the `close()` method &lt;br/&gt;
    +of each one of them. Then any buffered output data is flushed so that they can be processed by the downstream tasks, and finally the task tries to clear all the resources &lt;br/&gt;
    +held by the operators by calling the `dispose()` method of each one of them. When opening the different operators, we mentioned that the order is from the last to the first. &lt;br/&gt;
    +Closing happens the other way round, from first to last.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, when all operators have been closed and all their resources freed, the task shuts down its timer service, performs its task-specific cleanup, &lt;b&gt;e.g.&lt;/b&gt; clean all its &lt;br/&gt;
    +internal buffers, and then performs its generic task clean up which consists of closing all its output channels and cleaning any output buffers.&lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Checkpoints:&lt;/b&gt;* Previously we saw that during `initializeState()`, and in case of recovering from a failure, the task and all its operators and functions retrieve the &lt;br/&gt;
    +state that was persisted to stable storage during the last successful checkpoint before the failure. Checkpoints in Flink are performed periodically based on a user-specified &lt;br/&gt;
    +interval, and are performed by a different thread than that of the main task thread. This is the reason the are not included in the main phases of the task lifecycle. In a &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &quot;This is the reason the are not&quot; -&amp;gt; &quot;That&apos;s why they are not&quot;&lt;/p&gt;</comment>
                            <comment id="15888310" author="githubbot" created="Tue, 28 Feb 2017 16:01:39 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103485368&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103485368&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    +opening the user-defined function in the case of the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process fresh incoming data. This is done by invoking the `processElement()` and `processWatermark()` methods which&lt;br/&gt;
    +contain the logic for processing elements and watermark respectively.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is reached), the `close()` method is called to &lt;br/&gt;
    +perform any final bookkeeping action required by the operator&apos;s logic, and the `dispose()` is called after that to free any resources held by the operator. &lt;br/&gt;
    +&lt;br/&gt;
    +In the case of termination due to a failure or due to manual cancellation, the execution jumps directly to the `dispose()`, and skips any intermediate phases between&lt;br/&gt;
    +the phase the operator was in when the failure happened and the `dispose` one.&lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Checkpoints:&lt;/b&gt;* The `snapshotState()` method of the operator is called asynchronously to the rest of the methods described above, whenever a checkpoint barrier is received. &lt;br/&gt;
    +Its responsibility is to store the current state of the operator to the specified &lt;span class=&quot;error&quot;&gt;&amp;#91;state backend&amp;#93;&lt;/span&gt;({{ site.baseurl }}/ops/state_backends.html) from where it is going to be &lt;br/&gt;
    +retrieved when the job resumes execution after a failure. For a bried description of Flink&apos;s checkpointing mechanism please keep on reading, and for a more detailed discussion &lt;br/&gt;
    +on the principles around checkpointing in Flink please read the corresponding documentation: &lt;span class=&quot;error&quot;&gt;&amp;#91;Data Streaming Fault Tolerance&amp;#93;&lt;/span&gt;({{ site.baseurl }}/internals/stream_checkpointing.html).&lt;br/&gt;
    +&lt;br/&gt;
    +## Task Lifecycle&lt;br/&gt;
    +&lt;br/&gt;
    +Given the above brief introduction on the operator&apos;s main phases, this section describes in more detail how a task calls them during its execution on a cluster. The sequence &lt;br/&gt;
    +of the phases described here is mainly included in the `invoke()` method of the `StreamTask`. The remainder of this document is split into two subsections, one describing the &lt;br/&gt;
    +phases during a regular, fault-free execution of a task (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Normal Execution&amp;#93;&lt;/span&gt;(#normal-execution)), and (a shorter) one describing the different sequence followed in case &lt;br/&gt;
    +the task is cancelled (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Interrupted Execution&amp;#93;&lt;/span&gt;(#interrupted-execution)), &lt;br/&gt;
    +either manually, or due some other reason, &lt;b&gt;e.g.&lt;/b&gt; an exception thrown during execution.&lt;br/&gt;
    +&lt;br/&gt;
    +### Normal Execution&lt;br/&gt;
    +&lt;br/&gt;
    +The steps a task goes through when executed until completion without being interrupted are illustrated below:&lt;br/&gt;
    +&lt;br/&gt;
    +	setInitialState()&lt;br/&gt;
    +	invoke()&lt;br/&gt;
    +		Create basic utils (config, etc) and load the chain of operators&lt;br/&gt;
    +		setup-operators()&lt;br/&gt;
    + 		task specific init()&lt;br/&gt;
    + 		initialize-operator-states()&lt;br/&gt;
    + 		open-operators()&lt;br/&gt;
    + 		run()&lt;br/&gt;
    + 		close-operators()&lt;br/&gt;
    + 		dispose-operators()&lt;br/&gt;
    + 		task specific cleanup()&lt;br/&gt;
    + 		common cleanup&lt;br/&gt;
    +&lt;br/&gt;
    +As shown above, after recovering the task configuration and initializing some important runtime parameters, the very first step for the task is to retrieve its initial, &lt;br/&gt;
    +task-wide state. This is done in the `setInitialState()`, and it is particularly important in two cases:&lt;br/&gt;
    +&lt;br/&gt;
    +1. when the task is recovering from a failure and restarts from the last successful checkpoint, and&lt;br/&gt;
    +2. when resuming from a &lt;span class=&quot;error&quot;&gt;&amp;#91;savepoint&amp;#93;&lt;/span&gt;({{ site.baseurl }}/setup/savepoints.html). &lt;br/&gt;
    +&lt;br/&gt;
    +If it is the first time the task is executed, the initial task state is empty. &lt;br/&gt;
    +&lt;br/&gt;
    +After recovering any initial state, the task goes into its `invoke()` method. There, it first initializes the operators involved in the local computation by calling &lt;br/&gt;
    +the `setup()` method of each one of them and then performs its task-specific initialization by calling the local `init()` method. By task-specific, we mean that &lt;br/&gt;
    +depending on the type of the task (`SourceTask`, `OneInputStreamTask` or `TwoInputStreamTask`, etc), this step may differ, but in any case, here is where the necessary &lt;br/&gt;
    +task-wide resources are acquired. As an example, the `OneInputStreamTask` which represents a task that expects to have a single input stream, initializes the connection(s) &lt;br/&gt;
    +to the location(s) of the different partitions of the input stream that are relevant to the local task.&lt;br/&gt;
    +&lt;br/&gt;
    +Having acquired the necessary resources, it is time for the different operators and user-defined functions to acquire their individual state from the task-wide state &lt;br/&gt;
    +retrieved above. This is done in the `initializeState()` method, which calls the `initializeState()` of each individual operator. This method should be overriden by &lt;br/&gt;
    +every stateful operator and should contain the state initialization logic, both for the first time a job is executed, but also for the case when the task recovers from &lt;br/&gt;
    +a failure or using a savepoint.&lt;br/&gt;
    +&lt;br/&gt;
    +Now that all operators in the task have been initialized, the `open()` method of each individual operator is called by the `openAllOperators()` method of the `StreamTask`. &lt;br/&gt;
    +This is the place that implements all the operational initialization, such as register any retrieved timers with the timer service. A single task may be executing multiple &lt;br/&gt;
    +operators with one consuming the output of its predecessor. In this case, the `open()` method is called from the last operator, &lt;b&gt;i.e.&lt;/b&gt; the one whose output is also the output &lt;br/&gt;
    +of the task itself, to the first. This is done so that when the first operator starts processing the task&apos;s input, all downstream operators are ready to receive its output.&lt;br/&gt;
    +&lt;br/&gt;
    +Now the task can resume execution, and operators can start processing fresh input data. This is the place where the task-specific `run()` mehtod is called. This method will &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &quot;mehtod&quot; -&amp;gt; &quot;method&quot;&lt;/p&gt;</comment>
                            <comment id="15888311" author="githubbot" created="Tue, 28 Feb 2017 16:01:39 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103481296&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103481296&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    What about `snapshotState()`?&lt;/p&gt;</comment>
                            <comment id="15888312" author="githubbot" created="Tue, 28 Feb 2017 16:01:39 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103482579&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103482579&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    +opening the user-defined function in the case of the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process fresh incoming data. This is done by invoking the `processElement()` and `processWatermark()` methods which&lt;br/&gt;
    +contain the logic for processing elements and watermark respectively.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is reached), the `close()` method is called to &lt;br/&gt;
    +perform any final bookkeeping action required by the operator&apos;s logic, and the `dispose()` is called after that to free any resources held by the operator. &lt;br/&gt;
    +&lt;br/&gt;
    +In the case of termination due to a failure or due to manual cancellation, the execution jumps directly to the `dispose()`, and skips any intermediate phases between&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &quot;In case of &lt;b&gt;a&lt;/b&gt; termination...&quot;?&lt;/p&gt;</comment>
                            <comment id="15888313" author="githubbot" created="Tue, 28 Feb 2017 16:01:39 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103484503&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103484503&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    +opening the user-defined function in the case of the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process fresh incoming data. This is done by invoking the `processElement()` and `processWatermark()` methods which&lt;br/&gt;
    +contain the logic for processing elements and watermark respectively.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is reached), the `close()` method is called to &lt;br/&gt;
    +perform any final bookkeeping action required by the operator&apos;s logic, and the `dispose()` is called after that to free any resources held by the operator. &lt;br/&gt;
    +&lt;br/&gt;
    +In the case of termination due to a failure or due to manual cancellation, the execution jumps directly to the `dispose()`, and skips any intermediate phases between&lt;br/&gt;
    +the phase the operator was in when the failure happened and the `dispose` one.&lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Checkpoints:&lt;/b&gt;* The `snapshotState()` method of the operator is called asynchronously to the rest of the methods described above, whenever a checkpoint barrier is received. &lt;br/&gt;
    +Its responsibility is to store the current state of the operator to the specified &lt;span class=&quot;error&quot;&gt;&amp;#91;state backend&amp;#93;&lt;/span&gt;({{ site.baseurl }}/ops/state_backends.html) from where it is going to be &lt;br/&gt;
    +retrieved when the job resumes execution after a failure. For a bried description of Flink&apos;s checkpointing mechanism please keep on reading, and for a more detailed discussion &lt;br/&gt;
    +on the principles around checkpointing in Flink please read the corresponding documentation: &lt;span class=&quot;error&quot;&gt;&amp;#91;Data Streaming Fault Tolerance&amp;#93;&lt;/span&gt;({{ site.baseurl }}/internals/stream_checkpointing.html).&lt;br/&gt;
    +&lt;br/&gt;
    +## Task Lifecycle&lt;br/&gt;
    +&lt;br/&gt;
    +Given the above brief introduction on the operator&apos;s main phases, this section describes in more detail how a task calls them during its execution on a cluster. The sequence &lt;br/&gt;
    +of the phases described here is mainly included in the `invoke()` method of the `StreamTask`. The remainder of this document is split into two subsections, one describing the &lt;br/&gt;
    +phases during a regular, fault-free execution of a task (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Normal Execution&amp;#93;&lt;/span&gt;(#normal-execution)), and (a shorter) one describing the different sequence followed in case &lt;br/&gt;
    +the task is cancelled (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Interrupted Execution&amp;#93;&lt;/span&gt;(#interrupted-execution)), &lt;br/&gt;
    +either manually, or due some other reason, &lt;b&gt;e.g.&lt;/b&gt; an exception thrown during execution.&lt;br/&gt;
    +&lt;br/&gt;
    +### Normal Execution&lt;br/&gt;
    +&lt;br/&gt;
    +The steps a task goes through when executed until completion without being interrupted are illustrated below:&lt;br/&gt;
    +&lt;br/&gt;
    +	setInitialState()&lt;br/&gt;
    +	invoke()&lt;br/&gt;
    +		Create basic utils (config, etc) and load the chain of operators&lt;br/&gt;
    +		setup-operators()&lt;br/&gt;
    + 		task specific init()&lt;br/&gt;
    + 		initialize-operator-states()&lt;br/&gt;
    + 		open-operators()&lt;br/&gt;
    + 		run()&lt;br/&gt;
    + 		close-operators()&lt;br/&gt;
    + 		dispose-operators()&lt;br/&gt;
    + 		task specific cleanup()&lt;br/&gt;
    + 		common cleanup&lt;br/&gt;
    +&lt;br/&gt;
    +As shown above, after recovering the task configuration and initializing some important runtime parameters, the very first step for the task is to retrieve its initial, &lt;br/&gt;
    +task-wide state. This is done in the `setInitialState()`, and it is particularly important in two cases:&lt;br/&gt;
    +&lt;br/&gt;
    +1. when the task is recovering from a failure and restarts from the last successful checkpoint, and&lt;br/&gt;
    +2. when resuming from a &lt;span class=&quot;error&quot;&gt;&amp;#91;savepoint&amp;#93;&lt;/span&gt;({{ site.baseurl }}/setup/savepoints.html). &lt;br/&gt;
    +&lt;br/&gt;
    +If it is the first time the task is executed, the initial task state is empty. &lt;br/&gt;
    +&lt;br/&gt;
    +After recovering any initial state, the task goes into its `invoke()` method. There, it first initializes the operators involved in the local computation by calling &lt;br/&gt;
    +the `setup()` method of each one of them and then performs its task-specific initialization by calling the local `init()` method. By task-specific, we mean that &lt;br/&gt;
    +depending on the type of the task (`SourceTask`, `OneInputStreamTask` or `TwoInputStreamTask`, etc), this step may differ, but in any case, here is where the necessary &lt;br/&gt;
    +task-wide resources are acquired. As an example, the `OneInputStreamTask` which represents a task that expects to have a single input stream, initializes the connection(s) &lt;br/&gt;
    +to the location(s) of the different partitions of the input stream that are relevant to the local task.&lt;br/&gt;
    +&lt;br/&gt;
    +Having acquired the necessary resources, it is time for the different operators and user-defined functions to acquire their individual state from the task-wide state &lt;br/&gt;
    +retrieved above. This is done in the `initializeState()` method, which calls the `initializeState()` of each individual operator. This method should be overriden by &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &quot;overriden&quot; -&amp;gt; &quot;overridden&quot;&lt;/p&gt;</comment>
                            <comment id="15888314" author="githubbot" created="Tue, 28 Feb 2017 16:01:39 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103486754&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103486754&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    +opening the user-defined function in the case of the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process fresh incoming data. This is done by invoking the `processElement()` and `processWatermark()` methods which&lt;br/&gt;
    +contain the logic for processing elements and watermark respectively.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is reached), the `close()` method is called to &lt;br/&gt;
    +perform any final bookkeeping action required by the operator&apos;s logic, and the `dispose()` is called after that to free any resources held by the operator. &lt;br/&gt;
    +&lt;br/&gt;
    +In the case of termination due to a failure or due to manual cancellation, the execution jumps directly to the `dispose()`, and skips any intermediate phases between&lt;br/&gt;
    +the phase the operator was in when the failure happened and the `dispose` one.&lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Checkpoints:&lt;/b&gt;* The `snapshotState()` method of the operator is called asynchronously to the rest of the methods described above, whenever a checkpoint barrier is received. &lt;br/&gt;
    +Its responsibility is to store the current state of the operator to the specified &lt;span class=&quot;error&quot;&gt;&amp;#91;state backend&amp;#93;&lt;/span&gt;({{ site.baseurl }}/ops/state_backends.html) from where it is going to be &lt;br/&gt;
    +retrieved when the job resumes execution after a failure. For a bried description of Flink&apos;s checkpointing mechanism please keep on reading, and for a more detailed discussion &lt;br/&gt;
    +on the principles around checkpointing in Flink please read the corresponding documentation: &lt;span class=&quot;error&quot;&gt;&amp;#91;Data Streaming Fault Tolerance&amp;#93;&lt;/span&gt;({{ site.baseurl }}/internals/stream_checkpointing.html).&lt;br/&gt;
    +&lt;br/&gt;
    +## Task Lifecycle&lt;br/&gt;
    +&lt;br/&gt;
    +Given the above brief introduction on the operator&apos;s main phases, this section describes in more detail how a task calls them during its execution on a cluster. The sequence &lt;br/&gt;
    +of the phases described here is mainly included in the `invoke()` method of the `StreamTask`. The remainder of this document is split into two subsections, one describing the &lt;br/&gt;
    +phases during a regular, fault-free execution of a task (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Normal Execution&amp;#93;&lt;/span&gt;(#normal-execution)), and (a shorter) one describing the different sequence followed in case &lt;br/&gt;
    +the task is cancelled (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Interrupted Execution&amp;#93;&lt;/span&gt;(#interrupted-execution)), &lt;br/&gt;
    +either manually, or due some other reason, &lt;b&gt;e.g.&lt;/b&gt; an exception thrown during execution.&lt;br/&gt;
    +&lt;br/&gt;
    +### Normal Execution&lt;br/&gt;
    +&lt;br/&gt;
    +The steps a task goes through when executed until completion without being interrupted are illustrated below:&lt;br/&gt;
    +&lt;br/&gt;
    +	setInitialState()&lt;br/&gt;
    +	invoke()&lt;br/&gt;
    +		Create basic utils (config, etc) and load the chain of operators&lt;br/&gt;
    +		setup-operators()&lt;br/&gt;
    + 		task specific init()&lt;br/&gt;
    + 		initialize-operator-states()&lt;br/&gt;
    + 		open-operators()&lt;br/&gt;
    + 		run()&lt;br/&gt;
    + 		close-operators()&lt;br/&gt;
    + 		dispose-operators()&lt;br/&gt;
    + 		task specific cleanup()&lt;br/&gt;
    + 		common cleanup&lt;br/&gt;
    +&lt;br/&gt;
    +As shown above, after recovering the task configuration and initializing some important runtime parameters, the very first step for the task is to retrieve its initial, &lt;br/&gt;
    +task-wide state. This is done in the `setInitialState()`, and it is particularly important in two cases:&lt;br/&gt;
    +&lt;br/&gt;
    +1. when the task is recovering from a failure and restarts from the last successful checkpoint, and&lt;br/&gt;
    +2. when resuming from a &lt;span class=&quot;error&quot;&gt;&amp;#91;savepoint&amp;#93;&lt;/span&gt;({{ site.baseurl }}/setup/savepoints.html). &lt;br/&gt;
    +&lt;br/&gt;
    +If it is the first time the task is executed, the initial task state is empty. &lt;br/&gt;
    +&lt;br/&gt;
    +After recovering any initial state, the task goes into its `invoke()` method. There, it first initializes the operators involved in the local computation by calling &lt;br/&gt;
    +the `setup()` method of each one of them and then performs its task-specific initialization by calling the local `init()` method. By task-specific, we mean that &lt;br/&gt;
    +depending on the type of the task (`SourceTask`, `OneInputStreamTask` or `TwoInputStreamTask`, etc), this step may differ, but in any case, here is where the necessary &lt;br/&gt;
    +task-wide resources are acquired. As an example, the `OneInputStreamTask` which represents a task that expects to have a single input stream, initializes the connection(s) &lt;br/&gt;
    +to the location(s) of the different partitions of the input stream that are relevant to the local task.&lt;br/&gt;
    +&lt;br/&gt;
    +Having acquired the necessary resources, it is time for the different operators and user-defined functions to acquire their individual state from the task-wide state &lt;br/&gt;
    +retrieved above. This is done in the `initializeState()` method, which calls the `initializeState()` of each individual operator. This method should be overriden by &lt;br/&gt;
    +every stateful operator and should contain the state initialization logic, both for the first time a job is executed, but also for the case when the task recovers from &lt;br/&gt;
    +a failure or using a savepoint.&lt;br/&gt;
    +&lt;br/&gt;
    +Now that all operators in the task have been initialized, the `open()` method of each individual operator is called by the `openAllOperators()` method of the `StreamTask`. &lt;br/&gt;
    +This is the place that implements all the operational initialization, such as register any retrieved timers with the timer service. A single task may be executing multiple &lt;br/&gt;
    +operators with one consuming the output of its predecessor. In this case, the `open()` method is called from the last operator, &lt;b&gt;i.e.&lt;/b&gt; the one whose output is also the output &lt;br/&gt;
    +of the task itself, to the first. This is done so that when the first operator starts processing the task&apos;s input, all downstream operators are ready to receive its output.&lt;br/&gt;
    +&lt;br/&gt;
    +Now the task can resume execution, and operators can start processing fresh input data. This is the place where the task-specific `run()` mehtod is called. This method will &lt;br/&gt;
    +run until either there is no more input data (finite stream), or the task is cancelled (manually or not). Here is where the operator specific `processElement()` and &lt;br/&gt;
    +`processWatermark()` methods are called.&lt;br/&gt;
    +&lt;br/&gt;
    +In the case of running till completion, &lt;b&gt;i.e.&lt;/b&gt; there is no more input data to process, after exiting from the `run()` method, the task enters its shutdown process. &lt;br/&gt;
    +Initially, the timer service stops registering any new timers (e.g. from fired timers that are being executed), clears all the not yet started timers, and awaits the &lt;br/&gt;
    +completion of currently executing ones. Then the `closeAllOperators()` tries to gracefully close the operators involved in the computation by calling the `close()` method &lt;br/&gt;
    +of each one of them. Then any buffered output data is flushed so that they can be processed by the downstream tasks, and finally the task tries to clear all the resources &lt;br/&gt;
    +held by the operators by calling the `dispose()` method of each one of them. When opening the different operators, we mentioned that the order is from the last to the first. &lt;br/&gt;
    +Closing happens the other way round, from first to last.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, when all operators have been closed and all their resources freed, the task shuts down its timer service, performs its task-specific cleanup, &lt;b&gt;e.g.&lt;/b&gt; clean all its &lt;br/&gt;
    +internal buffers, and then performs its generic task clean up which consists of closing all its output channels and cleaning any output buffers.&lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Checkpoints:&lt;/b&gt;* Previously we saw that during `initializeState()`, and in case of recovering from a failure, the task and all its operators and functions retrieve the &lt;br/&gt;
    +state that was persisted to stable storage during the last successful checkpoint before the failure. Checkpoints in Flink are performed periodically based on a user-specified &lt;br/&gt;
    +interval, and are performed by a different thread than that of the main task thread. This is the reason the are not included in the main phases of the task lifecycle. In a &lt;br/&gt;
    +nutshell, special elements called `CheckpointBarriers` are injected periodically by the source tasks of a job in the stream of input data, and travel with the actual data from &lt;br/&gt;
    +source to sink. A source task injects these barriers after it is in running mode, and assuming that the CheckpointCoordinator is also running. Whenever a task receives such a &lt;br/&gt;
    +barrier, it schedules a task to be performed by the checkpoint thread which calls the `snapshotState()` of the operators in the task. Input data can still be received by the &lt;br/&gt;
    +task while the checkpoint is being performed, but they are buffered and only emitted downstream after the checkpoint is successfully completed. For details on the principles &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &quot;but they are buffered ...&quot; -&amp;gt; &quot;but they are buffered and only &lt;b&gt;processed and&lt;/b&gt; emitted downstream...&quot;&lt;/p&gt;</comment>
                            <comment id="15888315" author="githubbot" created="Tue, 28 Feb 2017 16:01:39 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103481871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103481871&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &quot;the `open()` &lt;b&gt;method&lt;/b&gt;?&lt;/p&gt;</comment>
                            <comment id="15888316" author="githubbot" created="Tue, 28 Feb 2017 16:01:39 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103481205&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103481205&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Move checkpointing into a separate box to make clear it is not included in the regular thread?&lt;/p&gt;</comment>
                            <comment id="15888317" author="githubbot" created="Tue, 28 Feb 2017 16:01:40 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103486405&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103486405&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    +opening the user-defined function in the case of the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process fresh incoming data. This is done by invoking the `processElement()` and `processWatermark()` methods which&lt;br/&gt;
    +contain the logic for processing elements and watermark respectively.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is reached), the `close()` method is called to &lt;br/&gt;
    +perform any final bookkeeping action required by the operator&apos;s logic, and the `dispose()` is called after that to free any resources held by the operator. &lt;br/&gt;
    +&lt;br/&gt;
    +In the case of termination due to a failure or due to manual cancellation, the execution jumps directly to the `dispose()`, and skips any intermediate phases between&lt;br/&gt;
    +the phase the operator was in when the failure happened and the `dispose` one.&lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Checkpoints:&lt;/b&gt;* The `snapshotState()` method of the operator is called asynchronously to the rest of the methods described above, whenever a checkpoint barrier is received. &lt;br/&gt;
    +Its responsibility is to store the current state of the operator to the specified &lt;span class=&quot;error&quot;&gt;&amp;#91;state backend&amp;#93;&lt;/span&gt;({{ site.baseurl }}/ops/state_backends.html) from where it is going to be &lt;br/&gt;
    +retrieved when the job resumes execution after a failure. For a bried description of Flink&apos;s checkpointing mechanism please keep on reading, and for a more detailed discussion &lt;br/&gt;
    +on the principles around checkpointing in Flink please read the corresponding documentation: &lt;span class=&quot;error&quot;&gt;&amp;#91;Data Streaming Fault Tolerance&amp;#93;&lt;/span&gt;({{ site.baseurl }}/internals/stream_checkpointing.html).&lt;br/&gt;
    +&lt;br/&gt;
    +## Task Lifecycle&lt;br/&gt;
    +&lt;br/&gt;
    +Given the above brief introduction on the operator&apos;s main phases, this section describes in more detail how a task calls them during its execution on a cluster. The sequence &lt;br/&gt;
    +of the phases described here is mainly included in the `invoke()` method of the `StreamTask`. The remainder of this document is split into two subsections, one describing the &lt;br/&gt;
    +phases during a regular, fault-free execution of a task (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Normal Execution&amp;#93;&lt;/span&gt;(#normal-execution)), and (a shorter) one describing the different sequence followed in case &lt;br/&gt;
    +the task is cancelled (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Interrupted Execution&amp;#93;&lt;/span&gt;(#interrupted-execution)), &lt;br/&gt;
    +either manually, or due some other reason, &lt;b&gt;e.g.&lt;/b&gt; an exception thrown during execution.&lt;br/&gt;
    +&lt;br/&gt;
    +### Normal Execution&lt;br/&gt;
    +&lt;br/&gt;
    +The steps a task goes through when executed until completion without being interrupted are illustrated below:&lt;br/&gt;
    +&lt;br/&gt;
    +	setInitialState()&lt;br/&gt;
    +	invoke()&lt;br/&gt;
    +		Create basic utils (config, etc) and load the chain of operators&lt;br/&gt;
    +		setup-operators()&lt;br/&gt;
    + 		task specific init()&lt;br/&gt;
    + 		initialize-operator-states()&lt;br/&gt;
    + 		open-operators()&lt;br/&gt;
    + 		run()&lt;br/&gt;
    + 		close-operators()&lt;br/&gt;
    + 		dispose-operators()&lt;br/&gt;
    + 		task specific cleanup()&lt;br/&gt;
    + 		common cleanup&lt;br/&gt;
    +&lt;br/&gt;
    +As shown above, after recovering the task configuration and initializing some important runtime parameters, the very first step for the task is to retrieve its initial, &lt;br/&gt;
    +task-wide state. This is done in the `setInitialState()`, and it is particularly important in two cases:&lt;br/&gt;
    +&lt;br/&gt;
    +1. when the task is recovering from a failure and restarts from the last successful checkpoint, and&lt;br/&gt;
    +2. when resuming from a &lt;span class=&quot;error&quot;&gt;&amp;#91;savepoint&amp;#93;&lt;/span&gt;({{ site.baseurl }}/setup/savepoints.html). &lt;br/&gt;
    +&lt;br/&gt;
    +If it is the first time the task is executed, the initial task state is empty. &lt;br/&gt;
    +&lt;br/&gt;
    +After recovering any initial state, the task goes into its `invoke()` method. There, it first initializes the operators involved in the local computation by calling &lt;br/&gt;
    +the `setup()` method of each one of them and then performs its task-specific initialization by calling the local `init()` method. By task-specific, we mean that &lt;br/&gt;
    +depending on the type of the task (`SourceTask`, `OneInputStreamTask` or `TwoInputStreamTask`, etc), this step may differ, but in any case, here is where the necessary &lt;br/&gt;
    +task-wide resources are acquired. As an example, the `OneInputStreamTask` which represents a task that expects to have a single input stream, initializes the connection(s) &lt;br/&gt;
    +to the location(s) of the different partitions of the input stream that are relevant to the local task.&lt;br/&gt;
    +&lt;br/&gt;
    +Having acquired the necessary resources, it is time for the different operators and user-defined functions to acquire their individual state from the task-wide state &lt;br/&gt;
    +retrieved above. This is done in the `initializeState()` method, which calls the `initializeState()` of each individual operator. This method should be overriden by &lt;br/&gt;
    +every stateful operator and should contain the state initialization logic, both for the first time a job is executed, but also for the case when the task recovers from &lt;br/&gt;
    +a failure or using a savepoint.&lt;br/&gt;
    +&lt;br/&gt;
    +Now that all operators in the task have been initialized, the `open()` method of each individual operator is called by the `openAllOperators()` method of the `StreamTask`. &lt;br/&gt;
    +This is the place that implements all the operational initialization, such as register any retrieved timers with the timer service. A single task may be executing multiple &lt;br/&gt;
    +operators with one consuming the output of its predecessor. In this case, the `open()` method is called from the last operator, &lt;b&gt;i.e.&lt;/b&gt; the one whose output is also the output &lt;br/&gt;
    +of the task itself, to the first. This is done so that when the first operator starts processing the task&apos;s input, all downstream operators are ready to receive its output.&lt;br/&gt;
    +&lt;br/&gt;
    +Now the task can resume execution, and operators can start processing fresh input data. This is the place where the task-specific `run()` mehtod is called. This method will &lt;br/&gt;
    +run until either there is no more input data (finite stream), or the task is cancelled (manually or not). Here is where the operator specific `processElement()` and &lt;br/&gt;
    +`processWatermark()` methods are called.&lt;br/&gt;
    +&lt;br/&gt;
    +In the case of running till completion, &lt;b&gt;i.e.&lt;/b&gt; there is no more input data to process, after exiting from the `run()` method, the task enters its shutdown process. &lt;br/&gt;
    +Initially, the timer service stops registering any new timers (e.g. from fired timers that are being executed), clears all the not yet started timers, and awaits the &lt;br/&gt;
    +completion of currently executing ones. Then the `closeAllOperators()` tries to gracefully close the operators involved in the computation by calling the `close()` method &lt;br/&gt;
    +of each one of them. Then any buffered output data is flushed so that they can be processed by the downstream tasks, and finally the task tries to clear all the resources &lt;br/&gt;
    +held by the operators by calling the `dispose()` method of each one of them. When opening the different operators, we mentioned that the order is from the last to the first. &lt;br/&gt;
    +Closing happens the other way round, from first to last.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, when all operators have been closed and all their resources freed, the task shuts down its timer service, performs its task-specific cleanup, &lt;b&gt;e.g.&lt;/b&gt; clean all its &lt;br/&gt;
    +internal buffers, and then performs its generic task clean up which consists of closing all its output channels and cleaning any output buffers.&lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Checkpoints:&lt;/b&gt;* Previously we saw that during `initializeState()`, and in case of recovering from a failure, the task and all its operators and functions retrieve the &lt;br/&gt;
    +state that was persisted to stable storage during the last successful checkpoint before the failure. Checkpoints in Flink are performed periodically based on a user-specified &lt;br/&gt;
    +interval, and are performed by a different thread than that of the main task thread. This is the reason the are not included in the main phases of the task lifecycle. In a &lt;br/&gt;
    +nutshell, special elements called `CheckpointBarriers` are injected periodically by the source tasks of a job in the stream of input data, and travel with the actual data from &lt;br/&gt;
    +source to sink. A source task injects these barriers after it is in running mode, and assuming that the CheckpointCoordinator is also running. Whenever a task receives such a &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    CheckpointCoordinator -&amp;gt; `CheckpointCoordinator`?&lt;/p&gt;</comment>
                            <comment id="15888318" author="githubbot" created="Tue, 28 Feb 2017 16:01:47 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r103482008&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r103482008&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,149 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. This is the place where each parallel instance of your operators gets executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +As the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. Given this, it is worth spending a few lines &lt;br/&gt;
    +simply mentioning the basic methods representing the lifecycle of an operator before diving into those of the `StreamTask` itself. The list is presented below in &lt;br/&gt;
    +the order that they are called. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +	    initializeState()&lt;br/&gt;
    +	    setup()&lt;br/&gt;
    +	    open()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // processing&lt;br/&gt;
    +	    processElement()&lt;br/&gt;
    +	    processWatermark()&lt;br/&gt;
    +	&lt;br/&gt;
    +	    // termination&lt;br/&gt;
    +	    close()&lt;br/&gt;
    +	    dispose()&lt;br/&gt;
    +&lt;br/&gt;
    +        // checkpointing&lt;br/&gt;
    +        snapshotState()&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `initializeState()` gives an operator its initial state. After obtaining it, the `setup()` is called to initialize some operator specific &lt;br/&gt;
    +machinery, such as its `RuntimContext` and its metric collection data-structures, and the `open()` executes any operator-specific initialization, such as&lt;br/&gt;
    +opening the user-defined function in the case of the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process fresh incoming data. This is done by invoking the `processElement()` and `processWatermark()` methods which&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    remove &quot;fresh&quot;?&lt;/p&gt;</comment>
                            <comment id="15894106" author="githubbot" created="Fri, 3 Mar 2017 10:43:14 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r104126670&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r104126670&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,186 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. It is the place where each parallel instance of an operator is executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different &lt;br/&gt;
    +task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +Because the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. &lt;br/&gt;
    +So, we will briefly mention the basic methods representing the lifecycle of an operator before diving into those of the &lt;br/&gt;
    +`StreamTask` itself. The list is presented below in the order that each of the methods is called. Given that an operator&lt;br/&gt;
    +can have a user-defined function (&lt;b&gt;UDF&lt;/b&gt;), below each of the operator methods we also present (indented) the methods in &lt;br/&gt;
    +the lifecycle of UDF that it calls. These methods are available if your operator extends the `AbstractUdfStreamOperator`, &lt;br/&gt;
    +which is the basic class for all operators that execute UDFs.&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +        OPERATOR::setup&lt;br/&gt;
    +            UDF::setRuntimeContext&lt;br/&gt;
    +        OPERATOR::initializeState&lt;br/&gt;
    +        OPERATOR::open&lt;br/&gt;
    +            UDF::open&lt;br/&gt;
    +        &lt;br/&gt;
    +        // processing&lt;br/&gt;
    +        OPERATOR::processElement&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Maybe we could somehow indicate that those functions are not called once, but in loops. Thereby, the operator might call methods on the user function. `run()` is just one possible method, if the UDF is a source function.&lt;/p&gt;</comment>
                            <comment id="15894107" author="githubbot" created="Fri, 3 Mar 2017 10:43:14 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r104126746&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r104126746&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,186 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. It is the place where each parallel instance of an operator is executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different &lt;br/&gt;
    +task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +Because the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. &lt;br/&gt;
    +So, we will briefly mention the basic methods representing the lifecycle of an operator before diving into those of the &lt;br/&gt;
    +`StreamTask` itself. The list is presented below in the order that each of the methods is called. Given that an operator&lt;br/&gt;
    +can have a user-defined function (&lt;b&gt;UDF&lt;/b&gt;), below each of the operator methods we also present (indented) the methods in &lt;br/&gt;
    +the lifecycle of UDF that it calls. These methods are available if your operator extends the `AbstractUdfStreamOperator`, &lt;br/&gt;
    +which is the basic class for all operators that execute UDFs.&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +        OPERATOR::setup&lt;br/&gt;
    +            UDF::setRuntimeContext&lt;br/&gt;
    +        OPERATOR::initializeState&lt;br/&gt;
    +        OPERATOR::open&lt;br/&gt;
    +            UDF::open&lt;br/&gt;
    +        &lt;br/&gt;
    +        // processing&lt;br/&gt;
    +        OPERATOR::processElement&lt;br/&gt;
    +            UDF::run&lt;br/&gt;
    +        OPERATOR::processWatermark&lt;br/&gt;
    +        &lt;br/&gt;
    +        // checkpointing (called asynchronously)&lt;br/&gt;
    +        OPERATOR::snapshotState&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Again, this could be called multiple times in the lifecycle. Once for each triggered checkpoint.&lt;/p&gt;</comment>
                            <comment id="15894108" author="githubbot" created="Fri, 3 Mar 2017 10:43:14 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r104128750&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r104128750&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,186 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. It is the place where each parallel instance of an operator is executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different &lt;br/&gt;
    +task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +Because the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. &lt;br/&gt;
    +So, we will briefly mention the basic methods representing the lifecycle of an operator before diving into those of the &lt;br/&gt;
    +`StreamTask` itself. The list is presented below in the order that each of the methods is called. Given that an operator&lt;br/&gt;
    +can have a user-defined function (&lt;b&gt;UDF&lt;/b&gt;), below each of the operator methods we also present (indented) the methods in &lt;br/&gt;
    +the lifecycle of UDF that it calls. These methods are available if your operator extends the `AbstractUdfStreamOperator`, &lt;br/&gt;
    +which is the basic class for all operators that execute UDFs.&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +        OPERATOR::setup&lt;br/&gt;
    +            UDF::setRuntimeContext&lt;br/&gt;
    +        OPERATOR::initializeState&lt;br/&gt;
    +        OPERATOR::open&lt;br/&gt;
    +            UDF::open&lt;br/&gt;
    +        &lt;br/&gt;
    +        // processing&lt;br/&gt;
    +        OPERATOR::processElement&lt;br/&gt;
    +            UDF::run&lt;br/&gt;
    +        OPERATOR::processWatermark&lt;br/&gt;
    +        &lt;br/&gt;
    +        // checkpointing (called asynchronously)&lt;br/&gt;
    +        OPERATOR::snapshotState&lt;br/&gt;
    +                &lt;br/&gt;
    +        // termination&lt;br/&gt;
    +        OPERATOR::close&lt;br/&gt;
    +            UDF::close&lt;br/&gt;
    +        OPERATOR::dispose&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `setup()` is called to initialize some operator-specific machinery, such as its `RuntimeContext` and &lt;br/&gt;
    +its metric collection data-structures. After this, the `initializeState()` gives an operator its initial state, and the &lt;br/&gt;
    + `open()` method executes any operator-specific initialization, such as opening the user-defined function in the case of &lt;br/&gt;
    +the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;span class=&quot;label label-danger&quot;&amp;gt;Attention&amp;lt;/span&amp;gt; The `initializeState()` contains both the logic for initializing the &lt;br/&gt;
    +state of the operator during its initial execution (&lt;b&gt;e.g.&lt;/b&gt; register any keyed state), and also the logic to retrieve its&lt;br/&gt;
    +state from a checkpoint after a failure. More about this on the rest of this page.&lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process incoming data. This is done by invoking the `processElement()` &lt;br/&gt;
    +and `processWatermark()` methods which contain the logic for processing elements and watermarks, respectively. The &lt;br/&gt;
    +`processElement()` is also the place where you function&apos;s logic is invoked, &lt;b&gt;e.g.&lt;/b&gt; the `map()` method of your `MapFunction`.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of a normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is &lt;br/&gt;
    +reached), the `close()` method is called to perform any final bookkeeping action required by the operator&apos;s logic, and &lt;br/&gt;
    +the `dispose()` is called after that to free any resources held by the operator. &lt;br/&gt;
    +&lt;br/&gt;
    +In the case of a termination due to a failure or due to manual cancellation, the execution jumps directly to the `dispose()` &lt;br/&gt;
    +and skips any intermediate phases between the phase the operator was in when the failure happened and the `dispose()`.&lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Checkpoints:&lt;/b&gt;* The `snapshotState()` method of the operator is called asynchronously to the rest of the methods described &lt;br/&gt;
    +above whenever a checkpoint barrier is received. Checkpoints are performed during the processing phase, &lt;b&gt;i.e.&lt;/b&gt; after the &lt;br/&gt;
    +operator is opened and before it is closed. The responsibility of this method is to store the current state of the operator &lt;br/&gt;
    +to the specified &lt;span class=&quot;error&quot;&gt;&amp;#91;state backend&amp;#93;&lt;/span&gt;({{ site.baseurl }}/ops/state_backends.html) from where it will be retrieved when &lt;br/&gt;
    +the job resumes execution after a failure. Below we include a brief description of Flink&apos;s checkpointing mechanism, &lt;br/&gt;
    +and for a more detailed discussion on the principles around checkpointing in Flink please read the corresponding documentation: &lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Data Streaming Fault Tolerance&amp;#93;&lt;/span&gt;({{ site.baseurl }}/internals/stream_checkpointing.html).&lt;br/&gt;
    +&lt;br/&gt;
    +## Task Lifecycle&lt;br/&gt;
    +&lt;br/&gt;
    +Following that brief introduction on the operator&apos;s main phases, this section describes in more detail how a task calls &lt;br/&gt;
    +the respective methods during its execution on a cluster. The sequence of the phases described here is mainly included &lt;br/&gt;
    +in the `invoke()` method of the `StreamTask` class. The remainder of this document is split into two subsections, one &lt;br/&gt;
    +describing the phases during a regular, fault-free execution of a task (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Normal Execution&amp;#93;&lt;/span&gt;(#normal-execution)), and &lt;br/&gt;
    +(a shorter) one describing the different sequence followed in case the task is cancelled (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Interrupted Execution&amp;#93;&lt;/span&gt;(#interrupted-execution)), &lt;br/&gt;
    +either manually, or due some other reason, &lt;b&gt;e.g.&lt;/b&gt; an exception thrown during execution.&lt;br/&gt;
    +&lt;br/&gt;
    +### Normal Execution&lt;br/&gt;
    +&lt;br/&gt;
    +The steps a task goes through when executed until completion without being interrupted are illustrated below:&lt;br/&gt;
    +&lt;br/&gt;
    +	    TASK::setInitialState&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Again, I suggest to always indicate already in the overview (and more so in the detailed description) which methods are just called once, and which are looped (and maybe what is there terminal condition)&lt;/p&gt;</comment>
                            <comment id="15894109" author="githubbot" created="Fri, 3 Mar 2017 10:43:14 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r104126990&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r104126990&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,186 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. It is the place where each parallel instance of an operator is executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different &lt;br/&gt;
    +task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +Because the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. &lt;br/&gt;
    +So, we will briefly mention the basic methods representing the lifecycle of an operator before diving into those of the &lt;br/&gt;
    +`StreamTask` itself. The list is presented below in the order that each of the methods is called. Given that an operator&lt;br/&gt;
    +can have a user-defined function (&lt;b&gt;UDF&lt;/b&gt;), below each of the operator methods we also present (indented) the methods in &lt;br/&gt;
    +the lifecycle of UDF that it calls. These methods are available if your operator extends the `AbstractUdfStreamOperator`, &lt;br/&gt;
    +which is the basic class for all operators that execute UDFs.&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +        OPERATOR::setup&lt;br/&gt;
    +            UDF::setRuntimeContext&lt;br/&gt;
    +        OPERATOR::initializeState&lt;br/&gt;
    +        OPERATOR::open&lt;br/&gt;
    +            UDF::open&lt;br/&gt;
    +        &lt;br/&gt;
    +        // processing&lt;br/&gt;
    +        OPERATOR::processElement&lt;br/&gt;
    +            UDF::run&lt;br/&gt;
    +        OPERATOR::processWatermark&lt;br/&gt;
    +        &lt;br/&gt;
    +        // checkpointing (called asynchronously)&lt;br/&gt;
    +        OPERATOR::snapshotState&lt;br/&gt;
    +                &lt;br/&gt;
    +        // termination&lt;br/&gt;
    +        OPERATOR::close&lt;br/&gt;
    +            UDF::close&lt;br/&gt;
    +        OPERATOR::dispose&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `setup()` is called to initialize some operator-specific machinery, such as its `RuntimeContext` and &lt;br/&gt;
    +its metric collection data-structures. After this, the `initializeState()` gives an operator its initial state, and the &lt;br/&gt;
    + `open()` method executes any operator-specific initialization, such as opening the user-defined function in the case of &lt;br/&gt;
    +the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;span class=&quot;label label-danger&quot;&amp;gt;Attention&amp;lt;/span&amp;gt; The `initializeState()` contains both the logic for initializing the &lt;br/&gt;
    +state of the operator during its initial execution (&lt;b&gt;e.g.&lt;/b&gt; register any keyed state), and also the logic to retrieve its&lt;br/&gt;
    +state from a checkpoint after a failure. More about this on the rest of this page.&lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process incoming data. This is done by invoking the `processElement()` &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    At least here, we should say that this is happening as a loop, until some condition causes a break. Otherwise, there is the misleading interpretation that this methods are called once and the looping happens inside of them.&lt;/p&gt;</comment>
                            <comment id="15894110" author="githubbot" created="Fri, 3 Mar 2017 10:43:14 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r104125117&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r104125117&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,186 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. It is the place where each parallel instance of an operator is executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    You could start &quot;`StreamTask` is the basis...&quot;. And after that start about going through its different phases.&lt;/p&gt;</comment>
                            <comment id="15894111" author="githubbot" created="Fri, 3 Mar 2017 10:43:14 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r104126474&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r104126474&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,186 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. It is the place where each parallel instance of an operator is executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different &lt;br/&gt;
    +task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +Because the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. &lt;br/&gt;
    +So, we will briefly mention the basic methods representing the lifecycle of an operator before diving into those of the &lt;br/&gt;
    +`StreamTask` itself. The list is presented below in the order that each of the methods is called. Given that an operator&lt;br/&gt;
    +can have a user-defined function (&lt;b&gt;UDF&lt;/b&gt;), below each of the operator methods we also present (indented) the methods in &lt;br/&gt;
    +the lifecycle of UDF that it calls. These methods are available if your operator extends the `AbstractUdfStreamOperator`, &lt;br/&gt;
    +which is the basic class for all operators that execute UDFs.&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +        OPERATOR::setup&lt;br/&gt;
    +            UDF::setRuntimeContext&lt;br/&gt;
    +        OPERATOR::initializeState&lt;br/&gt;
    +        OPERATOR::open&lt;br/&gt;
    +            UDF::open&lt;br/&gt;
    +        &lt;br/&gt;
    +        // processing&lt;br/&gt;
    +        OPERATOR::processElement&lt;br/&gt;
    +            UDF::run&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    `UDF::run` is actually just a special case for source functions. Other functions could have methods like `apply` that are called in the operator&apos;s main loop.&lt;/p&gt;</comment>
                            <comment id="15894112" author="githubbot" created="Fri, 3 Mar 2017 10:43:14 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r104128356&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r104128356&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,186 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. It is the place where each parallel instance of an operator is executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different &lt;br/&gt;
    +task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +Because the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. &lt;br/&gt;
    +So, we will briefly mention the basic methods representing the lifecycle of an operator before diving into those of the &lt;br/&gt;
    +`StreamTask` itself. The list is presented below in the order that each of the methods is called. Given that an operator&lt;br/&gt;
    +can have a user-defined function (&lt;b&gt;UDF&lt;/b&gt;), below each of the operator methods we also present (indented) the methods in &lt;br/&gt;
    +the lifecycle of UDF that it calls. These methods are available if your operator extends the `AbstractUdfStreamOperator`, &lt;br/&gt;
    +which is the basic class for all operators that execute UDFs.&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +        OPERATOR::setup&lt;br/&gt;
    +            UDF::setRuntimeContext&lt;br/&gt;
    +        OPERATOR::initializeState&lt;br/&gt;
    +        OPERATOR::open&lt;br/&gt;
    +            UDF::open&lt;br/&gt;
    +        &lt;br/&gt;
    +        // processing&lt;br/&gt;
    +        OPERATOR::processElement&lt;br/&gt;
    +            UDF::run&lt;br/&gt;
    +        OPERATOR::processWatermark&lt;br/&gt;
    +        &lt;br/&gt;
    +        // checkpointing (called asynchronously)&lt;br/&gt;
    +        OPERATOR::snapshotState&lt;br/&gt;
    +                &lt;br/&gt;
    +        // termination&lt;br/&gt;
    +        OPERATOR::close&lt;br/&gt;
    +            UDF::close&lt;br/&gt;
    +        OPERATOR::dispose&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `setup()` is called to initialize some operator-specific machinery, such as its `RuntimeContext` and &lt;br/&gt;
    +its metric collection data-structures. After this, the `initializeState()` gives an operator its initial state, and the &lt;br/&gt;
    + `open()` method executes any operator-specific initialization, such as opening the user-defined function in the case of &lt;br/&gt;
    +the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;span class=&quot;label label-danger&quot;&amp;gt;Attention&amp;lt;/span&amp;gt; The `initializeState()` contains both the logic for initializing the &lt;br/&gt;
    +state of the operator during its initial execution (&lt;b&gt;e.g.&lt;/b&gt; register any keyed state), and also the logic to retrieve its&lt;br/&gt;
    +state from a checkpoint after a failure. More about this on the rest of this page.&lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process incoming data. This is done by invoking the `processElement()` &lt;br/&gt;
    +and `processWatermark()` methods which contain the logic for processing elements and watermarks, respectively. The &lt;br/&gt;
    +`processElement()` is also the place where you function&apos;s logic is invoked, &lt;b&gt;e.g.&lt;/b&gt; the `map()` method of your `MapFunction`.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of a normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is &lt;br/&gt;
    +reached), the `close()` method is called to perform any final bookkeeping action required by the operator&apos;s logic, and &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    We could give examples to make the difference of `close` and `dispose`easier to understand. In particular, as the explanation is not 100% true. I suggest to say that e.g. `close` could close some streams (which could also be seen as releasing resources) or shutdown the operator&apos;s reactions on input. In a broader sense, it stops the operator from running. In contrast to that dispose could release native memory that held the operator&apos;s internal data. In a broader sense, it releases all resources that are still around after stopping the operator.&lt;/p&gt;</comment>
                            <comment id="15894114" author="githubbot" created="Fri, 3 Mar 2017 10:43:14 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r104128587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r104128587&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,186 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. It is the place where each parallel instance of an operator is executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different &lt;br/&gt;
    +task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +Because the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. &lt;br/&gt;
    +So, we will briefly mention the basic methods representing the lifecycle of an operator before diving into those of the &lt;br/&gt;
    +`StreamTask` itself. The list is presented below in the order that each of the methods is called. Given that an operator&lt;br/&gt;
    +can have a user-defined function (&lt;b&gt;UDF&lt;/b&gt;), below each of the operator methods we also present (indented) the methods in &lt;br/&gt;
    +the lifecycle of UDF that it calls. These methods are available if your operator extends the `AbstractUdfStreamOperator`, &lt;br/&gt;
    +which is the basic class for all operators that execute UDFs.&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +        OPERATOR::setup&lt;br/&gt;
    +            UDF::setRuntimeContext&lt;br/&gt;
    +        OPERATOR::initializeState&lt;br/&gt;
    +        OPERATOR::open&lt;br/&gt;
    +            UDF::open&lt;br/&gt;
    +        &lt;br/&gt;
    +        // processing&lt;br/&gt;
    +        OPERATOR::processElement&lt;br/&gt;
    +            UDF::run&lt;br/&gt;
    +        OPERATOR::processWatermark&lt;br/&gt;
    +        &lt;br/&gt;
    +        // checkpointing (called asynchronously)&lt;br/&gt;
    +        OPERATOR::snapshotState&lt;br/&gt;
    +                &lt;br/&gt;
    +        // termination&lt;br/&gt;
    +        OPERATOR::close&lt;br/&gt;
    +            UDF::close&lt;br/&gt;
    +        OPERATOR::dispose&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `setup()` is called to initialize some operator-specific machinery, such as its `RuntimeContext` and &lt;br/&gt;
    +its metric collection data-structures. After this, the `initializeState()` gives an operator its initial state, and the &lt;br/&gt;
    + `open()` method executes any operator-specific initialization, such as opening the user-defined function in the case of &lt;br/&gt;
    +the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;span class=&quot;label label-danger&quot;&amp;gt;Attention&amp;lt;/span&amp;gt; The `initializeState()` contains both the logic for initializing the &lt;br/&gt;
    +state of the operator during its initial execution (&lt;b&gt;e.g.&lt;/b&gt; register any keyed state), and also the logic to retrieve its&lt;br/&gt;
    +state from a checkpoint after a failure. More about this on the rest of this page.&lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process incoming data. This is done by invoking the `processElement()` &lt;br/&gt;
    +and `processWatermark()` methods which contain the logic for processing elements and watermarks, respectively. The &lt;br/&gt;
    +`processElement()` is also the place where you function&apos;s logic is invoked, &lt;b&gt;e.g.&lt;/b&gt; the `map()` method of your `MapFunction`.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of a normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is &lt;br/&gt;
    +reached), the `close()` method is called to perform any final bookkeeping action required by the operator&apos;s logic, and &lt;br/&gt;
    +the `dispose()` is called after that to free any resources held by the operator. &lt;br/&gt;
    +&lt;br/&gt;
    +In the case of a termination due to a failure or due to manual cancellation, the execution jumps directly to the `dispose()` &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This is also why failure go immediately to `dispose`: the operator is already stopped (because of the failure), but the resources are not yet all released.&lt;/p&gt;</comment>
                            <comment id="15894113" author="githubbot" created="Fri, 3 Mar 2017 10:43:14 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r104127245&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r104127245&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,186 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. It is the place where each parallel instance of an operator is executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different &lt;br/&gt;
    +task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +Because the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. &lt;br/&gt;
    +So, we will briefly mention the basic methods representing the lifecycle of an operator before diving into those of the &lt;br/&gt;
    +`StreamTask` itself. The list is presented below in the order that each of the methods is called. Given that an operator&lt;br/&gt;
    +can have a user-defined function (&lt;b&gt;UDF&lt;/b&gt;), below each of the operator methods we also present (indented) the methods in &lt;br/&gt;
    +the lifecycle of UDF that it calls. These methods are available if your operator extends the `AbstractUdfStreamOperator`, &lt;br/&gt;
    +which is the basic class for all operators that execute UDFs.&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I would suggest to add a `phase` after `initialization`, `processing`, etc.&lt;/p&gt;</comment>
                            <comment id="15894115" author="githubbot" created="Fri, 3 Mar 2017 10:43:14 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r104124935&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r104124935&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,186 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. It is the place where each parallel instance of an operator is executed. &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    &quot;A task ... is the place where each parallel instance...&quot;: one could interpret that all parallel instances run in one task, which is misleading.&lt;/p&gt;</comment>
                            <comment id="15894116" author="githubbot" created="Fri, 3 Mar 2017 10:43:14 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r104125316&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r104125316&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,186 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. It is the place where each parallel instance of an operator is executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different &lt;br/&gt;
    +task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +Because the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I think it is more precisely to say &quot;...that executes a parallel instance of an operator&quot;&lt;/p&gt;</comment>
                            <comment id="15894182" author="githubbot" created="Fri, 3 Mar 2017 11:29:49 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429#discussion_r104136196&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429#discussion_r104136196&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/internals/task_lifecycle.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,186 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title:  &quot;Task Lifecycle&quot;&lt;br/&gt;
    +nav-title: Task Lifecycle&lt;br/&gt;
    +nav-parent_id: internals&lt;br/&gt;
    +nav-pos: 5&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +A task in Flink is the basic unit of execution. It is the place where each parallel instance of an operator is executed. &lt;br/&gt;
    +&lt;br/&gt;
    +This document goes through the different phases in the lifecycle of the `StreamTask`, which is the base for all different &lt;br/&gt;
    +task sub-types in Flink&apos;s streaming engine. &lt;br/&gt;
    +&lt;br/&gt;
    +* This will be replaced by the TOC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +## Operator Lifecycle in a nutshell&lt;br/&gt;
    +&lt;br/&gt;
    +Because the task is the entity that executes your operators, its lifecycle is tightly integrated with that of an operator. &lt;br/&gt;
    +So, we will briefly mention the basic methods representing the lifecycle of an operator before diving into those of the &lt;br/&gt;
    +`StreamTask` itself. The list is presented below in the order that each of the methods is called. Given that an operator&lt;br/&gt;
    +can have a user-defined function (&lt;b&gt;UDF&lt;/b&gt;), below each of the operator methods we also present (indented) the methods in &lt;br/&gt;
    +the lifecycle of UDF that it calls. These methods are available if your operator extends the `AbstractUdfStreamOperator`, &lt;br/&gt;
    +which is the basic class for all operators that execute UDFs.&lt;br/&gt;
    +&lt;br/&gt;
    +        // initialization&lt;br/&gt;
    +        OPERATOR::setup&lt;br/&gt;
    +            UDF::setRuntimeContext&lt;br/&gt;
    +        OPERATOR::initializeState&lt;br/&gt;
    +        OPERATOR::open&lt;br/&gt;
    +            UDF::open&lt;br/&gt;
    +        &lt;br/&gt;
    +        // processing&lt;br/&gt;
    +        OPERATOR::processElement&lt;br/&gt;
    +            UDF::run&lt;br/&gt;
    +        OPERATOR::processWatermark&lt;br/&gt;
    +        &lt;br/&gt;
    +        // checkpointing (called asynchronously)&lt;br/&gt;
    +        OPERATOR::snapshotState&lt;br/&gt;
    +                &lt;br/&gt;
    +        // termination&lt;br/&gt;
    +        OPERATOR::close&lt;br/&gt;
    +            UDF::close&lt;br/&gt;
    +        OPERATOR::dispose&lt;br/&gt;
    +    &lt;br/&gt;
    +In a nutshell, the `setup()` is called to initialize some operator-specific machinery, such as its `RuntimeContext` and &lt;br/&gt;
    +its metric collection data-structures. After this, the `initializeState()` gives an operator its initial state, and the &lt;br/&gt;
    + `open()` method executes any operator-specific initialization, such as opening the user-defined function in the case of &lt;br/&gt;
    +the `AbstractUdfStreamOperator`. &lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;span class=&quot;label label-danger&quot;&amp;gt;Attention&amp;lt;/span&amp;gt; The `initializeState()` contains both the logic for initializing the &lt;br/&gt;
    +state of the operator during its initial execution (&lt;b&gt;e.g.&lt;/b&gt; register any keyed state), and also the logic to retrieve its&lt;br/&gt;
    +state from a checkpoint after a failure. More about this on the rest of this page.&lt;br/&gt;
    +&lt;br/&gt;
    +Now that everything is set, the operator is ready to process incoming data. This is done by invoking the `processElement()` &lt;br/&gt;
    +and `processWatermark()` methods which contain the logic for processing elements and watermarks, respectively. The &lt;br/&gt;
    +`processElement()` is also the place where you function&apos;s logic is invoked, &lt;b&gt;e.g.&lt;/b&gt; the `map()` method of your `MapFunction`.&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in the case of a normal, fault-free termination of the operator (&lt;b&gt;e.g.&lt;/b&gt; if the stream is finite and its end is &lt;br/&gt;
    +reached), the `close()` method is called to perform any final bookkeeping action required by the operator&apos;s logic, and &lt;br/&gt;
    +the `dispose()` is called after that to free any resources held by the operator. &lt;br/&gt;
    +&lt;br/&gt;
    +In the case of a termination due to a failure or due to manual cancellation, the execution jumps directly to the `dispose()` &lt;br/&gt;
    +and skips any intermediate phases between the phase the operator was in when the failure happened and the `dispose()`.&lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Checkpoints:&lt;/b&gt;* The `snapshotState()` method of the operator is called asynchronously to the rest of the methods described &lt;br/&gt;
    +above whenever a checkpoint barrier is received. Checkpoints are performed during the processing phase, &lt;b&gt;i.e.&lt;/b&gt; after the &lt;br/&gt;
    +operator is opened and before it is closed. The responsibility of this method is to store the current state of the operator &lt;br/&gt;
    +to the specified &lt;span class=&quot;error&quot;&gt;&amp;#91;state backend&amp;#93;&lt;/span&gt;({{ site.baseurl }}/ops/state_backends.html) from where it will be retrieved when &lt;br/&gt;
    +the job resumes execution after a failure. Below we include a brief description of Flink&apos;s checkpointing mechanism, &lt;br/&gt;
    +and for a more detailed discussion on the principles around checkpointing in Flink please read the corresponding documentation: &lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Data Streaming Fault Tolerance&amp;#93;&lt;/span&gt;({{ site.baseurl }}/internals/stream_checkpointing.html).&lt;br/&gt;
    +&lt;br/&gt;
    +## Task Lifecycle&lt;br/&gt;
    +&lt;br/&gt;
    +Following that brief introduction on the operator&apos;s main phases, this section describes in more detail how a task calls &lt;br/&gt;
    +the respective methods during its execution on a cluster. The sequence of the phases described here is mainly included &lt;br/&gt;
    +in the `invoke()` method of the `StreamTask` class. The remainder of this document is split into two subsections, one &lt;br/&gt;
    +describing the phases during a regular, fault-free execution of a task (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Normal Execution&amp;#93;&lt;/span&gt;(#normal-execution)), and &lt;br/&gt;
    +(a shorter) one describing the different sequence followed in case the task is cancelled (see &lt;span class=&quot;error&quot;&gt;&amp;#91;Interrupted Execution&amp;#93;&lt;/span&gt;(#interrupted-execution)), &lt;br/&gt;
    +either manually, or due some other reason, &lt;b&gt;e.g.&lt;/b&gt; an exception thrown during execution.&lt;br/&gt;
    +&lt;br/&gt;
    +### Normal Execution&lt;br/&gt;
    +&lt;br/&gt;
    +The steps a task goes through when executed until completion without being interrupted are illustrated below:&lt;br/&gt;
    +&lt;br/&gt;
    +	    TASK::setInitialState&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    In the task, all the described methods are called once.&lt;/p&gt;</comment>
                            <comment id="15894183" author="githubbot" created="Fri, 3 Mar 2017 11:30:22 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks a lot for the review @StefanRRichter . I will integrate them and merge.&lt;/p&gt;</comment>
                            <comment id="15894214" author="githubbot" created="Fri, 3 Mar 2017 12:01:08 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3429&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3429&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15894217" author="kkl0u" created="Fri, 3 Mar 2017 12:02:56 +0000"  >&lt;p&gt;Merged at a2e6fb06c404a31294c53903fbaeaac666403dc8&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 37 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3aqif:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>