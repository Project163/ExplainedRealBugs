<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:27:42 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-6197] Add support for iterative conditions.</title>
                <link>https://issues.apache.org/jira/browse/FLINK-6197</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;So far, the &lt;tt&gt;where&lt;/tt&gt; clause only supported simple &lt;tt&gt;FilterFunction&lt;/tt&gt; conditions. &lt;/p&gt;

&lt;p&gt;With this, we want to add support for conditions where the an event is accepted not only based on its own properties, e.g. name, as it was before, but also based on some statistic computed over previously accepted events in the pattern, e.g. if the price is higher than the average of the prices of the previously accepted events. &lt;/p&gt;

&lt;p&gt;This in combination with the recently added quantifiers will allow for a lot more expressive patterns.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13059421">FLINK-6197</key>
            <summary>Add support for iterative conditions.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kkl0u">Kostas Kloudas</assignee>
                                    <reporter username="kkl0u">Kostas Kloudas</reporter>
                        <labels>
                    </labels>
                <created>Mon, 27 Mar 2017 14:54:16 +0000</created>
                <updated>Tue, 28 Mar 2017 16:10:48 +0000</updated>
                            <resolved>Tue, 28 Mar 2017 16:10:48 +0000</resolved>
                                    <version>1.3.0</version>
                                    <fixVersion>1.3.0</fixVersion>
                                    <component>Library / CEP</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="15943411" author="githubbot" created="Mon, 27 Mar 2017 14:59:34 +0000"  >&lt;p&gt;GitHub user kl0u opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6197&quot; title=&quot;Add support for iterative conditions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-6197&quot;&gt;&lt;del&gt;FLINK-6197&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;cep&amp;#93;&lt;/span&gt; Add support for iterative conditions.&lt;/p&gt;

&lt;p&gt;    So far, the where clause only supported simple FilterFunction&lt;br/&gt;
    conditions. With this, we add support for conditions where an&lt;br/&gt;
    event is accepted not only based on its own properties, e.g.&lt;br/&gt;
    name, as it was before, but also based on some statistic&lt;br/&gt;
    computed over previously accepted events in the pattern, e.g.&lt;br/&gt;
    if the price is higher than the average of the prices of the&lt;br/&gt;
    previously accepted events.&lt;/p&gt;


&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/kl0u/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/kl0u/flink&lt;/a&gt; cep-iterative-functions&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #3624&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit dfb848b83864071ef6738261e425bf4d0e43575d&lt;br/&gt;
Author: kl0u &amp;lt;kkloudas@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-03-22T14:52:07Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6197&quot; title=&quot;Add support for iterative conditions.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-6197&quot;&gt;&lt;del&gt;FLINK-6197&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;cep&amp;#93;&lt;/span&gt; Add support for iterative conditions.&lt;/p&gt;

&lt;p&gt;    So far, the where clause only supported simple FilterFunction&lt;br/&gt;
    conditions. With this, we add support for conditions where an&lt;br/&gt;
    event is accepted not only based on its own properties, e.g.&lt;br/&gt;
    name, as it was before, but also based on some statistic&lt;br/&gt;
    computed over previously accepted events in the pattern, e.g.&lt;br/&gt;
    if the price is higher than the average of the prices of the&lt;br/&gt;
    previously accepted events.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15944734" author="githubbot" created="Tue, 28 Mar 2017 08:11:27 +0000"  >&lt;p&gt;Github user dawidwys commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108232033&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108232033&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/pattern/conditions/IterativeCondition.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,98 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.cep.pattern.conditions;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.functions.Function;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.Serializable;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * A user-defined condition that decides if an element should be accepted in the pattern or not.&lt;br/&gt;
    + * Accepting an element also signals a state transition for the corresponding &lt;/p&gt;
{@link org.apache.flink.cep.nfa.NFA}
&lt;p&gt;.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;A condition can be a simple filter or a more complex condition that iterates over the previously accepted&lt;br/&gt;
    + * elements in the pattern and decides to accept a new element or not based on some statistic over these elements.&lt;br/&gt;
    + * In the former case, the condition should extend the &lt;/p&gt;
{@link SimpleCondition}
&lt;p&gt; class. In the later, the condition&lt;br/&gt;
    + * should extend this class, which gives you also access to the previously accepted elements through a &lt;/p&gt;
{@link Context}.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;An iterative condition that accepts an element if i) its name is middle, and ii) the sum of the prices of all&lt;br/&gt;
    + * accepted elements is less than {@code 5} would look like:&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;pre&amp;gt;&lt;br/&gt;
    + * {@code&lt;br/&gt;
    + * private class MyCondition extends IterativeCondition&amp;lt;Event&amp;gt; {&lt;br/&gt;
    + *&lt;br/&gt;
    + * 		@Override&lt;br/&gt;
    + *     	public boolean filter(Event value, Context&amp;lt;Event&amp;gt; ctx) throws Exception {&lt;br/&gt;
    + *     		if (!value.getName().equals(&quot;middle&quot;)) {
    + *     			return false;
    + *     		}&lt;br/&gt;
    + *&lt;br/&gt;
    + *     		double sum = 0.0;&lt;br/&gt;
    + *     		for (Event e: ctx.getEventsForPattern(&quot;middle&quot;)) {
    + *     			sum += e.getPrice();
    + *     		}&lt;br/&gt;
    + *     		sum += value.getPrice();&lt;br/&gt;
    + *     		return Double.compare(sum, 5.0) &amp;lt;= 0;&lt;br/&gt;
    + *     	}&lt;br/&gt;
    + *    }&lt;br/&gt;
    + * }&lt;br/&gt;
    + * &amp;lt;/pre&amp;gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;b&amp;gt;ATTENTION: &amp;lt;/b&amp;gt; The call to {@link Context#getEventsForPattern(String) getEventsForPattern(...)} has to find&lt;br/&gt;
    + * the elements that belong to the pattern among the elements stored by the NFA. The cost of this operation can vary,&lt;br/&gt;
    + * so when implementing your condition, try to minimize the times the method is called.&lt;br/&gt;
    + */&lt;br/&gt;
    +public abstract class IterativeCondition&amp;lt;T&amp;gt; implements Function, Serializable {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final long serialVersionUID = 7067817235759351255L;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * The filter function that evaluates the predicate.&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;&lt;br/&gt;
    +	 * &amp;lt;strong&amp;gt;IMPORTANT:&amp;lt;/strong&amp;gt; The system assumes that the function does not&lt;br/&gt;
    +	 * modify the elements on which the predicate is applied. Violating this assumption&lt;br/&gt;
    +	 * can lead to incorrect results.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param value The value to be tested.&lt;br/&gt;
    +	 * @param ctx The {@link Context}
&lt;p&gt; used for the evaluation of the function and provides access to&lt;br/&gt;
    +	 *            the already accepted events in the pattern (see &lt;/p&gt;
{@link Context#getEventsForPattern(String)}
&lt;p&gt;).&lt;br/&gt;
    +	 * @return &lt;/p&gt;
{@code true}
&lt;p&gt; for values that should be retained, &lt;/p&gt;
{@code false}
&lt;p&gt;    +	 * for values to be filtered out.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @throws Exception This method may throw exceptions. Throwing an exception will cause the operation&lt;br/&gt;
    +	 *                   to fail and may trigger recovery.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public abstract boolean filter(T value, Context&amp;lt;T&amp;gt; ctx) throws Exception;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * The context used when evaluating the &lt;/p&gt;
{@link IterativeCondition condition}
&lt;p&gt;.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public interface Context&amp;lt;T&amp;gt; extends Serializable {&lt;br/&gt;
    +&lt;br/&gt;
    +		/**&lt;br/&gt;
    +		 * @return An &lt;/p&gt;
{@link Iterable}
&lt;p&gt; over the already accepted elements&lt;br/&gt;
    +		 * for a given pattern. Elements are iterated in the order the were&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    misspell : the -&amp;gt; they&lt;/p&gt;</comment>
                            <comment id="15944735" author="githubbot" created="Tue, 28 Mar 2017 08:11:27 +0000"  >&lt;p&gt;Github user dawidwys commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108355802&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108355802&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java &amp;#8212;&lt;br/&gt;
    @@ -553,9 +559,38 @@ private int calculateIncreasingSelfState(int ignoreBranches, int takeBranches) &lt;/p&gt;
{
     		return outgoingEdges;
     	}

&lt;p&gt;    +	private boolean checkFilterCondition(ComputationState&amp;lt;T&amp;gt; computationState, IterativeCondition&amp;lt;T&amp;gt; condition, T event) throws Exception &lt;/p&gt;
{
    +		return condition == null || condition.filter(event, computationState.getConditionContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	Map&amp;lt;String, List&amp;lt;T&amp;gt;&amp;gt; extractCurrentMatches(final ComputationState&amp;lt;T&amp;gt; computationState) {&lt;br/&gt;
    +		if (computationState.getPreviousState() == null) &lt;/p&gt;
{
    +			return new HashMap&amp;lt;&amp;gt;();
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Collection&amp;lt;LinkedHashMultimap&amp;lt;String, T&amp;gt;&amp;gt; paths = stringSharedBuffer.extractPatterns(&lt;br/&gt;
    +				computationState.getPreviousState().getName(),&lt;br/&gt;
    +				computationState.getEvent(),&lt;br/&gt;
    +				computationState.getTimestamp(),&lt;br/&gt;
    +				computationState.getVersion());&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private boolean checkFilterCondition(FilterFunction&amp;lt;T&amp;gt; condition, T event) throws Exception {&lt;/li&gt;
	&lt;li&gt;return condition == null || condition.filter(event);&lt;br/&gt;
    +		// for a given computation state, we cannot have more than one matching patterns.&lt;br/&gt;
    +		Preconditions.checkArgument(paths.size() &amp;lt;= 1);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    How about checkState? &lt;/p&gt;</comment>
                            <comment id="15944736" author="githubbot" created="Tue, 28 Mar 2017 08:11:27 +0000"  >&lt;p&gt;Github user dawidwys commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108358091&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108358091&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-cep-scala/src/main/scala/org/apache/flink/cep/scala/pattern/Pattern.scala &amp;#8212;&lt;br/&gt;
    @@ -138,7 +139,7 @@ class Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;T , F &amp;lt;: T&amp;#93;&lt;/span&gt;(jPattern: JPattern&lt;span class=&quot;error&quot;&gt;&amp;#91;T, F&amp;#93;&lt;/span&gt;) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param filter Or filter function&lt;/li&gt;
	&lt;li&gt;@return The same pattern operator where the new filter condition is set&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def or(filter: FilterFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;F&amp;#93;&lt;/span&gt;): Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;T, F&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +  def or(filter: IterativeCondition&lt;span class=&quot;error&quot;&gt;&amp;#91;F&amp;#93;&lt;/span&gt;): Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;T, F&amp;#93;&lt;/span&gt; = {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Missing version accepting lambdas.&lt;/p&gt;</comment>
                            <comment id="15944737" author="githubbot" created="Tue, 28 Mar 2017 08:11:27 +0000"  >&lt;p&gt;Github user dawidwys commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108355851&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108355851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java &amp;#8212;&lt;br/&gt;
    @@ -573,6 +608,9 @@ private boolean checkFilterCondition(FilterFunction&amp;lt;T&amp;gt; condition, T event) throw&lt;br/&gt;
     			computationState.getTimestamp(),&lt;br/&gt;
     			computationState.getVersion());&lt;/p&gt;

&lt;p&gt;    +		// for a given computation state, we cannot have more than one matching patterns.&lt;br/&gt;
    +		Preconditions.checkArgument(paths.size() &amp;lt;= 1);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    How about checkState?&lt;/p&gt;</comment>
                            <comment id="15944738" author="githubbot" created="Tue, 28 Mar 2017 08:11:27 +0000"  >&lt;p&gt;Github user dawidwys commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108352961&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108352961&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/libs/cep.md &amp;#8212;&lt;br/&gt;
    @@ -124,13 +124,70 @@ val start : Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;Event, _&amp;#93;&lt;/span&gt; = Pattern.begin(&quot;start&quot;)&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;    -Each state must have an unique name to identify the matched events later on.&lt;br/&gt;
    +Each state must have a unique name to identify the matched events later on.&lt;br/&gt;
     Additionally, we can specify a filter condition for the event to be accepted as the start event via the `where` method.&lt;br/&gt;
    +These filtering conditions can be either an `IterativeCondition` or a `SimpleCondition`. &lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Iterative Conditions:&lt;/b&gt;* This type of conditions can iterate over the previously accepted elements in the pattern and &lt;br/&gt;
    +decide to accept a new element or not, based on some statistic over those elements. &lt;br/&gt;
    +&lt;br/&gt;
    +Below is the code for an iterative condition that accepts elements whose name start with &quot;foo&quot; and for which, the sum &lt;br/&gt;
    +of the prices of the previously accepted elements for a state named &quot;middle&quot;, plus the price of the current event, do &lt;br/&gt;
    +not exceed the value of 5.0. Iterative condition can be very powerful, especially in combination with quantifiers, e.g.&lt;br/&gt;
    +`oneToMany` or `zeroToMany`.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;codetabs&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;java&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}
&lt;p&gt;    +start.where(new IterativeCondition&amp;lt;SubEvent&amp;gt;() {&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public boolean filter(SubEvent value, Context&amp;lt;SubEvent&amp;gt; ctx) throws Exception {&lt;br/&gt;
    +        if (!value.getName().startsWith(&quot;foo&quot;)) &lt;/p&gt;
{
    +            return false;
    +        }
&lt;p&gt;    +        &lt;br/&gt;
    +        double sum = 0.0;&lt;br/&gt;
    +        for (Event event : ctx.getEventsForPattern(&quot;middle&quot;)) &lt;/p&gt;
{
    +            sum += event.getPrice();
    +        }
&lt;p&gt;    +        sum += value.getPrice();&lt;br/&gt;
    +        return Double.compare(sum, 5.0) &amp;lt; 0;&lt;br/&gt;
    +    }&lt;br/&gt;
    +});&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}
&lt;p&gt;    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;scala&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight scala %}
&lt;p&gt;    +start.where(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I was thinking of some more Scala way of coding it. Maybe:&lt;br/&gt;
    ```&lt;br/&gt;
    Pattern.begin&lt;span class=&quot;error&quot;&gt;&amp;#91;Event&amp;#93;&lt;/span&gt;(&quot;abc&quot;).where(&lt;br/&gt;
          (a, ctx) =&amp;gt; &lt;/p&gt;
{
            lazy val sum = ctx.getEventsForPattern(&quot;a&quot;).asScala.map(_.getPrice).sum
            a.getName.startsWith(&quot;foo&quot;) &amp;amp;&amp;amp; sum + a.getPrice &amp;lt; 5.0
          }
&lt;p&gt;     )&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    Also I would try to make the Scala API more convenient. util.Iterable is not what I would expect. Not sure though if know it is the right moment. We could postpone it to redesigning the API.&lt;/p&gt;</comment>
                            <comment id="15944770" author="githubbot" created="Tue, 28 Mar 2017 08:35:37 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108362971&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108362971&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/libs/cep.md &amp;#8212;&lt;br/&gt;
    @@ -124,13 +124,70 @@ val start : Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;Event, _&amp;#93;&lt;/span&gt; = Pattern.begin(&quot;start&quot;)&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;    -Each state must have an unique name to identify the matched events later on.&lt;br/&gt;
    +Each state must have a unique name to identify the matched events later on.&lt;br/&gt;
     Additionally, we can specify a filter condition for the event to be accepted as the start event via the `where` method.&lt;br/&gt;
    +These filtering conditions can be either an `IterativeCondition` or a `SimpleCondition`. &lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Iterative Conditions:&lt;/b&gt;* This type of conditions can iterate over the previously accepted elements in the pattern and &lt;br/&gt;
    +decide to accept a new element or not, based on some statistic over those elements. &lt;br/&gt;
    +&lt;br/&gt;
    +Below is the code for an iterative condition that accepts elements whose name start with &quot;foo&quot; and for which, the sum &lt;br/&gt;
    +of the prices of the previously accepted elements for a state named &quot;middle&quot;, plus the price of the current event, do &lt;br/&gt;
    +not exceed the value of 5.0. Iterative condition can be very powerful, especially in combination with quantifiers, e.g.&lt;br/&gt;
    +`oneToMany` or `zeroToMany`.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;codetabs&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;java&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}
&lt;p&gt;    +start.where(new IterativeCondition&amp;lt;SubEvent&amp;gt;() {&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public boolean filter(SubEvent value, Context&amp;lt;SubEvent&amp;gt; ctx) throws Exception {&lt;br/&gt;
    +        if (!value.getName().startsWith(&quot;foo&quot;)) &lt;/p&gt;
{
    +            return false;
    +        }
&lt;p&gt;    +        &lt;br/&gt;
    +        double sum = 0.0;&lt;br/&gt;
    +        for (Event event : ctx.getEventsForPattern(&quot;middle&quot;)) &lt;/p&gt;
{
    +            sum += event.getPrice();
    +        }
&lt;p&gt;    +        sum += value.getPrice();&lt;br/&gt;
    +        return Double.compare(sum, 5.0) &amp;lt; 0;&lt;br/&gt;
    +    }&lt;br/&gt;
    +});&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}
&lt;p&gt;    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;scala&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight scala %}
&lt;p&gt;    +start.where(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I agree that this is a lot more scala-ish (apart from the `asScala` part), the only problem is that now we do not show that we should avoid always calling the `getEventsForPattern`.&lt;/p&gt;</comment>
                            <comment id="15944775" author="githubbot" created="Tue, 28 Mar 2017 08:37:59 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108363416&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108363416&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/libs/cep.md &amp;#8212;&lt;br/&gt;
    @@ -124,13 +124,70 @@ val start : Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;Event, _&amp;#93;&lt;/span&gt; = Pattern.begin(&quot;start&quot;)&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;    -Each state must have an unique name to identify the matched events later on.&lt;br/&gt;
    +Each state must have a unique name to identify the matched events later on.&lt;br/&gt;
     Additionally, we can specify a filter condition for the event to be accepted as the start event via the `where` method.&lt;br/&gt;
    +These filtering conditions can be either an `IterativeCondition` or a `SimpleCondition`. &lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Iterative Conditions:&lt;/b&gt;* This type of conditions can iterate over the previously accepted elements in the pattern and &lt;br/&gt;
    +decide to accept a new element or not, based on some statistic over those elements. &lt;br/&gt;
    +&lt;br/&gt;
    +Below is the code for an iterative condition that accepts elements whose name start with &quot;foo&quot; and for which, the sum &lt;br/&gt;
    +of the prices of the previously accepted elements for a state named &quot;middle&quot;, plus the price of the current event, do &lt;br/&gt;
    +not exceed the value of 5.0. Iterative condition can be very powerful, especially in combination with quantifiers, e.g.&lt;br/&gt;
    +`oneToMany` or `zeroToMany`.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;codetabs&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;java&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}
&lt;p&gt;    +start.where(new IterativeCondition&amp;lt;SubEvent&amp;gt;() {&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public boolean filter(SubEvent value, Context&amp;lt;SubEvent&amp;gt; ctx) throws Exception {&lt;br/&gt;
    +        if (!value.getName().startsWith(&quot;foo&quot;)) &lt;/p&gt;
{
    +            return false;
    +        }
&lt;p&gt;    +        &lt;br/&gt;
    +        double sum = 0.0;&lt;br/&gt;
    +        for (Event event : ctx.getEventsForPattern(&quot;middle&quot;)) &lt;/p&gt;
{
    +            sum += event.getPrice();
    +        }
&lt;p&gt;    +        sum += value.getPrice();&lt;br/&gt;
    +        return Double.compare(sum, 5.0) &amp;lt; 0;&lt;br/&gt;
    +    }&lt;br/&gt;
    +});&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}
&lt;p&gt;    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;scala&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight scala %}
&lt;p&gt;    +start.where(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    For the `asScala` part, I will address it in another PR which will see the scala api a bit more globally.&lt;/p&gt;</comment>
                            <comment id="15944781" author="githubbot" created="Tue, 28 Mar 2017 08:43:22 +0000"  >&lt;p&gt;Github user dawidwys commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108364477&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108364477&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/libs/cep.md &amp;#8212;&lt;br/&gt;
    @@ -124,13 +124,70 @@ val start : Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;Event, _&amp;#93;&lt;/span&gt; = Pattern.begin(&quot;start&quot;)&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;    -Each state must have an unique name to identify the matched events later on.&lt;br/&gt;
    +Each state must have a unique name to identify the matched events later on.&lt;br/&gt;
     Additionally, we can specify a filter condition for the event to be accepted as the start event via the `where` method.&lt;br/&gt;
    +These filtering conditions can be either an `IterativeCondition` or a `SimpleCondition`. &lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Iterative Conditions:&lt;/b&gt;* This type of conditions can iterate over the previously accepted elements in the pattern and &lt;br/&gt;
    +decide to accept a new element or not, based on some statistic over those elements. &lt;br/&gt;
    +&lt;br/&gt;
    +Below is the code for an iterative condition that accepts elements whose name start with &quot;foo&quot; and for which, the sum &lt;br/&gt;
    +of the prices of the previously accepted elements for a state named &quot;middle&quot;, plus the price of the current event, do &lt;br/&gt;
    +not exceed the value of 5.0. Iterative condition can be very powerful, especially in combination with quantifiers, e.g.&lt;br/&gt;
    +`oneToMany` or `zeroToMany`.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;codetabs&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;java&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}
&lt;p&gt;    +start.where(new IterativeCondition&amp;lt;SubEvent&amp;gt;() {&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public boolean filter(SubEvent value, Context&amp;lt;SubEvent&amp;gt; ctx) throws Exception {&lt;br/&gt;
    +        if (!value.getName().startsWith(&quot;foo&quot;)) &lt;/p&gt;
{
    +            return false;
    +        }
&lt;p&gt;    +        &lt;br/&gt;
    +        double sum = 0.0;&lt;br/&gt;
    +        for (Event event : ctx.getEventsForPattern(&quot;middle&quot;)) &lt;/p&gt;
{
    +            sum += event.getPrice();
    +        }
&lt;p&gt;    +        sum += value.getPrice();&lt;br/&gt;
    +        return Double.compare(sum, 5.0) &amp;lt; 0;&lt;br/&gt;
    +    }&lt;br/&gt;
    +});&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}
&lt;p&gt;    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;scala&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight scala %}
&lt;p&gt;    +start.where(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    It is not that obvious but the `lazy` keyword plays the role of avoiding calling `getEventsForPattern`. But I agree the java-ish way is more straightforward. &lt;/p&gt;</comment>
                            <comment id="15944783" author="githubbot" created="Tue, 28 Mar 2017 08:44:37 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108364748&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108364748&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/libs/cep.md &amp;#8212;&lt;br/&gt;
    @@ -124,13 +124,70 @@ val start : Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;Event, _&amp;#93;&lt;/span&gt; = Pattern.begin(&quot;start&quot;)&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;    -Each state must have an unique name to identify the matched events later on.&lt;br/&gt;
    +Each state must have a unique name to identify the matched events later on.&lt;br/&gt;
     Additionally, we can specify a filter condition for the event to be accepted as the start event via the `where` method.&lt;br/&gt;
    +These filtering conditions can be either an `IterativeCondition` or a `SimpleCondition`. &lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Iterative Conditions:&lt;/b&gt;* This type of conditions can iterate over the previously accepted elements in the pattern and &lt;br/&gt;
    +decide to accept a new element or not, based on some statistic over those elements. &lt;br/&gt;
    +&lt;br/&gt;
    +Below is the code for an iterative condition that accepts elements whose name start with &quot;foo&quot; and for which, the sum &lt;br/&gt;
    +of the prices of the previously accepted elements for a state named &quot;middle&quot;, plus the price of the current event, do &lt;br/&gt;
    +not exceed the value of 5.0. Iterative condition can be very powerful, especially in combination with quantifiers, e.g.&lt;br/&gt;
    +`oneToMany` or `zeroToMany`.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;codetabs&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;java&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}
&lt;p&gt;    +start.where(new IterativeCondition&amp;lt;SubEvent&amp;gt;() {&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public boolean filter(SubEvent value, Context&amp;lt;SubEvent&amp;gt; ctx) throws Exception {&lt;br/&gt;
    +        if (!value.getName().startsWith(&quot;foo&quot;)) &lt;/p&gt;
{
    +            return false;
    +        }
&lt;p&gt;    +        &lt;br/&gt;
    +        double sum = 0.0;&lt;br/&gt;
    +        for (Event event : ctx.getEventsForPattern(&quot;middle&quot;)) &lt;/p&gt;
{
    +            sum += event.getPrice();
    +        }
&lt;p&gt;    +        sum += value.getPrice();&lt;br/&gt;
    +        return Double.compare(sum, 5.0) &amp;lt; 0;&lt;br/&gt;
    +    }&lt;br/&gt;
    +});&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}
&lt;p&gt;    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;scala&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight scala %}
&lt;p&gt;    +start.where(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    You are right! I am fixing it.&lt;/p&gt;</comment>
                            <comment id="15944785" author="githubbot" created="Tue, 28 Mar 2017 08:47:44 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108365413&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108365413&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-cep-scala/src/main/scala/org/apache/flink/cep/scala/pattern/Pattern.scala &amp;#8212;&lt;br/&gt;
    @@ -138,7 +139,7 @@ class Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;T , F &amp;lt;: T&amp;#93;&lt;/span&gt;(jPattern: JPattern&lt;span class=&quot;error&quot;&gt;&amp;#91;T, F&amp;#93;&lt;/span&gt;) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param filter Or filter function&lt;/li&gt;
	&lt;li&gt;@return The same pattern operator where the new filter condition is set&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def or(filter: FilterFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;F&amp;#93;&lt;/span&gt;): Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;T, F&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +  def or(filter: IterativeCondition&lt;span class=&quot;error&quot;&gt;&amp;#91;F&amp;#93;&lt;/span&gt;): Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;T, F&amp;#93;&lt;/span&gt; = {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Fixing this&lt;/p&gt;</comment>
                            <comment id="15944791" author="githubbot" created="Tue, 28 Mar 2017 08:53:37 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108366616&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108366616&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/libs/cep.md &amp;#8212;&lt;br/&gt;
    @@ -124,13 +124,70 @@ val start : Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;Event, _&amp;#93;&lt;/span&gt; = Pattern.begin(&quot;start&quot;)&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;    -Each state must have an unique name to identify the matched events later on.&lt;br/&gt;
    +Each state must have a unique name to identify the matched events later on.&lt;br/&gt;
     Additionally, we can specify a filter condition for the event to be accepted as the start event via the `where` method.&lt;br/&gt;
    +These filtering conditions can be either an `IterativeCondition` or a `SimpleCondition`. &lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Iterative Conditions:&lt;/b&gt;* This type of conditions can iterate over the previously accepted elements in the pattern and &lt;br/&gt;
    +decide to accept a new element or not, based on some statistic over those elements. &lt;br/&gt;
    +&lt;br/&gt;
    +Below is the code for an iterative condition that accepts elements whose name start with &quot;foo&quot; and for which, the sum &lt;br/&gt;
    +of the prices of the previously accepted elements for a state named &quot;middle&quot;, plus the price of the current event, do &lt;br/&gt;
    +not exceed the value of 5.0. Iterative condition can be very powerful, especially in combination with quantifiers, e.g.&lt;br/&gt;
    +`oneToMany` or `zeroToMany`.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;codetabs&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;java&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}
&lt;p&gt;    +start.where(new IterativeCondition&amp;lt;SubEvent&amp;gt;() {&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public boolean filter(SubEvent value, Context&amp;lt;SubEvent&amp;gt; ctx) throws Exception {&lt;br/&gt;
    +        if (!value.getName().startsWith(&quot;foo&quot;)) &lt;/p&gt;
{
    +            return false;
    +        }
&lt;p&gt;    +        &lt;br/&gt;
    +        double sum = 0.0;&lt;br/&gt;
    +        for (Event event : ctx.getEventsForPattern(&quot;middle&quot;)) &lt;/p&gt;
{
    +            sum += event.getPrice();
    +        }
&lt;p&gt;    +        sum += value.getPrice();&lt;br/&gt;
    +        return Double.compare(sum, 5.0) &amp;lt; 0;&lt;br/&gt;
    +    }&lt;br/&gt;
    +});&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}
&lt;p&gt;    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;scala&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight scala %}
&lt;p&gt;    +start.where(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    BTW why iterable is not what you would expect? What do you think would be a better choice? This is aligned also with our windowing APIs and also I think it is expressive enough.&lt;/p&gt;</comment>
                            <comment id="15944805" author="githubbot" created="Tue, 28 Mar 2017 08:59:51 +0000"  >&lt;p&gt;Github user dawidwys commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108367951&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108367951&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/libs/cep.md &amp;#8212;&lt;br/&gt;
    @@ -124,13 +124,70 @@ val start : Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;Event, _&amp;#93;&lt;/span&gt; = Pattern.begin(&quot;start&quot;)&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;    -Each state must have an unique name to identify the matched events later on.&lt;br/&gt;
    +Each state must have a unique name to identify the matched events later on.&lt;br/&gt;
     Additionally, we can specify a filter condition for the event to be accepted as the start event via the `where` method.&lt;br/&gt;
    +These filtering conditions can be either an `IterativeCondition` or a `SimpleCondition`. &lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Iterative Conditions:&lt;/b&gt;* This type of conditions can iterate over the previously accepted elements in the pattern and &lt;br/&gt;
    +decide to accept a new element or not, based on some statistic over those elements. &lt;br/&gt;
    +&lt;br/&gt;
    +Below is the code for an iterative condition that accepts elements whose name start with &quot;foo&quot; and for which, the sum &lt;br/&gt;
    +of the prices of the previously accepted elements for a state named &quot;middle&quot;, plus the price of the current event, do &lt;br/&gt;
    +not exceed the value of 5.0. Iterative condition can be very powerful, especially in combination with quantifiers, e.g.&lt;br/&gt;
    +`oneToMany` or `zeroToMany`.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;codetabs&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;java&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}
&lt;p&gt;    +start.where(new IterativeCondition&amp;lt;SubEvent&amp;gt;() {&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public boolean filter(SubEvent value, Context&amp;lt;SubEvent&amp;gt; ctx) throws Exception {&lt;br/&gt;
    +        if (!value.getName().startsWith(&quot;foo&quot;)) &lt;/p&gt;
{
    +            return false;
    +        }
&lt;p&gt;    +        &lt;br/&gt;
    +        double sum = 0.0;&lt;br/&gt;
    +        for (Event event : ctx.getEventsForPattern(&quot;middle&quot;)) &lt;/p&gt;
{
    +            sum += event.getPrice();
    +        }
&lt;p&gt;    +        sum += value.getPrice();&lt;br/&gt;
    +        return Double.compare(sum, 5.0) &amp;lt; 0;&lt;br/&gt;
    +    }&lt;br/&gt;
    +});&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}
&lt;p&gt;    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;scala&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight scala %}
&lt;p&gt;    +start.where(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I just meant I would expect scala version of `Iterable` in scala code. Not the java version.&lt;/p&gt;</comment>
                            <comment id="15944815" author="githubbot" created="Tue, 28 Mar 2017 09:02:19 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108368612&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108368612&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/libs/cep.md &amp;#8212;&lt;br/&gt;
    @@ -124,13 +124,70 @@ val start : Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;Event, _&amp;#93;&lt;/span&gt; = Pattern.begin(&quot;start&quot;)&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;    -Each state must have an unique name to identify the matched events later on.&lt;br/&gt;
    +Each state must have a unique name to identify the matched events later on.&lt;br/&gt;
     Additionally, we can specify a filter condition for the event to be accepted as the start event via the `where` method.&lt;br/&gt;
    +These filtering conditions can be either an `IterativeCondition` or a `SimpleCondition`. &lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Iterative Conditions:&lt;/b&gt;* This type of conditions can iterate over the previously accepted elements in the pattern and &lt;br/&gt;
    +decide to accept a new element or not, based on some statistic over those elements. &lt;br/&gt;
    +&lt;br/&gt;
    +Below is the code for an iterative condition that accepts elements whose name start with &quot;foo&quot; and for which, the sum &lt;br/&gt;
    +of the prices of the previously accepted elements for a state named &quot;middle&quot;, plus the price of the current event, do &lt;br/&gt;
    +not exceed the value of 5.0. Iterative condition can be very powerful, especially in combination with quantifiers, e.g.&lt;br/&gt;
    +`oneToMany` or `zeroToMany`.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;codetabs&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;java&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}
&lt;p&gt;    +start.where(new IterativeCondition&amp;lt;SubEvent&amp;gt;() {&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public boolean filter(SubEvent value, Context&amp;lt;SubEvent&amp;gt; ctx) throws Exception {&lt;br/&gt;
    +        if (!value.getName().startsWith(&quot;foo&quot;)) &lt;/p&gt;
{
    +            return false;
    +        }
&lt;p&gt;    +        &lt;br/&gt;
    +        double sum = 0.0;&lt;br/&gt;
    +        for (Event event : ctx.getEventsForPattern(&quot;middle&quot;)) &lt;/p&gt;
{
    +            sum += event.getPrice();
    +        }
&lt;p&gt;    +        sum += value.getPrice();&lt;br/&gt;
    +        return Double.compare(sum, 5.0) &amp;lt; 0;&lt;br/&gt;
    +    }&lt;br/&gt;
    +});&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}
&lt;p&gt;    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;scala&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight scala %}
&lt;p&gt;    +start.where(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I see! Then we are on the same page. I was also thinking for the scala API to create a scala version of the `IterativeCondition` and then have a wrapper to expose it as a java `IterativeCondition`. This way we can wrap everything in more scala-flavored structures.&lt;/p&gt;</comment>
                            <comment id="15944824" author="githubbot" created="Tue, 28 Mar 2017 09:07:30 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108369790&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108369790&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java &amp;#8212;&lt;br/&gt;
    @@ -553,9 +559,38 @@ private int calculateIncreasingSelfState(int ignoreBranches, int takeBranches) &lt;/p&gt;
{
     		return outgoingEdges;
     	}

&lt;p&gt;    +	private boolean checkFilterCondition(ComputationState&amp;lt;T&amp;gt; computationState, IterativeCondition&amp;lt;T&amp;gt; condition, T event) throws Exception &lt;/p&gt;
{
    +		return condition == null || condition.filter(event, computationState.getConditionContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	Map&amp;lt;String, List&amp;lt;T&amp;gt;&amp;gt; extractCurrentMatches(final ComputationState&amp;lt;T&amp;gt; computationState) {&lt;br/&gt;
    +		if (computationState.getPreviousState() == null) &lt;/p&gt;
{
    +			return new HashMap&amp;lt;&amp;gt;();
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Collection&amp;lt;LinkedHashMultimap&amp;lt;String, T&amp;gt;&amp;gt; paths = stringSharedBuffer.extractPatterns(&lt;br/&gt;
    +				computationState.getPreviousState().getName(),&lt;br/&gt;
    +				computationState.getEvent(),&lt;br/&gt;
    +				computationState.getTimestamp(),&lt;br/&gt;
    +				computationState.getVersion());&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private boolean checkFilterCondition(FilterFunction&amp;lt;T&amp;gt; condition, T event) throws Exception {&lt;/li&gt;
	&lt;li&gt;return condition == null || condition.filter(event);&lt;br/&gt;
    +		// for a given computation state, we cannot have more than one matching patterns.&lt;br/&gt;
    +		Preconditions.checkArgument(paths.size() &amp;lt;= 1);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Fixing this&lt;/p&gt;</comment>
                            <comment id="15944826" author="githubbot" created="Tue, 28 Mar 2017 09:07:40 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108369832&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108369832&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java &amp;#8212;&lt;br/&gt;
    @@ -573,6 +608,9 @@ private boolean checkFilterCondition(FilterFunction&amp;lt;T&amp;gt; condition, T event) throw&lt;br/&gt;
     			computationState.getTimestamp(),&lt;br/&gt;
     			computationState.getVersion());&lt;/p&gt;

&lt;p&gt;    +		// for a given computation state, we cannot have more than one matching patterns.&lt;br/&gt;
    +		Preconditions.checkArgument(paths.size() &amp;lt;= 1);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Fixing this&lt;/p&gt;</comment>
                            <comment id="15944832" author="githubbot" created="Tue, 28 Mar 2017 09:10:43 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for the review @dawidwys ! I integrated the comments. I will wait for travis and then merge.&lt;/p&gt;</comment>
                            <comment id="15944847" author="githubbot" created="Tue, 28 Mar 2017 09:18:17 +0000"  >&lt;p&gt;Github user dawidwys commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624#discussion_r108372187&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624#discussion_r108372187&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/libs/cep.md &amp;#8212;&lt;br/&gt;
    @@ -124,13 +124,70 @@ val start : Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;Event, _&amp;#93;&lt;/span&gt; = Pattern.begin(&quot;start&quot;)&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;br/&gt;
     &amp;lt;/div&amp;gt;&lt;/p&gt;

&lt;p&gt;    -Each state must have an unique name to identify the matched events later on.&lt;br/&gt;
    +Each state must have a unique name to identify the matched events later on.&lt;br/&gt;
     Additionally, we can specify a filter condition for the event to be accepted as the start event via the `where` method.&lt;br/&gt;
    +These filtering conditions can be either an `IterativeCondition` or a `SimpleCondition`. &lt;br/&gt;
    +&lt;br/&gt;
    +*&lt;b&gt;Iterative Conditions:&lt;/b&gt;* This type of conditions can iterate over the previously accepted elements in the pattern and &lt;br/&gt;
    +decide to accept a new element or not, based on some statistic over those elements. &lt;br/&gt;
    +&lt;br/&gt;
    +Below is the code for an iterative condition that accepts elements whose name start with &quot;foo&quot; and for which, the sum &lt;br/&gt;
    +of the prices of the previously accepted elements for a state named &quot;middle&quot;, plus the price of the current event, do &lt;br/&gt;
    +not exceed the value of 5.0. Iterative condition can be very powerful, especially in combination with quantifiers, e.g.&lt;br/&gt;
    +`oneToMany` or `zeroToMany`.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;codetabs&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;java&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}
&lt;p&gt;    +start.where(new IterativeCondition&amp;lt;SubEvent&amp;gt;() {&lt;br/&gt;
    +    @Override&lt;br/&gt;
    +    public boolean filter(SubEvent value, Context&amp;lt;SubEvent&amp;gt; ctx) throws Exception {&lt;br/&gt;
    +        if (!value.getName().startsWith(&quot;foo&quot;)) &lt;/p&gt;
{
    +            return false;
    +        }
&lt;p&gt;    +        &lt;br/&gt;
    +        double sum = 0.0;&lt;br/&gt;
    +        for (Event event : ctx.getEventsForPattern(&quot;middle&quot;)) &lt;/p&gt;
{
    +            sum += event.getPrice();
    +        }
&lt;p&gt;    +        sum += value.getPrice();&lt;br/&gt;
    +        return Double.compare(sum, 5.0) &amp;lt; 0;&lt;br/&gt;
    +    }&lt;br/&gt;
    +});&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}
&lt;p&gt;    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div data-lang=&quot;scala&quot; markdown=&quot;1&quot;&amp;gt;&lt;br/&gt;
    +&lt;/p&gt;
{% highlight scala %}
&lt;p&gt;    +start.where(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    The other option would be to have just scala wrapper around `Context` and use it in the methods accepting lambdas. Underneath it would be used in IterativeCondition. Not sure if the methods accepting objects e.g. `IterativeCondition` in Scala would be used at all.&lt;/p&gt;

&lt;p&gt;    E.g.&lt;br/&gt;
    ```&lt;br/&gt;
    where( filterFun: (K, ScalaContext&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;) =&amp;gt; Boolean) : Pattern&lt;span class=&quot;error&quot;&gt;&amp;#91;T, F&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
        val filter = new IterativeCondition&lt;span class=&quot;error&quot;&gt;&amp;#91;F&amp;#93;&lt;/span&gt; &lt;/p&gt;
{
          val cleanFilter = cep.scala.cleanClosure(filterFun)
    
          override def filter(value: F, ctx: Context[F]): Boolean = cleanFilter(value, ScalaContext(ctx))
        }
&lt;p&gt;        where(filter)&lt;br/&gt;
    }&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="15945446" author="githubbot" created="Tue, 28 Mar 2017 16:04:36 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3624&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3624&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15945452" author="kkl0u" created="Tue, 28 Mar 2017 16:10:25 +0000"  >&lt;p&gt;Merged with ad21a441434b9ac5886b664871553bf57885e984&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 34 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3cu9r:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>