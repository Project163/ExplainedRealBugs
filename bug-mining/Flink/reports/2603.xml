<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:34:41 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-10187] Fix LogicalUnnestRule to match Correlate/Uncollect correctly</title>
                <link>https://issues.apache.org/jira/browse/FLINK-10187</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description></description>
                <environment></environment>
        <key id="13180128">FLINK-10187</key>
            <summary>Fix LogicalUnnestRule to match Correlate/Uncollect correctly</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="suez1224">Shuyi Chen</assignee>
                                    <reporter username="suez1224">Shuyi Chen</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Tue, 21 Aug 2018 06:27:38 +0000</created>
                <updated>Tue, 21 Aug 2018 22:26:36 +0000</updated>
                            <resolved>Tue, 21 Aug 2018 22:26:36 +0000</resolved>
                                    <version>1.6.0</version>
                                    <fixVersion>1.7.0</fixVersion>
                                    <component>Table SQL / API</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16587012" author="githubbot" created="Tue, 21 Aug 2018 06:34:06 +0000"  >&lt;p&gt;suez1224 opened a new pull request #6592: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10187&quot; title=&quot;Fix LogicalUnnestRule to match Correlate/Uncollect correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10187&quot;&gt;&lt;del&gt;FLINK-10187&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Table API &amp;amp; SQL&amp;#93;&lt;/span&gt; Fix LogicalUnnestRule to match correlate-&amp;gt;...&lt;del&gt;&amp;gt;project&lt;/del&gt;&amp;gt;uncollect cor&#8230;&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6592&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6592&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   &lt;b&gt;Fix LogicalUnnestRule to also match correlate-&amp;gt;...&lt;del&gt;&amp;gt;project&lt;/del&gt;&amp;gt;uncollect correctly after upgrading to use Calcite 1.17&lt;/b&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   &lt;b&gt;(for example&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Remove SqlToRelConverter copy in Flink repo&lt;/li&gt;
	&lt;li&gt;Fix LogicalUnnestRule to also match  correlate-&amp;gt;...&lt;del&gt;&amp;gt;project&lt;/del&gt;&amp;gt;uncollect correctly&lt;/li&gt;
&lt;/ul&gt;



&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   This change is already covered by existing tests&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): ( no)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: ( no)&lt;/li&gt;
	&lt;li&gt;The serializers: ( no)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (no)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (no)&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: ( no)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (no)&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? (not applicable)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16587979" author="githubbot" created="Tue, 21 Aug 2018 20:39:51 +0000"  >&lt;p&gt;fhueske commented on issue #6592: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10187&quot; title=&quot;Fix LogicalUnnestRule to match Correlate/Uncollect correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10187&quot;&gt;&lt;del&gt;FLINK-10187&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;table&amp;#93;&lt;/span&gt; Fix LogicalUnnestRule to match correlate-&amp;gt;...&lt;del&gt;&amp;gt;project&lt;/del&gt;&amp;gt;uncollect cor&#8230;&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6592#issuecomment-414814367&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6592#issuecomment-414814367&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Thanks for the PR @suez1224!&lt;/p&gt;

&lt;p&gt;   Merging&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16588086" author="githubbot" created="Tue, 21 Aug 2018 22:26:32 +0000"  >&lt;p&gt;asfgit closed pull request #6592: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10187&quot; title=&quot;Fix LogicalUnnestRule to match Correlate/Uncollect correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10187&quot;&gt;&lt;del&gt;FLINK-10187&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;table&amp;#93;&lt;/span&gt; Fix LogicalUnnestRule to match correlate-&amp;gt;...&lt;del&gt;&amp;gt;project&lt;/del&gt;&amp;gt;uncollect cor&#8230;&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6592&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6592&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/flink-libraries/flink-table/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java b/flink-libraries/flink-table/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java&lt;br/&gt;
deleted file mode 100644&lt;br/&gt;
index 564e9725cfc..00000000000&lt;br/&gt;
&amp;#8212; a/flink-libraries/flink-table/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java&lt;br/&gt;
+++ /dev/null&lt;br/&gt;
@@ -1,5619 +0,0 @@&lt;br/&gt;
-/*&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Licensed to the Apache Software Foundation (ASF) under one or more&lt;/li&gt;
	&lt;li&gt;* contributor license agreements.  See the NOTICE file distributed with&lt;/li&gt;
	&lt;li&gt;* this work for additional information regarding copyright ownership.&lt;/li&gt;
	&lt;li&gt;* The ASF licenses this file to you under the Apache License, Version 2.0&lt;/li&gt;
	&lt;li&gt;* (the &quot;License&quot;); you may not use this file except in compliance with&lt;/li&gt;
	&lt;li&gt;* the License.  You may obtain a copy of the License at&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* Unless required by applicable law or agreed to in writing, software&lt;/li&gt;
	&lt;li&gt;* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;/li&gt;
	&lt;li&gt;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;* See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;* limitations under the License.&lt;/li&gt;
	&lt;li&gt;*/&lt;br/&gt;
-package org.apache.calcite.sql2rel;&lt;br/&gt;
-&lt;br/&gt;
-import org.apache.calcite.avatica.util.Spaces;&lt;br/&gt;
-import org.apache.calcite.linq4j.Ord;&lt;br/&gt;
-import org.apache.calcite.plan.Convention;&lt;br/&gt;
-import org.apache.calcite.plan.RelOptCluster;&lt;br/&gt;
-import org.apache.calcite.plan.RelOptPlanner;&lt;br/&gt;
-import org.apache.calcite.plan.RelOptSamplingParameters;&lt;br/&gt;
-import org.apache.calcite.plan.RelOptTable;&lt;br/&gt;
-import org.apache.calcite.plan.RelOptUtil;&lt;br/&gt;
-import org.apache.calcite.plan.RelTraitSet;&lt;br/&gt;
-import org.apache.calcite.prepare.Prepare;&lt;br/&gt;
-import org.apache.calcite.prepare.RelOptTableImpl;&lt;br/&gt;
-import org.apache.calcite.rel.RelCollation;&lt;br/&gt;
-import org.apache.calcite.rel.RelCollationTraitDef;&lt;br/&gt;
-import org.apache.calcite.rel.RelCollations;&lt;br/&gt;
-import org.apache.calcite.rel.RelFieldCollation;&lt;br/&gt;
-import org.apache.calcite.rel.RelNode;&lt;br/&gt;
-import org.apache.calcite.rel.RelRoot;&lt;br/&gt;
-import org.apache.calcite.rel.SingleRel;&lt;br/&gt;
-import org.apache.calcite.rel.core.AggregateCall;&lt;br/&gt;
-import org.apache.calcite.rel.core.Collect;&lt;br/&gt;
-import org.apache.calcite.rel.core.CorrelationId;&lt;br/&gt;
-import org.apache.calcite.rel.core.Filter;&lt;br/&gt;
-import org.apache.calcite.rel.core.Join;&lt;br/&gt;
-import org.apache.calcite.rel.core.JoinInfo;&lt;br/&gt;
-import org.apache.calcite.rel.core.JoinRelType;&lt;br/&gt;
-import org.apache.calcite.rel.core.Project;&lt;br/&gt;
-import org.apache.calcite.rel.core.RelFactories;&lt;br/&gt;
-import org.apache.calcite.rel.core.Sample;&lt;br/&gt;
-import org.apache.calcite.rel.core.Sort;&lt;br/&gt;
-import org.apache.calcite.rel.core.Uncollect;&lt;br/&gt;
-import org.apache.calcite.rel.core.Values;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalAggregate;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalCorrelate;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalFilter;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalIntersect;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalJoin;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalMatch;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalMinus;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalProject;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalSort;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalTableFunctionScan;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalTableModify;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalTableScan;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalUnion;&lt;br/&gt;
-import org.apache.calcite.rel.logical.LogicalValues;&lt;br/&gt;
-import org.apache.calcite.rel.metadata.JaninoRelMetadataProvider;&lt;br/&gt;
-import org.apache.calcite.rel.metadata.RelColumnMapping;&lt;br/&gt;
-import org.apache.calcite.rel.metadata.RelMetadataQuery;&lt;br/&gt;
-import org.apache.calcite.rel.stream.Delta;&lt;br/&gt;
-import org.apache.calcite.rel.stream.LogicalDelta;&lt;br/&gt;
-import org.apache.calcite.rel.type.RelDataType;&lt;br/&gt;
-import org.apache.calcite.rel.type.RelDataTypeFactory;&lt;br/&gt;
-import org.apache.calcite.rel.type.RelDataTypeField;&lt;br/&gt;
-import org.apache.calcite.rex.RexBuilder;&lt;br/&gt;
-import org.apache.calcite.rex.RexCall;&lt;br/&gt;
-import org.apache.calcite.rex.RexCallBinding;&lt;br/&gt;
-import org.apache.calcite.rex.RexCorrelVariable;&lt;br/&gt;
-import org.apache.calcite.rex.RexDynamicParam;&lt;br/&gt;
-import org.apache.calcite.rex.RexFieldAccess;&lt;br/&gt;
-import org.apache.calcite.rex.RexFieldCollation;&lt;br/&gt;
-import org.apache.calcite.rex.RexInputRef;&lt;br/&gt;
-import org.apache.calcite.rex.RexLiteral;&lt;br/&gt;
-import org.apache.calcite.rex.RexNode;&lt;br/&gt;
-import org.apache.calcite.rex.RexPatternFieldRef;&lt;br/&gt;
-import org.apache.calcite.rex.RexRangeRef;&lt;br/&gt;
-import org.apache.calcite.rex.RexShuttle;&lt;br/&gt;
-import org.apache.calcite.rex.RexSubQuery;&lt;br/&gt;
-import org.apache.calcite.rex.RexUtil;&lt;br/&gt;
-import org.apache.calcite.rex.RexWindowBound;&lt;br/&gt;
-import org.apache.calcite.schema.ColumnStrategy;&lt;br/&gt;
-import org.apache.calcite.schema.ModifiableTable;&lt;br/&gt;
-import org.apache.calcite.schema.ModifiableView;&lt;br/&gt;
-import org.apache.calcite.schema.Table;&lt;br/&gt;
-import org.apache.calcite.schema.TranslatableTable;&lt;br/&gt;
-import org.apache.calcite.schema.Wrapper;&lt;br/&gt;
-import org.apache.calcite.sql.JoinConditionType;&lt;br/&gt;
-import org.apache.calcite.sql.JoinType;&lt;br/&gt;
-import org.apache.calcite.sql.SemiJoinType;&lt;br/&gt;
-import org.apache.calcite.sql.SqlAggFunction;&lt;br/&gt;
-import org.apache.calcite.sql.SqlBasicCall;&lt;br/&gt;
-import org.apache.calcite.sql.SqlCall;&lt;br/&gt;
-import org.apache.calcite.sql.SqlCallBinding;&lt;br/&gt;
-import org.apache.calcite.sql.SqlDataTypeSpec;&lt;br/&gt;
-import org.apache.calcite.sql.SqlDelete;&lt;br/&gt;
-import org.apache.calcite.sql.SqlDynamicParam;&lt;br/&gt;
-import org.apache.calcite.sql.SqlExplainFormat;&lt;br/&gt;
-import org.apache.calcite.sql.SqlExplainLevel;&lt;br/&gt;
-import org.apache.calcite.sql.SqlFunction;&lt;br/&gt;
-import org.apache.calcite.sql.SqlIdentifier;&lt;br/&gt;
-import org.apache.calcite.sql.SqlInsert;&lt;br/&gt;
-import org.apache.calcite.sql.SqlIntervalQualifier;&lt;br/&gt;
-import org.apache.calcite.sql.SqlJoin;&lt;br/&gt;
-import org.apache.calcite.sql.SqlKind;&lt;br/&gt;
-import org.apache.calcite.sql.SqlLiteral;&lt;br/&gt;
-import org.apache.calcite.sql.SqlMatchRecognize;&lt;br/&gt;
-import org.apache.calcite.sql.SqlMerge;&lt;br/&gt;
-import org.apache.calcite.sql.SqlNode;&lt;br/&gt;
-import org.apache.calcite.sql.SqlNodeList;&lt;br/&gt;
-import org.apache.calcite.sql.SqlNumericLiteral;&lt;br/&gt;
-import org.apache.calcite.sql.SqlOperator;&lt;br/&gt;
-import org.apache.calcite.sql.SqlOperatorTable;&lt;br/&gt;
-import org.apache.calcite.sql.SqlOrderBy;&lt;br/&gt;
-import org.apache.calcite.sql.SqlSampleSpec;&lt;br/&gt;
-import org.apache.calcite.sql.SqlSelect;&lt;br/&gt;
-import org.apache.calcite.sql.SqlSelectKeyword;&lt;br/&gt;
-import org.apache.calcite.sql.SqlSetOperator;&lt;br/&gt;
-import org.apache.calcite.sql.SqlUnnestOperator;&lt;br/&gt;
-import org.apache.calcite.sql.SqlUpdate;&lt;br/&gt;
-import org.apache.calcite.sql.SqlUtil;&lt;br/&gt;
-import org.apache.calcite.sql.SqlValuesOperator;&lt;br/&gt;
-import org.apache.calcite.sql.SqlWindow;&lt;br/&gt;
-import org.apache.calcite.sql.SqlWith;&lt;br/&gt;
-import org.apache.calcite.sql.SqlWithItem;&lt;br/&gt;
-import org.apache.calcite.sql.fun.SqlCountAggFunction;&lt;br/&gt;
-import org.apache.calcite.sql.fun.SqlInOperator;&lt;br/&gt;
-import org.apache.calcite.sql.fun.SqlQuantifyOperator;&lt;br/&gt;
-import org.apache.calcite.sql.fun.SqlRowOperator;&lt;br/&gt;
-import org.apache.calcite.sql.fun.SqlStdOperatorTable;&lt;br/&gt;
-import org.apache.calcite.sql.parser.SqlParserPos;&lt;br/&gt;
-import org.apache.calcite.sql.type.SqlReturnTypeInference;&lt;br/&gt;
-import org.apache.calcite.sql.type.SqlTypeName;&lt;br/&gt;
-import org.apache.calcite.sql.type.SqlTypeUtil;&lt;br/&gt;
-import org.apache.calcite.sql.type.TableFunctionReturnTypeInference;&lt;br/&gt;
-import org.apache.calcite.sql.util.SqlBasicVisitor;&lt;br/&gt;
-import org.apache.calcite.sql.util.SqlVisitor;&lt;br/&gt;
-import org.apache.calcite.sql.validate.AggregatingSelectScope;&lt;br/&gt;
-import org.apache.calcite.sql.validate.CollectNamespace;&lt;br/&gt;
-import org.apache.calcite.sql.validate.DelegatingScope;&lt;br/&gt;
-import org.apache.calcite.sql.validate.ListScope;&lt;br/&gt;
-import org.apache.calcite.sql.validate.MatchRecognizeScope;&lt;br/&gt;
-import org.apache.calcite.sql.validate.ParameterScope;&lt;br/&gt;
-import org.apache.calcite.sql.validate.SelectScope;&lt;br/&gt;
-import org.apache.calcite.sql.validate.SqlMonotonicity;&lt;br/&gt;
-import org.apache.calcite.sql.validate.SqlNameMatcher;&lt;br/&gt;
-import org.apache.calcite.sql.validate.SqlQualified;&lt;br/&gt;
-import org.apache.calcite.sql.validate.SqlUserDefinedTableFunction;&lt;br/&gt;
-import org.apache.calcite.sql.validate.SqlUserDefinedTableMacro;&lt;br/&gt;
-import org.apache.calcite.sql.validate.SqlValidator;&lt;br/&gt;
-import org.apache.calcite.sql.validate.SqlValidatorImpl;&lt;br/&gt;
-import org.apache.calcite.sql.validate.SqlValidatorNamespace;&lt;br/&gt;
-import org.apache.calcite.sql.validate.SqlValidatorScope;&lt;br/&gt;
-import org.apache.calcite.sql.validate.SqlValidatorTable;&lt;br/&gt;
-import org.apache.calcite.sql.validate.SqlValidatorUtil;&lt;br/&gt;
-import org.apache.calcite.tools.RelBuilder;&lt;br/&gt;
-import org.apache.calcite.tools.RelBuilderFactory;&lt;br/&gt;
-import org.apache.calcite.util.ImmutableBitSet;&lt;br/&gt;
-import org.apache.calcite.util.ImmutableIntList;&lt;br/&gt;
-import org.apache.calcite.util.Litmus;&lt;br/&gt;
-import org.apache.calcite.util.NlsString;&lt;br/&gt;
-import org.apache.calcite.util.NumberUtil;&lt;br/&gt;
-import org.apache.calcite.util.Pair;&lt;br/&gt;
-import org.apache.calcite.util.Util;&lt;br/&gt;
-import org.apache.calcite.util.trace.CalciteTrace;&lt;br/&gt;
-&lt;br/&gt;
-import com.google.common.base.Preconditions;&lt;br/&gt;
-import com.google.common.collect.ImmutableList;&lt;br/&gt;
-import com.google.common.collect.ImmutableList.Builder;&lt;br/&gt;
-import com.google.common.collect.ImmutableMap;&lt;br/&gt;
-import com.google.common.collect.ImmutableSet;&lt;br/&gt;
-import com.google.common.collect.Iterables;&lt;br/&gt;
-&lt;br/&gt;
-import org.slf4j.Logger;&lt;br/&gt;
-&lt;br/&gt;
-import java.lang.reflect.Type;&lt;br/&gt;
-import java.math.BigDecimal;&lt;br/&gt;
-import java.util.AbstractList;&lt;br/&gt;
-import java.util.ArrayDeque;&lt;br/&gt;
-import java.util.ArrayList;&lt;br/&gt;
-import java.util.Collection;&lt;br/&gt;
-import java.util.Collections;&lt;br/&gt;
-import java.util.Deque;&lt;br/&gt;
-import java.util.EnumSet;&lt;br/&gt;
-import java.util.HashMap;&lt;br/&gt;
-import java.util.HashSet;&lt;br/&gt;
-import java.util.LinkedHashSet;&lt;br/&gt;
-import java.util.List;&lt;br/&gt;
-import java.util.Map;&lt;br/&gt;
-import java.util.Objects;&lt;br/&gt;
-import java.util.Set;&lt;br/&gt;
-import java.util.TreeSet;&lt;br/&gt;
-import java.util.function.Supplier;&lt;br/&gt;
-&lt;br/&gt;
-import static org.apache.calcite.sql.SqlUtil.stripAs;&lt;br/&gt;
-&lt;br/&gt;
-/**&lt;/li&gt;
	&lt;li&gt;* THIS FILE HAS BEEN COPIED FROM THE APACHE CALCITE PROJECT UNTIL &lt;a href=&quot;https://issues.apache.org/jira/browse/CALCITE-2440&quot; title=&quot;SQL with UNNEST fail in volcano planner in some cases&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CALCITE-2440&quot;&gt;&lt;del&gt;CALCITE-2440&lt;/del&gt;&lt;/a&gt; is fixed.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* The following IT tests will fail.&lt;/li&gt;
	&lt;li&gt;*  - AggregateITCase.testTumbleWindowAggregateWithCollectUnnest&lt;/li&gt;
	&lt;li&gt;*  - JoinITCase.testCrossWithUnnest&lt;/li&gt;
	&lt;li&gt;*  - JoinITCase.testJoinWithUnnestOfTuple&lt;/li&gt;
	&lt;li&gt;*  - SqlITCase.testLeftUnnestMultiSetFromCollectResult&lt;/li&gt;
	&lt;li&gt;*  - SqlITCase.testUnnestArrayOfArrayFromTable&lt;/li&gt;
	&lt;li&gt;*  - SqlITCase.testUnnestMultiSetFromCollectResult&lt;/li&gt;
	&lt;li&gt;*  - SqlITCase.testUnnestObjectArrayFromTableWithFilter&lt;/li&gt;
	&lt;li&gt;*  - SqlITCase.testUnnestPrimitiveArrayFromTable&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* Converts a SQL parse tree (consisting of&lt;/li&gt;
	&lt;li&gt;* 
{@link org.apache.calcite.sql.SqlNode}
&lt;p&gt; objects) into a relational algebra&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;* expression (consisting of 
{@link org.apache.calcite.rel.RelNode}
&lt;p&gt; objects).&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;The public entry points are: 
{@link #convertQuery},&lt;br/&gt;
- * {@link #convertExpression(SqlNode)}.&lt;br/&gt;
- */&lt;br/&gt;
-public class SqlToRelConverter {&lt;br/&gt;
-	//~ Static fields/initializers ---------------------------------------------&lt;br/&gt;
-&lt;br/&gt;
-	protected static final Logger SQL2REL_LOGGER =&lt;br/&gt;
-			CalciteTrace.getSqlToRelTracer();&lt;br/&gt;
-&lt;br/&gt;
-	private static final BigDecimal TWO = BigDecimal.valueOf(2L);&lt;br/&gt;
-&lt;br/&gt;
-	/** Size of the smallest IN list that will be converted to a semijoin to a&lt;br/&gt;
-	 * static table. */&lt;br/&gt;
-	public static final int DEFAULT_IN_SUB_QUERY_THRESHOLD = 20;&lt;br/&gt;
-&lt;br/&gt;
-	@Deprecated // to be removed before 2.0&lt;br/&gt;
-	public static final int DEFAULT_IN_SUBQUERY_THRESHOLD =&lt;br/&gt;
-			DEFAULT_IN_SUB_QUERY_THRESHOLD;&lt;br/&gt;
-&lt;br/&gt;
-	//~ Instance fields --------------------------------------------------------&lt;br/&gt;
-&lt;br/&gt;
-	protected final SqlValidator validator;&lt;br/&gt;
-	protected final RexBuilder rexBuilder;&lt;br/&gt;
-	protected final Prepare.CatalogReader catalogReader;&lt;br/&gt;
-	protected final RelOptCluster cluster;&lt;br/&gt;
-	private SubQueryConverter subQueryConverter;&lt;br/&gt;
-	protected final List&amp;lt;RelNode&amp;gt; leaves = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-	private final List&amp;lt;SqlDynamicParam&amp;gt; dynamicParamSqlNodes = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-	private final SqlOperatorTable opTab;&lt;br/&gt;
-	protected final RelDataTypeFactory typeFactory;&lt;br/&gt;
-	private final SqlNodeToRexConverter exprConverter;&lt;br/&gt;
-	private int explainParamCount;&lt;br/&gt;
-	public final SqlToRelConverter.Config config;&lt;br/&gt;
-	private final RelBuilder relBuilder;&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Fields used in name resolution for correlated sub-queries.&lt;br/&gt;
-	 */&lt;br/&gt;
-	private final Map&amp;lt;CorrelationId, DeferredLookup&amp;gt; mapCorrelToDeferred =&lt;br/&gt;
-			new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Stack of names of datasets requested by the &amp;lt;code&amp;gt;&lt;br/&gt;
-	 * TABLE(SAMPLE(&amp;lt;datasetName&amp;gt;, &amp;lt;query&amp;gt;))&amp;lt;/code&amp;gt; construct.&lt;br/&gt;
-	 */&lt;br/&gt;
-	private final Deque&amp;lt;String&amp;gt; datasetStack = new ArrayDeque&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Mapping of non-correlated sub-queries that have been converted to their&lt;br/&gt;
-	 * equivalent constants. Used to avoid re-evaluating the sub-query if it&apos;s&lt;br/&gt;
-	 * already been evaluated.&lt;br/&gt;
-	 */&lt;br/&gt;
-	private final Map&amp;lt;SqlNode, RexNode&amp;gt; mapConvertedNonCorrSubqs =&lt;br/&gt;
-			new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;br/&gt;
-	public final RelOptTable.ViewExpander viewExpander;&lt;br/&gt;
-&lt;br/&gt;
-	//~ Constructors -----------------------------------------------------------&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Creates a converter.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param viewExpander    Preparing statement&lt;br/&gt;
-	 * @param validator       Validator&lt;br/&gt;
-	 * @param catalogReader   Schema&lt;br/&gt;
-	 * @param planner         Planner&lt;br/&gt;
-	 * @param rexBuilder      Rex builder&lt;br/&gt;
-	 * @param convertletTable Expression converter&lt;br/&gt;
-	 */&lt;br/&gt;
-	@Deprecated // to be removed before 2.0&lt;br/&gt;
-	public SqlToRelConverter(&lt;br/&gt;
-			RelOptTable.ViewExpander viewExpander,&lt;br/&gt;
-			SqlValidator validator,&lt;br/&gt;
-			Prepare.CatalogReader catalogReader,&lt;br/&gt;
-			RelOptPlanner planner,&lt;br/&gt;
-			RexBuilder rexBuilder,&lt;br/&gt;
-			SqlRexConvertletTable convertletTable) {
-		this(viewExpander, validator, catalogReader,
-				RelOptCluster.create(planner, rexBuilder), convertletTable,
-				Config.DEFAULT);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	@Deprecated // to be removed before 2.0&lt;br/&gt;
-	public SqlToRelConverter(&lt;br/&gt;
-			RelOptTable.ViewExpander viewExpander,&lt;br/&gt;
-			SqlValidator validator,&lt;br/&gt;
-			Prepare.CatalogReader catalogReader,&lt;br/&gt;
-			RelOptCluster cluster,&lt;br/&gt;
-			SqlRexConvertletTable convertletTable) {
-		this(viewExpander, validator, catalogReader, cluster, convertletTable,
-				Config.DEFAULT);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/* Creates a converter. */&lt;br/&gt;
-	public SqlToRelConverter(&lt;br/&gt;
-			RelOptTable.ViewExpander viewExpander,&lt;br/&gt;
-			SqlValidator validator,&lt;br/&gt;
-			Prepare.CatalogReader catalogReader,&lt;br/&gt;
-			RelOptCluster cluster,&lt;br/&gt;
-			SqlRexConvertletTable convertletTable,&lt;br/&gt;
-			Config config) {
-		this.viewExpander = viewExpander;
-		this.opTab =
-				(validator
-						== null) ? SqlStdOperatorTable.instance()
-						: validator.getOperatorTable();
-		this.validator = validator;
-		this.catalogReader = catalogReader;
-		this.subQueryConverter = new NoOpSubQueryConverter();
-		this.rexBuilder = cluster.getRexBuilder();
-		this.typeFactory = rexBuilder.getTypeFactory();
-		this.cluster = Objects.requireNonNull(cluster);
-		this.exprConverter = new SqlNodeToRexConverterImpl(convertletTable);
-		this.explainParamCount = 0;
-		this.config = new ConfigBuilder().withConfig(config).build();
-		this.relBuilder = config.getRelBuilderFactory().create(cluster, null);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	//~ Methods ----------------------------------------------------------------&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * @return the RelOptCluster in use.&lt;br/&gt;
-	 */&lt;br/&gt;
-	public RelOptCluster getCluster() {
-		return cluster;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Returns the row-expression builder.&lt;br/&gt;
-	 */&lt;br/&gt;
-	public RexBuilder getRexBuilder() {
-		return rexBuilder;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Returns the number of dynamic parameters encountered during translation;&lt;br/&gt;
-	 * this must only be called after {@link #convertQuery}
&lt;p&gt;.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @return number of dynamic parameters&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public int getDynamicParamCount() 
{
-		return dynamicParamSqlNodes.size();
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Returns the type inferred for a dynamic parameter.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param index 0-based index of dynamic parameter&lt;/li&gt;
	&lt;li&gt;* @return inferred type, never null&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public RelDataType getDynamicParamType(int index) {&lt;/li&gt;
	&lt;li&gt;SqlNode sqlNode = dynamicParamSqlNodes.get(index);&lt;/li&gt;
	&lt;li&gt;if (sqlNode == null) 
{
-			throw Util.needToImplement(&quot;dynamic param type inference&quot;);
-		}&lt;/li&gt;
	&lt;li&gt;return validator.getValidatedNodeType(sqlNode);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Returns the current count of the number of dynamic parameters in an&lt;/li&gt;
	&lt;li&gt;* EXPLAIN PLAN statement.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param increment if true, increment the count&lt;/li&gt;
	&lt;li&gt;* @return the current count before the optional increment&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public int getDynamicParamCountInExplain(boolean increment) {&lt;/li&gt;
	&lt;li&gt;int retVal = explainParamCount;&lt;/li&gt;
	&lt;li&gt;if (increment) 
{
-			++explainParamCount;
-		}&lt;/li&gt;
	&lt;li&gt;return retVal;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* @return mapping of non-correlated sub-queries that have been converted to&lt;/li&gt;
	&lt;li&gt;* the constants that they evaluate to&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public Map&amp;lt;SqlNode, RexNode&amp;gt; getMapConvertedNonCorrSubqs() 
{
-		return mapConvertedNonCorrSubqs;
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Adds to the current map of non-correlated converted sub-queries the&lt;/li&gt;
	&lt;li&gt;* elements from another map that contains non-correlated sub-queries that&lt;/li&gt;
	&lt;li&gt;* have been converted by another SqlToRelConverter.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param alreadyConvertedNonCorrSubqs the other map&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public void addConvertedNonCorrSubqs(&lt;/li&gt;
	&lt;li&gt;Map&amp;lt;SqlNode, RexNode&amp;gt; alreadyConvertedNonCorrSubqs) 
{
-		mapConvertedNonCorrSubqs.putAll(alreadyConvertedNonCorrSubqs);
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Sets a new SubQueryConverter. To have any effect, this must be called&lt;/li&gt;
	&lt;li&gt;* before any convert method.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param converter new SubQueryConverter&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public void setSubQueryConverter(SubQueryConverter converter) 
{
-		subQueryConverter = converter;
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Sets the number of dynamic parameters in the current EXPLAIN PLAN&lt;/li&gt;
	&lt;li&gt;* statement.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param explainParamCount number of dynamic parameters in the statement&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public void setDynamicParamCountInExplain(int explainParamCount) 
{
-		assert config.isExplain();
-		this.explainParamCount = explainParamCount;
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;private void checkConvertedType(SqlNode query, RelNode result) {&lt;/li&gt;
	&lt;li&gt;if (query.isA(SqlKind.DML)) 
{
-			return;
-		}&lt;br/&gt;
-		// Verify that conversion from SQL to relational algebra did&lt;br/&gt;
-		// not perturb any type information.  (We can&apos;t do this if the&lt;br/&gt;
-		// SQL statement is something like an INSERT which has no&lt;br/&gt;
-		// validator type information associated with its result,&lt;br/&gt;
-		// hence the namespace check above.)&lt;br/&gt;
-		final List&amp;lt;RelDataTypeField&amp;gt; validatedFields =&lt;br/&gt;
-				validator.getValidatedNodeType(query).getFieldList();&lt;br/&gt;
-		final RelDataType validatedRowType =&lt;br/&gt;
-				validator.getTypeFactory().createStructType(&lt;br/&gt;
-						Pair.right(validatedFields),&lt;br/&gt;
-						SqlValidatorUtil.uniquify(Pair.left(validatedFields),&lt;br/&gt;
-								catalogReader.nameMatcher().isCaseSensitive()));&lt;br/&gt;
-&lt;br/&gt;
-		final List&amp;lt;RelDataTypeField&amp;gt; convertedFields =&lt;br/&gt;
-				result.getRowType().getFieldList().subList(0, validatedFields.size());&lt;br/&gt;
-		final RelDataType convertedRowType =&lt;br/&gt;
-				validator.getTypeFactory().createStructType(convertedFields);&lt;br/&gt;
-&lt;br/&gt;
-		if (!RelOptUtil.equal(&quot;validated row type&quot;, validatedRowType,&lt;br/&gt;
-				&quot;converted row type&quot;, convertedRowType, Litmus.IGNORE)) {
-			throw new AssertionError(&quot;Conversion to relational algebra failed to &quot;
-					+ &quot;preserve datatypes:\n&quot;
-					+ &quot;validated type:\n&quot;
-					+ validatedRowType.getFullTypeString()
-					+ &quot;\nconverted type:\n&quot;
-					+ convertedRowType.getFullTypeString()
-					+ &quot;\nrel:\n&quot;
-					+ RelOptUtil.toString(result));
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	public RelNode flattenTypes(&lt;br/&gt;
-			RelNode rootRel,&lt;br/&gt;
-			boolean restructure) {
-		RelStructuredTypeFlattener typeFlattener =
-				new RelStructuredTypeFlattener(relBuilder,
-						rexBuilder, createToRelContext(), restructure);
-		return typeFlattener.rewrite(rootRel);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * If sub-query is correlated and decorrelation is enabled, performs&lt;br/&gt;
-	 * decorrelation.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param query   Query&lt;br/&gt;
-	 * @param rootRel Root relational expression&lt;br/&gt;
-	 * @return New root relational expression after decorrelation&lt;br/&gt;
-	 */&lt;br/&gt;
-	public RelNode decorrelate(SqlNode query, RelNode rootRel) {&lt;br/&gt;
-		if (!enableDecorrelation()) {
-			return rootRel;
-		}&lt;br/&gt;
-		final RelNode result = decorrelateQuery(rootRel);&lt;br/&gt;
-		if (result != rootRel) {
-			checkConvertedType(query, result);
-		}&lt;br/&gt;
-		return result;&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Walks over a tree of relational expressions, replacing each&lt;br/&gt;
-	 * {@link RelNode} with a &apos;slimmed down&apos; relational expression that projects&lt;br/&gt;
-	 * only the fields required by its consumer.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;This may make things easier for the optimizer, by removing crud that&lt;br/&gt;
-	 * would expand the search space, but is difficult for the optimizer itself&lt;br/&gt;
-	 * to do it, because optimizer rules must preserve the number and type of&lt;br/&gt;
-	 * fields. Hence, this transform that operates on the entire tree, similar&lt;br/&gt;
-	 * to the {@link RelStructuredTypeFlattener type-flattening transform}.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;Currently this functionality is disabled in farrago/luciddb; the&lt;br/&gt;
-	 * default implementation of this method does nothing.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param ordered Whether the relational expression must produce results in&lt;br/&gt;
-	 * a particular order (typically because it has an ORDER BY at top level)&lt;br/&gt;
-	 * @param rootRel Relational expression that is at the root of the tree&lt;br/&gt;
-	 * @return Trimmed relational expression&lt;br/&gt;
-	 */&lt;br/&gt;
-	public RelNode trimUnusedFields(boolean ordered, RelNode rootRel) {&lt;br/&gt;
-		// Trim fields that are not used by their consumer.&lt;br/&gt;
-		if (isTrimUnusedFields()) {&lt;br/&gt;
-			final RelFieldTrimmer trimmer = newFieldTrimmer();&lt;br/&gt;
-			final List&amp;lt;RelCollation&amp;gt; collations =&lt;br/&gt;
-					rootRel.getTraitSet().getTraits(RelCollationTraitDef.INSTANCE);&lt;br/&gt;
-			rootRel = trimmer.trim(rootRel);&lt;br/&gt;
-			if (!ordered&lt;br/&gt;
-					&amp;amp;&amp;amp; collations != null&lt;br/&gt;
-					&amp;amp;&amp;amp; !collations.isEmpty()&lt;br/&gt;
-					&amp;amp;&amp;amp; !collations.equals(ImmutableList.of(RelCollations.EMPTY))) {
-				final RelTraitSet traitSet = rootRel.getTraitSet()
-						.replace(RelCollationTraitDef.INSTANCE, collations);
-				rootRel = rootRel.copy(traitSet, rootRel.getInputs());
-			}&lt;br/&gt;
-			if (SQL2REL_LOGGER.isDebugEnabled()) {
-				SQL2REL_LOGGER.debug(
-						RelOptUtil.dumpPlan(&quot;Plan after trimming unused fields&quot;, rootRel,
-								SqlExplainFormat.TEXT, SqlExplainLevel.EXPPLAN_ATTRIBUTES));
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-		return rootRel;&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Creates a RelFieldTrimmer.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @return Field trimmer&lt;br/&gt;
-	 */&lt;br/&gt;
-	protected RelFieldTrimmer newFieldTrimmer() {
-		return new RelFieldTrimmer(validator, relBuilder);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Converts an unvalidated query&apos;s parse tree into a relational expression.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param query           Query to convert&lt;br/&gt;
-	 * @param needsValidation Whether to validate the query before converting;&lt;br/&gt;
-	 *                        &amp;lt;code&amp;gt;false&amp;lt;/code&amp;gt; if the query has already been&lt;br/&gt;
-	 *                        validated.&lt;br/&gt;
-	 * @param top             Whether the query is top-level, say if its result&lt;br/&gt;
-	 *                        will become a JDBC result set; &amp;lt;code&amp;gt;false&amp;lt;/code&amp;gt; if&lt;br/&gt;
-	 *                        the query will be part of a view.&lt;br/&gt;
-	 */&lt;br/&gt;
-	public RelRoot convertQuery(&lt;br/&gt;
-			SqlNode query,&lt;br/&gt;
-			final boolean needsValidation,&lt;br/&gt;
-			final boolean top) {&lt;br/&gt;
-		if (needsValidation) {
-			query = validator.validate(query);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		RelMetadataQuery.THREAD_PROVIDERS.set(&lt;br/&gt;
-				JaninoRelMetadataProvider.of(cluster.getMetadataProvider()));&lt;br/&gt;
-		RelNode result = convertQueryRecursive(query, top, null).rel;&lt;br/&gt;
-		if (top) {&lt;br/&gt;
-			if (isStream(query)) {
-				result = new LogicalDelta(cluster, result.getTraitSet(), result);
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-		RelCollation collation = RelCollations.EMPTY;&lt;br/&gt;
-		if (!query.isA(SqlKind.DML)) {&lt;br/&gt;
-			if (isOrdered(query)) {
-				collation = requiredCollation(result);
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-		checkConvertedType(query, result);&lt;br/&gt;
-&lt;br/&gt;
-		if (SQL2REL_LOGGER.isDebugEnabled()) {
-			SQL2REL_LOGGER.debug(
-					RelOptUtil.dumpPlan(&quot;Plan after converting SqlNode to RelNode&quot;,
-							result, SqlExplainFormat.TEXT,
-							SqlExplainLevel.EXPPLAN_ATTRIBUTES));
-		}&lt;br/&gt;
-&lt;br/&gt;
-		final RelDataType validatedRowType = validator.getValidatedNodeType(query);&lt;br/&gt;
-		return RelRoot.of(result, validatedRowType, query.getKind())&lt;br/&gt;
-				.withCollation(collation);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private static boolean isStream(SqlNode query) {
-		return query instanceof SqlSelect
-				&amp;amp;&amp;amp; ((SqlSelect) query).isKeywordPresent(SqlSelectKeyword.STREAM);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	public static boolean isOrdered(SqlNode query) {&lt;br/&gt;
-		switch (query.getKind()) {
-			case SELECT:
-				return ((SqlSelect) query).getOrderList() != null
-						&amp;amp;&amp;amp; ((SqlSelect) query).getOrderList().size() &amp;gt; 0;
-			case WITH:
-				return isOrdered(((SqlWith) query).body);
-			case ORDER_BY:
-				return ((SqlOrderBy) query).orderList.size() &amp;gt; 0;
-			default:
-				return false;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private RelCollation requiredCollation(RelNode r) {&lt;br/&gt;
-		if (r instanceof Sort) {
-			return ((Sort) r).collation;
-		}&lt;br/&gt;
-		if (r instanceof Project) {
-			return requiredCollation(((Project) r).getInput());
-		}&lt;br/&gt;
-		if (r instanceof Delta) {
-			return requiredCollation(((Delta) r).getInput());
-		}&lt;br/&gt;
-		throw new AssertionError();&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Converts a SELECT statement&apos;s parse tree into a relational expression.&lt;br/&gt;
-	 */&lt;br/&gt;
-	public RelNode convertSelect(SqlSelect select, boolean top) {
-		final SqlValidatorScope selectScope = validator.getWhereScope(select);
-		final Blackboard bb = createBlackboard(selectScope, null, top);
-		convertSelectImpl(bb, select);
-		return bb.root;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Factory method for creating translation workspace.&lt;br/&gt;
-	 */&lt;br/&gt;
-	protected Blackboard createBlackboard(SqlValidatorScope scope,&lt;br/&gt;
-	                                      Map&amp;lt;String, RexNode&amp;gt; nameToNodeMap, boolean top) {
-		return new Blackboard(scope, nameToNodeMap, top);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Implementation of {@link #convertSelect(SqlSelect, boolean)};&lt;br/&gt;
-	 * derived class may override.&lt;br/&gt;
-	 */&lt;br/&gt;
-	protected void convertSelectImpl(&lt;br/&gt;
-			final Blackboard bb,&lt;br/&gt;
-			SqlSelect select) {&lt;br/&gt;
-		convertFrom(&lt;br/&gt;
-				bb,&lt;br/&gt;
-				select.getFrom());&lt;br/&gt;
-		convertWhere(&lt;br/&gt;
-				bb,&lt;br/&gt;
-				select.getWhere());&lt;br/&gt;
-&lt;br/&gt;
-		final List&amp;lt;SqlNode&amp;gt; orderExprList = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-		final List&amp;lt;RelFieldCollation&amp;gt; collationList = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-		gatherOrderExprs(&lt;br/&gt;
-				bb,&lt;br/&gt;
-				select,&lt;br/&gt;
-				select.getOrderList(),&lt;br/&gt;
-				orderExprList,&lt;br/&gt;
-				collationList);&lt;br/&gt;
-		final RelCollation collation =&lt;br/&gt;
-				cluster.traitSet().canonize(RelCollations.of(collationList));&lt;br/&gt;
-&lt;br/&gt;
-		if (validator.isAggregate(select)) {
-			convertAgg(
-					bb,
-					select,
-					orderExprList);
-		} else {
-			convertSelectList(
-					bb,
-					select,
-					orderExprList);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		if (select.isDistinct()) {
-			distinctify(bb, true);
-		}&lt;br/&gt;
-		convertOrder(&lt;br/&gt;
-				select, bb, collation, orderExprList, select.getOffset(),&lt;br/&gt;
-				select.getFetch());&lt;br/&gt;
-		bb.setRoot(bb.root, true);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Having translated &apos;SELECT ... FROM ... &lt;span class=&quot;error&quot;&gt;&amp;#91;GROUP BY ...&amp;#93;&lt;/span&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;HAVING ...&amp;#93;&lt;/span&gt;&apos;, adds&lt;br/&gt;
-	 * a relational expression to make the results unique.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;If the SELECT clause contains duplicate expressions, adds&lt;br/&gt;
-	 * {@link org.apache.calcite.rel.logical.LogicalProject}s so that we are&lt;br/&gt;
-	 * grouping on the minimal set of keys. The performance gain isn&apos;t huge, but&lt;br/&gt;
-	 * it is difficult to detect these duplicate expressions later.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param bb               Blackboard&lt;br/&gt;
-	 * @param checkForDupExprs Check for duplicate expressions&lt;br/&gt;
-	 */&lt;br/&gt;
-	private void distinctify(&lt;br/&gt;
-			Blackboard bb,&lt;br/&gt;
-			boolean checkForDupExprs) {&lt;br/&gt;
-		// Look for duplicate expressions in the project.&lt;br/&gt;
-		// Say we have &apos;select x, y, x, z&apos;.&lt;br/&gt;
-		// Then dups will be {[2, 0]}&lt;br/&gt;
-		// and oldToNew will be {[0, 0], [1, 1], [2, 0], [3, 2]}&lt;br/&gt;
-		RelNode rel = bb.root;&lt;br/&gt;
-		if (checkForDupExprs &amp;amp;&amp;amp; (rel instanceof LogicalProject)) {&lt;br/&gt;
-			LogicalProject project = (LogicalProject) rel;&lt;br/&gt;
-			final List&amp;lt;RexNode&amp;gt; projectExprs = project.getProjects();&lt;br/&gt;
-			final List&amp;lt;Integer&amp;gt; origins = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-			int dupCount = 0;&lt;br/&gt;
-			for (int i = 0; i &amp;lt; projectExprs.size(); i++) {&lt;br/&gt;
-				int x = findExpr(projectExprs.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;, projectExprs, i);&lt;br/&gt;
-				if (x &amp;gt;= 0) {
-					origins.add(x);
-					++dupCount;
-				} else {
-					origins.add(i);
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-			if (dupCount == 0) {
-				distinctify(bb, false);
-				return;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			final Map&amp;lt;Integer, Integer&amp;gt; squished = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
-			final List&amp;lt;RelDataTypeField&amp;gt; fields = rel.getRowType().getFieldList();&lt;br/&gt;
-			final List&amp;lt;Pair&amp;lt;RexNode, String&amp;gt;&amp;gt; newProjects = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-			for (int i = 0; i &amp;lt; fields.size(); i++) {&lt;br/&gt;
-				if (origins.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; == i) {
-					squished.put(i, newProjects.size());
-					newProjects.add(RexInputRef.of2(i, fields));
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-			rel =&lt;br/&gt;
-					LogicalProject.create(rel, Pair.left(newProjects),&lt;br/&gt;
-							Pair.right(newProjects));&lt;br/&gt;
-			bb.root = rel;&lt;br/&gt;
-			distinctify(bb, false);&lt;br/&gt;
-			rel = bb.root;&lt;br/&gt;
-&lt;br/&gt;
-			// Create the expressions to reverse the mapping.&lt;br/&gt;
-			// Project($0, $1, $0, $2).&lt;br/&gt;
-			final List&amp;lt;Pair&amp;lt;RexNode, String&amp;gt;&amp;gt; undoProjects = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-			for (int i = 0; i &amp;lt; fields.size(); i++) {
-				final int origin = origins.get(i);
-				RelDataTypeField field = fields.get(i);
-				undoProjects.add(
-						Pair.of(
-								(RexNode) new RexInputRef(
-										squished.get(origin), field.getType()),
-								field.getName()));
-			}&lt;br/&gt;
-&lt;br/&gt;
-			rel =&lt;br/&gt;
-					LogicalProject.create(rel, Pair.left(undoProjects),&lt;br/&gt;
-							Pair.right(undoProjects));&lt;br/&gt;
-			bb.setRoot(&lt;br/&gt;
-					rel,&lt;br/&gt;
-					false);&lt;br/&gt;
-&lt;br/&gt;
-			return;&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		// Usual case: all of the expressions in the SELECT clause are&lt;br/&gt;
-		// different.&lt;br/&gt;
-		final ImmutableBitSet groupSet =&lt;br/&gt;
-				ImmutableBitSet.range(rel.getRowType().getFieldCount());&lt;br/&gt;
-		rel = createAggregate(bb, groupSet, ImmutableList.of(groupSet),&lt;br/&gt;
-				ImmutableList.of());&lt;br/&gt;
-&lt;br/&gt;
-		bb.setRoot(&lt;br/&gt;
-				rel,&lt;br/&gt;
-				false);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private int findExpr(RexNode seek, List&amp;lt;RexNode&amp;gt; exprs, int count) {&lt;br/&gt;
-		for (int i = 0; i &amp;lt; count; i++) {&lt;br/&gt;
-			RexNode expr = exprs.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;br/&gt;
-			if (expr.toString().equals(seek.toString())) {
-				return i;
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-		return -1;&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Converts a query&apos;s ORDER BY clause, if any.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param select        Query&lt;br/&gt;
-	 * @param bb            Blackboard&lt;br/&gt;
-	 * @param collation     Collation list&lt;br/&gt;
-	 * @param orderExprList Method populates this list with orderBy expressions&lt;br/&gt;
-	 *                      not present in selectList&lt;br/&gt;
-	 * @param offset        Expression for number of rows to discard before&lt;br/&gt;
-	 *                      returning first row&lt;br/&gt;
-	 * @param fetch         Expression for number of rows to fetch&lt;br/&gt;
-	 */&lt;br/&gt;
-	protected void convertOrder(&lt;br/&gt;
-			SqlSelect select,&lt;br/&gt;
-			Blackboard bb,&lt;br/&gt;
-			RelCollation collation,&lt;br/&gt;
-			List&amp;lt;SqlNode&amp;gt; orderExprList,&lt;br/&gt;
-			SqlNode offset,&lt;br/&gt;
-			SqlNode fetch) {&lt;br/&gt;
-		if (select.getOrderList() == null&lt;br/&gt;
-				|| select.getOrderList().getList().isEmpty()) {&lt;br/&gt;
-			assert collation.getFieldCollations().isEmpty();&lt;br/&gt;
-			if ((offset == null&lt;br/&gt;
-					|| (offset instanceof SqlLiteral&lt;br/&gt;
-					&amp;amp;&amp;amp; ((SqlLiteral) offset).bigDecimalValue().equals(BigDecimal.ZERO)))&lt;br/&gt;
-					&amp;amp;&amp;amp; fetch == null) {
-				return;
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		// Create a sorter using the previously constructed collations.&lt;br/&gt;
-		bb.setRoot(&lt;br/&gt;
-				LogicalSort.create(bb.root, collation,&lt;br/&gt;
-						offset == null ? null : convertExpression(offset),&lt;br/&gt;
-						fetch == null ? null : convertExpression(fetch)),&lt;br/&gt;
-				false);&lt;br/&gt;
-&lt;br/&gt;
-		// If extra expressions were added to the project list for sorting,&lt;br/&gt;
-		// add another project to remove them. But make the collation empty, because&lt;br/&gt;
-		// we can&apos;t represent the real collation.&lt;br/&gt;
-		//&lt;br/&gt;
-		// If it is the top node, use the real collation, but don&apos;t trim fields.&lt;br/&gt;
-		if (orderExprList.size() &amp;gt; 0 &amp;amp;&amp;amp; !bb.top) {&lt;br/&gt;
-			final List&amp;lt;RexNode&amp;gt; exprs = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-			final RelDataType rowType = bb.root.getRowType();&lt;br/&gt;
-			final int fieldCount =&lt;br/&gt;
-					rowType.getFieldCount() - orderExprList.size();&lt;br/&gt;
-			for (int i = 0; i &amp;lt; fieldCount; i++) {
-				exprs.add(rexBuilder.makeInputRef(bb.root, i));
-			}&lt;br/&gt;
-			bb.setRoot(&lt;br/&gt;
-					LogicalProject.create(bb.root, exprs,&lt;br/&gt;
-							rowType.getFieldNames().subList(0, fieldCount)),&lt;br/&gt;
-					false);&lt;br/&gt;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Returns whether a given node contains a {@link SqlInOperator}.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param node a RexNode tree&lt;br/&gt;
-	 */&lt;br/&gt;
-	private static boolean containsInOperator(&lt;br/&gt;
-			SqlNode node) {&lt;br/&gt;
-		try {&lt;br/&gt;
-			SqlVisitor&amp;lt;Void&amp;gt; visitor =&lt;br/&gt;
-					new SqlBasicVisitor&amp;lt;Void&amp;gt;() {&lt;br/&gt;
-						public Void visit(SqlCall call) {&lt;br/&gt;
-							if (call.getOperator() instanceof SqlInOperator) {
-								throw new Util.FoundOne(call);
-							}&lt;br/&gt;
-							return super.visit(call);&lt;br/&gt;
-						}&lt;br/&gt;
-					};&lt;br/&gt;
-			node.accept(visitor);&lt;br/&gt;
-			return false;&lt;br/&gt;
-		} catch (Util.FoundOne e) {
-			Util.swallow(e, null);
-			return true;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Push down all the NOT logical operators into any IN/NOT IN operators.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param scope Scope where {@code sqlNode} occurs&lt;br/&gt;
-	 * @param sqlNode the root node from which to look for NOT operators&lt;br/&gt;
-	 * @return the transformed SqlNode representation with NOT pushed down.&lt;br/&gt;
-	 */&lt;br/&gt;
-	private static SqlNode pushDownNotForIn(SqlValidatorScope scope,&lt;br/&gt;
-	                                        SqlNode sqlNode) {&lt;br/&gt;
-		if ((sqlNode instanceof SqlCall) &amp;amp;&amp;amp; containsInOperator(sqlNode)) {&lt;br/&gt;
-			SqlCall sqlCall = (SqlCall) sqlNode;&lt;br/&gt;
-			if ((sqlCall.getOperator() == SqlStdOperatorTable.AND)&lt;br/&gt;
-					|| (sqlCall.getOperator() == SqlStdOperatorTable.OR)) {&lt;br/&gt;
-				SqlNode[] sqlOperands = ((SqlBasicCall) sqlCall).operands;&lt;br/&gt;
-				for (int i = 0; i &amp;lt; sqlOperands.length; i++) {
-					sqlOperands[i] = pushDownNotForIn(scope, sqlOperands[i]);
-				}&lt;br/&gt;
-				return reg(scope, sqlNode);&lt;br/&gt;
-			} else if (sqlCall.getOperator() == SqlStdOperatorTable.NOT) {&lt;br/&gt;
-				SqlNode childNode = sqlCall.operand(0);&lt;br/&gt;
-				assert childNode instanceof SqlCall;&lt;br/&gt;
-				SqlBasicCall childSqlCall = (SqlBasicCall) childNode;&lt;br/&gt;
-				if (childSqlCall.getOperator() == SqlStdOperatorTable.AND) {&lt;br/&gt;
-					SqlNode[] andOperands = childSqlCall.getOperands();&lt;br/&gt;
-					SqlNode[] orOperands = new SqlNode&lt;span class=&quot;error&quot;&gt;&amp;#91;andOperands.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
-					for (int i = 0; i &amp;lt; orOperands.length; i++) {
-						orOperands[i] = reg(scope,
-								SqlStdOperatorTable.NOT.createCall(SqlParserPos.ZERO,
-										andOperands[i]));
-					}&lt;br/&gt;
-					for (int i = 0; i &amp;lt; orOperands.length; i++) {
-						orOperands[i] = pushDownNotForIn(scope, orOperands[i]);
-					}&lt;br/&gt;
-					return reg(scope,&lt;br/&gt;
-							SqlStdOperatorTable.OR.createCall(SqlParserPos.ZERO,&lt;br/&gt;
-									orOperands&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, orOperands&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;));&lt;br/&gt;
-				} else if (childSqlCall.getOperator() == SqlStdOperatorTable.OR) {&lt;br/&gt;
-					SqlNode[] orOperands = childSqlCall.getOperands();&lt;br/&gt;
-					SqlNode[] andOperands = new SqlNode&lt;span class=&quot;error&quot;&gt;&amp;#91;orOperands.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
-					for (int i = 0; i &amp;lt; andOperands.length; i++) {
-						andOperands[i] = reg(scope,
-								SqlStdOperatorTable.NOT.createCall(SqlParserPos.ZERO,
-										orOperands[i]));
-					}&lt;br/&gt;
-					for (int i = 0; i &amp;lt; andOperands.length; i++) {
-						andOperands[i] = pushDownNotForIn(scope, andOperands[i]);
-					}&lt;br/&gt;
-					return reg(scope,&lt;br/&gt;
-							SqlStdOperatorTable.AND.createCall(SqlParserPos.ZERO,&lt;br/&gt;
-									andOperands&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, andOperands&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;));&lt;br/&gt;
-				} else if (childSqlCall.getOperator() == SqlStdOperatorTable.NOT) {
-					SqlNode[] notOperands = childSqlCall.getOperands();
-					assert notOperands.length == 1;
-					return pushDownNotForIn(scope, notOperands[0]);
-				} else if (childSqlCall.getOperator() instanceof SqlInOperator) {&lt;br/&gt;
-					SqlNode[] inOperands = childSqlCall.getOperands();&lt;br/&gt;
-					SqlInOperator inOp =&lt;br/&gt;
-							(SqlInOperator) childSqlCall.getOperator();&lt;br/&gt;
-					if (inOp.kind == SqlKind.NOT_IN) {
-						return reg(scope,
-								SqlStdOperatorTable.IN.createCall(SqlParserPos.ZERO,
-										inOperands[0], inOperands[1]));
-					} else {
-						return reg(scope,
-								SqlStdOperatorTable.NOT_IN.createCall(SqlParserPos.ZERO,
-										inOperands[0], inOperands[1]));
-					}&lt;br/&gt;
-				} else {
-					// childSqlCall is &quot;leaf&quot; node in a logical expression tree
-					// (only considering AND, OR, NOT)
-					return sqlNode;
-				}&lt;br/&gt;
-			} else {
-				// sqlNode is &quot;leaf&quot; node in a logical expression tree
-				// (only considering AND, OR, NOT)
-				return sqlNode;
-			}&lt;br/&gt;
-		} else {
-			// tree rooted at sqlNode does not contain inOperator
-			return sqlNode;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/** Registers with the validator a {@link SqlNode} that has been created&lt;br/&gt;
-	 * during the Sql-to-Rel process. */&lt;br/&gt;
-	private static SqlNode reg(SqlValidatorScope scope, SqlNode e) {
-		scope.getValidator().deriveType(scope, e);
-		return e;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Converts a WHERE clause.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param bb    Blackboard&lt;br/&gt;
-	 * @param where WHERE clause, may be null&lt;br/&gt;
-	 */&lt;br/&gt;
-	private void convertWhere(&lt;br/&gt;
-			final Blackboard bb,&lt;br/&gt;
-			final SqlNode where) {&lt;br/&gt;
-		if (where == null) {-			return;-		}&lt;/li&gt;
	&lt;li&gt;SqlNode newWhere = pushDownNotForIn(bb.scope, where);&lt;/li&gt;
	&lt;li&gt;replaceSubQueries(bb, newWhere, RelOptUtil.Logic.UNKNOWN_AS_FALSE);&lt;/li&gt;
	&lt;li&gt;final RexNode convertedWhere = bb.convertExpression(newWhere);&lt;/li&gt;
	&lt;li&gt;final RexNode convertedWhere2 =&lt;/li&gt;
	&lt;li&gt;RexUtil.removeNullabilityCast(typeFactory, convertedWhere);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// only allocate filter if the condition is not TRUE&lt;/li&gt;
	&lt;li&gt;if (convertedWhere2.isAlwaysTrue()) 
{
-			return;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		final RelFactories.FilterFactory factory =&lt;br/&gt;
-				RelFactories.DEFAULT_FILTER_FACTORY;&lt;br/&gt;
-		final RelNode filter = factory.createFilter(bb.root, convertedWhere2);&lt;br/&gt;
-		final RelNode r;&lt;br/&gt;
-		final CorrelationUse p = getCorrelationUse(bb, filter);&lt;br/&gt;
-		if (p != null) {
-			assert p.r instanceof Filter;
-			Filter f = (Filter) p.r;
-			r = LogicalFilter.create(f.getInput(), f.getCondition(),
-					ImmutableSet.of(p.id));
-		} else {
-			r = filter;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		bb.setRoot(r, false);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private void replaceSubQueries(&lt;br/&gt;
-			final Blackboard bb,&lt;br/&gt;
-			final SqlNode expr,&lt;br/&gt;
-			RelOptUtil.Logic logic) {&lt;br/&gt;
-		findSubQueries(bb, expr, logic, false);&lt;br/&gt;
-		for (SubQuery node : bb.subQueryList) {
-			substituteSubQuery(bb, node);
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private void substituteSubQuery(Blackboard bb, SubQuery subQuery) {&lt;br/&gt;
-		final RexNode expr = subQuery.expr;&lt;br/&gt;
-		if (expr != null) {
-			// Already done.
-			return;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		final SqlBasicCall call;&lt;br/&gt;
-		final RelNode rel;&lt;br/&gt;
-		final SqlNode query;&lt;br/&gt;
-		final RelOptUtil.Exists converted;&lt;br/&gt;
-		switch (subQuery.node.getKind()) {&lt;br/&gt;
-			case CURSOR:&lt;br/&gt;
-				convertCursor(bb, subQuery);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case MULTISET_QUERY_CONSTRUCTOR:&lt;br/&gt;
-			case MULTISET_VALUE_CONSTRUCTOR:&lt;br/&gt;
-			case ARRAY_QUERY_CONSTRUCTOR:&lt;br/&gt;
-				rel = convertMultisets(ImmutableList.of(subQuery.node), bb);&lt;br/&gt;
-				subQuery.expr = bb.register(rel, JoinRelType.INNER);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case IN:&lt;br/&gt;
-			case NOT_IN:&lt;br/&gt;
-			case SOME:&lt;br/&gt;
-			case ALL:&lt;br/&gt;
-				call = (SqlBasicCall) subQuery.node;&lt;br/&gt;
-				query = call.operand(1);&lt;br/&gt;
-				if (!config.isExpand() &amp;amp;&amp;amp; !(query instanceof SqlNodeList)) {
-					return;
-				}&lt;br/&gt;
-				final SqlNode leftKeyNode = call.operand(0);&lt;br/&gt;
-&lt;br/&gt;
-				final List&amp;lt;RexNode&amp;gt; leftKeys;&lt;br/&gt;
-				switch (leftKeyNode.getKind()) {&lt;br/&gt;
-					case ROW:&lt;br/&gt;
-						leftKeys = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-						for (SqlNode sqlExpr : ((SqlBasicCall) leftKeyNode).getOperandList()) {
-							leftKeys.add(bb.convertExpression(sqlExpr));
-						}&lt;br/&gt;
-						break;&lt;br/&gt;
-					default:&lt;br/&gt;
-						leftKeys = ImmutableList.of(bb.convertExpression(leftKeyNode));&lt;br/&gt;
-				}&lt;br/&gt;
-&lt;br/&gt;
-				if (query instanceof SqlNodeList) {&lt;br/&gt;
-					SqlNodeList valueList = (SqlNodeList) query;&lt;br/&gt;
-					if (!containsNullLiteral(valueList)&lt;br/&gt;
-							&amp;amp;&amp;amp; valueList.size() &amp;lt; config.getInSubQueryThreshold()) {
-						// We&apos;re under the threshold, so convert to OR.
-						subQuery.expr =
-								convertInToOr(
-										bb,
-										leftKeys,
-										valueList,
-										(SqlInOperator) call.getOperator());
-						return;
-					}&lt;br/&gt;
-&lt;br/&gt;
-					// Otherwise, let convertExists translate&lt;br/&gt;
-					// values list into an inline table for the&lt;br/&gt;
-					// reference to Q below.&lt;br/&gt;
-				}&lt;br/&gt;
-&lt;br/&gt;
-				// Project out the search columns from the left side&lt;br/&gt;
-&lt;br/&gt;
-				// Q1:&lt;br/&gt;
-				// &quot;select from emp where emp.deptno in (select col1 from T)&quot;&lt;br/&gt;
-				//&lt;br/&gt;
-				// is converted to&lt;br/&gt;
-				//&lt;br/&gt;
-				// &quot;select from&lt;br/&gt;
-				//   emp inner join (select distinct col1 from T)) q&lt;br/&gt;
-				//   on emp.deptno = q.col1&lt;br/&gt;
-				//&lt;br/&gt;
-				// Q2:&lt;br/&gt;
-				// &quot;select from emp where emp.deptno not in (Q)&quot;&lt;br/&gt;
-				//&lt;br/&gt;
-				// is converted to&lt;br/&gt;
-				//&lt;br/&gt;
-				// &quot;select from&lt;br/&gt;
-				//   emp left outer join (select distinct col1, TRUE from T) q&lt;br/&gt;
-				//   on emp.deptno = q.col1&lt;br/&gt;
-				//   where emp.deptno &amp;lt;&amp;gt; null&lt;br/&gt;
-				//         and q.indicator &amp;lt;&amp;gt; TRUE&quot;&lt;br/&gt;
-				//&lt;br/&gt;
-				final RelDataType targetRowType =&lt;br/&gt;
-						SqlTypeUtil.promoteToRowType(typeFactory,&lt;br/&gt;
-								validator.getValidatedNodeType(leftKeyNode), null);&lt;br/&gt;
-				final boolean notIn = call.getOperator().kind == SqlKind.NOT_IN;&lt;br/&gt;
-				converted =&lt;br/&gt;
-						convertExists(query, RelOptUtil.SubQueryType.IN, subQuery.logic,&lt;br/&gt;
-								notIn, targetRowType);&lt;br/&gt;
-				if (converted.indicator) {
-					// Generate
-					//    emp CROSS JOIN (SELECT COUNT(*) AS c,
-					//                       COUNT(deptno) AS ck FROM dept)
-					final RelDataType longType =
-							typeFactory.createSqlType(SqlTypeName.BIGINT);
-					final RelNode seek = converted.r.getInput(0); // fragile
-					final int keyCount = leftKeys.size();
-					final List&amp;lt;Integer&amp;gt; args = ImmutableIntList.range(0, keyCount);
-					LogicalAggregate aggregate =
-							LogicalAggregate.create(seek, ImmutableBitSet.of(), null,
-									ImmutableList.of(
-											AggregateCall.create(SqlStdOperatorTable.COUNT, false,
-													false, ImmutableList.of(), -1, longType, null),
-											AggregateCall.create(SqlStdOperatorTable.COUNT, false,
-													false, args, -1, longType, null)));
-					LogicalJoin join =
-							LogicalJoin.create(bb.root, aggregate, rexBuilder.makeLiteral(true),
-									ImmutableSet.of(), JoinRelType.INNER);
-					bb.setRoot(join, false);
-				}&lt;br/&gt;
-				final RexNode rex =&lt;br/&gt;
-						bb.register(converted.r,&lt;br/&gt;
-								converted.outerJoin ? JoinRelType.LEFT : JoinRelType.INNER,&lt;br/&gt;
-								leftKeys);&lt;br/&gt;
-&lt;br/&gt;
-				RelOptUtil.Logic logic = subQuery.logic;&lt;br/&gt;
-				switch (logic) {&lt;br/&gt;
-					case TRUE_FALSE_UNKNOWN:&lt;br/&gt;
-					case UNKNOWN_AS_TRUE:&lt;br/&gt;
-						if (!converted.indicator) {
-							logic = RelOptUtil.Logic.TRUE_FALSE;
-						}&lt;br/&gt;
-				}&lt;br/&gt;
-				subQuery.expr = translateIn(logic, bb.root, rex);&lt;br/&gt;
-				if (notIn) {
-					subQuery.expr =
-							rexBuilder.makeCall(SqlStdOperatorTable.NOT, subQuery.expr);
-				}&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case EXISTS:&lt;br/&gt;
-				// &quot;select from emp where exists (select a from T)&quot;&lt;br/&gt;
-				//&lt;br/&gt;
-				// is converted to the following if the sub-query is correlated:&lt;br/&gt;
-				//&lt;br/&gt;
-				// &quot;select from emp left outer join (select AGG_TRUE() as indicator&lt;br/&gt;
-				// from T group by corr_var) q where q.indicator is true&quot;&lt;br/&gt;
-				//&lt;br/&gt;
-				// If there is no correlation, the expression is replaced with a&lt;br/&gt;
-				// boolean indicating whether the sub-query returned 0 or &amp;gt;= 1 row.&lt;br/&gt;
-				call = (SqlBasicCall) subQuery.node;&lt;br/&gt;
-				query = call.operand(0);&lt;br/&gt;
-				if (!config.isExpand()) {-					return;-				}&lt;br/&gt;
-				converted = convertExists(query, RelOptUtil.SubQueryType.EXISTS,&lt;br/&gt;
-						subQuery.logic, true, null);&lt;br/&gt;
-				assert !converted.indicator;&lt;br/&gt;
-				if (convertNonCorrelatedSubQuery(subQuery, bb, converted.r, true)) {
-					return;
-				}&lt;br/&gt;
-				subQuery.expr = bb.register(converted.r, JoinRelType.LEFT);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case SCALAR_QUERY:&lt;br/&gt;
-				// Convert the sub-query.  If it&apos;s non-correlated, convert it&lt;br/&gt;
-				// to a constant expression.&lt;br/&gt;
-				if (!config.isExpand()) {-					return;-				}&lt;br/&gt;
-				call = (SqlBasicCall) subQuery.node;&lt;br/&gt;
-				query = call.operand(0);&lt;br/&gt;
-				converted = convertExists(query, RelOptUtil.SubQueryType.SCALAR,&lt;br/&gt;
-						subQuery.logic, true, null);&lt;br/&gt;
-				assert !converted.indicator;&lt;br/&gt;
-				if (convertNonCorrelatedSubQuery(subQuery, bb, converted.r, false)) {
-					return;
-				}&lt;br/&gt;
-				rel = convertToSingleValueSubq(query, converted.r);&lt;br/&gt;
-				subQuery.expr = bb.register(rel, JoinRelType.LEFT);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case SELECT:&lt;br/&gt;
-				// This is used when converting multiset queries:&lt;br/&gt;
-				//&lt;br/&gt;
-				// select * from unnest(select multiset&lt;span class=&quot;error&quot;&gt;&amp;#91;deptno&amp;#93;&lt;/span&gt; from emps);&lt;br/&gt;
-				//&lt;br/&gt;
-				converted = convertExists(subQuery.node, RelOptUtil.SubQueryType.SCALAR,&lt;br/&gt;
-						subQuery.logic, true, null);&lt;br/&gt;
-				assert !converted.indicator;&lt;br/&gt;
-				subQuery.expr = bb.register(converted.r, JoinRelType.LEFT);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			default:&lt;br/&gt;
-				throw new AssertionError(&quot;unexpected kind of sub-query: &quot;&lt;br/&gt;
-						+ subQuery.node);&lt;br/&gt;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private RexNode translateIn(RelOptUtil.Logic logic, RelNode root,&lt;br/&gt;
-	                            final RexNode rex) {&lt;br/&gt;
-		switch (logic) {&lt;br/&gt;
-			case TRUE:&lt;br/&gt;
-				return rexBuilder.makeLiteral(true);&lt;br/&gt;
-&lt;br/&gt;
-			case TRUE_FALSE:&lt;br/&gt;
-			case UNKNOWN_AS_FALSE:&lt;br/&gt;
-				assert rex instanceof RexRangeRef;&lt;br/&gt;
-				final int fieldCount = rex.getType().getFieldCount();&lt;br/&gt;
-				RexNode rexNode = rexBuilder.makeFieldAccess(rex, fieldCount - 1);&lt;br/&gt;
-				rexNode = rexBuilder.makeCall(SqlStdOperatorTable.IS_TRUE, rexNode);&lt;br/&gt;
-&lt;br/&gt;
-				// Then append the IS NOT NULL(leftKeysForIn).&lt;br/&gt;
-				//&lt;br/&gt;
-				// RexRangeRef contains the following fields:&lt;br/&gt;
-				//   leftKeysForIn,&lt;br/&gt;
-				//   rightKeysForIn (the original sub-query select list),&lt;br/&gt;
-				//   nullIndicator&lt;br/&gt;
-				//&lt;br/&gt;
-				// The first two lists contain the same number of fields.&lt;br/&gt;
-				final int k = (fieldCount - 1) / 2;&lt;br/&gt;
-				for (int i = 0; i &amp;lt; k; i++) {
-					rexNode =
-							rexBuilder.makeCall(
-									SqlStdOperatorTable.AND,
-									rexNode,
-									rexBuilder.makeCall(
-											SqlStdOperatorTable.IS_NOT_NULL,
-											rexBuilder.makeFieldAccess(rex, i)));
-				}&lt;br/&gt;
-				return rexNode;&lt;br/&gt;
-&lt;br/&gt;
-			case TRUE_FALSE_UNKNOWN:&lt;br/&gt;
-			case UNKNOWN_AS_TRUE:&lt;br/&gt;
-				// select e.deptno,&lt;br/&gt;
-				//   case&lt;br/&gt;
-				//   when ct.c = 0 then false&lt;br/&gt;
-				//   when dt.i is not null then true&lt;br/&gt;
-				//   when e.deptno is null then null&lt;br/&gt;
-				//   when ct.ck &amp;lt; ct.c then null&lt;br/&gt;
-				//   else false&lt;br/&gt;
-				//   end&lt;br/&gt;
-				// from e&lt;br/&gt;
-				// cross join (select count&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; as c, count(deptno) as ck from v) as ct&lt;br/&gt;
-				// left join (select distinct deptno, true as i from v) as dt&lt;br/&gt;
-				//   on e.deptno = dt.deptno&lt;br/&gt;
-				final Join join = (Join) root;&lt;br/&gt;
-				final Project left = (Project) join.getLeft();&lt;br/&gt;
-				final RelNode leftLeft = ((Join) left.getInput()).getLeft();&lt;br/&gt;
-				final int leftLeftCount = leftLeft.getRowType().getFieldCount();&lt;br/&gt;
-				final RelDataType longType =&lt;br/&gt;
-						typeFactory.createSqlType(SqlTypeName.BIGINT);&lt;br/&gt;
-				final RexNode cRef = rexBuilder.makeInputRef(root, leftLeftCount);&lt;br/&gt;
-				final RexNode ckRef = rexBuilder.makeInputRef(root, leftLeftCount + 1);&lt;br/&gt;
-				final RexNode iRef =&lt;br/&gt;
-						rexBuilder.makeInputRef(root, root.getRowType().getFieldCount() - 1);&lt;br/&gt;
-&lt;br/&gt;
-				final RexLiteral zero =&lt;br/&gt;
-						rexBuilder.makeExactLiteral(BigDecimal.ZERO, longType);&lt;br/&gt;
-				final RexLiteral trueLiteral = rexBuilder.makeLiteral(true);&lt;br/&gt;
-				final RexLiteral falseLiteral = rexBuilder.makeLiteral(false);&lt;br/&gt;
-				final RexNode unknownLiteral =&lt;br/&gt;
-						rexBuilder.makeNullLiteral(trueLiteral.getType());&lt;br/&gt;
-&lt;br/&gt;
-				final ImmutableList.Builder&amp;lt;RexNode&amp;gt; args = ImmutableList.builder();&lt;br/&gt;
-				args.add(rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, cRef, zero),&lt;br/&gt;
-						falseLiteral,&lt;br/&gt;
-						rexBuilder.makeCall(SqlStdOperatorTable.IS_NOT_NULL, iRef),&lt;br/&gt;
-						trueLiteral);&lt;br/&gt;
-				final JoinInfo joinInfo = join.analyzeCondition();&lt;br/&gt;
-				for (int leftKey : joinInfo.leftKeys) {
-					final RexNode kRef = rexBuilder.makeInputRef(root, leftKey);
-					args.add(rexBuilder.makeCall(SqlStdOperatorTable.IS_NULL, kRef),
-							unknownLiteral);
-				}&lt;br/&gt;
-				args.add(rexBuilder.makeCall(SqlStdOperatorTable.LESS_THAN, ckRef, cRef),&lt;br/&gt;
-						unknownLiteral,&lt;br/&gt;
-						falseLiteral);&lt;br/&gt;
-&lt;br/&gt;
-				return rexBuilder.makeCall(SqlStdOperatorTable.CASE, args.build());&lt;br/&gt;
-&lt;br/&gt;
-			default:&lt;br/&gt;
-				throw new AssertionError(logic);&lt;br/&gt;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private static boolean containsNullLiteral(SqlNodeList valueList) {&lt;br/&gt;
-		for (SqlNode node : valueList.getList()) {&lt;br/&gt;
-			if (node instanceof SqlLiteral) {&lt;br/&gt;
-				SqlLiteral lit = (SqlLiteral) node;&lt;br/&gt;
-				if (lit.getValue() == null) {
-					return true;
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-		return false;&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Determines if a sub-query is non-correlated and if so, converts it to a&lt;br/&gt;
-	 * constant.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param subQuery  the call that references the sub-query&lt;br/&gt;
-	 * @param bb        blackboard used to convert the sub-query&lt;br/&gt;
-	 * @param converted RelNode tree corresponding to the sub-query&lt;br/&gt;
-	 * @param isExists  true if the sub-query is part of an EXISTS expression&lt;br/&gt;
-	 * @return Whether the sub-query can be converted to a constant&lt;br/&gt;
-	 */&lt;br/&gt;
-	private boolean convertNonCorrelatedSubQuery(&lt;br/&gt;
-			SubQuery subQuery,&lt;br/&gt;
-			Blackboard bb,&lt;br/&gt;
-			RelNode converted,&lt;br/&gt;
-			boolean isExists) {&lt;br/&gt;
-		SqlCall call = (SqlBasicCall) subQuery.node;&lt;br/&gt;
-		if (subQueryConverter.canConvertSubQuery()&lt;br/&gt;
-				&amp;amp;&amp;amp; isSubQueryNonCorrelated(converted, bb)) {&lt;br/&gt;
-			// First check if the sub-query has already been converted&lt;br/&gt;
-			// because it&apos;s a nested sub-query.  If so, don&apos;t re-evaluate&lt;br/&gt;
-			// it again.&lt;br/&gt;
-			RexNode constExpr = mapConvertedNonCorrSubqs.get(call);&lt;br/&gt;
-			if (constExpr == null) {
-				constExpr =
-						subQueryConverter.convertSubQuery(
-								call,
-								this,
-								isExists,
-								config.isExplain());
-			}&lt;br/&gt;
-			if (constExpr != null) {
-				subQuery.expr = constExpr;
-				mapConvertedNonCorrSubqs.put(call, constExpr);
-				return true;
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-		return false;&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Converts the RelNode tree for a select statement to a select that&lt;br/&gt;
-	 * produces a single value.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param query the query&lt;br/&gt;
-	 * @param plan   the original RelNode tree corresponding to the statement&lt;br/&gt;
-	 * @return the converted RelNode tree&lt;br/&gt;
-	 */&lt;br/&gt;
-	public RelNode convertToSingleValueSubq(&lt;br/&gt;
-			SqlNode query,&lt;br/&gt;
-			RelNode plan) {&lt;br/&gt;
-		// Check whether query is guaranteed to produce a single value.&lt;br/&gt;
-		if (query instanceof SqlSelect) {&lt;br/&gt;
-			SqlSelect select = (SqlSelect) query;&lt;br/&gt;
-			SqlNodeList selectList = select.getSelectList();&lt;br/&gt;
-			SqlNodeList groupList = select.getGroup();&lt;br/&gt;
-&lt;br/&gt;
-			if ((selectList.size() == 1)&lt;br/&gt;
-					&amp;amp;&amp;amp; ((groupList == null) || (groupList.size() == 0))) {&lt;br/&gt;
-				SqlNode selectExpr = selectList.get(0);&lt;br/&gt;
-				if (selectExpr instanceof SqlCall) {&lt;br/&gt;
-					SqlCall selectExprCall = (SqlCall) selectExpr;&lt;br/&gt;
-					if (Util.isSingleValue(selectExprCall)) {
-						return plan;
-					}&lt;br/&gt;
-				}&lt;br/&gt;
-&lt;br/&gt;
-				// If there is a limit with 0 or 1,&lt;br/&gt;
-				// it is ensured to produce a single value&lt;br/&gt;
-				if (select.getFetch() != null&lt;br/&gt;
-						&amp;amp;&amp;amp; select.getFetch() instanceof SqlNumericLiteral) {&lt;br/&gt;
-					SqlNumericLiteral limitNum = (SqlNumericLiteral) select.getFetch();&lt;br/&gt;
-					if (((BigDecimal) limitNum.getValue()).intValue() &amp;lt; 2) {-						return plan;-					}&lt;br/&gt;
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-		} else if (query instanceof SqlCall) {&lt;br/&gt;
-			// If the query is (values ...),&lt;br/&gt;
-			// it is necessary to look into the operands to determine&lt;br/&gt;
-			// whether SingleValueAgg is necessary&lt;br/&gt;
-			SqlCall exprCall = (SqlCall) query;&lt;br/&gt;
-			if (exprCall.getOperator()&lt;br/&gt;
-					instanceof SqlValuesOperator&lt;br/&gt;
-					&amp;amp;&amp;amp; Util.isSingleValue(exprCall)) {
-				return plan;
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		// If not, project SingleValueAgg&lt;br/&gt;
-		return RelOptUtil.createSingleValueAggRel(&lt;br/&gt;
-				cluster,&lt;br/&gt;
-				plan);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Converts &quot;x IN (1, 2, ...)&quot; to &quot;x=1 OR x=2 OR ...&quot;.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param leftKeys   LHS&lt;br/&gt;
-	 * @param valuesList RHS&lt;br/&gt;
-	 * @param op         The operator (IN, NOT IN, &amp;gt; SOME, ...)&lt;br/&gt;
-	 * @return converted expression&lt;br/&gt;
-	 */&lt;br/&gt;
-	private RexNode convertInToOr(&lt;br/&gt;
-			final Blackboard bb,&lt;br/&gt;
-			final List&amp;lt;RexNode&amp;gt; leftKeys,&lt;br/&gt;
-			SqlNodeList valuesList,&lt;br/&gt;
-			SqlInOperator op) {&lt;br/&gt;
-		final List&amp;lt;RexNode&amp;gt; comparisons = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-		for (SqlNode rightVals : valuesList) {&lt;br/&gt;
-			RexNode rexComparison;&lt;br/&gt;
-			final SqlOperator comparisonOp;&lt;br/&gt;
-			if (op instanceof SqlQuantifyOperator) {
-				comparisonOp = RelOptUtil.op(((SqlQuantifyOperator) op).comparisonKind,
-						SqlStdOperatorTable.EQUALS);
-			} else {
-				comparisonOp = SqlStdOperatorTable.EQUALS;
-			}&lt;br/&gt;
-			if (leftKeys.size() == 1) {
-				rexComparison =
-						rexBuilder.makeCall(comparisonOp,
-								leftKeys.get(0),
-								ensureSqlType(leftKeys.get(0).getType(),
-										bb.convertExpression(rightVals)));
-			} else {
-				assert rightVals instanceof SqlCall;
-				final SqlBasicCall call = (SqlBasicCall) rightVals;
-				assert (call.getOperator() instanceof SqlRowOperator)
-						&amp;amp;&amp;amp; call.operandCount() == leftKeys.size();
-				rexComparison =
-						RexUtil.composeConjunction(
-								rexBuilder,
-								Iterables.transform(
-										Pair.zip(leftKeys, call.getOperandList()),
-										pair -&amp;gt; rexBuilder.makeCall(comparisonOp, pair.left,
-												ensureSqlType(pair.left.getType(),
-														bb.convertExpression(pair.right)))),
-								false);
-			}&lt;br/&gt;
-			comparisons.add(rexComparison);&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		switch (op.kind) {
-			case ALL:
-				return RexUtil.composeConjunction(rexBuilder, comparisons, true);
-			case NOT_IN:
-				return rexBuilder.makeCall(SqlStdOperatorTable.NOT,
-						RexUtil.composeDisjunction(rexBuilder, comparisons, true));
-			case IN:
-			case SOME:
-				return RexUtil.composeDisjunction(rexBuilder, comparisons, true);
-			default:
-				throw new AssertionError();
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/** Ensures that an expression has a given {@link SqlTypeName}, applying a&lt;br/&gt;
-	 * cast if necessary. If the expression already has the right type family,&lt;br/&gt;
-	 * returns the expression unchanged. */&lt;br/&gt;
-	private RexNode ensureSqlType(RelDataType type, RexNode node) {&lt;br/&gt;
-		if (type.getSqlTypeName() == node.getType().getSqlTypeName()&lt;br/&gt;
-				|| (type.getSqlTypeName() == SqlTypeName.VARCHAR&lt;br/&gt;
-				&amp;amp;&amp;amp; node.getType().getSqlTypeName() == SqlTypeName.CHAR)) {
-			return node;
-		}&lt;br/&gt;
-		return rexBuilder.ensureType(type, node, true);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Gets the list size threshold under which {@link #convertInToOr} is used.&lt;br/&gt;
-	 * Lists of this size or greater will instead be converted to use a join&lt;br/&gt;
-	 * against an inline table&lt;br/&gt;
-	 * ({@link org.apache.calcite.rel.logical.LogicalValues}) rather than a&lt;br/&gt;
-	 * predicate. A threshold of 0 forces usage of an inline table in all cases; a&lt;br/&gt;
-	 * threshold of Integer.MAX_VALUE forces usage of OR in all cases&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @return threshold, default {@link #DEFAULT_IN_SUB_QUERY_THRESHOLD}&lt;br/&gt;
-	 */&lt;br/&gt;
-	@Deprecated // to be removed before 2.0&lt;br/&gt;
-	protected int getInSubqueryThreshold() {
-		return config.getInSubQueryThreshold();
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Converts an EXISTS or IN predicate into a join. For EXISTS, the sub-query&lt;br/&gt;
-	 * produces an indicator variable, and the result is a relational expression&lt;br/&gt;
-	 * which outer joins that indicator to the original query. After performing&lt;br/&gt;
-	 * the outer join, the condition will be TRUE if the EXISTS condition holds,&lt;br/&gt;
-	 * NULL otherwise.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param seek           A query, for example &apos;select * from emp&apos; or&lt;br/&gt;
-	 *                       &apos;values (1,2,3)&apos; or &apos;(&apos;Foo&apos;, 34)&apos;.&lt;br/&gt;
-	 * @param subQueryType   Whether sub-query is IN, EXISTS or scalar&lt;br/&gt;
-	 * @param logic Whether the answer needs to be in full 3-valued logic (TRUE,&lt;br/&gt;
-	 *     FALSE, UNKNOWN) will be required, or whether we can accept an&lt;br/&gt;
-	 *     approximation (say representing UNKNOWN as FALSE)&lt;br/&gt;
-	 * @param notIn Whether the operation is NOT IN&lt;br/&gt;
-	 * @return join expression&lt;br/&gt;
-	 */&lt;br/&gt;
-	private RelOptUtil.Exists convertExists(&lt;br/&gt;
-			SqlNode seek,&lt;br/&gt;
-			RelOptUtil.SubQueryType subQueryType,&lt;br/&gt;
-			RelOptUtil.Logic logic,&lt;br/&gt;
-			boolean notIn,&lt;br/&gt;
-			RelDataType targetDataType) {
-		final SqlValidatorScope seekScope =
-				(seek instanceof SqlSelect)
-						? validator.getSelectScope((SqlSelect) seek)
-						: null;
-		final Blackboard seekBb = createBlackboard(seekScope, null, false);
-		RelNode seekRel = convertQueryOrInList(seekBb, seek, targetDataType);
-
-		return RelOptUtil.createExistsPlan(seekRel,
-				subQueryType, logic, notIn, relBuilder);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private RelNode convertQueryOrInList(&lt;br/&gt;
-			Blackboard bb,&lt;br/&gt;
-			SqlNode seek,&lt;br/&gt;
-			RelDataType targetRowType) {&lt;br/&gt;
-		// NOTE: Once we start accepting single-row queries as row constructors,&lt;br/&gt;
-		// there will be an ambiguity here for a case like X IN ((SELECT Y FROM&lt;br/&gt;
-		// Z)).  The SQL standard resolves the ambiguity by saying that a lone&lt;br/&gt;
-		// select should be interpreted as a table expression, not a row&lt;br/&gt;
-		// expression.  The semantic difference is that a table expression can&lt;br/&gt;
-		// return multiple rows.&lt;br/&gt;
-		if (seek instanceof SqlNodeList) {
-			return convertRowValues(
-					bb,
-					seek,
-					((SqlNodeList) seek).getList(),
-					false,
-					targetRowType);
-		} else {
-			return convertQueryRecursive(seek, false, null).project();
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private RelNode convertRowValues(&lt;br/&gt;
-			Blackboard bb,&lt;br/&gt;
-			SqlNode rowList,&lt;br/&gt;
-			Collection&amp;lt;SqlNode&amp;gt; rows,&lt;br/&gt;
-			boolean allowLiteralsOnly,&lt;br/&gt;
-			RelDataType targetRowType) {&lt;br/&gt;
-		// NOTE jvs 30-Apr-2006: We combine all rows consisting entirely of&lt;br/&gt;
-		// literals into a single LogicalValues; this gives the optimizer a smaller&lt;br/&gt;
-		// input tree.  For everything else (computed expressions, row&lt;br/&gt;
-		// sub-queries), we union each row in as a projection on top of a&lt;br/&gt;
-		// LogicalOneRow.&lt;br/&gt;
-&lt;br/&gt;
-		final ImmutableList.Builder&amp;lt;ImmutableList&amp;lt;RexLiteral&amp;gt;&amp;gt; tupleList =&lt;br/&gt;
-				ImmutableList.builder();&lt;br/&gt;
-		final RelDataType rowType;&lt;br/&gt;
-		if (targetRowType != null) {
-			rowType = targetRowType;
-		} else {
-			rowType =
-					SqlTypeUtil.promoteToRowType(
-							typeFactory,
-							validator.getValidatedNodeType(rowList),
-							null);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		final List&amp;lt;RelNode&amp;gt; unionInputs = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-		for (SqlNode node : rows) {&lt;br/&gt;
-			SqlBasicCall call;&lt;br/&gt;
-			if (isRowConstructor(node)) {&lt;br/&gt;
-				call = (SqlBasicCall) node;&lt;br/&gt;
-				ImmutableList.Builder&amp;lt;RexLiteral&amp;gt; tuple = ImmutableList.builder();&lt;br/&gt;
-				for (Ord&amp;lt;SqlNode&amp;gt; operand : Ord.zip(call.operands)) {&lt;br/&gt;
-					RexLiteral rexLiteral =&lt;br/&gt;
-							convertLiteralInValuesList(&lt;br/&gt;
-									operand.e,&lt;br/&gt;
-									bb,&lt;br/&gt;
-									rowType,&lt;br/&gt;
-									operand.i);&lt;br/&gt;
-					if ((rexLiteral == null) &amp;amp;&amp;amp; allowLiteralsOnly) {
-						return null;
-					}&lt;br/&gt;
-					if ((rexLiteral == null) || !config.isCreateValuesRel()) {
-						// fallback to convertRowConstructor
-						tuple = null;
-						break;
-					}&lt;br/&gt;
-					tuple.add(rexLiteral);&lt;br/&gt;
-				}&lt;br/&gt;
-				if (tuple != null) {
-					tupleList.add(tuple.build());
-					continue;
-				}&lt;br/&gt;
-			} else {&lt;br/&gt;
-				RexLiteral rexLiteral =&lt;br/&gt;
-						convertLiteralInValuesList(&lt;br/&gt;
-								node,&lt;br/&gt;
-								bb,&lt;br/&gt;
-								rowType,&lt;br/&gt;
-								0);&lt;br/&gt;
-				if ((rexLiteral != null) &amp;amp;&amp;amp; config.isCreateValuesRel()) {
-					tupleList.add(ImmutableList.of(rexLiteral));
-					continue;
-				} else {&lt;br/&gt;
-					if ((rexLiteral == null) &amp;amp;&amp;amp; allowLiteralsOnly) {-						return null;-					}&lt;br/&gt;
-				}&lt;br/&gt;
-&lt;br/&gt;
-				// convert &quot;1&quot; to &quot;row(1)&quot;&lt;br/&gt;
-				call =&lt;br/&gt;
-						(SqlBasicCall) SqlStdOperatorTable.ROW.createCall(&lt;br/&gt;
-								SqlParserPos.ZERO,&lt;br/&gt;
-								node);&lt;br/&gt;
-			}&lt;br/&gt;
-			unionInputs.add(convertRowConstructor(bb, call));&lt;br/&gt;
-		}&lt;br/&gt;
-		LogicalValues values =&lt;br/&gt;
-				LogicalValues.create(cluster, rowType, tupleList.build());&lt;br/&gt;
-		RelNode resultRel;&lt;br/&gt;
-		if (unionInputs.isEmpty()) {
-			resultRel = values;
-		} else {&lt;br/&gt;
-			if (!values.getTuples().isEmpty()) {
-				unionInputs.add(values);
-			}&lt;br/&gt;
-			resultRel = LogicalUnion.create(unionInputs, true);&lt;br/&gt;
-		}&lt;br/&gt;
-		leaves.add(resultRel);&lt;br/&gt;
-		return resultRel;&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private RexLiteral convertLiteralInValuesList(&lt;br/&gt;
-			SqlNode sqlNode,&lt;br/&gt;
-			Blackboard bb,&lt;br/&gt;
-			RelDataType rowType,&lt;br/&gt;
-			int iField) {&lt;br/&gt;
-		if (!(sqlNode instanceof SqlLiteral)) {
-			return null;
-		}&lt;br/&gt;
-		RelDataTypeField field = rowType.getFieldList().get(iField);&lt;br/&gt;
-		RelDataType type = field.getType();&lt;br/&gt;
-		if (type.isStruct()) {
-			// null literals for weird stuff like UDT&apos;s need
-			// special handling during type flattening, so
-			// don&apos;t use LogicalValues for those
-			return null;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		RexNode literalExpr =&lt;br/&gt;
-				exprConverter.convertLiteral(&lt;br/&gt;
-						bb,&lt;br/&gt;
-						(SqlLiteral) sqlNode);&lt;br/&gt;
-&lt;br/&gt;
-		if (!(literalExpr instanceof RexLiteral)) {
-			assert literalExpr.isA(SqlKind.CAST);
-			RexNode child = ((RexCall) literalExpr).getOperands().get(0);
-			assert RexLiteral.isNullLiteral(child);
-
-			// NOTE jvs 22-Nov-2006:  we preserve type info
-			// in LogicalValues digest, so it&apos;s OK to lose it here
-			return (RexLiteral) child;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		RexLiteral literal = (RexLiteral) literalExpr;&lt;br/&gt;
-&lt;br/&gt;
-		Comparable value = literal.getValue();&lt;br/&gt;
-&lt;br/&gt;
-		if (SqlTypeUtil.isExactNumeric(type) &amp;amp;&amp;amp; SqlTypeUtil.hasScale(type)) {
-			BigDecimal roundedValue =
-					NumberUtil.rescaleBigDecimal(
-							(BigDecimal) value,
-							type.getScale());
-			return rexBuilder.makeExactLiteral(
-					roundedValue,
-					type);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		if ((value instanceof NlsString)&lt;br/&gt;
-				&amp;amp;&amp;amp; (type.getSqlTypeName() == SqlTypeName.CHAR)) {
-			// pad fixed character type
-			NlsString unpadded = (NlsString) value;
-			return rexBuilder.makeCharLiteral(
-					new NlsString(
-							Spaces.padRight(unpadded.getValue(), type.getPrecision()),
-							unpadded.getCharsetName(),
-							unpadded.getCollation()));
-		}&lt;br/&gt;
-		return literal;&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private boolean isRowConstructor(SqlNode node) {&lt;br/&gt;
-		if (!(node.getKind() == SqlKind.ROW)) {
-			return false;
-		}&lt;br/&gt;
-		SqlCall call = (SqlCall) node;&lt;br/&gt;
-		return call.getOperator().getName().equalsIgnoreCase(&quot;row&quot;);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Builds a list of all &amp;lt;code&amp;gt;IN&amp;lt;/code&amp;gt; or &amp;lt;code&amp;gt;EXISTS&amp;lt;/code&amp;gt; operators&lt;br/&gt;
-	 * inside SQL parse tree. Does not traverse inside queries.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param bb                           blackboard&lt;br/&gt;
-	 * @param node                         the SQL parse tree&lt;br/&gt;
-	 * @param logic Whether the answer needs to be in full 3-valued logic (TRUE,&lt;br/&gt;
-	 *              FALSE, UNKNOWN) will be required, or whether we can accept&lt;br/&gt;
-	 *              an approximation (say representing UNKNOWN as FALSE)&lt;br/&gt;
-	 * @param registerOnlyScalarSubQueries if set to true and the parse tree&lt;br/&gt;
-	 *                                     corresponds to a variation of a select&lt;br/&gt;
-	 *                                     node, only register it if it&apos;s a scalar&lt;br/&gt;
-	 *                                     sub-query&lt;br/&gt;
-	 */&lt;br/&gt;
-	private void findSubQueries(&lt;br/&gt;
-			Blackboard bb,&lt;br/&gt;
-			SqlNode node,&lt;br/&gt;
-			RelOptUtil.Logic logic,&lt;br/&gt;
-			boolean registerOnlyScalarSubQueries) {&lt;br/&gt;
-		final SqlKind kind = node.getKind();&lt;br/&gt;
-		switch (kind) {&lt;br/&gt;
-			case EXISTS:&lt;br/&gt;
-			case SELECT:&lt;br/&gt;
-			case MULTISET_QUERY_CONSTRUCTOR:&lt;br/&gt;
-			case MULTISET_VALUE_CONSTRUCTOR:&lt;br/&gt;
-			case ARRAY_QUERY_CONSTRUCTOR:&lt;br/&gt;
-			case CURSOR:&lt;br/&gt;
-			case SCALAR_QUERY:&lt;br/&gt;
-				if (!registerOnlyScalarSubQueries&lt;br/&gt;
-						|| (kind == SqlKind.SCALAR_QUERY)) {
-					bb.registerSubQuery(node, RelOptUtil.Logic.TRUE_FALSE);
-				}&lt;br/&gt;
-				return;&lt;br/&gt;
-			case IN:&lt;br/&gt;
-				break;&lt;br/&gt;
-			case NOT_IN:&lt;br/&gt;
-			case NOT:&lt;br/&gt;
-				logic = logic.negate();&lt;br/&gt;
-				break;&lt;br/&gt;
-		}&lt;br/&gt;
-		if (node instanceof SqlCall) {&lt;br/&gt;
-			switch (kind) {
-				// Do no change logic for AND, IN and NOT IN expressions;
-				// but do change logic for OR, NOT and others;
-				// EXISTS was handled already.
-				case AND:
-				case IN:
-				case NOT_IN:
-					break;
-				default:
-					logic = RelOptUtil.Logic.TRUE_FALSE_UNKNOWN;
-					break;
-			}&lt;br/&gt;
-			for (SqlNode operand : ((SqlCall) node).getOperandList()) {&lt;br/&gt;
-				if (operand != null) {
-					// In the case of an IN expression, locate scalar
-					// sub-queries so we can convert them to constants
-					findSubQueries(bb, operand, logic,
-							kind == SqlKind.IN || kind == SqlKind.NOT_IN
-									|| kind == SqlKind.SOME || kind == SqlKind.ALL
-									|| registerOnlyScalarSubQueries);
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-		} else if (node instanceof SqlNodeList) {&lt;br/&gt;
-			for (SqlNode child : (SqlNodeList) node) {
-				findSubQueries(bb, child, logic,
-						kind == SqlKind.IN || kind == SqlKind.NOT_IN
-								|| kind == SqlKind.SOME || kind == SqlKind.ALL
-								|| registerOnlyScalarSubQueries);
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		// Now that we&apos;ve located any scalar sub-queries inside the IN&lt;br/&gt;
-		// expression, register the IN expression itself.  We need to&lt;br/&gt;
-		// register the scalar sub-queries first so they can be converted&lt;br/&gt;
-		// before the IN expression is converted.&lt;br/&gt;
-		switch (kind) {&lt;br/&gt;
-			case IN:&lt;br/&gt;
-			case NOT_IN:&lt;br/&gt;
-			case SOME:&lt;br/&gt;
-			case ALL:&lt;br/&gt;
-				switch (logic) {&lt;br/&gt;
-					case TRUE_FALSE_UNKNOWN:&lt;br/&gt;
-						if (validator.getValidatedNodeType(node).isNullable()) {
-							break;
-						} else if (true) {-							break;-						}&lt;br/&gt;
-						// fall through&lt;br/&gt;
-					case UNKNOWN_AS_FALSE:&lt;br/&gt;
-						logic = RelOptUtil.Logic.TRUE;&lt;br/&gt;
-				}&lt;br/&gt;
-				bb.registerSubQuery(node, logic);&lt;br/&gt;
-				break;&lt;br/&gt;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Converts an expression from {@link SqlNode} to {@link RexNode} format.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param node Expression to translate&lt;br/&gt;
-	 * @return Converted expression&lt;br/&gt;
-	 */&lt;br/&gt;
-	public RexNode convertExpression(&lt;br/&gt;
-			SqlNode node) {
-		Map&amp;lt;String, RelDataType&amp;gt; nameToTypeMap = Collections.emptyMap();
-		final ParameterScope scope =
-				new ParameterScope((SqlValidatorImpl) validator, nameToTypeMap);
-		final Blackboard bb = createBlackboard(scope, null, false);
-		return bb.convertExpression(node);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Converts an expression from {@link SqlNode} to {@link RexNode} format,&lt;br/&gt;
-	 * mapping identifier references to predefined expressions.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param node          Expression to translate&lt;br/&gt;
-	 * @param nameToNodeMap map from String to {@link RexNode}; when an&lt;br/&gt;
-	 *                      {@link SqlIdentifier} is encountered, it is used as a&lt;br/&gt;
-	 *                      key and translated to the corresponding value from&lt;br/&gt;
-	 *                      this map&lt;br/&gt;
-	 * @return Converted expression&lt;br/&gt;
-	 */&lt;br/&gt;
-	public RexNode convertExpression(&lt;br/&gt;
-			SqlNode node,&lt;br/&gt;
-			Map&amp;lt;String, RexNode&amp;gt; nameToNodeMap) {&lt;br/&gt;
-		final Map&amp;lt;String, RelDataType&amp;gt; nameToTypeMap = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
-		for (Map.Entry&amp;lt;String, RexNode&amp;gt; entry : nameToNodeMap.entrySet()) {
-			nameToTypeMap.put(entry.getKey(), entry.getValue().getType());
-		}&lt;br/&gt;
-		final ParameterScope scope =&lt;br/&gt;
-				new ParameterScope((SqlValidatorImpl) validator, nameToTypeMap);&lt;br/&gt;
-		final Blackboard bb = createBlackboard(scope, nameToNodeMap, false);&lt;br/&gt;
-		return bb.convertExpression(node);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Converts a non-standard expression.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;This method is an extension-point that derived classes can override. If&lt;br/&gt;
-	 * this method returns a null result, the normal expression translation&lt;br/&gt;
-	 * process will proceed. The default implementation always returns null.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param node Expression&lt;br/&gt;
-	 * @param bb   Blackboard&lt;br/&gt;
-	 * @return null to proceed with the usual expression translation process&lt;br/&gt;
-	 */&lt;br/&gt;
-	protected RexNode convertExtendedExpression(&lt;br/&gt;
-			SqlNode node,&lt;br/&gt;
-			Blackboard bb) {
-		return null;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private RexNode convertOver(Blackboard bb, SqlNode node) {&lt;br/&gt;
-		SqlCall call = (SqlCall) node;&lt;br/&gt;
-		SqlCall aggCall = call.operand(0);&lt;br/&gt;
-		SqlNode windowOrRef = call.operand(1);&lt;br/&gt;
-		final SqlWindow window =&lt;br/&gt;
-				validator.resolveWindow(windowOrRef, bb.scope, true);&lt;br/&gt;
-&lt;br/&gt;
-		// ROW_NUMBER() expects specific kind of framing.&lt;br/&gt;
-		if (aggCall.getKind() == SqlKind.ROW_NUMBER) {
-			window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));
-			window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));
-			window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));
-		}&lt;br/&gt;
-		final SqlNodeList partitionList = window.getPartitionList();&lt;br/&gt;
-		final ImmutableList.Builder&amp;lt;RexNode&amp;gt; partitionKeys =&lt;br/&gt;
-				ImmutableList.builder();&lt;br/&gt;
-		for (SqlNode partition : partitionList) {
-			partitionKeys.add(bb.convertExpression(partition));
-		}&lt;br/&gt;
-		RexNode lowerBound = bb.convertExpression(window.getLowerBound());&lt;br/&gt;
-		RexNode upperBound = bb.convertExpression(window.getUpperBound());&lt;br/&gt;
-		SqlNodeList orderList = window.getOrderList();&lt;br/&gt;
-		if ((orderList.size() == 0) &amp;amp;&amp;amp; !window.isRows()) {&lt;br/&gt;
-			// A logical range requires an ORDER BY clause. Use the implicit&lt;br/&gt;
-			// ordering of this relation. There must be one, otherwise it would&lt;br/&gt;
-			// have failed validation.&lt;br/&gt;
-			orderList = bb.scope.getOrderList();&lt;br/&gt;
-			if (orderList == null) {
-				throw new AssertionError(
-						&quot;Relation should have sort key for implicit ORDER BY&quot;);
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		final ImmutableList.Builder&amp;lt;RexFieldCollation&amp;gt; orderKeys =&lt;br/&gt;
-				ImmutableList.builder();&lt;br/&gt;
-		for (SqlNode order : orderList) {
-			orderKeys.add(
-					bb.convertSortExpression(order,
-							RelFieldCollation.Direction.ASCENDING,
-							RelFieldCollation.NullDirection.UNSPECIFIED));
-		}&lt;br/&gt;
-&lt;br/&gt;
-		try {
-			Preconditions.checkArgument(bb.window == null,
-					&quot;already in window agg mode&quot;);
-			bb.window = window;
-			RexNode rexAgg = exprConverter.convertCall(bb, aggCall);
-			rexAgg =
-					rexBuilder.ensureType(
-							validator.getValidatedNodeType(call), rexAgg, false);
-
-			// Walk over the tree and apply &apos;over&apos; to all agg functions. This is
-			// necessary because the returned expression is not necessarily a call
-			// to an agg function. For example, AVG(x) becomes SUM(x) / COUNT(x).
-
-			final SqlLiteral q = aggCall.getFunctionQuantifier();
-			final boolean isDistinct = q != null
-					&amp;amp;&amp;amp; q.getValue() == SqlSelectKeyword.DISTINCT;
-
-			final RexShuttle visitor =
-					new HistogramShuttle(
-							partitionKeys.build(), orderKeys.build(),
-							RexWindowBound.create(window.getLowerBound(), lowerBound),
-							RexWindowBound.create(window.getUpperBound(), upperBound),
-							window,
-							isDistinct);
-			RexNode overNode = rexAgg.accept(visitor);
-
-			return overNode;
-		} finally {
-			bb.window = null;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Converts a FROM clause into a relational expression.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param bb   Scope within which to resolve identifiers&lt;br/&gt;
-	 * @param from FROM clause of a query. Examples include:&lt;br/&gt;
-	 *&lt;br/&gt;
-	 *             &amp;lt;ul&amp;gt;&lt;br/&gt;
-	 *             &amp;lt;li&amp;gt;a single table (&quot;SALES.EMP&quot;),&lt;br/&gt;
-	 *             &amp;lt;li&amp;gt;an aliased table (&quot;EMP AS E&quot;),&lt;br/&gt;
-	 *             &amp;lt;li&amp;gt;a list of tables (&quot;EMP, DEPT&quot;),&lt;br/&gt;
-	 *             &amp;lt;li&amp;gt;an ANSI Join expression (&quot;EMP JOIN DEPT ON EMP.DEPTNO =&lt;br/&gt;
-	 *             DEPT.DEPTNO&quot;),&lt;br/&gt;
-	 *             &amp;lt;li&amp;gt;a VALUES clause (&quot;VALUES (&apos;Fred&apos;, 20)&quot;),&lt;br/&gt;
-	 *             &amp;lt;li&amp;gt;a query (&quot;(SELECT * FROM EMP WHERE GENDER = &apos;F&apos;)&quot;),&lt;br/&gt;
-	 *             &amp;lt;li&amp;gt;or any combination of the above.&lt;br/&gt;
-	 *             &amp;lt;/ul&amp;gt;&lt;br/&gt;
-	 */&lt;br/&gt;
-	protected void convertFrom(&lt;br/&gt;
-			Blackboard bb,&lt;br/&gt;
-			SqlNode from) {&lt;br/&gt;
-		if (from == null) {
-			bb.setRoot(LogicalValues.createOneRow(cluster), false);
-			return;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		final SqlCall call;&lt;br/&gt;
-		final SqlNode[] operands;&lt;br/&gt;
-		switch (from.getKind()) {&lt;br/&gt;
-			case MATCH_RECOGNIZE:&lt;br/&gt;
-				convertMatchRecognize(bb, (SqlCall) from);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case AS:&lt;br/&gt;
-				call = (SqlCall) from;&lt;br/&gt;
-				convertFrom(bb, call.operand(0));&lt;br/&gt;
-				if (call.operandCount() &amp;gt; 2&lt;br/&gt;
-						&amp;amp;&amp;amp; bb.root instanceof Values) {&lt;br/&gt;
-					final List&amp;lt;String&amp;gt; fieldNames = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-					for (SqlNode node : Util.skip(call.getOperandList(), 2)) {
-						fieldNames.add(((SqlIdentifier) node).getSimple());
-					}&lt;br/&gt;
-					bb.setRoot(relBuilder.push(bb.root).rename(fieldNames).build(), true);&lt;br/&gt;
-				}&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case WITH_ITEM:&lt;br/&gt;
-				convertFrom(bb, ((SqlWithItem) from).query);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case WITH:&lt;br/&gt;
-				convertFrom(bb, ((SqlWith) from).body);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case TABLESAMPLE:&lt;br/&gt;
-				operands = ((SqlBasicCall) from).getOperands();&lt;br/&gt;
-				SqlSampleSpec sampleSpec = SqlLiteral.sampleValue(operands&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;);&lt;br/&gt;
-				if (sampleSpec instanceof SqlSampleSpec.SqlSubstitutionSampleSpec) {
-					String sampleName =
-							((SqlSampleSpec.SqlSubstitutionSampleSpec) sampleSpec)
-									.getName();
-					datasetStack.push(sampleName);
-					convertFrom(bb, operands[0]);
-					datasetStack.pop();
-				} else if (sampleSpec instanceof SqlSampleSpec.SqlTableSampleSpec) {
-					SqlSampleSpec.SqlTableSampleSpec tableSampleSpec =
-							(SqlSampleSpec.SqlTableSampleSpec) sampleSpec;
-					convertFrom(bb, operands[0]);
-					RelOptSamplingParameters params =
-							new RelOptSamplingParameters(
-									tableSampleSpec.isBernoulli(),
-									tableSampleSpec.getSamplePercentage(),
-									tableSampleSpec.isRepeatable(),
-									tableSampleSpec.getRepeatableSeed());
-					bb.setRoot(new Sample(cluster, bb.root, params), false);
-				} else {
-					throw new AssertionError(&quot;unknown TABLESAMPLE type: &quot; + sampleSpec);
-				}&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case IDENTIFIER:&lt;br/&gt;
-				convertIdentifier(bb, (SqlIdentifier) from, null);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case EXTEND:&lt;br/&gt;
-				call = (SqlCall) from;&lt;br/&gt;
-				SqlIdentifier id = (SqlIdentifier) call.getOperandList().get(0);&lt;br/&gt;
-				SqlNodeList extendedColumns = (SqlNodeList) call.getOperandList().get(1);&lt;br/&gt;
-				convertIdentifier(bb, id, extendedColumns);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case JOIN:&lt;br/&gt;
-				final SqlJoin join = (SqlJoin) from;&lt;br/&gt;
-				final SqlValidatorScope scope = validator.getJoinScope(from);&lt;br/&gt;
-				final Blackboard fromBlackboard = createBlackboard(scope, null, false);&lt;br/&gt;
-				SqlNode left = join.getLeft();&lt;br/&gt;
-				SqlNode right = join.getRight();&lt;br/&gt;
-				final boolean isNatural = join.isNatural();&lt;br/&gt;
-				final JoinType joinType = join.getJoinType();&lt;br/&gt;
-				final SqlValidatorScope leftScope =&lt;br/&gt;
-						Util.first(validator.getJoinScope(left),&lt;br/&gt;
-								((DelegatingScope) bb.scope).getParent());&lt;br/&gt;
-				final Blackboard leftBlackboard =&lt;br/&gt;
-						createBlackboard(leftScope, null, false);&lt;br/&gt;
-				final SqlValidatorScope rightScope =&lt;br/&gt;
-						Util.first(validator.getJoinScope(right),&lt;br/&gt;
-								((DelegatingScope) bb.scope).getParent());&lt;br/&gt;
-				final Blackboard rightBlackboard =&lt;br/&gt;
-						createBlackboard(rightScope, null, false);&lt;br/&gt;
-				convertFrom(leftBlackboard, left);&lt;br/&gt;
-				RelNode leftRel = leftBlackboard.root;&lt;br/&gt;
-				convertFrom(rightBlackboard, right);&lt;br/&gt;
-				RelNode rightRel = rightBlackboard.root;&lt;br/&gt;
-				JoinRelType convertedJoinType = convertJoinType(joinType);&lt;br/&gt;
-				RexNode conditionExp;&lt;br/&gt;
-				final SqlValidatorNamespace leftNamespace = validator.getNamespace(left);&lt;br/&gt;
-				final SqlValidatorNamespace rightNamespace = validator.getNamespace(right);&lt;br/&gt;
-				if (isNatural) {
-					final RelDataType leftRowType = leftNamespace.getRowType();
-					final RelDataType rightRowType = rightNamespace.getRowType();
-					final List&amp;lt;String&amp;gt; columnList =
-							SqlValidatorUtil.deriveNaturalJoinColumnList(
-									catalogReader.nameMatcher(), leftRowType, rightRowType);
-					conditionExp = convertUsing(leftNamespace, rightNamespace, columnList);
-				} else {
-					conditionExp =
-							convertJoinCondition(
-									fromBlackboard,
-									leftNamespace,
-									rightNamespace,
-									join.getCondition(),
-									join.getConditionType(),
-									leftRel,
-									rightRel);
-				}&lt;br/&gt;
-&lt;br/&gt;
-				final RelNode joinRel =&lt;br/&gt;
-						createJoin(&lt;br/&gt;
-								fromBlackboard,&lt;br/&gt;
-								leftRel,&lt;br/&gt;
-								rightRel,&lt;br/&gt;
-								conditionExp,&lt;br/&gt;
-								convertedJoinType);&lt;br/&gt;
-				bb.setRoot(joinRel, false);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case SELECT:&lt;br/&gt;
-			case INTERSECT:&lt;br/&gt;
-			case EXCEPT:&lt;br/&gt;
-			case UNION:&lt;br/&gt;
-				final RelNode rel = convertQueryRecursive(from, false, null).project();&lt;br/&gt;
-				bb.setRoot(rel, true);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case VALUES:&lt;br/&gt;
-				convertValuesImpl(bb, (SqlCall) from, null);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case UNNEST:&lt;br/&gt;
-				call = (SqlCall) from;&lt;br/&gt;
-				final List&amp;lt;SqlNode&amp;gt; nodes = call.getOperandList();&lt;br/&gt;
-				final SqlUnnestOperator operator = (SqlUnnestOperator) call.getOperator();&lt;br/&gt;
-				for (SqlNode node : nodes) {
-					replaceSubQueries(bb, node, RelOptUtil.Logic.TRUE_FALSE_UNKNOWN);
-				}&lt;br/&gt;
-				final List&amp;lt;RexNode&amp;gt; exprs = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-				final List&amp;lt;String&amp;gt; fieldNames = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-				for (Ord&amp;lt;SqlNode&amp;gt; node : Ord.zip(nodes)) {
-					exprs.add(bb.convertExpression(node.e));
-					fieldNames.add(validator.deriveAlias(node.e, node.i));
-				}&lt;br/&gt;
-				RelNode child =&lt;br/&gt;
-						(null != bb.root) ? bb.root : LogicalValues.createOneRow(cluster);&lt;br/&gt;
-				relBuilder.push(child).projectNamed(exprs, fieldNames, false);&lt;br/&gt;
-&lt;br/&gt;
-				Uncollect uncollect =&lt;br/&gt;
-						new Uncollect(cluster, cluster.traitSetOf(Convention.NONE),&lt;br/&gt;
-								relBuilder.build(), operator.withOrdinality);&lt;br/&gt;
-				bb.setRoot(uncollect, true);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			case COLLECTION_TABLE:&lt;br/&gt;
-				call = (SqlCall) from;&lt;br/&gt;
-&lt;br/&gt;
-				// Dig out real call; TABLE() wrapper is just syntactic.&lt;br/&gt;
-				assert call.getOperandList().size() == 1;&lt;br/&gt;
-				final SqlCall call2 = call.operand(0);&lt;br/&gt;
-				convertCollectionTable(bb, call2);&lt;br/&gt;
-				return;&lt;br/&gt;
-&lt;br/&gt;
-			default:&lt;br/&gt;
-				throw new AssertionError(&quot;not a join operator &quot; + from);&lt;br/&gt;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	protected void convertMatchRecognize(Blackboard bb, SqlCall call) {&lt;br/&gt;
-		final SqlMatchRecognize matchRecognize = (SqlMatchRecognize) call;&lt;br/&gt;
-		final SqlValidatorNamespace ns = validator.getNamespace(matchRecognize);&lt;br/&gt;
-		final SqlValidatorScope scope = validator.getMatchRecognizeScope(matchRecognize);&lt;br/&gt;
-&lt;br/&gt;
-		final Blackboard matchBb = createBlackboard(scope, null, false);&lt;br/&gt;
-		final RelDataType rowType = ns.getRowType();&lt;br/&gt;
-		// convert inner query, could be a table name or a derived table&lt;br/&gt;
-		SqlNode expr = matchRecognize.getTableRef();&lt;br/&gt;
-		convertFrom(matchBb, expr);&lt;br/&gt;
-		final RelNode input = matchBb.root;&lt;br/&gt;
-&lt;br/&gt;
-		// PARTITION BY&lt;br/&gt;
-		final SqlNodeList partitionList = matchRecognize.getPartitionList();&lt;br/&gt;
-		final List&amp;lt;RexNode&amp;gt; partitionKeys = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-		for (SqlNode partition : partitionList) {
-			RexNode e = matchBb.convertExpression(partition);
-			partitionKeys.add(e);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		// ORDER BY&lt;br/&gt;
-		final SqlNodeList orderList = matchRecognize.getOrderList();&lt;br/&gt;
-		final List&amp;lt;RelFieldCollation&amp;gt; orderKeys = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-		for (SqlNode order : orderList) {&lt;br/&gt;
-			final RelFieldCollation.Direction direction;&lt;br/&gt;
-			switch (order.getKind()) {
-				case DESCENDING:
-					direction = RelFieldCollation.Direction.DESCENDING;
-					order = ((SqlCall) order).operand(0);
-					break;
-				case NULLS_FIRST:
-				case NULLS_LAST:
-					throw new AssertionError();
-				default:
-					direction = RelFieldCollation.Direction.ASCENDING;
-					break;
-			}&lt;br/&gt;
-			final RelFieldCollation.NullDirection nullDirection =&lt;br/&gt;
-					validator.getDefaultNullCollation().last(desc(direction))&lt;br/&gt;
-							? RelFieldCollation.NullDirection.LAST&lt;br/&gt;
-							: RelFieldCollation.NullDirection.FIRST;&lt;br/&gt;
-			RexNode e = matchBb.convertExpression(order);&lt;br/&gt;
-			orderKeys.add(&lt;br/&gt;
-					new RelFieldCollation(((RexInputRef) e).getIndex(), direction,&lt;br/&gt;
-							nullDirection));&lt;br/&gt;
-		}&lt;br/&gt;
-		final RelCollation orders = cluster.traitSet().canonize(RelCollations.of(orderKeys));&lt;br/&gt;
-&lt;br/&gt;
-		// convert pattern&lt;br/&gt;
-		final Set&amp;lt;String&amp;gt; patternVarsSet = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
-		SqlNode pattern = matchRecognize.getPattern();&lt;br/&gt;
-		final SqlBasicVisitor&amp;lt;RexNode&amp;gt; patternVarVisitor =&lt;br/&gt;
-				new SqlBasicVisitor&amp;lt;RexNode&amp;gt;() {&lt;br/&gt;
-					@Override public RexNode visit(SqlCall call) {&lt;br/&gt;
-						List&amp;lt;SqlNode&amp;gt; operands = call.getOperandList();&lt;br/&gt;
-						List&amp;lt;RexNode&amp;gt; newOperands = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-						for (SqlNode node : operands) {
-							newOperands.add(node.accept(this));
-						}&lt;br/&gt;
-						return rexBuilder.makeCall(&lt;br/&gt;
-								validator.getUnknownType(), call.getOperator(), newOperands);&lt;br/&gt;
-					}&lt;br/&gt;
-&lt;br/&gt;
-					@Override public RexNode visit(SqlIdentifier id) {
-						assert id.isSimple();
-						patternVarsSet.add(id.getSimple());
-						return rexBuilder.makeLiteral(id.getSimple());
-					}&lt;br/&gt;
-&lt;br/&gt;
-					@Override public RexNode visit(SqlLiteral literal) {&lt;br/&gt;
-						if (literal instanceof SqlNumericLiteral) {
-							return rexBuilder.makeExactLiteral(BigDecimal.valueOf(literal.intValue(true)));
-						} else {
-							return rexBuilder.makeLiteral(literal.booleanValue());
-						}&lt;br/&gt;
-					}&lt;br/&gt;
-				};&lt;br/&gt;
-		final RexNode patternNode = pattern.accept(patternVarVisitor);&lt;br/&gt;
-&lt;br/&gt;
-		SqlLiteral interval = matchRecognize.getInterval();&lt;br/&gt;
-		RexNode intervalNode = null;&lt;br/&gt;
-		if (interval != null) {
-			intervalNode = matchBb.convertLiteral(interval);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		// convert subset&lt;br/&gt;
-		final SqlNodeList subsets = matchRecognize.getSubsetList();&lt;br/&gt;
-		final Map&amp;lt;String, TreeSet&amp;lt;String&amp;gt;&amp;gt; subsetMap = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
-		for (SqlNode node : subsets) {&lt;br/&gt;
-			List&amp;lt;SqlNode&amp;gt; operands = ((SqlCall) node).getOperandList();&lt;br/&gt;
-			SqlIdentifier left = (SqlIdentifier) operands.get(0);&lt;br/&gt;
-			patternVarsSet.add(left.getSimple());&lt;br/&gt;
-			SqlNodeList rights = (SqlNodeList) operands.get(1);&lt;br/&gt;
-			final TreeSet&amp;lt;String&amp;gt; list = new TreeSet&amp;lt;String&amp;gt;();&lt;br/&gt;
-			for (SqlNode right : rights) {
-				assert right instanceof SqlIdentifier;
-				list.add(((SqlIdentifier) right).getSimple());
-			}&lt;br/&gt;
-			subsetMap.put(left.getSimple(), list);&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		SqlNode afterMatch = matchRecognize.getAfter();&lt;br/&gt;
-		if (afterMatch == null) {
-			afterMatch =
-					SqlMatchRecognize.AfterOption.SKIP_TO_NEXT_ROW.symbol(SqlParserPos.ZERO);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		final RexNode after;&lt;br/&gt;
-		if (afterMatch instanceof SqlCall) {
-			List&amp;lt;SqlNode&amp;gt; operands = ((SqlCall) afterMatch).getOperandList();
-			SqlOperator operator = ((SqlCall) afterMatch).getOperator();
-			assert operands.size() == 1;
-			SqlIdentifier id = (SqlIdentifier) operands.get(0);
-			assert patternVarsSet.contains(id.getSimple())
-					: id.getSimple() + &quot; not defined in pattern&quot;;
-			RexNode rex = rexBuilder.makeLiteral(id.getSimple());
-			after =
-					rexBuilder.makeCall(validator.getUnknownType(), operator,
-							ImmutableList.of(rex));
-		} else {
-			after = matchBb.convertExpression(afterMatch);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		matchBb.setPatternVarRef(true);&lt;br/&gt;
-&lt;br/&gt;
-		// convert measures&lt;br/&gt;
-		final ImmutableMap.Builder&amp;lt;String, RexNode&amp;gt; measureNodes =&lt;br/&gt;
-				ImmutableMap.builder();&lt;br/&gt;
-		for (SqlNode measure : matchRecognize.getMeasureList()) {
-			List&amp;lt;SqlNode&amp;gt; operands = ((SqlCall) measure).getOperandList();
-			String alias = ((SqlIdentifier) operands.get(1)).getSimple();
-			RexNode rex = matchBb.convertExpression(operands.get(0));
-			measureNodes.put(alias, rex);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		// convert definitions&lt;br/&gt;
-		final ImmutableMap.Builder&amp;lt;String, RexNode&amp;gt; definitionNodes =&lt;br/&gt;
-				ImmutableMap.builder();&lt;br/&gt;
-		for (SqlNode def : matchRecognize.getPatternDefList()) {
-			List&amp;lt;SqlNode&amp;gt; operands = ((SqlCall) def).getOperandList();
-			String alias = ((SqlIdentifier) operands.get(1)).getSimple();
-			RexNode rex = matchBb.convertExpression(operands.get(0));
-			definitionNodes.put(alias, rex);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		final SqlLiteral rowsPerMatch = matchRecognize.getRowsPerMatch();&lt;br/&gt;
-		final boolean allRows = rowsPerMatch != null&lt;br/&gt;
-				&amp;amp;&amp;amp; rowsPerMatch.getValue() == SqlMatchRecognize.RowsPerMatchOption.ALL_ROWS;&lt;br/&gt;
-&lt;br/&gt;
-		matchBb.setPatternVarRef(false);&lt;br/&gt;
-&lt;br/&gt;
-		final RelFactories.MatchFactory factory =&lt;br/&gt;
-				RelFactories.DEFAULT_MATCH_FACTORY;&lt;br/&gt;
-		final RelNode rel =&lt;br/&gt;
-				factory.createMatch(input, patternNode,&lt;br/&gt;
-						rowType, matchRecognize.getStrictStart().booleanValue(),&lt;br/&gt;
-						matchRecognize.getStrictEnd().booleanValue(),&lt;br/&gt;
-						definitionNodes.build(), measureNodes.build(), after,&lt;br/&gt;
-						subsetMap, allRows, partitionKeys, orders, intervalNode);&lt;br/&gt;
-		bb.setRoot(rel, false);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private void convertIdentifier(Blackboard bb, SqlIdentifier id,&lt;br/&gt;
-	                               SqlNodeList extendedColumns) {&lt;br/&gt;
-		final SqlValidatorNamespace fromNamespace =&lt;br/&gt;
-				validator.getNamespace(id).resolve();&lt;br/&gt;
-		if (fromNamespace.getNode() != null) {
-			convertFrom(bb, fromNamespace.getNode());
-			return;
-		}&lt;br/&gt;
-		final String datasetName =&lt;br/&gt;
-				datasetStack.isEmpty() ? null : datasetStack.peek();&lt;br/&gt;
-		final boolean[] usedDataset = {false};&lt;br/&gt;
-		RelOptTable table =&lt;br/&gt;
-				SqlValidatorUtil.getRelOptTable(fromNamespace, catalogReader,&lt;br/&gt;
-						datasetName, usedDataset);&lt;br/&gt;
-		if (extendedColumns != null &amp;amp;&amp;amp; extendedColumns.size() &amp;gt; 0) {
-			assert table != null;
-			final SqlValidatorTable validatorTable =
-					table.unwrap(SqlValidatorTable.class);
-			final List&amp;lt;RelDataTypeField&amp;gt; extendedFields =
-					SqlValidatorUtil.getExtendedColumns(validator.getTypeFactory(), validatorTable,
-							extendedColumns);
-			table = table.extend(extendedFields);
-		}&lt;br/&gt;
-		final RelNode tableRel;&lt;br/&gt;
-		if (config.isConvertTableAccess()) {
-			tableRel = toRel(table);
-		} else {
-			tableRel = LogicalTableScan.create(cluster, table);
-		}&lt;br/&gt;
-		bb.setRoot(tableRel, true);&lt;br/&gt;
-		if (usedDataset&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;) {
-			bb.setDataset(datasetName);
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	protected void convertCollectionTable(&lt;br/&gt;
-			Blackboard bb,&lt;br/&gt;
-			SqlCall call) {&lt;br/&gt;
-		final SqlOperator operator = call.getOperator();&lt;br/&gt;
-		if (operator == SqlStdOperatorTable.TABLESAMPLE) {
-			final String sampleName =
-					SqlLiteral.unchain(call.operand(0)).getValueAs(String.class);
-			datasetStack.push(sampleName);
-			SqlCall cursorCall = call.operand(1);
-			SqlNode query = cursorCall.operand(0);
-			RelNode converted = convertQuery(query, false, false).rel;
-			bb.setRoot(converted, false);
-			datasetStack.pop();
-			return;
-		}&lt;br/&gt;
-		replaceSubQueries(bb, call, RelOptUtil.Logic.TRUE_FALSE_UNKNOWN);&lt;br/&gt;
-&lt;br/&gt;
-		// Expand table macro if possible. It&apos;s more efficient than&lt;br/&gt;
-		// LogicalTableFunctionScan.&lt;br/&gt;
-		final SqlCallBinding callBinding =&lt;br/&gt;
-				new SqlCallBinding(bb.scope.getValidator(), bb.scope, call);&lt;br/&gt;
-		if (operator instanceof SqlUserDefinedTableMacro) {
-			final SqlUserDefinedTableMacro udf =
-					(SqlUserDefinedTableMacro) operator;
-			final TranslatableTable table =
-					udf.getTable(typeFactory, callBinding.operands());
-			final RelDataType rowType = table.getRowType(typeFactory);
-			RelOptTable relOptTable = RelOptTableImpl.create(null, rowType, table,
-					udf.getNameAsId().names);
-			RelNode converted = toRel(relOptTable);
-			bb.setRoot(converted, true);
-			return;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		Type elementType;&lt;br/&gt;
-		if (operator instanceof SqlUserDefinedTableFunction) {
-			SqlUserDefinedTableFunction udtf = (SqlUserDefinedTableFunction) operator;
-			elementType = udtf.getElementType(typeFactory, callBinding.operands());
-		} else {
-			elementType = null;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		RexNode rexCall = bb.convertExpression(call);&lt;br/&gt;
-		final List&amp;lt;RelNode&amp;gt; inputs = bb.retrieveCursors();&lt;br/&gt;
-		Set&amp;lt;RelColumnMapping&amp;gt; columnMappings =&lt;br/&gt;
-				getColumnMappings(operator);&lt;br/&gt;
-		LogicalTableFunctionScan callRel =&lt;br/&gt;
-				LogicalTableFunctionScan.create(&lt;br/&gt;
-						cluster,&lt;br/&gt;
-						inputs,&lt;br/&gt;
-						rexCall,&lt;br/&gt;
-						elementType,&lt;br/&gt;
-						validator.getValidatedNodeType(call),&lt;br/&gt;
-						columnMappings);&lt;br/&gt;
-		bb.setRoot(callRel, true);&lt;br/&gt;
-		afterTableFunction(bb, call, callRel);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	protected void afterTableFunction(&lt;br/&gt;
-			SqlToRelConverter.Blackboard bb,&lt;br/&gt;
-			SqlCall call,&lt;br/&gt;
-			LogicalTableFunctionScan callRel) {
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private Set&amp;lt;RelColumnMapping&amp;gt; getColumnMappings(SqlOperator op) {&lt;br/&gt;
-		SqlReturnTypeInference rti = op.getReturnTypeInference();&lt;br/&gt;
-		if (rti == null) {-			return null;-		}&lt;br/&gt;
-		if (rti instanceof TableFunctionReturnTypeInference) {
-			TableFunctionReturnTypeInference tfrti =
-					(TableFunctionReturnTypeInference) rti;
-			return tfrti.getColumnMappings();
-		} else {
-			return null;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	protected RelNode createJoin(&lt;br/&gt;
-			Blackboard bb,&lt;br/&gt;
-			RelNode leftRel,&lt;br/&gt;
-			RelNode rightRel,&lt;br/&gt;
-			RexNode joinCond,&lt;br/&gt;
-			JoinRelType joinType) {&lt;br/&gt;
-		assert joinCond != null;&lt;br/&gt;
-&lt;br/&gt;
-		final CorrelationUse p = getCorrelationUse(bb, rightRel);&lt;br/&gt;
-		if (p != null) {&lt;br/&gt;
-			LogicalCorrelate corr = LogicalCorrelate.create(leftRel, p.r,&lt;br/&gt;
-					p.id, p.requiredColumns, SemiJoinType.of(joinType));&lt;br/&gt;
-			if (!joinCond.isAlwaysTrue()) {
-				final RelFactories.FilterFactory factory =
-						RelFactories.DEFAULT_FILTER_FACTORY;
-				return factory.createFilter(corr, joinCond);
-			}&lt;br/&gt;
-			return corr;&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		final Join originalJoin =&lt;br/&gt;
-				(Join) RelFactories.DEFAULT_JOIN_FACTORY.createJoin(leftRel, rightRel,&lt;br/&gt;
-						joinCond, ImmutableSet.of(), joinType, false);&lt;br/&gt;
-&lt;br/&gt;
-		return RelOptUtil.pushDownJoinConditions(originalJoin, relBuilder);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private CorrelationUse getCorrelationUse(Blackboard bb, final RelNode r0) {&lt;br/&gt;
-		final Set&amp;lt;CorrelationId&amp;gt; correlatedVariables =&lt;br/&gt;
-				RelOptUtil.getVariablesUsed(r0);&lt;br/&gt;
-		if (correlatedVariables.isEmpty()) {-			return null;-		}&lt;br/&gt;
-		final ImmutableBitSet.Builder requiredColumns = ImmutableBitSet.builder();&lt;br/&gt;
-		final List&amp;lt;CorrelationId&amp;gt; correlNames = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;br/&gt;
-		// All correlations must refer the same namespace since correlation&lt;br/&gt;
-		// produces exactly one correlation source.&lt;br/&gt;
-		// The same source might be referenced by different variables since&lt;br/&gt;
-		// DeferredLookups are not de-duplicated at create time.&lt;br/&gt;
-		SqlValidatorNamespace prevNs = null;&lt;br/&gt;
-&lt;br/&gt;
-		for (CorrelationId correlName : correlatedVariables) {&lt;br/&gt;
-			DeferredLookup lookup =&lt;br/&gt;
-					mapCorrelToDeferred.get(correlName);&lt;br/&gt;
-			RexFieldAccess fieldAccess = lookup.getFieldAccess(correlName);&lt;br/&gt;
-			String originalRelName = lookup.getOriginalRelName();&lt;br/&gt;
-			String originalFieldName = fieldAccess.getField().getName();&lt;br/&gt;
-&lt;br/&gt;
-			final SqlNameMatcher nameMatcher =&lt;br/&gt;
-					bb.getValidator().getCatalogReader().nameMatcher();&lt;br/&gt;
-			final SqlValidatorScope.ResolvedImpl resolved =&lt;br/&gt;
-					new SqlValidatorScope.ResolvedImpl();&lt;br/&gt;
-			lookup.bb.scope.resolve(ImmutableList.of(originalRelName),&lt;br/&gt;
-					nameMatcher, false, resolved);&lt;br/&gt;
-			assert resolved.count() == 1;&lt;br/&gt;
-			final SqlValidatorScope.Resolve resolve = resolved.only();&lt;br/&gt;
-			final SqlValidatorNamespace foundNs = resolve.namespace;&lt;br/&gt;
-			final RelDataType rowType = resolve.rowType();&lt;br/&gt;
-			final int childNamespaceIndex = resolve.path.steps().get(0).i;&lt;br/&gt;
-			final SqlValidatorScope ancestorScope = resolve.scope;&lt;br/&gt;
-			boolean correlInCurrentScope = bb.scope.isWithin(ancestorScope);&lt;br/&gt;
-&lt;br/&gt;
-			if (!correlInCurrentScope) {
-				continue;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			if (prevNs == null) {
-				prevNs = foundNs;
-			} else {
-				assert prevNs == foundNs : &quot;All correlation variables should resolve&quot;
-						+ &quot; to the same namespace.&quot;
-						+ &quot; Prev ns=&quot; + prevNs
-						+ &quot;, new ns=&quot; + foundNs;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			int namespaceOffset = 0;&lt;br/&gt;
-			if (childNamespaceIndex &amp;gt; 0) {&lt;br/&gt;
-				// If not the first child, need to figure out the width&lt;br/&gt;
-				// of output types from all the preceding namespaces&lt;br/&gt;
-				assert ancestorScope instanceof ListScope;&lt;br/&gt;
-				List&amp;lt;SqlValidatorNamespace&amp;gt; children =&lt;br/&gt;
-						((ListScope) ancestorScope).getChildren();&lt;br/&gt;
-&lt;br/&gt;
-				for (int i = 0; i &amp;lt; childNamespaceIndex; i++) {
-					SqlValidatorNamespace child = children.get(i);
-					namespaceOffset +=
-							child.getRowType().getFieldCount();
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			RexFieldAccess topLevelFieldAccess = fieldAccess;&lt;br/&gt;
-			while (topLevelFieldAccess.getReferenceExpr() instanceof RexFieldAccess) {
-				topLevelFieldAccess = (RexFieldAccess) topLevelFieldAccess.getReferenceExpr();
-			}&lt;br/&gt;
-			final RelDataTypeField field = rowType.getFieldList()&lt;br/&gt;
-					.get(topLevelFieldAccess.getField().getIndex() - namespaceOffset);&lt;br/&gt;
-			int pos = namespaceOffset + field.getIndex();&lt;br/&gt;
-&lt;br/&gt;
-			assert field.getType()&lt;br/&gt;
-					== topLevelFieldAccess.getField().getType();&lt;br/&gt;
-&lt;br/&gt;
-			assert pos != -1;&lt;br/&gt;
-&lt;br/&gt;
-			if (bb.mapRootRelToFieldProjection.containsKey(bb.root)) {&lt;br/&gt;
-				// bb.root is an aggregate and only projects group by&lt;br/&gt;
-				// keys.&lt;br/&gt;
-				Map&amp;lt;Integer, Integer&amp;gt; exprProjection =&lt;br/&gt;
-						bb.mapRootRelToFieldProjection.get(bb.root);&lt;br/&gt;
-&lt;br/&gt;
-				// sub-query can reference group by keys projected from&lt;br/&gt;
-				// the root of the outer relation.&lt;br/&gt;
-				if (exprProjection.containsKey(pos)) {
-					pos = exprProjection.get(pos);
-				} else {
-					// correl not grouped
-					throw new AssertionError(&quot;Identifier &apos;&quot; + originalRelName + &quot;.&quot;
-							+ originalFieldName + &quot;&apos; is not a group expr&quot;);
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			requiredColumns.set(pos);&lt;br/&gt;
-			correlNames.add(correlName);&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		if (correlNames.isEmpty()) {
-			// None of the correlating variables originated in this scope.
-			return null;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		RelNode r = r0;&lt;br/&gt;
-		if (correlNames.size() &amp;gt; 1) {
-			// The same table was referenced more than once.
-			// So we deduplicate.
-			r = DeduplicateCorrelateVariables.go(rexBuilder, correlNames.get(0),
-					Util.skip(correlNames), r0);
-			// Add new node to leaves.
-			leaves.add(r);
-		}&lt;br/&gt;
-		return new CorrelationUse(correlNames.get(0), requiredColumns.build(), r);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Determines whether a sub-query is non-correlated. Note that a&lt;br/&gt;
-	 * non-correlated sub-query can contain correlated references, provided those&lt;br/&gt;
-	 * references do not reference select statements that are parents of the&lt;br/&gt;
-	 * sub-query.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param subq the sub-query&lt;br/&gt;
-	 * @param bb   blackboard used while converting the sub-query, i.e., the&lt;br/&gt;
-	 *             blackboard of the parent query of this sub-query&lt;br/&gt;
-	 * @return true if the sub-query is non-correlated&lt;br/&gt;
-	 */&lt;br/&gt;
-	private boolean isSubQueryNonCorrelated(RelNode subq, Blackboard bb) {&lt;br/&gt;
-		Set&amp;lt;CorrelationId&amp;gt; correlatedVariables = RelOptUtil.getVariablesUsed(subq);&lt;br/&gt;
-		for (CorrelationId correlName : correlatedVariables) {&lt;br/&gt;
-			DeferredLookup lookup = mapCorrelToDeferred.get(correlName);&lt;br/&gt;
-			String originalRelName = lookup.getOriginalRelName();&lt;br/&gt;
-&lt;br/&gt;
-			final SqlNameMatcher nameMatcher =&lt;br/&gt;
-					lookup.bb.scope.getValidator().getCatalogReader().nameMatcher();&lt;br/&gt;
-			final SqlValidatorScope.ResolvedImpl resolved =&lt;br/&gt;
-					new SqlValidatorScope.ResolvedImpl();&lt;br/&gt;
-			lookup.bb.scope.resolve(ImmutableList.of(originalRelName), nameMatcher,&lt;br/&gt;
-					false, resolved);&lt;br/&gt;
-&lt;br/&gt;
-			SqlValidatorScope ancestorScope = resolved.only().scope;&lt;br/&gt;
-&lt;br/&gt;
-			// If the correlated reference is in a scope that&apos;s &quot;above&quot; the&lt;br/&gt;
-			// sub-query, then this is a correlated sub-query.&lt;br/&gt;
-			SqlValidatorScope parentScope = bb.scope;&lt;br/&gt;
-			do {&lt;br/&gt;
-				if (ancestorScope == parentScope) {
-					return false;
-				}&lt;br/&gt;
-				if (parentScope instanceof DelegatingScope) {
-					parentScope = ((DelegatingScope) parentScope).getParent();
-				} else {
-					break;
-				}&lt;br/&gt;
-			} while (parentScope != null);&lt;br/&gt;
-		}&lt;br/&gt;
-		return true;&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Returns a list of fields to be prefixed to each relational expression.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @return List of system fields&lt;br/&gt;
-	 */&lt;br/&gt;
-	protected List&amp;lt;RelDataTypeField&amp;gt; getSystemFields() {
-		return Collections.emptyList();
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private RexNode convertJoinCondition(Blackboard bb,&lt;br/&gt;
-	                                     SqlValidatorNamespace leftNamespace,&lt;br/&gt;
-	                                     SqlValidatorNamespace rightNamespace,&lt;br/&gt;
-	                                     SqlNode condition,&lt;br/&gt;
-	                                     JoinConditionType conditionType,&lt;br/&gt;
-	                                     RelNode leftRel,&lt;br/&gt;
-	                                     RelNode rightRel) {&lt;br/&gt;
-		if (condition == null) {
-			return rexBuilder.makeLiteral(true);
-		}&lt;br/&gt;
-		bb.setRoot(ImmutableList.of(leftRel, rightRel));&lt;br/&gt;
-		replaceSubQueries(bb, condition, RelOptUtil.Logic.UNKNOWN_AS_FALSE);&lt;br/&gt;
-		switch (conditionType) {&lt;br/&gt;
-			case ON:&lt;br/&gt;
-				bb.setRoot(ImmutableList.of(leftRel, rightRel));&lt;br/&gt;
-				return bb.convertExpression(condition);&lt;br/&gt;
-			case USING:&lt;br/&gt;
-				final SqlNodeList list = (SqlNodeList) condition;&lt;br/&gt;
-				final List&amp;lt;String&amp;gt; nameList = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-				for (SqlNode columnName : list) {
-					final SqlIdentifier id = (SqlIdentifier) columnName;
-					String name = id.getSimple();
-					nameList.add(name);
-				}&lt;br/&gt;
-				return convertUsing(leftNamespace, rightNamespace, nameList);&lt;br/&gt;
-			default:&lt;br/&gt;
-				throw Util.unexpected(conditionType);&lt;br/&gt;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Returns an expression for matching columns of a USING clause or inferred&lt;br/&gt;
-	 * from NATURAL JOIN. &quot;a JOIN b USING (x, y)&quot; becomes &quot;a.x = b.x AND a.y =&lt;br/&gt;
-	 * b.y&quot;. Returns null if the column list is empty.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param leftNamespace Namespace of left input to join&lt;br/&gt;
-	 * @param rightNamespace Namespace of right input to join&lt;br/&gt;
-	 * @param nameList List of column names to join on&lt;br/&gt;
-	 * @return Expression to match columns from name list, or true if name list&lt;br/&gt;
-	 * is empty&lt;br/&gt;
-	 */&lt;br/&gt;
-	private RexNode convertUsing(SqlValidatorNamespace leftNamespace,&lt;br/&gt;
-	                             SqlValidatorNamespace rightNamespace,&lt;br/&gt;
-	                             List&amp;lt;String&amp;gt; nameList) {&lt;br/&gt;
-		final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();&lt;br/&gt;
-		final List&amp;lt;RexNode&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-		for (String name : nameList) {&lt;br/&gt;
-			List&amp;lt;RexNode&amp;gt; operands = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-			int offset = 0;&lt;br/&gt;
-			for (SqlValidatorNamespace n : ImmutableList.of(leftNamespace,&lt;br/&gt;
-					rightNamespace)) {
-				final RelDataType rowType = n.getRowType();
-				final RelDataTypeField field = nameMatcher.field(rowType, name);
-				operands.add(
-						rexBuilder.makeInputRef(field.getType(),
-								offset + field.getIndex()));
-				offset += rowType.getFieldList().size();
-			}&lt;br/&gt;
-			list.add(rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, operands));&lt;br/&gt;
-		}&lt;br/&gt;
-		return RexUtil.composeConjunction(rexBuilder, list, false);&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private static JoinRelType convertJoinType(JoinType joinType) {&lt;br/&gt;
-		switch (joinType) {
-			case COMMA:
-			case INNER:
-			case CROSS:
-				return JoinRelType.INNER;
-			case FULL:
-				return JoinRelType.FULL;
-			case LEFT:
-				return JoinRelType.LEFT;
-			case RIGHT:
-				return JoinRelType.RIGHT;
-			default:
-				throw Util.unexpected(joinType);
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Converts the SELECT, GROUP BY and HAVING clauses of an aggregate query.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;This method extracts SELECT, GROUP BY and HAVING clauses, and creates&lt;br/&gt;
-	 * an {@link AggConverter}, then delegates to {@link #createAggImpl}.&lt;br/&gt;
-	 * Derived class may override this method to change any of those clauses or&lt;br/&gt;
-	 * specify a different {@link AggConverter}.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param bb            Scope within which to resolve identifiers&lt;br/&gt;
-	 * @param select        Query&lt;br/&gt;
-	 * @param orderExprList Additional expressions needed to implement ORDER BY&lt;br/&gt;
-	 */&lt;br/&gt;
-	protected void convertAgg(&lt;br/&gt;
-			Blackboard bb,&lt;br/&gt;
-			SqlSelect select,&lt;br/&gt;
-			List&amp;lt;SqlNode&amp;gt; orderExprList) {
-		assert bb.root != null : &quot;precondition: child != null&quot;;
-		SqlNodeList groupList = select.getGroup();
-		SqlNodeList selectList = select.getSelectList();
-		SqlNode having = select.getHaving();
-
-		final AggConverter aggConverter = new AggConverter(bb, select);
-		createAggImpl(
-				bb,
-				aggConverter,
-				selectList,
-				groupList,
-				having,
-				orderExprList);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	protected final void createAggImpl(&lt;br/&gt;
-			Blackboard bb,&lt;br/&gt;
-			final AggConverter aggConverter,&lt;br/&gt;
-			SqlNodeList selectList,&lt;br/&gt;
-			SqlNodeList groupList,&lt;br/&gt;
-			SqlNode having,&lt;br/&gt;
-			List&amp;lt;SqlNode&amp;gt; orderExprList) {&lt;br/&gt;
-		// Find aggregate functions in SELECT and HAVING clause&lt;br/&gt;
-		final AggregateFinder aggregateFinder = new AggregateFinder();&lt;br/&gt;
-		selectList.accept(aggregateFinder);&lt;br/&gt;
-		if (having != null) {
-			having.accept(aggregateFinder);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		// first replace the sub-queries inside the aggregates&lt;br/&gt;
-		// because they will provide input rows to the aggregates.&lt;br/&gt;
-		replaceSubQueries(bb, aggregateFinder.list,&lt;br/&gt;
-				RelOptUtil.Logic.TRUE_FALSE_UNKNOWN);&lt;br/&gt;
-&lt;br/&gt;
-		// also replace sub-queries inside filters in the aggregates&lt;br/&gt;
-		replaceSubQueries(bb, aggregateFinder.filterList,&lt;br/&gt;
-				RelOptUtil.Logic.TRUE_FALSE_UNKNOWN);&lt;br/&gt;
-&lt;br/&gt;
-		// If group-by clause is missing, pretend that it has zero elements.&lt;br/&gt;
-		if (groupList == null) {
-			groupList = SqlNodeList.EMPTY;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		replaceSubQueries(bb, groupList, RelOptUtil.Logic.TRUE_FALSE_UNKNOWN);&lt;br/&gt;
-&lt;br/&gt;
-		// register the group exprs&lt;br/&gt;
-&lt;br/&gt;
-		// build a map to remember the projections from the top scope to the&lt;br/&gt;
-		// output of the current root.&lt;br/&gt;
-		//&lt;br/&gt;
-		// Calcite allows expressions, not just column references in&lt;br/&gt;
-		// group by list. This is not SQL 2003 compliant, but hey.&lt;br/&gt;
-&lt;br/&gt;
-		final AggregatingSelectScope scope = aggConverter.aggregatingSelectScope;&lt;br/&gt;
-		final AggregatingSelectScope.Resolved r = scope.resolved.get();&lt;br/&gt;
-		for (SqlNode groupExpr : r.groupExprList) {
-			aggConverter.addGroupExpr(groupExpr);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		final RexNode havingExpr;&lt;br/&gt;
-		final List&amp;lt;Pair&amp;lt;RexNode, String&amp;gt;&amp;gt; projects = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;br/&gt;
-		try {&lt;br/&gt;
-			Preconditions.checkArgument(bb.agg == null, &quot;already in agg mode&quot;);&lt;br/&gt;
-			bb.agg = aggConverter;&lt;br/&gt;
-&lt;br/&gt;
-			// convert the select and having expressions, so that the&lt;br/&gt;
-			// agg converter knows which aggregations are required&lt;br/&gt;
-&lt;br/&gt;
-			selectList.accept(aggConverter);&lt;br/&gt;
-			// Assert we don&apos;t have dangling items left in the stack&lt;br/&gt;
-			assert !aggConverter.inOver;&lt;br/&gt;
-			for (SqlNode expr : orderExprList) {
-				expr.accept(aggConverter);
-				assert !aggConverter.inOver;
-			}&lt;br/&gt;
-			if (having != null) {
-				having.accept(aggConverter);
-				assert !aggConverter.inOver;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			// compute inputs to the aggregator&lt;br/&gt;
-			List&amp;lt;Pair&amp;lt;RexNode, String&amp;gt;&amp;gt; preExprs = aggConverter.getPreExprs();&lt;br/&gt;
-&lt;br/&gt;
-			if (preExprs.size() == 0) {
-				// Special case for COUNT(*), where we can end up with no inputs
-				// at all.  The rest of the system doesn&apos;t like 0-tuples, so we
-				// select a dummy constant here.
-				final RexNode zero = rexBuilder.makeExactLiteral(BigDecimal.ZERO);
-				preExprs = ImmutableList.of(Pair.of(zero, (String) null));
-			}&lt;br/&gt;
-&lt;br/&gt;
-			final RelNode inputRel = bb.root;&lt;br/&gt;
-&lt;br/&gt;
-			// Project the expressions required by agg and having.&lt;br/&gt;
-			bb.setRoot(&lt;br/&gt;
-					relBuilder.push(inputRel)&lt;br/&gt;
-							.projectNamed(Pair.left(preExprs), Pair.right(preExprs), false)&lt;br/&gt;
-							.build(),&lt;br/&gt;
-					false);&lt;br/&gt;
-			bb.mapRootRelToFieldProjection.put(bb.root, r.groupExprProjection);&lt;br/&gt;
-&lt;br/&gt;
-			// REVIEW jvs 31-Oct-2007:  doesn&apos;t the declaration of&lt;br/&gt;
-			// monotonicity here assume sort-based aggregation at&lt;br/&gt;
-			// the physical level?&lt;br/&gt;
-&lt;br/&gt;
-			// Tell bb which of group columns are sorted.&lt;br/&gt;
-			bb.columnMonotonicities.clear();&lt;br/&gt;
-			for (SqlNode groupItem : groupList) {
-				bb.columnMonotonicities.add(
-						bb.scope.getMonotonicity(groupItem));
-			}&lt;br/&gt;
-&lt;br/&gt;
-			// Add the aggregator&lt;br/&gt;
-			bb.setRoot(&lt;br/&gt;
-					createAggregate(bb, r.groupSet, r.groupSets,&lt;br/&gt;
-							aggConverter.getAggCalls()),&lt;br/&gt;
-					false);&lt;br/&gt;
-&lt;br/&gt;
-			bb.mapRootRelToFieldProjection.put(bb.root, r.groupExprProjection);&lt;br/&gt;
-&lt;br/&gt;
-			// Replace sub-queries in having here and modify having to use&lt;br/&gt;
-			// the replaced expressions&lt;br/&gt;
-			if (having != null) {
-				SqlNode newHaving = pushDownNotForIn(bb.scope, having);
-				replaceSubQueries(bb, newHaving, RelOptUtil.Logic.UNKNOWN_AS_FALSE);
-				havingExpr = bb.convertExpression(newHaving);
-			} else {
-				havingExpr = relBuilder.literal(true);
-			}&lt;br/&gt;
-&lt;br/&gt;
-			// Now convert the other sub-queries in the select list.&lt;br/&gt;
-			// This needs to be done separately from the sub-query inside&lt;br/&gt;
-			// any aggregate in the select list, and after the aggregate rel&lt;br/&gt;
-			// is allocated.&lt;br/&gt;
-			replaceSubQueries(bb, selectList, RelOptUtil.Logic.TRUE_FALSE_UNKNOWN);&lt;br/&gt;
-&lt;br/&gt;
-			// Now sub-queries in the entire select list have been converted.&lt;br/&gt;
-			// Convert the select expressions to get the final list to be&lt;br/&gt;
-			// projected.&lt;br/&gt;
-			int k = 0;&lt;br/&gt;
-&lt;br/&gt;
-			// For select expressions, use the field names previously assigned&lt;br/&gt;
-			// by the validator. If we derive afresh, we might generate names&lt;br/&gt;
-			// like &quot;EXPR$2&quot; that don&apos;t match the names generated by the&lt;br/&gt;
-			// validator. This is especially the case when there are system&lt;br/&gt;
-			// fields; system fields appear in the relnode&apos;s rowtype but do not&lt;br/&gt;
-			// (yet) appear in the validator type.&lt;br/&gt;
-			final SelectScope selectScope =&lt;br/&gt;
-					SqlValidatorUtil.getEnclosingSelectScope(bb.scope);&lt;br/&gt;
-			assert selectScope != null;&lt;br/&gt;
-			final SqlValidatorNamespace selectNamespace =&lt;br/&gt;
-					validator.getNamespace(selectScope.getNode());&lt;br/&gt;
-			final List&amp;lt;String&amp;gt; names =&lt;br/&gt;
-					selectNamespace.getRowType().getFieldNames();&lt;br/&gt;
-			int sysFieldCount = selectList.size() - names.size();&lt;br/&gt;
-			for (SqlNode expr : selectList) {
-				projects.add(
-						Pair.of(bb.convertExpression(expr),
-								k &amp;lt; sysFieldCount
-										? validator.deriveAlias(expr, k++)
-										: names.get(k++ - sysFieldCount)));
-			}&lt;br/&gt;
-&lt;br/&gt;
-			for (SqlNode expr : orderExprList) {
-				projects.add(
-						Pair.of(bb.convertExpression(expr),
-								validator.deriveAlias(expr, k++)));
-			}&lt;br/&gt;
-		} finally {
-			bb.agg = null;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		// implement HAVING (we have already checked that it is non-trivial)&lt;br/&gt;
-		relBuilder.push(bb.root);&lt;br/&gt;
-		if (havingExpr != null) {
-			relBuilder.filter(havingExpr);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		// implement the SELECT list&lt;br/&gt;
-		relBuilder.project(Pair.left(projects), Pair.right(projects))&lt;br/&gt;
-				.rename(Pair.right(projects));&lt;br/&gt;
-		bb.setRoot(relBuilder.build(), false);&lt;br/&gt;
-&lt;br/&gt;
-		// Tell bb which of group columns are sorted.&lt;br/&gt;
-		bb.columnMonotonicities.clear();&lt;br/&gt;
-		for (SqlNode selectItem : selectList) {
-			bb.columnMonotonicities.add(
-					bb.scope.getMonotonicity(selectItem));
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Creates an Aggregate.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;In case the aggregate rel changes the order in which it projects&lt;br/&gt;
-	 * fields, the &amp;lt;code&amp;gt;groupExprProjection&amp;lt;/code&amp;gt; parameter is provided, and&lt;br/&gt;
-	 * the implementation of this method may modify it.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;The &amp;lt;code&amp;gt;sortedCount&amp;lt;/code&amp;gt; parameter is the number of expressions&lt;br/&gt;
-	 * known to be monotonic. These expressions must be on the leading edge of&lt;br/&gt;
-	 * the grouping keys. The default implementation of this method ignores this&lt;br/&gt;
-	 * parameter.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param bb       Blackboard&lt;br/&gt;
-	 * @param groupSet Bit set of ordinals of grouping columns&lt;br/&gt;
-	 * @param groupSets Grouping sets&lt;br/&gt;
-	 * @param aggCalls Array of calls to aggregate functions&lt;br/&gt;
-	 * @return LogicalAggregate&lt;br/&gt;
-	 */&lt;br/&gt;
-	protected RelNode createAggregate(Blackboard bb, ImmutableBitSet groupSet,&lt;br/&gt;
-	                                  ImmutableList&amp;lt;ImmutableBitSet&amp;gt; groupSets, List&amp;lt;AggregateCall&amp;gt; aggCalls) {
-		return LogicalAggregate.create(bb.root, groupSet, groupSets, aggCalls);
-	}&lt;br/&gt;
-&lt;br/&gt;
-	public RexDynamicParam convertDynamicParam(&lt;br/&gt;
-			final SqlDynamicParam dynamicParam) {&lt;br/&gt;
-		// REVIEW jvs 8-Jan-2005:  dynamic params may be encountered out of&lt;br/&gt;
-		// order.  Should probably cross-check with the count from the parser&lt;br/&gt;
-		// at the end and make sure they all got filled in.  Why doesn&apos;t List&lt;br/&gt;
-		// have a resize() method?!?  Make this a utility.&lt;br/&gt;
-		while (dynamicParam.getIndex() &amp;gt;= dynamicParamSqlNodes.size()) {
-			dynamicParamSqlNodes.add(null);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		dynamicParamSqlNodes.set(&lt;br/&gt;
-				dynamicParam.getIndex(),&lt;br/&gt;
-				dynamicParam);&lt;br/&gt;
-		return rexBuilder.makeDynamicParam(&lt;br/&gt;
-				getDynamicParamType(dynamicParam.getIndex()),&lt;br/&gt;
-				dynamicParam.getIndex());&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Creates a list of collations required to implement the ORDER BY clause,&lt;br/&gt;
-	 * if there is one. Populates &amp;lt;code&amp;gt;extraOrderExprs&amp;lt;/code&amp;gt; with any sort&lt;br/&gt;
-	 * expressions which are not in the select clause.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @param bb              Scope within which to resolve identifiers&lt;br/&gt;
-	 * @param select          Select clause. Never null, because we invent a&lt;br/&gt;
-	 *                        dummy SELECT if ORDER BY is applied to a set&lt;br/&gt;
-	 *                        operation (UNION etc.)&lt;br/&gt;
-	 * @param orderList       Order by clause, may be null&lt;br/&gt;
-	 * @param extraOrderExprs Sort expressions which are not in the select&lt;br/&gt;
-	 *                        clause (output)&lt;br/&gt;
-	 * @param collationList   List of collations (output)&lt;br/&gt;
-	 */&lt;br/&gt;
-	protected void gatherOrderExprs(&lt;br/&gt;
-			Blackboard bb,&lt;br/&gt;
-			SqlSelect select,&lt;br/&gt;
-			SqlNodeList orderList,&lt;br/&gt;
-			List&amp;lt;SqlNode&amp;gt; extraOrderExprs,&lt;br/&gt;
-			List&amp;lt;RelFieldCollation&amp;gt; collationList) {&lt;br/&gt;
-		// TODO:  add validation rules to SqlValidator also&lt;br/&gt;
-		assert bb.root != null : &quot;precondition: child != null&quot;;&lt;br/&gt;
-		assert select != null;&lt;br/&gt;
-		if (orderList == null) {-			return;-		}&lt;/li&gt;
	&lt;li&gt;for (SqlNode orderItem : orderList) 
{
-			collationList.add(
-					convertOrderItem(select, orderItem, extraOrderExprs,
-							RelFieldCollation.Direction.ASCENDING,
-							RelFieldCollation.NullDirection.UNSPECIFIED));
-		}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;protected RelFieldCollation convertOrderItem(&lt;/li&gt;
	&lt;li&gt;SqlSelect select,&lt;/li&gt;
	&lt;li&gt;SqlNode orderItem, List&amp;lt;SqlNode&amp;gt; extraExprs,&lt;/li&gt;
	&lt;li&gt;RelFieldCollation.Direction direction,&lt;/li&gt;
	&lt;li&gt;RelFieldCollation.NullDirection nullDirection) {&lt;/li&gt;
	&lt;li&gt;assert select != null;&lt;/li&gt;
	&lt;li&gt;// Handle DESC keyword, e.g. &apos;select a, b from t order by a desc&apos;.&lt;/li&gt;
	&lt;li&gt;switch (orderItem.getKind()) 
{
-			case DESCENDING:
-				return convertOrderItem(
-						select,
-						((SqlCall) orderItem).operand(0),
-						extraExprs,
-						RelFieldCollation.Direction.DESCENDING,
-						nullDirection);
-			case NULLS_FIRST:
-				return convertOrderItem(
-						select,
-						((SqlCall) orderItem).operand(0),
-						extraExprs,
-						direction,
-						RelFieldCollation.NullDirection.FIRST);
-			case NULLS_LAST:
-				return convertOrderItem(
-						select,
-						((SqlCall) orderItem).operand(0),
-						extraExprs,
-						direction,
-						RelFieldCollation.NullDirection.LAST);
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;SqlNode converted = validator.expandOrderExpr(select, orderItem);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;switch (nullDirection) 
{
-			case UNSPECIFIED:
-				nullDirection = validator.getDefaultNullCollation().last(desc(direction))
-						? RelFieldCollation.NullDirection.LAST
-						: RelFieldCollation.NullDirection.FIRST;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Scan the select list and order exprs for an identical expression.&lt;/li&gt;
	&lt;li&gt;final SelectScope selectScope = validator.getRawSelectScope(select);&lt;/li&gt;
	&lt;li&gt;int ordinal = -1;&lt;/li&gt;
	&lt;li&gt;for (SqlNode selectItem : selectScope.getExpandedSelectList()) {&lt;/li&gt;
	&lt;li&gt;++ordinal;&lt;/li&gt;
	&lt;li&gt;if (converted.equalsDeep(stripAs(selectItem), Litmus.IGNORE)) 
{
-				return new RelFieldCollation(ordinal, direction, nullDirection);
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		for (SqlNode extraExpr : extraExprs) {&lt;br/&gt;
-			++ordinal;&lt;br/&gt;
-			if (converted.equalsDeep(extraExpr, Litmus.IGNORE)) {-				return new RelFieldCollation(ordinal, direction, nullDirection);-			}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// TODO:  handle collation sequence&lt;/li&gt;
	&lt;li&gt;// TODO: flag expressions as non-standard&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;extraExprs.add(converted);&lt;/li&gt;
	&lt;li&gt;return new RelFieldCollation(ordinal + 1, direction, nullDirection);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private static boolean desc(RelFieldCollation.Direction direction) {&lt;/li&gt;
	&lt;li&gt;switch (direction) 
{
-			case DESCENDING:
-			case STRICTLY_DESCENDING:
-				return true;
-			default:
-				return false;
-		}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;@Deprecated // to be removed before 2.0&lt;/li&gt;
	&lt;li&gt;protected boolean enableDecorrelation() 
{
-		// disable sub-query decorrelation when needed.
-		// e.g. if outer joins are not supported.
-		return config.isDecorrelationEnabled();
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;protected RelNode decorrelateQuery(RelNode rootRel) 
{
-		return RelDecorrelator.decorrelateQuery(rootRel, relBuilder);
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Returns whether to trim unused fields as part of the conversion process.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @return Whether to trim unused fields&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;@Deprecated // to be removed before 2.0&lt;/li&gt;
	&lt;li&gt;public boolean isTrimUnusedFields() 
{
-		return config.isTrimUnusedFields();
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Recursively converts a query to a relational expression.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param query         Query&lt;/li&gt;
	&lt;li&gt;* @param top           Whether this query is the top-level query of the&lt;/li&gt;
	&lt;li&gt;*                      statement&lt;/li&gt;
	&lt;li&gt;* @param targetRowType Target row type, or null&lt;/li&gt;
	&lt;li&gt;* @return Relational expression&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;protected RelRoot convertQueryRecursive(SqlNode query, boolean top,&lt;/li&gt;
	&lt;li&gt;RelDataType targetRowType) {&lt;/li&gt;
	&lt;li&gt;final SqlKind kind = query.getKind();&lt;/li&gt;
	&lt;li&gt;switch (kind) 
{
-			case SELECT:
-				return RelRoot.of(convertSelect((SqlSelect) query, top), kind);
-			case INSERT:
-				return RelRoot.of(convertInsert((SqlInsert) query), kind);
-			case DELETE:
-				return RelRoot.of(convertDelete((SqlDelete) query), kind);
-			case UPDATE:
-				return RelRoot.of(convertUpdate((SqlUpdate) query), kind);
-			case MERGE:
-				return RelRoot.of(convertMerge((SqlMerge) query), kind);
-			case UNION:
-			case INTERSECT:
-			case EXCEPT:
-				return RelRoot.of(convertSetOp((SqlCall) query), kind);
-			case WITH:
-				return convertWith((SqlWith) query, top);
-			case VALUES:
-				return RelRoot.of(convertValues((SqlCall) query, targetRowType), kind);
-			default:
-				throw new AssertionError(&quot;not a query: &quot; + query);
-		}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Converts a set operation (UNION, INTERSECT, MINUS) into relational&lt;/li&gt;
	&lt;li&gt;* expressions.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param call Call to set operator&lt;/li&gt;
	&lt;li&gt;* @return Relational expression&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;protected RelNode convertSetOp(SqlCall call) {&lt;/li&gt;
	&lt;li&gt;final RelNode left =&lt;/li&gt;
	&lt;li&gt;convertQueryRecursive(call.operand(0), false, null).project();&lt;/li&gt;
	&lt;li&gt;final RelNode right =&lt;/li&gt;
	&lt;li&gt;convertQueryRecursive(call.operand(1), false, null).project();&lt;/li&gt;
	&lt;li&gt;switch (call.getKind()) 
{
-			case UNION:
-				return LogicalUnion.create(ImmutableList.of(left, right), all(call));
-
-			case INTERSECT:
-				return LogicalIntersect.create(ImmutableList.of(left, right), all(call));
-
-			case EXCEPT:
-				return LogicalMinus.create(ImmutableList.of(left, right), all(call));
-
-			default:
-				throw Util.unexpected(call.getKind());
-		}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private boolean all(SqlCall call) 
{
-		return ((SqlSetOperator) call.getOperator()).isAll();
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;protected RelNode convertInsert(SqlInsert call) 
{
-		RelOptTable targetTable = getTargetTable(call);
-
-		final RelDataType targetRowType =
-				validator.getValidatedNodeType(call);
-		assert targetRowType != null;
-		RelNode sourceRel =
-				convertQueryRecursive(call.getSource(), false, targetRowType).project();
-		RelNode massagedRel = convertColumnList(call, sourceRel);
-
-		return createModify(targetTable, massagedRel);
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/** Creates a relational expression to modify a table or modifiable view. */&lt;/li&gt;
	&lt;li&gt;private RelNode createModify(RelOptTable targetTable, RelNode source) {&lt;/li&gt;
	&lt;li&gt;final ModifiableTable modifiableTable =&lt;/li&gt;
	&lt;li&gt;targetTable.unwrap(ModifiableTable.class);&lt;/li&gt;
	&lt;li&gt;if (modifiableTable != null&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; modifiableTable == targetTable.unwrap(Table.class)) 
{
-			return modifiableTable.toModificationRel(cluster, targetTable,
-					catalogReader, source, LogicalTableModify.Operation.INSERT, null,
-					null, false);
-		}&lt;/li&gt;
	&lt;li&gt;final ModifiableView modifiableView =&lt;/li&gt;
	&lt;li&gt;targetTable.unwrap(ModifiableView.class);&lt;/li&gt;
	&lt;li&gt;if (modifiableView != null) 
{
-			final Table delegateTable = modifiableView.getTable();
-			final RelDataType delegateRowType = delegateTable.getRowType(typeFactory);
-			final RelOptTable delegateRelOptTable =
-					RelOptTableImpl.create(null, delegateRowType, delegateTable,
-							modifiableView.getTablePath());
-			final RelNode newSource =
-					createSource(targetTable, source, modifiableView, delegateRowType);
-			return createModify(delegateRelOptTable, newSource);
-		}&lt;/li&gt;
	&lt;li&gt;return LogicalTableModify.create(targetTable, catalogReader, source,&lt;/li&gt;
	&lt;li&gt;LogicalTableModify.Operation.INSERT, null, null, false);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/** Wraps a relational expression in the projects and filters implied by&lt;/li&gt;
	&lt;li&gt;* a 
{@link ModifiableView}
&lt;p&gt;.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;The input relational expression is suitable for inserting into the view,&lt;/li&gt;
	&lt;li&gt;* and the returned relational expression is suitable for inserting into its&lt;/li&gt;
	&lt;li&gt;* delegate table.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;In principle, the delegate table of a view might be another modifiable&lt;/li&gt;
	&lt;li&gt;* view, and if so, the process can be repeated. */&lt;/li&gt;
	&lt;li&gt;private RelNode createSource(RelOptTable targetTable, RelNode source,&lt;/li&gt;
	&lt;li&gt;ModifiableView modifiableView, RelDataType delegateRowType) {&lt;/li&gt;
	&lt;li&gt;final ImmutableIntList mapping = modifiableView.getColumnMapping();&lt;/li&gt;
	&lt;li&gt;assert mapping.size() == targetTable.getRowType().getFieldCount();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// For columns represented in the mapping, the expression is just a field&lt;/li&gt;
	&lt;li&gt;// reference.&lt;/li&gt;
	&lt;li&gt;final Map&amp;lt;Integer, RexNode&amp;gt; projectMap = new HashMap&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;RexNode&amp;gt; filters = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;for (int i = 0; i &amp;lt; mapping.size(); i++) {&lt;/li&gt;
	&lt;li&gt;int target = mapping.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;/li&gt;
	&lt;li&gt;if (target &amp;gt;= 0) 
{
-				projectMap.put(target, RexInputRef.of(i, source.getRowType()));
-			}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// For columns that are not in the mapping, and have a constraint of the&lt;/li&gt;
	&lt;li&gt;// form &quot;column = value&quot;, the expression is the literal &quot;value&quot;.&lt;/li&gt;
	&lt;li&gt;//&lt;/li&gt;
	&lt;li&gt;// If a column has multiple constraints, the extra ones will become a&lt;/li&gt;
	&lt;li&gt;// filter.&lt;/li&gt;
	&lt;li&gt;final RexNode constraint =&lt;/li&gt;
	&lt;li&gt;modifiableView.getConstraint(rexBuilder, delegateRowType);&lt;/li&gt;
	&lt;li&gt;RelOptUtil.inferViewPredicates(projectMap, filters, constraint);&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;Pair&amp;lt;RexNode, String&amp;gt;&amp;gt; projects = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;for (RelDataTypeField field : delegateRowType.getFieldList()) {&lt;/li&gt;
	&lt;li&gt;RexNode node = projectMap.get(field.getIndex());&lt;/li&gt;
	&lt;li&gt;if (node == null) 
{
-				node = rexBuilder.makeNullLiteral(field.getType());
-			}&lt;/li&gt;
	&lt;li&gt;projects.add(&lt;/li&gt;
	&lt;li&gt;Pair.of(rexBuilder.ensureType(field.getType(), node, false),&lt;/li&gt;
	&lt;li&gt;field.getName()));&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;return relBuilder.push(source)&lt;/li&gt;
	&lt;li&gt;.projectNamed(Pair.left(projects), Pair.right(projects), false)&lt;/li&gt;
	&lt;li&gt;.filter(filters)&lt;/li&gt;
	&lt;li&gt;.build();&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private RelOptTable.ToRelContext createToRelContext() {&lt;/li&gt;
	&lt;li&gt;return new RelOptTable.ToRelContext() {&lt;/li&gt;
	&lt;li&gt;public RelOptCluster getCluster() 
{
-				return cluster;
-			}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override public RelRoot expandView(&lt;/li&gt;
	&lt;li&gt;RelDataType rowType,&lt;/li&gt;
	&lt;li&gt;String queryString,&lt;/li&gt;
	&lt;li&gt;List&amp;lt;String&amp;gt; schemaPath,&lt;/li&gt;
	&lt;li&gt;List&amp;lt;String&amp;gt; viewPath) 
{
-				return viewExpander.expandView(rowType, queryString, schemaPath, viewPath);
-			}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;};&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;public RelNode toRel(final RelOptTable table) {&lt;/li&gt;
	&lt;li&gt;final RelNode scan = table.toRel(createToRelContext());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final InitializerExpressionFactory ief =&lt;/li&gt;
	&lt;li&gt;Util.first(table.unwrap(InitializerExpressionFactory.class),&lt;/li&gt;
	&lt;li&gt;NullInitializerExpressionFactory.INSTANCE);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Lazily create a blackboard that contains all non-generated columns.&lt;/li&gt;
	&lt;li&gt;final Supplier&amp;lt;Blackboard&amp;gt; bb = () -&amp;gt; 
{
-			RexNode sourceRef = rexBuilder.makeRangeReference(scan);
-			return createInsertBlackboard(table, sourceRef,
-					table.getRowType().getFieldNames());
-		}
&lt;p&gt;;&lt;br/&gt;
-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;int virtualCount = 0;&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;RexNode&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;for (RelDataTypeField f : table.getRowType().getFieldList()) {&lt;/li&gt;
	&lt;li&gt;final ColumnStrategy strategy =&lt;/li&gt;
	&lt;li&gt;ief.generationStrategy(table, f.getIndex());&lt;/li&gt;
	&lt;li&gt;switch (strategy) 
{
-				case VIRTUAL:
-					list.add(ief.newColumnDefaultValue(table, f.getIndex(), bb.get()));
-					++virtualCount;
-					break;
-				default:
-					list.add(
-							rexBuilder.makeInputRef(scan,
-									RelOptTableImpl.realOrdinal(table, f.getIndex())));
-			}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;if (virtualCount &amp;gt; 0) 
{
-			relBuilder.push(scan);
-			relBuilder.project(list);
-			return relBuilder.build();
-		}&lt;/li&gt;
	&lt;li&gt;return scan;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;protected RelOptTable getTargetTable(SqlNode call) {&lt;/li&gt;
	&lt;li&gt;final SqlValidatorNamespace targetNs = validator.getNamespace(call);&lt;/li&gt;
	&lt;li&gt;if (targetNs.isWrapperFor(SqlValidatorImpl.DmlNamespace.class)) 
{
-			final SqlValidatorImpl.DmlNamespace dmlNamespace =
-					targetNs.unwrap(SqlValidatorImpl.DmlNamespace.class);
-			return SqlValidatorUtil.getRelOptTable(dmlNamespace, catalogReader, null, null);
-		}&lt;/li&gt;
	&lt;li&gt;final SqlValidatorNamespace resolvedNamespace = targetNs.resolve();&lt;/li&gt;
	&lt;li&gt;return SqlValidatorUtil.getRelOptTable(resolvedNamespace, catalogReader, null, null);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Creates a source for an INSERT statement.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;If the column list is not specified, source expressions match target&lt;/li&gt;
	&lt;li&gt;* columns in order.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;If the column list is specified, Source expressions are mapped to&lt;/li&gt;
	&lt;li&gt;* target columns by name via targetColumnList, and may not cover the entire&lt;/li&gt;
	&lt;li&gt;* target table. So, we&apos;ll make up a full row, using a combination of&lt;/li&gt;
	&lt;li&gt;* default values and the source expressions provided.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param call      Insert expression&lt;/li&gt;
	&lt;li&gt;* @param source Source relational expression&lt;/li&gt;
	&lt;li&gt;* @return Converted INSERT statement&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;protected RelNode convertColumnList(final SqlInsert call, RelNode source) {&lt;/li&gt;
	&lt;li&gt;RelDataType sourceRowType = source.getRowType();&lt;/li&gt;
	&lt;li&gt;final RexNode sourceRef =&lt;/li&gt;
	&lt;li&gt;rexBuilder.makeRangeReference(sourceRowType, 0, false);&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;String&amp;gt; targetColumnNames = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;RexNode&amp;gt; columnExprs = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;collectInsertTargets(call, sourceRef, targetColumnNames, columnExprs);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final RelOptTable targetTable = getTargetTable(call);&lt;/li&gt;
	&lt;li&gt;final RelDataType targetRowType = RelOptTableImpl.realRowType(targetTable);&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;RelDataTypeField&amp;gt; targetFields = targetRowType.getFieldList();&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;RexNode&amp;gt; sourceExps =&lt;/li&gt;
	&lt;li&gt;new ArrayList&amp;lt;&amp;gt;(&lt;/li&gt;
	&lt;li&gt;Collections.nCopies(targetFields.size(), null));&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;String&amp;gt; fieldNames =&lt;/li&gt;
	&lt;li&gt;new ArrayList&amp;lt;&amp;gt;(&lt;/li&gt;
	&lt;li&gt;Collections.nCopies(targetFields.size(), null));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final InitializerExpressionFactory initializerFactory =&lt;/li&gt;
	&lt;li&gt;getInitializerFactory(validator.getNamespace(call).getTable());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Walk the name list and place the associated value in the&lt;/li&gt;
	&lt;li&gt;// expression list according to the ordinal value returned from&lt;/li&gt;
	&lt;li&gt;// the table construct, leaving nulls in the list for columns&lt;/li&gt;
	&lt;li&gt;// that are not referenced.&lt;/li&gt;
	&lt;li&gt;final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();&lt;/li&gt;
	&lt;li&gt;for (Pair&amp;lt;String, RexNode&amp;gt; p : Pair.zip(targetColumnNames, columnExprs)) 
{
-			RelDataTypeField field = nameMatcher.field(targetRowType, p.left);
-			assert field != null : &quot;column &quot; + p.left + &quot; not found&quot;;
-			sourceExps.set(field.getIndex(), p.right);
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Lazily create a blackboard that contains all non-generated columns.&lt;/li&gt;
	&lt;li&gt;final Supplier&amp;lt;Blackboard&amp;gt; bb = () -&amp;gt;&lt;/li&gt;
	&lt;li&gt;createInsertBlackboard(targetTable, sourceRef, targetColumnNames);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Walk the expression list and get default values for any columns&lt;/li&gt;
	&lt;li&gt;// that were not supplied in the statement. Get field names too.&lt;/li&gt;
	&lt;li&gt;for (int i = 0; i &amp;lt; targetFields.size(); ++i) {&lt;/li&gt;
	&lt;li&gt;final RelDataTypeField field = targetFields.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;/li&gt;
	&lt;li&gt;final String fieldName = field.getName();&lt;/li&gt;
	&lt;li&gt;fieldNames.set(i, fieldName);&lt;/li&gt;
	&lt;li&gt;if (sourceExps.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; == null&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; sourceExps.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.getKind() == SqlKind.DEFAULT) 
{
-				sourceExps.set(i,
-						initializerFactory.newColumnDefaultValue(targetTable, i, bb.get()));
-
-				// bare nulls are dangerous in the wrong hands
-				sourceExps.set(i,
-						castNullLiteralIfNeeded(sourceExps.get(i), field.getType()));
-			}&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;return relBuilder.push(source)&lt;/li&gt;
	&lt;li&gt;.projectNamed(sourceExps, fieldNames, false)&lt;/li&gt;
	&lt;li&gt;.build();&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/** Creates a blackboard for translating the expressions of generated columns&lt;/li&gt;
	&lt;li&gt;* in an INSERT statement. */&lt;/li&gt;
	&lt;li&gt;private Blackboard createInsertBlackboard(RelOptTable targetTable,&lt;/li&gt;
	&lt;li&gt;RexNode sourceRef, List&amp;lt;String&amp;gt; targetColumnNames) {&lt;/li&gt;
	&lt;li&gt;final Map&amp;lt;String, RexNode&amp;gt; nameToNodeMap = new HashMap&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;int j = 0;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Assign expressions for non-generated columns.&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;ColumnStrategy&amp;gt; strategies = targetTable.getColumnStrategies();&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;String&amp;gt; targetFields = targetTable.getRowType().getFieldNames();&lt;/li&gt;
	&lt;li&gt;for (String targetColumnName : targetColumnNames) {&lt;/li&gt;
	&lt;li&gt;final int i = targetFields.indexOf(targetColumnName);&lt;/li&gt;
	&lt;li&gt;switch (strategies.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) 
{
-				case STORED:
-				case VIRTUAL:
-					break;
-				default:
-					nameToNodeMap.put(targetColumnName,
-							rexBuilder.makeFieldAccess(sourceRef, j++));
-			}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;return createBlackboard(null, nameToNodeMap, false);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private InitializerExpressionFactory getInitializerFactory(&lt;/li&gt;
	&lt;li&gt;SqlValidatorTable validatorTable) {&lt;/li&gt;
	&lt;li&gt;// We might unwrap a null instead of a InitializerExpressionFactory.&lt;/li&gt;
	&lt;li&gt;final Table table = unwrap(validatorTable, Table.class);&lt;/li&gt;
	&lt;li&gt;if (table != null) {&lt;/li&gt;
	&lt;li&gt;InitializerExpressionFactory f =&lt;/li&gt;
	&lt;li&gt;unwrap(table, InitializerExpressionFactory.class);&lt;/li&gt;
	&lt;li&gt;if (f != null) 
{
-				return f;
-			}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;return NullInitializerExpressionFactory.INSTANCE;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private static &amp;lt;T&amp;gt; T unwrap(Object o, Class&amp;lt;T&amp;gt; clazz) {&lt;/li&gt;
	&lt;li&gt;if (o instanceof Wrapper) 
{
-			return ((Wrapper) o).unwrap(clazz);
-		}&lt;/li&gt;
	&lt;li&gt;return null;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private RexNode castNullLiteralIfNeeded(RexNode node, RelDataType type) {&lt;/li&gt;
	&lt;li&gt;if (!RexLiteral.isNullLiteral(node)) 
{
-			return node;
-		}&lt;/li&gt;
	&lt;li&gt;return rexBuilder.makeCast(type, node);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Given an INSERT statement, collects the list of names to be populated and&lt;/li&gt;
	&lt;li&gt;* the expressions to put in them.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param call              Insert statement&lt;/li&gt;
	&lt;li&gt;* @param sourceRef         Expression representing a row from the source&lt;/li&gt;
	&lt;li&gt;*                          relational expression&lt;/li&gt;
	&lt;li&gt;* @param targetColumnNames List of target column names, to be populated&lt;/li&gt;
	&lt;li&gt;* @param columnExprs       List of expressions, to be populated&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;protected void collectInsertTargets(&lt;/li&gt;
	&lt;li&gt;SqlInsert call,&lt;/li&gt;
	&lt;li&gt;final RexNode sourceRef,&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;String&amp;gt; targetColumnNames,&lt;/li&gt;
	&lt;li&gt;List&amp;lt;RexNode&amp;gt; columnExprs) {&lt;/li&gt;
	&lt;li&gt;final RelOptTable targetTable = getTargetTable(call);&lt;/li&gt;
	&lt;li&gt;final RelDataType tableRowType = targetTable.getRowType();&lt;/li&gt;
	&lt;li&gt;SqlNodeList targetColumnList = call.getTargetColumnList();&lt;/li&gt;
	&lt;li&gt;if (targetColumnList == null) {&lt;/li&gt;
	&lt;li&gt;if (validator.getConformance().isInsertSubsetColumnsAllowed()) 
{
-				final RelDataType targetRowType =
-						typeFactory.createStructType(
-								tableRowType.getFieldList()
-										.subList(0, sourceRef.getType().getFieldCount()));
-				targetColumnNames.addAll(targetRowType.getFieldNames());
-			}
&lt;p&gt; else &lt;/p&gt;
{
-				targetColumnNames.addAll(tableRowType.getFieldNames());
-			}&lt;/li&gt;
	&lt;li&gt;} else {&lt;/li&gt;
	&lt;li&gt;for (int i = 0; i &amp;lt; targetColumnList.size(); i++) 
{
-				SqlIdentifier id = (SqlIdentifier) targetColumnList.get(i);
-				RelDataTypeField field =
-						SqlValidatorUtil.getTargetField(
-								tableRowType, typeFactory, id, catalogReader, targetTable);
-				assert field != null : &quot;column &quot; + id.toString() + &quot; not found&quot;;
-				targetColumnNames.add(field.getName());
-			}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final Blackboard bb =&lt;/li&gt;
	&lt;li&gt;createInsertBlackboard(targetTable, sourceRef, targetColumnNames);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Next, assign expressions for generated columns.&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;ColumnStrategy&amp;gt; strategies = targetTable.getColumnStrategies();&lt;/li&gt;
	&lt;li&gt;for (String columnName : targetColumnNames) {&lt;/li&gt;
	&lt;li&gt;final int i = tableRowType.getFieldNames().indexOf(columnName);&lt;/li&gt;
	&lt;li&gt;final RexNode expr;&lt;/li&gt;
	&lt;li&gt;switch (strategies.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) 
{
-				case STORED:
-					final InitializerExpressionFactory f =
-							Util.first(targetTable.unwrap(InitializerExpressionFactory.class),
-									NullInitializerExpressionFactory.INSTANCE);
-					expr = f.newColumnDefaultValue(targetTable, i, bb);
-					break;
-				case VIRTUAL:
-					expr = null;
-					break;
-				default:
-					expr = bb.nameToNodeMap.get(columnName);
-			}&lt;/li&gt;
	&lt;li&gt;columnExprs.add(expr);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Remove virtual columns from the list.&lt;/li&gt;
	&lt;li&gt;for (int i = 0; i &amp;lt; targetColumnNames.size(); i++) {&lt;/li&gt;
	&lt;li&gt;if (columnExprs.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; == null) 
{
-				columnExprs.remove(i);
-				targetColumnNames.remove(i);
-				--i;
-			}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private RelNode convertDelete(SqlDelete call) 
{
-		RelOptTable targetTable = getTargetTable(call);
-		RelNode sourceRel = convertSelect(call.getSourceSelect(), false);
-		return LogicalTableModify.create(targetTable, catalogReader, sourceRel,
-				LogicalTableModify.Operation.DELETE, null, null, false);
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;private RelNode convertUpdate(SqlUpdate call) {&lt;/li&gt;
	&lt;li&gt;final SqlValidatorScope scope = validator.getWhereScope(call.getSourceSelect());&lt;/li&gt;
	&lt;li&gt;Blackboard bb = createBlackboard(scope, null, false);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;Builder&amp;lt;RexNode&amp;gt; rexNodeSourceExpressionListBuilder = ImmutableList.builder();&lt;/li&gt;
	&lt;li&gt;for (SqlNode n : call.getSourceExpressionList()) 
{
-			RexNode rn = bb.convertExpression(n);
-			rexNodeSourceExpressionListBuilder.add(rn);
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;RelOptTable targetTable = getTargetTable(call);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// convert update column list from SqlIdentifier to String&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;String&amp;gt; targetColumnNameList = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;final RelDataType targetRowType = targetTable.getRowType();&lt;/li&gt;
	&lt;li&gt;for (SqlNode node : call.getTargetColumnList()) 
{
-			SqlIdentifier id = (SqlIdentifier) node;
-			RelDataTypeField field =
-					SqlValidatorUtil.getTargetField(
-							targetRowType, typeFactory, id, catalogReader, targetTable);
-			assert field != null : &quot;column &quot; + id.toString() + &quot; not found&quot;;
-			targetColumnNameList.add(field.getName());
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;RelNode sourceRel = convertSelect(call.getSourceSelect(), false);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;return LogicalTableModify.create(targetTable, catalogReader, sourceRel,&lt;/li&gt;
	&lt;li&gt;LogicalTableModify.Operation.UPDATE, targetColumnNameList,&lt;/li&gt;
	&lt;li&gt;rexNodeSourceExpressionListBuilder.build(), false);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private RelNode convertMerge(SqlMerge call) {&lt;/li&gt;
	&lt;li&gt;RelOptTable targetTable = getTargetTable(call);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// convert update column list from SqlIdentifier to String&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;String&amp;gt; targetColumnNameList = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;final RelDataType targetRowType = targetTable.getRowType();&lt;/li&gt;
	&lt;li&gt;SqlUpdate updateCall = call.getUpdateCall();&lt;/li&gt;
	&lt;li&gt;if (updateCall != null) {&lt;/li&gt;
	&lt;li&gt;for (SqlNode targetColumn : updateCall.getTargetColumnList()) 
{
-				SqlIdentifier id = (SqlIdentifier) targetColumn;
-				RelDataTypeField field =
-						SqlValidatorUtil.getTargetField(
-								targetRowType, typeFactory, id, catalogReader, targetTable);
-				assert field != null : &quot;column &quot; + id.toString() + &quot; not found&quot;;
-				targetColumnNameList.add(field.getName());
-			}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// replace the projection of the source select with a&lt;/li&gt;
	&lt;li&gt;// projection that contains the following:&lt;/li&gt;
	&lt;li&gt;// 1) the expressions corresponding to the new insert row (if there is&lt;/li&gt;
	&lt;li&gt;//    an insert)&lt;/li&gt;
	&lt;li&gt;// 2) all columns from the target table (if there is an update)&lt;/li&gt;
	&lt;li&gt;// 3) the set expressions in the update call (if there is an update)&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// first, convert the merge&apos;s source select to construct the columns&lt;/li&gt;
	&lt;li&gt;// from the target table and the set expressions in the update call&lt;/li&gt;
	&lt;li&gt;RelNode mergeSourceRel = convertSelect(call.getSourceSelect(), false);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// then, convert the insert statement so we can get the insert&lt;/li&gt;
	&lt;li&gt;// values expressions&lt;/li&gt;
	&lt;li&gt;SqlInsert insertCall = call.getInsertCall();&lt;/li&gt;
	&lt;li&gt;int nLevel1Exprs = 0;&lt;/li&gt;
	&lt;li&gt;List&amp;lt;RexNode&amp;gt; level1InsertExprs = null;&lt;/li&gt;
	&lt;li&gt;List&amp;lt;RexNode&amp;gt; level2InsertExprs = null;&lt;/li&gt;
	&lt;li&gt;if (insertCall != null) {&lt;/li&gt;
	&lt;li&gt;RelNode insertRel = convertInsert(insertCall);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// if there are 2 level of projections in the insert source, combine&lt;/li&gt;
	&lt;li&gt;// them into a single project; level1 refers to the topmost project;&lt;/li&gt;
	&lt;li&gt;// the level1 projection contains references to the level2&lt;/li&gt;
	&lt;li&gt;// expressions, except in the case where no target expression was&lt;/li&gt;
	&lt;li&gt;// provided, in which case, the expression is the default value for&lt;/li&gt;
	&lt;li&gt;// the column; or if the expressions directly map to the source&lt;/li&gt;
	&lt;li&gt;// table&lt;/li&gt;
	&lt;li&gt;level1InsertExprs =&lt;/li&gt;
	&lt;li&gt;((LogicalProject) insertRel.getInput(0)).getProjects();&lt;/li&gt;
	&lt;li&gt;if (insertRel.getInput(0).getInput(0) instanceof LogicalProject) 
{
-				level2InsertExprs =
-						((LogicalProject) insertRel.getInput(0).getInput(0))
-								.getProjects();
-			}&lt;/li&gt;
	&lt;li&gt;nLevel1Exprs = level1InsertExprs.size();&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;LogicalJoin join = (LogicalJoin) mergeSourceRel.getInput(0);&lt;/li&gt;
	&lt;li&gt;int nSourceFields = join.getLeft().getRowType().getFieldCount();&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;RexNode&amp;gt; projects = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;for (int level1Idx = 0; level1Idx &amp;lt; nLevel1Exprs; level1Idx++) {&lt;/li&gt;
	&lt;li&gt;if ((level2InsertExprs != null)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; (level1InsertExprs.get(level1Idx) instanceof RexInputRef)) 
{
-				int level2Idx =
-						((RexInputRef) level1InsertExprs.get(level1Idx)).getIndex();
-				projects.add(level2InsertExprs.get(level2Idx));
-			}
&lt;p&gt; else &lt;/p&gt;
{
-				projects.add(level1InsertExprs.get(level1Idx));
-			}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;if (updateCall != null) 
{
-			final LogicalProject project = (LogicalProject) mergeSourceRel;
-			projects.addAll(
-					Util.skip(project.getProjects(), nSourceFields));
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;relBuilder.push(join)&lt;/li&gt;
	&lt;li&gt;.project(projects);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;return LogicalTableModify.create(targetTable, catalogReader,&lt;/li&gt;
	&lt;li&gt;relBuilder.build(), LogicalTableModify.Operation.MERGE,&lt;/li&gt;
	&lt;li&gt;targetColumnNameList, null, false);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Converts an identifier into an expression in a given scope. For example,&lt;/li&gt;
	&lt;li&gt;* the &quot;empno&quot; in &quot;select empno from emp join dept&quot; becomes &quot;emp.empno&quot;.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private RexNode convertIdentifier(&lt;/li&gt;
	&lt;li&gt;Blackboard bb,&lt;/li&gt;
	&lt;li&gt;SqlIdentifier identifier) {&lt;/li&gt;
	&lt;li&gt;// first check for reserved identifiers like CURRENT_USER&lt;/li&gt;
	&lt;li&gt;final SqlCall call = SqlUtil.makeCall(opTab, identifier);&lt;/li&gt;
	&lt;li&gt;if (call != null) 
{
-			return bb.convertExpression(call);
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;String pv = null;&lt;/li&gt;
	&lt;li&gt;if (bb.isPatternVarRef &amp;amp;&amp;amp; identifier.names.size() &amp;gt; 1) 
{
-			pv = identifier.names.get(0);
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;final SqlQualified qualified;&lt;/li&gt;
	&lt;li&gt;if (bb.scope != null) 
{
-			qualified = bb.scope.fullyQualify(identifier);
-		}
&lt;p&gt; else &lt;/p&gt;
{
-			qualified = SqlQualified.create(null, 1, null, identifier);
-		}&lt;/li&gt;
	&lt;li&gt;final Pair&amp;lt;RexNode, Map&amp;lt;String, Integer&amp;gt;&amp;gt; e0 = bb.lookupExp(qualified);&lt;/li&gt;
	&lt;li&gt;RexNode e = e0.left;&lt;/li&gt;
	&lt;li&gt;for (String name : qualified.suffix()) {&lt;/li&gt;
	&lt;li&gt;if (e == e0.left &amp;amp;&amp;amp; e0.right != null) 
{
-				int i = e0.right.get(name);
-				e = rexBuilder.makeFieldAccess(e, i);
-			}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;final boolean caseSensitive = true; // name already fully-qualified&lt;/li&gt;
	&lt;li&gt;if (identifier.isStar() &amp;amp;&amp;amp; bb.scope instanceof MatchRecognizeScope) 
{
-					e = rexBuilder.makeFieldAccess(e, 0);
-				}
&lt;p&gt; else &lt;/p&gt;
{
-					e = rexBuilder.makeFieldAccess(e, name, caseSensitive);
-				}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;if (e instanceof RexInputRef) {&lt;/li&gt;
	&lt;li&gt;// adjust the type to account for nulls introduced by outer joins&lt;/li&gt;
	&lt;li&gt;e = adjustInputRef(bb, (RexInputRef) e);&lt;/li&gt;
	&lt;li&gt;if (pv != null) 
{
-				e = RexPatternFieldRef.of(pv, (RexInputRef) e);
-			}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;if (e0.left instanceof RexCorrelVariable) 
{
-			assert e instanceof RexFieldAccess;
-			final RexNode prev =
-					bb.mapCorrelateToRex.put(((RexCorrelVariable) e0.left).id,
-							(RexFieldAccess) e);
-			assert prev == null;
-		}&lt;/li&gt;
	&lt;li&gt;return e;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Adjusts the type of a reference to an input field to account for nulls&lt;/li&gt;
	&lt;li&gt;* introduced by outer joins; and adjusts the offset to match the physical&lt;/li&gt;
	&lt;li&gt;* implementation.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param bb       Blackboard&lt;/li&gt;
	&lt;li&gt;* @param inputRef Input ref&lt;/li&gt;
	&lt;li&gt;* @return Adjusted input ref&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;protected RexNode adjustInputRef(&lt;/li&gt;
	&lt;li&gt;Blackboard bb,&lt;/li&gt;
	&lt;li&gt;RexInputRef inputRef) {&lt;/li&gt;
	&lt;li&gt;RelDataTypeField field = bb.getRootField(inputRef);&lt;/li&gt;
	&lt;li&gt;if (field != null) 
{
-			return rexBuilder.makeInputRef(
-					field.getType(),
-					inputRef.getIndex());
-		}&lt;/li&gt;
	&lt;li&gt;return inputRef;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Converts a row constructor into a relational expression.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param bb             Blackboard&lt;/li&gt;
	&lt;li&gt;* @param rowConstructor Row constructor expression&lt;/li&gt;
	&lt;li&gt;* @return Relational expression which returns a single row.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private RelNode convertRowConstructor(&lt;/li&gt;
	&lt;li&gt;Blackboard bb,&lt;/li&gt;
	&lt;li&gt;SqlCall rowConstructor) 
{
-		Preconditions.checkArgument(isRowConstructor(rowConstructor));
-		final List&amp;lt;SqlNode&amp;gt; operands = rowConstructor.getOperandList();
-		return convertMultisets(operands, bb);
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;private RelNode convertCursor(Blackboard bb, SubQuery subQuery) 
{
-		final SqlCall cursorCall = (SqlCall) subQuery.node;
-		assert cursorCall.operandCount() == 1;
-		SqlNode query = cursorCall.operand(0);
-		RelNode converted = convertQuery(query, false, false).rel;
-		int iCursor = bb.cursors.size();
-		bb.cursors.add(converted);
-		subQuery.expr =
-				new RexInputRef(
-						iCursor,
-						converted.getRowType());
-		return converted;
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;private RelNode convertMultisets(final List&amp;lt;SqlNode&amp;gt; operands,&lt;/li&gt;
	&lt;li&gt;Blackboard bb) {&lt;/li&gt;
	&lt;li&gt;// NOTE: Wael 2/04/05: this implementation is not the most efficient in&lt;/li&gt;
	&lt;li&gt;// terms of planning since it generates XOs that can be reduced.&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;Object&amp;gt; joinList = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;List&amp;lt;SqlNode&amp;gt; lastList = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;for (int i = 0; i &amp;lt; operands.size(); i++) {&lt;/li&gt;
	&lt;li&gt;SqlNode operand = operands.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;/li&gt;
	&lt;li&gt;if (!(operand instanceof SqlCall)) 
{
-				lastList.add(operand);
-				continue;
-			}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;final SqlCall call = (SqlCall) operand;&lt;/li&gt;
	&lt;li&gt;final RelNode input;&lt;/li&gt;
	&lt;li&gt;switch (call.getKind()) {&lt;/li&gt;
	&lt;li&gt;case MULTISET_VALUE_CONSTRUCTOR:&lt;/li&gt;
	&lt;li&gt;case ARRAY_VALUE_CONSTRUCTOR:&lt;/li&gt;
	&lt;li&gt;final SqlNodeList list =&lt;/li&gt;
	&lt;li&gt;new SqlNodeList(call.getOperandList(), call.getParserPosition());&lt;/li&gt;
	&lt;li&gt;CollectNamespace nss =&lt;/li&gt;
	&lt;li&gt;(CollectNamespace) validator.getNamespace(call);&lt;/li&gt;
	&lt;li&gt;Blackboard usedBb;&lt;/li&gt;
	&lt;li&gt;if (null != nss) 
{
-						usedBb = createBlackboard(nss.getScope(), null, false);
-					}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;usedBb =&lt;/li&gt;
	&lt;li&gt;createBlackboard(new ListScope(bb.scope) {&lt;/li&gt;
	&lt;li&gt;public SqlNode getNode() 
{
-										return call;
-									}&lt;/li&gt;
	&lt;li&gt;}, null, false);&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;RelDataType multisetType = validator.getValidatedNodeType(call);&lt;/li&gt;
	&lt;li&gt;((SqlValidatorImpl) validator).setValidatedNodeType(list,&lt;/li&gt;
	&lt;li&gt;multisetType.getComponentType());&lt;/li&gt;
	&lt;li&gt;input = convertQueryOrInList(usedBb, list, null);&lt;/li&gt;
	&lt;li&gt;break;&lt;/li&gt;
	&lt;li&gt;case MULTISET_QUERY_CONSTRUCTOR:&lt;/li&gt;
	&lt;li&gt;case ARRAY_QUERY_CONSTRUCTOR:&lt;/li&gt;
	&lt;li&gt;final RelRoot root = convertQuery(call.operand(0), false, true);&lt;/li&gt;
	&lt;li&gt;input = root.rel;&lt;/li&gt;
	&lt;li&gt;break;&lt;/li&gt;
	&lt;li&gt;default:&lt;/li&gt;
	&lt;li&gt;lastList.add(operand);&lt;/li&gt;
	&lt;li&gt;continue;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;if (lastList.size() &amp;gt; 0) 
{
-				joinList.add(lastList);
-			}&lt;/li&gt;
	&lt;li&gt;lastList = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;Collect collect =&lt;/li&gt;
	&lt;li&gt;new Collect(&lt;/li&gt;
	&lt;li&gt;cluster,&lt;/li&gt;
	&lt;li&gt;cluster.traitSetOf(Convention.NONE),&lt;/li&gt;
	&lt;li&gt;input,&lt;/li&gt;
	&lt;li&gt;validator.deriveAlias(call, i));&lt;/li&gt;
	&lt;li&gt;joinList.add(collect);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;if (joinList.size() == 0) 
{
-			joinList.add(lastList);
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;for (int i = 0; i &amp;lt; joinList.size(); i++) {&lt;/li&gt;
	&lt;li&gt;Object o = joinList.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;/li&gt;
	&lt;li&gt;if (o instanceof List) {&lt;/li&gt;
	&lt;li&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/li&gt;
	&lt;li&gt;List&amp;lt;SqlNode&amp;gt; projectList = (List&amp;lt;SqlNode&amp;gt;) o;&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;RexNode&amp;gt; selectList = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;String&amp;gt; fieldNameList = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;for (int j = 0; j &amp;lt; projectList.size(); j++) 
{
-					SqlNode operand = projectList.get(j);
-					selectList.add(bb.convertExpression(operand));
-
-					// REVIEW angel 5-June-2005: Use deriveAliasFromOrdinal
-					// instead of deriveAlias to match field names from
-					// SqlRowOperator. Otherwise, get error   Type
-					// &apos;RecordType(INTEGER EMPNO)&apos; has no field &apos;EXPR$0&apos; when
-					// doing   select * from unnest(     select multiset[empno]
-					// from sales.emps);
-
-					fieldNameList.add(SqlUtil.deriveAliasFromOrdinal(j));
-				}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;relBuilder.push(LogicalValues.createOneRow(cluster))&lt;/li&gt;
	&lt;li&gt;.projectNamed(selectList, fieldNameList, true);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;joinList.set(i, relBuilder.build());&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;RelNode ret = (RelNode) joinList.get(0);&lt;/li&gt;
	&lt;li&gt;for (int i = 1; i &amp;lt; joinList.size(); i++) 
{
-			RelNode relNode = (RelNode) joinList.get(i);
-			ret =
-					RelFactories.DEFAULT_JOIN_FACTORY.createJoin(
-							ret,
-							relNode,
-							rexBuilder.makeLiteral(true),
-							ImmutableSet.of(),
-							JoinRelType.INNER,
-							false);
-		}&lt;/li&gt;
	&lt;li&gt;return ret;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private void convertSelectList(&lt;/li&gt;
	&lt;li&gt;Blackboard bb,&lt;/li&gt;
	&lt;li&gt;SqlSelect select,&lt;/li&gt;
	&lt;li&gt;List&amp;lt;SqlNode&amp;gt; orderList) {&lt;/li&gt;
	&lt;li&gt;SqlNodeList selectList = select.getSelectList();&lt;/li&gt;
	&lt;li&gt;selectList = validator.expandStar(selectList, select, false);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;replaceSubQueries(bb, selectList, RelOptUtil.Logic.TRUE_FALSE_UNKNOWN);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;List&amp;lt;String&amp;gt; fieldNames = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;RexNode&amp;gt; exprs = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;final Collection&amp;lt;String&amp;gt; aliases = new TreeSet&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Project any system fields. (Must be done before regular select items,&lt;/li&gt;
	&lt;li&gt;// because offsets may be affected.)&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;SqlMonotonicity&amp;gt; columnMonotonicityList = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;extraSelectItems(&lt;/li&gt;
	&lt;li&gt;bb,&lt;/li&gt;
	&lt;li&gt;select,&lt;/li&gt;
	&lt;li&gt;exprs,&lt;/li&gt;
	&lt;li&gt;fieldNames,&lt;/li&gt;
	&lt;li&gt;aliases,&lt;/li&gt;
	&lt;li&gt;columnMonotonicityList);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Project select clause.&lt;/li&gt;
	&lt;li&gt;int i = -1;&lt;/li&gt;
	&lt;li&gt;for (SqlNode expr : selectList) 
{
-			++i;
-			exprs.add(bb.convertExpression(expr));
-			fieldNames.add(deriveAlias(expr, aliases, i));
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Project extra fields for sorting.&lt;/li&gt;
	&lt;li&gt;for (SqlNode expr : orderList) 
{
-			++i;
-			SqlNode expr2 = validator.expandOrderExpr(select, expr);
-			exprs.add(bb.convertExpression(expr2));
-			fieldNames.add(deriveAlias(expr, aliases, i));
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;fieldNames = SqlValidatorUtil.uniquify(fieldNames,&lt;/li&gt;
	&lt;li&gt;catalogReader.nameMatcher().isCaseSensitive());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;relBuilder.push(bb.root)&lt;/li&gt;
	&lt;li&gt;.projectNamed(exprs, fieldNames, true);&lt;/li&gt;
	&lt;li&gt;bb.setRoot(relBuilder.build(), false);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;assert bb.columnMonotonicities.isEmpty();&lt;/li&gt;
	&lt;li&gt;bb.columnMonotonicities.addAll(columnMonotonicityList);&lt;/li&gt;
	&lt;li&gt;for (SqlNode selectItem : selectList) 
{
-			bb.columnMonotonicities.add(
-					selectItem.getMonotonicity(bb.scope));
-		}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Adds extra select items. The default implementation adds nothing; derived&lt;/li&gt;
	&lt;li&gt;* classes may add columns to exprList, nameList, aliasList and&lt;/li&gt;
	&lt;li&gt;* columnMonotonicityList.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param bb                     Blackboard&lt;/li&gt;
	&lt;li&gt;* @param select                 Select statement being translated&lt;/li&gt;
	&lt;li&gt;* @param exprList               List of expressions in select clause&lt;/li&gt;
	&lt;li&gt;* @param nameList               List of names, one per column&lt;/li&gt;
	&lt;li&gt;* @param aliasList              Collection of aliases that have been used&lt;/li&gt;
	&lt;li&gt;*                               already&lt;/li&gt;
	&lt;li&gt;* @param columnMonotonicityList List of monotonicity, one per column&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;protected void extraSelectItems(&lt;/li&gt;
	&lt;li&gt;Blackboard bb,&lt;/li&gt;
	&lt;li&gt;SqlSelect select,&lt;/li&gt;
	&lt;li&gt;List&amp;lt;RexNode&amp;gt; exprList,&lt;/li&gt;
	&lt;li&gt;List&amp;lt;String&amp;gt; nameList,&lt;/li&gt;
	&lt;li&gt;Collection&amp;lt;String&amp;gt; aliasList,&lt;/li&gt;
	&lt;li&gt;List&amp;lt;SqlMonotonicity&amp;gt; columnMonotonicityList) 
{
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;private String deriveAlias(&lt;/li&gt;
	&lt;li&gt;final SqlNode node,&lt;/li&gt;
	&lt;li&gt;Collection&amp;lt;String&amp;gt; aliases,&lt;/li&gt;
	&lt;li&gt;final int ordinal) {&lt;/li&gt;
	&lt;li&gt;String alias = validator.deriveAlias(node, ordinal);&lt;/li&gt;
	&lt;li&gt;if ((alias == null) || aliases.contains(alias)) {&lt;/li&gt;
	&lt;li&gt;String aliasBase = (alias == null) ? &quot;EXPR$&quot; : alias;&lt;/li&gt;
	&lt;li&gt;for (int j = 0;; j++) {&lt;/li&gt;
	&lt;li&gt;alias = aliasBase + j;&lt;/li&gt;
	&lt;li&gt;if (!aliases.contains(alias)) 
{
-					break;
-				}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;aliases.add(alias);&lt;/li&gt;
	&lt;li&gt;return alias;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Converts a WITH sub-query into a relational expression.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public RelRoot convertWith(SqlWith with, boolean top) 
{
-		return convertQuery(with.body, false, top);
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Converts a SELECT statement&apos;s parse tree into a relational expression.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public RelNode convertValues(&lt;/li&gt;
	&lt;li&gt;SqlCall values,&lt;/li&gt;
	&lt;li&gt;RelDataType targetRowType) 
{
-		final SqlValidatorScope scope = validator.getOverScope(values);
-		assert scope != null;
-		final Blackboard bb = createBlackboard(scope, null, false);
-		convertValuesImpl(bb, values, targetRowType);
-		return bb.root;
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Converts a values clause (as in &quot;INSERT INTO T(x,y) VALUES (1,2)&quot;) into a&lt;/li&gt;
	&lt;li&gt;* relational expression.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param bb            Blackboard&lt;/li&gt;
	&lt;li&gt;* @param values        Call to SQL VALUES operator&lt;/li&gt;
	&lt;li&gt;* @param targetRowType Target row type&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private void convertValuesImpl(&lt;/li&gt;
	&lt;li&gt;Blackboard bb,&lt;/li&gt;
	&lt;li&gt;SqlCall values,&lt;/li&gt;
	&lt;li&gt;RelDataType targetRowType) {&lt;/li&gt;
	&lt;li&gt;// Attempt direct conversion to LogicalValues; if that fails, deal with&lt;/li&gt;
	&lt;li&gt;// fancy stuff like sub-queries below.&lt;/li&gt;
	&lt;li&gt;RelNode valuesRel =&lt;/li&gt;
	&lt;li&gt;convertRowValues(&lt;/li&gt;
	&lt;li&gt;bb,&lt;/li&gt;
	&lt;li&gt;values,&lt;/li&gt;
	&lt;li&gt;values.getOperandList(),&lt;/li&gt;
	&lt;li&gt;true,&lt;/li&gt;
	&lt;li&gt;targetRowType);&lt;/li&gt;
	&lt;li&gt;if (valuesRel != null) 
{
-			bb.setRoot(valuesRel, true);
-			return;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;RelNode&amp;gt; unionRels = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;for (SqlNode rowConstructor1 : values.getOperandList()) {&lt;/li&gt;
	&lt;li&gt;SqlCall rowConstructor = (SqlCall) rowConstructor1;&lt;/li&gt;
	&lt;li&gt;Blackboard tmpBb = createBlackboard(bb.scope, null, false);&lt;/li&gt;
	&lt;li&gt;replaceSubQueries(tmpBb, rowConstructor,&lt;/li&gt;
	&lt;li&gt;RelOptUtil.Logic.TRUE_FALSE_UNKNOWN);&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;Pair&amp;lt;RexNode, String&amp;gt;&amp;gt; exps = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;for (Ord&amp;lt;SqlNode&amp;gt; operand : Ord.zip(rowConstructor.getOperandList())) 
{
-				exps.add(
-						Pair.of(
-								tmpBb.convertExpression(operand.e),
-								validator.deriveAlias(operand.e, operand.i)));
-			}&lt;/li&gt;
	&lt;li&gt;RelNode in =&lt;/li&gt;
	&lt;li&gt;(null == tmpBb.root)&lt;/li&gt;
	&lt;li&gt;? LogicalValues.createOneRow(cluster)&lt;/li&gt;
	&lt;li&gt;: tmpBb.root;&lt;/li&gt;
	&lt;li&gt;unionRels.add(relBuilder.push(in)&lt;/li&gt;
	&lt;li&gt;.project(Pair.left(exps), Pair.right(exps))&lt;/li&gt;
	&lt;li&gt;.build());&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;if (unionRels.size() == 0) 
{
-			throw new AssertionError(&quot;empty values clause&quot;);
-		}
&lt;p&gt; else if (unionRels.size() == 1) &lt;/p&gt;
{
-			bb.setRoot(
-					unionRels.get(0),
-					true);
-		}
&lt;p&gt; else &lt;/p&gt;
{
-			bb.setRoot(
-					LogicalUnion.create(unionRels, true),
-					true);
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// REVIEW jvs 22-Jan-2004:  should I add&lt;/li&gt;
	&lt;li&gt;// mapScopeToLux.put(validator.getScope(values),bb.root);&lt;/li&gt;
	&lt;li&gt;// ?&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;//~ Inner Classes ----------------------------------------------------------&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Workspace for translating an individual SELECT statement (or sub-SELECT).&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;protected class Blackboard implements SqlRexContext, SqlVisitor&amp;lt;RexNode&amp;gt;,&lt;/li&gt;
	&lt;li&gt;InitializerContext {&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Collection of 
{@link RelNode}
&lt;p&gt; objects which correspond to a SELECT&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;* statement.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public final SqlValidatorScope scope;&lt;/li&gt;
	&lt;li&gt;private final Map&amp;lt;String, RexNode&amp;gt; nameToNodeMap;&lt;/li&gt;
	&lt;li&gt;public RelNode root;&lt;/li&gt;
	&lt;li&gt;private List&amp;lt;RelNode&amp;gt; inputs;&lt;/li&gt;
	&lt;li&gt;private final Map&amp;lt;CorrelationId, RexFieldAccess&amp;gt; mapCorrelateToRex =&lt;/li&gt;
	&lt;li&gt;new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private boolean isPatternVarRef = false;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;RelNode&amp;gt; cursors = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* List of &amp;lt;code&amp;gt;IN&amp;lt;/code&amp;gt; and &amp;lt;code&amp;gt;EXISTS&amp;lt;/code&amp;gt; nodes inside this&lt;/li&gt;
	&lt;li&gt;* &amp;lt;code&amp;gt;SELECT&amp;lt;/code&amp;gt; statement (but not inside sub-queries).&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private final Set&amp;lt;SubQuery&amp;gt; subQueryList = new LinkedHashSet&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Workspace for building aggregates.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;AggConverter agg;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* When converting window aggregate, we need to know if the window is&lt;/li&gt;
	&lt;li&gt;* guaranteed to be non-empty.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;SqlWindow window;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Project the groupby expressions out of the root of this sub-select.&lt;/li&gt;
	&lt;li&gt;* Sub-queries can reference group by expressions projected from the&lt;/li&gt;
	&lt;li&gt;* &quot;right&quot; to the sub-query.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private final Map&amp;lt;RelNode, Map&amp;lt;Integer, Integer&amp;gt;&amp;gt; mapRootRelToFieldProjection =&lt;/li&gt;
	&lt;li&gt;new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private final List&amp;lt;SqlMonotonicity&amp;gt; columnMonotonicities =&lt;/li&gt;
	&lt;li&gt;new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private final List&amp;lt;RelDataTypeField&amp;gt; systemFieldList = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;final boolean top;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private final InitializerExpressionFactory initializerExpressionFactory =&lt;/li&gt;
	&lt;li&gt;new NullInitializerExpressionFactory();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Creates a Blackboard.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param scope         Name-resolution scope for expressions validated&lt;/li&gt;
	&lt;li&gt;*                      within this query. Can be null if this Blackboard is&lt;/li&gt;
	&lt;li&gt;*                      for a leaf node, say&lt;/li&gt;
	&lt;li&gt;* @param nameToNodeMap Map which translates the expression to map a&lt;/li&gt;
	&lt;li&gt;*                      given parameter into, if translating expressions;&lt;/li&gt;
	&lt;li&gt;*                      null otherwise&lt;/li&gt;
	&lt;li&gt;* @param top           Whether this is the root of the query&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;protected Blackboard(SqlValidatorScope scope,&lt;/li&gt;
	&lt;li&gt;Map&amp;lt;String, RexNode&amp;gt; nameToNodeMap, boolean top) 
{
-			this.scope = scope;
-			this.nameToNodeMap = nameToNodeMap;
-			this.top = top;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public void setPatternVarRef(boolean isVarRef) 
{
-			this.isPatternVarRef = isVarRef;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public RexNode register(&lt;/li&gt;
	&lt;li&gt;RelNode rel,&lt;/li&gt;
	&lt;li&gt;JoinRelType joinType) 
{
-			return register(rel, joinType, null);
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Registers a relational expression.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param rel               Relational expression&lt;/li&gt;
	&lt;li&gt;* @param joinType          Join type&lt;/li&gt;
	&lt;li&gt;* @param leftKeys LHS of IN clause, or null for expressions&lt;/li&gt;
	&lt;li&gt;*                          other than IN&lt;/li&gt;
	&lt;li&gt;* @return Expression with which to refer to the row (or partial row)&lt;/li&gt;
	&lt;li&gt;* coming from this relational expression&apos;s side of the join&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public RexNode register(&lt;/li&gt;
	&lt;li&gt;RelNode rel,&lt;/li&gt;
	&lt;li&gt;JoinRelType joinType,&lt;/li&gt;
	&lt;li&gt;List&amp;lt;RexNode&amp;gt; leftKeys) {&lt;/li&gt;
	&lt;li&gt;assert joinType != null;&lt;/li&gt;
	&lt;li&gt;if (root == null) 
{
-				assert leftKeys == null;
-				setRoot(rel, false);
-				return rexBuilder.makeRangeReference(
-						root.getRowType(),
-						0,
-						false);
-			}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;final RexNode joinCond;&lt;/li&gt;
	&lt;li&gt;final int origLeftInputCount = root.getRowType().getFieldCount();&lt;/li&gt;
	&lt;li&gt;if (leftKeys != null) {&lt;/li&gt;
	&lt;li&gt;List&amp;lt;RexNode&amp;gt; newLeftInputExprs = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;for (int i = 0; i &amp;lt; origLeftInputCount; i++) 
{
-					newLeftInputExprs.add(rexBuilder.makeInputRef(root, i));
-				}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;Integer&amp;gt; leftJoinKeys = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;for (RexNode leftKey : leftKeys) {&lt;/li&gt;
	&lt;li&gt;int index = newLeftInputExprs.indexOf(leftKey);&lt;/li&gt;
	&lt;li&gt;if (index &amp;lt; 0 || joinType == JoinRelType.LEFT) 
{
-						index = newLeftInputExprs.size();
-						newLeftInputExprs.add(leftKey);
-					}&lt;/li&gt;
	&lt;li&gt;leftJoinKeys.add(index);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;RelNode newLeftInput =&lt;/li&gt;
	&lt;li&gt;relBuilder.push(root)&lt;/li&gt;
	&lt;li&gt;.project(newLeftInputExprs)&lt;/li&gt;
	&lt;li&gt;.build();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// maintain the group by mapping in the new LogicalProject&lt;/li&gt;
	&lt;li&gt;if (mapRootRelToFieldProjection.containsKey(root)) 
{
-					mapRootRelToFieldProjection.put(
-							newLeftInput,
-							mapRootRelToFieldProjection.get(root));
-				}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;setRoot(newLeftInput, false);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// right fields appear after the LHS fields.&lt;/li&gt;
	&lt;li&gt;final int rightOffset = root.getRowType().getFieldCount()&lt;/li&gt;
	&lt;li&gt;- newLeftInput.getRowType().getFieldCount();&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;Integer&amp;gt; rightKeys =&lt;/li&gt;
	&lt;li&gt;Util.range(rightOffset, rightOffset + leftKeys.size());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;joinCond =&lt;/li&gt;
	&lt;li&gt;RelOptUtil.createEquiJoinCondition(newLeftInput, leftJoinKeys,&lt;/li&gt;
	&lt;li&gt;rel, rightKeys, rexBuilder);&lt;/li&gt;
	&lt;li&gt;} else 
{
-				joinCond = rexBuilder.makeLiteral(true);
-			}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;int leftFieldCount = root.getRowType().getFieldCount();&lt;/li&gt;
	&lt;li&gt;final RelNode join =&lt;/li&gt;
	&lt;li&gt;createJoin(&lt;/li&gt;
	&lt;li&gt;this,&lt;/li&gt;
	&lt;li&gt;root,&lt;/li&gt;
	&lt;li&gt;rel,&lt;/li&gt;
	&lt;li&gt;joinCond,&lt;/li&gt;
	&lt;li&gt;joinType);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;setRoot(join, false);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;if (leftKeys != null&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; joinType == JoinRelType.LEFT) {&lt;/li&gt;
	&lt;li&gt;final int leftKeyCount = leftKeys.size();&lt;/li&gt;
	&lt;li&gt;int rightFieldLength = rel.getRowType().getFieldCount();&lt;/li&gt;
	&lt;li&gt;assert leftKeyCount == rightFieldLength - 1;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final int rexRangeRefLength = leftKeyCount + rightFieldLength;&lt;/li&gt;
	&lt;li&gt;RelDataType returnType =&lt;/li&gt;
	&lt;li&gt;typeFactory.createStructType(&lt;/li&gt;
	&lt;li&gt;new AbstractList&amp;lt;Map.Entry&amp;lt;String, RelDataType&amp;gt;&amp;gt;() {&lt;/li&gt;
	&lt;li&gt;public Map.Entry&amp;lt;String, RelDataType&amp;gt; get(&lt;/li&gt;
	&lt;li&gt;int index) 
{
-										return join.getRowType().getFieldList()
-												.get(origLeftInputCount + index);
-									}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public int size() 
{
-										return rexRangeRefLength;
-									}&lt;/li&gt;
	&lt;li&gt;});&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;return rexBuilder.makeRangeReference(&lt;/li&gt;
	&lt;li&gt;returnType,&lt;/li&gt;
	&lt;li&gt;origLeftInputCount,&lt;/li&gt;
	&lt;li&gt;false);&lt;/li&gt;
	&lt;li&gt;} else 
{
-				return rexBuilder.makeRangeReference(
-						rel.getRowType(),
-						leftFieldCount,
-						joinType.generatesNullsOnRight());
-			}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Sets a new root relational expression, as the translation process&lt;/li&gt;
	&lt;li&gt;* backs its way further up the tree.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param root New root relational expression&lt;/li&gt;
	&lt;li&gt;* @param leaf Whether the relational expression is a leaf, that is,&lt;/li&gt;
	&lt;li&gt;*             derived from an atomic relational expression such as a table&lt;/li&gt;
	&lt;li&gt;*             name in the from clause, or the projection on top of a&lt;/li&gt;
	&lt;li&gt;*             select-sub-query. In particular, relational expressions&lt;/li&gt;
	&lt;li&gt;*             derived from JOIN operators are not leaves, but set&lt;/li&gt;
	&lt;li&gt;*             expressions are.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public void setRoot(RelNode root, boolean leaf) {&lt;/li&gt;
	&lt;li&gt;setRoot(&lt;/li&gt;
	&lt;li&gt;Collections.singletonList(root), root, root instanceof LogicalJoin);&lt;/li&gt;
	&lt;li&gt;if (leaf) 
{
-				leaves.add(root);
-			}&lt;/li&gt;
	&lt;li&gt;this.columnMonotonicities.clear();&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private void setRoot(&lt;/li&gt;
	&lt;li&gt;List&amp;lt;RelNode&amp;gt; inputs,&lt;/li&gt;
	&lt;li&gt;RelNode root,&lt;/li&gt;
	&lt;li&gt;boolean hasSystemFields) {&lt;/li&gt;
	&lt;li&gt;this.inputs = inputs;&lt;/li&gt;
	&lt;li&gt;this.root = root;&lt;/li&gt;
	&lt;li&gt;this.systemFieldList.clear();&lt;/li&gt;
	&lt;li&gt;if (hasSystemFields) 
{
-				this.systemFieldList.addAll(getSystemFields());
-			}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Notifies this Blackboard that the root just set using&lt;/li&gt;
	&lt;li&gt;* 
{@link #setRoot(RelNode, boolean)}
&lt;p&gt; was derived using dataset&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;* substitution.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;The default implementation is not interested in such&lt;/li&gt;
	&lt;li&gt;* notifications, and does nothing.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param datasetName Dataset name&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public void setDataset(String datasetName) 
{
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;void setRoot(List&amp;lt;RelNode&amp;gt; inputs) 
{
-			setRoot(inputs, null, false);
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Returns an expression with which to reference a from-list item.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param qualified the alias of the from item&lt;/li&gt;
	&lt;li&gt;* @return a 
{@link RexFieldAccess}
&lt;p&gt; or &lt;/p&gt;
{@link RexRangeRef}
&lt;p&gt;, or null if&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;* not found&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;Pair&amp;lt;RexNode, Map&amp;lt;String, Integer&amp;gt;&amp;gt; lookupExp(SqlQualified qualified) {&lt;/li&gt;
	&lt;li&gt;if (nameToNodeMap != null &amp;amp;&amp;amp; qualified.prefixLength == 1) {&lt;/li&gt;
	&lt;li&gt;RexNode node = nameToNodeMap.get(qualified.identifier.names.get(0));&lt;/li&gt;
	&lt;li&gt;if (node == null) 
{
-					throw new AssertionError(&quot;Unknown identifier &apos;&quot; + qualified.identifier
-							+ &quot;&apos; encountered while expanding expression&quot;);
-				}&lt;/li&gt;
	&lt;li&gt;return Pair.of(node, null);&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;final SqlNameMatcher nameMatcher =&lt;/li&gt;
	&lt;li&gt;scope.getValidator().getCatalogReader().nameMatcher();&lt;/li&gt;
	&lt;li&gt;final SqlValidatorScope.ResolvedImpl resolved =&lt;/li&gt;
	&lt;li&gt;new SqlValidatorScope.ResolvedImpl();&lt;/li&gt;
	&lt;li&gt;scope.resolve(qualified.prefix(), nameMatcher, false, resolved);&lt;/li&gt;
	&lt;li&gt;if (!(resolved.count() == 1)) 
{
-				return null;
-			}&lt;br/&gt;
-			final SqlValidatorScope.Resolve resolve = resolved.only();&lt;br/&gt;
-			final RelDataType rowType = resolve.rowType();&lt;br/&gt;
-&lt;br/&gt;
-			// Found in current query&apos;s from list.  Find which from item.&lt;br/&gt;
-			// We assume that the order of the from clause items has been&lt;br/&gt;
-			// preserved.&lt;br/&gt;
-			final SqlValidatorScope ancestorScope = resolve.scope;&lt;br/&gt;
-			boolean isParent = ancestorScope != scope;&lt;br/&gt;
-			if ((inputs != null) &amp;amp;&amp;amp; !isParent) {&lt;br/&gt;
-				final LookupContext rels =&lt;br/&gt;
-						new LookupContext(this, inputs, systemFieldList.size());&lt;br/&gt;
-				final RexNode node = lookup(resolve.path.steps().get(0).i, rels);&lt;br/&gt;
-				if (node == null) {
-					return null;
-				} else {&lt;br/&gt;
-					final Map&amp;lt;String, Integer&amp;gt; fieldOffsets = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
-					for (RelDataTypeField f : resolve.rowType().getFieldList()) {&lt;br/&gt;
-						if (!fieldOffsets.containsKey(f.getName())) {
-							fieldOffsets.put(f.getName(), f.getIndex());
-						}&lt;br/&gt;
-					}&lt;br/&gt;
-					final Map&amp;lt;String, Integer&amp;gt; map = ImmutableMap.copyOf(fieldOffsets);&lt;br/&gt;
-					return Pair.of(node, map);&lt;br/&gt;
-				}&lt;br/&gt;
-			} else {&lt;br/&gt;
-				// We&apos;re referencing a relational expression which has not been&lt;br/&gt;
-				// converted yet. This occurs when from items are correlated,&lt;br/&gt;
-				// e.g. &quot;select from emp as emp join emp.getDepts() as dept&quot;.&lt;br/&gt;
-				// Create a temporary expression.&lt;br/&gt;
-				DeferredLookup lookup =&lt;br/&gt;
-						new DeferredLookup(this, qualified.identifier.names.get(0));&lt;br/&gt;
-				final CorrelationId correlId = cluster.createCorrel();&lt;br/&gt;
-				mapCorrelToDeferred.put(correlId, lookup);&lt;br/&gt;
-				if (resolve.path.steps().get(0).i &amp;lt; 0) {
-					return Pair.of(rexBuilder.makeCorrel(rowType, correlId), null);
-				} else {&lt;br/&gt;
-					final RelDataTypeFactory.Builder builder = typeFactory.builder();&lt;br/&gt;
-					final ListScope ancestorScope1 = (ListScope) resolve.scope;&lt;br/&gt;
-					final ImmutableMap.Builder&amp;lt;String, Integer&amp;gt; fields =&lt;br/&gt;
-							ImmutableMap.builder();&lt;br/&gt;
-					int i = 0;&lt;br/&gt;
-					int offset = 0;&lt;br/&gt;
-					for (SqlValidatorNamespace c : ancestorScope1.getChildren()) {&lt;br/&gt;
-						builder.addAll(c.getRowType().getFieldList());&lt;br/&gt;
-						if (i == resolve.path.steps().get(0).i) {&lt;br/&gt;
-							for (RelDataTypeField field : c.getRowType().getFieldList()) {
-								fields.put(field.getName(), field.getIndex() + offset);
-							}&lt;br/&gt;
-						}&lt;br/&gt;
-						++i;&lt;br/&gt;
-						offset += c.getRowType().getFieldCount();&lt;br/&gt;
-					}&lt;br/&gt;
-					final RexNode c =&lt;br/&gt;
-							rexBuilder.makeCorrel(builder.uniquify().build(), correlId);&lt;br/&gt;
-					return Pair.of(c, fields.build());&lt;br/&gt;
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * Creates an expression with which to reference the expression whose&lt;br/&gt;
-		 * offset in its from-list is {@code offset}.&lt;br/&gt;
-		 */&lt;br/&gt;
-		RexNode lookup(&lt;br/&gt;
-				int offset,&lt;br/&gt;
-				LookupContext lookupContext) {
-			Pair&amp;lt;RelNode, Integer&amp;gt; pair = lookupContext.findRel(offset);
-			return rexBuilder.makeRangeReference(
-					pair.left.getRowType(),
-					pair.right,
-					false);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		RelDataTypeField getRootField(RexInputRef inputRef) {&lt;br/&gt;
-			if (inputs == null) {-				return null;-			}&lt;/li&gt;
	&lt;li&gt;int fieldOffset = inputRef.getIndex();&lt;/li&gt;
	&lt;li&gt;for (RelNode input : inputs) {&lt;/li&gt;
	&lt;li&gt;RelDataType rowType = input.getRowType();&lt;/li&gt;
	&lt;li&gt;if (rowType == null) 
{
-					// TODO:  remove this once leastRestrictive
-					// is correctly implemented
-					return null;
-				}&lt;/li&gt;
	&lt;li&gt;if (fieldOffset &amp;lt; rowType.getFieldCount()) 
{
-					return rowType.getFieldList().get(fieldOffset);
-				}&lt;/li&gt;
	&lt;li&gt;fieldOffset -= rowType.getFieldCount();&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;throw new AssertionError();&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;public void flatten(&lt;/li&gt;
	&lt;li&gt;List&amp;lt;RelNode&amp;gt; rels,&lt;/li&gt;
	&lt;li&gt;int systemFieldCount,&lt;/li&gt;
	&lt;li&gt;int[] start,&lt;/li&gt;
	&lt;li&gt;List&amp;lt;Pair&amp;lt;RelNode, Integer&amp;gt;&amp;gt; relOffsetList) {&lt;/li&gt;
	&lt;li&gt;for (RelNode rel : rels) {&lt;/li&gt;
	&lt;li&gt;if (leaves.contains(rel) || rel instanceof LogicalMatch) 
{
-					relOffsetList.add(
-							Pair.of(rel, start[0]));
-					start[0] += rel.getRowType().getFieldCount();
-				}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;if (rel instanceof LogicalJoin&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; rel instanceof LogicalAggregate) 
{
-						start[0] += systemFieldCount;
-					}&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;flatten(&lt;/li&gt;
	&lt;li&gt;rel.getInputs(),&lt;/li&gt;
	&lt;li&gt;systemFieldCount,&lt;/li&gt;
	&lt;li&gt;start,&lt;/li&gt;
	&lt;li&gt;relOffsetList);&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;void registerSubQuery(SqlNode node, RelOptUtil.Logic logic) {&lt;/li&gt;
	&lt;li&gt;for (SubQuery subQuery : subQueryList) {&lt;/li&gt;
	&lt;li&gt;if (node.equalsDeep(subQuery.node, Litmus.IGNORE)) 
{
-					return;
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-			subQueryList.add(new SubQuery(node, logic));&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		SubQuery getSubQuery(SqlNode expr) {&lt;br/&gt;
-			for (SubQuery subQuery : subQueryList) {&lt;br/&gt;
-				if (expr.equalsDeep(subQuery.node, Litmus.IGNORE)) {
-					return subQuery;
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			return null;&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		ImmutableList&amp;lt;RelNode&amp;gt; retrieveCursors() {&lt;br/&gt;
-			try {
-				return ImmutableList.copyOf(cursors);
-			} finally {
-				cursors.clear();
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexNode convertExpression(SqlNode expr) {&lt;br/&gt;
-			// If we&apos;re in aggregation mode and this is an expression in the&lt;br/&gt;
-			// GROUP BY clause, return a reference to the field.&lt;br/&gt;
-			if (agg != null) {&lt;br/&gt;
-				final SqlNode expandedGroupExpr = validator.expand(expr, scope);&lt;br/&gt;
-				final int ref = agg.lookupGroupExpr(expandedGroupExpr);&lt;br/&gt;
-				if (ref &amp;gt;= 0) {
-					return rexBuilder.makeInputRef(root, ref);
-				}&lt;br/&gt;
-				if (expr instanceof SqlCall) {&lt;br/&gt;
-					final RexNode rex = agg.lookupAggregates((SqlCall) expr);&lt;br/&gt;
-					if (rex != null) {
-						return rex;
-					}&lt;br/&gt;
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			// Allow the derived class chance to override the standard&lt;br/&gt;
-			// behavior for special kinds of expressions.&lt;br/&gt;
-			RexNode rex = convertExtendedExpression(expr, this);&lt;br/&gt;
-			if (rex != null) {
-				return rex;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			// Sub-queries and OVER expressions are not like ordinary&lt;br/&gt;
-			// expressions.&lt;br/&gt;
-			final SqlKind kind = expr.getKind();&lt;br/&gt;
-			final SubQuery subQuery;&lt;br/&gt;
-			if (!config.isExpand()) {&lt;br/&gt;
-				final SqlCall call;&lt;br/&gt;
-				final SqlNode query;&lt;br/&gt;
-				final RelRoot root;&lt;br/&gt;
-				switch (kind) {&lt;br/&gt;
-					case IN:&lt;br/&gt;
-					case NOT_IN:&lt;br/&gt;
-					case SOME:&lt;br/&gt;
-					case ALL:&lt;br/&gt;
-						call = (SqlCall) expr;&lt;br/&gt;
-						query = call.operand(1);&lt;br/&gt;
-						if (!(query instanceof SqlNodeList)) {&lt;br/&gt;
-							root = convertQueryRecursive(query, false, null);&lt;br/&gt;
-							final SqlNode operand = call.operand(0);&lt;br/&gt;
-							List&amp;lt;SqlNode&amp;gt; nodes;&lt;br/&gt;
-							switch (operand.getKind()) {
-								case ROW:
-									nodes = ((SqlCall) operand).getOperandList();
-									break;
-								default:
-									nodes = ImmutableList.of(operand);
-							}&lt;br/&gt;
-							final ImmutableList.Builder&amp;lt;RexNode&amp;gt; builder =&lt;br/&gt;
-									ImmutableList.builder();&lt;br/&gt;
-							for (SqlNode node : nodes) {
-								builder.add(convertExpression(node));
-							}&lt;br/&gt;
-							final ImmutableList&amp;lt;RexNode&amp;gt; list = builder.build();&lt;br/&gt;
-							switch (kind) {
-								case IN:
-									return RexSubQuery.in(root.rel, list);
-								case NOT_IN:
-									return rexBuilder.makeCall(SqlStdOperatorTable.NOT,
-											RexSubQuery.in(root.rel, list));
-								case SOME:
-									return RexSubQuery.some(root.rel, list,
-											(SqlQuantifyOperator) call.getOperator());
-								case ALL:
-									return rexBuilder.makeCall(SqlStdOperatorTable.NOT,
-											RexSubQuery.some(root.rel, list,
-													negate((SqlQuantifyOperator) call.getOperator())));
-								default:
-									throw new AssertionError(kind);
-							}&lt;br/&gt;
-						}&lt;br/&gt;
-						break;&lt;br/&gt;
-&lt;br/&gt;
-					case EXISTS:&lt;br/&gt;
-						call = (SqlCall) expr;&lt;br/&gt;
-						query = Iterables.getOnlyElement(call.getOperandList());&lt;br/&gt;
-						root = convertQueryRecursive(query, false, null);&lt;br/&gt;
-						RelNode rel = root.rel;&lt;br/&gt;
-						while (rel instanceof Project&lt;br/&gt;
-								|| rel instanceof Sort&lt;br/&gt;
-								&amp;amp;&amp;amp; ((Sort) rel).fetch == null&lt;br/&gt;
-								&amp;amp;&amp;amp; ((Sort) rel).offset == null) {
-							rel = ((SingleRel) rel).getInput();
-						}&lt;br/&gt;
-						return RexSubQuery.exists(rel);&lt;br/&gt;
-&lt;br/&gt;
-					case SCALAR_QUERY:&lt;br/&gt;
-						call = (SqlCall) expr;&lt;br/&gt;
-						query = Iterables.getOnlyElement(call.getOperandList());&lt;br/&gt;
-						root = convertQueryRecursive(query, false, null);&lt;br/&gt;
-						return RexSubQuery.scalar(root.rel);&lt;br/&gt;
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			switch (kind) {&lt;br/&gt;
-				case SOME:&lt;br/&gt;
-				case ALL:&lt;br/&gt;
-					if (config.isExpand()) {
-						throw new RuntimeException(kind
-								+ &quot; is only supported if expand = false&quot;);
-					}&lt;br/&gt;
-					// fall through&lt;br/&gt;
-				case CURSOR:&lt;br/&gt;
-				case IN:&lt;br/&gt;
-				case NOT_IN:&lt;br/&gt;
-					subQuery = Objects.requireNonNull(getSubQuery(expr));&lt;br/&gt;
-					rex = Objects.requireNonNull(subQuery.expr);&lt;br/&gt;
-					return StandardConvertletTable.castToValidatedType(expr, rex,&lt;br/&gt;
-							validator, rexBuilder);&lt;br/&gt;
-&lt;br/&gt;
-				case SELECT:&lt;br/&gt;
-				case EXISTS:&lt;br/&gt;
-				case SCALAR_QUERY:&lt;br/&gt;
-					subQuery = getSubQuery(expr);&lt;br/&gt;
-					assert subQuery != null;&lt;br/&gt;
-					rex = subQuery.expr;&lt;br/&gt;
-					assert rex != null : &quot;rex != null&quot;;&lt;br/&gt;
-&lt;br/&gt;
-					if (((kind == SqlKind.SCALAR_QUERY)&lt;br/&gt;
-							|| (kind == SqlKind.EXISTS))&lt;br/&gt;
-							&amp;amp;&amp;amp; isConvertedSubq(rex)) {
-						// scalar sub-query or EXISTS has been converted to a
-						// constant
-						return rex;
-					}&lt;br/&gt;
-&lt;br/&gt;
-					// The indicator column is the last field of the sub-query.&lt;br/&gt;
-					RexNode fieldAccess =&lt;br/&gt;
-							rexBuilder.makeFieldAccess(&lt;br/&gt;
-									rex,&lt;br/&gt;
-									rex.getType().getFieldCount() - 1);&lt;br/&gt;
-&lt;br/&gt;
-					// The indicator column will be nullable if it comes from&lt;br/&gt;
-					// the null-generating side of the join. For EXISTS, add an&lt;br/&gt;
-					// &quot;IS TRUE&quot; check so that the result is &quot;BOOLEAN NOT NULL&quot;.&lt;br/&gt;
-					if (fieldAccess.getType().isNullable()&lt;br/&gt;
-							&amp;amp;&amp;amp; kind == SqlKind.EXISTS) {
-						fieldAccess =
-								rexBuilder.makeCall(
-										SqlStdOperatorTable.IS_NOT_NULL,
-										fieldAccess);
-					}&lt;br/&gt;
-					return fieldAccess;&lt;br/&gt;
-&lt;br/&gt;
-				case OVER:&lt;br/&gt;
-					return convertOver(this, expr);&lt;br/&gt;
-&lt;br/&gt;
-				default:&lt;br/&gt;
-					// fall through&lt;br/&gt;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			// Apply standard conversions.&lt;br/&gt;
-			rex = expr.accept(this);&lt;br/&gt;
-			return Objects.requireNonNull(rex);&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * Converts an item in an ORDER BY clause inside a window (OVER) clause,&lt;br/&gt;
-		 * extracting DESC, NULLS LAST and NULLS FIRST flags first.&lt;br/&gt;
-		 */&lt;br/&gt;
-		public RexFieldCollation convertSortExpression(SqlNode expr,&lt;br/&gt;
-		                                               RelFieldCollation.Direction direction,&lt;br/&gt;
-		                                               RelFieldCollation.NullDirection nullDirection) {&lt;br/&gt;
-			switch (expr.getKind()) {&lt;br/&gt;
-				case DESCENDING:&lt;br/&gt;
-					return convertSortExpression(((SqlCall) expr).operand(0),&lt;br/&gt;
-							RelFieldCollation.Direction.DESCENDING, nullDirection);&lt;br/&gt;
-				case NULLS_LAST:&lt;br/&gt;
-					return convertSortExpression(((SqlCall) expr).operand(0),&lt;br/&gt;
-							direction, RelFieldCollation.NullDirection.LAST);&lt;br/&gt;
-				case NULLS_FIRST:&lt;br/&gt;
-					return convertSortExpression(((SqlCall) expr).operand(0),&lt;br/&gt;
-							direction, RelFieldCollation.NullDirection.FIRST);&lt;br/&gt;
-				default:&lt;br/&gt;
-					final Set&amp;lt;SqlKind&amp;gt; flags = EnumSet.noneOf(SqlKind.class);&lt;br/&gt;
-					switch (direction) {
-						case DESCENDING:
-							flags.add(SqlKind.DESCENDING);
-					}&lt;br/&gt;
-					switch (nullDirection) {&lt;br/&gt;
-						case UNSPECIFIED:&lt;br/&gt;
-							final RelFieldCollation.NullDirection nullDefaultDirection =&lt;br/&gt;
-									validator.getDefaultNullCollation().last(desc(direction))&lt;br/&gt;
-											? RelFieldCollation.NullDirection.LAST&lt;br/&gt;
-											: RelFieldCollation.NullDirection.FIRST;&lt;br/&gt;
-							if (nullDefaultDirection != direction.defaultNullDirection()) {
-								SqlKind nullDirectionSqlKind =
-										validator.getDefaultNullCollation().last(desc(direction))
-												? SqlKind.NULLS_LAST
-												: SqlKind.NULLS_FIRST;
-								flags.add(nullDirectionSqlKind);
-							}&lt;br/&gt;
-							break;&lt;br/&gt;
-						case FIRST:&lt;br/&gt;
-							flags.add(SqlKind.NULLS_FIRST);&lt;br/&gt;
-							break;&lt;br/&gt;
-						case LAST:&lt;br/&gt;
-							flags.add(SqlKind.NULLS_LAST);&lt;br/&gt;
-							break;&lt;br/&gt;
-					}&lt;br/&gt;
-					return new RexFieldCollation(convertExpression(expr), flags);&lt;br/&gt;
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * Determines whether a RexNode corresponds to a sub-query that&apos;s been&lt;br/&gt;
-		 * converted to a constant.&lt;br/&gt;
-		 *&lt;br/&gt;
-		 * @param rex the expression to be examined&lt;br/&gt;
-		 * @return true if the expression is a dynamic parameter, a literal, or&lt;br/&gt;
-		 * a literal that is being cast&lt;br/&gt;
-		 */&lt;br/&gt;
-		private boolean isConvertedSubq(RexNode rex) {&lt;br/&gt;
-			if ((rex instanceof RexLiteral)&lt;br/&gt;
-					|| (rex instanceof RexDynamicParam)) {
-				return true;
-			}&lt;br/&gt;
-			if (rex instanceof RexCall) {&lt;br/&gt;
-				RexCall call = (RexCall) rex;&lt;br/&gt;
-				if (call.getOperator() == SqlStdOperatorTable.CAST) {&lt;br/&gt;
-					RexNode operand = call.getOperands().get(0);&lt;br/&gt;
-					if (operand instanceof RexLiteral) {
-						return true;
-					}&lt;br/&gt;
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-			return false;&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public int getGroupCount() {&lt;br/&gt;
-			if (agg != null) {
-				return agg.groupExprs.size();
-			}&lt;br/&gt;
-			if (window != null) {
-				return window.isAlwaysNonEmpty() ? 1 : 0;
-			}&lt;br/&gt;
-			return -1;&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexBuilder getRexBuilder() {
-			return rexBuilder;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexRangeRef getSubQueryExpr(SqlCall call) {
-			final SubQuery subQuery = getSubQuery(call);
-			assert subQuery != null;
-			return (RexRangeRef) subQuery.expr;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RelDataTypeFactory getTypeFactory() {
-			return typeFactory;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public InitializerExpressionFactory getInitializerExpressionFactory() {
-			return initializerExpressionFactory;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public SqlValidator getValidator() {
-			return validator;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexNode convertLiteral(SqlLiteral literal) {
-			return exprConverter.convertLiteral(this, literal);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexNode convertInterval(SqlIntervalQualifier intervalQualifier) {
-			return exprConverter.convertInterval(this, intervalQualifier);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexNode visit(SqlLiteral literal) {-			return exprConverter.convertLiteral(this, literal);-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexNode visit(SqlCall call) {&lt;br/&gt;
-			if (agg != null) {&lt;br/&gt;
-				final SqlOperator op = call.getOperator();&lt;br/&gt;
-				if (window == null&lt;br/&gt;
-						&amp;amp;&amp;amp; (op.isAggregator() || op.getKind() == SqlKind.FILTER)) {
-					return agg.lookupAggregates(call);
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-			return exprConverter.convertCall(this,&lt;br/&gt;
-					new SqlCallBinding(validator, scope, call).permutedCall());&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexNode visit(SqlNodeList nodeList) {
-			throw new UnsupportedOperationException();
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexNode visit(SqlIdentifier id) {
-			return convertIdentifier(this, id);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexNode visit(SqlDataTypeSpec type) {-			throw new UnsupportedOperationException();-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexNode visit(SqlDynamicParam param) {
-			return convertDynamicParam(param);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexNode visit(SqlIntervalQualifier intervalQualifier) {
-			return convertInterval(intervalQualifier);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public List&amp;lt;SqlMonotonicity&amp;gt; getColumnMonotonicities() {
-			return columnMonotonicities;
-		}&lt;br/&gt;
-&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	private SqlQuantifyOperator negate(SqlQuantifyOperator operator) {
-		assert operator.kind == SqlKind.ALL;
-		return SqlStdOperatorTable.some(operator.comparisonKind.negateNullSafe());
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/** Deferred lookup. */&lt;br/&gt;
-	private static class DeferredLookup {&lt;br/&gt;
-		Blackboard bb;&lt;br/&gt;
-		String originalRelName;&lt;br/&gt;
-&lt;br/&gt;
-		DeferredLookup(&lt;br/&gt;
-				Blackboard bb,&lt;br/&gt;
-				String originalRelName) {
-			this.bb = bb;
-			this.originalRelName = originalRelName;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexFieldAccess getFieldAccess(CorrelationId name) {
-			return (RexFieldAccess) bb.mapCorrelateToRex.get(name);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public String getOriginalRelName() {
-			return originalRelName;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * A default implementation of SubQueryConverter that does no conversion.&lt;br/&gt;
-	 */&lt;br/&gt;
-	private class NoOpSubQueryConverter implements SubQueryConverter {&lt;br/&gt;
-		public boolean canConvertSubQuery() {
-			return false;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public RexNode convertSubQuery(&lt;br/&gt;
-				SqlCall subQuery,&lt;br/&gt;
-				SqlToRelConverter parentConverter,&lt;br/&gt;
-				boolean isExists,&lt;br/&gt;
-				boolean isExplain) {
-			throw new IllegalArgumentException();
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Converts expressions to aggregates.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;Consider the expression&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;blockquote&amp;gt;&lt;br/&gt;
-	 * {@code SELECT deptno, SUM(2 * sal) FROM emp GROUP BY deptno}&lt;br/&gt;
-	 * &amp;lt;/blockquote&amp;gt;&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;p&amp;gt;Then:&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * &amp;lt;ul&amp;gt;&lt;br/&gt;
-	 * &amp;lt;li&amp;gt;groupExprs = {SqlIdentifier(deptno)}&amp;lt;/li&amp;gt;&lt;br/&gt;
-	 * &amp;lt;li&amp;gt;convertedInputExprs = {RexInputRef(deptno), 2 *
-	 * RefInputRef(sal)}&amp;lt;/li&amp;gt;&lt;br/&gt;
-	 * &amp;lt;li&amp;gt;inputRefs = {RefInputRef(#0), RexInputRef(#1)}&amp;lt;/li&amp;gt;&lt;br/&gt;
-	 * &amp;lt;li&amp;gt;aggCalls = {AggCall(SUM, {1})}&amp;lt;/li&amp;gt;&lt;br/&gt;
-	 * &amp;lt;/ul&amp;gt;&lt;br/&gt;
-	 */&lt;br/&gt;
-	protected class AggConverter implements SqlVisitor&amp;lt;Void&amp;gt; {&lt;br/&gt;
-		private final Blackboard bb;&lt;br/&gt;
-		public final AggregatingSelectScope aggregatingSelectScope;&lt;br/&gt;
-&lt;br/&gt;
-		private final Map&amp;lt;String, String&amp;gt; nameMap = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * The group-by expressions, in {@link SqlNode} format.&lt;br/&gt;
-		 */&lt;br/&gt;
-		private final SqlNodeList groupExprs =&lt;br/&gt;
-				new SqlNodeList(SqlParserPos.ZERO);&lt;br/&gt;
-&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * The auxiliary group-by expressions.&lt;br/&gt;
-		 */&lt;br/&gt;
-		private final Map&amp;lt;SqlNode, Ord&amp;lt;AuxiliaryConverter&amp;gt;&amp;gt; auxiliaryGroupExprs =&lt;br/&gt;
-				new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * Input expressions for the group columns and aggregates, in&lt;br/&gt;
-		 * {@link RexNode} format. The first elements of the list correspond to the&lt;br/&gt;
-		 * elements in {@link #groupExprs}; the remaining elements are for&lt;br/&gt;
-		 * aggregates. The right field of each pair is the name of the expression,&lt;br/&gt;
-		 * where the expressions are simple mappings to input fields.&lt;br/&gt;
-		 */&lt;br/&gt;
-		private final List&amp;lt;Pair&amp;lt;RexNode, String&amp;gt;&amp;gt; convertedInputExprs =&lt;br/&gt;
-				new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;br/&gt;
-		/** Expressions to be evaluated as rows are being placed into the&lt;br/&gt;
-		 * aggregate&apos;s hash table. This is when group functions such as TUMBLE&lt;br/&gt;
-		 * cause rows to be expanded. */&lt;br/&gt;
-&lt;br/&gt;
-		private final List&amp;lt;AggregateCall&amp;gt; aggCalls = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-		private final Map&amp;lt;SqlNode, RexNode&amp;gt; aggMapping = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
-		private final Map&amp;lt;AggregateCall, RexNode&amp;gt; aggCallMapping =&lt;br/&gt;
-				new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;br/&gt;
-		/** Are we directly inside a windowed aggregate? */&lt;br/&gt;
-		private boolean inOver = false;&lt;br/&gt;
-&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * Creates an AggConverter.&lt;br/&gt;
-		 *&lt;br/&gt;
-		 * &amp;lt;p&amp;gt;The &amp;lt;code&amp;gt;select&amp;lt;/code&amp;gt; parameter provides enough context to name&lt;br/&gt;
-		 * aggregate calls which are top-level select list items.&lt;br/&gt;
-		 *&lt;br/&gt;
-		 * @param bb     Blackboard&lt;br/&gt;
-		 * @param select Query being translated; provides context to give&lt;br/&gt;
-		 */&lt;br/&gt;
-		public AggConverter(Blackboard bb, SqlSelect select) {&lt;br/&gt;
-			this.bb = bb;&lt;br/&gt;
-			this.aggregatingSelectScope =&lt;br/&gt;
-					(AggregatingSelectScope) bb.getValidator().getSelectScope(select);&lt;br/&gt;
-&lt;br/&gt;
-			// Collect all expressions used in the select list so that aggregate&lt;br/&gt;
-			// calls can be named correctly.&lt;br/&gt;
-			final SqlNodeList selectList = select.getSelectList();&lt;br/&gt;
-			for (int i = 0; i &amp;lt; selectList.size(); i++) {&lt;br/&gt;
-				SqlNode selectItem = selectList.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;br/&gt;
-				String name = null;&lt;br/&gt;
-				if (SqlUtil.isCallTo(&lt;br/&gt;
-						selectItem,&lt;br/&gt;
-						SqlStdOperatorTable.AS)) {
-					final SqlCall call = (SqlCall) selectItem;
-					selectItem = call.operand(0);
-					name = call.operand(1).toString();
-				}&lt;br/&gt;
-				if (name == null) {
-					name = validator.deriveAlias(selectItem, i);
-				}&lt;br/&gt;
-				nameMap.put(selectItem.toString(), name);&lt;br/&gt;
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public int addGroupExpr(SqlNode expr) {&lt;br/&gt;
-			int ref = lookupGroupExpr(expr);&lt;br/&gt;
-			if (ref &amp;gt;= 0) {
-				return ref;
-			}&lt;br/&gt;
-			final int index = groupExprs.size();&lt;br/&gt;
-			groupExprs.add(expr);&lt;br/&gt;
-			String name = nameMap.get(expr.toString());&lt;br/&gt;
-			RexNode convExpr = bb.convertExpression(expr);&lt;br/&gt;
-			addExpr(convExpr, name);&lt;br/&gt;
-&lt;br/&gt;
-			if (expr instanceof SqlCall) {&lt;br/&gt;
-				SqlCall call = (SqlCall) expr;&lt;br/&gt;
-				for (Pair&amp;lt;SqlNode, AuxiliaryConverter&amp;gt; p&lt;br/&gt;
-						: SqlStdOperatorTable.convertGroupToAuxiliaryCalls(call)) {
-					addAuxiliaryGroupExpr(p.left, index, p.right);
-				}&lt;br/&gt;
-			}&lt;br/&gt;
-&lt;br/&gt;
-			return index;&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		void addAuxiliaryGroupExpr(SqlNode node, int index,&lt;br/&gt;
-		                           AuxiliaryConverter converter) {&lt;br/&gt;
-			for (SqlNode node2 : auxiliaryGroupExprs.keySet()) {&lt;br/&gt;
-				if (node2.equalsDeep(node, Litmus.IGNORE)) {-					return;-				}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;auxiliaryGroupExprs.put(node, Ord.of(index, converter));&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Adds an expression, deducing an appropriate name if possible.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param expr Expression&lt;/li&gt;
	&lt;li&gt;* @param name Suggested name&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private void addExpr(RexNode expr, String name) {&lt;/li&gt;
	&lt;li&gt;if ((name == null) &amp;amp;&amp;amp; (expr instanceof RexInputRef)) 
{
-				final int i = ((RexInputRef) expr).getIndex();
-				name = bb.root.getRowType().getFieldList().get(i).getName();
-			}&lt;/li&gt;
	&lt;li&gt;if (Pair.right(convertedInputExprs).contains(name)) 
{
-				// In case like &apos;SELECT ... GROUP BY x, y, x&apos;, don&apos;t add
-				// name &apos;x&apos; twice.
-				name = null;
-			}&lt;/li&gt;
	&lt;li&gt;convertedInputExprs.add(Pair.of(expr, name));&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;public Void visit(SqlIdentifier id) 
{
-			return null;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public Void visit(SqlNodeList nodeList) {&lt;br/&gt;
-			for (int i = 0; i &amp;lt; nodeList.size(); i++) {
-				nodeList.get(i).accept(this);
-			}&lt;br/&gt;
-			return null;&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public Void visit(SqlLiteral lit) {-			return null;-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public Void visit(SqlDataTypeSpec type) 
{
-			return null;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public Void visit(SqlDynamicParam param) {-			return null;-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public Void visit(SqlIntervalQualifier intervalQualifier) 
{
-			return null;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public Void visit(SqlCall call) {&lt;/li&gt;
	&lt;li&gt;switch (call.getKind()) 
{
-				case FILTER:
-					translateAgg((SqlCall) call.operand(0), call.operand(1), call);
-					return null;
-				case SELECT:
-					// rchen 2006-10-17:
-					// for now do not detect aggregates in sub-queries.
-					return null;
-			}&lt;/li&gt;
	&lt;li&gt;final boolean prevInOver = inOver;&lt;/li&gt;
	&lt;li&gt;// Ignore window aggregates and ranking functions (associated with OVER&lt;/li&gt;
	&lt;li&gt;// operator). However, do not ignore nested window aggregates.&lt;/li&gt;
	&lt;li&gt;if (call.getOperator().getKind() == SqlKind.OVER) 
{
-				// Track aggregate nesting levels only within an OVER operator.
-				List&amp;lt;SqlNode&amp;gt; operandList = call.getOperandList();
-				assert operandList.size() == 2;
-
-				// Ignore the top level window aggregates and ranking functions
-				// positioned as the first operand of a OVER operator
-				inOver = true;
-				operandList.get(0).accept(this);
-
-				// Normal translation for the second operand of a OVER operator
-				inOver = false;
-				operandList.get(1).accept(this);
-				return null;
-			}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Do not translate the top level window aggregate. Only do so for&lt;/li&gt;
	&lt;li&gt;// nested aggregates, if present&lt;/li&gt;
	&lt;li&gt;if (call.getOperator().isAggregator()) {&lt;/li&gt;
	&lt;li&gt;if (inOver) 
{
-					// Add the parent aggregate level before visiting its children
-					inOver = false;
-				}
&lt;p&gt; else &lt;/p&gt;
{
-					// We&apos;re beyond the one ignored level
-					translateAgg(call, null, call);
-					return null;
-				}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;for (SqlNode operand : call.getOperandList()) {&lt;/li&gt;
	&lt;li&gt;// Operands are occasionally null, e.g. switched CASE arg 0.&lt;/li&gt;
	&lt;li&gt;if (operand != null) 
{
-					operand.accept(this);
-				}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;// Remove the parent aggregate level after visiting its children&lt;/li&gt;
	&lt;li&gt;inOver = prevInOver;&lt;/li&gt;
	&lt;li&gt;return null;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private void translateAgg(SqlCall call, SqlNode filter, SqlCall outerCall) {&lt;/li&gt;
	&lt;li&gt;assert bb.agg == this;&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;Integer&amp;gt; args = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;int filterArg = -1;&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;RelDataType&amp;gt; argTypes =&lt;/li&gt;
	&lt;li&gt;call.getOperator() instanceof SqlCountAggFunction&lt;/li&gt;
	&lt;li&gt;? new ArrayList&amp;lt;RelDataType&amp;gt;(call.getOperandList().size())&lt;/li&gt;
	&lt;li&gt;: null;&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;// switch out of agg mode&lt;/li&gt;
	&lt;li&gt;bb.agg = null;&lt;/li&gt;
	&lt;li&gt;for (SqlNode operand : call.getOperandList()) {&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// special case for COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/star_yellow.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;:  delete the *&lt;/li&gt;
	&lt;li&gt;if (operand instanceof SqlIdentifier) {&lt;/li&gt;
	&lt;li&gt;SqlIdentifier id = (SqlIdentifier) operand;&lt;/li&gt;
	&lt;li&gt;if (id.isStar()) 
{
-							assert call.operandCount() == 1;
-							assert args.isEmpty();
-							break;
-						}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;RexNode convertedExpr = bb.convertExpression(operand);&lt;/li&gt;
	&lt;li&gt;assert convertedExpr != null;&lt;/li&gt;
	&lt;li&gt;if (argTypes != null) 
{
-						argTypes.add(convertedExpr.getType());
-					}&lt;/li&gt;
	&lt;li&gt;args.add(lookupOrCreateGroupExpr(convertedExpr));&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;if (filter != null) {&lt;/li&gt;
	&lt;li&gt;RexNode convertedExpr = bb.convertExpression(filter);&lt;/li&gt;
	&lt;li&gt;assert convertedExpr != null;&lt;/li&gt;
	&lt;li&gt;if (convertedExpr.getType().isNullable()) 
{
-						convertedExpr =
-								rexBuilder.makeCall(SqlStdOperatorTable.IS_TRUE, convertedExpr);
-					}&lt;/li&gt;
	&lt;li&gt;filterArg = lookupOrCreateGroupExpr(convertedExpr);&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;} finally 
{
-				// switch back into agg mode
-				bb.agg = this;
-			}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;SqlAggFunction aggFunction =&lt;/li&gt;
	&lt;li&gt;(SqlAggFunction) call.getOperator();&lt;/li&gt;
	&lt;li&gt;final RelDataType type = validator.deriveType(bb.scope, call);&lt;/li&gt;
	&lt;li&gt;boolean distinct = false;&lt;/li&gt;
	&lt;li&gt;SqlLiteral quantifier = call.getFunctionQuantifier();&lt;/li&gt;
	&lt;li&gt;if ((null != quantifier)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; (quantifier.getValue() == SqlSelectKeyword.DISTINCT)) 
{
-				distinct = true;
-			}&lt;/li&gt;
	&lt;li&gt;boolean approximate = false;&lt;/li&gt;
	&lt;li&gt;if (aggFunction == SqlStdOperatorTable.APPROX_COUNT_DISTINCT) 
{
-				aggFunction = SqlStdOperatorTable.COUNT;
-				distinct = true;
-				approximate = true;
-			}&lt;/li&gt;
	&lt;li&gt;final AggregateCall aggCall =&lt;/li&gt;
	&lt;li&gt;AggregateCall.create(&lt;/li&gt;
	&lt;li&gt;aggFunction,&lt;/li&gt;
	&lt;li&gt;distinct,&lt;/li&gt;
	&lt;li&gt;approximate,&lt;/li&gt;
	&lt;li&gt;args,&lt;/li&gt;
	&lt;li&gt;filterArg,&lt;/li&gt;
	&lt;li&gt;type,&lt;/li&gt;
	&lt;li&gt;nameMap.get(outerCall.toString()));&lt;/li&gt;
	&lt;li&gt;final AggregatingSelectScope.Resolved r =&lt;/li&gt;
	&lt;li&gt;aggregatingSelectScope.resolved.get();&lt;/li&gt;
	&lt;li&gt;RexNode rex =&lt;/li&gt;
	&lt;li&gt;rexBuilder.addAggCall(&lt;/li&gt;
	&lt;li&gt;aggCall,&lt;/li&gt;
	&lt;li&gt;groupExprs.size(),&lt;/li&gt;
	&lt;li&gt;false,&lt;/li&gt;
	&lt;li&gt;aggCalls,&lt;/li&gt;
	&lt;li&gt;aggCallMapping,&lt;/li&gt;
	&lt;li&gt;argTypes);&lt;/li&gt;
	&lt;li&gt;aggMapping.put(outerCall, rex);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private int lookupOrCreateGroupExpr(RexNode expr) {&lt;/li&gt;
	&lt;li&gt;int index = 0;&lt;/li&gt;
	&lt;li&gt;for (RexNode convertedInputExpr : Pair.left(convertedInputExprs)) {&lt;/li&gt;
	&lt;li&gt;if (expr.toString().equals(convertedInputExpr.toString())) 
{
-					return index;
-				}&lt;/li&gt;
	&lt;li&gt;++index;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// not found &amp;#8211; add it&lt;/li&gt;
	&lt;li&gt;addExpr(expr, null);&lt;/li&gt;
	&lt;li&gt;return index;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* If an expression is structurally identical to one of the group-by&lt;/li&gt;
	&lt;li&gt;* expressions, returns a reference to the expression, otherwise returns&lt;/li&gt;
	&lt;li&gt;* null.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public int lookupGroupExpr(SqlNode expr) {&lt;/li&gt;
	&lt;li&gt;for (int i = 0; i &amp;lt; groupExprs.size(); i++) {&lt;/li&gt;
	&lt;li&gt;SqlNode groupExpr = groupExprs.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;;&lt;/li&gt;
	&lt;li&gt;if (expr.equalsDeep(groupExpr, Litmus.IGNORE)) 
{
-					return i;
-				}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;return -1;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;public RexNode lookupAggregates(SqlCall call) {&lt;/li&gt;
	&lt;li&gt;// assert call.getOperator().isAggregator();&lt;/li&gt;
	&lt;li&gt;assert bb.agg == this;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;for (Map.Entry&amp;lt;SqlNode, Ord&amp;lt;AuxiliaryConverter&amp;gt;&amp;gt; e&lt;/li&gt;
	&lt;li&gt;: auxiliaryGroupExprs.entrySet()) {&lt;/li&gt;
	&lt;li&gt;if (call.equalsDeep(e.getKey(), Litmus.IGNORE)) 
{
-					AuxiliaryConverter converter = e.getValue().e;
-					final int groupOrdinal = e.getValue().i;
-					return converter.convert(rexBuilder,
-							convertedInputExprs.get(groupOrdinal).left,
-							rexBuilder.makeInputRef(bb.root, groupOrdinal));
-				}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;return aggMapping.get(call);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;public List&amp;lt;Pair&amp;lt;RexNode, String&amp;gt;&amp;gt; getPreExprs() 
{
-			return convertedInputExprs;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public List&amp;lt;AggregateCall&amp;gt; getAggCalls() 
{
-			return aggCalls;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public RelDataTypeFactory getTypeFactory() 
{
-			return typeFactory;
-		}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Context to find a relational expression to a field offset.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private static class LookupContext {&lt;/li&gt;
	&lt;li&gt;private final List&amp;lt;Pair&amp;lt;RelNode, Integer&amp;gt;&amp;gt; relOffsetList =&lt;/li&gt;
	&lt;li&gt;new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Creates a LookupContext with multiple input relational expressions.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param bb               Context for translating this sub-query&lt;/li&gt;
	&lt;li&gt;* @param rels             Relational expressions&lt;/li&gt;
	&lt;li&gt;* @param systemFieldCount Number of system fields&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;LookupContext(Blackboard bb, List&amp;lt;RelNode&amp;gt; rels, int systemFieldCount) {&lt;/li&gt;
	&lt;li&gt;bb.flatten(rels, systemFieldCount, new int[]
{0}
&lt;p&gt;, relOffsetList);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Returns the relational expression with a given offset, and the&lt;/li&gt;
	&lt;li&gt;* ordinal in the combined row of its first field.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;For example, in 
{@code Emp JOIN Dept}
&lt;p&gt;, findRel(1) returns the&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;* relational expression for 
{@code Dept} and offset 6 (because&lt;br/&gt;
-		 * {@code Emp} has 6 fields, therefore the first field of {@code Dept}&lt;/li&gt;
	&lt;li&gt;* is field 6.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param offset Offset of relational expression in FROM clause&lt;/li&gt;
	&lt;li&gt;* @return Relational expression and the ordinal of its first field&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;Pair&amp;lt;RelNode, Integer&amp;gt; findRel(int offset) 
{
-			return relOffsetList.get(offset);
-		}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Shuttle which walks over a tree of 
{@link RexNode}
&lt;p&gt;s and applies &apos;over&apos; to&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;* all agg functions.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;This is necessary because the returned expression is not necessarily a&lt;/li&gt;
	&lt;li&gt;* call to an agg function. For example,&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;blockquote&amp;gt;&amp;lt;code&amp;gt;AVG&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&amp;lt;/code&amp;gt;&amp;lt;/blockquote&amp;gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;becomes&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;blockquote&amp;gt;&amp;lt;code&amp;gt;SUM&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; / COUNT&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&amp;lt;/code&amp;gt;&amp;lt;/blockquote&amp;gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;Any aggregate functions are converted to calls to the internal &amp;lt;code&amp;gt;&lt;/li&gt;
	&lt;li&gt;* $Histogram&amp;lt;/code&amp;gt; aggregation function and accessors such as &amp;lt;code&amp;gt;&lt;/li&gt;
	&lt;li&gt;* $HistogramMin&amp;lt;/code&amp;gt;; for example,&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;blockquote&amp;gt;&amp;lt;code&amp;gt;MIN&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;, MAX&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&amp;lt;/code&amp;gt;&amp;lt;/blockquote&amp;gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;are converted to&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;blockquote&amp;gt;&amp;lt;code&amp;gt;$HistogramMin($Histogram&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;),&lt;/li&gt;
	&lt;li&gt;* $HistogramMax($Histogram&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;)&amp;lt;/code&amp;gt;&amp;lt;/blockquote&amp;gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;Common sub-expression elimination will ensure that only one histogram is&lt;/li&gt;
	&lt;li&gt;* computed.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;private class HistogramShuttle extends RexShuttle {&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Whether to convert calls to MIN&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; to HISTOGRAM_MIN(HISTOGRAM&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).&lt;/li&gt;
	&lt;li&gt;* Histograms allow rolling computation, but require more space.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;static final boolean ENABLE_HISTOGRAM_AGG = false;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private final List&amp;lt;RexNode&amp;gt; partitionKeys;&lt;/li&gt;
	&lt;li&gt;private final ImmutableList&amp;lt;RexFieldCollation&amp;gt; orderKeys;&lt;/li&gt;
	&lt;li&gt;private final RexWindowBound lowerBound;&lt;/li&gt;
	&lt;li&gt;private final RexWindowBound upperBound;&lt;/li&gt;
	&lt;li&gt;private final SqlWindow window;&lt;/li&gt;
	&lt;li&gt;private final boolean distinct;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;HistogramShuttle(&lt;/li&gt;
	&lt;li&gt;List&amp;lt;RexNode&amp;gt; partitionKeys,&lt;/li&gt;
	&lt;li&gt;ImmutableList&amp;lt;RexFieldCollation&amp;gt; orderKeys,&lt;/li&gt;
	&lt;li&gt;RexWindowBound lowerBound, RexWindowBound upperBound,&lt;/li&gt;
	&lt;li&gt;SqlWindow window,&lt;/li&gt;
	&lt;li&gt;boolean distinct) 
{
-			this.partitionKeys = partitionKeys;
-			this.orderKeys = orderKeys;
-			this.lowerBound = lowerBound;
-			this.upperBound = upperBound;
-			this.window = window;
-			this.distinct = distinct;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public RexNode visitCall(RexCall call) {&lt;/li&gt;
	&lt;li&gt;final SqlOperator op = call.getOperator();&lt;/li&gt;
	&lt;li&gt;if (!(op instanceof SqlAggFunction)) 
{
-				return super.visitCall(call);
-			}&lt;/li&gt;
	&lt;li&gt;final SqlAggFunction aggOp = (SqlAggFunction) op;&lt;/li&gt;
	&lt;li&gt;final RelDataType type = call.getType();&lt;/li&gt;
	&lt;li&gt;List&amp;lt;RexNode&amp;gt; exprs = call.getOperands();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;SqlFunction histogramOp = !ENABLE_HISTOGRAM_AGG&lt;/li&gt;
	&lt;li&gt;? null&lt;/li&gt;
	&lt;li&gt;: getHistogramOp(aggOp);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;if (histogramOp != null) {&lt;/li&gt;
	&lt;li&gt;final RelDataType histogramType = computeHistogramType(type);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// For DECIMAL, since it&apos;s already represented as a bigint we&lt;/li&gt;
	&lt;li&gt;// want to do a reinterpretCast instead of a cast to avoid&lt;/li&gt;
	&lt;li&gt;// losing any precision.&lt;/li&gt;
	&lt;li&gt;boolean reinterpretCast =&lt;/li&gt;
	&lt;li&gt;type.getSqlTypeName() == SqlTypeName.DECIMAL;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Replace original expression with CAST of not one&lt;/li&gt;
	&lt;li&gt;// of the supported types&lt;/li&gt;
	&lt;li&gt;if (histogramType != type) 
{
-					exprs = new ArrayList&amp;lt;&amp;gt;(exprs);
-					exprs.set(
-							0,
-							reinterpretCast
-									? rexBuilder.makeReinterpretCast(histogramType, exprs.get(0),
-									rexBuilder.makeLiteral(false))
-									: rexBuilder.makeCast(histogramType, exprs.get(0)));
-				}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;RexCallBinding bind =&lt;/li&gt;
	&lt;li&gt;new RexCallBinding(&lt;/li&gt;
	&lt;li&gt;rexBuilder.getTypeFactory(),&lt;/li&gt;
	&lt;li&gt;SqlStdOperatorTable.HISTOGRAM_AGG,&lt;/li&gt;
	&lt;li&gt;exprs,&lt;/li&gt;
	&lt;li&gt;ImmutableList.of());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;RexNode over =&lt;/li&gt;
	&lt;li&gt;rexBuilder.makeOver(&lt;/li&gt;
	&lt;li&gt;SqlStdOperatorTable.HISTOGRAM_AGG&lt;/li&gt;
	&lt;li&gt;.inferReturnType(bind),&lt;/li&gt;
	&lt;li&gt;SqlStdOperatorTable.HISTOGRAM_AGG,&lt;/li&gt;
	&lt;li&gt;exprs,&lt;/li&gt;
	&lt;li&gt;partitionKeys,&lt;/li&gt;
	&lt;li&gt;orderKeys,&lt;/li&gt;
	&lt;li&gt;lowerBound,&lt;/li&gt;
	&lt;li&gt;upperBound,&lt;/li&gt;
	&lt;li&gt;window.isRows(),&lt;/li&gt;
	&lt;li&gt;window.isAllowPartial(),&lt;/li&gt;
	&lt;li&gt;false,&lt;/li&gt;
	&lt;li&gt;distinct);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;RexNode histogramCall =&lt;/li&gt;
	&lt;li&gt;rexBuilder.makeCall(&lt;/li&gt;
	&lt;li&gt;histogramType,&lt;/li&gt;
	&lt;li&gt;histogramOp,&lt;/li&gt;
	&lt;li&gt;ImmutableList.of(over));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// If needed, post Cast result back to original&lt;/li&gt;
	&lt;li&gt;// type.&lt;/li&gt;
	&lt;li&gt;if (histogramType != type) {&lt;/li&gt;
	&lt;li&gt;if (reinterpretCast) 
{
-						histogramCall =
-								rexBuilder.makeReinterpretCast(
-										type,
-										histogramCall,
-										rexBuilder.makeLiteral(false));
-					}
&lt;p&gt; else &lt;/p&gt;
{
-						histogramCall =
-								rexBuilder.makeCast(type, histogramCall);
-					}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;return histogramCall;&lt;/li&gt;
	&lt;li&gt;} else 
{
-				boolean needSum0 = aggOp == SqlStdOperatorTable.SUM
-						&amp;amp;&amp;amp; type.isNullable();
-				SqlAggFunction aggOpToUse =
-						needSum0 ? SqlStdOperatorTable.SUM0
-								: aggOp;
-				return rexBuilder.makeOver(
-						type,
-						aggOpToUse,
-						exprs,
-						partitionKeys,
-						orderKeys,
-						lowerBound,
-						upperBound,
-						window.isRows(),
-						window.isAllowPartial(),
-						needSum0,
-						distinct);
-			}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Returns the histogram operator corresponding to a given aggregate&lt;/li&gt;
	&lt;li&gt;* function.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* &amp;lt;p&amp;gt;For example, &amp;lt;code&amp;gt;getHistogramOp&lt;/li&gt;
	&lt;li&gt;*({@link SqlStdOperatorTable#MIN}}&amp;lt;/code&amp;gt; returns&lt;/li&gt;
	&lt;li&gt;* 
{@link SqlStdOperatorTable#HISTOGRAM_MIN}
&lt;p&gt;.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param aggFunction An aggregate function&lt;/li&gt;
	&lt;li&gt;* @return Its histogram function, or null&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;SqlFunction getHistogramOp(SqlAggFunction aggFunction) {&lt;/li&gt;
	&lt;li&gt;if (aggFunction == SqlStdOperatorTable.MIN) 
{
-				return SqlStdOperatorTable.HISTOGRAM_MIN;
-			}
&lt;p&gt; else if (aggFunction == SqlStdOperatorTable.MAX) &lt;/p&gt;
{
-				return SqlStdOperatorTable.HISTOGRAM_MAX;
-			}
&lt;p&gt; else if (aggFunction == SqlStdOperatorTable.FIRST_VALUE) &lt;/p&gt;
{
-				return SqlStdOperatorTable.HISTOGRAM_FIRST_VALUE;
-			}
&lt;p&gt; else if (aggFunction == SqlStdOperatorTable.LAST_VALUE) &lt;/p&gt;
{
-				return SqlStdOperatorTable.HISTOGRAM_LAST_VALUE;
-			}
&lt;p&gt; else &lt;/p&gt;
{
-				return null;
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		/**&lt;br/&gt;
-		 * Returns the type for a histogram function. It is either the actual&lt;br/&gt;
-		 * type or an an approximation to it.&lt;br/&gt;
-		 */&lt;br/&gt;
-		private RelDataType computeHistogramType(RelDataType type) {&lt;br/&gt;
-			if (SqlTypeUtil.isExactNumeric(type)&lt;br/&gt;
-					&amp;amp;&amp;amp; type.getSqlTypeName() != SqlTypeName.BIGINT) {
-				return typeFactory.createSqlType(SqlTypeName.BIGINT);
-			} else if (SqlTypeUtil.isApproximateNumeric(type)&lt;br/&gt;
-					&amp;amp;&amp;amp; type.getSqlTypeName() != SqlTypeName.DOUBLE) {
-				return typeFactory.createSqlType(SqlTypeName.DOUBLE);
-			} else {
-				return type;
-			}&lt;br/&gt;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/** A sub-query, whether it needs to be translated using 2- or 3-valued&lt;br/&gt;
-	 * logic. */&lt;br/&gt;
-	private static class SubQuery {&lt;br/&gt;
-		final SqlNode node;&lt;br/&gt;
-		final RelOptUtil.Logic logic;&lt;br/&gt;
-		RexNode expr;&lt;br/&gt;
-&lt;br/&gt;
-		private SubQuery(SqlNode node, RelOptUtil.Logic logic) {
-			this.node = node;
-			this.logic = logic;
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Visitor that collects all aggregate functions in a {@link SqlNode} tree.&lt;br/&gt;
-	 */&lt;br/&gt;
-	private static class AggregateFinder extends SqlBasicVisitor&amp;lt;Void&amp;gt; {&lt;br/&gt;
-		final SqlNodeList list = new SqlNodeList(SqlParserPos.ZERO);&lt;br/&gt;
-		final SqlNodeList filterList = new SqlNodeList(SqlParserPos.ZERO);&lt;br/&gt;
-&lt;br/&gt;
-		@Override public Void visit(SqlCall call) {&lt;br/&gt;
-			// ignore window aggregates and ranking functions (associated with OVER operator)&lt;br/&gt;
-			if (call.getOperator().getKind() == SqlKind.OVER) {-				return null;-			}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;if (call.getOperator().getKind() == SqlKind.FILTER) 
{
-				// the WHERE in a FILTER must be tracked too so we can call replaceSubQueries on it.
-				// see https://issues.apache.org/jira/browse/CALCITE-1910
-				final SqlNode aggCall = call.getOperandList().get(0);
-				final SqlNode whereCall = call.getOperandList().get(1);
-				list.add(aggCall);
-				filterList.add(whereCall);
-				return null;
-			}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;if (call.getOperator().isAggregator()) 
{
-				list.add(call);
-				return null;
-			}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Don&apos;t traverse into sub-queries, even if they contain aggregate&lt;/li&gt;
	&lt;li&gt;// functions.&lt;/li&gt;
	&lt;li&gt;if (call instanceof SqlSelect) 
{
-				return null;
-			}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;return call.getOperator().acceptCall(this, call);&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/** Use of a row as a correlating variable by a given relational&lt;/li&gt;
	&lt;li&gt;* expression. */&lt;/li&gt;
	&lt;li&gt;private static class CorrelationUse {&lt;/li&gt;
	&lt;li&gt;private final CorrelationId id;&lt;/li&gt;
	&lt;li&gt;private final ImmutableBitSet requiredColumns;&lt;/li&gt;
	&lt;li&gt;/** The relational expression that uses the variable. */&lt;/li&gt;
	&lt;li&gt;private final RelNode r;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;CorrelationUse(CorrelationId id, ImmutableBitSet requiredColumns,&lt;/li&gt;
	&lt;li&gt;RelNode r) 
{
-			this.id = id;
-			this.requiredColumns = requiredColumns;
-			this.r = r;
-		}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/** Creates a builder for a 
{@link Config}. */&lt;br/&gt;
-	public static ConfigBuilder configBuilder() {
-		return new ConfigBuilder();
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/**&lt;br/&gt;
-	 * Interface to define the configuration for a SqlToRelConverter.&lt;br/&gt;
-	 * Provides methods to set each configuration option.&lt;br/&gt;
-	 *&lt;br/&gt;
-	 * @see ConfigBuilder&lt;br/&gt;
-	 * @see SqlToRelConverter#configBuilder()&lt;br/&gt;
-	 */&lt;br/&gt;
-	public interface Config {&lt;br/&gt;
-		/** Default configuration. */&lt;br/&gt;
-		Config DEFAULT = configBuilder().build();&lt;br/&gt;
-&lt;br/&gt;
-		/** Returns the {@code convertTableAccess} option. Controls whether table&lt;br/&gt;
-		 * access references are converted to physical rels immediately. The&lt;br/&gt;
-		 * optimizer doesn&apos;t like leaf rels to have {@link Convention#NONE}.&lt;br/&gt;
-		 * However, if we are doing further conversion passes (e.g.&lt;br/&gt;
-		 * {@link RelStructuredTypeFlattener}), then we may need to defer&lt;br/&gt;
-		 * conversion. */&lt;br/&gt;
-		boolean isConvertTableAccess();&lt;br/&gt;
-&lt;br/&gt;
-		/** Returns the {@code decorrelationEnabled} option. Controls whether to&lt;br/&gt;
-		 * disable sub-query decorrelation when needed. e.g. if outer joins are not&lt;br/&gt;
-		 * supported. */&lt;br/&gt;
-		boolean isDecorrelationEnabled();&lt;br/&gt;
-&lt;br/&gt;
-		/** Returns the {@code trimUnusedFields} option. Controls whether to trim&lt;br/&gt;
-		 * unused fields as part of the conversion process. */&lt;br/&gt;
-		boolean isTrimUnusedFields();&lt;br/&gt;
-&lt;br/&gt;
-		/** Returns the {@code createValuesRel} option. Controls whether instances&lt;br/&gt;
-		 * of {@link org.apache.calcite.rel.logical.LogicalValues} are generated.&lt;br/&gt;
-		 * These may not be supported by all physical implementations. */&lt;br/&gt;
-		boolean isCreateValuesRel();&lt;br/&gt;
-&lt;br/&gt;
-		/** Returns the {@code explain} option. Describes whether the current&lt;br/&gt;
-		 * statement is part of an EXPLAIN PLAN statement. */&lt;br/&gt;
-		boolean isExplain();&lt;br/&gt;
-&lt;br/&gt;
-		/** Returns the {@code expand} option. Controls whether to expand&lt;br/&gt;
-		 * sub-queries. If false, each sub-query becomes a&lt;br/&gt;
-		 * {@link org.apache.calcite.rex.RexSubQuery}. */&lt;br/&gt;
-		boolean isExpand();&lt;br/&gt;
-&lt;br/&gt;
-		/** Returns the {@code inSubQueryThreshold} option,&lt;br/&gt;
-		 * default {@link #DEFAULT_IN_SUB_QUERY_THRESHOLD}. Controls the list size&lt;br/&gt;
-		 * threshold under which {@link #convertInToOr} is used. Lists of this size&lt;br/&gt;
-		 * or greater will instead be converted to use a join against an inline&lt;br/&gt;
-		 * table ({@link org.apache.calcite.rel.logical.LogicalValues}) rather than&lt;br/&gt;
-		 * a predicate. A threshold of 0 forces usage of an inline table in all&lt;br/&gt;
-		 * cases; a threshold of {@link Integer#MAX_VALUE} forces usage of OR in all&lt;br/&gt;
-		 * cases. */&lt;br/&gt;
-		int getInSubQueryThreshold();&lt;br/&gt;
-&lt;br/&gt;
-		/** Returns the factory to create {@link RelBuilder}, never null. Default is&lt;br/&gt;
-		 * {@link RelFactories#LOGICAL_BUILDER}. */&lt;br/&gt;
-		RelBuilderFactory getRelBuilderFactory();&lt;br/&gt;
-	}&lt;br/&gt;
-&lt;br/&gt;
-	/** Builder for a {@link Config}
&lt;p&gt;. */&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public static class ConfigBuilder {&lt;/li&gt;
	&lt;li&gt;private boolean convertTableAccess = true;&lt;/li&gt;
	&lt;li&gt;private boolean decorrelationEnabled = true;&lt;/li&gt;
	&lt;li&gt;private boolean trimUnusedFields = false;&lt;/li&gt;
	&lt;li&gt;private boolean createValuesRel = true;&lt;/li&gt;
	&lt;li&gt;private boolean explain;&lt;/li&gt;
	&lt;li&gt;private boolean expand = true;&lt;/li&gt;
	&lt;li&gt;private int inSubQueryThreshold = DEFAULT_IN_SUB_QUERY_THRESHOLD;&lt;/li&gt;
	&lt;li&gt;private RelBuilderFactory relBuilderFactory = RelFactories.LOGICAL_BUILDER;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private ConfigBuilder() {}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/** Sets configuration identical to a given 
{@link Config}. */&lt;br/&gt;
-		public ConfigBuilder withConfig(Config config) {
-			this.convertTableAccess = config.isConvertTableAccess();
-			this.decorrelationEnabled = config.isDecorrelationEnabled();
-			this.trimUnusedFields = config.isTrimUnusedFields();
-			this.createValuesRel = config.isCreateValuesRel();
-			this.explain = config.isExplain();
-			this.expand = config.isExpand();
-			this.inSubQueryThreshold = config.getInSubQueryThreshold();
-			this.relBuilderFactory = config.getRelBuilderFactory();
-			return this;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public ConfigBuilder withConvertTableAccess(boolean convertTableAccess) {
-			this.convertTableAccess = convertTableAccess;
-			return this;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public ConfigBuilder withDecorrelationEnabled(boolean enabled) {
-			this.decorrelationEnabled = enabled;
-			return this;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public ConfigBuilder withTrimUnusedFields(boolean trimUnusedFields) {
-			this.trimUnusedFields = trimUnusedFields;
-			return this;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public ConfigBuilder withCreateValuesRel(boolean createValuesRel) {
-			this.createValuesRel = createValuesRel;
-			return this;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public ConfigBuilder withExplain(boolean explain) {
-			this.explain = explain;
-			return this;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public ConfigBuilder withExpand(boolean expand) {
-			this.expand = expand;
-			return this;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		@Deprecated // to be removed before 2.0&lt;br/&gt;
-		public ConfigBuilder withInSubqueryThreshold(int inSubQueryThreshold) {
-			return withInSubQueryThreshold(inSubQueryThreshold);
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public ConfigBuilder withInSubQueryThreshold(int inSubQueryThreshold) {
-			this.inSubQueryThreshold = inSubQueryThreshold;
-			return this;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		public ConfigBuilder withRelBuilderFactory(&lt;br/&gt;
-				RelBuilderFactory relBuilderFactory) {
-			this.relBuilderFactory = relBuilderFactory;
-			return this;
-		}&lt;br/&gt;
-&lt;br/&gt;
-		/** Builds a {@link Config}
&lt;p&gt;. */&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public Config build() 
{
-			return new ConfigImpl(convertTableAccess, decorrelationEnabled,
-					trimUnusedFields, createValuesRel, explain, expand,
-					inSubQueryThreshold, relBuilderFactory);
-		}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/** Implementation of 
{@link Config}
&lt;p&gt;.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;* Called by builder; all values are in private final fields. */&lt;/li&gt;
	&lt;li&gt;private static class ConfigImpl implements Config {&lt;/li&gt;
	&lt;li&gt;private final boolean convertTableAccess;&lt;/li&gt;
	&lt;li&gt;private final boolean decorrelationEnabled;&lt;/li&gt;
	&lt;li&gt;private final boolean trimUnusedFields;&lt;/li&gt;
	&lt;li&gt;private final boolean createValuesRel;&lt;/li&gt;
	&lt;li&gt;private final boolean explain;&lt;/li&gt;
	&lt;li&gt;private final boolean expand;&lt;/li&gt;
	&lt;li&gt;private final int inSubQueryThreshold;&lt;/li&gt;
	&lt;li&gt;private final RelBuilderFactory relBuilderFactory;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private ConfigImpl(boolean convertTableAccess, boolean decorrelationEnabled,&lt;/li&gt;
	&lt;li&gt;boolean trimUnusedFields, boolean createValuesRel, boolean explain,&lt;/li&gt;
	&lt;li&gt;boolean expand, int inSubQueryThreshold,&lt;/li&gt;
	&lt;li&gt;RelBuilderFactory relBuilderFactory) 
{
-			this.convertTableAccess = convertTableAccess;
-			this.decorrelationEnabled = decorrelationEnabled;
-			this.trimUnusedFields = trimUnusedFields;
-			this.createValuesRel = createValuesRel;
-			this.explain = explain;
-			this.expand = expand;
-			this.inSubQueryThreshold = inSubQueryThreshold;
-			this.relBuilderFactory = relBuilderFactory;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public boolean isConvertTableAccess() 
{
-			return convertTableAccess;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public boolean isDecorrelationEnabled() 
{
-			return decorrelationEnabled;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public boolean isTrimUnusedFields() 
{
-			return trimUnusedFields;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public boolean isCreateValuesRel() 
{
-			return createValuesRel;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public boolean isExplain() 
{
-			return explain;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public boolean isExpand() 
{
-			return expand;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public int getInSubQueryThreshold() 
{
-			return inSubQueryThreshold;
-		}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public RelBuilderFactory getRelBuilderFactory() 
{
-			return relBuilderFactory;
-		}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-}&lt;br/&gt;
-&lt;br/&gt;
-// End SqlToRelConverter.java&lt;br/&gt;
diff --git a/flink-libraries/flink-table/src/main/scala/org/apache/flink/table/plan/rules/logical/LogicalUnnestRule.scala b/flink-libraries/flink-table/src/main/scala/org/apache/flink/table/plan/rules/logical/LogicalUnnestRule.scala&lt;br/&gt;
index 8ef9fd3f136..f985a806f48 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-libraries/flink-table/src/main/scala/org/apache/flink/table/plan/rules/logical/LogicalUnnestRule.scala&lt;br/&gt;
+++ b/flink-libraries/flink-table/src/main/scala/org/apache/flink/table/plan/rules/logical/LogicalUnnestRule.scala&lt;br/&gt;
@@ -50,8 +50,16 @@ class LogicalUnnestRule(&lt;br/&gt;
       case filter: LogicalFilter =&amp;gt;&lt;br/&gt;
         filter.getInput.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;RelSubset&amp;#93;&lt;/span&gt;.getOriginal match 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {           case u}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+      case p: LogicalProject =&amp;gt; p.getInput.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;RelSubset&amp;#93;&lt;/span&gt;.getOriginal match &lt;/p&gt;
{
+        case u: Uncollect =&amp;gt; !u.withOrdinality
+        case _ =&amp;gt; false
+      }
&lt;p&gt;       case u: Uncollect =&amp;gt; !u.withOrdinality&lt;br/&gt;
       case _ =&amp;gt; false&lt;br/&gt;
     }&lt;br/&gt;
@@ -68,6 +76,11 @@ class LogicalUnnestRule(&lt;br/&gt;
         case rs: RelSubset =&amp;gt;&lt;br/&gt;
           convert(rs.getRelList.get(0))&lt;/p&gt;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+        case p: LogicalProject =&amp;gt;&lt;br/&gt;
+          p.copy(&lt;br/&gt;
+            p.getTraitSet,&lt;br/&gt;
+            ImmutableList.of(convert(p.getInput.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;RelSubset&amp;#93;&lt;/span&gt;.getOriginal)))&lt;br/&gt;
+&lt;br/&gt;
         case f: LogicalFilter =&amp;gt;&lt;br/&gt;
           f.copy(&lt;br/&gt;
             f.getTraitSet,&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16588087" author="fhueske" created="Tue, 21 Aug 2018 22:26:36 +0000"  >&lt;p&gt;Fixed for 1.7.0 with d8c45fa709e7c2ec7f187c81319762a83dd2d1c4&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 12 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3x8y7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>