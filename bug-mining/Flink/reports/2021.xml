<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:30:37 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-6563] Expose time indicator attributes in the KafkaTableSource</title>
                <link>https://issues.apache.org/jira/browse/FLINK-6563</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;This is a follow up for &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5884&quot; title=&quot;Integrate time indicators for Table API &amp;amp; SQL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5884&quot;&gt;&lt;del&gt;FLINK-5884&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5884&quot; title=&quot;Integrate time indicators for Table API &amp;amp; SQL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5884&quot;&gt;&lt;del&gt;FLINK-5884&lt;/del&gt;&lt;/a&gt; requires the &lt;tt&gt;TableSource&lt;/tt&gt; interfaces to expose the processing time and the event time for the data stream. This jira proposes to expose these two information in the Kafka table source.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13071373">FLINK-6563</key>
            <summary>Expose time indicator attributes in the KafkaTableSource</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="10">Implemented</resolution>
                                        <assignee username="fhueske">Fabian Hueske</assignee>
                                    <reporter username="wheat9">Haohui Mai</reporter>
                        <labels>
                    </labels>
                <created>Thu, 11 May 2017 22:46:35 +0000</created>
                <updated>Wed, 1 Nov 2017 07:21:23 +0000</updated>
                            <resolved>Wed, 1 Nov 2017 07:21:23 +0000</resolved>
                                                    <fixVersion>1.4.0</fixVersion>
                                    <component>Table SQL / API</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="16007997" author="fhueske" created="Fri, 12 May 2017 11:44:02 +0000"  >&lt;p&gt;Actually, the missing &lt;tt&gt;DefinedProctimeAttribute&lt;/tt&gt; and &lt;tt&gt;DefinedRowtimeAttribute&lt;/tt&gt; interfaces are not the only issue. &lt;br/&gt;
We also need to extend the KafkaTableSource to accept a TimestampAssigner.&lt;/p&gt;</comment>
                            <comment id="16152674" author="fhueske" created="Mon, 4 Sep 2017 14:44:29 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=wheat9&quot; class=&quot;user-hover&quot; rel=&quot;wheat9&quot;&gt;wheat9&lt;/a&gt;, I addressed this issue but did not check for an existing JIRA issue. I hope you haven&apos;t started to work on this yet.&lt;br/&gt;
I&apos;ll open a PR and would appreciate your review.&lt;/p&gt;

&lt;p&gt;This will be a temporary solution until we addressed &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7446&quot; title=&quot;Support to define an existing field as the rowtime field for TableSource&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7446&quot;&gt;&lt;del&gt;FLINK-7446&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7548&quot; title=&quot;Support watermark generation for TableSource&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7548&quot;&gt;&lt;del&gt;FLINK-7548&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
We also need to resolve &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7571&quot; title=&quot;Execution of TableSources with Time Indicators fails&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7571&quot;&gt;&lt;del&gt;FLINK-7571&lt;/del&gt;&lt;/a&gt; (I opened a PR a for this one last week).&lt;/p&gt;

&lt;p&gt;Thanks, Fabian&lt;/p&gt;</comment>
                            <comment id="16152696" author="githubbot" created="Mon, 4 Sep 2017 15:06:25 +0000"  >&lt;p&gt;GitHub user fhueske opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6563&quot; title=&quot;Expose time indicator attributes in the KafkaTableSource&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-6563&quot;&gt;&lt;del&gt;FLINK-6563&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;table&amp;#93;&lt;/span&gt; Add time indicator support to KafkaTableSource.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    Add support for time indicators (processing time, ingestion time, event time) for Kafka table sources that extend `KafkaTableSource`.&lt;/p&gt;

&lt;p&gt;    The PR adds the following methods:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;`addProcTimeAttribute(String proctime)`: adds a processing time attribute to the table&lt;/li&gt;
	&lt;li&gt;`addIngestionTimeAttribute(String ingestionTime)`: adds an ingestion time attribute to the table&lt;/li&gt;
	&lt;li&gt;`setAscendingRowTimeAttribute(String rowtime)`: sets an existing attribute to be the row time attribute and automatically assigns watermarks for monotonically increasing attributes.&lt;/li&gt;
	&lt;li&gt;`setBoundedOutOfOrderRowtimeAttribute(String rowtime, long watermarkDelay)`: sets an existing attribute to be the row time attribute and automatically assigns watermarks with a specified fixed delay.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    So, event-time is currently only supported for ascending timestamps and timestamps which are out-of-order by a fixed delay.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;`KafkaTableSource` implements `DefinedProcTimeAttribute` and `DefinedRowTimeAttribute` interfaces.&lt;/li&gt;
	&lt;li&gt;Added methods to set different time attributes.&lt;/li&gt;
	&lt;li&gt;Added tests to validate the time attribute methods.&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;added `KafkaTableSource` test.&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The serializers: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? *&lt;b&gt;yes&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? *&lt;b&gt;NOT YET&lt;/b&gt;*&lt;/li&gt;
&lt;/ul&gt;




&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/fhueske/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/fhueske/flink&lt;/a&gt; tableKafkaTime&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4638&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit ba6385b1f8c546221c716e44e2d8f9a9fac5a05a&lt;br/&gt;
Author: Fabian Hueske &amp;lt;fhueske@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-08-31T12:35:41Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6563&quot; title=&quot;Expose time indicator attributes in the KafkaTableSource&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-6563&quot;&gt;&lt;del&gt;FLINK-6563&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;table&amp;#93;&lt;/span&gt; Add time indicator support to KafkaTableSource.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16154348" author="wheat9" created="Tue, 5 Sep 2017 21:29:25 +0000"  >&lt;p&gt;Thanks for the PR. I&apos;ll take a look at the PR later today.&lt;/p&gt;</comment>
                            <comment id="16157798" author="githubbot" created="Thu, 7 Sep 2017 22:42:19 +0000"  >&lt;p&gt;Github user haohui commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r137671151&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r137671151&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I&apos;m wondering why we need to remove the field here and add it back later on. Changing the orders of the fields seems problematic and can potentially break serialization (in very hacky cases).&lt;/p&gt;

&lt;p&gt;    Another question is that to which extent a customized timestamp assigner can reuse the code here? Is it possible to implement it as a decorator of the table source? That way it opens up the possibilities to reuse the code for other table sources.&lt;/p&gt;</comment>
                            <comment id="16158303" author="githubbot" created="Fri, 8 Sep 2017 08:35:00 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r137737055&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r137737055&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Yes, it&apos;s not very nice to move the time attribute into the `StreamRecord`, remove the `Row` field, and copy the `StreamRecord` timestamp back into the `Row`. That&apos;s just how the current interface is designed. However, this will be changed with &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7446&quot; title=&quot;Support to define an existing field as the rowtime field for TableSource&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7446&quot;&gt;&lt;del&gt;FLINK-7446&lt;/del&gt;&lt;/a&gt;(&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7446&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-7446&lt;/a&gt;). &lt;/p&gt;

&lt;p&gt;    The issue of watermark generation (timestamps don&apos;t need to be generated as they are already expected to be in the `Row`) will be addressed by &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7548&quot; title=&quot;Support watermark generation for TableSource&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7548&quot;&gt;&lt;del&gt;FLINK-7548&lt;/del&gt;&lt;/a&gt;(&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7548&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-7548&lt;/a&gt;). &lt;/p&gt;

&lt;p&gt;    We have to see how much of &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7446&quot; title=&quot;Support to define an existing field as the rowtime field for TableSource&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7446&quot;&gt;&lt;del&gt;FLINK-7446&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7548&quot; title=&quot;Support watermark generation for TableSource&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7548&quot;&gt;&lt;del&gt;FLINK-7548&lt;/del&gt;&lt;/a&gt; we can solve before Flink 1.4.0. I did this PR to have at least some time attribute support for KafkaTableSources in 1.4.0. Do you need more specialized watermark generators for your use case?&lt;/p&gt;</comment>
                            <comment id="16159598" author="githubbot" created="Sat, 9 Sep 2017 00:39:33 +0000"  >&lt;p&gt;Github user haohui commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r137913506&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r137913506&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    What about accelerating the efforts on &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7446&quot; title=&quot;Support to define an existing field as the rowtime field for TableSource&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7446&quot;&gt;&lt;del&gt;FLINK-7446&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7548&quot; title=&quot;Support watermark generation for TableSource&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7548&quot;&gt;&lt;del&gt;FLINK-7548&lt;/del&gt;&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;    Unfortunately our use cases are a little bit more than that thus this PR will not solve the problem out of the box. In one use case we have a timestamp that is a `double` instead of a `bigint`, in another use case we have the timestamp sit in a nested structure. That&apos;s the reason why I&apos;m more inclined for a decorator-based approach which is more easy to customize.&lt;/p&gt;
</comment>
                            <comment id="16160060" author="githubbot" created="Sat, 9 Sep 2017 19:38:20 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r137933653&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r137933653&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I think you are right. We should not ask each `TableSource` to assign watermarks. &lt;/p&gt;

&lt;p&gt;    A decorator approach, i.e., a watermark generation wrapper around a `TableSource` would be one option. Alternatively, we could also give the responsibility for watermark generation to the scan operator. All the `TableSource` would need to provide is the name of the field for which watermarks are generated and the watermark strategy ascending, bounded, or custom). The generation would be handled completely internally. At that point, we can also access all fields of any type (Row, Pojo, Tuple, ...), nested or flat, via code generation. So, we would need to extend or replace the `DefinedRowtimeAttribute` interface because we need information about the watermark strategy (ascending, bounded, or custom). What do you think @haohui?&lt;/p&gt;

&lt;p&gt;    I already started to work on &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7446&quot; title=&quot;Support to define an existing field as the rowtime field for TableSource&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7446&quot;&gt;&lt;del&gt;FLINK-7446&lt;/del&gt;&lt;/a&gt; but will also not too much time in the next weeks due to conferences. I hope that we can address these issues with the next release.&lt;/p&gt;</comment>
                            <comment id="16170641" author="githubbot" created="Mon, 18 Sep 2017 20:32:34 +0000"  >&lt;p&gt;Github user haohui commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r139532226&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r139532226&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Currently in our internal system we worked around this problem by decorating the data stream return by Kafka. Having the scan operator to assign the watermark seems pretty neat. +1 for that.&lt;/p&gt;

&lt;p&gt;    It might be cleaner to put both the assignment of the timestamp (i.e., `TimestampAssigner`) and the naming of the timestamp (i.e., `DefinedRowtimeAttribute` and `DefinedProctimeAttribute`) together.&lt;/p&gt;

&lt;p&gt;    What do you think?&lt;/p&gt;
</comment>
                            <comment id="16170660" author="githubbot" created="Mon, 18 Sep 2017 20:42:08 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r139534525&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r139534525&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Thanks for the response!&lt;/p&gt;

&lt;p&gt;    I would not merge `DefinedProctimeAttribute` and `DefinedProctimeAttribute` into a single interface. Both are for different types of timestamps (processing time and event time):&lt;/p&gt;

&lt;p&gt;    The idea is to have two interfaces:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;`DefinedProctimeAttribute` adds a timestamp attribute for processing time operations. The interface specifies the name of the new attribute. The source will simply add a virtual attribute, that fetches the current time when it is accessed.&lt;/li&gt;
	&lt;li&gt;`DefinedRowtimeAttribute` (or its successor) specifies an existing attribute (via its name) to be an event time attribute and provides a watermark strategy (ascending, bounded-ooo, custom). If a `TableSource` specifies the interface, the scan will generate watermarks based on the existing field and the watermark strategy. During registration, we check that the field exists and has the right type. So instead of adding a field, we simply ensure that we have watermarks for it and change its type to be a time indicator field.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    In this design, we `DefinedRowtimeAttribute` specifies the field and the watermark strategy as you proposed.&lt;/p&gt;</comment>
                            <comment id="16170804" author="githubbot" created="Mon, 18 Sep 2017 22:12:07 +0000"  >&lt;p&gt;Github user haohui commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r139553991&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r139553991&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Sorry for not stating it more clear. I was proposing having a tighter connection between `TimestampAssigner` and `DefinedProctimeAttribute`/ `DefinedRowtimeAttribute`, but not merging `DefinedProctimeAttribute`/ `DefinedRowtimeAttribute`.&lt;/p&gt;

&lt;p&gt;    In our use cases it is not enough to just have a trivial implementation of `TimeStampAssigner` to extract rowtime. We need to convert the corresponding field from `double` to `bigint`. It would be great if we can do it a little bit cleaner.&lt;/p&gt;
</comment>
                            <comment id="16171292" author="githubbot" created="Tue, 19 Sep 2017 08:19:11 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r139625081&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r139625081&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Thanks for the clarification @haohui. &lt;/p&gt;

&lt;p&gt;    Would be sufficient to apply default casting logic to the timestamp field, i.e., cast numeric fields to `bigint` or do you need custom conversion logic (evaluate a custom expression, possibly involving scalar UDFs)? &lt;/p&gt;</comment>
                            <comment id="16171297" author="githubbot" created="Tue, 19 Sep 2017 08:21:42 +0000"  >&lt;p&gt;Github user haohui commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r139625581&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r139625581&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Unfortunately we do need customer logics &amp;#8211; other people might need them too to take care issues like time zone differences.&lt;/p&gt;</comment>
                            <comment id="16171309" author="githubbot" created="Tue, 19 Sep 2017 08:32:19 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r139627915&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r139627915&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I assume you also need access to the full row, correct?&lt;/p&gt;</comment>
                            <comment id="16171319" author="githubbot" created="Tue, 19 Sep 2017 08:41:33 +0000"  >&lt;p&gt;Github user haohui commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r139629938&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r139629938&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    As of today the answer is no &amp;#8211; we only need a single, top-level field. There might be use cases that have the rowtime in the nested fields. `TimestampAssigner` does come handy as the flexibility is quite important to us.&lt;/p&gt;

&lt;p&gt;    Maybe it makes sense to provide some default implementation of `TimestampAssigner` to extract a field in the row in order to make it easier to use?&lt;/p&gt;

</comment>
                            <comment id="16171338" author="githubbot" created="Tue, 19 Sep 2017 08:50:46 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r139632155&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r139632155&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I see. Let&apos;s collect the requirements for the watermark and timestamp generation in the respective JIRA issue: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7548&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-7548&lt;/a&gt;. &lt;/p&gt;</comment>
                            <comment id="16171557" author="githubbot" created="Tue, 19 Sep 2017 11:37:25 +0000"  >&lt;p&gt;Github user uybhatti commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r139665963&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r139665963&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; fieldNames.length; i++) {&lt;br/&gt;
    +			if (fieldNames&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;.equals(rowtime)) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				if (fieldTypes[i] != Types.LONG) {
    +					throw new IllegalArgumentException(&quot;Specified rowtime field must be of type BIGINT. &quot; +
    +						&quot;Available fields: &quot; + toSchemaString(fieldNames, fieldTypes));
    +				}    +				this.rowtimeFieldPos = i;    +				break;    +			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +		}&lt;br/&gt;
    +		if (this.rowtimeFieldPos &amp;lt; 0) &lt;/p&gt;
{
    +			throw new IllegalArgumentException(&quot;Specified rowtime field must be present in data. &quot; +
    +				&quot;Available fields: &quot; + toSchemaString(fieldNames, fieldTypes));
    +		}
&lt;p&gt;    +		this.rowTimeAttribute = rowtime;&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust result type by removing rowtime field (will be added later)&lt;br/&gt;
    +		String[] newNames = new String&lt;span class=&quot;error&quot;&gt;&amp;#91;fieldNames.length - 1&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +		TypeInformation[] newTypes = new TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;fieldTypes.length - 1&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; rowtimeFieldPos; i++) &lt;/p&gt;
{
    +			newNames[i] = fieldNames[i];
    +			newTypes[i] = fieldTypes[i];
    +		}
&lt;p&gt;    +		for (int i = rowtimeFieldPos + 1; i &amp;lt; fieldNames.length; i++) &lt;/p&gt;
{
    +			newNames[i - 1] = fieldNames[i];
    +			newTypes[i - 1] = fieldTypes[i];
    +		}
&lt;p&gt;    +		this.typeInfo = new RowTypeInfo(newTypes, newNames);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Util method to create a schema description.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param fieldNames The names of the fields.&lt;br/&gt;
    +	 * @param fieldTypes The types of the fields.&lt;br/&gt;
    +	 * @return A string describing the schema of the given field information.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private String toSchemaString(String[] fieldNames, TypeInformation[] fieldTypes) {&lt;br/&gt;
    +		Preconditions.checkArgument(fieldNames.length == fieldTypes.length);&lt;br/&gt;
    +&lt;br/&gt;
    +		StringBuilder sb = new StringBuilder(&quot;[&quot;);&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; fieldNames.length - 1; i++) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			sb.append(fieldNames[i]);    +			sb.append(&amp;quot;}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +		sb.delete(sb.length() - 2, sb.length());&lt;br/&gt;
    +		sb.append(&quot;]&quot;);&lt;br/&gt;
    +		return sb.toString();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns an existing field as timestamp and generates bounded out-of-order watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class RowFieldWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private final int timeField;&lt;br/&gt;
    +		private final long delayMs;&lt;br/&gt;
    +		private long maxTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		private RowFieldWatermarkAssigner(int timeFieldPos, long delayMs) &lt;/p&gt;
{
    +			Preconditions.checkArgument(delayMs &amp;gt;= 0, &quot;Watermark delay must be positive.&quot;);
    +			this.timeField = timeFieldPos;
    +			this.delayMs = delayMs;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row row, long previousElementTimestamp) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = (long) row.getField(timeField);    +			if (t &amp;gt; maxTime) {
    +				maxTime = t;
    +			}    +			return t;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(maxTime - delayMs);
    +		}
&lt;p&gt;     	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Removes a field from a Row.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class FieldRemover implements MapFunction&amp;lt;Row, Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private int fieldToRemove;&lt;br/&gt;
    +&lt;br/&gt;
    +		private FieldRemover(int fieldToRemove) &lt;/p&gt;
{
    +			this.fieldToRemove = fieldToRemove;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Row map(Row value) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +			Row out = new Row(value.getArity());&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    it should be `Row out = new Row(value.getArity() - 1)` because you are removing one field from a row.&lt;/p&gt;</comment>
                            <comment id="16171704" author="githubbot" created="Tue, 19 Sep 2017 13:33:56 +0000"  >&lt;p&gt;Github user uybhatti commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r139692943&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r139692943&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -62,10 +88,107 @@&lt;br/&gt;
     			DeserializationSchema&amp;lt;Row&amp;gt; deserializationSchema,&lt;br/&gt;
     			TypeInformation&amp;lt;Row&amp;gt; typeInfo) &lt;/p&gt;
{
     
    -		this.topic = Preconditions.checkNotNull(topic, &quot;Topic&quot;);
    -		this.properties = Preconditions.checkNotNull(properties, &quot;Properties&quot;);
    -		this.deserializationSchema = Preconditions.checkNotNull(deserializationSchema, &quot;Deserialization schema&quot;);
    -		this.typeInfo = Preconditions.checkNotNull(typeInfo, &quot;Type information&quot;);
    +		this.topic = Preconditions.checkNotNull(topic, &quot;Topic must not be null.&quot;);
    +		this.properties = Preconditions.checkNotNull(properties, &quot;Properties must not be null.&quot;);
    +		this.deserializationSchema = Preconditions.checkNotNull(deserializationSchema, &quot;Deserialization schema must not be null.&quot;);
    +		this.typeInfo = Preconditions.checkNotNull(typeInfo, &quot;Type information must not be null.&quot;);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Adds processing time attribute to the table. The attribute is appended to each row.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param proctime The name of the added processing time attribute.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void addProcTimeAttribute(String proctime) &lt;/p&gt;
{
    +		Preconditions.checkNotNull(proctime, &quot;Processing time attribute must not be null.&quot;);
    +		this.procTimeAttribute = proctime;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Adds an ingestion time attribute to the table. The attribute is append at the end of each row.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;For each row, the ingestion time attribute is initialized with the current time when the row&lt;br/&gt;
    +	 * is read from Kafka. From there on, it behaves as an event time attribute.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param ingestionTime The name of the added ingestion time attribute.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void addIngestionTimeAttribute(String ingestionTime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(ingestionTime, &quot;Ingestion time attribute must not be null.&quot;);&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify an ingestion time attribute OR a row time attribute.&quot;);
    +		}
&lt;p&gt;    +		this.rowTimeAttribute = ingestionTime;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    it should be `this.ingestionTimeAttribute = ingestionTime;` &lt;br/&gt;
    Otherwise no need of `ingestionTimeAttribute` variable&lt;/p&gt;</comment>
                            <comment id="16171795" author="githubbot" created="Tue, 19 Sep 2017 14:35:21 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r139711376&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r139711376&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -106,8 +240,191 @@&lt;br/&gt;
     		return deserializationSchema;&lt;br/&gt;
     	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String explainSource() {&lt;/li&gt;
	&lt;li&gt;return &quot;&quot;;&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns ingestion time timestamps and watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class IngestionTimeWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private long curTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row element, long previousElementTimestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = System.currentTimeMillis();    +			if (t &amp;gt; curTime) {
    +				curTime = t;
    +			}    +			return curTime;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(curTime - 1);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	protected AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; getAssigner() &lt;/p&gt;
{
    +		return this.timestampAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Checks that the provided row time attribute is valid, determines its position in the schema,&lt;br/&gt;
    +	 * and adjusts the return type.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param rowtime The attribute to check.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void configureRowTimeAttribute(String rowtime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(rowtime, &quot;Row time attribute must not be null.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (this.ingestionTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify a row time attribute OR an ingestion time attribute.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;Row time attribute can only be specified once.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// get current fields&lt;br/&gt;
    +		String[] fieldNames = ((RowTypeInfo) this.getReturnType()).getFieldNames();&lt;br/&gt;
    +		TypeInformation[] fieldTypes = ((RowTypeInfo) this.getReturnType()).getFieldTypes();&lt;br/&gt;
    +&lt;br/&gt;
    +		// check if the rowtime field exists and remember position&lt;br/&gt;
    +		this.rowtimeFieldPos = -1;&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; fieldNames.length; i++) {&lt;br/&gt;
    +			if (fieldNames&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;.equals(rowtime)) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				if (fieldTypes[i] != Types.LONG) {
    +					throw new IllegalArgumentException(&quot;Specified rowtime field must be of type BIGINT. &quot; +
    +						&quot;Available fields: &quot; + toSchemaString(fieldNames, fieldTypes));
    +				}    +				this.rowtimeFieldPos = i;    +				break;    +			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +		}&lt;br/&gt;
    +		if (this.rowtimeFieldPos &amp;lt; 0) &lt;/p&gt;
{
    +			throw new IllegalArgumentException(&quot;Specified rowtime field must be present in data. &quot; +
    +				&quot;Available fields: &quot; + toSchemaString(fieldNames, fieldTypes));
    +		}
&lt;p&gt;    +		this.rowTimeAttribute = rowtime;&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust result type by removing rowtime field (will be added later)&lt;br/&gt;
    +		String[] newNames = new String&lt;span class=&quot;error&quot;&gt;&amp;#91;fieldNames.length - 1&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +		TypeInformation[] newTypes = new TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;fieldTypes.length - 1&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; rowtimeFieldPos; i++) &lt;/p&gt;
{
    +			newNames[i] = fieldNames[i];
    +			newTypes[i] = fieldTypes[i];
    +		}
&lt;p&gt;    +		for (int i = rowtimeFieldPos + 1; i &amp;lt; fieldNames.length; i++) &lt;/p&gt;
{
    +			newNames[i - 1] = fieldNames[i];
    +			newTypes[i - 1] = fieldTypes[i];
    +		}
&lt;p&gt;    +		this.typeInfo = new RowTypeInfo(newTypes, newNames);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Util method to create a schema description.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param fieldNames The names of the fields.&lt;br/&gt;
    +	 * @param fieldTypes The types of the fields.&lt;br/&gt;
    +	 * @return A string describing the schema of the given field information.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private String toSchemaString(String[] fieldNames, TypeInformation[] fieldTypes) {&lt;br/&gt;
    +		Preconditions.checkArgument(fieldNames.length == fieldTypes.length);&lt;br/&gt;
    +&lt;br/&gt;
    +		StringBuilder sb = new StringBuilder(&quot;[&quot;);&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; fieldNames.length - 1; i++) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			sb.append(fieldNames[i]);    +			sb.append(&amp;quot;}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +		sb.delete(sb.length() - 2, sb.length());&lt;br/&gt;
    +		sb.append(&quot;]&quot;);&lt;br/&gt;
    +		return sb.toString();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Assigns an existing field as timestamp and generates bounded out-of-order watermarks.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class RowFieldWatermarkAssigner implements AssignerWithPeriodicWatermarks&amp;lt;Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private final int timeField;&lt;br/&gt;
    +		private final long delayMs;&lt;br/&gt;
    +		private long maxTime = Long.MIN_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		private RowFieldWatermarkAssigner(int timeFieldPos, long delayMs) &lt;/p&gt;
{
    +			Preconditions.checkArgument(delayMs &amp;gt;= 0, &quot;Watermark delay must be positive.&quot;);
    +			this.timeField = timeFieldPos;
    +			this.delayMs = delayMs;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public long extractTimestamp(Row row, long previousElementTimestamp) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			long t = (long) row.getField(timeField);    +			if (t &amp;gt; maxTime) {
    +				maxTime = t;
    +			}    +			return t;    +		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +		@Nullable&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Watermark getCurrentWatermark() &lt;/p&gt;
{
    +			return new Watermark(maxTime - delayMs);
    +		}
&lt;p&gt;     	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Removes a field from a Row.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class FieldRemover implements MapFunction&amp;lt;Row, Row&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		private int fieldToRemove;&lt;br/&gt;
    +&lt;br/&gt;
    +		private FieldRemover(int fieldToRemove) &lt;/p&gt;
{
    +			this.fieldToRemove = fieldToRemove;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public Row map(Row value) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +			Row out = new Row(value.getArity());&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Yes, you&apos;re right. Thanks!&lt;/p&gt;</comment>
                            <comment id="16171806" author="githubbot" created="Tue, 19 Sep 2017 14:45:19 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638#discussion_r139714565&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638#discussion_r139714565&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kafka-base/src/main/java/org/apache/flink/streaming/connectors/kafka/KafkaTableSource.java &amp;#8212;&lt;br/&gt;
    @@ -62,10 +88,107 @@&lt;br/&gt;
     			DeserializationSchema&amp;lt;Row&amp;gt; deserializationSchema,&lt;br/&gt;
     			TypeInformation&amp;lt;Row&amp;gt; typeInfo) &lt;/p&gt;
{
     
    -		this.topic = Preconditions.checkNotNull(topic, &quot;Topic&quot;);
    -		this.properties = Preconditions.checkNotNull(properties, &quot;Properties&quot;);
    -		this.deserializationSchema = Preconditions.checkNotNull(deserializationSchema, &quot;Deserialization schema&quot;);
    -		this.typeInfo = Preconditions.checkNotNull(typeInfo, &quot;Type information&quot;);
    +		this.topic = Preconditions.checkNotNull(topic, &quot;Topic must not be null.&quot;);
    +		this.properties = Preconditions.checkNotNull(properties, &quot;Properties must not be null.&quot;);
    +		this.deserializationSchema = Preconditions.checkNotNull(deserializationSchema, &quot;Deserialization schema must not be null.&quot;);
    +		this.typeInfo = Preconditions.checkNotNull(typeInfo, &quot;Type information must not be null.&quot;);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Adds processing time attribute to the table. The attribute is appended to each row.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param proctime The name of the added processing time attribute.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void addProcTimeAttribute(String proctime) &lt;/p&gt;
{
    +		Preconditions.checkNotNull(proctime, &quot;Processing time attribute must not be null.&quot;);
    +		this.procTimeAttribute = proctime;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Adds an ingestion time attribute to the table. The attribute is append at the end of each row.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;For each row, the ingestion time attribute is initialized with the current time when the row&lt;br/&gt;
    +	 * is read from Kafka. From there on, it behaves as an event time attribute.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param ingestionTime The name of the added ingestion time attribute.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void addIngestionTimeAttribute(String ingestionTime) {&lt;br/&gt;
    +		Preconditions.checkNotNull(ingestionTime, &quot;Ingestion time attribute must not be null.&quot;);&lt;br/&gt;
    +		if (this.rowTimeAttribute != null) &lt;/p&gt;
{
    +			throw new ValidationException(
    +				&quot;You can only specify an ingestion time attribute OR a row time attribute.&quot;);
    +		}
&lt;p&gt;    +		this.rowTimeAttribute = ingestionTime;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Yes, that&apos;s inconsistently handled. Thanks for pointing this out.&lt;br/&gt;
    I removed `this.ingestionTimeAttribute`&lt;/p&gt;</comment>
                            <comment id="16227512" author="githubbot" created="Tue, 31 Oct 2017 20:44:45 +0000"  >&lt;p&gt;Github user fhueske commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Running some last tests before merging this PR&lt;/p&gt;</comment>
                            <comment id="16233564" author="githubbot" created="Wed, 1 Nov 2017 01:53:39 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4638&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4638&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16233737" author="fhueske" created="Wed, 1 Nov 2017 07:21:23 +0000"  >&lt;p&gt;Implemented for 1.4.0 with 0e92b6632f35b69c62d7747f1cbaa3ee207fb235&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 2 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3evd3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>