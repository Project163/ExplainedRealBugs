<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:29:08 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-6888] Can not determine TypeInformation of ACC type of AggregateFunction when ACC is a Scala case/tuple class</title>
                <link>https://issues.apache.org/jira/browse/FLINK-6888</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;Currently the &lt;tt&gt;ACC&lt;/tt&gt; TypeInformation of &lt;tt&gt;org.apache.flink.table.functions.AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T, ACC&amp;#93;&lt;/span&gt;&lt;/tt&gt; is extracted using &lt;tt&gt;TypeInformation.of(Class)&lt;/tt&gt;. When &lt;tt&gt;ACC&lt;/tt&gt; is a Scala case class or tuple class, the TypeInformation will fall back to &lt;tt&gt;GenericType&lt;/tt&gt; which result in bad performance when state de/serialization. &lt;/p&gt;

&lt;p&gt;I suggest to extract the ACC TypeInformation when called &lt;tt&gt;TableEnvironment.registerFunction()&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;Here is an example:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Accumulator(sum: &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;, count: &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;)

&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;MyAgg &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; AggregateFunction[&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;, Accumulator] {

  &lt;span class=&quot;code-comment&quot;&gt;//Overloaded accumulate method
&lt;/span&gt;  def accumulate(acc: Accumulator, value: &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;): Unit = {
  }

  override def createAccumulator(): Accumulator = Accumulator(0, 0)

  override def getValue(accumulator: Accumulator): &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt; = 1
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;tt&gt;Accumulator&lt;/tt&gt; will be recognized as &lt;tt&gt;GenericType&amp;lt;Accumulator&amp;gt;&lt;/tt&gt;.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13078938">FLINK-6888</key>
            <summary>Can not determine TypeInformation of ACC type of AggregateFunction when ACC is a Scala case/tuple class</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jark">Jark Wu</assignee>
                                    <reporter username="jark">Jark Wu</reporter>
                        <labels>
                    </labels>
                <created>Sun, 11 Jun 2017 11:44:01 +0000</created>
                <updated>Thu, 13 Jul 2017 02:18:21 +0000</updated>
                            <resolved>Thu, 13 Jul 2017 02:18:21 +0000</resolved>
                                                    <fixVersion>1.4.0</fixVersion>
                                    <component>Table SQL / API</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="16045957" author="sunjincheng121" created="Sun, 11 Jun 2017 13:15:55 +0000"  >&lt;p&gt;Hi, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jark&quot; class=&quot;user-hover&quot; rel=&quot;jark&quot;&gt;jark&lt;/a&gt;  when we dev the UDAG, we using {{org.apache.flink.api.java.tuple.Tuple2} for all ACCs of build-in AGG. the main reason is you mentioned above. You can see more info in &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5957&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;FLINK-5957&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5564&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;FLINK-5564&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="16045992" author="jark" created="Sun, 11 Jun 2017 14:38:01 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sunjincheng121&quot; class=&quot;user-hover&quot; rel=&quot;sunjincheng121&quot;&gt;sunjincheng121&lt;/a&gt;, you are right that all the build-in AGGs work good but user-defined aggs with Scala accumulator might not as mentioned in &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5957&quot; title=&quot;Remove  `getAccumulatorType` method from build-in `AggregateFunction`&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5957&quot;&gt;&lt;del&gt;FLINK-5957&lt;/del&gt;&lt;/a&gt; by Fabian.  The &lt;tt&gt;getAccumulatorType()&lt;/tt&gt; contract method can solve this issue but it&apos;s trivial to implement this method for every Scala accumulator.&lt;/p&gt;

&lt;p&gt;So I suggest to extract ACC type information when &lt;tt&gt;registerFunction&lt;/tt&gt; using Scala implicit parameters.&lt;/p&gt;</comment>
                            <comment id="16046010" author="sunjincheng121" created="Sun, 11 Jun 2017 15:33:07 +0000"  >&lt;p&gt;Yes, I just want you know the history. I also hope we can improve it. &lt;/p&gt;</comment>
                            <comment id="16046318" author="githubbot" created="Mon, 12 Jun 2017 08:16:34 +0000"  >&lt;p&gt;Github user sunjincheng121 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r121329856&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r121329856&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/runtime/aggregate/AggregateUtil.scala &amp;#8212;&lt;br/&gt;
    @@ -1395,50 +1399,25 @@ object AggregateUtil {&lt;/p&gt;

&lt;p&gt;             case udagg: AggSqlFunction =&amp;gt;&lt;br/&gt;
               aggregates(index) = udagg.getFunction&lt;br/&gt;
    +          accTypes(index) = udagg.accType&lt;/p&gt;

&lt;p&gt;             case unSupported: SqlAggFunction =&amp;gt;&lt;br/&gt;
               throw new TableException(s&quot;unsupported Function: &apos;${unSupported.getName}&apos;&quot;)&lt;br/&gt;
           }&lt;br/&gt;
         }&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(aggFieldIndexes, aggregates)&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;private def createAccumulatorType(&lt;/li&gt;
	&lt;li&gt;aggregates: Array[TableAggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;]): Seq[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;] = {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val aggTypes: Seq[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;] =&lt;/li&gt;
	&lt;li&gt;aggregates.map {&lt;/li&gt;
	&lt;li&gt;agg =&amp;gt;&lt;/li&gt;
	&lt;li&gt;val accType = try 
{
    -            val method: Method = agg.getClass.getMethod(&quot;getAccumulatorType&quot;)
    -            method.invoke(agg).asInstanceOf[TypeInformation[_]]
    -          }
&lt;p&gt; catch &lt;/p&gt;
{
    -            case _: NoSuchMethodException =&amp;gt; null
    -            case ite: Throwable =&amp;gt; throw new TableException(&quot;Unexpected exception:&quot;, ite)
    -          }&lt;/li&gt;
	&lt;li&gt;if (accType != null) 
{
    -            accType
    -          }
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;val accumulator = agg.createAccumulator()&lt;/li&gt;
	&lt;li&gt;try 
{
    -              TypeInformation.of(accumulator.getClass)
    -            }
&lt;p&gt; catch &lt;/p&gt;
{
    -              case ite: InvalidTypesException =&amp;gt;
    -                throw new TableException(
    -                  &quot;Cannot infer type of accumulator. &quot; +
    -                    &quot;You can override AggregateFunction.getAccumulatorType() to specify the type.&quot;,
    -                  ite)
    -            }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    +    // create accumulator type information for every aggregate function&lt;br/&gt;
    +    aggregates.zipWithIndex.foreach { case (agg, index) =&amp;gt;&lt;br/&gt;
    +      accTypes(index) = getAccumulatorTypeOfAggregateFunction(agg, accTypes(index))
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I think we need add a check as follows:&lt;br/&gt;
    ```&lt;br/&gt;
    aggregates.zipWithIndex.foreach { case (agg, index) =&amp;gt;&lt;br/&gt;
          if(null ==  accTypes(index))&lt;/p&gt;
{
            accTypes(index) = getAccumulatorTypeOfAggregateFunction(agg, accTypes(index))
          }
&lt;p&gt;        }&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="16046319" author="githubbot" created="Mon, 12 Jun 2017 08:16:34 +0000"  >&lt;p&gt;Github user sunjincheng121 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r121321436&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r121321436&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/functions/utils/UserDefinedFunctionUtils.scala &amp;#8212;&lt;br/&gt;
    @@ -329,6 +337,41 @@ object UserDefinedFunctionUtils {&lt;br/&gt;
         }&lt;br/&gt;
       }&lt;/p&gt;

&lt;p&gt;    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +    * Internal method of AggregateFunction#getAccumulatorType() that does some pre-checking&lt;br/&gt;
    +    * and uses [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeExtractor&amp;#93;&lt;/span&gt;] as default return type inference.&lt;br/&gt;
    +    */&lt;br/&gt;
    +  def getAccumulatorTypeOfAggregateFunction(&lt;br/&gt;
    +    aggregateFunction: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Can we abstract a method according ` getAccumulatorTypeOfAggregateFunction` and `getResultTypeOfAggregateFunction`. just like follows:&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    def getTypeByMethodOrTypeExtractor(&lt;br/&gt;
          aggregateFunction: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;,&lt;br/&gt;
          clazz: Class&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
          methodName: String,&lt;br/&gt;
          candidateType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = null): TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = {&lt;/p&gt;

&lt;p&gt;        val resultType = try &lt;/p&gt;
{
          val method: Method = aggregateFunction.getClass.getMethod(methodName)
          method.invoke(aggregateFunction).asInstanceOf[TypeInformation[_]]
        }
&lt;p&gt; catch &lt;/p&gt;
{
          case _: NoSuchMethodException =&amp;gt; null
          case ite: Throwable =&amp;gt; throw new TableException(&quot;Unexpected exception:&quot;, ite)
        }

&lt;p&gt;        if (resultType != null) &lt;/p&gt;
{
          resultType
        }
&lt;p&gt; else if(candidateType != null) &lt;/p&gt;
{
          candidateType
        }
&lt;p&gt; else {&lt;br/&gt;
          try &lt;/p&gt;
{
            TypeExtractor.createTypeInfo(clazz).asInstanceOf[TypeInformation[_]]
          }
&lt;p&gt; catch &lt;/p&gt;
{
            case ite: InvalidTypesException =&amp;gt;
              throw new TableException(
                s&quot;Cannot infer type of $clazz&quot; +
                s&quot;You can override AggregateFunction.$methodName to specify the type.&quot;, ite)
          }
&lt;p&gt;        }&lt;br/&gt;
      }&lt;br/&gt;
    ```&lt;br/&gt;
    I&apos;m not sure whether it is the best way, Please let me know what you think?&lt;/p&gt;</comment>
                            <comment id="16046320" author="githubbot" created="Mon, 12 Jun 2017 08:16:34 +0000"  >&lt;p&gt;Github user sunjincheng121 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r121324222&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r121324222&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/functions/utils/AggSqlFunction.scala &amp;#8212;&lt;br/&gt;
    @@ -37,24 +36,26 @@ import org.apache.flink.table.functions.utils.UserDefinedFunctionUtils._&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param name function name (used by SQL parser)&lt;/li&gt;
	&lt;li&gt;@param aggregateFunction aggregate function to be called&lt;/li&gt;
	&lt;li&gt;@param returnType the type information of returned value&lt;br/&gt;
    +  * @param accType the type information of the accumulator&lt;/li&gt;
	&lt;li&gt;@param typeFactory type factory for converting Flink&apos;s between Calcite&apos;s types&lt;br/&gt;
       */&lt;br/&gt;
     class AggSqlFunction(&lt;br/&gt;
         name: String,&lt;br/&gt;
         aggregateFunction: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;,&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;returnType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +    val returnType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +    val accType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
         typeFactory: FlinkTypeFactory,&lt;br/&gt;
         requiresOver: Boolean)&lt;/li&gt;
	&lt;li&gt;extends SqlUserDefinedAggFunction(&lt;br/&gt;
    +  extends SqlAggFunction(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Why we need change `SqlUserDefinedAggFunction` to `SqlAggFunction`. Is there some reasons? If so, please explain more about. &lt;br/&gt;
    If not so, I suggest keeping using `SqlUserDefinedAggFunction`. Because `SqlUserDefinedAggFunction` is provided by Calcite which related the UDAG, in order to adapt to Calcite changes I recommend keeping using `SqlUserDefinedAggFunction`. (Although the `SqlUserDefinedAggFunction` of calcite is covered by the current flink.). &lt;/p&gt;</comment>
                            <comment id="16046321" author="githubbot" created="Mon, 12 Jun 2017 08:16:35 +0000"  >&lt;p&gt;Github user sunjincheng121 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r121325300&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r121325300&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/scala/stream/sql/AggregationsTest.scala &amp;#8212;&lt;br/&gt;
    @@ -39,4 +44,34 @@ class AggregationsTest extends TableTestBase &lt;/p&gt;
{
     
         streamUtil.tEnv.sql(sqlQuery)
       }
&lt;p&gt;    +&lt;br/&gt;
    +  @Test&lt;br/&gt;
    +  def testUserDefinedAggregateFunctionWithScalaAccumulator(): Unit = &lt;/p&gt;
{
    +    streamUtil.addFunction(&quot;udag&quot;, new MyAgg)
    +    val call = streamUtil
    +      .tEnv
    +      .functionCatalog
    +      .lookupFunction(&quot;udag&quot;, Seq())
    +      .asInstanceOf[AggFunctionCall]
    +
    +    val typeInfo = call.accTypeInfo
    +    assertTrue(typeInfo.isInstanceOf[CaseClassTypeInfo[_]])
    +    assertEquals(2, typeInfo.getTotalFields)
    +    val caseTypeInfo = typeInfo.asInstanceOf[CaseClassTypeInfo[_]]
    +    assertEquals(Types.LONG, caseTypeInfo.getTypeAt(0))
    +    assertEquals(Types.LONG, caseTypeInfo.getTypeAt(1))
    +  }
&lt;p&gt;    +}&lt;br/&gt;
    +&lt;br/&gt;
    +case class Accumulator(sum: Long, count: Long)&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    The members of `Accumulator` must be modified. &lt;/p&gt;</comment>
                            <comment id="16046330" author="githubbot" created="Mon, 12 Jun 2017 08:33:40 +0000"  >&lt;p&gt;Github user wuchong commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r121335610&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r121335610&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/functions/utils/AggSqlFunction.scala &amp;#8212;&lt;br/&gt;
    @@ -37,24 +36,26 @@ import org.apache.flink.table.functions.utils.UserDefinedFunctionUtils._&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param name function name (used by SQL parser)&lt;/li&gt;
	&lt;li&gt;@param aggregateFunction aggregate function to be called&lt;/li&gt;
	&lt;li&gt;@param returnType the type information of returned value&lt;br/&gt;
    +  * @param accType the type information of the accumulator&lt;/li&gt;
	&lt;li&gt;@param typeFactory type factory for converting Flink&apos;s between Calcite&apos;s types&lt;br/&gt;
       */&lt;br/&gt;
     class AggSqlFunction(&lt;br/&gt;
         name: String,&lt;br/&gt;
         aggregateFunction: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;,&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;returnType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +    val returnType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +    val accType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
         typeFactory: FlinkTypeFactory,&lt;br/&gt;
         requiresOver: Boolean)&lt;/li&gt;
	&lt;li&gt;extends SqlUserDefinedAggFunction(&lt;br/&gt;
    +  extends SqlAggFunction(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Sorry, I didn&apos;t notice the copied `SqlUserDefinedAggFunction` from Calcite. I did these change because the constructor of Calcite `SqlUserDefinedAggFunction` doesn&apos;t match the calling with additional `requiresOver`. &lt;/p&gt;</comment>
                            <comment id="16046332" author="githubbot" created="Mon, 12 Jun 2017 08:35:17 +0000"  >&lt;p&gt;Github user wuchong commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r121335927&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r121335927&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/runtime/aggregate/AggregateUtil.scala &amp;#8212;&lt;br/&gt;
    @@ -1395,50 +1399,25 @@ object AggregateUtil {&lt;/p&gt;

&lt;p&gt;             case udagg: AggSqlFunction =&amp;gt;&lt;br/&gt;
               aggregates(index) = udagg.getFunction&lt;br/&gt;
    +          accTypes(index) = udagg.accType&lt;/p&gt;

&lt;p&gt;             case unSupported: SqlAggFunction =&amp;gt;&lt;br/&gt;
               throw new TableException(s&quot;unsupported Function: &apos;${unSupported.getName}&apos;&quot;)&lt;br/&gt;
           }&lt;br/&gt;
         }&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(aggFieldIndexes, aggregates)&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;private def createAccumulatorType(&lt;/li&gt;
	&lt;li&gt;aggregates: Array[TableAggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;]): Seq[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;] = {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val aggTypes: Seq[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;] =&lt;/li&gt;
	&lt;li&gt;aggregates.map {&lt;/li&gt;
	&lt;li&gt;agg =&amp;gt;&lt;/li&gt;
	&lt;li&gt;val accType = try 
{
    -            val method: Method = agg.getClass.getMethod(&quot;getAccumulatorType&quot;)
    -            method.invoke(agg).asInstanceOf[TypeInformation[_]]
    -          }
&lt;p&gt; catch &lt;/p&gt;
{
    -            case _: NoSuchMethodException =&amp;gt; null
    -            case ite: Throwable =&amp;gt; throw new TableException(&quot;Unexpected exception:&quot;, ite)
    -          }&lt;/li&gt;
	&lt;li&gt;if (accType != null) 
{
    -            accType
    -          }
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;val accumulator = agg.createAccumulator()&lt;/li&gt;
	&lt;li&gt;try 
{
    -              TypeInformation.of(accumulator.getClass)
    -            }
&lt;p&gt; catch &lt;/p&gt;
{
    -              case ite: InvalidTypesException =&amp;gt;
    -                throw new TableException(
    -                  &quot;Cannot infer type of accumulator. &quot; +
    -                    &quot;You can override AggregateFunction.getAccumulatorType() to specify the type.&quot;,
    -                  ite)
    -            }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    +    // create accumulator type information for every aggregate function&lt;br/&gt;
    +    aggregates.zipWithIndex.foreach { case (agg, index) =&amp;gt;&lt;br/&gt;
    +      accTypes(index) = getAccumulatorTypeOfAggregateFunction(agg, accTypes(index))
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I don&apos;t think so. The `getAccumulatorTypeOfAggregateFunction` can handle the nullable `accTypes(index)`.&lt;/p&gt;</comment>
                            <comment id="16046334" author="githubbot" created="Mon, 12 Jun 2017 08:35:37 +0000"  >&lt;p&gt;Github user wuchong commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r121335993&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r121335993&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/functions/utils/UserDefinedFunctionUtils.scala &amp;#8212;&lt;br/&gt;
    @@ -329,6 +337,41 @@ object UserDefinedFunctionUtils {&lt;br/&gt;
         }&lt;br/&gt;
       }&lt;/p&gt;

&lt;p&gt;    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +    * Internal method of AggregateFunction#getAccumulatorType() that does some pre-checking&lt;br/&gt;
    +    * and uses [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeExtractor&amp;#93;&lt;/span&gt;] as default return type inference.&lt;br/&gt;
    +    */&lt;br/&gt;
    +  def getAccumulatorTypeOfAggregateFunction(&lt;br/&gt;
    +    aggregateFunction: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Good idea. I like it.&lt;/p&gt;</comment>
                            <comment id="16046335" author="githubbot" created="Mon, 12 Jun 2017 08:36:23 +0000"  >&lt;p&gt;Github user wuchong commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r121336133&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r121336133&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/functions/utils/AggSqlFunction.scala &amp;#8212;&lt;br/&gt;
    @@ -37,24 +36,26 @@ import org.apache.flink.table.functions.utils.UserDefinedFunctionUtils._&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param name function name (used by SQL parser)&lt;/li&gt;
	&lt;li&gt;@param aggregateFunction aggregate function to be called&lt;/li&gt;
	&lt;li&gt;@param returnType the type information of returned value&lt;br/&gt;
    +  * @param accType the type information of the accumulator&lt;/li&gt;
	&lt;li&gt;@param typeFactory type factory for converting Flink&apos;s between Calcite&apos;s types&lt;br/&gt;
       */&lt;br/&gt;
     class AggSqlFunction(&lt;br/&gt;
         name: String,&lt;br/&gt;
         aggregateFunction: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;,&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;returnType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +    val returnType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +    val accType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
         typeFactory: FlinkTypeFactory,&lt;br/&gt;
         requiresOver: Boolean)&lt;/li&gt;
	&lt;li&gt;extends SqlUserDefinedAggFunction(&lt;br/&gt;
    +  extends SqlAggFunction(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Will revert these change &lt;/p&gt;</comment>
                            <comment id="16046370" author="githubbot" created="Mon, 12 Jun 2017 09:26:23 +0000"  >&lt;p&gt;Github user sunjincheng121 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r121346261&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r121346261&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/runtime/aggregate/AggregateUtil.scala &amp;#8212;&lt;br/&gt;
    @@ -1395,50 +1399,25 @@ object AggregateUtil {&lt;/p&gt;

&lt;p&gt;             case udagg: AggSqlFunction =&amp;gt;&lt;br/&gt;
               aggregates(index) = udagg.getFunction&lt;br/&gt;
    +          accTypes(index) = udagg.accType&lt;/p&gt;

&lt;p&gt;             case unSupported: SqlAggFunction =&amp;gt;&lt;br/&gt;
               throw new TableException(s&quot;unsupported Function: &apos;${unSupported.getName}&apos;&quot;)&lt;br/&gt;
           }&lt;br/&gt;
         }&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(aggFieldIndexes, aggregates)&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;private def createAccumulatorType(&lt;/li&gt;
	&lt;li&gt;aggregates: Array[TableAggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;]): Seq[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;] = {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val aggTypes: Seq[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;] =&lt;/li&gt;
	&lt;li&gt;aggregates.map {&lt;/li&gt;
	&lt;li&gt;agg =&amp;gt;&lt;/li&gt;
	&lt;li&gt;val accType = try 
{
    -            val method: Method = agg.getClass.getMethod(&quot;getAccumulatorType&quot;)
    -            method.invoke(agg).asInstanceOf[TypeInformation[_]]
    -          }
&lt;p&gt; catch &lt;/p&gt;
{
    -            case _: NoSuchMethodException =&amp;gt; null
    -            case ite: Throwable =&amp;gt; throw new TableException(&quot;Unexpected exception:&quot;, ite)
    -          }&lt;/li&gt;
	&lt;li&gt;if (accType != null) 
{
    -            accType
    -          }
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;val accumulator = agg.createAccumulator()&lt;/li&gt;
	&lt;li&gt;try 
{
    -              TypeInformation.of(accumulator.getClass)
    -            }
&lt;p&gt; catch &lt;/p&gt;
{
    -              case ite: InvalidTypesException =&amp;gt;
    -                throw new TableException(
    -                  &quot;Cannot infer type of accumulator. &quot; +
    -                    &quot;You can override AggregateFunction.getAccumulatorType() to specify the type.&quot;,
    -                  ite)
    -            }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    +    // create accumulator type information for every aggregate function&lt;br/&gt;
    +    aggregates.zipWithIndex.foreach { case (agg, index) =&amp;gt;&lt;br/&gt;
    +      accTypes(index) = getAccumulatorTypeOfAggregateFunction(agg, accTypes(index))
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    If i understand correctly. only build-in AGG need call `getAccumulatorTypeOfAggregateFunction`. &lt;br/&gt;
    and all the UDAGG do not need call this method. is that correct? If so, I think if only `null==accTypes(index)` need call this method. Please explain more If I understand incorrectly. thanks!&lt;/p&gt;
</comment>
                            <comment id="16046385" author="githubbot" created="Mon, 12 Jun 2017 09:41:49 +0000"  >&lt;p&gt;Github user wuchong commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r121349658&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r121349658&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/runtime/aggregate/AggregateUtil.scala &amp;#8212;&lt;br/&gt;
    @@ -1395,50 +1399,25 @@ object AggregateUtil {&lt;/p&gt;

&lt;p&gt;             case udagg: AggSqlFunction =&amp;gt;&lt;br/&gt;
               aggregates(index) = udagg.getFunction&lt;br/&gt;
    +          accTypes(index) = udagg.accType&lt;/p&gt;

&lt;p&gt;             case unSupported: SqlAggFunction =&amp;gt;&lt;br/&gt;
               throw new TableException(s&quot;unsupported Function: &apos;${unSupported.getName}&apos;&quot;)&lt;br/&gt;
           }&lt;br/&gt;
         }&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(aggFieldIndexes, aggregates)&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;private def createAccumulatorType(&lt;/li&gt;
	&lt;li&gt;aggregates: Array[TableAggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;]): Seq[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;] = {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val aggTypes: Seq[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;] =&lt;/li&gt;
	&lt;li&gt;aggregates.map {&lt;/li&gt;
	&lt;li&gt;agg =&amp;gt;&lt;/li&gt;
	&lt;li&gt;val accType = try 
{
    -            val method: Method = agg.getClass.getMethod(&quot;getAccumulatorType&quot;)
    -            method.invoke(agg).asInstanceOf[TypeInformation[_]]
    -          }
&lt;p&gt; catch &lt;/p&gt;
{
    -            case _: NoSuchMethodException =&amp;gt; null
    -            case ite: Throwable =&amp;gt; throw new TableException(&quot;Unexpected exception:&quot;, ite)
    -          }&lt;/li&gt;
	&lt;li&gt;if (accType != null) 
{
    -            accType
    -          }
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;val accumulator = agg.createAccumulator()&lt;/li&gt;
	&lt;li&gt;try 
{
    -              TypeInformation.of(accumulator.getClass)
    -            }
&lt;p&gt; catch &lt;/p&gt;
{
    -              case ite: InvalidTypesException =&amp;gt;
    -                throw new TableException(
    -                  &quot;Cannot infer type of accumulator. &quot; +
    -                    &quot;You can override AggregateFunction.getAccumulatorType() to specify the type.&quot;,
    -                  ite)
    -            }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    +    // create accumulator type information for every aggregate function&lt;br/&gt;
    +    aggregates.zipWithIndex.foreach { case (agg, index) =&amp;gt;&lt;br/&gt;
    +      accTypes(index) = getAccumulatorTypeOfAggregateFunction(agg, accTypes(index))
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Yes, adding the `null == accTypes(index)` condition can reduce one more time calling `getAccumulatorTypeOfAggregateFunction`.  I will add it. &lt;/p&gt;</comment>
                            <comment id="16046587" author="githubbot" created="Mon, 12 Jun 2017 13:58:07 +0000"  >&lt;p&gt;Github user wuchong commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r121399188&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r121399188&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/functions/utils/UserDefinedFunctionUtils.scala &amp;#8212;&lt;br/&gt;
    @@ -329,6 +337,41 @@ object UserDefinedFunctionUtils {&lt;br/&gt;
         }&lt;br/&gt;
       }&lt;/p&gt;

&lt;p&gt;    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +    * Internal method of AggregateFunction#getAccumulatorType() that does some pre-checking&lt;br/&gt;
    +    * and uses [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeExtractor&amp;#93;&lt;/span&gt;] as default return type inference.&lt;br/&gt;
    +    */&lt;br/&gt;
    +  def getAccumulatorTypeOfAggregateFunction(&lt;br/&gt;
    +    aggregateFunction: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I find that only the following code block can be extracted. I think maybe we don&apos;t need to extract it. What do you think? @sunjincheng121 &lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
      val resultType = try &lt;/p&gt;
{
          val method: Method = aggregateFunction.getClass.getMethod(methodName)
          method.invoke(aggregateFunction).asInstanceOf[TypeInformation[_]]
        }
&lt;p&gt; catch &lt;/p&gt;
{
          case _: NoSuchMethodException =&amp;gt; null
          case ite: Throwable =&amp;gt; throw new TableException(&quot;Unexpected exception:&quot;, ite)
        }
&lt;p&gt;    ```&lt;/p&gt;</comment>
                            <comment id="16047629" author="githubbot" created="Tue, 13 Jun 2017 09:17:30 +0000"  >&lt;p&gt;Github user hustfxj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r121624773&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r121624773&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/functions/utils/UserDefinedFunctionUtils.scala &amp;#8212;&lt;br/&gt;
    @@ -329,6 +337,41 @@ object UserDefinedFunctionUtils {&lt;br/&gt;
         }&lt;br/&gt;
       }&lt;/p&gt;

&lt;p&gt;    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +    * Internal method of AggregateFunction#getAccumulatorType() that does some pre-checking&lt;br/&gt;
    +    * and uses [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeExtractor&amp;#93;&lt;/span&gt;] as default return type inference.&lt;br/&gt;
    +    */&lt;br/&gt;
    +  def getAccumulatorTypeOfAggregateFunction(&lt;br/&gt;
    +    aggregateFunction: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +    extractedType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = null)&lt;br/&gt;
    +  : TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +&lt;br/&gt;
    +    val accType = try &lt;/p&gt;
{
    +      val method: Method = aggregateFunction.getClass.getMethod(&quot;getAccumulatorType&quot;)
    +      method.invoke(aggregateFunction).asInstanceOf[TypeInformation[_]]
    +    }
&lt;p&gt; catch &lt;/p&gt;
{
    +      case _: NoSuchMethodException =&amp;gt; null
    +      case ite: Throwable =&amp;gt; throw new TableException(&quot;Unexpected exception:&quot;, ite)
    +    }
&lt;p&gt;    +    if (accType != null) &lt;/p&gt;
{
    +      accType
    +    }
&lt;p&gt; else if (extractedType != null) &lt;/p&gt;
{
    +      extractedType
    +    }
&lt;p&gt; else {&lt;br/&gt;
    +      val accumulator = aggregateFunction.createAccumulator()&lt;br/&gt;
    +      try {&lt;br/&gt;
    +        TypeInformation.of(accumulator.getClass)&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Maybe we use the followed code replace *&lt;b&gt;TypeInformation.of&lt;/b&gt;* ?&lt;br/&gt;
     ```&lt;br/&gt;
    val accumulator = TypeExtractor&lt;br/&gt;
            .createTypeInfo(aggregateFunction, classOf[AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;],&lt;br/&gt;
              aggregateFunction.getClass, 1).asInstanceOf[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="16047634" author="githubbot" created="Tue, 13 Jun 2017 09:22:35 +0000"  >&lt;p&gt;Github user wuchong commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r121625889&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r121625889&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/functions/utils/UserDefinedFunctionUtils.scala &amp;#8212;&lt;br/&gt;
    @@ -329,6 +337,41 @@ object UserDefinedFunctionUtils {&lt;br/&gt;
         }&lt;br/&gt;
       }&lt;/p&gt;

&lt;p&gt;    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +    * Internal method of AggregateFunction#getAccumulatorType() that does some pre-checking&lt;br/&gt;
    +    * and uses [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeExtractor&amp;#93;&lt;/span&gt;] as default return type inference.&lt;br/&gt;
    +    */&lt;br/&gt;
    +  def getAccumulatorTypeOfAggregateFunction(&lt;br/&gt;
    +    aggregateFunction: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +    extractedType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = null)&lt;br/&gt;
    +  : TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +&lt;br/&gt;
    +    val accType = try &lt;/p&gt;
{
    +      val method: Method = aggregateFunction.getClass.getMethod(&quot;getAccumulatorType&quot;)
    +      method.invoke(aggregateFunction).asInstanceOf[TypeInformation[_]]
    +    }
&lt;p&gt; catch &lt;/p&gt;
{
    +      case _: NoSuchMethodException =&amp;gt; null
    +      case ite: Throwable =&amp;gt; throw new TableException(&quot;Unexpected exception:&quot;, ite)
    +    }
&lt;p&gt;    +    if (accType != null) &lt;/p&gt;
{
    +      accType
    +    }
&lt;p&gt; else if (extractedType != null) &lt;/p&gt;
{
    +      extractedType
    +    }
&lt;p&gt; else {&lt;br/&gt;
    +      val accumulator = aggregateFunction.createAccumulator()&lt;br/&gt;
    +      try {&lt;br/&gt;
    +        TypeInformation.of(accumulator.getClass)&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I think it&apos;s a good advice.&lt;/p&gt;</comment>
                            <comment id="16048241" author="githubbot" created="Tue, 13 Jun 2017 18:49:23 +0000"  >&lt;p&gt;Github user StephanEwen commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Is the code ever called from Java code, or is that purely within the Scala code base?&lt;/p&gt;

&lt;p&gt;    Just FYI, the design principles in the DataStream and DataSet API are:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Never run `TypeExtractor` for Scala code. Scala code always uses implicits and context bounds for the Type Information&lt;/li&gt;
	&lt;li&gt;Java code entry methods uses the Type Extractor&lt;/li&gt;
	&lt;li&gt;Code that is shared between Java / Scala always gets the Type Information passed in&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="16048638" author="githubbot" created="Wed, 14 Jun 2017 02:47:18 +0000"  >&lt;p&gt;Github user wuchong commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks @StephanEwen .  This PR is aiming to fix the issues you mentioned: it used `TypeExtractor` for Scala code. &lt;/p&gt;

&lt;p&gt;    @sunjincheng121  I addressed all your comments. Could you please have a look again ?&lt;/p&gt;</comment>
                            <comment id="16048652" author="githubbot" created="Wed, 14 Jun 2017 03:08:06 +0000"  >&lt;p&gt;Github user sunjincheng121 commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @wuchong thanks for the update. It&apos;s looks pretty good for me now.&lt;br/&gt;
    + to merged.&lt;/p&gt;</comment>
                            <comment id="16051960" author="githubbot" created="Fri, 16 Jun 2017 14:21:38 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r122447580&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r122447580&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/java/BatchTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -192,10 +193,14 @@ class BatchTableEnvironment(&lt;br/&gt;
           name: String,&lt;br/&gt;
           f: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T, ACC&amp;#93;&lt;/span&gt;)&lt;br/&gt;
       : Unit = {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;implicit val typeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt; = TypeExtractor&lt;/li&gt;
	&lt;li&gt;.createTypeInfo(f, classOf[AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T, ACC&amp;#93;&lt;/span&gt;], f.getClass, 0)&lt;br/&gt;
    +    implicit val typeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt; = UserDefinedFunctionUtils&lt;br/&gt;
    +      .getResultTypeOfAggregateFunction(f)&lt;br/&gt;
           .asInstanceOf[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;]&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    implicit val accTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;ACC&amp;#93;&lt;/span&gt; = UserDefinedFunctionUtils&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    The correct extraction of TypeInformation for Scala classes only works in the Scala TableEnvironments but not for Java environments. Hence, UDAGGs that use Scala classes should not be used in Java queries because they will fall back to GenericTypes there.&lt;/p&gt;

&lt;p&gt;    The safe and portable way is to use Java classes for accumulators.&lt;/p&gt;</comment>
                            <comment id="16051961" author="githubbot" created="Fri, 16 Jun 2017 14:21:38 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r122447088&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r122447088&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/functions/utils/UserDefinedFunctionUtils.scala &amp;#8212;&lt;br/&gt;
    @@ -307,9 +315,29 @@ object UserDefinedFunctionUtils {&lt;br/&gt;
           aggregateFunction: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;,&lt;br/&gt;
           extractedType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = null)&lt;br/&gt;
         : TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = &lt;/p&gt;
{
    +    getGenericTypeOfAggregateFunction(aggregateFunction, &quot;getResultType&quot;, 0, extractedType)
    +  }
&lt;p&gt;    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +    * Internal method of AggregateFunction#getAccumulatorType() that does some pre-checking&lt;br/&gt;
    +    * and uses [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeExtractor&amp;#93;&lt;/span&gt;] as default return type inference.&lt;br/&gt;
    +    */&lt;br/&gt;
    +  def getAccumulatorTypeOfAggregateFunction(&lt;br/&gt;
    +    aggregateFunction: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +    extractedType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = null)&lt;br/&gt;
    +  : TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = &lt;/p&gt;
{
    +    getGenericTypeOfAggregateFunction(aggregateFunction, &quot;getAccumulatorType&quot;, 1, extractedType)
    +  }
&lt;p&gt;    +&lt;br/&gt;
    +  private def getGenericTypeOfAggregateFunction(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I would not call the method `getGenericTypeOfAggFunction` because this implies that it returns a `GenericType` which we want to avoid.&lt;/p&gt;</comment>
                            <comment id="16051962" author="githubbot" created="Fri, 16 Jun 2017 14:21:38 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r122448432&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r122448432&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -358,20 +358,27 @@ abstract class TableEnvironment(val config: TableConfig) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Registers an [&lt;span class=&quot;error&quot;&gt;&amp;#91;AggregateFunction&amp;#93;&lt;/span&gt;] under a unique name. Replaces already existing&lt;/li&gt;
	&lt;li&gt;user-defined functions under this name.&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def registerAggregateFunctionInternal&lt;span class=&quot;error&quot;&gt;&amp;#91;T: TypeInformation, ACC&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +  private&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def registerAggregateFunctionInternal&lt;span class=&quot;error&quot;&gt;&amp;#91;T: TypeInformation, ACC: TypeInformation&amp;#93;&lt;/span&gt;(&lt;br/&gt;
           name: String, function: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T, ACC&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
         // check if class not Scala object&lt;br/&gt;
         checkNotSingleton(function.getClass)&lt;br/&gt;
         // check if class could be instantiated&lt;br/&gt;
         checkForInstantiation(function.getClass)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val typeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    +    val resultTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    +    val accTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;ACC&amp;#93;&lt;/span&gt;]&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // register in Table API&lt;br/&gt;
         functionCatalog.registerFunction(name, function.getClass)&lt;/p&gt;

&lt;p&gt;         // register in SQL API&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val sqlFunctions = createAggregateSqlFunction(name, function, typeInfo, typeFactory)&lt;br/&gt;
    +    val sqlFunctions = createAggregateSqlFunction(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    To be honest, I don&apos;t think it is a nice approach to add the acc type to the internal representation of UDAGGs. It is not related to the logic of the function or required for the optimization but rather an internal runtime aspect.&lt;/p&gt;

&lt;p&gt;    An alternative could be to wrap the functions registered from Scala in a class that extends the `AggregateFunction` interface and holds the original agg function and the acc type information (exposed via the getAccumulatorType()` method). We would need to unwrap it before we translate it. It&apos;s not a super nice solution either, but would probably require fewer changes.&lt;/p&gt;

&lt;p&gt;    What do you think?&lt;/p&gt;</comment>
                            <comment id="16053427" author="githubbot" created="Mon, 19 Jun 2017 02:59:14 +0000"  >&lt;p&gt;Github user wuchong commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r122613823&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r122613823&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -358,20 +358,27 @@ abstract class TableEnvironment(val config: TableConfig) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Registers an [&lt;span class=&quot;error&quot;&gt;&amp;#91;AggregateFunction&amp;#93;&lt;/span&gt;] under a unique name. Replaces already existing&lt;/li&gt;
	&lt;li&gt;user-defined functions under this name.&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def registerAggregateFunctionInternal&lt;span class=&quot;error&quot;&gt;&amp;#91;T: TypeInformation, ACC&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +  private&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def registerAggregateFunctionInternal&lt;span class=&quot;error&quot;&gt;&amp;#91;T: TypeInformation, ACC: TypeInformation&amp;#93;&lt;/span&gt;(&lt;br/&gt;
           name: String, function: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T, ACC&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
         // check if class not Scala object&lt;br/&gt;
         checkNotSingleton(function.getClass)&lt;br/&gt;
         // check if class could be instantiated&lt;br/&gt;
         checkForInstantiation(function.getClass)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val typeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    +    val resultTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    +    val accTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;ACC&amp;#93;&lt;/span&gt;]&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // register in Table API&lt;br/&gt;
         functionCatalog.registerFunction(name, function.getClass)&lt;/p&gt;

&lt;p&gt;         // register in SQL API&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val sqlFunctions = createAggregateSqlFunction(name, function, typeInfo, typeFactory)&lt;br/&gt;
    +    val sqlFunctions = createAggregateSqlFunction(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Hi @fhueske , I think the ACC type extraction is similar to `T` type of `AggreateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T, ACC&amp;#93;&lt;/span&gt;` and `T` type of `TableFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;`. Currently, they are both extracted and add to the internal representation of UDAGGs and UDTFs. To keep the consistent, I followed the same way to add the acc type. If we decide to adopt the approach that wrapping the registered functions, it would be better to make the other type extractions follow this approach.&lt;/p&gt;

&lt;p&gt;    What do you think ? &lt;/p&gt;</comment>
                            <comment id="16053432" author="githubbot" created="Mon, 19 Jun 2017 03:11:53 +0000"  >&lt;p&gt;Github user wuchong commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r122614563&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r122614563&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/java/BatchTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -192,10 +193,14 @@ class BatchTableEnvironment(&lt;br/&gt;
           name: String,&lt;br/&gt;
           f: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T, ACC&amp;#93;&lt;/span&gt;)&lt;br/&gt;
       : Unit = {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;implicit val typeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt; = TypeExtractor&lt;/li&gt;
	&lt;li&gt;.createTypeInfo(f, classOf[AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T, ACC&amp;#93;&lt;/span&gt;], f.getClass, 0)&lt;br/&gt;
    +    implicit val typeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt; = UserDefinedFunctionUtils&lt;br/&gt;
    +      .getResultTypeOfAggregateFunction(f)&lt;br/&gt;
           .asInstanceOf[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;]&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    implicit val accTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;ACC&amp;#93;&lt;/span&gt; = UserDefinedFunctionUtils&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I agree with you. But this PR is only to fix Scala classes can&apos;t work in the Scala TableEnvironments. In general, users create Scala classes and naturally will use it in Scala TableEnvironments. Registering a Scala class into Java TableEnvironments is not recommended (should forbidden). This is the same with that Scala `T` classes of `Aggregate&lt;span class=&quot;error&quot;&gt;&amp;#91;T, _&amp;#93;&lt;/span&gt; and TableFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;` works in Scala TableEnvironments.&lt;/p&gt;</comment>
                            <comment id="16054023" author="githubbot" created="Mon, 19 Jun 2017 13:49:10 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r122711347&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r122711347&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -358,20 +358,27 @@ abstract class TableEnvironment(val config: TableConfig) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Registers an [&lt;span class=&quot;error&quot;&gt;&amp;#91;AggregateFunction&amp;#93;&lt;/span&gt;] under a unique name. Replaces already existing&lt;/li&gt;
	&lt;li&gt;user-defined functions under this name.&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def registerAggregateFunctionInternal&lt;span class=&quot;error&quot;&gt;&amp;#91;T: TypeInformation, ACC&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +  private&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def registerAggregateFunctionInternal&lt;span class=&quot;error&quot;&gt;&amp;#91;T: TypeInformation, ACC: TypeInformation&amp;#93;&lt;/span&gt;(&lt;br/&gt;
           name: String, function: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T, ACC&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
         // check if class not Scala object&lt;br/&gt;
         checkNotSingleton(function.getClass)&lt;br/&gt;
         // check if class could be instantiated&lt;br/&gt;
         checkForInstantiation(function.getClass)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val typeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    +    val resultTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    +    val accTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;ACC&amp;#93;&lt;/span&gt;]&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // register in Table API&lt;br/&gt;
         functionCatalog.registerFunction(name, function.getClass)&lt;/p&gt;

&lt;p&gt;         // register in SQL API&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val sqlFunctions = createAggregateSqlFunction(name, function, typeInfo, typeFactory)&lt;br/&gt;
    +    val sqlFunctions = createAggregateSqlFunction(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    You are right. We use the same approach for the return type `T` of all UDFs. However, the return type is part of the function signature and needs to be known to Calcite for semantic validation. The `ACC` type is only needed for compilation and an engine specific property.  &lt;/p&gt;

&lt;p&gt;    TBH, I&apos;m not sure which approach is better.&lt;/p&gt;</comment>
                            <comment id="16054032" author="githubbot" created="Mon, 19 Jun 2017 13:52:30 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r122712259&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r122712259&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/java/BatchTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -192,10 +193,14 @@ class BatchTableEnvironment(&lt;br/&gt;
           name: String,&lt;br/&gt;
           f: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T, ACC&amp;#93;&lt;/span&gt;)&lt;br/&gt;
       : Unit = {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;implicit val typeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt; = TypeExtractor&lt;/li&gt;
	&lt;li&gt;.createTypeInfo(f, classOf[AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T, ACC&amp;#93;&lt;/span&gt;], f.getClass, 0)&lt;br/&gt;
    +    implicit val typeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt; = UserDefinedFunctionUtils&lt;br/&gt;
    +      .getResultTypeOfAggregateFunction(f)&lt;br/&gt;
           .asInstanceOf[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;]&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    implicit val accTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;ACC&amp;#93;&lt;/span&gt; = UserDefinedFunctionUtils&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    UDAGGs are sometimes also shared in libraries. If a UDAGG class is included in a JAR file and loaded into the classpath, a user can hardly tell whether it is implemented in Java or Scala. So, I would not prohibit Scala UDFs in Jave environments. However, functions which are intended to be shared should be implemented with Java types.&lt;/p&gt;</comment>
                            <comment id="16055700" author="githubbot" created="Tue, 20 Jun 2017 12:48:34 +0000"  >&lt;p&gt;Github user wuchong commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r122964903&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r122964903&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -358,20 +358,27 @@ abstract class TableEnvironment(val config: TableConfig) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Registers an [&lt;span class=&quot;error&quot;&gt;&amp;#91;AggregateFunction&amp;#93;&lt;/span&gt;] under a unique name. Replaces already existing&lt;/li&gt;
	&lt;li&gt;user-defined functions under this name.&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def registerAggregateFunctionInternal&lt;span class=&quot;error&quot;&gt;&amp;#91;T: TypeInformation, ACC&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +  private&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def registerAggregateFunctionInternal&lt;span class=&quot;error&quot;&gt;&amp;#91;T: TypeInformation, ACC: TypeInformation&amp;#93;&lt;/span&gt;(&lt;br/&gt;
           name: String, function: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T, ACC&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
         // check if class not Scala object&lt;br/&gt;
         checkNotSingleton(function.getClass)&lt;br/&gt;
         // check if class could be instantiated&lt;br/&gt;
         checkForInstantiation(function.getClass)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val typeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    +    val resultTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    +    val accTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;ACC&amp;#93;&lt;/span&gt;]&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // register in Table API&lt;br/&gt;
         functionCatalog.registerFunction(name, function.getClass)&lt;/p&gt;

&lt;p&gt;         // register in SQL API&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val sqlFunctions = createAggregateSqlFunction(name, function, typeInfo, typeFactory)&lt;br/&gt;
    +    val sqlFunctions = createAggregateSqlFunction(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @fhueske thanks for your explanation. I tried to wrap the UDAGG in an `AggregateFunctionWrapper`, but find that it is not an easy way. Because I can&apos;t override the user-defined contract methods, such as `accumulate`, `retract`, `merge`. And in code generation, we generate the acc type class depend on `createAccumulator` method return type, but the return type of `createAccumulator` of `AggregateFunctionWrapper` can only be `Any` which will result in error.&lt;/p&gt;

&lt;p&gt;    In addition, I plan to support composite result type for UDAGG. This also need the return type not only to be known to Calcite for semantic validation but also to be known for code generation.&lt;/p&gt;</comment>
                            <comment id="16064202" author="githubbot" created="Tue, 27 Jun 2017 03:34:40 +0000"  >&lt;p&gt;Github user wuchong commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r124171844&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r124171844&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -358,20 +358,27 @@ abstract class TableEnvironment(val config: TableConfig) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Registers an [&lt;span class=&quot;error&quot;&gt;&amp;#91;AggregateFunction&amp;#93;&lt;/span&gt;] under a unique name. Replaces already existing&lt;/li&gt;
	&lt;li&gt;user-defined functions under this name.&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def registerAggregateFunctionInternal&lt;span class=&quot;error&quot;&gt;&amp;#91;T: TypeInformation, ACC&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +  private&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def registerAggregateFunctionInternal&lt;span class=&quot;error&quot;&gt;&amp;#91;T: TypeInformation, ACC: TypeInformation&amp;#93;&lt;/span&gt;(&lt;br/&gt;
           name: String, function: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;T, ACC&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
         // check if class not Scala object&lt;br/&gt;
         checkNotSingleton(function.getClass)&lt;br/&gt;
         // check if class could be instantiated&lt;br/&gt;
         checkForInstantiation(function.getClass)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val typeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    +    val resultTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    +    val accTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;ACC&amp;#93;&lt;/span&gt;]&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // register in Table API&lt;br/&gt;
         functionCatalog.registerFunction(name, function.getClass)&lt;/p&gt;

&lt;p&gt;         // register in SQL API&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val sqlFunctions = createAggregateSqlFunction(name, function, typeInfo, typeFactory)&lt;br/&gt;
    +    val sqlFunctions = createAggregateSqlFunction(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Ping @fhueske , what do you think about this? &lt;/p&gt;</comment>
                            <comment id="16066800" author="githubbot" created="Wed, 28 Jun 2017 16:20:19 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r124570771&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r124570771&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/java/BatchTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -22,6 +22,7 @@ import org.apache.flink.api.java.typeutils.TypeExtractor&lt;br/&gt;
     import org.apache.flink.api.java.&lt;/p&gt;
{DataSet, ExecutionEnvironment}
&lt;p&gt;     import org.apache.flink.table.expressions.ExpressionParser&lt;br/&gt;
     import org.apache.flink.table.api._&lt;br/&gt;
    +import org.apache.flink.table.functions.utils.UserDefinedFunctionUtils&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    import is unused&lt;/p&gt;</comment>
                            <comment id="16066801" author="githubbot" created="Wed, 28 Jun 2017 16:20:19 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r124574280&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r124574280&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/expressions/aggregations.scala &amp;#8212;&lt;br/&gt;
    @@ -228,12 +228,16 @@ case class VarSamp(child: Expression) extends Aggregation {&lt;/p&gt;

&lt;p&gt;     case class AggFunctionCall(&lt;br/&gt;
         aggregateFunction: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +    resultTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +    accTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
         args: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;)&lt;br/&gt;
       extends Aggregation {&lt;/p&gt;

&lt;p&gt;       override private&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def children: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt; = args&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;override def resultType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = getResultTypeOfAggregateFunction(aggregateFunction)&lt;br/&gt;
    +  override def resultType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = getResultTypeOfAggregateFunction(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    should we call `getResultTypeOfAggregateFunction` directly in `UDAGGExpression.apply()`? &lt;br/&gt;
    Otherwise, we spread the inference of the function types to several places.&lt;/p&gt;</comment>
                            <comment id="16066802" author="githubbot" created="Wed, 28 Jun 2017 16:20:19 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r124578206&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r124578206&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/functions/utils/UserDefinedFunctionUtils.scala &amp;#8212;&lt;br/&gt;
    @@ -320,12 +348,20 @@ object UserDefinedFunctionUtils {&lt;br/&gt;
         } else if(extractedType != null) &lt;/p&gt;
{
           extractedType
         }
&lt;p&gt; else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TypeExtractor&lt;br/&gt;
    +      try {&lt;br/&gt;
    +        TypeExtractor
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The fallback type extraction of the accumulator type is different now. Before, we created an accumulator instance and called `TypeInformation.of(Any)`. Now, we try to extract it from the generics of the UDAGG.&lt;/p&gt;

&lt;p&gt;    @twalthr, does this method work as reliable as `TypeInformation.of(Any)`?&lt;/p&gt;</comment>
                            <comment id="16066803" author="githubbot" created="Wed, 28 Jun 2017 16:20:19 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r124575144&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r124575144&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/functions/utils/UserDefinedFunctionUtils.scala &amp;#8212;&lt;br/&gt;
    @@ -286,13 +286,21 @@ object UserDefinedFunctionUtils {&lt;br/&gt;
       def createAggregateSqlFunction(&lt;br/&gt;
           name: String,&lt;br/&gt;
           aggFunction: AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;_, _&amp;#93;&lt;/span&gt;,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;typeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      extractedResultTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      accTypeInfo: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
           typeFactory: FlinkTypeFactory)&lt;br/&gt;
       : SqlFunction = {&lt;br/&gt;
         //check if a qualified accumulate method exists before create Sql function&lt;br/&gt;
         checkAndExtractMethods(aggFunction, &quot;accumulate&quot;)&lt;/li&gt;
	&lt;li&gt;val resultType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = getResultTypeOfAggregateFunction(aggFunction, typeInfo)&lt;/li&gt;
	&lt;li&gt;AggSqlFunction(name, aggFunction, resultType, typeFactory, aggFunction.requiresOver)&lt;br/&gt;
    +    val resultType = getResultTypeOfAggregateFunction(aggFunction, extractedResultTypeInfo)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    `getResultTypeOfAggregateFunction` was called before in `TableEnvironment`. Can we remove it here? If not, we also might want to double check the acc type.&lt;/p&gt;</comment>
                            <comment id="16066804" author="githubbot" created="Wed, 28 Jun 2017 16:20:19 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r124570840&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r124570840&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/java/StreamTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -27,6 +27,8 @@ import org.apache.flink.streaming.api.datastream.DataStream&lt;br/&gt;
     import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment&lt;br/&gt;
     import &lt;em&gt;root&lt;/em&gt;.java.lang.&lt;/p&gt;
{Boolean =&amp;gt; JBool}

&lt;p&gt;    +import org.apache.flink.table.functions.utils.UserDefinedFunctionUtils&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    unused import&lt;/p&gt;</comment>
                            <comment id="16067649" author="githubbot" created="Thu, 29 Jun 2017 03:17:10 +0000"  >&lt;p&gt;Github user wuchong commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r124704209&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r124704209&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/functions/utils/UserDefinedFunctionUtils.scala &amp;#8212;&lt;br/&gt;
    @@ -320,12 +348,20 @@ object UserDefinedFunctionUtils {&lt;br/&gt;
         } else if(extractedType != null) &lt;/p&gt;
{
           extractedType
         }
&lt;p&gt; else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TypeExtractor&lt;br/&gt;
    +      try {&lt;br/&gt;
    +        TypeExtractor
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I think it is more safe than `TypeInformation.of(Any)`, because `TypeInformation.of(Any)` can only works for non-generic types. &lt;/p&gt;

&lt;p&gt;    For example: &lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    public class UDAF extends AggregateFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;Tuple2&amp;lt;String, Long&amp;gt;, Long&amp;#93;&lt;/span&gt; {&lt;br/&gt;
        public Long createAccumulator() &lt;/p&gt;
{...}&lt;br/&gt;
        public Tuple2&amp;lt;String, Long&amp;gt; getValue(Long acc) {...}
&lt;p&gt;    }&lt;br/&gt;
    ```&lt;br/&gt;
    For the given UDAF, the return type is a generic type `Tuple2&amp;lt;String, Long&amp;gt;`. We can&apos;t extract the return type  from an instance of Tuple2, because of Java type erasure. But we can extract it from the type hierarchy of UDAF class. &lt;/p&gt;

&lt;p&gt;    Am I right, @twalthr ?&lt;/p&gt;



&lt;p&gt;    ```&lt;/p&gt;



</comment>
                            <comment id="16067747" author="githubbot" created="Thu, 29 Jun 2017 05:12:29 +0000"  >&lt;p&gt;Github user wuchong commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Comments addressed&lt;/p&gt;</comment>
                            <comment id="16074755" author="githubbot" created="Wed, 5 Jul 2017 13:33:20 +0000"  >&lt;p&gt;Github user wuchong commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I have rebased the code and updated.  Would you like to have a look again? @fhueske  @twalthr @sunjincheng121 &lt;/p&gt;</comment>
                            <comment id="16082292" author="githubbot" created="Tue, 11 Jul 2017 14:35:42 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r126702994&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r126702994&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/functions/utils/UserDefinedFunctionUtils.scala &amp;#8212;&lt;br/&gt;
    @@ -320,12 +347,20 @@ object UserDefinedFunctionUtils {&lt;br/&gt;
         } else if(extractedType != null) &lt;/p&gt;
{
    --- End diff --
    
    +space `}
&lt;p&gt; else if (extractedType`&lt;/p&gt;</comment>
                            <comment id="16082293" author="githubbot" created="Tue, 11 Jul 2017 14:35:42 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r126706300&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r126706300&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/test/java/org/apache/flink/table/api/java/utils/UserDefinedAggFunctions.java &amp;#8212;&lt;br/&gt;
    @@ -59,7 +59,7 @@ public boolean requiresOver() {&lt;br/&gt;
     	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Accumulator for WeightedAvg.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static class WeightedAvgAccum extends Tuple2&amp;lt;Long, Integer&amp;gt; {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Why do you change the type of this accumulator?&lt;/p&gt;</comment>
                            <comment id="16083456" author="githubbot" created="Wed, 12 Jul 2017 05:13:26 +0000"  >&lt;p&gt;Github user wuchong commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r126865636&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r126865636&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/test/java/org/apache/flink/table/api/java/utils/UserDefinedAggFunctions.java &amp;#8212;&lt;br/&gt;
    @@ -59,7 +59,7 @@ public boolean requiresOver() {&lt;br/&gt;
     	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Accumulator for WeightedAvg.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static class WeightedAvgAccum extends Tuple2&amp;lt;Long, Integer&amp;gt; {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    TypeExtractor will recognize `WeightedAvgAccum` as a `TupleType` which will ignore the `sum` and `count` fields when de/serialize. So I changed it as a POJO class. This should not be included in this PR. But I fixed it when I find it.&lt;/p&gt;</comment>
                            <comment id="16083594" author="githubbot" created="Wed, 12 Jul 2017 07:42:03 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105#discussion_r126883954&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105#discussion_r126883954&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/test/java/org/apache/flink/table/api/java/utils/UserDefinedAggFunctions.java &amp;#8212;&lt;br/&gt;
    @@ -59,7 +59,7 @@ public boolean requiresOver() {&lt;br/&gt;
     	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Accumulator for WeightedAvg.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static class WeightedAvgAccum extends Tuple2&amp;lt;Long, Integer&amp;gt; {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Yes, you are right. Either we change the type or we touch the code and use `acc.f0` instead of `acc.sum` and `acc.f1` instead of `acc.count`.&lt;/p&gt;

&lt;p&gt;    Let&apos;s go with your approach.&lt;/p&gt;</comment>
                            <comment id="16083598" author="githubbot" created="Wed, 12 Jul 2017 07:43:36 +0000"  >&lt;p&gt;Github user fhueske commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    +1 to merge&lt;/p&gt;</comment>
                            <comment id="16083657" author="githubbot" created="Wed, 12 Jul 2017 08:47:18 +0000"  >&lt;p&gt;Github user wuchong commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    merging... &lt;/p&gt;</comment>
                            <comment id="16085052" author="githubbot" created="Thu, 13 Jul 2017 02:17:56 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4105&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4105&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16085053" author="jark" created="Thu, 13 Jul 2017 02:18:21 +0000"  >&lt;p&gt;Fixed in 59463278a868f37028a3391a9b9505a77584e0f7&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 18 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3g587:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>