<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:31:27 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-8203] Make schema definition of DataStream/DataSet to Table conversion more flexible</title>
                <link>https://issues.apache.org/jira/browse/FLINK-8203</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;When converting or registering a &lt;tt&gt;DataStream&lt;/tt&gt; or &lt;tt&gt;DataSet&lt;/tt&gt; as &lt;tt&gt;Table&lt;/tt&gt;, the schema of the table can be defined (by default it is extracted from the &lt;tt&gt;TypeInformation&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;The schema needs to be manually specified to select (project) fields, rename fields, or define time attributes. Right now, there are several limitations how the fields can be defined that also depend on the type of the &lt;tt&gt;DataStream&lt;/tt&gt; / &lt;tt&gt;DataSet&lt;/tt&gt;. Types with explicit field ordering (e.g., tuples, case classes, Row) require schema definition based on the position of fields. Pojo types which have no fixed order of fields, require to refer to fields by name. Moreover, there are several restrictions on how time attributes can be defined, e.g., event time attribute must replace an existing field or be appended and proctime attributes must be appended.&lt;/p&gt;

&lt;p&gt;I think we can make the schema definition more flexible and provide two modes:&lt;/p&gt;

&lt;p&gt;1. Reference input fields by name: All fields in the schema definition are referenced by name (and possibly renamed using an alias (&lt;tt&gt;as&lt;/tt&gt;). In this mode, fields can be reordered and projected out. Moreover, we can define proctime and eventtime attributes at arbitrary positions using arbitrary names (except those that existing the result schema). This mode can be used for any input type, including POJOs. This mode is used if all field references exist in the input type.&lt;/p&gt;

&lt;p&gt;2. Reference input fields by position: Field references might not refer to existing fields in the input type. In this mode, fields are simply renamed. Event-time attributes can replace the field on their position in the input data (if it is of correct type) or be appended at the end. Proctime attributes must be appended at the end. This mode can only be used if the input type has a defined field order (tuple, case class, Row).&lt;/p&gt;

&lt;p&gt;We need to add more tests the check for all combinations of input types and schema definition modes.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13122822">FLINK-8203</key>
            <summary>Make schema definition of DataStream/DataSet to Table conversion more flexible</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="twalthr">Timo Walther</assignee>
                                    <reporter username="fhueske">Fabian Hueske</reporter>
                        <labels>
                    </labels>
                <created>Tue, 5 Dec 2017 10:17:23 +0000</created>
                <updated>Fri, 5 Jan 2018 17:40:54 +0000</updated>
                            <resolved>Fri, 5 Jan 2018 17:39:57 +0000</resolved>
                                    <version>1.4.0</version>
                    <version>1.5.0</version>
                                    <fixVersion>1.5.0</fixVersion>
                                    <component>Table SQL / API</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="16281731" author="githubbot" created="Thu, 7 Dec 2017 11:30:39 +0000"  >&lt;p&gt;GitHub user twalthr opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8203&quot; title=&quot;Make schema definition of DataStream/DataSet to Table conversion more flexible&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8203&quot;&gt;&lt;del&gt;FLINK-8203&lt;/del&gt;&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7681&quot; title=&quot;Support arbitrary TypeInformation in Table API&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7681&quot;&gt;&lt;del&gt;FLINK-7681&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;table&amp;#93;&lt;/span&gt; Make schema definition of DataStream/DataSet to Table conversion more flexible&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This PR makes the schema definition more flexible. It add two ways of adding schema information:&lt;/p&gt;

&lt;p&gt;    Reference input fields by name:&lt;br/&gt;
    All fields in the schema definition are referenced by name&lt;br/&gt;
    (and possibly renamed using an alias (as). In this mode, fields can be reordered and&lt;br/&gt;
    projected out. Moreover, we can define proctime and rowtime attributes at arbitrary&lt;br/&gt;
    positions using arbitrary names (except those that exist in the result schema). This mode&lt;br/&gt;
    can be used for any input type, including POJOs.&lt;/p&gt;

&lt;p&gt;    Reference input fields by position:&lt;br/&gt;
    Field references must refer to existing fields in the input type (except for&lt;br/&gt;
    renaming with alias (as)). In this mode, fields are simply renamed. Event-time attributes can&lt;br/&gt;
    replace the field on their position in the input data (if it is of correct type) or be&lt;br/&gt;
    appended at the end. Proctime attributes must be appended at the end. This mode can only be&lt;br/&gt;
    used if the input type has a defined field order (tuple, case class, Row) and no of fields&lt;br/&gt;
    references a field of the input type.&lt;/p&gt;

&lt;p&gt;    It also allows any TypeInformation. In the past, this behavior was not consistent.&lt;/p&gt;

&lt;p&gt;    I will add some paragraphs to the documentation, once we agreed on this new behavior.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    Various changes in `TableEnvironment`, `Stream/BatchTableEnvironment`, and pattern matches that referenced `AtomicType` instead of `TypeInformation`.&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    See TableEnvironment tests.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): no&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: no&lt;/li&gt;
	&lt;li&gt;The serializers: no&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): no&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: no&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: no&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? no&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? will document it later&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/twalthr/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/twalthr/flink&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8203&quot; title=&quot;Make schema definition of DataStream/DataSet to Table conversion more flexible&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8203&quot;&gt;&lt;del&gt;FLINK-8203&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #5132&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 38562e1dcc5416996ad5531b901f89e4b868e5eb&lt;br/&gt;
Author: twalthr &amp;lt;twalthr@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-12-07T10:52:28Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8203&quot; title=&quot;Make schema definition of DataStream/DataSet to Table conversion more flexible&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8203&quot;&gt;&lt;del&gt;FLINK-8203&lt;/del&gt;&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7681&quot; title=&quot;Support arbitrary TypeInformation in Table API&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7681&quot;&gt;&lt;del&gt;FLINK-7681&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;table&amp;#93;&lt;/span&gt; Make schema definition of DataStream/DataSet to Table conversion more flexible&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16312182" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159758396&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159758396&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -768,6 +768,39 @@ abstract class TableEnvironment(val config: TableConfig) &lt;/p&gt;
{
         frameworkConfig
       }

&lt;p&gt;    +  /**&lt;br/&gt;
    +    * Reference input fields by name:&lt;br/&gt;
    +    * All fields in the schema definition are referenced by name&lt;br/&gt;
    +    * (and possibly renamed using an alias (as). In this mode, fields can be reordered and&lt;br/&gt;
    +    * projected out. Moreover, we can define proctime and rowtime attributes at arbitrary&lt;br/&gt;
    +    * positions using arbitrary names (except those that exist in the result schema). This mode&lt;br/&gt;
    +    * can be used for any input type, including POJOs.&lt;br/&gt;
    +    *&lt;br/&gt;
    +    * Reference input fields by position:&lt;br/&gt;
    +    * Field references must refer to existing fields in the input type (except for&lt;br/&gt;
    +    * renaming with alias (as)). In this mode, fields are simply renamed. Event-time attributes can&lt;br/&gt;
    +    * replace the field on their position in the input data (if it is of correct type) or be&lt;br/&gt;
    +    * appended at the end. Proctime attributes must be appended at the end. This mode can only be&lt;br/&gt;
    +    * used if the input type has a defined field order (tuple, case class, Row) and no of fields&lt;br/&gt;
    +    * references a field of the input type.&lt;br/&gt;
    +    */&lt;br/&gt;
    +  protected def isReferenceByPosition(t: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;, fields: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;): Boolean = {&lt;br/&gt;
    +    if (t.isInstanceOf[PojoTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;]) &lt;/p&gt;
{
    +      return false
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    val inputNames = t match &lt;/p&gt;
{
    +      case ct: CompositeType[_] =&amp;gt; ct.getFieldNames
    +      case _ =&amp;gt; return false // atomic types are references by name
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    // use the by position mode if no of the fields exists in the input&lt;br/&gt;
    +    fields.forall {&lt;br/&gt;
    +      case UnresolvedFieldReference(name) =&amp;gt; !inputNames.contains(name)&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I had suggested to use ref-by-name if all field names of the schema are in the input type and ref-by-pos otherwise. This implementation is a bit different as it excludes cases where at least one but not all of the schema fields are in the input type. Hence, there schema mappings that cannot be resolved and will fail.&lt;/p&gt;

&lt;p&gt;    For example if we have a Tuple3 input type, we cannot name fields like `(&apos;f0, &apos;f1, &apos;myName)`. This breaks the current behavior. On the other hand, it prevents possibly confusing cases like `(&apos;f2, &apos;f0, &apos;myName)` where fields are renamed by position but the user might assume reordering instead of renaming.&lt;/p&gt;

&lt;p&gt;    Not sure what&apos;s the best strategy here, but I wanted to raise this point.&lt;/p&gt;</comment>
                            <comment id="16312183" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159761372&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159761372&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -791,92 +824,109 @@ abstract class TableEnvironment(val config: TableConfig) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns field names and field positions for a given [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] and [&lt;span class=&quot;error&quot;&gt;&amp;#91;Array&amp;#93;&lt;/span&gt;] of&lt;/li&gt;
	&lt;li&gt;[&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]. It does not handle time attributes but considers them in indices.&lt;br/&gt;
         *&lt;br/&gt;
    +    * @param isReferenceByPosition schema mode see [&lt;span class=&quot;error&quot;&gt;&amp;#91;isReferenceByPosition()&amp;#93;&lt;/span&gt;]&lt;/li&gt;
	&lt;li&gt;@param inputType The [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] against which the [&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]s are evaluated.&lt;/li&gt;
	&lt;li&gt;@param exprs     The expressions that define the field names.&lt;/li&gt;
	&lt;li&gt;@tparam A The type of the TypeInformation.&lt;/li&gt;
	&lt;li&gt;@return A tuple of two arrays holding the field names and corresponding field positions.&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +  protected def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +      isReferenceByPosition: Boolean,
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    why not call `isReferenceByPosition()` inside of `getFieldInfo()`? It has all required parameters. Moreover, we only need to call it for tuple-like types that can be resolved by pos or name.&lt;/p&gt;
</comment>
                            <comment id="16312184" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159757312&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159757312&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -768,6 +768,39 @@ abstract class TableEnvironment(val config: TableConfig) &lt;/p&gt;
{
         frameworkConfig
       }

&lt;p&gt;    +  /**&lt;br/&gt;
    +    * Reference input fields by name:&lt;br/&gt;
    +    * All fields in the schema definition are referenced by name&lt;br/&gt;
    +    * (and possibly renamed using an alias (as). In this mode, fields can be reordered and&lt;br/&gt;
    +    * projected out. Moreover, we can define proctime and rowtime attributes at arbitrary&lt;br/&gt;
    +    * positions using arbitrary names (except those that exist in the result schema). This mode&lt;br/&gt;
    +    * can be used for any input type, including POJOs.&lt;br/&gt;
    +    *&lt;br/&gt;
    +    * Reference input fields by position:&lt;br/&gt;
    +    * Field references must refer to existing fields in the input type (except for&lt;br/&gt;
    +    * renaming with alias (as)). In this mode, fields are simply renamed. Event-time attributes can&lt;br/&gt;
    +    * replace the field on their position in the input data (if it is of correct type) or be&lt;br/&gt;
    +    * appended at the end. Proctime attributes must be appended at the end. This mode can only be&lt;br/&gt;
    +    * used if the input type has a defined field order (tuple, case class, Row) and no of fields&lt;br/&gt;
    +    * references a field of the input type.&lt;br/&gt;
    +    */&lt;br/&gt;
    +  protected def isReferenceByPosition(t: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;, fields: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;): Boolean = {&lt;br/&gt;
    +    if (t.isInstanceOf[PojoTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;]) &lt;/p&gt;
{
    +      return false
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    val inputNames = t match {&lt;br/&gt;
    +      case ct: CompositeType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt; ct.getFieldNames&lt;br/&gt;
    +      case _ =&amp;gt; return false // atomic types are references by name&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    If atomic types are referenced by name, what&apos;s the name? Atomic types are neither referenced by position or name. Instead we can reference the field because there is only one field in the input.&lt;/p&gt;

&lt;p&gt;    Should we make this method only available for `CompositeType` by changing the type of `t` to `CompositeType`?&lt;/p&gt;
</comment>
                            <comment id="16312185" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159764095&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159764095&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -791,92 +824,109 @@ abstract class TableEnvironment(val config: TableConfig) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns field names and field positions for a given [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] and [&lt;span class=&quot;error&quot;&gt;&amp;#91;Array&amp;#93;&lt;/span&gt;] of&lt;/li&gt;
	&lt;li&gt;[&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]. It does not handle time attributes but considers them in indices.&lt;br/&gt;
         *&lt;br/&gt;
    +    * @param isReferenceByPosition schema mode see [&lt;span class=&quot;error&quot;&gt;&amp;#91;isReferenceByPosition()&amp;#93;&lt;/span&gt;]&lt;/li&gt;
	&lt;li&gt;@param inputType The [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] against which the [&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]s are evaluated.&lt;/li&gt;
	&lt;li&gt;@param exprs     The expressions that define the field names.&lt;/li&gt;
	&lt;li&gt;@tparam A The type of the TypeInformation.&lt;/li&gt;
	&lt;li&gt;@return A tuple of two arrays holding the field names and corresponding field positions.&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +  protected def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +      isReferenceByPosition: Boolean,&lt;br/&gt;
           inputType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;,&lt;br/&gt;
           exprs: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;)&lt;br/&gt;
         : (Array&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;, Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;) = {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         TableEnvironment.validateType(inputType)&lt;/p&gt;

&lt;p&gt;    +    def referenceByName(name: String, ct: CompositeType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;): Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +      val inputIdx = ct.getFieldIndex(name)&lt;br/&gt;
    +      if (inputIdx &amp;lt; 0) {&lt;br/&gt;
    +        throw new TableException(s&quot;$name is not a field of type $ct. &quot; +&lt;br/&gt;
    +                s&quot;Expected: ${ct.getFieldNames.mkString(&quot;, &quot;)}&quot;)&lt;br/&gt;
    +      } else &lt;/p&gt;
{
    +        Some((inputIdx, name))
    +      }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
         val indexedNames: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = inputType match {&lt;br/&gt;
    +&lt;br/&gt;
           case g: GenericTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; if g.getTypeClass == classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
             throw new TableException(&lt;br/&gt;
               &quot;An input of GenericTypeInfo&amp;lt;Row&amp;gt; cannot be converted to Table. &quot; +&lt;br/&gt;
                 &quot;Please specify the type of the input with a RowTypeInfo.&quot;)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;case a: AtomicType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt;&lt;/li&gt;
	&lt;li&gt;exprs.zipWithIndex flatMap 
{
    -          case (_: TimeAttribute, _) =&amp;gt;
    -            None
    -          case (UnresolvedFieldReference(name), idx) if idx &amp;gt; 0 =&amp;gt;
    -            // only accept the first field for an atomic type
    -            throw new TableException(&quot;Only the first field can reference an atomic type.&quot;)
    -          case (UnresolvedFieldReference(name), idx) =&amp;gt;
    -            // first field reference is mapped to atomic type
    -            Some((0, name))
    -          case _ =&amp;gt; throw new TableException(&quot;Field reference expression requested.&quot;)
    -        }
&lt;p&gt;    +&lt;br/&gt;
           case t: TupleTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
             exprs.zipWithIndex flatMap {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;case (UnresolvedFieldReference(name), idx) =&amp;gt;&lt;/li&gt;
	&lt;li&gt;Some((idx, name))&lt;/li&gt;
	&lt;li&gt;case (Alias(UnresolvedFieldReference(origName), name, _), _) =&amp;gt;&lt;br/&gt;
    +          case (UnresolvedFieldReference(name: String), idx) =&amp;gt;&lt;br/&gt;
    +            if (isReferenceByPosition) 
{
    +              Some((idx, name))
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +              referenceByName(name, t)
    +            }
&lt;p&gt;    +          case (Alias(UnresolvedFieldReference(origName), name: String, _), _) =&amp;gt;&lt;br/&gt;
                 val idx = t.getFieldIndex(origName)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    we can use `referenceByName()` here.&lt;/p&gt;
</comment>
                            <comment id="16312186" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159766790&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159766790&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -791,92 +824,109 @@ abstract class TableEnvironment(val config: TableConfig) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns field names and field positions for a given [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] and [&lt;span class=&quot;error&quot;&gt;&amp;#91;Array&amp;#93;&lt;/span&gt;] of&lt;/li&gt;
	&lt;li&gt;[&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]. It does not handle time attributes but considers them in indices.&lt;br/&gt;
         *&lt;br/&gt;
    +    * @param isReferenceByPosition schema mode see [&lt;span class=&quot;error&quot;&gt;&amp;#91;isReferenceByPosition()&amp;#93;&lt;/span&gt;]&lt;/li&gt;
	&lt;li&gt;@param inputType The [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] against which the [&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]s are evaluated.&lt;/li&gt;
	&lt;li&gt;@param exprs     The expressions that define the field names.&lt;/li&gt;
	&lt;li&gt;@tparam A The type of the TypeInformation.&lt;/li&gt;
	&lt;li&gt;@return A tuple of two arrays holding the field names and corresponding field positions.&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +  protected def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +      isReferenceByPosition: Boolean,&lt;br/&gt;
           inputType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;,&lt;br/&gt;
           exprs: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;)&lt;br/&gt;
         : (Array&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;, Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;) = {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         TableEnvironment.validateType(inputType)&lt;/p&gt;

&lt;p&gt;    +    def referenceByName(name: String, ct: CompositeType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;): Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +      val inputIdx = ct.getFieldIndex(name)&lt;br/&gt;
    +      if (inputIdx &amp;lt; 0) {&lt;br/&gt;
    +        throw new TableException(s&quot;$name is not a field of type $ct. &quot; +&lt;br/&gt;
    +                s&quot;Expected: ${ct.getFieldNames.mkString(&quot;, &quot;)}&quot;)&lt;br/&gt;
    +      } else &lt;/p&gt;
{
    +        Some((inputIdx, name))
    +      }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
         val indexedNames: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = inputType match {&lt;br/&gt;
    +&lt;br/&gt;
           case g: GenericTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; if g.getTypeClass == classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
             throw new TableException(&lt;br/&gt;
               &quot;An input of GenericTypeInfo&amp;lt;Row&amp;gt; cannot be converted to Table. &quot; +&lt;br/&gt;
                 &quot;Please specify the type of the input with a RowTypeInfo.&quot;)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;case a: AtomicType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt;&lt;/li&gt;
	&lt;li&gt;exprs.zipWithIndex flatMap 
{
    -          case (_: TimeAttribute, _) =&amp;gt;
    -            None
    -          case (UnresolvedFieldReference(name), idx) if idx &amp;gt; 0 =&amp;gt;
    -            // only accept the first field for an atomic type
    -            throw new TableException(&quot;Only the first field can reference an atomic type.&quot;)
    -          case (UnresolvedFieldReference(name), idx) =&amp;gt;
    -            // first field reference is mapped to atomic type
    -            Some((0, name))
    -          case _ =&amp;gt; throw new TableException(&quot;Field reference expression requested.&quot;)
    -        }
&lt;p&gt;    +&lt;br/&gt;
           case t: TupleTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
             exprs.zipWithIndex flatMap {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;case (UnresolvedFieldReference(name), idx) =&amp;gt;&lt;/li&gt;
	&lt;li&gt;Some((idx, name))&lt;/li&gt;
	&lt;li&gt;case (Alias(UnresolvedFieldReference(origName), name, _), _) =&amp;gt;&lt;br/&gt;
    +          case (UnresolvedFieldReference(name: String), idx) =&amp;gt;&lt;br/&gt;
    +            if (isReferenceByPosition) 
{
    +              Some((idx, name))
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +              referenceByName(name, t)
    +            }
&lt;p&gt;    +          case (Alias(UnresolvedFieldReference(origName), name: String, _), _) =&amp;gt;&lt;br/&gt;
                 val idx = t.getFieldIndex(origName)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    With this implementation, we allow for mixing of reference by position and reference by name if `as` is used.&lt;br/&gt;
    For example a `Tuple5` could be mapped like: `(&apos;a, &apos;b, &apos;f4 as &apos;c)`, where `a` is `f0`, `b` is `f1` and `c` is `f4`. Do we really want to support such mappings or would this be too error prone? &lt;/p&gt;

&lt;p&gt;    We could also prohibit `as` in ref-by-pos mode and thereby enforce ref-by-name like `(&apos;f0 as &apos;a, &apos;f1 as &apos;b, &apos;f4 as &apos;c)` which is more verbose but also more explicit, IMO.&lt;/p&gt;
</comment>
                            <comment id="16312187" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159772482&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159772482&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/StreamTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -414,11 +414,14 @@ abstract class StreamTableEnvironment(&lt;/p&gt;

&lt;p&gt;         val streamType = dataStream.getType&lt;/p&gt;

&lt;p&gt;    +    // determine schema definition mode (by position or by name)&lt;br/&gt;
    +    val isRefByPosition = isReferenceByPosition(streamType, fields)&lt;br/&gt;
    +&lt;br/&gt;
         // get field names and types for all non-replaced fields&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val (fieldNames, fieldIndexes) = getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;(streamType, fields)&lt;br/&gt;
    +    val (fieldNames, fieldIndexes) = getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;(isRefByPosition, streamType, fields)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // validate and extract time attributes&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val (rowtime, proctime) = validateAndExtractTimeAttributes(streamType, fields)&lt;br/&gt;
    +    val (rowtime, proctime) = validateAndExtractTimeAttributes(isRefByPosition, streamType, fields)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    call `isReferenceByPosition()` inside of `validateAndExtractTimeAttributes()`? It has all required parameters and the call is only required if `streamType` is a tuple-like type.&lt;/p&gt;</comment>
                            <comment id="16312188" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159767413&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159767413&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -791,92 +824,109 @@ abstract class TableEnvironment(val config: TableConfig) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns field names and field positions for a given [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] and [&lt;span class=&quot;error&quot;&gt;&amp;#91;Array&amp;#93;&lt;/span&gt;] of&lt;/li&gt;
	&lt;li&gt;[&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]. It does not handle time attributes but considers them in indices.&lt;br/&gt;
         *&lt;br/&gt;
    +    * @param isReferenceByPosition schema mode see [&lt;span class=&quot;error&quot;&gt;&amp;#91;isReferenceByPosition()&amp;#93;&lt;/span&gt;]&lt;/li&gt;
	&lt;li&gt;@param inputType The [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] against which the [&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]s are evaluated.&lt;/li&gt;
	&lt;li&gt;@param exprs     The expressions that define the field names.&lt;/li&gt;
	&lt;li&gt;@tparam A The type of the TypeInformation.&lt;/li&gt;
	&lt;li&gt;@return A tuple of two arrays holding the field names and corresponding field positions.&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +  protected def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +      isReferenceByPosition: Boolean,&lt;br/&gt;
           inputType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;,&lt;br/&gt;
           exprs: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;)&lt;br/&gt;
         : (Array&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;, Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;) = {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         TableEnvironment.validateType(inputType)&lt;/p&gt;

&lt;p&gt;    +    def referenceByName(name: String, ct: CompositeType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;): Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +      val inputIdx = ct.getFieldIndex(name)&lt;br/&gt;
    +      if (inputIdx &amp;lt; 0) {&lt;br/&gt;
    +        throw new TableException(s&quot;$name is not a field of type $ct. &quot; +&lt;br/&gt;
    +                s&quot;Expected: ${ct.getFieldNames.mkString(&quot;, &quot;)}&quot;)&lt;br/&gt;
    +      } else &lt;/p&gt;
{
    +        Some((inputIdx, name))
    +      }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
         val indexedNames: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = inputType match {&lt;br/&gt;
    +&lt;br/&gt;
           case g: GenericTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; if g.getTypeClass == classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
             throw new TableException(&lt;br/&gt;
               &quot;An input of GenericTypeInfo&amp;lt;Row&amp;gt; cannot be converted to Table. &quot; +&lt;br/&gt;
                 &quot;Please specify the type of the input with a RowTypeInfo.&quot;)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;case a: AtomicType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt;&lt;/li&gt;
	&lt;li&gt;exprs.zipWithIndex flatMap 
{
    -          case (_: TimeAttribute, _) =&amp;gt;
    -            None
    -          case (UnresolvedFieldReference(name), idx) if idx &amp;gt; 0 =&amp;gt;
    -            // only accept the first field for an atomic type
    -            throw new TableException(&quot;Only the first field can reference an atomic type.&quot;)
    -          case (UnresolvedFieldReference(name), idx) =&amp;gt;
    -            // first field reference is mapped to atomic type
    -            Some((0, name))
    -          case _ =&amp;gt; throw new TableException(&quot;Field reference expression requested.&quot;)
    -        }
&lt;p&gt;    +&lt;br/&gt;
           case t: TupleTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
             exprs.zipWithIndex flatMap {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;case (UnresolvedFieldReference(name), idx) =&amp;gt;&lt;/li&gt;
	&lt;li&gt;Some((idx, name))&lt;/li&gt;
	&lt;li&gt;case (Alias(UnresolvedFieldReference(origName), name, _), _) =&amp;gt;&lt;br/&gt;
    +          case (UnresolvedFieldReference(name: String), idx) =&amp;gt;&lt;br/&gt;
    +            if (isReferenceByPosition) 
{
    +              Some((idx, name))
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +              referenceByName(name, t)
    +            }
&lt;p&gt;    +          case (Alias(UnresolvedFieldReference(origName), name: String, _), _) =&amp;gt;&lt;br/&gt;
                 val idx = t.getFieldIndex(origName)&lt;br/&gt;
                 if (idx &amp;lt; 0) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;throw new TableException(s&quot;$origName is not a field of type $t&quot;)&lt;br/&gt;
    +              throw new TableException(s&quot;$origName is not a field of type $t. &quot; +&lt;br/&gt;
    +                s&quot;Expected: ${t.getFieldNames.mkString(&quot;, &quot;)}&quot;)&lt;br/&gt;
                 }&lt;br/&gt;
                 Some((idx, name))&lt;br/&gt;
               case (_: TimeAttribute, _) =&amp;gt;&lt;br/&gt;
                 None&lt;br/&gt;
               case _ =&amp;gt; throw new TableException(&lt;br/&gt;
                 &quot;Field reference expression or alias on field expression expected.&quot;)&lt;br/&gt;
             }&lt;br/&gt;
    +&lt;br/&gt;
           case c: CaseClassTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; =&amp;gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Can we merge the cases of `TupleTypeInfo`, `CaseClassTypeInfo`, and `RowTypeInfo` by checking for &lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    case t: TupleTypeInfoBase&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; if t.isInstanceOf[TupleTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;] ||&lt;br/&gt;
            t.isInstanceOf[CaseClassTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;] || t.isInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;RowTypeInfo&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
    ```&lt;/p&gt;
</comment>
                            <comment id="16312189" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159777530&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159777530&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala &amp;#8212;&lt;br/&gt;
    @@ -18,231 +18,574 @@&lt;/p&gt;

&lt;p&gt;     package org.apache.flink.table.api&lt;/p&gt;

&lt;p&gt;    -import org.apache.flink.api.common.typeinfo.BasicTypeInfo._&lt;br/&gt;
     import org.apache.flink.api.common.typeinfo.TypeInformation&lt;br/&gt;
    -import org.apache.flink.api.java.typeutils.&lt;/p&gt;
{GenericTypeInfo, RowTypeInfo, TupleTypeInfo, TypeExtractor}
&lt;p&gt;     import org.apache.flink.api.scala._&lt;br/&gt;
    -import org.apache.flink.table.expressions.&lt;/p&gt;
{Alias, UnresolvedFieldReference}
&lt;p&gt;    -import org.apache.flink.table.runtime.types.CRowTypeInfo&lt;br/&gt;
    -import org.apache.flink.table.utils.&lt;/p&gt;
{MockTableEnvironment, TableTestBase}
&lt;p&gt;    +import org.apache.flink.table.api.TableEnvironmentTest._&lt;br/&gt;
    +import org.apache.flink.table.api.Types._&lt;br/&gt;
    +import org.apache.flink.table.api.scala._&lt;br/&gt;
    +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo.&lt;/p&gt;
{PROCTIME_INDICATOR =&amp;gt; PROCTIME}
&lt;p&gt;    +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo.&lt;/p&gt;
{ROWTIME_INDICATOR =&amp;gt; ROWTIME}
&lt;p&gt;    +import org.apache.flink.table.utils.TableTestBase&lt;br/&gt;
     import org.apache.flink.types.Row&lt;br/&gt;
    -import org.junit.Assert.assertEquals&lt;br/&gt;
    +import org.apache.flink.api.java.tuple.&lt;/p&gt;
{Tuple3 =&amp;gt; JTuple3}
&lt;p&gt;    +import org.apache.flink.api.java.typeutils.GenericTypeInfo&lt;br/&gt;
    +import org.apache.flink.api.scala.typeutils.UnitTypeInfo&lt;br/&gt;
     import org.junit.Test&lt;/p&gt;

&lt;p&gt;     class TableEnvironmentTest extends TableTestBase {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val tEnv = new MockTableEnvironment&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val tupleType = new TupleTypeInfo(&lt;/li&gt;
	&lt;li&gt;INT_TYPE_INFO,&lt;/li&gt;
	&lt;li&gt;STRING_TYPE_INFO,&lt;/li&gt;
	&lt;li&gt;DOUBLE_TYPE_INFO)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val rowType = new RowTypeInfo(INT_TYPE_INFO, STRING_TYPE_INFO,DOUBLE_TYPE_INFO)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val cRowType = new CRowTypeInfo(rowType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val caseClassType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;CClass&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;CClass&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val pojoType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;PojoClass&amp;#93;&lt;/span&gt; = TypeExtractor.createTypeInfo(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;PojoClass&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val atomicType = INT_TYPE_INFO&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val genericRowType = new GenericTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;br/&gt;
    +  // schema definition by position&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoRow(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(rowType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testProjectByPosition(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a, &apos;b, &apos;c),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a, &apos;b),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable(&apos;a, &apos;b, &apos;c)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;a, &apos;b)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;a)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoRowNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;rowType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithAddingTimeAttributesByPosition(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c , &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoTuple(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(tupleType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamAliasWithReplacingTimeAttributesByPosition(): Unit = {&lt;br/&gt;
    +    val util = streamTestUtil()&lt;br/&gt;
    +&lt;br/&gt;
    +    // case class&lt;br/&gt;
    +    util.verifySchema(&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;CClassWithTime&amp;#93;&lt;/span&gt;(&apos;a, &apos;b.rowtime, &apos;c),&lt;br/&gt;
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))&lt;br/&gt;
    +&lt;br/&gt;
    +    util.verifySchema(&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;CClassWithTime&amp;#93;&lt;/span&gt;(&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    which field does `&apos;b` reference? We could do the same with `&apos;new.rowtime`, right?&lt;/p&gt;</comment>
                            <comment id="16312190" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159779000&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159779000&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala &amp;#8212;&lt;br/&gt;
    @@ -18,231 +18,574 @@&lt;/p&gt;

&lt;p&gt;     package org.apache.flink.table.api&lt;/p&gt;

&lt;p&gt;    -import org.apache.flink.api.common.typeinfo.BasicTypeInfo._&lt;br/&gt;
     import org.apache.flink.api.common.typeinfo.TypeInformation&lt;br/&gt;
    -import org.apache.flink.api.java.typeutils.&lt;/p&gt;
{GenericTypeInfo, RowTypeInfo, TupleTypeInfo, TypeExtractor}
&lt;p&gt;     import org.apache.flink.api.scala._&lt;br/&gt;
    -import org.apache.flink.table.expressions.&lt;/p&gt;
{Alias, UnresolvedFieldReference}
&lt;p&gt;    -import org.apache.flink.table.runtime.types.CRowTypeInfo&lt;br/&gt;
    -import org.apache.flink.table.utils.&lt;/p&gt;
{MockTableEnvironment, TableTestBase}
&lt;p&gt;    +import org.apache.flink.table.api.TableEnvironmentTest._&lt;br/&gt;
    +import org.apache.flink.table.api.Types._&lt;br/&gt;
    +import org.apache.flink.table.api.scala._&lt;br/&gt;
    +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo.&lt;/p&gt;
{PROCTIME_INDICATOR =&amp;gt; PROCTIME}
&lt;p&gt;    +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo.&lt;/p&gt;
{ROWTIME_INDICATOR =&amp;gt; ROWTIME}
&lt;p&gt;    +import org.apache.flink.table.utils.TableTestBase&lt;br/&gt;
     import org.apache.flink.types.Row&lt;br/&gt;
    -import org.junit.Assert.assertEquals&lt;br/&gt;
    +import org.apache.flink.api.java.tuple.&lt;/p&gt;
{Tuple3 =&amp;gt; JTuple3}
&lt;p&gt;    +import org.apache.flink.api.java.typeutils.GenericTypeInfo&lt;br/&gt;
    +import org.apache.flink.api.scala.typeutils.UnitTypeInfo&lt;br/&gt;
     import org.junit.Test&lt;/p&gt;

&lt;p&gt;     class TableEnvironmentTest extends TableTestBase {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val tEnv = new MockTableEnvironment&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val tupleType = new TupleTypeInfo(&lt;/li&gt;
	&lt;li&gt;INT_TYPE_INFO,&lt;/li&gt;
	&lt;li&gt;STRING_TYPE_INFO,&lt;/li&gt;
	&lt;li&gt;DOUBLE_TYPE_INFO)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val rowType = new RowTypeInfo(INT_TYPE_INFO, STRING_TYPE_INFO,DOUBLE_TYPE_INFO)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val cRowType = new CRowTypeInfo(rowType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val caseClassType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;CClass&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;CClass&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val pojoType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;PojoClass&amp;#93;&lt;/span&gt; = TypeExtractor.createTypeInfo(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;PojoClass&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val atomicType = INT_TYPE_INFO&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val genericRowType = new GenericTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;br/&gt;
    +  // schema definition by position&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoRow(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(rowType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testProjectByPosition(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a, &apos;b, &apos;c),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a, &apos;b),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable(&apos;a, &apos;b, &apos;c)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;a, &apos;b)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;a)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoRowNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;rowType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithAddingTimeAttributesByPosition(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c , &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoTuple(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(tupleType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamAliasWithReplacingTimeAttributesByPosition(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;a, &apos;b.rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b.rowtime, &apos;c)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, (&apos;b as &apos;new).rowtime, &apos;c)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;def testGetFieldInfoCClass(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(caseClassType)&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;br/&gt;
    +  // schema definition by name&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;cf1&quot;, &quot;cf2&quot;, &quot;cf3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  @Test&lt;br/&gt;
    +  def testProjectByName(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // atomic
    +      util.verifySchema(
    +        util.addTable[Int](),
    +        Seq(&quot;f0&quot; -&amp;gt; INT))
    +
    +      util.verifySchema(
    +        util.addTable[Int](&apos;myint),
    +        Seq(&quot;myint&quot; -&amp;gt; INT))
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf2&quot; -&amp;gt; STRING, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf1, &apos;cf2),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf2&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf1, &apos;cf3),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf3, &apos;cf1),
    +        Seq(&quot;cf3&quot; -&amp;gt; DOUBLE, &quot;cf1&quot; -&amp;gt; INT))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable()(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf2&quot; -&amp;gt; STRING, &quot;rf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;rf1, &apos;rf2)(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf2&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;rf1, &apos;rf3)(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;rf3, &apos;rf1)(TEST_ROW),
    +        Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f1&quot; -&amp;gt; STRING, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f1),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f1&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f2),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f2, &apos;f0),
    +        Seq(&quot;f2&quot; -&amp;gt; DOUBLE, &quot;f0&quot; -&amp;gt; INT))
    +
    +      // pojo
    +      util.verifySchema(
    +        util.addTable[PojoClass](),
    +        Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf2&quot; -&amp;gt; STRING, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[PojoClass](&apos;pf1, &apos;pf2),
    +        Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf2&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[PojoClass](&apos;pf1, &apos;pf3),
    +        Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[PojoClass](&apos;pf3, &apos;pf1),
    +        Seq(&quot;pf3&quot; -&amp;gt; DOUBLE, &quot;pf1&quot; -&amp;gt; INT))
    +
    +      // generic
    +      util.verifySchema(
    +        util.addTable[Class[_]](&apos;mygeneric),
    +        Seq(&quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +      util.verifySchema(
    +        util.addTable[Class[_]](),
    +        Seq(&quot;f0&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +      // any type info
    +      util.verifySchema(
    +        util.addTable[Unit](),
    +        Seq(&quot;f0&quot; -&amp;gt; new UnitTypeInfo()))
    +
    +      util.verifySchema(
    +        util.addTable[Unit](&apos;unit),
    +        Seq(&quot;unit&quot; -&amp;gt; new UnitTypeInfo()))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoPojo(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(pojoType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;pf1&quot;, &quot;pf2&quot;, &quot;pf3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithAddingTimeAttributesByName(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // atomic
    +    util.verifySchema(
    +      util.addTable[Int](&apos;proctime.proctime, &apos;myint),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;myint&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[Int](&apos;rowtime.rowtime, &apos;myint),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;myint&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[Int](&apos;myint, &apos;proctime.proctime),
    +      Seq(&quot;myint&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[Int](&apos;myint, &apos;rowtime.rowtime),
    +      Seq(&quot;myint&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;proctime.proctime, &apos;cf1, &apos;cf3),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;rowtime.rowtime, &apos;cf3, &apos;cf1),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;cf3&quot; -&amp;gt; DOUBLE, &quot;cf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf1, &apos;proctime.proctime, &apos;cf3),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf3, &apos;rowtime.rowtime, &apos;cf1),
    +      Seq(&quot;cf3&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;cf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf1, &apos;cf3, &apos;proctime.proctime),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf3, &apos;cf1, &apos;rowtime.rowtime),
    +      Seq(&quot;cf3&quot; -&amp;gt; DOUBLE, &quot;cf1&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;proctime.proctime, &apos;rf1, &apos;rf3)(TEST_ROW),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rowtime.rowtime, &apos;rf3, &apos;rf1)(TEST_ROW),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;proctime.proctime, &apos;rf1)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;rf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;rowtime.rowtime, &apos;rf1)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;rf1&quot; -&amp;gt; INT))
    +
    +        util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;rf1, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +        util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;rf1, &apos;rowtime.rowtime)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;proctime.proctime, &apos;f0, &apos;f2),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;rowtime.rowtime, &apos;f2, &apos;f0),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;f2&quot; -&amp;gt; DOUBLE, &quot;f0&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;proctime.proctime, &apos;f2),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f2, &apos;rowtime.rowtime, &apos;f0),
    +      Seq(&quot;f2&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;f0&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f2, &apos;proctime.proctime),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f2, &apos;f0, &apos;rowtime.rowtime),
    +      Seq(&quot;f2&quot; -&amp;gt; DOUBLE, &quot;f0&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // pojo
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;proctime.proctime, &apos;pf1, &apos;pf3),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;pf1&quot; -&amp;gt; INT, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;rowtime.rowtime, &apos;pf3, &apos;pf1),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;pf3&quot; -&amp;gt; DOUBLE, &quot;pf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf1, &apos;proctime.proctime, &apos;pf3),
    +      Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf3, &apos;rowtime.rowtime, &apos;pf1),
    +      Seq(&quot;pf3&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;pf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf1, &apos;pf3, &apos;proctime.proctime),
    +      Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf3&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf3, &apos;pf1, &apos;rowtime.rowtime),
    +      Seq(&quot;pf3&quot; -&amp;gt; DOUBLE, &quot;pf1&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // generic
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;proctime.proctime, &apos;mygeneric),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;rowtime.rowtime, &apos;mygeneric),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;mygeneric, &apos;proctime.proctime),
    +      Seq(&quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]]), &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;mygeneric, &apos;rowtime.rowtime),
    +      Seq(&quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]]), &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // any type info
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;proctime.proctime, &apos;unit),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;unit&quot; -&amp;gt; new UnitTypeInfo()))
    +
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;rowtime.rowtime, &apos;unit),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;unit&quot; -&amp;gt; new UnitTypeInfo()))
    +
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;unit, &apos;proctime.proctime),
    +      Seq(&quot;unit&quot; -&amp;gt; new UnitTypeInfo(), &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;unit, &apos;rowtime.rowtime),
    +      Seq(&quot;unit&quot; -&amp;gt; new UnitTypeInfo(), &quot;rowtime&quot; -&amp;gt; ROWTIME))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoAtomic(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(atomicType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithReplacingTimeAttributesByName(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // atomic
    +    util.verifySchema(
    +      util.addTable[Int](&apos;myint.proctime),
    +      Seq(&quot;myint&quot; -&amp;gt; PROCTIME))
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;cf1, &apos;cf3.proctime, &apos;cf2),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; PROCTIME, &quot;cf2&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;cf1, &apos;cf3.rowtime, &apos;cf2),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; ROWTIME, &quot;cf2&quot; -&amp;gt; LONG))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;rf1, &apos;rf3.proctime, &apos;rf2)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; PROCTIME, &quot;rf2&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf1, &apos;rf3.rowtime, &apos;rf2)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; ROWTIME, &quot;rf2&quot; -&amp;gt; LONG))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;f0, &apos;f2.proctime, &apos;f1),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; PROCTIME, &quot;f1&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;f0, &apos;f2.rowtime, &apos;f1),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; ROWTIME, &quot;f1&quot; -&amp;gt; LONG))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoTupleNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;tupleType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testAliasByName(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // atomic
    +      util.verifySchema(
    +        util.addTable[Int](&apos;myint as &apos;new),
    +        Seq(&quot;new&quot; -&amp;gt; INT))
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf1, &apos;cf3 as &apos;new, &apos;cf2),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; DOUBLE, &quot;cf2&quot; -&amp;gt; STRING))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable(&apos;rf1, &apos;rf3 as &apos;new, &apos;rf2)(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; DOUBLE, &quot;rf2&quot; -&amp;gt; STRING))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f2 as &apos;new, &apos;f1),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; DOUBLE, &quot;f1&quot; -&amp;gt; STRING))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoCClassNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;caseClassType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamAliasWithAddingTimeAttributesByName(): Unit = {&lt;br/&gt;
    +    val util = streamTestUtil()&lt;br/&gt;
    +&lt;br/&gt;
    +    // atomic&lt;br/&gt;
    +    util.verifySchema(&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;((&apos;myint as &apos;new).proctime),&lt;br/&gt;
    +      Seq(&quot;new&quot; -&amp;gt; PROCTIME))&lt;br/&gt;
    +&lt;br/&gt;
    +    // case class&lt;br/&gt;
    +    util.verifySchema(&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;CClassWithTime&amp;#93;&lt;/span&gt;(&apos;cf1, (&apos;newnew as &apos;new).proctime, &apos;cf2),
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I think we should add checks that `&apos;newnew` is actually present in the schema. For `proctime` `as` should be forbidden, IMO. &lt;/p&gt;</comment>
                            <comment id="16312191" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159766942&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159766942&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -791,92 +824,109 @@ abstract class TableEnvironment(val config: TableConfig) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns field names and field positions for a given [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] and [&lt;span class=&quot;error&quot;&gt;&amp;#91;Array&amp;#93;&lt;/span&gt;] of&lt;/li&gt;
	&lt;li&gt;[&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]. It does not handle time attributes but considers them in indices.&lt;br/&gt;
         *&lt;br/&gt;
    +    * @param isReferenceByPosition schema mode see [&lt;span class=&quot;error&quot;&gt;&amp;#91;isReferenceByPosition()&amp;#93;&lt;/span&gt;]&lt;/li&gt;
	&lt;li&gt;@param inputType The [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] against which the [&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]s are evaluated.&lt;/li&gt;
	&lt;li&gt;@param exprs     The expressions that define the field names.&lt;/li&gt;
	&lt;li&gt;@tparam A The type of the TypeInformation.&lt;/li&gt;
	&lt;li&gt;@return A tuple of two arrays holding the field names and corresponding field positions.&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +  protected def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +      isReferenceByPosition: Boolean,&lt;br/&gt;
           inputType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;,&lt;br/&gt;
           exprs: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;)&lt;br/&gt;
         : (Array&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;, Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;) = {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         TableEnvironment.validateType(inputType)&lt;/p&gt;

&lt;p&gt;    +    def referenceByName(name: String, ct: CompositeType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;): Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +      val inputIdx = ct.getFieldIndex(name)&lt;br/&gt;
    +      if (inputIdx &amp;lt; 0) {&lt;br/&gt;
    +        throw new TableException(s&quot;$name is not a field of type $ct. &quot; +&lt;br/&gt;
    +                s&quot;Expected: ${ct.getFieldNames.mkString(&quot;, &quot;)}&quot;)&lt;br/&gt;
    +      } else &lt;/p&gt;
{
    +        Some((inputIdx, name))
    +      }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
         val indexedNames: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = inputType match {&lt;br/&gt;
    +&lt;br/&gt;
           case g: GenericTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; if g.getTypeClass == classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
             throw new TableException(&lt;br/&gt;
               &quot;An input of GenericTypeInfo&amp;lt;Row&amp;gt; cannot be converted to Table. &quot; +&lt;br/&gt;
                 &quot;Please specify the type of the input with a RowTypeInfo.&quot;)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;case a: AtomicType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt;&lt;/li&gt;
	&lt;li&gt;exprs.zipWithIndex flatMap 
{
    -          case (_: TimeAttribute, _) =&amp;gt;
    -            None
    -          case (UnresolvedFieldReference(name), idx) if idx &amp;gt; 0 =&amp;gt;
    -            // only accept the first field for an atomic type
    -            throw new TableException(&quot;Only the first field can reference an atomic type.&quot;)
    -          case (UnresolvedFieldReference(name), idx) =&amp;gt;
    -            // first field reference is mapped to atomic type
    -            Some((0, name))
    -          case _ =&amp;gt; throw new TableException(&quot;Field reference expression requested.&quot;)
    -        }
&lt;p&gt;    +&lt;br/&gt;
           case t: TupleTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
             exprs.zipWithIndex flatMap {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;case (UnresolvedFieldReference(name), idx) =&amp;gt;&lt;/li&gt;
	&lt;li&gt;Some((idx, name))&lt;/li&gt;
	&lt;li&gt;case (Alias(UnresolvedFieldReference(origName), name, _), _) =&amp;gt;&lt;br/&gt;
    +          case (UnresolvedFieldReference(name: String), idx) =&amp;gt;&lt;br/&gt;
    +            if (isReferenceByPosition) 
{
    +              Some((idx, name))
    +            } else {
    +              referenceByName(name, t)
    +            }&lt;br/&gt;
    +          case (Alias(UnresolvedFieldReference(origName), name: String, _), _) =&amp;gt;&lt;br/&gt;
                 val idx = t.getFieldIndex(origName)&lt;br/&gt;
                 if (idx &amp;lt; 0) {&lt;br/&gt;
    -              throw new TableException(s&quot;$origName is not a field of type $t&quot;)&lt;br/&gt;
    +              throw new TableException(s&quot;$origName is not a field of type $t. &quot; +&lt;br/&gt;
    +                s&quot;Expected: ${t.getFieldNames.mkString(&quot;, &quot;)}&quot;)&lt;br/&gt;
                 }&lt;br/&gt;
                 Some((idx, name))&lt;br/&gt;
               case (_: TimeAttribute, _) =&amp;gt;&lt;br/&gt;
                 None&lt;br/&gt;
               case _ =&amp;gt; throw new TableException(&lt;br/&gt;
                 &quot;Field reference expression or alias on field expression expected.&quot;)&lt;br/&gt;
             }&lt;br/&gt;
    +&lt;br/&gt;
           case c: CaseClassTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
             exprs.zipWithIndex flatMap {&lt;br/&gt;
    -          case (UnresolvedFieldReference(name), idx) =&amp;gt;&lt;br/&gt;
    -            Some((idx, name))&lt;br/&gt;
    -          case (Alias(UnresolvedFieldReference(origName), name, _), _) =&amp;gt;&lt;br/&gt;
    +          case (UnresolvedFieldReference(name: String), idx) =&amp;gt;&lt;br/&gt;
    +            if (isReferenceByPosition) {    +              Some((idx, name))    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +              referenceByName(name, c)
    +            }
&lt;p&gt;    +          case (Alias(UnresolvedFieldReference(origName), name: String, _), _) =&amp;gt;&lt;br/&gt;
                 val idx = c.getFieldIndex(origName)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    we can use `referenceByName()` here.&lt;/p&gt;</comment>
                            <comment id="16312192" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159770375&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159770375&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -791,92 +824,109 @@ abstract class TableEnvironment(val config: TableConfig) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns field names and field positions for a given [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] and [&lt;span class=&quot;error&quot;&gt;&amp;#91;Array&amp;#93;&lt;/span&gt;] of&lt;/li&gt;
	&lt;li&gt;[&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]. It does not handle time attributes but considers them in indices.&lt;br/&gt;
         *&lt;br/&gt;
    +    * @param isReferenceByPosition schema mode see [&lt;span class=&quot;error&quot;&gt;&amp;#91;isReferenceByPosition()&amp;#93;&lt;/span&gt;]&lt;/li&gt;
	&lt;li&gt;@param inputType The [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] against which the [&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]s are evaluated.&lt;/li&gt;
	&lt;li&gt;@param exprs     The expressions that define the field names.&lt;/li&gt;
	&lt;li&gt;@tparam A The type of the TypeInformation.&lt;/li&gt;
	&lt;li&gt;@return A tuple of two arrays holding the field names and corresponding field positions.&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +  protected def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +      isReferenceByPosition: Boolean,&lt;br/&gt;
           inputType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;,&lt;br/&gt;
           exprs: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;)&lt;br/&gt;
         : (Array&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;, Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;) = {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         TableEnvironment.validateType(inputType)&lt;/p&gt;

&lt;p&gt;    +    def referenceByName(name: String, ct: CompositeType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;): Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    if we change the return type to `Option&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;`, we can use it also for the `Alias` cases.&lt;/p&gt;

&lt;p&gt;    For example for `PojoTypeInfo`:&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    case (UnresolvedFieldReference(name: String)) =&amp;gt;&lt;br/&gt;
      referenceByName(name, p).map((_, name))&lt;br/&gt;
    case Alias(UnresolvedFieldReference(origName), name: String, _) =&amp;gt;&lt;br/&gt;
      referenceByName(origName, p).map((_, name))&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="16312193" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159776487&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159776487&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/StreamTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -464,23 +470,29 @@ abstract class StreamTableEnvironment(&lt;br/&gt;
             throw new TableException(&lt;br/&gt;
               &quot;The rowtime attribute can only be defined once in a table schema.&quot;)&lt;br/&gt;
           } else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val mappedIdx = streamType match 
{
    -          case pti: PojoTypeInfo[_] =&amp;gt;
    -            pti.getFieldIndex(origName.getOrElse(name))
    -          case _ =&amp;gt; idx;
    -        }&lt;/li&gt;
	&lt;li&gt;// check type of field that is replaced&lt;/li&gt;
	&lt;li&gt;if (mappedIdx &amp;lt; 0) {&lt;/li&gt;
	&lt;li&gt;throw new TableException(&lt;/li&gt;
	&lt;li&gt;s&quot;The rowtime attribute can only replace a valid field. &quot; +&lt;/li&gt;
	&lt;li&gt;s&quot;${origName.getOrElse(name)} is not a field of type $streamType.&quot;)&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;else if (mappedIdx &amp;lt; fieldTypes.length &amp;amp;&amp;amp;&lt;/li&gt;
	&lt;li&gt;!(TypeCheckUtils.isLong(fieldTypes(mappedIdx)) ||&lt;/li&gt;
	&lt;li&gt;TypeCheckUtils.isTimePoint(fieldTypes(mappedIdx)))) {&lt;/li&gt;
	&lt;li&gt;throw new TableException(&lt;/li&gt;
	&lt;li&gt;s&quot;The rowtime attribute can only replace a field with a valid time type, &quot; +&lt;/li&gt;
	&lt;li&gt;s&quot;such as Timestamp or Long. But was: ${fieldTypes(mappedIdx)}&quot;)&lt;br/&gt;
    +        // if the fields are referenced by position,&lt;br/&gt;
    +        // it is possible to replace an existing field or append the time attribute at the end&lt;br/&gt;
    +        if (isReferenceByPosition) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    IMO, we should distinguish the types (tuple-like, pojo, any) first before checking for the reference mode (which is only relevant for tuple-like types).&lt;/p&gt;</comment>
                            <comment id="16312194" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159771384&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159771384&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -885,8 +935,23 @@ abstract class TableEnvironment(val config: TableConfig) &lt;/p&gt;
{
                 &quot;Field reference expression or alias on field expression expected.&quot;)
             }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;case tpe =&amp;gt; throw new TableException(&lt;/li&gt;
	&lt;li&gt;s&quot;Source of type $tpe cannot be converted into Table.&quot;)&lt;br/&gt;
    +      case _: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt; // atomic or other custom type information&lt;br/&gt;
    +        var referenced = false&lt;br/&gt;
    +        exprs flatMap {&lt;br/&gt;
    +          case _: TimeAttribute =&amp;gt;&lt;br/&gt;
    +            None&lt;br/&gt;
    +          case UnresolvedFieldReference(_) if referenced =&amp;gt;&lt;br/&gt;
    +            // only accept the first field for an atomic type&lt;br/&gt;
    +            throw new TableException(&quot;Only the first field can reference an atomic type.&quot;)&lt;br/&gt;
    +          case UnresolvedFieldReference(name: String) =&amp;gt;&lt;br/&gt;
    +            referenced = true&lt;br/&gt;
    +            // first field reference is mapped to atomic type&lt;br/&gt;
    +            Some((0, name))&lt;br/&gt;
    +          case Alias(UnresolvedFieldReference(_), name: String, _) =&amp;gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    should we support this case? This would allow to use an arbitrary name as a references, e.g., for a String type (which has no name), we could define the schema as `(&apos;a as &apos;b)`. The name of the field would be `&apos;b` but where would `&apos;a` point to?&lt;/p&gt;
</comment>
                            <comment id="16312195" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159779494&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159779494&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/stream/StreamTableEnvironmentValidationTest.scala &amp;#8212;&lt;br/&gt;
    @@ -30,77 +30,88 @@ import org.junit.Test&lt;/p&gt;

&lt;p&gt;     class StreamTableEnvironmentValidationTest extends TableTestBase {&lt;/p&gt;

&lt;p&gt;    +  // ----------------------------------------------------------------------------------------------&lt;br/&gt;
    +  // schema definition by position&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +  @Test(expected = classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;TableException&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    +  def testInvalidProctimeAttributesByPosition(): Unit = {&lt;br/&gt;
    +    val util = streamTestUtil()&lt;br/&gt;
    +    // table definition makes no sense&lt;br/&gt;
    +    util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;(Long, Int, String, Int, Long)&amp;#93;&lt;/span&gt;(&apos;a.rowtime.rowtime, &apos;b, &apos;c, &apos;d, &apos;e)&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    method name suggests a test about proctime but only rowtime is used.&lt;/p&gt;</comment>
                            <comment id="16312196" author="githubbot" created="Thu, 4 Jan 2018 23:25:50 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159776065&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159776065&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/StreamTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -464,23 +470,29 @@ abstract class StreamTableEnvironment(&lt;br/&gt;
             throw new TableException(&lt;br/&gt;
               &quot;The rowtime attribute can only be defined once in a table schema.&quot;)&lt;br/&gt;
           } else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val mappedIdx = streamType match 
{
    -          case pti: PojoTypeInfo[_] =&amp;gt;
    -            pti.getFieldIndex(origName.getOrElse(name))
    -          case _ =&amp;gt; idx;
    -        }&lt;/li&gt;
	&lt;li&gt;// check type of field that is replaced&lt;/li&gt;
	&lt;li&gt;if (mappedIdx &amp;lt; 0) {&lt;/li&gt;
	&lt;li&gt;throw new TableException(&lt;/li&gt;
	&lt;li&gt;s&quot;The rowtime attribute can only replace a valid field. &quot; +&lt;/li&gt;
	&lt;li&gt;s&quot;${origName.getOrElse(name)} is not a field of type $streamType.&quot;)&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;else if (mappedIdx &amp;lt; fieldTypes.length &amp;amp;&amp;amp;&lt;/li&gt;
	&lt;li&gt;!(TypeCheckUtils.isLong(fieldTypes(mappedIdx)) ||&lt;/li&gt;
	&lt;li&gt;TypeCheckUtils.isTimePoint(fieldTypes(mappedIdx)))) {&lt;/li&gt;
	&lt;li&gt;throw new TableException(&lt;/li&gt;
	&lt;li&gt;s&quot;The rowtime attribute can only replace a field with a valid time type, &quot; +&lt;/li&gt;
	&lt;li&gt;s&quot;such as Timestamp or Long. But was: ${fieldTypes(mappedIdx)}&quot;)&lt;br/&gt;
    +        // if the fields are referenced by position,&lt;br/&gt;
    +        // it is possible to replace an existing field or append the time attribute at the end&lt;br/&gt;
    +        if (isReferenceByPosition) {&lt;br/&gt;
    +&lt;br/&gt;
    +          val mappedIdx = streamType match {&lt;br/&gt;
    +            case pti: PojoTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I think this case will never be entered, because `isReferenceByPosition` will always be `false` for `PojoTypeInfo`.&lt;/p&gt;
</comment>
                            <comment id="16312197" author="githubbot" created="Thu, 4 Jan 2018 23:25:51 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159779243&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159779243&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala &amp;#8212;&lt;br/&gt;
    @@ -18,231 +18,574 @@&lt;/p&gt;

&lt;p&gt;     package org.apache.flink.table.api&lt;/p&gt;

&lt;p&gt;    -import org.apache.flink.api.common.typeinfo.BasicTypeInfo._&lt;br/&gt;
     import org.apache.flink.api.common.typeinfo.TypeInformation&lt;br/&gt;
    -import org.apache.flink.api.java.typeutils.&lt;/p&gt;
{GenericTypeInfo, RowTypeInfo, TupleTypeInfo, TypeExtractor}
&lt;p&gt;     import org.apache.flink.api.scala._&lt;br/&gt;
    -import org.apache.flink.table.expressions.&lt;/p&gt;
{Alias, UnresolvedFieldReference}
&lt;p&gt;    -import org.apache.flink.table.runtime.types.CRowTypeInfo&lt;br/&gt;
    -import org.apache.flink.table.utils.&lt;/p&gt;
{MockTableEnvironment, TableTestBase}
&lt;p&gt;    +import org.apache.flink.table.api.TableEnvironmentTest._&lt;br/&gt;
    +import org.apache.flink.table.api.Types._&lt;br/&gt;
    +import org.apache.flink.table.api.scala._&lt;br/&gt;
    +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo.&lt;/p&gt;
{PROCTIME_INDICATOR =&amp;gt; PROCTIME}
&lt;p&gt;    +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo.&lt;/p&gt;
{ROWTIME_INDICATOR =&amp;gt; ROWTIME}
&lt;p&gt;    +import org.apache.flink.table.utils.TableTestBase&lt;br/&gt;
     import org.apache.flink.types.Row&lt;br/&gt;
    -import org.junit.Assert.assertEquals&lt;br/&gt;
    +import org.apache.flink.api.java.tuple.&lt;/p&gt;
{Tuple3 =&amp;gt; JTuple3}
&lt;p&gt;    +import org.apache.flink.api.java.typeutils.GenericTypeInfo&lt;br/&gt;
    +import org.apache.flink.api.scala.typeutils.UnitTypeInfo&lt;br/&gt;
     import org.junit.Test&lt;/p&gt;

&lt;p&gt;     class TableEnvironmentTest extends TableTestBase {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val tEnv = new MockTableEnvironment&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val tupleType = new TupleTypeInfo(&lt;/li&gt;
	&lt;li&gt;INT_TYPE_INFO,&lt;/li&gt;
	&lt;li&gt;STRING_TYPE_INFO,&lt;/li&gt;
	&lt;li&gt;DOUBLE_TYPE_INFO)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val rowType = new RowTypeInfo(INT_TYPE_INFO, STRING_TYPE_INFO,DOUBLE_TYPE_INFO)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val cRowType = new CRowTypeInfo(rowType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val caseClassType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;CClass&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;CClass&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val pojoType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;PojoClass&amp;#93;&lt;/span&gt; = TypeExtractor.createTypeInfo(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;PojoClass&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val atomicType = INT_TYPE_INFO&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val genericRowType = new GenericTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;br/&gt;
    +  // schema definition by position&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoRow(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(rowType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testProjectByPosition(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a, &apos;b, &apos;c),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a, &apos;b),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable(&apos;a, &apos;b, &apos;c)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;a, &apos;b)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;a)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoRowNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;rowType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithAddingTimeAttributesByPosition(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c , &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoTuple(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(tupleType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamAliasWithReplacingTimeAttributesByPosition(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;a, &apos;b.rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b.rowtime, &apos;c)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, (&apos;b as &apos;new).rowtime, &apos;c)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;def testGetFieldInfoCClass(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(caseClassType)&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;br/&gt;
    +  // schema definition by name&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;cf1&quot;, &quot;cf2&quot;, &quot;cf3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  @Test&lt;br/&gt;
    +  def testProjectByName(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // atomic
    +      util.verifySchema(
    +        util.addTable[Int](),
    +        Seq(&quot;f0&quot; -&amp;gt; INT))
    +
    +      util.verifySchema(
    +        util.addTable[Int](&apos;myint),
    +        Seq(&quot;myint&quot; -&amp;gt; INT))
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf2&quot; -&amp;gt; STRING, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf1, &apos;cf2),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf2&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf1, &apos;cf3),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf3, &apos;cf1),
    +        Seq(&quot;cf3&quot; -&amp;gt; DOUBLE, &quot;cf1&quot; -&amp;gt; INT))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable()(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf2&quot; -&amp;gt; STRING, &quot;rf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;rf1, &apos;rf2)(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf2&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;rf1, &apos;rf3)(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;rf3, &apos;rf1)(TEST_ROW),
    +        Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f1&quot; -&amp;gt; STRING, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f1),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f1&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f2),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f2, &apos;f0),
    +        Seq(&quot;f2&quot; -&amp;gt; DOUBLE, &quot;f0&quot; -&amp;gt; INT))
    +
    +      // pojo
    +      util.verifySchema(
    +        util.addTable[PojoClass](),
    +        Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf2&quot; -&amp;gt; STRING, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[PojoClass](&apos;pf1, &apos;pf2),
    +        Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf2&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[PojoClass](&apos;pf1, &apos;pf3),
    +        Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[PojoClass](&apos;pf3, &apos;pf1),
    +        Seq(&quot;pf3&quot; -&amp;gt; DOUBLE, &quot;pf1&quot; -&amp;gt; INT))
    +
    +      // generic
    +      util.verifySchema(
    +        util.addTable[Class[_]](&apos;mygeneric),
    +        Seq(&quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +      util.verifySchema(
    +        util.addTable[Class[_]](),
    +        Seq(&quot;f0&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +      // any type info
    +      util.verifySchema(
    +        util.addTable[Unit](),
    +        Seq(&quot;f0&quot; -&amp;gt; new UnitTypeInfo()))
    +
    +      util.verifySchema(
    +        util.addTable[Unit](&apos;unit),
    +        Seq(&quot;unit&quot; -&amp;gt; new UnitTypeInfo()))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoPojo(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(pojoType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;pf1&quot;, &quot;pf2&quot;, &quot;pf3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithAddingTimeAttributesByName(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // atomic
    +    util.verifySchema(
    +      util.addTable[Int](&apos;proctime.proctime, &apos;myint),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;myint&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[Int](&apos;rowtime.rowtime, &apos;myint),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;myint&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[Int](&apos;myint, &apos;proctime.proctime),
    +      Seq(&quot;myint&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[Int](&apos;myint, &apos;rowtime.rowtime),
    +      Seq(&quot;myint&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;proctime.proctime, &apos;cf1, &apos;cf3),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;rowtime.rowtime, &apos;cf3, &apos;cf1),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;cf3&quot; -&amp;gt; DOUBLE, &quot;cf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf1, &apos;proctime.proctime, &apos;cf3),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf3, &apos;rowtime.rowtime, &apos;cf1),
    +      Seq(&quot;cf3&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;cf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf1, &apos;cf3, &apos;proctime.proctime),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf3, &apos;cf1, &apos;rowtime.rowtime),
    +      Seq(&quot;cf3&quot; -&amp;gt; DOUBLE, &quot;cf1&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;proctime.proctime, &apos;rf1, &apos;rf3)(TEST_ROW),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rowtime.rowtime, &apos;rf3, &apos;rf1)(TEST_ROW),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;proctime.proctime, &apos;rf1)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;rf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;rowtime.rowtime, &apos;rf1)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;rf1&quot; -&amp;gt; INT))
    +
    +        util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;rf1, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +        util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;rf1, &apos;rowtime.rowtime)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;proctime.proctime, &apos;f0, &apos;f2),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;rowtime.rowtime, &apos;f2, &apos;f0),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;f2&quot; -&amp;gt; DOUBLE, &quot;f0&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;proctime.proctime, &apos;f2),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f2, &apos;rowtime.rowtime, &apos;f0),
    +      Seq(&quot;f2&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;f0&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f2, &apos;proctime.proctime),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f2, &apos;f0, &apos;rowtime.rowtime),
    +      Seq(&quot;f2&quot; -&amp;gt; DOUBLE, &quot;f0&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // pojo
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;proctime.proctime, &apos;pf1, &apos;pf3),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;pf1&quot; -&amp;gt; INT, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;rowtime.rowtime, &apos;pf3, &apos;pf1),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;pf3&quot; -&amp;gt; DOUBLE, &quot;pf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf1, &apos;proctime.proctime, &apos;pf3),
    +      Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf3, &apos;rowtime.rowtime, &apos;pf1),
    +      Seq(&quot;pf3&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;pf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf1, &apos;pf3, &apos;proctime.proctime),
    +      Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf3&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf3, &apos;pf1, &apos;rowtime.rowtime),
    +      Seq(&quot;pf3&quot; -&amp;gt; DOUBLE, &quot;pf1&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // generic
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;proctime.proctime, &apos;mygeneric),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;rowtime.rowtime, &apos;mygeneric),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;mygeneric, &apos;proctime.proctime),
    +      Seq(&quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]]), &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;mygeneric, &apos;rowtime.rowtime),
    +      Seq(&quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]]), &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // any type info
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;proctime.proctime, &apos;unit),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;unit&quot; -&amp;gt; new UnitTypeInfo()))
    +
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;rowtime.rowtime, &apos;unit),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;unit&quot; -&amp;gt; new UnitTypeInfo()))
    +
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;unit, &apos;proctime.proctime),
    +      Seq(&quot;unit&quot; -&amp;gt; new UnitTypeInfo(), &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;unit, &apos;rowtime.rowtime),
    +      Seq(&quot;unit&quot; -&amp;gt; new UnitTypeInfo(), &quot;rowtime&quot; -&amp;gt; ROWTIME))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoAtomic(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(atomicType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithReplacingTimeAttributesByName(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // atomic
    +    util.verifySchema(
    +      util.addTable[Int](&apos;myint.proctime),
    +      Seq(&quot;myint&quot; -&amp;gt; PROCTIME))
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;cf1, &apos;cf3.proctime, &apos;cf2),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; PROCTIME, &quot;cf2&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;cf1, &apos;cf3.rowtime, &apos;cf2),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; ROWTIME, &quot;cf2&quot; -&amp;gt; LONG))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;rf1, &apos;rf3.proctime, &apos;rf2)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; PROCTIME, &quot;rf2&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf1, &apos;rf3.rowtime, &apos;rf2)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; ROWTIME, &quot;rf2&quot; -&amp;gt; LONG))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;f0, &apos;f2.proctime, &apos;f1),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; PROCTIME, &quot;f1&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;f0, &apos;f2.rowtime, &apos;f1),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; ROWTIME, &quot;f1&quot; -&amp;gt; LONG))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoTupleNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;tupleType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testAliasByName(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // atomic
    +      util.verifySchema(
    +        util.addTable[Int](&apos;myint as &apos;new),
    +        Seq(&quot;new&quot; -&amp;gt; INT))
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf1, &apos;cf3 as &apos;new, &apos;cf2),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; DOUBLE, &quot;cf2&quot; -&amp;gt; STRING))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable(&apos;rf1, &apos;rf3 as &apos;new, &apos;rf2)(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; DOUBLE, &quot;rf2&quot; -&amp;gt; STRING))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f2 as &apos;new, &apos;f1),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; DOUBLE, &quot;f1&quot; -&amp;gt; STRING))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoCClassNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;caseClassType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamAliasWithAddingTimeAttributesByName(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // atomic
    +    util.verifySchema(
    +      util.addTable[Int]((&apos;myint as &apos;new).proctime),
    +      Seq(&quot;new&quot; -&amp;gt; PROCTIME))
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;cf1, (&apos;newnew as &apos;new).proctime, &apos;cf2),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; PROCTIME, &quot;cf2&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;cf1, (&apos;newnew as &apos;new).rowtime, &apos;cf2),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;cf2&quot; -&amp;gt; LONG))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;rf1, (&apos;newnew as &apos;new).proctime, &apos;rf2)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; PROCTIME, &quot;rf2&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf1, (&apos;newnew as &apos;new).rowtime, &apos;rf2)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;rf2&quot; -&amp;gt; LONG))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;f0, (&apos;newnew as &apos;new).proctime, &apos;f1),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; PROCTIME, &quot;f1&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;f0, (&apos;newnew as &apos;new).rowtime, &apos;f1),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;f1&quot; -&amp;gt; LONG))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoPojoNames2(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;pojoType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;pf3&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;pf1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;pf2&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;pf3&quot;, &quot;pf1&quot;, &quot;pf2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(2, 0, 1)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamAliasWithReplacingTimeAttributesByName(): Unit = {&lt;br/&gt;
    +    val util = streamTestUtil()&lt;br/&gt;
    +&lt;br/&gt;
    +    // atomic&lt;br/&gt;
    +    util.verifySchema(&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;((&apos;myint as &apos;new).proctime),&lt;br/&gt;
    +      Seq(&quot;new&quot; -&amp;gt; PROCTIME))&lt;br/&gt;
    +&lt;br/&gt;
    +    // case class&lt;br/&gt;
    +    util.verifySchema(&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;CClassWithTime&amp;#93;&lt;/span&gt;(&apos;cf1, (&apos;cf3 as &apos;new).proctime, &apos;cf2),
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Should we allow to define an existing field as a `proctime` attribute?&lt;/p&gt;
</comment>
                            <comment id="16312198" author="githubbot" created="Thu, 4 Jan 2018 23:25:51 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159779026&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159779026&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala &amp;#8212;&lt;br/&gt;
    @@ -18,231 +18,574 @@&lt;/p&gt;

&lt;p&gt;     package org.apache.flink.table.api&lt;/p&gt;

&lt;p&gt;    -import org.apache.flink.api.common.typeinfo.BasicTypeInfo._&lt;br/&gt;
     import org.apache.flink.api.common.typeinfo.TypeInformation&lt;br/&gt;
    -import org.apache.flink.api.java.typeutils.&lt;/p&gt;
{GenericTypeInfo, RowTypeInfo, TupleTypeInfo, TypeExtractor}
&lt;p&gt;     import org.apache.flink.api.scala._&lt;br/&gt;
    -import org.apache.flink.table.expressions.&lt;/p&gt;
{Alias, UnresolvedFieldReference}
&lt;p&gt;    -import org.apache.flink.table.runtime.types.CRowTypeInfo&lt;br/&gt;
    -import org.apache.flink.table.utils.&lt;/p&gt;
{MockTableEnvironment, TableTestBase}
&lt;p&gt;    +import org.apache.flink.table.api.TableEnvironmentTest._&lt;br/&gt;
    +import org.apache.flink.table.api.Types._&lt;br/&gt;
    +import org.apache.flink.table.api.scala._&lt;br/&gt;
    +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo.&lt;/p&gt;
{PROCTIME_INDICATOR =&amp;gt; PROCTIME}
&lt;p&gt;    +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo.&lt;/p&gt;
{ROWTIME_INDICATOR =&amp;gt; ROWTIME}
&lt;p&gt;    +import org.apache.flink.table.utils.TableTestBase&lt;br/&gt;
     import org.apache.flink.types.Row&lt;br/&gt;
    -import org.junit.Assert.assertEquals&lt;br/&gt;
    +import org.apache.flink.api.java.tuple.&lt;/p&gt;
{Tuple3 =&amp;gt; JTuple3}
&lt;p&gt;    +import org.apache.flink.api.java.typeutils.GenericTypeInfo&lt;br/&gt;
    +import org.apache.flink.api.scala.typeutils.UnitTypeInfo&lt;br/&gt;
     import org.junit.Test&lt;/p&gt;

&lt;p&gt;     class TableEnvironmentTest extends TableTestBase {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val tEnv = new MockTableEnvironment&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val tupleType = new TupleTypeInfo(&lt;/li&gt;
	&lt;li&gt;INT_TYPE_INFO,&lt;/li&gt;
	&lt;li&gt;STRING_TYPE_INFO,&lt;/li&gt;
	&lt;li&gt;DOUBLE_TYPE_INFO)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val rowType = new RowTypeInfo(INT_TYPE_INFO, STRING_TYPE_INFO,DOUBLE_TYPE_INFO)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val cRowType = new CRowTypeInfo(rowType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val caseClassType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;CClass&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;CClass&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val pojoType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;PojoClass&amp;#93;&lt;/span&gt; = TypeExtractor.createTypeInfo(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;PojoClass&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val atomicType = INT_TYPE_INFO&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val genericRowType = new GenericTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;br/&gt;
    +  // schema definition by position&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoRow(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(rowType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testProjectByPosition(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a, &apos;b, &apos;c),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a, &apos;b),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable(&apos;a, &apos;b, &apos;c)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;a, &apos;b)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;a)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoRowNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;rowType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithAddingTimeAttributesByPosition(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c , &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoTuple(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(tupleType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamAliasWithReplacingTimeAttributesByPosition(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;a, &apos;b.rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b.rowtime, &apos;c)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, (&apos;b as &apos;new).rowtime, &apos;c)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;def testGetFieldInfoCClass(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(caseClassType)&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;br/&gt;
    +  // schema definition by name&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;cf1&quot;, &quot;cf2&quot;, &quot;cf3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  @Test&lt;br/&gt;
    +  def testProjectByName(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // atomic
    +      util.verifySchema(
    +        util.addTable[Int](),
    +        Seq(&quot;f0&quot; -&amp;gt; INT))
    +
    +      util.verifySchema(
    +        util.addTable[Int](&apos;myint),
    +        Seq(&quot;myint&quot; -&amp;gt; INT))
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf2&quot; -&amp;gt; STRING, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf1, &apos;cf2),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf2&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf1, &apos;cf3),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf3, &apos;cf1),
    +        Seq(&quot;cf3&quot; -&amp;gt; DOUBLE, &quot;cf1&quot; -&amp;gt; INT))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable()(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf2&quot; -&amp;gt; STRING, &quot;rf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;rf1, &apos;rf2)(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf2&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;rf1, &apos;rf3)(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;rf3, &apos;rf1)(TEST_ROW),
    +        Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f1&quot; -&amp;gt; STRING, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f1),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f1&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f2),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f2, &apos;f0),
    +        Seq(&quot;f2&quot; -&amp;gt; DOUBLE, &quot;f0&quot; -&amp;gt; INT))
    +
    +      // pojo
    +      util.verifySchema(
    +        util.addTable[PojoClass](),
    +        Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf2&quot; -&amp;gt; STRING, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[PojoClass](&apos;pf1, &apos;pf2),
    +        Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf2&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[PojoClass](&apos;pf1, &apos;pf3),
    +        Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[PojoClass](&apos;pf3, &apos;pf1),
    +        Seq(&quot;pf3&quot; -&amp;gt; DOUBLE, &quot;pf1&quot; -&amp;gt; INT))
    +
    +      // generic
    +      util.verifySchema(
    +        util.addTable[Class[_]](&apos;mygeneric),
    +        Seq(&quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +      util.verifySchema(
    +        util.addTable[Class[_]](),
    +        Seq(&quot;f0&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +      // any type info
    +      util.verifySchema(
    +        util.addTable[Unit](),
    +        Seq(&quot;f0&quot; -&amp;gt; new UnitTypeInfo()))
    +
    +      util.verifySchema(
    +        util.addTable[Unit](&apos;unit),
    +        Seq(&quot;unit&quot; -&amp;gt; new UnitTypeInfo()))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoPojo(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(pojoType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;pf1&quot;, &quot;pf2&quot;, &quot;pf3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithAddingTimeAttributesByName(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // atomic
    +    util.verifySchema(
    +      util.addTable[Int](&apos;proctime.proctime, &apos;myint),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;myint&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[Int](&apos;rowtime.rowtime, &apos;myint),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;myint&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[Int](&apos;myint, &apos;proctime.proctime),
    +      Seq(&quot;myint&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[Int](&apos;myint, &apos;rowtime.rowtime),
    +      Seq(&quot;myint&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;proctime.proctime, &apos;cf1, &apos;cf3),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;rowtime.rowtime, &apos;cf3, &apos;cf1),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;cf3&quot; -&amp;gt; DOUBLE, &quot;cf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf1, &apos;proctime.proctime, &apos;cf3),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf3, &apos;rowtime.rowtime, &apos;cf1),
    +      Seq(&quot;cf3&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;cf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf1, &apos;cf3, &apos;proctime.proctime),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf3, &apos;cf1, &apos;rowtime.rowtime),
    +      Seq(&quot;cf3&quot; -&amp;gt; DOUBLE, &quot;cf1&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;proctime.proctime, &apos;rf1, &apos;rf3)(TEST_ROW),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rowtime.rowtime, &apos;rf3, &apos;rf1)(TEST_ROW),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;proctime.proctime, &apos;rf1)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;rf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;rowtime.rowtime, &apos;rf1)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;rf1&quot; -&amp;gt; INT))
    +
    +        util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;rf1, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +        util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;rf1, &apos;rowtime.rowtime)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;proctime.proctime, &apos;f0, &apos;f2),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;rowtime.rowtime, &apos;f2, &apos;f0),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;f2&quot; -&amp;gt; DOUBLE, &quot;f0&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;proctime.proctime, &apos;f2),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f2, &apos;rowtime.rowtime, &apos;f0),
    +      Seq(&quot;f2&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;f0&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f2, &apos;proctime.proctime),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f2, &apos;f0, &apos;rowtime.rowtime),
    +      Seq(&quot;f2&quot; -&amp;gt; DOUBLE, &quot;f0&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // pojo
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;proctime.proctime, &apos;pf1, &apos;pf3),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;pf1&quot; -&amp;gt; INT, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;rowtime.rowtime, &apos;pf3, &apos;pf1),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;pf3&quot; -&amp;gt; DOUBLE, &quot;pf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf1, &apos;proctime.proctime, &apos;pf3),
    +      Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf3, &apos;rowtime.rowtime, &apos;pf1),
    +      Seq(&quot;pf3&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;pf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf1, &apos;pf3, &apos;proctime.proctime),
    +      Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf3&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf3, &apos;pf1, &apos;rowtime.rowtime),
    +      Seq(&quot;pf3&quot; -&amp;gt; DOUBLE, &quot;pf1&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // generic
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;proctime.proctime, &apos;mygeneric),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;rowtime.rowtime, &apos;mygeneric),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;mygeneric, &apos;proctime.proctime),
    +      Seq(&quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]]), &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;mygeneric, &apos;rowtime.rowtime),
    +      Seq(&quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]]), &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // any type info
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;proctime.proctime, &apos;unit),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;unit&quot; -&amp;gt; new UnitTypeInfo()))
    +
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;rowtime.rowtime, &apos;unit),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;unit&quot; -&amp;gt; new UnitTypeInfo()))
    +
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;unit, &apos;proctime.proctime),
    +      Seq(&quot;unit&quot; -&amp;gt; new UnitTypeInfo(), &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;unit, &apos;rowtime.rowtime),
    +      Seq(&quot;unit&quot; -&amp;gt; new UnitTypeInfo(), &quot;rowtime&quot; -&amp;gt; ROWTIME))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoAtomic(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(atomicType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithReplacingTimeAttributesByName(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // atomic
    +    util.verifySchema(
    +      util.addTable[Int](&apos;myint.proctime),
    +      Seq(&quot;myint&quot; -&amp;gt; PROCTIME))
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;cf1, &apos;cf3.proctime, &apos;cf2),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; PROCTIME, &quot;cf2&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;cf1, &apos;cf3.rowtime, &apos;cf2),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; ROWTIME, &quot;cf2&quot; -&amp;gt; LONG))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;rf1, &apos;rf3.proctime, &apos;rf2)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; PROCTIME, &quot;rf2&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf1, &apos;rf3.rowtime, &apos;rf2)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; ROWTIME, &quot;rf2&quot; -&amp;gt; LONG))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;f0, &apos;f2.proctime, &apos;f1),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; PROCTIME, &quot;f1&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;f0, &apos;f2.rowtime, &apos;f1),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; ROWTIME, &quot;f1&quot; -&amp;gt; LONG))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoTupleNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;tupleType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testAliasByName(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // atomic
    +      util.verifySchema(
    +        util.addTable[Int](&apos;myint as &apos;new),
    +        Seq(&quot;new&quot; -&amp;gt; INT))
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf1, &apos;cf3 as &apos;new, &apos;cf2),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; DOUBLE, &quot;cf2&quot; -&amp;gt; STRING))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable(&apos;rf1, &apos;rf3 as &apos;new, &apos;rf2)(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; DOUBLE, &quot;rf2&quot; -&amp;gt; STRING))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f2 as &apos;new, &apos;f1),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; DOUBLE, &quot;f1&quot; -&amp;gt; STRING))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoCClassNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;caseClassType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamAliasWithAddingTimeAttributesByName(): Unit = {&lt;br/&gt;
    +    val util = streamTestUtil()&lt;br/&gt;
    +&lt;br/&gt;
    +    // atomic&lt;br/&gt;
    +    util.verifySchema(&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;((&apos;myint as &apos;new).proctime),&lt;br/&gt;
    +      Seq(&quot;new&quot; -&amp;gt; PROCTIME))&lt;br/&gt;
    +&lt;br/&gt;
    +    // case class&lt;br/&gt;
    +    util.verifySchema(&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;CClassWithTime&amp;#93;&lt;/span&gt;(&apos;cf1, (&apos;newnew as &apos;new).proctime, &apos;cf2),&lt;br/&gt;
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; PROCTIME, &quot;cf2&quot; -&amp;gt; LONG))&lt;br/&gt;
    +&lt;br/&gt;
    +    util.verifySchema(&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;CClassWithTime&amp;#93;&lt;/span&gt;(&apos;cf1, (&apos;newnew as &apos;new).rowtime, &apos;cf2),
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I think we should add checks that `&apos;newnew` is actually present in the schema.&lt;/p&gt;</comment>
                            <comment id="16312799" author="githubbot" created="Fri, 5 Jan 2018 09:55:17 +0000"  >&lt;p&gt;Github user twalthr commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159841031&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159841031&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/StreamTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -464,23 +470,29 @@ abstract class StreamTableEnvironment(&lt;br/&gt;
             throw new TableException(&lt;br/&gt;
               &quot;The rowtime attribute can only be defined once in a table schema.&quot;)&lt;br/&gt;
           } else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val mappedIdx = streamType match 
{
    -          case pti: PojoTypeInfo[_] =&amp;gt;
    -            pti.getFieldIndex(origName.getOrElse(name))
    -          case _ =&amp;gt; idx;
    -        }&lt;/li&gt;
	&lt;li&gt;// check type of field that is replaced&lt;/li&gt;
	&lt;li&gt;if (mappedIdx &amp;lt; 0) {&lt;/li&gt;
	&lt;li&gt;throw new TableException(&lt;/li&gt;
	&lt;li&gt;s&quot;The rowtime attribute can only replace a valid field. &quot; +&lt;/li&gt;
	&lt;li&gt;s&quot;${origName.getOrElse(name)} is not a field of type $streamType.&quot;)&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;else if (mappedIdx &amp;lt; fieldTypes.length &amp;amp;&amp;amp;&lt;/li&gt;
	&lt;li&gt;!(TypeCheckUtils.isLong(fieldTypes(mappedIdx)) ||&lt;/li&gt;
	&lt;li&gt;TypeCheckUtils.isTimePoint(fieldTypes(mappedIdx)))) {&lt;/li&gt;
	&lt;li&gt;throw new TableException(&lt;/li&gt;
	&lt;li&gt;s&quot;The rowtime attribute can only replace a field with a valid time type, &quot; +&lt;/li&gt;
	&lt;li&gt;s&quot;such as Timestamp or Long. But was: ${fieldTypes(mappedIdx)}&quot;)&lt;br/&gt;
    +        // if the fields are referenced by position,&lt;br/&gt;
    +        // it is possible to replace an existing field or append the time attribute at the end&lt;br/&gt;
    +        if (isReferenceByPosition) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This method does no need to distinguish between types anymore. The `isReferenceByPosition` method is doing that. The type checking is done earlier in `getFieldInfo()`. &lt;/p&gt;</comment>
                            <comment id="16312864" author="githubbot" created="Fri, 5 Jan 2018 10:16:13 +0000"  >&lt;p&gt;Github user twalthr commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159844472&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159844472&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -768,6 +768,39 @@ abstract class TableEnvironment(val config: TableConfig) &lt;/p&gt;
{
         frameworkConfig
       }

&lt;p&gt;    +  /**&lt;br/&gt;
    +    * Reference input fields by name:&lt;br/&gt;
    +    * All fields in the schema definition are referenced by name&lt;br/&gt;
    +    * (and possibly renamed using an alias (as). In this mode, fields can be reordered and&lt;br/&gt;
    +    * projected out. Moreover, we can define proctime and rowtime attributes at arbitrary&lt;br/&gt;
    +    * positions using arbitrary names (except those that exist in the result schema). This mode&lt;br/&gt;
    +    * can be used for any input type, including POJOs.&lt;br/&gt;
    +    *&lt;br/&gt;
    +    * Reference input fields by position:&lt;br/&gt;
    +    * Field references must refer to existing fields in the input type (except for&lt;br/&gt;
    +    * renaming with alias (as)). In this mode, fields are simply renamed. Event-time attributes can&lt;br/&gt;
    +    * replace the field on their position in the input data (if it is of correct type) or be&lt;br/&gt;
    +    * appended at the end. Proctime attributes must be appended at the end. This mode can only be&lt;br/&gt;
    +    * used if the input type has a defined field order (tuple, case class, Row) and no of fields&lt;br/&gt;
    +    * references a field of the input type.&lt;br/&gt;
    +    */&lt;br/&gt;
    +  protected def isReferenceByPosition(t: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;, fields: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;): Boolean = {&lt;br/&gt;
    +    if (t.isInstanceOf[PojoTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;]) &lt;/p&gt;
{
    +      return false
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    val inputNames = t match &lt;/p&gt;
{
    +      case ct: CompositeType[_] =&amp;gt; ct.getFieldNames
    +      case _ =&amp;gt; return false // atomic types are references by name
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    // use the by position mode if no of the fields exists in the input&lt;br/&gt;
    +    fields.forall {&lt;br/&gt;
    +      case UnresolvedFieldReference(name) =&amp;gt; !inputNames.contains(name)&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Yes, that was my main concern behind this. This makes the difference between by-ref and by-pos more explicit. In this case I think it is better to fail instead of having implicit behavior that a user might not have intended. I will add a comment about this in the code.&lt;/p&gt;</comment>
                            <comment id="16312914" author="githubbot" created="Fri, 5 Jan 2018 10:45:41 +0000"  >&lt;p&gt;Github user twalthr commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159850168&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159850168&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -791,92 +824,109 @@ abstract class TableEnvironment(val config: TableConfig) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns field names and field positions for a given [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] and [&lt;span class=&quot;error&quot;&gt;&amp;#91;Array&amp;#93;&lt;/span&gt;] of&lt;/li&gt;
	&lt;li&gt;[&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]. It does not handle time attributes but considers them in indices.&lt;br/&gt;
         *&lt;br/&gt;
    +    * @param isReferenceByPosition schema mode see [&lt;span class=&quot;error&quot;&gt;&amp;#91;isReferenceByPosition()&amp;#93;&lt;/span&gt;]&lt;/li&gt;
	&lt;li&gt;@param inputType The [&lt;span class=&quot;error&quot;&gt;&amp;#91;TypeInformation&amp;#93;&lt;/span&gt;] against which the [&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;]s are evaluated.&lt;/li&gt;
	&lt;li&gt;@param exprs     The expressions that define the field names.&lt;/li&gt;
	&lt;li&gt;@tparam A The type of the TypeInformation.&lt;/li&gt;
	&lt;li&gt;@return A tuple of two arrays holding the field names and corresponding field positions.&lt;br/&gt;
         */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected&lt;span class=&quot;error&quot;&gt;&amp;#91;flink&amp;#93;&lt;/span&gt; def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +  protected def getFieldInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;(&lt;br/&gt;
    +      isReferenceByPosition: Boolean,&lt;br/&gt;
           inputType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;,&lt;br/&gt;
           exprs: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;)&lt;br/&gt;
         : (Array&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;, Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;) = {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         TableEnvironment.validateType(inputType)&lt;/p&gt;

&lt;p&gt;    +    def referenceByName(name: String, ct: CompositeType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;): Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +      val inputIdx = ct.getFieldIndex(name)&lt;br/&gt;
    +      if (inputIdx &amp;lt; 0) {&lt;br/&gt;
    +        throw new TableException(s&quot;$name is not a field of type $ct. &quot; +&lt;br/&gt;
    +                s&quot;Expected: ${ct.getFieldNames.mkString(&quot;, &quot;)}&quot;)&lt;br/&gt;
    +      } else &lt;/p&gt;
{
    +        Some((inputIdx, name))
    +      }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
         val indexedNames: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = inputType match {&lt;br/&gt;
    +&lt;br/&gt;
           case g: GenericTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; if g.getTypeClass == classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
             throw new TableException(&lt;br/&gt;
               &quot;An input of GenericTypeInfo&amp;lt;Row&amp;gt; cannot be converted to Table. &quot; +&lt;br/&gt;
                 &quot;Please specify the type of the input with a RowTypeInfo.&quot;)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;case a: AtomicType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt;&lt;/li&gt;
	&lt;li&gt;exprs.zipWithIndex flatMap 
{
    -          case (_: TimeAttribute, _) =&amp;gt;
    -            None
    -          case (UnresolvedFieldReference(name), idx) if idx &amp;gt; 0 =&amp;gt;
    -            // only accept the first field for an atomic type
    -            throw new TableException(&quot;Only the first field can reference an atomic type.&quot;)
    -          case (UnresolvedFieldReference(name), idx) =&amp;gt;
    -            // first field reference is mapped to atomic type
    -            Some((0, name))
    -          case _ =&amp;gt; throw new TableException(&quot;Field reference expression requested.&quot;)
    -        }
&lt;p&gt;    +&lt;br/&gt;
           case t: TupleTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
             exprs.zipWithIndex flatMap {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;case (UnresolvedFieldReference(name), idx) =&amp;gt;&lt;/li&gt;
	&lt;li&gt;Some((idx, name))&lt;/li&gt;
	&lt;li&gt;case (Alias(UnresolvedFieldReference(origName), name, _), _) =&amp;gt;&lt;br/&gt;
    +          case (UnresolvedFieldReference(name: String), idx) =&amp;gt;&lt;br/&gt;
    +            if (isReferenceByPosition) 
{
    +              Some((idx, name))
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +              referenceByName(name, t)
    +            }
&lt;p&gt;    +          case (Alias(UnresolvedFieldReference(origName), name: String, _), _) =&amp;gt;&lt;br/&gt;
                 val idx = t.getFieldIndex(origName)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Good point. I&apos;m fine with prohibiting it.&lt;/p&gt;</comment>
                            <comment id="16312961" author="githubbot" created="Fri, 5 Jan 2018 11:05:13 +0000"  >&lt;p&gt;Github user twalthr commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159853373&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159853373&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala &amp;#8212;&lt;br/&gt;
    @@ -18,231 +18,574 @@&lt;/p&gt;

&lt;p&gt;     package org.apache.flink.table.api&lt;/p&gt;

&lt;p&gt;    -import org.apache.flink.api.common.typeinfo.BasicTypeInfo._&lt;br/&gt;
     import org.apache.flink.api.common.typeinfo.TypeInformation&lt;br/&gt;
    -import org.apache.flink.api.java.typeutils.&lt;/p&gt;
{GenericTypeInfo, RowTypeInfo, TupleTypeInfo, TypeExtractor}
&lt;p&gt;     import org.apache.flink.api.scala._&lt;br/&gt;
    -import org.apache.flink.table.expressions.&lt;/p&gt;
{Alias, UnresolvedFieldReference}
&lt;p&gt;    -import org.apache.flink.table.runtime.types.CRowTypeInfo&lt;br/&gt;
    -import org.apache.flink.table.utils.&lt;/p&gt;
{MockTableEnvironment, TableTestBase}
&lt;p&gt;    +import org.apache.flink.table.api.TableEnvironmentTest._&lt;br/&gt;
    +import org.apache.flink.table.api.Types._&lt;br/&gt;
    +import org.apache.flink.table.api.scala._&lt;br/&gt;
    +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo.&lt;/p&gt;
{PROCTIME_INDICATOR =&amp;gt; PROCTIME}
&lt;p&gt;    +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo.&lt;/p&gt;
{ROWTIME_INDICATOR =&amp;gt; ROWTIME}
&lt;p&gt;    +import org.apache.flink.table.utils.TableTestBase&lt;br/&gt;
     import org.apache.flink.types.Row&lt;br/&gt;
    -import org.junit.Assert.assertEquals&lt;br/&gt;
    +import org.apache.flink.api.java.tuple.&lt;/p&gt;
{Tuple3 =&amp;gt; JTuple3}
&lt;p&gt;    +import org.apache.flink.api.java.typeutils.GenericTypeInfo&lt;br/&gt;
    +import org.apache.flink.api.scala.typeutils.UnitTypeInfo&lt;br/&gt;
     import org.junit.Test&lt;/p&gt;

&lt;p&gt;     class TableEnvironmentTest extends TableTestBase {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val tEnv = new MockTableEnvironment&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val tupleType = new TupleTypeInfo(&lt;/li&gt;
	&lt;li&gt;INT_TYPE_INFO,&lt;/li&gt;
	&lt;li&gt;STRING_TYPE_INFO,&lt;/li&gt;
	&lt;li&gt;DOUBLE_TYPE_INFO)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val rowType = new RowTypeInfo(INT_TYPE_INFO, STRING_TYPE_INFO,DOUBLE_TYPE_INFO)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val cRowType = new CRowTypeInfo(rowType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val caseClassType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;CClass&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;CClass&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val pojoType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;PojoClass&amp;#93;&lt;/span&gt; = TypeExtractor.createTypeInfo(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;PojoClass&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val atomicType = INT_TYPE_INFO&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val genericRowType = new GenericTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;br/&gt;
    +  // schema definition by position&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoRow(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(rowType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testProjectByPosition(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a, &apos;b, &apos;c),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a, &apos;b),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable(&apos;a, &apos;b, &apos;c)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;a, &apos;b)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;a)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoRowNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;rowType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithAddingTimeAttributesByPosition(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c , &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoTuple(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(tupleType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamAliasWithReplacingTimeAttributesByPosition(): Unit = {&lt;br/&gt;
    +    val util = streamTestUtil()&lt;br/&gt;
    +&lt;br/&gt;
    +    // case class&lt;br/&gt;
    +    util.verifySchema(&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;CClassWithTime&amp;#93;&lt;/span&gt;(&apos;a, &apos;b.rowtime, &apos;c),&lt;br/&gt;
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))&lt;br/&gt;
    +&lt;br/&gt;
    +    util.verifySchema(&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;CClassWithTime&amp;#93;&lt;/span&gt;(&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Yes we could. I just tested the case. But it does make much sense.&lt;/p&gt;</comment>
                            <comment id="16313065" author="githubbot" created="Fri, 5 Jan 2018 13:05:49 +0000"  >&lt;p&gt;Github user twalthr commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159871785&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159871785&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala &amp;#8212;&lt;br/&gt;
    @@ -18,231 +18,574 @@&lt;/p&gt;

&lt;p&gt;     package org.apache.flink.table.api&lt;/p&gt;

&lt;p&gt;    -import org.apache.flink.api.common.typeinfo.BasicTypeInfo._&lt;br/&gt;
     import org.apache.flink.api.common.typeinfo.TypeInformation&lt;br/&gt;
    -import org.apache.flink.api.java.typeutils.&lt;/p&gt;
{GenericTypeInfo, RowTypeInfo, TupleTypeInfo, TypeExtractor}
&lt;p&gt;     import org.apache.flink.api.scala._&lt;br/&gt;
    -import org.apache.flink.table.expressions.&lt;/p&gt;
{Alias, UnresolvedFieldReference}
&lt;p&gt;    -import org.apache.flink.table.runtime.types.CRowTypeInfo&lt;br/&gt;
    -import org.apache.flink.table.utils.&lt;/p&gt;
{MockTableEnvironment, TableTestBase}
&lt;p&gt;    +import org.apache.flink.table.api.TableEnvironmentTest._&lt;br/&gt;
    +import org.apache.flink.table.api.Types._&lt;br/&gt;
    +import org.apache.flink.table.api.scala._&lt;br/&gt;
    +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo.&lt;/p&gt;
{PROCTIME_INDICATOR =&amp;gt; PROCTIME}
&lt;p&gt;    +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo.&lt;/p&gt;
{ROWTIME_INDICATOR =&amp;gt; ROWTIME}
&lt;p&gt;    +import org.apache.flink.table.utils.TableTestBase&lt;br/&gt;
     import org.apache.flink.types.Row&lt;br/&gt;
    -import org.junit.Assert.assertEquals&lt;br/&gt;
    +import org.apache.flink.api.java.tuple.&lt;/p&gt;
{Tuple3 =&amp;gt; JTuple3}
&lt;p&gt;    +import org.apache.flink.api.java.typeutils.GenericTypeInfo&lt;br/&gt;
    +import org.apache.flink.api.scala.typeutils.UnitTypeInfo&lt;br/&gt;
     import org.junit.Test&lt;/p&gt;

&lt;p&gt;     class TableEnvironmentTest extends TableTestBase {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val tEnv = new MockTableEnvironment&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val tupleType = new TupleTypeInfo(&lt;/li&gt;
	&lt;li&gt;INT_TYPE_INFO,&lt;/li&gt;
	&lt;li&gt;STRING_TYPE_INFO,&lt;/li&gt;
	&lt;li&gt;DOUBLE_TYPE_INFO)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val rowType = new RowTypeInfo(INT_TYPE_INFO, STRING_TYPE_INFO,DOUBLE_TYPE_INFO)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val cRowType = new CRowTypeInfo(rowType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val caseClassType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;CClass&amp;#93;&lt;/span&gt; = implicitly[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;CClass&amp;#93;&lt;/span&gt;]&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val pojoType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;PojoClass&amp;#93;&lt;/span&gt; = TypeExtractor.createTypeInfo(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;PojoClass&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val atomicType = INT_TYPE_INFO&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val genericRowType = new GenericTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;br/&gt;
    +  // schema definition by position&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoRow(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(rowType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testProjectByPosition(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a, &apos;b, &apos;c),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a, &apos;b),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;a),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable(&apos;a, &apos;b, &apos;c)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;a, &apos;b)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;a)(TEST_ROW),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b),
    +        Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;a),
    +        Seq(&quot;a&quot; -&amp;gt; INT))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoRowNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;rowType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithAddingTimeAttributesByPosition(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c , &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;a, &apos;b, &apos;c, &apos;rowtime.rowtime, &apos;proctime.proctime),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; STRING, &quot;c&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;proctime&quot; -&amp;gt; PROCTIME))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoTuple(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(tupleType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;, &quot;f1&quot;, &quot;f2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamAliasWithReplacingTimeAttributesByPosition(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;a, &apos;b.rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;a, &apos;b.rowtime, &apos;c)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;b&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;a, (&apos;b as &apos;new).rowtime, &apos;c)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;a, (&apos;b as &apos;new).rowtime, &apos;c),
    +      Seq(&quot;a&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;c&quot; -&amp;gt; STRING))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;def testGetFieldInfoCClass(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(caseClassType)&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;br/&gt;
    +  // schema definition by name&lt;br/&gt;
    +  // ----------------------------------------------------------------------------------------------&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;cf1&quot;, &quot;cf2&quot;, &quot;cf3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  @Test&lt;br/&gt;
    +  def testProjectByName(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // atomic
    +      util.verifySchema(
    +        util.addTable[Int](),
    +        Seq(&quot;f0&quot; -&amp;gt; INT))
    +
    +      util.verifySchema(
    +        util.addTable[Int](&apos;myint),
    +        Seq(&quot;myint&quot; -&amp;gt; INT))
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf2&quot; -&amp;gt; STRING, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf1, &apos;cf2),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf2&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf1, &apos;cf3),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf3, &apos;cf1),
    +        Seq(&quot;cf3&quot; -&amp;gt; DOUBLE, &quot;cf1&quot; -&amp;gt; INT))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable()(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf2&quot; -&amp;gt; STRING, &quot;rf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;rf1, &apos;rf2)(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf2&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;rf1, &apos;rf3)(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable(&apos;rf3, &apos;rf1)(TEST_ROW),
    +        Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f1&quot; -&amp;gt; STRING, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f1),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f1&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f2),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f2, &apos;f0),
    +        Seq(&quot;f2&quot; -&amp;gt; DOUBLE, &quot;f0&quot; -&amp;gt; INT))
    +
    +      // pojo
    +      util.verifySchema(
    +        util.addTable[PojoClass](),
    +        Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf2&quot; -&amp;gt; STRING, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[PojoClass](&apos;pf1, &apos;pf2),
    +        Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf2&quot; -&amp;gt; STRING))
    +
    +      util.verifySchema(
    +        util.addTable[PojoClass](&apos;pf1, &apos;pf3),
    +        Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +      util.verifySchema(
    +        util.addTable[PojoClass](&apos;pf3, &apos;pf1),
    +        Seq(&quot;pf3&quot; -&amp;gt; DOUBLE, &quot;pf1&quot; -&amp;gt; INT))
    +
    +      // generic
    +      util.verifySchema(
    +        util.addTable[Class[_]](&apos;mygeneric),
    +        Seq(&quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +      util.verifySchema(
    +        util.addTable[Class[_]](),
    +        Seq(&quot;f0&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +      // any type info
    +      util.verifySchema(
    +        util.addTable[Unit](),
    +        Seq(&quot;f0&quot; -&amp;gt; new UnitTypeInfo()))
    +
    +      util.verifySchema(
    +        util.addTable[Unit](&apos;unit),
    +        Seq(&quot;unit&quot; -&amp;gt; new UnitTypeInfo()))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoPojo(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(pojoType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;pf1&quot;, &quot;pf2&quot;, &quot;pf3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithAddingTimeAttributesByName(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // atomic
    +    util.verifySchema(
    +      util.addTable[Int](&apos;proctime.proctime, &apos;myint),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;myint&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[Int](&apos;rowtime.rowtime, &apos;myint),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;myint&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[Int](&apos;myint, &apos;proctime.proctime),
    +      Seq(&quot;myint&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[Int](&apos;myint, &apos;rowtime.rowtime),
    +      Seq(&quot;myint&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;proctime.proctime, &apos;cf1, &apos;cf3),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;rowtime.rowtime, &apos;cf3, &apos;cf1),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;cf3&quot; -&amp;gt; DOUBLE, &quot;cf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf1, &apos;proctime.proctime, &apos;cf3),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;cf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf3, &apos;rowtime.rowtime, &apos;cf1),
    +      Seq(&quot;cf3&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;cf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf1, &apos;cf3, &apos;proctime.proctime),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[CClass](&apos;cf3, &apos;cf1, &apos;rowtime.rowtime),
    +      Seq(&quot;cf3&quot; -&amp;gt; DOUBLE, &quot;cf1&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;proctime.proctime, &apos;rf1, &apos;rf3)(TEST_ROW),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rowtime.rowtime, &apos;rf3, &apos;rf1)(TEST_ROW),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;proctime.proctime, &apos;rf1)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;rf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;rowtime.rowtime, &apos;rf1)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;rf1&quot; -&amp;gt; INT))
    +
    +        util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;rf1, &apos;proctime.proctime)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +        util.verifySchema(
    +      util.addTable(&apos;rf3, &apos;rf1, &apos;rowtime.rowtime)(TEST_ROW),
    +      Seq(&quot;rf3&quot; -&amp;gt; DOUBLE, &quot;rf1&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;proctime.proctime, &apos;f0, &apos;f2),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;rowtime.rowtime, &apos;f2, &apos;f0),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;f2&quot; -&amp;gt; DOUBLE, &quot;f0&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;proctime.proctime, &apos;f2),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;f2&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f2, &apos;rowtime.rowtime, &apos;f0),
    +      Seq(&quot;f2&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;f0&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f2, &apos;proctime.proctime),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, String, Double]](&apos;f2, &apos;f0, &apos;rowtime.rowtime),
    +      Seq(&quot;f2&quot; -&amp;gt; DOUBLE, &quot;f0&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // pojo
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;proctime.proctime, &apos;pf1, &apos;pf3),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;pf1&quot; -&amp;gt; INT, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;rowtime.rowtime, &apos;pf3, &apos;pf1),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;pf3&quot; -&amp;gt; DOUBLE, &quot;pf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf1, &apos;proctime.proctime, &apos;pf3),
    +      Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;proctime&quot; -&amp;gt; PROCTIME, &quot;pf3&quot; -&amp;gt; DOUBLE))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf3, &apos;rowtime.rowtime, &apos;pf1),
    +      Seq(&quot;pf3&quot; -&amp;gt; DOUBLE, &quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;pf1&quot; -&amp;gt; INT))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf1, &apos;pf3, &apos;proctime.proctime),
    +      Seq(&quot;pf1&quot; -&amp;gt; INT, &quot;pf3&quot; -&amp;gt; DOUBLE, &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[PojoClass](&apos;pf3, &apos;pf1, &apos;rowtime.rowtime),
    +      Seq(&quot;pf3&quot; -&amp;gt; DOUBLE, &quot;pf1&quot; -&amp;gt; INT, &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // generic
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;proctime.proctime, &apos;mygeneric),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;rowtime.rowtime, &apos;mygeneric),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]])))
    +
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;mygeneric, &apos;proctime.proctime),
    +      Seq(&quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]]), &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[Class[_]](&apos;mygeneric, &apos;rowtime.rowtime),
    +      Seq(&quot;mygeneric&quot; -&amp;gt; new GenericTypeInfo[Class[_]](classOf[Class[_]]), &quot;rowtime&quot; -&amp;gt; ROWTIME))
    +
    +    // any type info
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;proctime.proctime, &apos;unit),
    +      Seq(&quot;proctime&quot; -&amp;gt; PROCTIME, &quot;unit&quot; -&amp;gt; new UnitTypeInfo()))
    +
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;rowtime.rowtime, &apos;unit),
    +      Seq(&quot;rowtime&quot; -&amp;gt; ROWTIME, &quot;unit&quot; -&amp;gt; new UnitTypeInfo()))
    +
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;unit, &apos;proctime.proctime),
    +      Seq(&quot;unit&quot; -&amp;gt; new UnitTypeInfo(), &quot;proctime&quot; -&amp;gt; PROCTIME))
    +
    +    util.verifySchema(
    +      util.addTable[Unit](&apos;unit, &apos;rowtime.rowtime),
    +      Seq(&quot;unit&quot; -&amp;gt; new UnitTypeInfo(), &quot;rowtime&quot; -&amp;gt; ROWTIME))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoAtomic(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(atomicType)&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;f0&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamProjectWithReplacingTimeAttributesByName(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // atomic
    +    util.verifySchema(
    +      util.addTable[Int](&apos;myint.proctime),
    +      Seq(&quot;myint&quot; -&amp;gt; PROCTIME))
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;cf1, &apos;cf3.proctime, &apos;cf2),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; PROCTIME, &quot;cf2&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;cf1, &apos;cf3.rowtime, &apos;cf2),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;cf3&quot; -&amp;gt; ROWTIME, &quot;cf2&quot; -&amp;gt; LONG))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;rf1, &apos;rf3.proctime, &apos;rf2)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; PROCTIME, &quot;rf2&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf1, &apos;rf3.rowtime, &apos;rf2)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;rf3&quot; -&amp;gt; ROWTIME, &quot;rf2&quot; -&amp;gt; LONG))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;f0, &apos;f2.proctime, &apos;f1),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; PROCTIME, &quot;f1&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;f0, &apos;f2.rowtime, &apos;f1),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;f2&quot; -&amp;gt; ROWTIME, &quot;f1&quot; -&amp;gt; LONG))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoTupleNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;tupleType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testAliasByName(): Unit = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    val utils = Seq(streamTestUtil(), batchTestUtil())    +    +    utils.foreach { util =&amp;gt;
    +
    +      // atomic
    +      util.verifySchema(
    +        util.addTable[Int](&apos;myint as &apos;new),
    +        Seq(&quot;new&quot; -&amp;gt; INT))
    +
    +      // case class
    +      util.verifySchema(
    +        util.addTable[CClass](&apos;cf1, &apos;cf3 as &apos;new, &apos;cf2),
    +        Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; DOUBLE, &quot;cf2&quot; -&amp;gt; STRING))
    +
    +      // row
    +      util.verifySchema(
    +        util.addTable(&apos;rf1, &apos;rf3 as &apos;new, &apos;rf2)(TEST_ROW),
    +        Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; DOUBLE, &quot;rf2&quot; -&amp;gt; STRING))
    +
    +      // tuple
    +      util.verifySchema(
    +        util.addTable[JTuple3[Int, String, Double]](&apos;f0, &apos;f2 as &apos;new, &apos;f1),
    +        Seq(&quot;f0&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; DOUBLE, &quot;f1&quot; -&amp;gt; STRING))
    +    }       }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoCClassNames(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;caseClassType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name2&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;name3&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(0, 1, 2)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamAliasWithAddingTimeAttributesByName(): Unit = 
{
    +    val util = streamTestUtil()
    +
    +    // atomic
    +    util.verifySchema(
    +      util.addTable[Int]((&apos;myint as &apos;new).proctime),
    +      Seq(&quot;new&quot; -&amp;gt; PROCTIME))
    +
    +    // case class
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;cf1, (&apos;newnew as &apos;new).proctime, &apos;cf2),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; PROCTIME, &quot;cf2&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable[CClassWithTime](&apos;cf1, (&apos;newnew as &apos;new).rowtime, &apos;cf2),
    +      Seq(&quot;cf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;cf2&quot; -&amp;gt; LONG))
    +
    +    // row
    +    util.verifySchema(
    +      util.addTable(&apos;rf1, (&apos;newnew as &apos;new).proctime, &apos;rf2)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; PROCTIME, &quot;rf2&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable(&apos;rf1, (&apos;newnew as &apos;new).rowtime, &apos;rf2)(TEST_ROW_WITH_TIME),
    +      Seq(&quot;rf1&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;rf2&quot; -&amp;gt; LONG))
    +
    +    // tuple
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;f0, (&apos;newnew as &apos;new).proctime, &apos;f1),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; PROCTIME, &quot;f1&quot; -&amp;gt; LONG))
    +
    +    util.verifySchema(
    +      util.addTable[JTuple3[Int, Long, String]](&apos;f0, (&apos;newnew as &apos;new).rowtime, &apos;f1),
    +      Seq(&quot;f0&quot; -&amp;gt; INT, &quot;new&quot; -&amp;gt; ROWTIME, &quot;f1&quot; -&amp;gt; LONG))
       }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def testGetFieldInfoPojoNames2(): Unit = {&lt;/li&gt;
	&lt;li&gt;val fieldInfo = tEnv.getFieldInfo(&lt;/li&gt;
	&lt;li&gt;pojoType,&lt;/li&gt;
	&lt;li&gt;Array(&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;pf3&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;pf1&quot;),&lt;/li&gt;
	&lt;li&gt;UnresolvedFieldReference(&quot;pf2&quot;)&lt;/li&gt;
	&lt;li&gt;))&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;fieldInfo._1.zip(Array(&quot;pf3&quot;, &quot;pf1&quot;, &quot;pf2&quot;)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;/li&gt;
	&lt;li&gt;fieldInfo._2.zip(Array(2, 0, 1)).foreach(x =&amp;gt; assertEquals(x._2, x._1))&lt;br/&gt;
    +  def testStreamAliasWithReplacingTimeAttributesByName(): Unit = {&lt;br/&gt;
    +    val util = streamTestUtil()&lt;br/&gt;
    +&lt;br/&gt;
    +    // atomic&lt;br/&gt;
    +    util.verifySchema(&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;((&apos;myint as &apos;new).proctime),&lt;br/&gt;
    +      Seq(&quot;new&quot; -&amp;gt; PROCTIME))&lt;br/&gt;
    +&lt;br/&gt;
    +    // case class&lt;br/&gt;
    +    util.verifySchema(&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;CClassWithTime&amp;#93;&lt;/span&gt;(&apos;cf1, (&apos;cf3 as &apos;new).proctime, &apos;cf2),
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I removed this.&lt;/p&gt;</comment>
                            <comment id="16313206" author="githubbot" created="Fri, 5 Jan 2018 14:36:21 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159878296&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159878296&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala &amp;#8212;&lt;br/&gt;
    @@ -532,35 +527,27 @@ class TableEnvironmentTest extends TableTestBase {&lt;/p&gt;

&lt;p&gt;         // atomic&lt;br/&gt;
         util.verifySchema(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;((&apos;myint as &apos;new).proctime),&lt;/li&gt;
	&lt;li&gt;Seq(&quot;new&quot; -&amp;gt; PROCTIME))&lt;br/&gt;
    +      util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;Long&amp;#93;&lt;/span&gt;(&apos;new.rowtime),
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    No alias used in method that should check &quot;alias with replacing time attributes by name&quot;&lt;/p&gt;</comment>
                            <comment id="16313207" author="githubbot" created="Fri, 5 Jan 2018 14:36:21 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159880719&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159880719&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/StreamTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -492,11 +509,16 @@ abstract class StreamTableEnvironment(&lt;br/&gt;
               throw new TableException(&lt;br/&gt;
                 &quot;The proctime attribute can only be defined once in a table schema.&quot;)&lt;br/&gt;
           } else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// check that proctime is only appended&lt;/li&gt;
	&lt;li&gt;if (idx &amp;lt; fieldTypes.length) {&lt;/li&gt;
	&lt;li&gt;throw new TableException(&lt;/li&gt;
	&lt;li&gt;&quot;The proctime attribute can only be appended to the table schema and not replace &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;an existing field. Please move it to the end of the schema.&quot;)&lt;br/&gt;
    +        // if the fields are referenced by position,&lt;br/&gt;
    +        // it is only possible to append the time attribute at the end&lt;br/&gt;
    +        if (isRefByPos) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    +          // check that proctime is only appended    +          if (idx &amp;lt; fieldTypes.length) {
    +            throw new TableException(
    +              &quot;The proctime attribute can only be appended to the table schema and not replace &quot; +
    +                &quot;an existing field. Please move it to the end of the schema.&quot;)
    +          }             }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;             proctime = Some(idx, name)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    should we also check that the name of the proctime attribute is not in the fields of the input type?&lt;/p&gt;</comment>
                            <comment id="16313208" author="githubbot" created="Fri, 5 Jan 2018 14:36:21 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159877092&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159877092&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/TableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -855,42 +852,26 @@ abstract class TableEnvironment(val config: TableConfig) {&lt;br/&gt;
               &quot;An input of GenericTypeInfo&amp;lt;Row&amp;gt; cannot be converted to Table. &quot; +&lt;br/&gt;
                 &quot;Please specify the type of the input with a RowTypeInfo.&quot;)&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;case t: TupleTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; =&amp;gt;&lt;/li&gt;
	&lt;li&gt;exprs.zipWithIndex flatMap {&lt;/li&gt;
	&lt;li&gt;case (UnresolvedFieldReference(name: String), idx) =&amp;gt;&lt;/li&gt;
	&lt;li&gt;if (isReferenceByPosition) 
{
    -              Some((idx, name))
    -            }
&lt;p&gt; else &lt;/p&gt;
{
    -              referenceByName(name, t)
    -            }&lt;/li&gt;
	&lt;li&gt;case (Alias(UnresolvedFieldReference(origName), name: String, _), _) =&amp;gt;&lt;/li&gt;
	&lt;li&gt;val idx = t.getFieldIndex(origName)&lt;/li&gt;
	&lt;li&gt;if (idx &amp;lt; 0) {&lt;/li&gt;
	&lt;li&gt;throw new TableException(s&quot;$origName is not a field of type $t. &quot; +&lt;/li&gt;
	&lt;li&gt;s&quot;Expected: ${t.getFieldNames.mkString(&quot;, &quot;)}&quot;)&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;Some((idx, name))&lt;/li&gt;
	&lt;li&gt;case (_: TimeAttribute, _) =&amp;gt;&lt;/li&gt;
	&lt;li&gt;None&lt;/li&gt;
	&lt;li&gt;case _ =&amp;gt; throw new TableException(&lt;/li&gt;
	&lt;li&gt;&quot;Field reference expression or alias on field expression expected.&quot;)&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    +      case t: TupleTypeInfoBase&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; if t.isInstanceOf[TupleTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;] ||&lt;br/&gt;
    +        t.isInstanceOf[CaseClassTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt;] || t.isInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;RowTypeInfo&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +        // determine schema definition mode (by position or by name)&lt;br/&gt;
    +        val isRefByPos = isReferenceByPosition(t, exprs)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;case c: CaseClassTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;A&amp;#93;&lt;/span&gt; =&amp;gt;&lt;br/&gt;
             exprs.zipWithIndex flatMap {&lt;br/&gt;
               case (UnresolvedFieldReference(name: String), idx) =&amp;gt;&lt;/li&gt;
	&lt;li&gt;if (isReferenceByPosition) {&lt;br/&gt;
    +            if (isRefByPos) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    moving the `isRefByPos` check outside of the `match` might be easier to read?&lt;/p&gt;</comment>
                            <comment id="16313209" author="githubbot" created="Fri, 5 Jan 2018 14:36:21 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159876208&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159876208&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/StreamTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -446,52 +443,60 @@ abstract class StreamTableEnvironment(&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Checks for at most one rowtime and proctime attribute.&lt;/li&gt;
	&lt;li&gt;Returns the time attributes.&lt;br/&gt;
         *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @param isReferenceByPosition schema mode see [&lt;span class=&quot;error&quot;&gt;&amp;#91;isReferenceByPosition()&amp;#93;&lt;/span&gt;]&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@return rowtime attribute and proctime attribute&lt;br/&gt;
         */&lt;br/&gt;
       private def validateAndExtractTimeAttributes(&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;isReferenceByPosition: Boolean,&lt;br/&gt;
         streamType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;,&lt;br/&gt;
         exprs: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;)&lt;br/&gt;
       : (Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt;, Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt;) = {&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val fieldTypes: Array[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;] = streamType match {&lt;/li&gt;
	&lt;li&gt;case c: CompositeType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt; (0 until c.getArity).map(i =&amp;gt; c.getTypeAt&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).toArray&lt;/li&gt;
	&lt;li&gt;case t: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt; Array(t)&lt;br/&gt;
    +    val (isRefByPos, fieldTypes) = streamType match 
{
    +      case c: CompositeType[_] =&amp;gt;
    +        // determine schema definition mode (by position or by name)
    +        (isReferenceByPosition(c, exprs), (0 until c.getArity).map(i =&amp;gt; c.getTypeAt(i)).toArray)
    +      case t: TypeInformation[_] =&amp;gt;
    +        (false, Array(t))
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         var fieldNames: List&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt; = Nil&lt;br/&gt;
         var rowtime: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = None&lt;br/&gt;
         var proctime: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = None&lt;/p&gt;

&lt;p&gt;    +    def checkRowtimeType(t: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
    +      if (!(TypeCheckUtils.isLong(t) || TypeCheckUtils.isTimePoint(t))) &lt;/p&gt;
{
    +        throw new TableException(
    +          s&quot;The rowtime attribute can only replace a field with a valid time type, &quot; +
    +          s&quot;such as Timestamp or Long. But was: $t&quot;)
    +      }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
         def extractRowtime(idx: Int, name: String, origName: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
           if (rowtime.isDefined) &lt;/p&gt;
{
             throw new TableException(
               &quot;The rowtime attribute can only be defined once in a table schema.&quot;)
           }
&lt;p&gt; else {&lt;br/&gt;
             // if the fields are referenced by position,&lt;br/&gt;
             // it is possible to replace an existing field or append the time attribute at the end&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (isReferenceByPosition) {&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;val mappedIdx = streamType match 
{
    -            case pti: PojoTypeInfo[_] =&amp;gt;
    -              pti.getFieldIndex(origName.getOrElse(name))
    -            case _ =&amp;gt; idx;
    -          }
&lt;p&gt;    -&lt;br/&gt;
    +        if (isRefByPos) {&lt;br/&gt;
               // check type of field that is replaced&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;if (mappedIdx &amp;lt; 0) {&lt;br/&gt;
    +          if (idx &amp;lt; 0) {&lt;br/&gt;
                 throw new TableException(&lt;br/&gt;
                   s&quot;The rowtime attribute can only replace a valid field. &quot; +&lt;br/&gt;
                     s&quot;${origName.getOrElse(name)} is not a field of type $streamType.&quot;)&lt;br/&gt;
               }&lt;/li&gt;
	&lt;li&gt;else if (mappedIdx &amp;lt; fieldTypes.length &amp;amp;&amp;amp;&lt;/li&gt;
	&lt;li&gt;!(TypeCheckUtils.isLong(fieldTypes(mappedIdx)) ||&lt;/li&gt;
	&lt;li&gt;TypeCheckUtils.isTimePoint(fieldTypes(mappedIdx)))) {&lt;/li&gt;
	&lt;li&gt;throw new TableException(&lt;/li&gt;
	&lt;li&gt;s&quot;The rowtime attribute can only replace a field with a valid time type, &quot; +&lt;/li&gt;
	&lt;li&gt;s&quot;such as Timestamp or Long. But was: ${fieldTypes(mappedIdx)}&quot;)&lt;br/&gt;
    +          else if (idx &amp;lt; fieldTypes.length) 
{
    +            checkRowtimeType(fieldTypes(idx))
    +          }
&lt;p&gt;    +        }&lt;br/&gt;
    +        // check for valid alias if referenced by name&lt;br/&gt;
    +        else if (origName.isDefined) {&lt;br/&gt;
    +          // check for valid alias&lt;br/&gt;
    +          streamType match {&lt;br/&gt;
    +            case ct: CompositeType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; if ct.hasField(origName.get) =&amp;gt;&lt;br/&gt;
    +              val t = ct.getTypeAt(ct.getFieldIndex(origName.get))&lt;br/&gt;
    +              checkRowtimeType(t)&lt;br/&gt;
    +            case _ =&amp;gt;&lt;br/&gt;
    +              throw new TableException(&quot;An alias must always reference an existing field.&quot;)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Add `origName` (and the existing fields?) to the error message.&lt;/p&gt;</comment>
                            <comment id="16313210" author="githubbot" created="Fri, 5 Jan 2018 14:36:21 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159885776&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159885776&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/StreamTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -450,37 +450,54 @@ abstract class StreamTableEnvironment(&lt;br/&gt;
         exprs: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;)&lt;br/&gt;
       : (Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt;, Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt;) = {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val fieldTypes: Array[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;] = streamType match {&lt;/li&gt;
	&lt;li&gt;case c: CompositeType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt; (0 until c.getArity).map(i =&amp;gt; c.getTypeAt&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).toArray&lt;/li&gt;
	&lt;li&gt;case a: AtomicType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt; Array(a)&lt;br/&gt;
    +    val (isRefByPos, fieldTypes) = streamType match 
{
    +      case c: CompositeType[_] =&amp;gt;
    +        // determine schema definition mode (by position or by name)
    +        (isReferenceByPosition(c, exprs), (0 until c.getArity).map(i =&amp;gt; c.getTypeAt(i)).toArray)
    +      case t: TypeInformation[_] =&amp;gt;
    +        (false, Array(t))
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         var fieldNames: List&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt; = Nil&lt;br/&gt;
         var rowtime: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = None&lt;br/&gt;
         var proctime: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = None&lt;/p&gt;

&lt;p&gt;    +    def checkRowtimeType(t: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
    +      if (!(TypeCheckUtils.isLong(t) || TypeCheckUtils.isTimePoint(t))) &lt;/p&gt;
{
    +        throw new TableException(
    +          s&quot;The rowtime attribute can only replace a field with a valid time type, &quot; +
    +          s&quot;such as Timestamp or Long. But was: $t&quot;)
    +      }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
         def extractRowtime(idx: Int, name: String, origName: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
           if (rowtime.isDefined) &lt;/p&gt;
{
             throw new TableException(
               &quot;The rowtime attribute can only be defined once in a table schema.&quot;)
           }
&lt;p&gt; else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val mappedIdx = streamType match {&lt;/li&gt;
	&lt;li&gt;case pti: PojoTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt;&lt;/li&gt;
	&lt;li&gt;pti.getFieldIndex(origName.getOrElse(name))&lt;/li&gt;
	&lt;li&gt;case _ =&amp;gt; idx;&lt;br/&gt;
    +        // if the fields are referenced by position,&lt;br/&gt;
    +        // it is possible to replace an existing field or append the time attribute at the end&lt;br/&gt;
    +        if (isRefByPos) {&lt;br/&gt;
    +          // check type of field that is replaced&lt;br/&gt;
    +          if (idx &amp;lt; 0) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I think this will never be `true` because the method is called with `idx` being an index of `exprs`&lt;/p&gt;</comment>
                            <comment id="16313211" author="githubbot" created="Fri, 5 Jan 2018 14:36:21 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159887168&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159887168&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/StreamTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -450,37 +450,54 @@ abstract class StreamTableEnvironment(&lt;br/&gt;
         exprs: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;)&lt;br/&gt;
       : (Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt;, Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt;) = {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val fieldTypes: Array[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;] = streamType match {&lt;/li&gt;
	&lt;li&gt;case c: CompositeType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt; (0 until c.getArity).map(i =&amp;gt; c.getTypeAt&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).toArray&lt;/li&gt;
	&lt;li&gt;case a: AtomicType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt; Array(a)&lt;br/&gt;
    +    val (isRefByPos, fieldTypes) = streamType match 
{
    +      case c: CompositeType[_] =&amp;gt;
    +        // determine schema definition mode (by position or by name)
    +        (isReferenceByPosition(c, exprs), (0 until c.getArity).map(i =&amp;gt; c.getTypeAt(i)).toArray)
    +      case t: TypeInformation[_] =&amp;gt;
    +        (false, Array(t))
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         var fieldNames: List&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt; = Nil&lt;br/&gt;
         var rowtime: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = None&lt;br/&gt;
         var proctime: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = None&lt;/p&gt;

&lt;p&gt;    +    def checkRowtimeType(t: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
    +      if (!(TypeCheckUtils.isLong(t) || TypeCheckUtils.isTimePoint(t))) &lt;/p&gt;
{
    +        throw new TableException(
    +          s&quot;The rowtime attribute can only replace a field with a valid time type, &quot; +
    +          s&quot;such as Timestamp or Long. But was: $t&quot;)
    +      }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
         def extractRowtime(idx: Int, name: String, origName: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
           if (rowtime.isDefined) &lt;/p&gt;
{
             throw new TableException(
               &quot;The rowtime attribute can only be defined once in a table schema.&quot;)
           }
&lt;p&gt; else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val mappedIdx = streamType match {&lt;/li&gt;
	&lt;li&gt;case pti: PojoTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt;&lt;/li&gt;
	&lt;li&gt;pti.getFieldIndex(origName.getOrElse(name))&lt;/li&gt;
	&lt;li&gt;case _ =&amp;gt; idx;&lt;br/&gt;
    +        // if the fields are referenced by position,&lt;br/&gt;
    +        // it is possible to replace an existing field or append the time attribute at the end&lt;br/&gt;
    +        if (isRefByPos) {&lt;br/&gt;
    +          // check type of field that is replaced&lt;br/&gt;
    +          if (idx &amp;lt; 0) {&lt;br/&gt;
    +            throw new TableException(&lt;br/&gt;
    +              s&quot;The rowtime attribute can only replace a valid field. &quot; +&lt;br/&gt;
    +                s&quot;${origName.getOrElse(name)} is not a field of type $streamType.&quot;)&lt;br/&gt;
    +          }&lt;br/&gt;
    +          else if (idx &amp;lt; fieldTypes.length) 
{
    +            checkRowtimeType(fieldTypes(idx))
    +          }
&lt;p&gt;             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// check type of field that is replaced&lt;/li&gt;
	&lt;li&gt;if (mappedIdx &amp;lt; 0) {&lt;/li&gt;
	&lt;li&gt;throw new TableException(&lt;/li&gt;
	&lt;li&gt;s&quot;The rowtime attribute can only replace a valid field. &quot; +&lt;/li&gt;
	&lt;li&gt;s&quot;${origName.getOrElse(name)} is not a field of type $streamType.&quot;)&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;else if (mappedIdx &amp;lt; fieldTypes.length &amp;amp;&amp;amp;&lt;/li&gt;
	&lt;li&gt;!(TypeCheckUtils.isLong(fieldTypes(mappedIdx)) ||&lt;/li&gt;
	&lt;li&gt;TypeCheckUtils.isTimePoint(fieldTypes(mappedIdx)))) {&lt;/li&gt;
	&lt;li&gt;throw new TableException(&lt;/li&gt;
	&lt;li&gt;s&quot;The rowtime attribute can only replace a field with a valid time type, &quot; +&lt;/li&gt;
	&lt;li&gt;s&quot;such as Timestamp or Long. But was: ${fieldTypes(mappedIdx)}&quot;)&lt;br/&gt;
    +        // check for valid alias if referenced by name&lt;br/&gt;
    +        else if (origName.isDefined) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    we should also check the field type for ref-by-name if no alias is used and the name references a field that exists in the input, e.g., for `Tuple3` `(&apos;f1, &apos;f0.rowtime, &apos;f2)`.&lt;/p&gt;</comment>
                            <comment id="16313212" author="githubbot" created="Fri, 5 Jan 2018 14:36:21 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159878618&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159878618&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/stream/StreamTableEnvironmentValidationTest.scala &amp;#8212;&lt;br/&gt;
    @@ -138,4 +145,25 @@ class StreamTableEnvironmentValidationTest extends TableTestBase &lt;/p&gt;
{
         // we mix reference by position and by name
         util.addTable[(Long, Int, String, Int, Long)](&apos;x, &apos;_1)
       }
&lt;p&gt;    +&lt;br/&gt;
    +  @Test(expected = classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;TableException&amp;#93;&lt;/span&gt;)&lt;br/&gt;
    +  def testInvalidAliasWithProctimeAttribute(): Unit = {&lt;br/&gt;
    +    val util = streamTestUtil()&lt;br/&gt;
    +    // alias in proctime not allowed&lt;br/&gt;
    +    util.addTable&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, Long, String)&amp;#93;&lt;/span&gt;(&apos;_1, (&apos;newnew as &apos;new).proctime, &apos;_3)&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    also add a test where proctime alias references an existing field and a test for `&apos;x.proctime` where `&apos;x` is a valid field (if there isn&apos;t such a test yet).&lt;/p&gt;
</comment>
                            <comment id="16313213" author="githubbot" created="Fri, 5 Jan 2018 14:36:21 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159889511&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159889511&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/StreamTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -450,37 +450,54 @@ abstract class StreamTableEnvironment(&lt;br/&gt;
         exprs: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Expression&amp;#93;&lt;/span&gt;)&lt;br/&gt;
       : (Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt;, Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt;) = {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val fieldTypes: Array[TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;] = streamType match {&lt;/li&gt;
	&lt;li&gt;case c: CompositeType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt; (0 until c.getArity).map(i =&amp;gt; c.getTypeAt&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).toArray&lt;/li&gt;
	&lt;li&gt;case a: AtomicType&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt; Array(a)&lt;br/&gt;
    +    val (isRefByPos, fieldTypes) = streamType match 
{
    +      case c: CompositeType[_] =&amp;gt;
    +        // determine schema definition mode (by position or by name)
    +        (isReferenceByPosition(c, exprs), (0 until c.getArity).map(i =&amp;gt; c.getTypeAt(i)).toArray)
    +      case t: TypeInformation[_] =&amp;gt;
    +        (false, Array(t))
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         var fieldNames: List&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt; = Nil&lt;br/&gt;
         var rowtime: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = None&lt;br/&gt;
         var proctime: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;(Int, String)&amp;#93;&lt;/span&gt; = None&lt;/p&gt;

&lt;p&gt;    +    def checkRowtimeType(t: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
    +      if (!(TypeCheckUtils.isLong(t) || TypeCheckUtils.isTimePoint(t))) &lt;/p&gt;
{
    +        throw new TableException(
    +          s&quot;The rowtime attribute can only replace a field with a valid time type, &quot; +
    +          s&quot;such as Timestamp or Long. But was: $t&quot;)
    +      }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
         def extractRowtime(idx: Int, name: String, origName: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
           if (rowtime.isDefined) &lt;/p&gt;
{
             throw new TableException(
               &quot;The rowtime attribute can only be defined once in a table schema.&quot;)
           }
&lt;p&gt; else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val mappedIdx = streamType match {&lt;/li&gt;
	&lt;li&gt;case pti: PojoTypeInfo&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; =&amp;gt;&lt;/li&gt;
	&lt;li&gt;pti.getFieldIndex(origName.getOrElse(name))&lt;/li&gt;
	&lt;li&gt;case _ =&amp;gt; idx;&lt;br/&gt;
    +        // if the fields are referenced by position,&lt;br/&gt;
    +        // it is possible to replace an existing field or append the time attribute at the end&lt;br/&gt;
    +        if (isRefByPos) {&lt;br/&gt;
    +          // check type of field that is replaced&lt;br/&gt;
    +          if (idx &amp;lt; 0) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    aliases are not permitted for regular fields in ref-by-pos mode. I think prohibit them for rowtime attributes as well by checking for `origName.isDefined`.&lt;/p&gt;</comment>
                            <comment id="16313446" author="githubbot" created="Fri, 5 Jan 2018 17:02:36 +0000"  >&lt;p&gt;Github user twalthr commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132#discussion_r159926701&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132#discussion_r159926701&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/api/StreamTableEnvironment.scala &amp;#8212;&lt;br/&gt;
    @@ -492,11 +509,16 @@ abstract class StreamTableEnvironment(&lt;br/&gt;
               throw new TableException(&lt;br/&gt;
                 &quot;The proctime attribute can only be defined once in a table schema.&quot;)&lt;br/&gt;
           } else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// check that proctime is only appended&lt;/li&gt;
	&lt;li&gt;if (idx &amp;lt; fieldTypes.length) {&lt;/li&gt;
	&lt;li&gt;throw new TableException(&lt;/li&gt;
	&lt;li&gt;&quot;The proctime attribute can only be appended to the table schema and not replace &quot; +&lt;/li&gt;
	&lt;li&gt;&quot;an existing field. Please move it to the end of the schema.&quot;)&lt;br/&gt;
    +        // if the fields are referenced by position,&lt;br/&gt;
    +        // it is only possible to append the time attribute at the end&lt;br/&gt;
    +        if (isRefByPos) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    +          // check that proctime is only appended    +          if (idx &amp;lt; fieldTypes.length) {
    +            throw new TableException(
    +              &quot;The proctime attribute can only be appended to the table schema and not replace &quot; +
    +                &quot;an existing field. Please move it to the end of the schema.&quot;)
    +          }             }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;             proctime = Some(idx, name)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I keep the current behavior because this allows to have arbitrary table schemas.&lt;/p&gt;</comment>
                            <comment id="16313494" author="githubbot" created="Fri, 5 Jan 2018 17:31:10 +0000"  >&lt;p&gt;Github user twalthr commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for the intensive review @fhueske. I will merge this now &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16313512" author="twalthr" created="Fri, 5 Jan 2018 17:39:57 +0000"  >&lt;p&gt;Fixed in 1.5: fb29898cd3507b2b94dd8bbf3dbfd2132b643a1d&lt;/p&gt;</comment>
                            <comment id="16313513" author="githubbot" created="Fri, 5 Jan 2018 17:40:54 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5132&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5132&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 45 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3njhj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>