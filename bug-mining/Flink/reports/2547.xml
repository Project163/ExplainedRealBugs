<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:34:17 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-9755] Exceptions in RemoteInputChannel#notifyBufferAvailable() are not propagated to the responsible thread</title>
                <link>https://issues.apache.org/jira/browse/FLINK-9755</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;The credit-based flow control implementation of RemoteInputChannel#notifyBufferAvailable() does not forward errors (like the &lt;tt&gt;IllegalStateException&lt;/tt&gt;) to the thread that is being notified. The calling code at &lt;tt&gt;LocalBufferPool#recycle&lt;/tt&gt;, however, relies on the callback forwarding errors and completely ignores any failures.&lt;/p&gt;

&lt;p&gt;Therefore, we could end up with a program waiting forever for the callback and not even a failure message in the logs.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13170142">FLINK-9755</key>
            <summary>Exceptions in RemoteInputChannel#notifyBufferAvailable() are not propagated to the responsible thread</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="nkruber">Nico Kruber</assignee>
                                    <reporter username="nkruber">Nico Kruber</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Wed, 4 Jul 2018 22:35:46 +0000</created>
                <updated>Thu, 19 Jul 2018 19:31:02 +0000</updated>
                            <resolved>Thu, 19 Jul 2018 19:31:02 +0000</resolved>
                                    <version>1.5.0</version>
                                    <fixVersion>1.5.2</fixVersion>
                    <fixVersion>1.6.0</fixVersion>
                                    <component>Runtime / Network</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="16534518" author="githubbot" created="Fri, 6 Jul 2018 07:19:48 +0000"  >&lt;p&gt;GitHub user NicoK opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9755&quot; title=&quot;Exceptions in RemoteInputChannel#notifyBufferAvailable() are not propagated to the responsible thread&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9755&quot;&gt;&lt;del&gt;FLINK-9755&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;network&amp;#93;&lt;/span&gt; forward exceptions in RemoteInputChannel#notifyBufferAvailable() to the responsible thread&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    Exceptions in `RemoteInputChannel#notifyBufferAvailable()`, e.g. state checks, were swallowed inside `LocalBufferPool#recycle()` and neither logged nor otherwise processed and may have lead to stalling processes waiting for a notification that never comes.&lt;/p&gt;

&lt;p&gt;    Please note that this PR builds upon #6271 which also touched the unit tests which we change here. @tillrohrmann, @zhijiangW can you have a look at this cleanup of `LocalBufferPool#recycle()`?&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;cleanup of `LocalBufferPool#recycle()` also clarifying the contract of `BufferListener#notifyBufferAvailable()` which should recycle the given buffer (one implementation already did that; `RemoteInputChannel` did not)&lt;/li&gt;
	&lt;li&gt;forward exceptions in `RemoteInputChannel#notifyBufferAvailable()` to the responsible channel and recycle the given buffer in that case&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This change added tests and can be verified as follows:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;added `RemoteInputChannelTest#testFailureInNotifyBufferAvailable()`&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The serializers: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? *&lt;b&gt;JavaDocs&lt;/b&gt;*&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/NicoK/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/NicoK/flink&lt;/a&gt; flink-9755&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #6272&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 0b623b66399915d43f29245da148fed63bf940bf&lt;br/&gt;
Author: Nico Kruber &amp;lt;nico@...&amp;gt;&lt;br/&gt;
Date:   2018-07-05T13:49:15Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9766&quot; title=&quot;Incomplete/incorrect cleanup in RemoteInputChannelTest&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9766&quot;&gt;&lt;del&gt;FLINK-9766&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;network&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;tests&amp;#93;&lt;/span&gt; fix cleanup in RemoteInputChannelTest&lt;/p&gt;

&lt;p&gt;    If an assertion in the test fails and as a result the cleanup fails, in most&lt;br/&gt;
    tests the original assertion was swallowed making it hard to debug.&lt;/p&gt;

&lt;p&gt;    Furthermore, #testConcurrentRecycleAndRelease2() does even not clean up at all&lt;br/&gt;
    if successful.&lt;/p&gt;

&lt;p&gt;commit 38a26a829b047ce1e50794470f979e708b0bb81f&lt;br/&gt;
Author: Nico Kruber &amp;lt;nico@...&amp;gt;&lt;br/&gt;
Date:   2018-07-04T22:48:33Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9755&quot; title=&quot;Exceptions in RemoteInputChannel#notifyBufferAvailable() are not propagated to the responsible thread&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9755&quot;&gt;&lt;del&gt;FLINK-9755&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;network&amp;#93;&lt;/span&gt; forward exceptions in RemoteInputChannel#notifyBufferAvailable() to the responsible thread&lt;/p&gt;

&lt;p&gt;    This mainly involves state checks but previously these have only been swallowed&lt;br/&gt;
    without re-registration or any other logging/handling. This may have lead to&lt;br/&gt;
    some thread stalling while waiting for the notification that never came.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16538213" author="githubbot" created="Tue, 10 Jul 2018 07:55:49 +0000"  >&lt;p&gt;Github user zhijiangW commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272#discussion_r201242662&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272#discussion_r201242662&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -360,32 +360,45 @@ public boolean notifyBufferAvailable(Buffer buffer) &lt;/p&gt;
{
     			return false;
     		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;boolean needMoreBuffers = false;&lt;/li&gt;
	&lt;li&gt;synchronized (bufferQueue) {&lt;/li&gt;
	&lt;li&gt;checkState(isWaitingForFloatingBuffers, &quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +		boolean recycleBuffer = true;&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			boolean needMoreBuffers = false;&lt;br/&gt;
    +			synchronized (bufferQueue) {&lt;br/&gt;
    +				checkState(isWaitingForFloatingBuffers,&lt;br/&gt;
    +					&quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +				// Important: double check the isReleased state inside synchronized block, so there is no&lt;br/&gt;
    +				// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;br/&gt;
    +				if (isReleased.get() ||&lt;br/&gt;
    +					bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    +					isWaitingForFloatingBuffers = false;
    +					buffer.recycleBuffer();
    +					return false;
    +				}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Important: double check the isReleased state inside synchronized block, so there is no&lt;/li&gt;
	&lt;li&gt;// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;/li&gt;
	&lt;li&gt;if (isReleased.get() || bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    -				isWaitingForFloatingBuffers = false;
    -				buffer.recycleBuffer();
    -				return false;
    -			}
&lt;p&gt;    +				// note: this call may fail, for better cleanup, increase the counter first&lt;br/&gt;
    +				if (unannouncedCredit.getAndAdd(1) == 0) {&lt;br/&gt;
    +					notifyCreditAvailable();&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    From failure point, `notifyCreditAvailable` should be called before `bufferQueue.addFloatingBuffer`. But from another point,  it seems more strict in logic to confirm buffer ready before announcing credit, otherwise the channel may receive new data before queuing this floating buffer, although it can hardly happen based on current implementation.&lt;/p&gt;

&lt;p&gt;    Another concern is that `notifyCreditAvailable` itself is thread safe. But considering handling failure easily, we place it under `synchronized` part. Currently the process of `notifyCreditAvailable` is very lightweight, so the cost can be ignored.&lt;/p&gt;

&lt;p&gt;    Maybe the above two concerns are unnecessary, and I can accept the current modifications.&lt;/p&gt;</comment>
                            <comment id="16538214" author="githubbot" created="Tue, 10 Jul 2018 07:55:49 +0000"  >&lt;p&gt;Github user zhijiangW commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272#discussion_r201247182&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272#discussion_r201247182&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java &amp;#8212;&lt;br/&gt;
    @@ -687,7 +690,65 @@ public void testFairDistributionFloatingBuffers() throws Exception {&lt;br/&gt;
     		} catch (Throwable t) &lt;/p&gt;
{
     			thrown = t;
     		}
&lt;p&gt; finally &lt;/p&gt;
{
    -			cleanup(networkBufferPool, null, thrown, channel1, channel2, channel3);
    +			cleanup(networkBufferPool, null, null, thrown, channel1, channel2, channel3);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Tests that failures are propagated correctly if&lt;br/&gt;
    +	 * &lt;/p&gt;
{@link RemoteInputChannel#notifyBufferAvailable(Buffer)}
&lt;p&gt; throws an exception. Also tests that&lt;br/&gt;
    +	 * a second listener will be notified in this case.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testFailureInNotifyBufferAvailable() throws Exception {&lt;br/&gt;
    +		// Setup&lt;br/&gt;
    +		final int numExclusiveBuffers = 0;&lt;br/&gt;
    +		final int numFloatingBuffers = 1;&lt;br/&gt;
    +		final int numTotalBuffers = numExclusiveBuffers + numFloatingBuffers;&lt;br/&gt;
    +		final NetworkBufferPool networkBufferPool = new NetworkBufferPool(&lt;br/&gt;
    +			numTotalBuffers, 32);&lt;br/&gt;
    +&lt;br/&gt;
    +		final SingleInputGate inputGate = createSingleInputGate();&lt;br/&gt;
    +		final RemoteInputChannel successfulRemoteIC = createRemoteInputChannel(inputGate);&lt;br/&gt;
    +		inputGate.setInputChannel(successfulRemoteIC.partitionId.getPartitionId(), successfulRemoteIC);&lt;br/&gt;
    +&lt;br/&gt;
    +//		inputGate.assignExclusiveSegments(networkBufferPool, numExclusiveBuffers);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    remove this annotated code?&lt;/p&gt;</comment>
                            <comment id="16538228" author="githubbot" created="Tue, 10 Jul 2018 08:04:10 +0000"  >&lt;p&gt;Github user zhijiangW commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for fixing this potential bug. &lt;br/&gt;
    It makes sense to handle exception during `notifyBufferAvailable` on listener side. Just some thoughts on my side above. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16538259" author="githubbot" created="Tue, 10 Jul 2018 08:40:26 +0000"  >&lt;p&gt;Github user NicoK commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272#discussion_r201260221&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272#discussion_r201260221&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -360,32 +360,45 @@ public boolean notifyBufferAvailable(Buffer buffer) &lt;/p&gt;
{
     			return false;
     		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;boolean needMoreBuffers = false;&lt;/li&gt;
	&lt;li&gt;synchronized (bufferQueue) {&lt;/li&gt;
	&lt;li&gt;checkState(isWaitingForFloatingBuffers, &quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +		boolean recycleBuffer = true;&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			boolean needMoreBuffers = false;&lt;br/&gt;
    +			synchronized (bufferQueue) {&lt;br/&gt;
    +				checkState(isWaitingForFloatingBuffers,&lt;br/&gt;
    +					&quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +				// Important: double check the isReleased state inside synchronized block, so there is no&lt;br/&gt;
    +				// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;br/&gt;
    +				if (isReleased.get() ||&lt;br/&gt;
    +					bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    +					isWaitingForFloatingBuffers = false;
    +					buffer.recycleBuffer();
    +					return false;
    +				}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Important: double check the isReleased state inside synchronized block, so there is no&lt;/li&gt;
	&lt;li&gt;// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;/li&gt;
	&lt;li&gt;if (isReleased.get() || bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    -				isWaitingForFloatingBuffers = false;
    -				buffer.recycleBuffer();
    -				return false;
    -			}
&lt;p&gt;    +				// note: this call may fail, for better cleanup, increase the counter first&lt;br/&gt;
    +				if (unannouncedCredit.getAndAdd(1) == 0) {&lt;br/&gt;
    +					notifyCreditAvailable();&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    yes, this one is a tricky one:&lt;br/&gt;
    Logically it should be: first adding the floating buffer, then enqueuing the channel. However, `notifyCreditAvailable()` is outside our control and could potentially fail. If it fails, we have two options:&lt;br/&gt;
    1) revert any change done by `notifyBufferAvailable()` and freeing the buffer so that it can be directly re-used by `LocalBufferPool`&lt;/p&gt;

&lt;p&gt;    2) keep everything done by `notifyBufferAvailable()` and rely on `setError()` to clean up eventually - this means we should not recycle the buffer if it was already added to the `bufferQueue`.&lt;/p&gt;

&lt;p&gt;    Giving it a second thought, it may indeed be better to go for solution 2 and keep the logical execution as you proposed (infact, now I can&apos;t really think of a reason why I did not do that). We should be able to steer the recycling via the `recycleBuffer` as is already done in other cases.&lt;/p&gt;</comment>
                            <comment id="16538270" author="githubbot" created="Tue, 10 Jul 2018 08:47:11 +0000"  >&lt;p&gt;Github user NicoK commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    thanks for the review - I changed the code as requested&lt;/p&gt;</comment>
                            <comment id="16538367" author="githubbot" created="Tue, 10 Jul 2018 10:26:29 +0000"  >&lt;p&gt;Github user zhijiangW commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272#discussion_r201292263&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272#discussion_r201292263&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -360,32 +360,45 @@ public boolean notifyBufferAvailable(Buffer buffer) &lt;/p&gt;
{
     			return false;
     		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;boolean needMoreBuffers = false;&lt;/li&gt;
	&lt;li&gt;synchronized (bufferQueue) {&lt;/li&gt;
	&lt;li&gt;checkState(isWaitingForFloatingBuffers, &quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +		boolean recycleBuffer = true;&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			boolean needMoreBuffers = false;&lt;br/&gt;
    +			synchronized (bufferQueue) {&lt;br/&gt;
    +				checkState(isWaitingForFloatingBuffers,&lt;br/&gt;
    +					&quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +				// Important: double check the isReleased state inside synchronized block, so there is no&lt;br/&gt;
    +				// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;br/&gt;
    +				if (isReleased.get() ||&lt;br/&gt;
    +					bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    +					isWaitingForFloatingBuffers = false;
    +					buffer.recycleBuffer();
    +					return false;
    +				}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Important: double check the isReleased state inside synchronized block, so there is no&lt;/li&gt;
	&lt;li&gt;// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;/li&gt;
	&lt;li&gt;if (isReleased.get() || bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    -				isWaitingForFloatingBuffers = false;
    -				buffer.recycleBuffer();
    -				return false;
    -			}
&lt;p&gt;    +				// note: this call may fail, for better cleanup, increase the counter first&lt;br/&gt;
    +				if (unannouncedCredit.getAndAdd(1) == 0) {&lt;br/&gt;
    +					notifyCreditAvailable();&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    &#128077;&lt;/p&gt;</comment>
                            <comment id="16538368" author="githubbot" created="Tue, 10 Jul 2018 10:26:38 +0000"  >&lt;p&gt;Github user zhijiangW commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    LGTM!&lt;/p&gt;</comment>
                            <comment id="16538520" author="githubbot" created="Tue, 10 Jul 2018 12:52:02 +0000"  >&lt;p&gt;Github user NicoK commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    actually, I forgot to adapt the unit test which relied on the previous order of the calls and assumed that the buffer got recycled. With the changes from the fixup, the buffer is not recycled by the failure directly but rather during error handling which will eventually release the channel&apos;s resources.&lt;br/&gt;
    -&amp;gt; this is now fixed as well&lt;/p&gt;</comment>
                            <comment id="16540298" author="githubbot" created="Wed, 11 Jul 2018 16:09:47 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272#discussion_r201743330&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272#discussion_r201743330&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java &amp;#8212;&lt;br/&gt;
    @@ -258,12 +258,12 @@ private MemorySegment requestMemorySegment(boolean isBlocking) throws Interrupte&lt;br/&gt;
     	@Override&lt;br/&gt;
     	public void recycle(MemorySegment segment) {&lt;br/&gt;
     		BufferListener listener;&lt;br/&gt;
    +		boolean needMoreBuffers = false;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    why did you move this declaration up here? Inline it with `needMoreBuffers = listener.notifyBufferAvailable(...)`?&lt;/p&gt;</comment>
                            <comment id="16540299" author="githubbot" created="Wed, 11 Jul 2018 16:09:47 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272#discussion_r201744892&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272#discussion_r201744892&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java &amp;#8212;&lt;br/&gt;
    @@ -277,37 +277,17 @@ public void recycle(MemorySegment segment) {&lt;br/&gt;
     		// We do not know which locks have been acquired before the recycle() or are needed in the&lt;br/&gt;
     		// notification and which other threads also access them.&lt;br/&gt;
     		// -&amp;gt; call notifyBufferAvailable() outside of the synchronized block to avoid a deadlock (&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9676&quot; title=&quot;Deadlock during canceling task and recycling exclusive buffer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9676&quot;&gt;&lt;del&gt;FLINK-9676&lt;/del&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;boolean success = false;&lt;/li&gt;
	&lt;li&gt;boolean needMoreBuffers = false;&lt;/li&gt;
	&lt;li&gt;try 
{
    -			needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));
    -			success = true;
    -		}
&lt;p&gt; catch (Throwable ignored) &lt;/p&gt;
{
    -			// handled below, under the lock
    -		}
&lt;p&gt;    +		// Note that in case of any exceptions notifyBufferAvailable() should recycle the buffer and&lt;br/&gt;
    +		// therefore end up in this method again.&lt;br/&gt;
    +		needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (!success || needMoreBuffers) {&lt;br/&gt;
    +		if (needMoreBuffers) {&lt;br/&gt;
     			synchronized (availableMemorySegments) {&lt;br/&gt;
     				if (isDestroyed) {&lt;br/&gt;
     					// cleanup tasks how they would have been done if we only had one synchronized block&lt;/li&gt;
	&lt;li&gt;if (needMoreBuffers) 
{
    -						listener.notifyBufferDestroyed();
    -					}&lt;/li&gt;
	&lt;li&gt;if (!success) 
{
    -						returnMemorySegment(segment);
    -					}
&lt;p&gt;    +					listener.notifyBufferDestroyed();&lt;br/&gt;
     				} else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;if (needMoreBuffers) 
{
    -						registeredListeners.add(listener);
    -					}&lt;/li&gt;
	&lt;li&gt;if (!success) {&lt;/li&gt;
	&lt;li&gt;if (numberOfRequestedMemorySegments &amp;gt; currentPoolSize) 
{
    -							returnMemorySegment(segment);
    -						}
&lt;p&gt; else &lt;/p&gt;
{
    -							availableMemorySegments.add(segment);
    -							availableMemorySegments.notify();
    -						}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    +					registeredListeners.add(listener);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    If there is an exception being thrown, this will not be called. Is that how it supposed to be?&lt;/p&gt;</comment>
                            <comment id="16540300" author="githubbot" created="Wed, 11 Jul 2018 16:09:47 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272#discussion_r201744623&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272#discussion_r201744623&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferListener.java &amp;#8212;&lt;br/&gt;
    @@ -27,6 +27,13 @@&lt;br/&gt;
     	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Notification callback if a buffer is recycled and becomes available in buffer pool.&lt;br/&gt;
     	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;Note: responsibility on recycling the given buffer is transferred to this implementation,&lt;br/&gt;
    +	 * including any errors that lead to exceptions being thrown!&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;BEWARE:&amp;lt;/strong&amp;gt; since this may be called from outside the thread that relies on&lt;br/&gt;
    +	 * the listener&apos;s logic, any exception that occurs with this handler should be forwarded to the&lt;br/&gt;
    +	 * responsible thread for handling (the buffer pool ignores any 
{@link Throwable}
&lt;p&gt; from here!).&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    However now `LocalBufferPool` is not ignoring exceptions, but it is forwarding them&lt;/p&gt;</comment>
                            <comment id="16540301" author="githubbot" created="Wed, 11 Jul 2018 16:09:47 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272#discussion_r201752234&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272#discussion_r201752234&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -360,32 +360,44 @@ public boolean notifyBufferAvailable(Buffer buffer) &lt;/p&gt;
{
     			return false;
     		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;boolean needMoreBuffers = false;&lt;/li&gt;
	&lt;li&gt;synchronized (bufferQueue) {&lt;/li&gt;
	&lt;li&gt;checkState(isWaitingForFloatingBuffers, &quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +		boolean recycleBuffer = true;&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			boolean needMoreBuffers = false;&lt;br/&gt;
    +			synchronized (bufferQueue) {&lt;br/&gt;
    +				checkState(isWaitingForFloatingBuffers,&lt;br/&gt;
    +					&quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +				// Important: double check the isReleased state inside synchronized block, so there is no&lt;br/&gt;
    +				// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;br/&gt;
    +				if (isReleased.get() ||&lt;br/&gt;
    +					bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    +					isWaitingForFloatingBuffers = false;
    +					buffer.recycleBuffer();
    +					return false;
    +				}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Important: double check the isReleased state inside synchronized block, so there is no&lt;/li&gt;
	&lt;li&gt;// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;/li&gt;
	&lt;li&gt;if (isReleased.get() || bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    -				isWaitingForFloatingBuffers = false;
    -				buffer.recycleBuffer();
    -				return false;
    -			}
&lt;p&gt;    +				recycleBuffer = false;&lt;br/&gt;
    +				bufferQueue.addFloatingBuffer(buffer);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;bufferQueue.addFloatingBuffer(buffer);&lt;br/&gt;
    +				if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) 
{
    +					isWaitingForFloatingBuffers = false;
    +				}
&lt;p&gt; else &lt;/p&gt;
{
    +					needMoreBuffers = true;
    +				}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) 
{
    -				isWaitingForFloatingBuffers = false;
    -			}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;needMoreBuffers =  true;&lt;br/&gt;
    +				if (unannouncedCredit.getAndAdd(1) == 0) 
{
    +					notifyCreditAvailable();
    +				}
&lt;p&gt;     			}&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (unannouncedCredit.getAndAdd(1) == 0) 
{
    -			notifyCreditAvailable();
    +			return needMoreBuffers;
    +		}
&lt;p&gt; catch (Throwable t) {&lt;br/&gt;
    +			if (recycleBuffer) &lt;/p&gt;
{
    +				buffer.recycleBuffer();
    +			}
&lt;p&gt;    +			setError(t);&lt;br/&gt;
    +			return false;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    hmmm, `return false`? Can not it deadlock? Shouldn&apos;t we return correct value here? Maybe this `try catch` should be more tight? However I don&apos;t fully understand what this try/catch is protecting us from.&lt;/p&gt;</comment>
                            <comment id="16540302" author="githubbot" created="Wed, 11 Jul 2018 16:09:47 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272#discussion_r201750461&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272#discussion_r201750461&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -360,32 +360,44 @@ public boolean notifyBufferAvailable(Buffer buffer) &lt;/p&gt;
{
     			return false;
     		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;boolean needMoreBuffers = false;&lt;/li&gt;
	&lt;li&gt;synchronized (bufferQueue) {&lt;/li&gt;
	&lt;li&gt;checkState(isWaitingForFloatingBuffers, &quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +		boolean recycleBuffer = true;&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			boolean needMoreBuffers = false;&lt;br/&gt;
    +			synchronized (bufferQueue) {&lt;br/&gt;
    +				checkState(isWaitingForFloatingBuffers,&lt;br/&gt;
    +					&quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +				// Important: double check the isReleased state inside synchronized block, so there is no&lt;br/&gt;
    +				// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;br/&gt;
    +				if (isReleased.get() ||&lt;br/&gt;
    +					bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    nitty nit: this folding doesn&apos;t look good and melds with if&apos;s body.&lt;/p&gt;</comment>
                            <comment id="16540303" author="githubbot" created="Wed, 11 Jul 2018 16:09:47 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272#discussion_r201750691&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272#discussion_r201750691&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -360,32 +360,44 @@ public boolean notifyBufferAvailable(Buffer buffer) &lt;/p&gt;
{
     			return false;
     		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;boolean needMoreBuffers = false;&lt;/li&gt;
	&lt;li&gt;synchronized (bufferQueue) {&lt;/li&gt;
	&lt;li&gt;checkState(isWaitingForFloatingBuffers, &quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +		boolean recycleBuffer = true;&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			boolean needMoreBuffers = false;&lt;br/&gt;
    +			synchronized (bufferQueue) {&lt;br/&gt;
    +				checkState(isWaitingForFloatingBuffers,&lt;br/&gt;
    +					&quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +				// Important: double check the isReleased state inside synchronized block, so there is no&lt;br/&gt;
    +				// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;br/&gt;
    +				if (isReleased.get() ||&lt;br/&gt;
    +					bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    +					isWaitingForFloatingBuffers = false;
    +					buffer.recycleBuffer();
    +					return false;
    +				}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Important: double check the isReleased state inside synchronized block, so there is no&lt;/li&gt;
	&lt;li&gt;// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;/li&gt;
	&lt;li&gt;if (isReleased.get() || bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    -				isWaitingForFloatingBuffers = false;
    -				buffer.recycleBuffer();
    -				return false;
    -			}
&lt;p&gt;    +				recycleBuffer = false;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I don&apos;t understand this `recycleBuffer` flag. How can it ever be `true`?&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If we throw form `checkState` - that case we should just ignore.&lt;/li&gt;
	&lt;li&gt;If we throw from `bufferQueue.getAvailableBufferSize()`? Is it possible?&lt;/li&gt;
	&lt;li&gt;If we throw from `buffer.recycleBuffer();`? In that case for whatever reason we attempt to recycle second time?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    none of those options make sense, so am I missing something?&lt;/p&gt;</comment>
                            <comment id="16541379" author="githubbot" created="Thu, 12 Jul 2018 09:31:52 +0000"  >&lt;p&gt;Github user NicoK commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272#discussion_r201969455&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272#discussion_r201969455&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java &amp;#8212;&lt;br/&gt;
    @@ -277,37 +277,17 @@ public void recycle(MemorySegment segment) {&lt;br/&gt;
     		// We do not know which locks have been acquired before the recycle() or are needed in the&lt;br/&gt;
     		// notification and which other threads also access them.&lt;br/&gt;
     		// -&amp;gt; call notifyBufferAvailable() outside of the synchronized block to avoid a deadlock (&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9676&quot; title=&quot;Deadlock during canceling task and recycling exclusive buffer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9676&quot;&gt;&lt;del&gt;FLINK-9676&lt;/del&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;boolean success = false;&lt;/li&gt;
	&lt;li&gt;boolean needMoreBuffers = false;&lt;/li&gt;
	&lt;li&gt;try 
{
    -			needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));
    -			success = true;
    -		}
&lt;p&gt; catch (Throwable ignored) &lt;/p&gt;
{
    -			// handled below, under the lock
    -		}
&lt;p&gt;    +		// Note that in case of any exceptions notifyBufferAvailable() should recycle the buffer and&lt;br/&gt;
    +		// therefore end up in this method again.&lt;br/&gt;
    +		needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (!success || needMoreBuffers) {&lt;br/&gt;
    +		if (needMoreBuffers) {&lt;br/&gt;
     			synchronized (availableMemorySegments) {&lt;br/&gt;
     				if (isDestroyed) {&lt;br/&gt;
     					// cleanup tasks how they would have been done if we only had one synchronized block&lt;/li&gt;
	&lt;li&gt;if (needMoreBuffers) 
{
    -						listener.notifyBufferDestroyed();
    -					}&lt;/li&gt;
	&lt;li&gt;if (!success) 
{
    -						returnMemorySegment(segment);
    -					}
&lt;p&gt;    +					listener.notifyBufferDestroyed();&lt;br/&gt;
     				} else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;if (needMoreBuffers) 
{
    -						registeredListeners.add(listener);
    -					}&lt;/li&gt;
	&lt;li&gt;if (!success) {&lt;/li&gt;
	&lt;li&gt;if (numberOfRequestedMemorySegments &amp;gt; currentPoolSize) 
{
    -							returnMemorySegment(segment);
    -						}
&lt;p&gt; else &lt;/p&gt;
{
    -							availableMemorySegments.add(segment);
    -							availableMemorySegments.notify();
    -						}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    +					registeredListeners.add(listener);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    that&apos;s how it always was:&lt;br/&gt;
    a) if the exception was caught in the `notifyBufferAvailable()` handler, `needMoreBuffers` is `false` and we expect the error handling in that method to fail the logic that the thread waiting on the listener is relying on - otherwise this thread&apos;s error handling needs to re-register.&lt;/p&gt;

&lt;p&gt;    b) if `notifyBufferAvailable()` throws (this is not allowed anymore!), previous logic  also did not re-add the listener&lt;/p&gt;</comment>
                            <comment id="16541383" author="githubbot" created="Thu, 12 Jul 2018 09:35:27 +0000"  >&lt;p&gt;Github user NicoK commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272#discussion_r201970654&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272#discussion_r201970654&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -360,32 +360,44 @@ public boolean notifyBufferAvailable(Buffer buffer) &lt;/p&gt;
{
     			return false;
     		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;boolean needMoreBuffers = false;&lt;/li&gt;
	&lt;li&gt;synchronized (bufferQueue) {&lt;/li&gt;
	&lt;li&gt;checkState(isWaitingForFloatingBuffers, &quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +		boolean recycleBuffer = true;&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			boolean needMoreBuffers = false;&lt;br/&gt;
    +			synchronized (bufferQueue) {&lt;br/&gt;
    +				checkState(isWaitingForFloatingBuffers,&lt;br/&gt;
    +					&quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +				// Important: double check the isReleased state inside synchronized block, so there is no&lt;br/&gt;
    +				// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;br/&gt;
    +				if (isReleased.get() ||&lt;br/&gt;
    +					bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    +					isWaitingForFloatingBuffers = false;
    +					buffer.recycleBuffer();
    +					return false;
    +				}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Important: double check the isReleased state inside synchronized block, so there is no&lt;/li&gt;
	&lt;li&gt;// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;/li&gt;
	&lt;li&gt;if (isReleased.get() || bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    -				isWaitingForFloatingBuffers = false;
    -				buffer.recycleBuffer();
    -				return false;
    -			}
&lt;p&gt;    +				recycleBuffer = false;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I don&apos;t think we should ignore the `checkState` since a failure there in our task is of course an implementation error but should not leak buffers for other tasks still running and working with this buffer pool.&lt;br/&gt;
    Regarding the `buffer.recycleBuffer()`, you are right: we kind of always assume this cannot throw, but here we should maybe guard against recycling twice.&lt;/p&gt;</comment>
                            <comment id="16541389" author="githubbot" created="Thu, 12 Jul 2018 09:39:16 +0000"  >&lt;p&gt;Github user NicoK commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272#discussion_r201971896&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272#discussion_r201971896&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -360,32 +360,44 @@ public boolean notifyBufferAvailable(Buffer buffer) &lt;/p&gt;
{
     			return false;
     		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;boolean needMoreBuffers = false;&lt;/li&gt;
	&lt;li&gt;synchronized (bufferQueue) {&lt;/li&gt;
	&lt;li&gt;checkState(isWaitingForFloatingBuffers, &quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +		boolean recycleBuffer = true;&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			boolean needMoreBuffers = false;&lt;br/&gt;
    +			synchronized (bufferQueue) {&lt;br/&gt;
    +				checkState(isWaitingForFloatingBuffers,&lt;br/&gt;
    +					&quot;This channel should be waiting for floating buffers.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +				// Important: double check the isReleased state inside synchronized block, so there is no&lt;br/&gt;
    +				// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;br/&gt;
    +				if (isReleased.get() ||&lt;br/&gt;
    +					bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    +					isWaitingForFloatingBuffers = false;
    +					buffer.recycleBuffer();
    +					return false;
    +				}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Important: double check the isReleased state inside synchronized block, so there is no&lt;/li&gt;
	&lt;li&gt;// race condition when notifyBufferAvailable and releaseAllResources running in parallel.&lt;/li&gt;
	&lt;li&gt;if (isReleased.get() || bufferQueue.getAvailableBufferSize() &amp;gt;= numRequiredBuffers) 
{
    -				isWaitingForFloatingBuffers = false;
    -				buffer.recycleBuffer();
    -				return false;
    -			}
&lt;p&gt;    +				recycleBuffer = false;&lt;br/&gt;
    +				bufferQueue.addFloatingBuffer(buffer);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;bufferQueue.addFloatingBuffer(buffer);&lt;br/&gt;
    +				if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) 
{
    +					isWaitingForFloatingBuffers = false;
    +				}
&lt;p&gt; else &lt;/p&gt;
{
    +					needMoreBuffers = true;
    +				}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) 
{
    -				isWaitingForFloatingBuffers = false;
    -			}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;needMoreBuffers =  true;&lt;br/&gt;
    +				if (unannouncedCredit.getAndAdd(1) == 0) 
{
    +					notifyCreditAvailable();
    +				}
&lt;p&gt;     			}&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (unannouncedCredit.getAndAdd(1) == 0) 
{
    -			notifyCreditAvailable();
    +			return needMoreBuffers;
    +		}
&lt;p&gt; catch (Throwable t) {&lt;br/&gt;
    +			if (recycleBuffer) &lt;/p&gt;
{
    +				buffer.recycleBuffer();
    +			}
&lt;p&gt;    +			setError(t);&lt;br/&gt;
    +			return false;&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The protection (currently) is against the `checkState` here and in `notifyCreditAvailable()` (the latter also has some external calls).&lt;br/&gt;
    We could return `needMoreBuffers` here but I actually see this exception as if it happened in the responsible thread and therefore not continue to use this listener.&lt;/p&gt;</comment>
                            <comment id="16549216" author="githubbot" created="Thu, 19 Jul 2018 12:32:38 +0000"  >&lt;p&gt;Github user NicoK commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    rebased to solve the merge conflict (auto-solved by git though)&lt;/p&gt;</comment>
                            <comment id="16549407" author="githubbot" created="Thu, 19 Jul 2018 15:12:41 +0000"  >&lt;p&gt;Github user NicoK commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for the review, merging...&lt;/p&gt;</comment>
                            <comment id="16549711" author="githubbot" created="Thu, 19 Jul 2018 19:10:49 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6272&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6272&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16549731" author="nicok" created="Thu, 19 Jul 2018 19:31:02 +0000"  >&lt;p&gt;Fixed in&lt;br/&gt;
master: 5857f5543a7d9d3082d2f74342758d5a452a3c13&lt;br/&gt;
1.6: 0fec75c03bba0fa85a14e3f73baeb01998c83be0&lt;br/&gt;
1.5: 8193d5dc68289760ad68cf0b6b237fd86b0fd906&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13170143">FLINK-9756</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 17 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3vjz3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>