<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:29:31 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-7343] Kafka010ProducerITCase instability</title>
                <link>https://issues.apache.org/jira/browse/FLINK-7343</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;As reported by &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=till.rohrmann&quot; class=&quot;user-hover&quot; rel=&quot;till.rohrmann&quot;&gt;till.rohrmann&lt;/a&gt; in &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6996&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-6996&lt;/a&gt; there seems to be a test instability with `Kafka010ProducerITCase&amp;gt;KafkaProducerTestBase.testOneToOneAtLeastOnceRegularSink`&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/tillrohrmann/flink/jobs/258538641&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://travis-ci.org/tillrohrmann/flink/jobs/258538641&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It is probably related to log.flush intervals in Kafka, which delay flushing the data to files and potentially causing data loses on killing Kafka brokers in the tests.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13091792">FLINK-7343</key>
            <summary>Kafka010ProducerITCase instability</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="pnowojski">Piotr Nowojski</assignee>
                                    <reporter username="pnowojski">Piotr Nowojski</reporter>
                        <labels>
                            <label>test-stability</label>
                    </labels>
                <created>Wed, 2 Aug 2017 07:03:22 +0000</created>
                <updated>Wed, 21 Mar 2018 22:40:37 +0000</updated>
                            <resolved>Wed, 21 Mar 2018 22:40:37 +0000</resolved>
                                                    <fixVersion>1.5.0</fixVersion>
                                    <component>Connectors / Kafka</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16110577" author="githubbot" created="Wed, 2 Aug 2017 08:58:24 +0000"  >&lt;p&gt;Github user NicoK commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4456&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4456&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    yes, seems like it was changed from `-Xmx800m` to `-Xmx1536m` by &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-6128&quot; title=&quot;Optimize JVM options for improve test performance&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-6128&quot;&gt;&lt;del&gt;FLINK-6128&lt;/del&gt;&lt;/a&gt; and again to `-Xmx2048m` by &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7004&quot; title=&quot;Switch to Travis Trusty image&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7004&quot;&gt;&lt;del&gt;FLINK-7004&lt;/del&gt;&lt;/a&gt; without changing it here. The question should rather be whether we need the specialised options anyway or whether we can remove them.&lt;br/&gt;
    I tested the latter (removing the `&amp;lt;argLine&amp;gt;...&amp;lt;/argLine&amp;gt;` lines but keeping the `&amp;lt;forkCount&amp;gt;1&amp;lt;/forkCount&amp;gt;`) and then the root pom&apos;s values are inherited which may be a better solution anyway.&lt;/p&gt;</comment>
                            <comment id="16112332" author="githubbot" created="Thu, 3 Aug 2017 07:24:50 +0000"  >&lt;p&gt;Github user pnowojski commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4456&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4456&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @NicoK sounds reasonable however this will drop `-UseGCOverheadLimit` flag. It should be fine when at the same time we increase the `Xmx`. Btw, having `UseGCOverheadLimit` seems a little bit fishy in the first place...&lt;/p&gt;

&lt;p&gt;    Pushing fixup with inheriting values from the parent pom.&lt;/p&gt;</comment>
                            <comment id="16112654" author="githubbot" created="Thu, 3 Aug 2017 12:35:07 +0000"  >&lt;p&gt;GitHub user pnowojski opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4470&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4470&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7343&quot; title=&quot;Kafka010ProducerITCase instability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7343&quot;&gt;&lt;del&gt;FLINK-7343&lt;/del&gt;&lt;/a&gt; Simulate network failures in kafka at-least-once test&lt;/p&gt;

&lt;p&gt;    We shouldn&apos;t fail KafkaServers directly, because they might not be able to flush the data (`log.flush.interval.***` properties). Since we don&apos;t want to test how well Kafka implements at-least-once/exactly-once semantic, it is a better idea (and hopefully more reliable) to just simulate network failure between Flink and Kafka in our at-least-once tests. To achieve that I have implemented `NetworkFailuresProxy` class.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/pnowojski/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/pnowojski/flink&lt;/a&gt; network-failures&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4470.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4470.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4470&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 0e28327619893cfbf793fa842be3d965f649516c&lt;br/&gt;
Author: Piotr Nowojski &amp;lt;piotr.nowojski@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-08-01T14:05:49Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7343&quot; title=&quot;Kafka010ProducerITCase instability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7343&quot;&gt;&lt;del&gt;FLINK-7343&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;kafka&amp;#93;&lt;/span&gt; Increase Xmx for tests&lt;/p&gt;

&lt;p&gt;    Sometimes 1000m was not enough memory to run at-least-once tests with broker failures on Travis&lt;/p&gt;

&lt;p&gt;commit 8d820c3d0e77624a945e074f4a1bc476b5fd0f75&lt;br/&gt;
Author: Piotr Nowojski &amp;lt;piotr.nowojski@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-08-01T16:11:27Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7343&quot; title=&quot;Kafka010ProducerITCase instability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7343&quot;&gt;&lt;del&gt;FLINK-7343&lt;/del&gt;&lt;/a&gt; Add network proxy utility to simulate network failures&lt;/p&gt;

&lt;p&gt;commit 967e1dfc87846b4011652bbaefab696900abc8dd&lt;br/&gt;
Author: Piotr Nowojski &amp;lt;piotr.nowojski@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-08-03T07:25:04Z&lt;/p&gt;

&lt;p&gt;    fixup! &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7343&quot; title=&quot;Kafka010ProducerITCase instability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7343&quot;&gt;&lt;del&gt;FLINK-7343&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;kafka&amp;#93;&lt;/span&gt; Increase Xmx for tests&lt;/p&gt;

&lt;p&gt;commit 27b20f2ec3770231d95c3c7918c9313ce58b5e18&lt;br/&gt;
Author: Piotr Nowojski &amp;lt;piotr.nowojski@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-08-03T09:27:12Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7343&quot; title=&quot;Kafka010ProducerITCase instability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7343&quot;&gt;&lt;del&gt;FLINK-7343&lt;/del&gt;&lt;/a&gt; Use NetworkFailureProxy in kafka tests&lt;/p&gt;

&lt;p&gt;    We shouldn&apos;t fail KafkaServers directly, because they might not be able&lt;br/&gt;
    to flush the data. Since we don&apos;t want to test how well Kafka implements&lt;br/&gt;
    at-least-once/exactly-once semantic, we just simulate network failure&lt;br/&gt;
    between Flink and Kafka in our at-least-once tests.&lt;/p&gt;

&lt;p&gt;commit 692b5944f16b98aafe716ca1d18a04fa8a033798&lt;br/&gt;
Author: Piotr Nowojski &amp;lt;piotr.nowojski@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-08-03T09:35:26Z&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;hotfix&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Kafka&amp;#93;&lt;/span&gt; Clean up getKafkaServer method&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16116176" author="githubbot" created="Mon, 7 Aug 2017 07:13:15 +0000"  >&lt;p&gt;Github user tzulitai commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4456&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4456&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    +1, LGTM.&lt;/p&gt;</comment>
                            <comment id="16116357" author="githubbot" created="Mon, 7 Aug 2017 09:54:52 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4470#discussion_r131608115&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4470#discussion_r131608115&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-test-utils-parent/flink-test-utils/src/main/java/org/apache/flink/networking/NetworkFailureHandler.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,176 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.networking;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.jboss.netty.bootstrap.ClientBootstrap;&lt;br/&gt;
    +import org.jboss.netty.buffer.ChannelBuffer;&lt;br/&gt;
    +import org.jboss.netty.buffer.ChannelBuffers;&lt;br/&gt;
    +import org.jboss.netty.channel.Channel;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelFuture;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelFutureListener;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelHandlerContext;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelStateEvent;&lt;br/&gt;
    +import org.jboss.netty.channel.ExceptionEvent;&lt;br/&gt;
    +import org.jboss.netty.channel.MessageEvent;&lt;br/&gt;
    +import org.jboss.netty.channel.SimpleChannelUpstreamHandler;&lt;br/&gt;
    +import org.jboss.netty.channel.socket.ClientSocketChannelFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.net.InetSocketAddress;&lt;br/&gt;
    +import java.util.Map;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    +import java.util.function.Consumer;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Handler that is forwarding inbound traffic from the source channel to the target channel on remoteHost:remotePort&lt;br/&gt;
    + * and the responses in the opposite direction. All of the network traffic can be blocked at any time using blocked&lt;br/&gt;
    + * flag.&lt;br/&gt;
    + */&lt;br/&gt;
    +class NetworkFailureHandler extends SimpleChannelUpstreamHandler {&lt;br/&gt;
    +	private static final String TARGET_CHANNEL_HANDLER_NAME = &quot;target_channel_handler&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	// mapping between source and target channels, used for finding correct target channel to use for given source.&lt;br/&gt;
    +	private final Map&amp;lt;Channel, Channel&amp;gt; sourceToTargetChannels = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
    +	private final Consumer&amp;lt;NetworkFailureHandler&amp;gt; onClose;&lt;br/&gt;
    +	private final ClientSocketChannelFactory channelFactory;&lt;br/&gt;
    +	private final String remoteHost;&lt;br/&gt;
    +	private final int remotePort;&lt;br/&gt;
    +&lt;br/&gt;
    +	private final AtomicBoolean blocked;&lt;br/&gt;
    +&lt;br/&gt;
    +	public NetworkFailureHandler(&lt;br/&gt;
    +			AtomicBoolean blocked,&lt;br/&gt;
    +			Consumer&amp;lt;NetworkFailureHandler&amp;gt; onClose,&lt;br/&gt;
    +			ClientSocketChannelFactory channelFactory,&lt;br/&gt;
    +			String remoteHost,&lt;br/&gt;
    +			int remotePort) &lt;/p&gt;
{
    +		this.blocked = blocked;
    +		this.onClose = onClose;
    +		this.channelFactory = channelFactory;
    +		this.remoteHost = remoteHost;
    +		this.remotePort = remotePort;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Closes the specified channel after all queued write requests are flushed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	static void closeOnFlush(Channel channel) {&lt;br/&gt;
    +		if (channel.isConnected()) &lt;/p&gt;
{
    +			channel.write(ChannelBuffers.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public void closeConnections() {&lt;br/&gt;
    +		for (Map.Entry&amp;lt;Channel, Channel&amp;gt; entry : sourceToTargetChannels.entrySet()) &lt;/p&gt;
{
    +			// target channel is closed on source&apos;s channel channelClosed even
    +			entry.getKey().close();
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void channelOpen(ChannelHandlerContext context, ChannelStateEvent event) throws Exception {&lt;br/&gt;
    +		// Suspend incoming traffic until connected to the remote host.&lt;br/&gt;
    +		final Channel sourceChannel = event.getChannel();&lt;br/&gt;
    +		sourceChannel.setReadable(false);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (blocked.get()) &lt;/p&gt;
{
    +			sourceChannel.close();
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// Start the connection attempt.&lt;br/&gt;
    +		ClientBootstrap targetConnectionBootstrap = new ClientBootstrap(channelFactory);&lt;br/&gt;
    +		targetConnectionBootstrap.getPipeline().addLast(TARGET_CHANNEL_HANDLER_NAME, new TargetChannelHandler(event.getChannel(), blocked));&lt;br/&gt;
    +		ChannelFuture connectFuture = targetConnectionBootstrap.connect(new InetSocketAddress(remoteHost, remotePort));&lt;br/&gt;
    +		sourceToTargetChannels.put(sourceChannel, connectFuture.getChannel());&lt;br/&gt;
    +&lt;br/&gt;
    +		connectFuture.addListener(future -&amp;gt; {&lt;br/&gt;
    +			if (future.isSuccess()) &lt;/p&gt;
{
    +				// Connection attempt succeeded:
    +				// Begin to accept incoming traffic.
    +				sourceChannel.setReadable(true);
    +			}
&lt;p&gt; else &lt;/p&gt;
{
    +				// Close the connection if the connection attempt has failed.
    +				sourceChannel.close();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void messageReceived(ChannelHandlerContext context, MessageEvent event) throws Exception {&lt;br/&gt;
    +		if (blocked.get()) &lt;/p&gt;
{
    +			return;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		ChannelBuffer msg = (ChannelBuffer) event.getMessage();&lt;br/&gt;
    +		Channel targetChannel = sourceToTargetChannels.get(event.getChannel());&lt;br/&gt;
    +		if (targetChannel == null) {
    +			throw new IllegalStateException();
    +		}&lt;br/&gt;
    +		targetChannel.write(msg);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void channelClosed(ChannelHandlerContext context, ChannelStateEvent event) throws Exception {&lt;br/&gt;
    +		Channel targetChannel = sourceToTargetChannels.get(event.getChannel());&lt;br/&gt;
    +		if (targetChannel == null) {    +			return;    +		}
&lt;p&gt;    +		closeOnFlush(targetChannel);&lt;br/&gt;
    +		sourceToTargetChannels.remove(event.getChannel());&lt;br/&gt;
    +		onClose.accept(this);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void exceptionCaught(ChannelHandlerContext context, ExceptionEvent event) throws Exception {&lt;br/&gt;
    +		event.getCause().printStackTrace();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I suggest to replace the `printStackTrace()` with logging.&lt;/p&gt;</comment>
                            <comment id="16116358" author="githubbot" created="Mon, 7 Aug 2017 09:54:52 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4470#discussion_r131609166&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4470#discussion_r131609166&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-test-utils-parent/flink-test-utils/src/main/java/org/apache/flink/networking/NetworkFailureHandler.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,176 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.networking;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.jboss.netty.bootstrap.ClientBootstrap;&lt;br/&gt;
    +import org.jboss.netty.buffer.ChannelBuffer;&lt;br/&gt;
    +import org.jboss.netty.buffer.ChannelBuffers;&lt;br/&gt;
    +import org.jboss.netty.channel.Channel;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelFuture;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelFutureListener;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelHandlerContext;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelStateEvent;&lt;br/&gt;
    +import org.jboss.netty.channel.ExceptionEvent;&lt;br/&gt;
    +import org.jboss.netty.channel.MessageEvent;&lt;br/&gt;
    +import org.jboss.netty.channel.SimpleChannelUpstreamHandler;&lt;br/&gt;
    +import org.jboss.netty.channel.socket.ClientSocketChannelFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.net.InetSocketAddress;&lt;br/&gt;
    +import java.util.Map;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    +import java.util.function.Consumer;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Handler that is forwarding inbound traffic from the source channel to the target channel on remoteHost:remotePort&lt;br/&gt;
    + * and the responses in the opposite direction. All of the network traffic can be blocked at any time using blocked&lt;br/&gt;
    + * flag.&lt;br/&gt;
    + */&lt;br/&gt;
    +class NetworkFailureHandler extends SimpleChannelUpstreamHandler {&lt;br/&gt;
    +	private static final String TARGET_CHANNEL_HANDLER_NAME = &quot;target_channel_handler&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	// mapping between source and target channels, used for finding correct target channel to use for given source.&lt;br/&gt;
    +	private final Map&amp;lt;Channel, Channel&amp;gt; sourceToTargetChannels = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
    +	private final Consumer&amp;lt;NetworkFailureHandler&amp;gt; onClose;&lt;br/&gt;
    +	private final ClientSocketChannelFactory channelFactory;&lt;br/&gt;
    +	private final String remoteHost;&lt;br/&gt;
    +	private final int remotePort;&lt;br/&gt;
    +&lt;br/&gt;
    +	private final AtomicBoolean blocked;&lt;br/&gt;
    +&lt;br/&gt;
    +	public NetworkFailureHandler(&lt;br/&gt;
    +			AtomicBoolean blocked,&lt;br/&gt;
    +			Consumer&amp;lt;NetworkFailureHandler&amp;gt; onClose,&lt;br/&gt;
    +			ClientSocketChannelFactory channelFactory,&lt;br/&gt;
    +			String remoteHost,&lt;br/&gt;
    +			int remotePort) &lt;/p&gt;
{
    +		this.blocked = blocked;
    +		this.onClose = onClose;
    +		this.channelFactory = channelFactory;
    +		this.remoteHost = remoteHost;
    +		this.remotePort = remotePort;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Closes the specified channel after all queued write requests are flushed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	static void closeOnFlush(Channel channel) {&lt;br/&gt;
    +		if (channel.isConnected()) &lt;/p&gt;
{
    +			channel.write(ChannelBuffers.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public void closeConnections() {&lt;br/&gt;
    +		for (Map.Entry&amp;lt;Channel, Channel&amp;gt; entry : sourceToTargetChannels.entrySet()) &lt;/p&gt;
{
    +			// target channel is closed on source&apos;s channel channelClosed even
    +			entry.getKey().close();
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void channelOpen(ChannelHandlerContext context, ChannelStateEvent event) throws Exception {&lt;br/&gt;
    +		// Suspend incoming traffic until connected to the remote host.&lt;br/&gt;
    +		final Channel sourceChannel = event.getChannel();&lt;br/&gt;
    +		sourceChannel.setReadable(false);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (blocked.get()) &lt;/p&gt;
{
    +			sourceChannel.close();
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// Start the connection attempt.&lt;br/&gt;
    +		ClientBootstrap targetConnectionBootstrap = new ClientBootstrap(channelFactory);&lt;br/&gt;
    +		targetConnectionBootstrap.getPipeline().addLast(TARGET_CHANNEL_HANDLER_NAME, new TargetChannelHandler(event.getChannel(), blocked));&lt;br/&gt;
    +		ChannelFuture connectFuture = targetConnectionBootstrap.connect(new InetSocketAddress(remoteHost, remotePort));&lt;br/&gt;
    +		sourceToTargetChannels.put(sourceChannel, connectFuture.getChannel());&lt;br/&gt;
    +&lt;br/&gt;
    +		connectFuture.addListener(future -&amp;gt; {&lt;br/&gt;
    +			if (future.isSuccess()) &lt;/p&gt;
{
    +				// Connection attempt succeeded:
    +				// Begin to accept incoming traffic.
    +				sourceChannel.setReadable(true);
    +			}
&lt;p&gt; else &lt;/p&gt;
{
    +				// Close the connection if the connection attempt has failed.
    +				sourceChannel.close();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void messageReceived(ChannelHandlerContext context, MessageEvent event) throws Exception {&lt;br/&gt;
    +		if (blocked.get()) &lt;/p&gt;
{
    +			return;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		ChannelBuffer msg = (ChannelBuffer) event.getMessage();&lt;br/&gt;
    +		Channel targetChannel = sourceToTargetChannels.get(event.getChannel());&lt;br/&gt;
    +		if (targetChannel == null) {
    +			throw new IllegalStateException();
    +		}&lt;br/&gt;
    +		targetChannel.write(msg);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void channelClosed(ChannelHandlerContext context, ChannelStateEvent event) throws Exception {&lt;br/&gt;
    +		Channel targetChannel = sourceToTargetChannels.get(event.getChannel());&lt;br/&gt;
    +		if (targetChannel == null) {    +			return;    +		}
&lt;p&gt;    +		closeOnFlush(targetChannel);&lt;br/&gt;
    +		sourceToTargetChannels.remove(event.getChannel());&lt;br/&gt;
    +		onClose.accept(this);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void exceptionCaught(ChannelHandlerContext context, ExceptionEvent event) throws Exception &lt;/p&gt;
{
    +		event.getCause().printStackTrace();
    +		closeOnFlush(event.getChannel());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static class TargetChannelHandler extends SimpleChannelUpstreamHandler {&lt;br/&gt;
    +		private final Channel sourceChannel;&lt;br/&gt;
    +		private final AtomicBoolean blocked;&lt;br/&gt;
    +&lt;br/&gt;
    +		TargetChannelHandler(Channel sourceChannel, AtomicBoolean blocked) &lt;/p&gt;
{
    +			this.sourceChannel = sourceChannel;
    +			this.blocked = blocked;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public void messageReceived(ChannelHandlerContext context, MessageEvent event) throws Exception {&lt;br/&gt;
    +			if (blocked.get()) &lt;/p&gt;
{
    +				return;
    +			}
&lt;p&gt;    +			ChannelBuffer msg = (ChannelBuffer) event.getMessage();&lt;br/&gt;
    +			sourceChannel.write(msg);&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public void channelClosed(ChannelHandlerContext context, ChannelStateEvent event) throws Exception &lt;/p&gt;
{
    +			closeOnFlush(sourceChannel);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public void exceptionCaught(ChannelHandlerContext context, ExceptionEvent event)&lt;br/&gt;
    +			throws Exception {&lt;br/&gt;
    +			event.getCause().printStackTrace();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Same suggestion to use logging over `printStackTrace ()`.&lt;/p&gt;</comment>
                            <comment id="16116359" author="githubbot" created="Mon, 7 Aug 2017 09:54:52 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4470#discussion_r131608304&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4470#discussion_r131608304&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-test-utils-parent/flink-test-utils/src/main/java/org/apache/flink/networking/NetworkFailureHandler.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,176 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.networking;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.jboss.netty.bootstrap.ClientBootstrap;&lt;br/&gt;
    +import org.jboss.netty.buffer.ChannelBuffer;&lt;br/&gt;
    +import org.jboss.netty.buffer.ChannelBuffers;&lt;br/&gt;
    +import org.jboss.netty.channel.Channel;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelFuture;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelFutureListener;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelHandlerContext;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelStateEvent;&lt;br/&gt;
    +import org.jboss.netty.channel.ExceptionEvent;&lt;br/&gt;
    +import org.jboss.netty.channel.MessageEvent;&lt;br/&gt;
    +import org.jboss.netty.channel.SimpleChannelUpstreamHandler;&lt;br/&gt;
    +import org.jboss.netty.channel.socket.ClientSocketChannelFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.net.InetSocketAddress;&lt;br/&gt;
    +import java.util.Map;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    +import java.util.function.Consumer;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Handler that is forwarding inbound traffic from the source channel to the target channel on remoteHost:remotePort&lt;br/&gt;
    + * and the responses in the opposite direction. All of the network traffic can be blocked at any time using blocked&lt;br/&gt;
    + * flag.&lt;br/&gt;
    + */&lt;br/&gt;
    +class NetworkFailureHandler extends SimpleChannelUpstreamHandler {&lt;br/&gt;
    +	private static final String TARGET_CHANNEL_HANDLER_NAME = &quot;target_channel_handler&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	// mapping between source and target channels, used for finding correct target channel to use for given source.&lt;br/&gt;
    +	private final Map&amp;lt;Channel, Channel&amp;gt; sourceToTargetChannels = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
    +	private final Consumer&amp;lt;NetworkFailureHandler&amp;gt; onClose;&lt;br/&gt;
    +	private final ClientSocketChannelFactory channelFactory;&lt;br/&gt;
    +	private final String remoteHost;&lt;br/&gt;
    +	private final int remotePort;&lt;br/&gt;
    +&lt;br/&gt;
    +	private final AtomicBoolean blocked;&lt;br/&gt;
    +&lt;br/&gt;
    +	public NetworkFailureHandler(&lt;br/&gt;
    +			AtomicBoolean blocked,&lt;br/&gt;
    +			Consumer&amp;lt;NetworkFailureHandler&amp;gt; onClose,&lt;br/&gt;
    +			ClientSocketChannelFactory channelFactory,&lt;br/&gt;
    +			String remoteHost,&lt;br/&gt;
    +			int remotePort) &lt;/p&gt;
{
    +		this.blocked = blocked;
    +		this.onClose = onClose;
    +		this.channelFactory = channelFactory;
    +		this.remoteHost = remoteHost;
    +		this.remotePort = remotePort;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Closes the specified channel after all queued write requests are flushed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	static void closeOnFlush(Channel channel) {&lt;br/&gt;
    +		if (channel.isConnected()) &lt;/p&gt;
{
    +			channel.write(ChannelBuffers.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public void closeConnections() {&lt;br/&gt;
    +		for (Map.Entry&amp;lt;Channel, Channel&amp;gt; entry : sourceToTargetChannels.entrySet()) &lt;/p&gt;
{
    +			// target channel is closed on source&apos;s channel channelClosed even
    +			entry.getKey().close();
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void channelOpen(ChannelHandlerContext context, ChannelStateEvent event) throws Exception {&lt;br/&gt;
    +		// Suspend incoming traffic until connected to the remote host.&lt;br/&gt;
    +		final Channel sourceChannel = event.getChannel();&lt;br/&gt;
    +		sourceChannel.setReadable(false);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (blocked.get()) &lt;/p&gt;
{
    +			sourceChannel.close();
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// Start the connection attempt.&lt;br/&gt;
    +		ClientBootstrap targetConnectionBootstrap = new ClientBootstrap(channelFactory);&lt;br/&gt;
    +		targetConnectionBootstrap.getPipeline().addLast(TARGET_CHANNEL_HANDLER_NAME, new TargetChannelHandler(event.getChannel(), blocked));&lt;br/&gt;
    +		ChannelFuture connectFuture = targetConnectionBootstrap.connect(new InetSocketAddress(remoteHost, remotePort));&lt;br/&gt;
    +		sourceToTargetChannels.put(sourceChannel, connectFuture.getChannel());&lt;br/&gt;
    +&lt;br/&gt;
    +		connectFuture.addListener(future -&amp;gt; {&lt;br/&gt;
    +			if (future.isSuccess()) &lt;/p&gt;
{
    +				// Connection attempt succeeded:
    +				// Begin to accept incoming traffic.
    +				sourceChannel.setReadable(true);
    +			}
&lt;p&gt; else &lt;/p&gt;
{
    +				// Close the connection if the connection attempt has failed.
    +				sourceChannel.close();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void messageReceived(ChannelHandlerContext context, MessageEvent event) throws Exception {&lt;br/&gt;
    +		if (blocked.get()) &lt;/p&gt;
{
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		ChannelBuffer msg = (ChannelBuffer) event.getMessage();&lt;br/&gt;
    +		Channel targetChannel = sourceToTargetChannels.get(event.getChannel());&lt;br/&gt;
    +		if (targetChannel == null) {&lt;br/&gt;
    +			throw new IllegalStateException();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    A cause message could be added.&lt;/p&gt;</comment>
                            <comment id="16116399" author="githubbot" created="Mon, 7 Aug 2017 10:27:24 +0000"  >&lt;p&gt;Github user zentol commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4456&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4456&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    merging.&lt;/p&gt;</comment>
                            <comment id="16116539" author="githubbot" created="Mon, 7 Aug 2017 12:58:06 +0000"  >&lt;p&gt;Github user pnowojski commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4456&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4456&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16116547" author="githubbot" created="Mon, 7 Aug 2017 13:05:40 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4470#discussion_r131648638&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4470#discussion_r131648638&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-test-utils-parent/flink-test-utils/src/main/java/org/apache/flink/networking/NetworkFailureHandler.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,176 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.networking;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.jboss.netty.bootstrap.ClientBootstrap;&lt;br/&gt;
    +import org.jboss.netty.buffer.ChannelBuffer;&lt;br/&gt;
    +import org.jboss.netty.buffer.ChannelBuffers;&lt;br/&gt;
    +import org.jboss.netty.channel.Channel;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelFuture;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelFutureListener;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelHandlerContext;&lt;br/&gt;
    +import org.jboss.netty.channel.ChannelStateEvent;&lt;br/&gt;
    +import org.jboss.netty.channel.ExceptionEvent;&lt;br/&gt;
    +import org.jboss.netty.channel.MessageEvent;&lt;br/&gt;
    +import org.jboss.netty.channel.SimpleChannelUpstreamHandler;&lt;br/&gt;
    +import org.jboss.netty.channel.socket.ClientSocketChannelFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.net.InetSocketAddress;&lt;br/&gt;
    +import java.util.Map;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicBoolean;&lt;br/&gt;
    +import java.util.function.Consumer;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Handler that is forwarding inbound traffic from the source channel to the target channel on remoteHost:remotePort&lt;br/&gt;
    + * and the responses in the opposite direction. All of the network traffic can be blocked at any time using blocked&lt;br/&gt;
    + * flag.&lt;br/&gt;
    + */&lt;br/&gt;
    +class NetworkFailureHandler extends SimpleChannelUpstreamHandler {&lt;br/&gt;
    +	private static final String TARGET_CHANNEL_HANDLER_NAME = &quot;target_channel_handler&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	// mapping between source and target channels, used for finding correct target channel to use for given source.&lt;br/&gt;
    +	private final Map&amp;lt;Channel, Channel&amp;gt; sourceToTargetChannels = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
    +	private final Consumer&amp;lt;NetworkFailureHandler&amp;gt; onClose;&lt;br/&gt;
    +	private final ClientSocketChannelFactory channelFactory;&lt;br/&gt;
    +	private final String remoteHost;&lt;br/&gt;
    +	private final int remotePort;&lt;br/&gt;
    +&lt;br/&gt;
    +	private final AtomicBoolean blocked;&lt;br/&gt;
    +&lt;br/&gt;
    +	public NetworkFailureHandler(&lt;br/&gt;
    +			AtomicBoolean blocked,&lt;br/&gt;
    +			Consumer&amp;lt;NetworkFailureHandler&amp;gt; onClose,&lt;br/&gt;
    +			ClientSocketChannelFactory channelFactory,&lt;br/&gt;
    +			String remoteHost,&lt;br/&gt;
    +			int remotePort) &lt;/p&gt;
{
    +		this.blocked = blocked;
    +		this.onClose = onClose;
    +		this.channelFactory = channelFactory;
    +		this.remoteHost = remoteHost;
    +		this.remotePort = remotePort;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Closes the specified channel after all queued write requests are flushed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	static void closeOnFlush(Channel channel) {&lt;br/&gt;
    +		if (channel.isConnected()) &lt;/p&gt;
{
    +			channel.write(ChannelBuffers.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public void closeConnections() {&lt;br/&gt;
    +		for (Map.Entry&amp;lt;Channel, Channel&amp;gt; entry : sourceToTargetChannels.entrySet()) &lt;/p&gt;
{
    +			// target channel is closed on source&apos;s channel channelClosed even
    +			entry.getKey().close();
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void channelOpen(ChannelHandlerContext context, ChannelStateEvent event) throws Exception {&lt;br/&gt;
    +		// Suspend incoming traffic until connected to the remote host.&lt;br/&gt;
    +		final Channel sourceChannel = event.getChannel();&lt;br/&gt;
    +		sourceChannel.setReadable(false);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (blocked.get()) &lt;/p&gt;
{
    +			sourceChannel.close();
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		// Start the connection attempt.&lt;br/&gt;
    +		ClientBootstrap targetConnectionBootstrap = new ClientBootstrap(channelFactory);&lt;br/&gt;
    +		targetConnectionBootstrap.getPipeline().addLast(TARGET_CHANNEL_HANDLER_NAME, new TargetChannelHandler(event.getChannel(), blocked));&lt;br/&gt;
    +		ChannelFuture connectFuture = targetConnectionBootstrap.connect(new InetSocketAddress(remoteHost, remotePort));&lt;br/&gt;
    +		sourceToTargetChannels.put(sourceChannel, connectFuture.getChannel());&lt;br/&gt;
    +&lt;br/&gt;
    +		connectFuture.addListener(future -&amp;gt; {&lt;br/&gt;
    +			if (future.isSuccess()) &lt;/p&gt;
{
    +				// Connection attempt succeeded:
    +				// Begin to accept incoming traffic.
    +				sourceChannel.setReadable(true);
    +			}
&lt;p&gt; else &lt;/p&gt;
{
    +				// Close the connection if the connection attempt has failed.
    +				sourceChannel.close();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void messageReceived(ChannelHandlerContext context, MessageEvent event) throws Exception {&lt;br/&gt;
    +		if (blocked.get()) &lt;/p&gt;
{
    +			return;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		ChannelBuffer msg = (ChannelBuffer) event.getMessage();&lt;br/&gt;
    +		Channel targetChannel = sourceToTargetChannels.get(event.getChannel());&lt;br/&gt;
    +		if (targetChannel == null) {
    +			throw new IllegalStateException();
    +		}&lt;br/&gt;
    +		targetChannel.write(msg);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void channelClosed(ChannelHandlerContext context, ChannelStateEvent event) throws Exception {&lt;br/&gt;
    +		Channel targetChannel = sourceToTargetChannels.get(event.getChannel());&lt;br/&gt;
    +		if (targetChannel == null) {    +			return;    +		}
&lt;p&gt;    +		closeOnFlush(targetChannel);&lt;br/&gt;
    +		sourceToTargetChannels.remove(event.getChannel());&lt;br/&gt;
    +		onClose.accept(this);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void exceptionCaught(ChannelHandlerContext context, ExceptionEvent event) throws Exception {&lt;br/&gt;
    +		event.getCause().printStackTrace();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Ops, missed that when cleaning up a copied example code.&lt;/p&gt;</comment>
                            <comment id="16116559" author="githubbot" created="Mon, 7 Aug 2017 13:18:15 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4456&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4456&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16116568" author="zentol" created="Mon, 7 Aug 2017 13:19:09 +0000"  >&lt;p&gt;Xmx increase in 1.4 in 4406d4868320c72ce7c744748cbd7528ff4bc642&lt;/p&gt;</comment>
                            <comment id="16116655" author="githubbot" created="Mon, 7 Aug 2017 14:32:47 +0000"  >&lt;p&gt;Github user pnowojski commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4470&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4470&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Yes I also didn&apos;t like adding this new flag, but didn&apos;t have enough motivation to change it. I have done some refactoring extracting those dynamically set in `prepare` method to some `Config` class. &lt;/p&gt;

&lt;p&gt;    However it helps only a little bit. Those tests would need a more comprehensive refactor in the future. I particularly don&apos;t like that this `prepare` method exists, it should all be configured in the constructor and all of those should be final fields.&lt;/p&gt;</comment>
                            <comment id="16116666" author="githubbot" created="Mon, 7 Aug 2017 14:40:03 +0000"  >&lt;p&gt;Github user StefanRRichter commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4470&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4470&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Merging.&lt;/p&gt;</comment>
                            <comment id="16118019" author="githubbot" created="Tue, 8 Aug 2017 08:14:42 +0000"  >&lt;p&gt;Github user StefanRRichter commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4470&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4470&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Please close the commit and the Jira issue.&lt;/p&gt;</comment>
                            <comment id="16118104" author="githubbot" created="Tue, 8 Aug 2017 09:35:36 +0000"  >&lt;p&gt;Github user pnowojski commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4470&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4470&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16118105" author="githubbot" created="Tue, 8 Aug 2017 09:35:37 +0000"  >&lt;p&gt;Github user pnowojski closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4470&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4470&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16118107" author="pnowojski" created="Tue, 8 Aug 2017 09:41:45 +0000"  >&lt;p&gt;Hopefully with two recent changes this issue will not show up again.&lt;/p&gt;</comment>
                            <comment id="16363125" author="till.rohrmann" created="Tue, 13 Feb 2018 22:10:09 +0000"  >&lt;p&gt;It happened again &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://api.travis-ci.org/v3/job/340947835/log.txt&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://api.travis-ci.org/v3/job/340947835/log.txt&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16406282" author="githubbot" created="Tue, 20 Mar 2018 12:57:49 +0000"  >&lt;p&gt;GitHub user pnowojski opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5729&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5729&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7343&quot; title=&quot;Kafka010ProducerITCase instability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7343&quot;&gt;&lt;del&gt;FLINK-7343&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;kafka-tests&amp;#93;&lt;/span&gt; Fix test at-least-once test instability&lt;/p&gt;

&lt;p&gt;    This pr fixes instabilities in both Kafka 0.10 and Kafka 0.9.&lt;/p&gt;

&lt;p&gt;    Previously we could set lastSnapshotedElement to some value during checkpointing AFTER executing shutdown while KafkaProducer snapshot of this value would fail. This was leading to incorrectly expect this value to be present in the test kafka topic. Fix is to remember lastSnapshotedElementBeforeShutdown - last snapshot that we exepct to succeed without failure.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;The serializers: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? (*&lt;b&gt;not applicable&lt;/b&gt;* / docs / JavaDocs / not documented)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/pnowojski/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/pnowojski/flink&lt;/a&gt; f7343&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5729.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5729.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #5729&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;</comment>
                            <comment id="16407737" author="githubbot" created="Wed, 21 Mar 2018 10:43:20 +0000"  >&lt;p&gt;Github user StephanEwen commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5729&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5729&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Sweet, nice to see this fixed.&lt;/p&gt;

&lt;p&gt;    Code looks good, +1 to merge!&lt;/p&gt;</comment>
                            <comment id="16407853" author="githubbot" created="Wed, 21 Mar 2018 12:52:42 +0000"  >&lt;p&gt;Github user zentol commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5729&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5729&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    merging.&lt;/p&gt;</comment>
                            <comment id="16408010" author="githubbot" created="Wed, 21 Mar 2018 14:37:13 +0000"  >&lt;p&gt;Github user pnowojski commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5729&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5729&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks!&lt;/p&gt;</comment>
                            <comment id="16408706" author="githubbot" created="Wed, 21 Mar 2018 22:40:15 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5729&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5729&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16408709" author="zentol" created="Wed, 21 Mar 2018 22:40:37 +0000"  >&lt;p&gt;master: b87e660ac64bebbd9a0a6aa4334a68736140053f&lt;br/&gt;
1.5: 0fa76e50f06e84da8764089f36227ed26a2c2765&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 34 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3ib2f:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>