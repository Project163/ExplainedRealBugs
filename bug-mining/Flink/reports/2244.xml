<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:32:14 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-8679] RocksDBKeyedBackend.getKeys(stateName, namespace) doesn&apos;t filter data with namespace</title>
                <link>https://issues.apache.org/jira/browse/FLINK-8679</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;Currently, `RocksDBKeyedBackend.getKeys(stateName, namespace)` is odds. It doesn&apos;t use the namespace to filter data. And `HeapKeyedBackend.getKeys(stateName, namespace)` has done that, I think they should be consistent at least.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13139101">FLINK-8679</key>
            <summary>RocksDBKeyedBackend.getKeys(stateName, namespace) doesn&apos;t filter data with namespace</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="sihuazhou">Sihua Zhou</assignee>
                                    <reporter username="sihuazhou">Sihua Zhou</reporter>
                        <labels>
                    </labels>
                <created>Fri, 16 Feb 2018 17:46:31 +0000</created>
                <updated>Fri, 23 Feb 2018 10:01:37 +0000</updated>
                            <resolved>Fri, 23 Feb 2018 10:01:37 +0000</resolved>
                                    <version>1.5.0</version>
                                    <fixVersion>1.5.0</fixVersion>
                                    <component>Runtime / State Backends</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="16368216" author="githubbot" created="Sat, 17 Feb 2018 14:23:36 +0000"  >&lt;p&gt;GitHub user sihuazhou opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8679&quot; title=&quot;RocksDBKeyedBackend.getKeys(stateName, namespace) doesn&amp;#39;t filter data with namespace&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8679&quot;&gt;&lt;del&gt;FLINK-8679&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;State Backends&amp;#93;&lt;/span&gt;Fix RocksDBKeyedBackend.getKeys() bug for missing namespace condition.&lt;/p&gt;

&lt;p&gt;    This PR addressed issue &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8679&quot; title=&quot;RocksDBKeyedBackend.getKeys(stateName, namespace) doesn&amp;#39;t filter data with namespace&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8679&quot;&gt;&lt;del&gt;FLINK-8679&lt;/del&gt;&lt;/a&gt;(&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8679&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-8679&lt;/a&gt;). Currently, `RocksDBKeyedBackend.getKeys(stateName, namespace)` is odds. It doesn&apos;t use the namespace to filter data. The lead to problematic when one key corresponding to different namespace. &lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Modify RocksDBKeyedStateBackend.getKeys() to filter data according to namespace.&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;This change can be verified by unit test in StateBackendTestBase.testGetKeys().&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (no)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (no)&lt;/li&gt;
	&lt;li&gt;The serializers: (no)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (no)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (no)&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: (no)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (no)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/sihuazhou/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/sihuazhou/flink&lt;/a&gt; fix_rocksdb_getkeys&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #5518&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit ec861f44c7dd9fb136fdc682154992f115288f77&lt;br/&gt;
Author: sihuazhou &amp;lt;summerleafs@...&amp;gt;&lt;br/&gt;
Date:   2018-02-16T17:26:12Z&lt;/p&gt;

&lt;p&gt;    Fix getKeys() in RocksDBKeyStateBackend.&lt;/p&gt;

&lt;p&gt;commit 7b0069421aa4e484aba2a97db2e4c6b3cd88f058&lt;br/&gt;
Author: sihuazhou &amp;lt;summerleafs@...&amp;gt;&lt;br/&gt;
Date:   2018-02-17T02:29:59Z&lt;/p&gt;

&lt;p&gt;    Fix loop bug in `getKeys()`.&lt;/p&gt;

&lt;p&gt;commit d50cf63a7da42ebcf5e6ad08e3bbe28b462b1f7c&lt;br/&gt;
Author: sihuazhou &amp;lt;summerleafs@...&amp;gt;&lt;br/&gt;
Date:   2018-02-17T14:13:14Z&lt;/p&gt;

&lt;p&gt;    add test case for different namespace.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16368217" author="githubbot" created="Sat, 17 Feb 2018 14:24:35 +0000"  >&lt;p&gt;Github user sihuazhou commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @pnowojski Could you please have a look at this?&lt;/p&gt;</comment>
                            <comment id="16369127" author="githubbot" created="Mon, 19 Feb 2018 13:45:55 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169066387&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169066387&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/KeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -62,7 +62,7 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param state State variable for which existing keys will be returned.&lt;/li&gt;
	&lt;li&gt;@param namespace Namespace for which existing keys will be returned.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace);&lt;br/&gt;
    +	&amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace, TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    New parameter should be referenced in JavaDoc.&lt;/p&gt;</comment>
                            <comment id="16369128" author="githubbot" created="Mon, 19 Feb 2018 13:45:55 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169067403&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169067403&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -266,9 +267,16 @@ public RocksDBKeyedStateBackend(&lt;br/&gt;
     		RocksIterator iterator = db.newIterator(columnInfo.f0);&lt;br/&gt;
     		iterator.seekToFirst();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Iterable&amp;lt;K&amp;gt; iterable = () -&amp;gt; new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes);&lt;/li&gt;
	&lt;li&gt;Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(iterable.spliterator(), false);&lt;/li&gt;
	&lt;li&gt;return targetStream.onClose(iterator::close);&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			ByteArrayOutputStream outputStream = new ByteArrayOutputStream(8);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    You could better use our `ByteArrayOutputStreamWithPos` which drops all the unnecessary synchronization.&lt;/p&gt;</comment>
                            <comment id="16369129" author="githubbot" created="Mon, 19 Feb 2018 13:45:55 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169074775&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169074775&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +1999,71 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private K nextKey;&lt;/p&gt;

&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			while (nextKey == null &amp;amp;&amp;amp; iterator.isValid()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					boolean namespaceValid = true;&lt;br/&gt;
    +					byte[] key = iterator.key();&lt;br/&gt;
    +					if (key.length &amp;gt;= namespaceBytesLength + keyGroupPrefixBytes) {&lt;br/&gt;
    +						for (int i = 1; i &amp;lt;= namespaceBytesLength; ++i) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +							if (key[key.length - i] != namespaceBytes[namespaceBytesLength - i]) {
    +								namespaceValid = false;
    +								break;
    +							}    +						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +						if (namespaceValid) {&lt;br/&gt;
    +							DataInputViewStreamWrapper dataInput = new DataInputViewStreamWrapper(&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This creates a lot of short-lived objects, and the `ByteArrayInputStreamWithPos` can also grow internally. I wonder if we could not just reuse always the same `ByteArrayInputStreamWithPos` at least? This could also let the internal array eventually be at good size. &lt;/p&gt;</comment>
                            <comment id="16369130" author="githubbot" created="Mon, 19 Feb 2018 13:45:55 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169072840&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169072840&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +1999,71 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private K nextKey;&lt;/p&gt;

&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This method became pretty complex now, so maybe we should have a unit test for it, similar to e.g. `RocksDBMergeIteratorTest`? In particular, it should cover corner cases and different keygroup prefix byte sizes.&lt;/p&gt;</comment>
                            <comment id="16369131" author="githubbot" created="Mon, 19 Feb 2018 13:45:55 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169075007&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169075007&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +1999,71 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private K nextKey;&lt;/p&gt;

&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			while (nextKey == null &amp;amp;&amp;amp; iterator.isValid()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					boolean namespaceValid = true;&lt;br/&gt;
    +					byte[] key = iterator.key();&lt;br/&gt;
    +					if (key.length &amp;gt;= namespaceBytesLength + keyGroupPrefixBytes) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    `namespaceBytesLength + keyGroupPrefixBytes` is basically a constant after the constructor.&lt;/p&gt;</comment>
                            <comment id="16369132" author="githubbot" created="Mon, 19 Feb 2018 13:45:55 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169077434&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169077434&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +1999,71 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private K nextKey;&lt;/p&gt;

&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			while (nextKey == null &amp;amp;&amp;amp; iterator.isValid()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					boolean namespaceValid = true;&lt;br/&gt;
    +					byte[] key = iterator.key();&lt;br/&gt;
    +					if (key.length &amp;gt;= namespaceBytesLength + keyGroupPrefixBytes) {&lt;br/&gt;
    +						for (int i = 1; i &amp;lt;= namespaceBytesLength; ++i) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +							if (key[key.length - i] != namespaceBytes[namespaceBytesLength - i]) {
    +								namespaceValid = false;
    +								break;
    +							}    +						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +						if (namespaceValid) {&lt;br/&gt;
    +							DataInputViewStreamWrapper dataInput = new DataInputViewStreamWrapper(&lt;br/&gt;
    +								new ByteArrayInputStreamWithPos(key, keyGroupPrefixBytes, key.length - keyGroupPrefixBytes));&lt;br/&gt;
    +							K value = keySerializer.deserialize(dataInput);&lt;br/&gt;
    +							if (dataInput.available() == namespaceBytesLength) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    What is the purpose of this `if`? It looks more like a sanity check, but at the same time will silently drop data if it is triggered.&lt;/p&gt;</comment>
                            <comment id="16369133" author="githubbot" created="Mon, 19 Feb 2018 13:45:55 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169076426&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169076426&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +1999,71 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private K nextKey;&lt;/p&gt;

&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			while (nextKey == null &amp;amp;&amp;amp; iterator.isValid()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					boolean namespaceValid = true;&lt;br/&gt;
    +					byte[] key = iterator.key();&lt;br/&gt;
    +					if (key.length &amp;gt;= namespaceBytesLength + keyGroupPrefixBytes) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    We could decompose this loop by introducing a helper method `isMatchingNameSpace(byte[] key, byte[] nameSpaceBytes)`. I think that makes the control flow easier to read.&lt;/p&gt;</comment>
                            <comment id="16369134" author="githubbot" created="Mon, 19 Feb 2018 13:45:56 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169072232&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169072232&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +1999,71 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    One change that I would suggest to something that was not introduced in the PR: we could make `RocksIteratorWrapper` implement `AutoCloseable` and use that close method instead of calling close directly on the RockDB iterator where this is used. I think this is cleaner, because the wrapper should own the Rocks iterator.&lt;/p&gt;</comment>
                            <comment id="16369135" author="githubbot" created="Mon, 19 Feb 2018 13:45:56 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169069584&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169069584&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -266,9 +267,16 @@ public RocksDBKeyedStateBackend(&lt;br/&gt;
     		RocksIterator iterator = db.newIterator(columnInfo.f0);&lt;br/&gt;
     		iterator.seekToFirst();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Iterable&amp;lt;K&amp;gt; iterable = () -&amp;gt; new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes);&lt;/li&gt;
	&lt;li&gt;Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(iterable.spliterator(), false);&lt;/li&gt;
	&lt;li&gt;return targetStream.onClose(iterator::close);&lt;br/&gt;
    +		try 
{
    +			ByteArrayOutputStream outputStream = new ByteArrayOutputStream(8);
    +			namespaceSerializer.serialize(namespace, new DataOutputViewStreamWrapper(outputStream));
    +			final byte[] namespaceBytes = outputStream.toByteArray();
    +			Iterable&amp;lt;K&amp;gt; iterable = () -&amp;gt; new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes, namespaceBytes);
    +			Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(iterable.spliterator(), false);
    +			return targetStream.onClose(iterator::close);
    +		}
&lt;p&gt; catch (IOException ex) {&lt;br/&gt;
    +			throw new FlinkRuntimeException(&quot;Failed to get keys from RocksDB state backend.&quot;, ex);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This case would not call `iterator.close()`. I suggest to just create everything related to `namespaceBytes` before creating the iterator, so that the iterator is only created when no further exception should happen.&lt;/p&gt;</comment>
                            <comment id="16369171" author="githubbot" created="Mon, 19 Feb 2018 14:25:26 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169065861&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169065861&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java &amp;#8212;&lt;br/&gt;
    @@ -211,24 +211,55 @@ protected CheckpointStreamFactory createStreamFactory() throws Exception {&lt;/p&gt;

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testGetKeys() throws Exception {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final int elementsToTest = 1000;&lt;br/&gt;
    +		final int namespace1ElementsNum = 1000;&lt;br/&gt;
    +		final int namespace2ElementsNum = 1000;&lt;br/&gt;
     		String fieldName = &quot;get-keys-test&quot;;&lt;br/&gt;
     		AbstractKeyedStateBackend&amp;lt;Integer&amp;gt; backend = createKeyedBackend(IntSerializer.INSTANCE);&lt;br/&gt;
     		try {&lt;/li&gt;
	&lt;li&gt;ValueState&amp;lt;Integer&amp;gt; keyedState = backend.getOrCreateKeyedState(&lt;/li&gt;
	&lt;li&gt;VoidNamespaceSerializer.INSTANCE,&lt;/li&gt;
	&lt;li&gt;new ValueStateDescriptor&amp;lt;&amp;gt;(fieldName, IntSerializer.INSTANCE));&lt;/li&gt;
	&lt;li&gt;((InternalValueState&amp;lt;VoidNamespace, Integer&amp;gt;) keyedState).setCurrentNamespace(VoidNamespace.INSTANCE);&lt;br/&gt;
    +			final String ns1 = &quot;ns1&quot;;&lt;br/&gt;
    +			ValueState&amp;lt;Integer&amp;gt; keyedState1 = backend.getPartitionedState(&lt;br/&gt;
    +				ns1,&lt;br/&gt;
    +				StringSerializer.INSTANCE,&lt;br/&gt;
    +				new ValueStateDescriptor&amp;lt;&amp;gt;(fieldName, IntSerializer.INSTANCE)&lt;br/&gt;
    +			);&lt;br/&gt;
    +&lt;br/&gt;
    +			((InternalValueState&amp;lt;String, Integer&amp;gt;) keyedState1).setCurrentNamespace(ns1);&lt;br/&gt;
    +&lt;br/&gt;
    +			for (int key = 0; key &amp;lt; namespace1ElementsNum; key++) 
{
    +				backend.setCurrentKey(key);
    +				keyedState1.update(key * 2);
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			ValueState&amp;lt;Integer&amp;gt; keyedState2 = backend.getPartitionedState(&lt;br/&gt;
    +				ns1,&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    If you give `ns2` here you don&apos;t have to call `setCurrentNamespace()` later.&lt;/p&gt;</comment>
                            <comment id="16370183" author="githubbot" created="Tue, 20 Feb 2018 16:03:05 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169367889&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169367889&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/KeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -62,7 +62,7 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param state State variable for which existing keys will be returned.&lt;/li&gt;
	&lt;li&gt;@param namespace Namespace for which existing keys will be returned.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace);&lt;br/&gt;
    +	&amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace, TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    addressed.&lt;/p&gt;</comment>
                            <comment id="16370184" author="githubbot" created="Tue, 20 Feb 2018 16:03:14 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169367934&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169367934&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -266,9 +267,16 @@ public RocksDBKeyedStateBackend(&lt;br/&gt;
     		RocksIterator iterator = db.newIterator(columnInfo.f0);&lt;br/&gt;
     		iterator.seekToFirst();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Iterable&amp;lt;K&amp;gt; iterable = () -&amp;gt; new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes);&lt;/li&gt;
	&lt;li&gt;Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(iterable.spliterator(), false);&lt;/li&gt;
	&lt;li&gt;return targetStream.onClose(iterator::close);&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			ByteArrayOutputStream outputStream = new ByteArrayOutputStream(8);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    addressed.&lt;/p&gt;</comment>
                            <comment id="16370189" author="githubbot" created="Tue, 20 Feb 2018 16:04:37 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169368355&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169368355&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -266,9 +267,16 @@ public RocksDBKeyedStateBackend(&lt;br/&gt;
     		RocksIterator iterator = db.newIterator(columnInfo.f0);&lt;br/&gt;
     		iterator.seekToFirst();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Iterable&amp;lt;K&amp;gt; iterable = () -&amp;gt; new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes);&lt;/li&gt;
	&lt;li&gt;Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(iterable.spliterator(), false);&lt;/li&gt;
	&lt;li&gt;return targetStream.onClose(iterator::close);&lt;br/&gt;
    +		try 
{
    +			ByteArrayOutputStream outputStream = new ByteArrayOutputStream(8);
    +			namespaceSerializer.serialize(namespace, new DataOutputViewStreamWrapper(outputStream));
    +			final byte[] namespaceBytes = outputStream.toByteArray();
    +			Iterable&amp;lt;K&amp;gt; iterable = () -&amp;gt; new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes, namespaceBytes);
    +			Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(iterable.spliterator(), false);
    +			return targetStream.onClose(iterator::close);
    +		}
&lt;p&gt; catch (IOException ex) {&lt;br/&gt;
    +			throw new FlinkRuntimeException(&quot;Failed to get keys from RocksDB state backend.&quot;, ex);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Nice catch! Addressed.&lt;/p&gt;</comment>
                            <comment id="16370190" author="githubbot" created="Tue, 20 Feb 2018 16:04:55 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169368440&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169368440&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +1999,71 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Good point, addressed.&lt;/p&gt;</comment>
                            <comment id="16370191" author="githubbot" created="Tue, 20 Feb 2018 16:05:29 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169368679&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169368679&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +1999,71 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private K nextKey;&lt;/p&gt;

&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Added a unit test `RocksDBRocksIteratorWrapperTest`.&lt;/p&gt;</comment>
                            <comment id="16370192" author="githubbot" created="Tue, 20 Feb 2018 16:05:44 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169368766&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169368766&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +1999,71 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private K nextKey;&lt;/p&gt;

&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			while (nextKey == null &amp;amp;&amp;amp; iterator.isValid()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					boolean namespaceValid = true;&lt;br/&gt;
    +					byte[] key = iterator.key();&lt;br/&gt;
    +					if (key.length &amp;gt;= namespaceBytesLength + keyGroupPrefixBytes) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    addressed.&lt;/p&gt;</comment>
                            <comment id="16370193" author="githubbot" created="Tue, 20 Feb 2018 16:05:53 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169368813&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169368813&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +1999,71 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private K nextKey;&lt;/p&gt;

&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			while (nextKey == null &amp;amp;&amp;amp; iterator.isValid()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					boolean namespaceValid = true;&lt;br/&gt;
    +					byte[] key = iterator.key();&lt;br/&gt;
    +					if (key.length &amp;gt;= namespaceBytesLength + keyGroupPrefixBytes) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    addressed.&lt;/p&gt;</comment>
                            <comment id="16370195" author="githubbot" created="Tue, 20 Feb 2018 16:07:14 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169369280&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169369280&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +1999,71 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private K nextKey;&lt;/p&gt;

&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			while (nextKey == null &amp;amp;&amp;amp; iterator.isValid()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					boolean namespaceValid = true;&lt;br/&gt;
    +					byte[] key = iterator.key();&lt;br/&gt;
    +					if (key.length &amp;gt;= namespaceBytesLength + keyGroupPrefixBytes) {&lt;br/&gt;
    +						for (int i = 1; i &amp;lt;= namespaceBytesLength; ++i) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +							if (key[key.length - i] != namespaceBytes[namespaceBytesLength - i]) {
    +								namespaceValid = false;
    +								break;
    +							}    +						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +						if (namespaceValid) {&lt;br/&gt;
    +							DataInputViewStreamWrapper dataInput = new DataInputViewStreamWrapper(&lt;br/&gt;
    +								new ByteArrayInputStreamWithPos(key, keyGroupPrefixBytes, key.length - keyGroupPrefixBytes));&lt;br/&gt;
    +							K value = keySerializer.deserialize(dataInput);&lt;br/&gt;
    +							if (dataInput.available() == namespaceBytesLength) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    You are right! And I am almost like to remove it now ...&lt;/p&gt;</comment>
                            <comment id="16370197" author="githubbot" created="Tue, 20 Feb 2018 16:07:26 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169369352&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169369352&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java &amp;#8212;&lt;br/&gt;
    @@ -211,24 +211,55 @@ protected CheckpointStreamFactory createStreamFactory() throws Exception {&lt;/p&gt;

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testGetKeys() throws Exception {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final int elementsToTest = 1000;&lt;br/&gt;
    +		final int namespace1ElementsNum = 1000;&lt;br/&gt;
    +		final int namespace2ElementsNum = 1000;&lt;br/&gt;
     		String fieldName = &quot;get-keys-test&quot;;&lt;br/&gt;
     		AbstractKeyedStateBackend&amp;lt;Integer&amp;gt; backend = createKeyedBackend(IntSerializer.INSTANCE);&lt;br/&gt;
     		try {&lt;/li&gt;
	&lt;li&gt;ValueState&amp;lt;Integer&amp;gt; keyedState = backend.getOrCreateKeyedState(&lt;/li&gt;
	&lt;li&gt;VoidNamespaceSerializer.INSTANCE,&lt;/li&gt;
	&lt;li&gt;new ValueStateDescriptor&amp;lt;&amp;gt;(fieldName, IntSerializer.INSTANCE));&lt;/li&gt;
	&lt;li&gt;((InternalValueState&amp;lt;VoidNamespace, Integer&amp;gt;) keyedState).setCurrentNamespace(VoidNamespace.INSTANCE);&lt;br/&gt;
    +			final String ns1 = &quot;ns1&quot;;&lt;br/&gt;
    +			ValueState&amp;lt;Integer&amp;gt; keyedState1 = backend.getPartitionedState(&lt;br/&gt;
    +				ns1,&lt;br/&gt;
    +				StringSerializer.INSTANCE,&lt;br/&gt;
    +				new ValueStateDescriptor&amp;lt;&amp;gt;(fieldName, IntSerializer.INSTANCE)&lt;br/&gt;
    +			);&lt;br/&gt;
    +&lt;br/&gt;
    +			((InternalValueState&amp;lt;String, Integer&amp;gt;) keyedState1).setCurrentNamespace(ns1);&lt;br/&gt;
    +&lt;br/&gt;
    +			for (int key = 0; key &amp;lt; namespace1ElementsNum; key++) 
{
    +				backend.setCurrentKey(key);
    +				keyedState1.update(key * 2);
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			ValueState&amp;lt;Integer&amp;gt; keyedState2 = backend.getPartitionedState(&lt;br/&gt;
    +				ns1,&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    addressed.&lt;/p&gt;</comment>
                            <comment id="16370206" author="githubbot" created="Tue, 20 Feb 2018 16:12:24 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169371111&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169371111&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +1999,71 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private K nextKey;&lt;/p&gt;

&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			while (nextKey == null &amp;amp;&amp;amp; iterator.isValid()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					boolean namespaceValid = true;&lt;br/&gt;
    +					byte[] key = iterator.key();&lt;br/&gt;
    +					if (key.length &amp;gt;= namespaceBytesLength + keyGroupPrefixBytes) {&lt;br/&gt;
    +						for (int i = 1; i &amp;lt;= namespaceBytesLength; ++i) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +							if (key[key.length - i] != namespaceBytes[namespaceBytesLength - i]) {
    +								namespaceValid = false;
    +								break;
    +							}    +						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +						if (namespaceValid) {&lt;br/&gt;
    +							DataInputViewStreamWrapper dataInput = new DataInputViewStreamWrapper(&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Aha, sorry that I am a bit confuse about &quot;`ByteArrayInputStreamWithPos` can also grow internally?&quot; Do you mean `ByteArrayOutputStreamWithPos`?&lt;/p&gt;</comment>
                            <comment id="16370209" author="githubbot" created="Tue, 20 Feb 2018 16:14:31 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169371872&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169371872&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-contrib/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +1999,71 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private K nextKey;&lt;/p&gt;

&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			while (nextKey == null &amp;amp;&amp;amp; iterator.isValid()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					boolean namespaceValid = true;&lt;br/&gt;
    +					byte[] key = iterator.key();&lt;br/&gt;
    +					if (key.length &amp;gt;= namespaceBytesLength + keyGroupPrefixBytes) {&lt;br/&gt;
    +						for (int i = 1; i &amp;lt;= namespaceBytesLength; ++i) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +							if (key[key.length - i] != namespaceBytes[namespaceBytesLength - i]) {
    +								namespaceValid = false;
    +								break;
    +							}    +						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +						if (namespaceValid) {&lt;br/&gt;
    +							DataInputViewStreamWrapper dataInput = new DataInputViewStreamWrapper(&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Oh, yes sorry you are right, I was confused &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16371366" author="githubbot" created="Wed, 21 Feb 2018 12:55:20 +0000"  >&lt;p&gt;Github user sihuazhou commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I have addressed all the comments, could you please have a look again? cc @StefanRRichter @aljoscha &lt;/p&gt;</comment>
                            <comment id="16372612" author="githubbot" created="Thu, 22 Feb 2018 09:55:28 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169904243&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169904243&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/KeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -61,8 +61,9 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;over it keys are not supported.&lt;/li&gt;
	&lt;li&gt;@param state State variable for which existing keys will be returned.&lt;/li&gt;
	&lt;li&gt;@param namespace Namespace for which existing keys will be returned.&lt;br/&gt;
    +	 * @param namespaceSerializer the serializer for the namespace.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace);&lt;br/&gt;
    +	&amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace, TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I noticed that introducing this additional parameter is actually not required. It is only used in RocksDB, where we can also get the namespace serializer in `getKeys(...)` via&lt;br/&gt;
    ```&lt;br/&gt;
    		Tuple2&amp;lt;ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo&amp;lt;?, ?&amp;gt;&amp;gt; columnInfo = kvStateInformation.get(state);&lt;br/&gt;
    		if (columnInfo == null) &lt;/p&gt;
{
    			return Stream.empty();
    		}
&lt;p&gt;    ...&lt;br/&gt;
    		columnInfo.f1.getNamespaceSerializer();&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="16372613" author="githubbot" created="Thu, 22 Feb 2018 10:00:09 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169905515&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169905515&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -207,6 +208,9 @@&lt;br/&gt;
     	/** Unique ID of this backend. */&lt;br/&gt;
     	private UUID backendUID;&lt;/p&gt;

&lt;p&gt;    +	/** The byte array for namespace serialization in getKeys(). */&lt;br/&gt;
    +	private final ByteArrayOutputStreamWithPos namespaceOutputStream;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    It feels like this member is in a too broad scope. While this maximizes caching, I wonder if creating one of there per `getKeys(...)` all is not cleaner and still efficient enough. What do you think?&lt;/p&gt;</comment>
                            <comment id="16372711" author="githubbot" created="Thu, 22 Feb 2018 11:46:44 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169931821&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169931821&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +2034,87 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt;, AutoCloseable {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private final boolean ambiguousKeyPossible;&lt;br/&gt;
    +		private K nextKey;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				boolean ambiguousKeyPossible,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
    +			this.ambiguousKeyPossible = ambiguousKeyPossible;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			final int basicLength = namespaceBytesLength + keyGroupPrefixBytes;&lt;br/&gt;
    +			while (nextKey == null &amp;amp;&amp;amp; iterator.isValid()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					byte[] key = iterator.key();&lt;br/&gt;
    +					if (key.length &amp;gt;= basicLength) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +						if (isMatchingNameSpace(key)) {
    +							ByteArrayInputStreamWithPos inputStream =
    +								new ByteArrayInputStreamWithPos(key, keyGroupPrefixBytes, key.length - keyGroupPrefixBytes);
    +							DataInputViewStreamWrapper dataInput = new DataInputViewStreamWrapper(inputStream);
    +							K value = AbstractRocksDBState.AbstractRocksDBUtils.readKey(
    +								keySerializer,
    +								inputStream,
    +								dataInput,
    +								ambiguousKeyPossible);
    +							nextKey = value;
    +						}    +					}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +					iterator.next();&lt;br/&gt;
    +				} catch (IOException e) &lt;/p&gt;
{
    +					throw new FlinkRuntimeException(&quot;Failed to access state [&quot; + state + &quot;]&quot;, e);
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +			return nextKey != null;&lt;br/&gt;
     		}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public K next() {&lt;br/&gt;
     			if (!hasNext()) &lt;/p&gt;
{
     				throw new NoSuchElementException(&quot;Failed to access state [&quot; + state + &quot;]&quot;);
     			}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try 
{
    -				byte[] key = iterator.key();
    -					DataInputViewStreamWrapper dataInput = new DataInputViewStreamWrapper(
    -					new ByteArrayInputStreamWithPos(key, keyGroupPrefixBytes, key.length - keyGroupPrefixBytes));
    -				K value = keySerializer.deserialize(dataInput);
    -				iterator.next();
    -				return value;
    -			}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    -				throw new FlinkRuntimeException(&quot;Failed to access state [&quot; + state + &quot;]&quot;, e);
    +
    +			K tmpKey = nextKey;
    +			nextKey = null;
    +			return tmpKey;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		private boolean isMatchingNameSpace(byte[] key) {&lt;br/&gt;
    +&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			for (int i = 1; i &amp;lt;= namespaceBytesLength; ++i) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				if (key[key.length - i] != namespaceBytes[namespaceBytesLength - i]) {
    +					return false;
    +				}     			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +			return true;&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public void close() throws Exception {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    You can remove the `throws Exception` here. Then you can also still use the method reference `targetStream.onClose(iterable::close)` in line 296.&lt;/p&gt;</comment>
                            <comment id="16372768" author="githubbot" created="Thu, 22 Feb 2018 12:55:58 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169946359&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169946359&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -253,22 +257,61 @@ public RocksDBKeyedStateBackend(&lt;br/&gt;
     		this.restoredKvStateMetaInfos = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
     		this.materializedSstFiles = new TreeMap&amp;lt;&amp;gt;();&lt;br/&gt;
     		this.backendUID = UUID.randomUUID();&lt;br/&gt;
    +		this.namespaceOutputStream = new ByteArrayOutputStreamWithPos(8);&lt;br/&gt;
     		LOG.debug(&quot;Setting initial keyed backend uid for operator {} to {}.&quot;, this.operatorIdentifier, this.backendUID);&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public &amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace) {&lt;br/&gt;
    +	public &amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace, TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer) {&lt;br/&gt;
     		Tuple2&amp;lt;ColumnFamilyHandle, ?&amp;gt; columnInfo = kvStateInformation.get(state);&lt;br/&gt;
     		if (columnInfo == null) 
{
     			return Stream.empty();
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;RocksIterator iterator = db.newIterator(columnInfo.f0);&lt;/li&gt;
	&lt;li&gt;iterator.seekToFirst();&lt;br/&gt;
    +		RocksIterator iterator = null;&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			iterator = db.newIterator(columnInfo.f0);&lt;br/&gt;
    +			iterator.seekToFirst();&lt;br/&gt;
    +&lt;br/&gt;
    +			boolean ambiguousKeyPossible = AbstractRocksDBState.AbstractRocksDBUtils.isAmbiguousKeyPossible(keySerializer, namespaceSerializer);&lt;br/&gt;
    +			final byte[] nameSpaceBytes;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Iterable&amp;lt;K&amp;gt; iterable = () -&amp;gt; new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes);&lt;/li&gt;
	&lt;li&gt;Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(iterable.spliterator(), false);&lt;/li&gt;
	&lt;li&gt;return targetStream.onClose(iterator::close);&lt;br/&gt;
    +			try 
{
    +				namespaceOutputStream.reset();
    +				AbstractRocksDBState.AbstractRocksDBUtils.writeNameSpace(
    +					namespace,
    +					namespaceSerializer,
    +					namespaceOutputStream,
    +					new DataOutputViewStreamWrapper(namespaceOutputStream),
    +					ambiguousKeyPossible);
    +				nameSpaceBytes = namespaceOutputStream.toByteArray();
    +			}
&lt;p&gt; catch (IOException ex) &lt;/p&gt;
{
    +				throw new FlinkRuntimeException(&quot;Failed to get keys from RocksDB state backend.&quot;, ex);
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			final RocksIteratorWrapper&amp;lt;K&amp;gt; iteratorWrapper = new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes,&lt;br/&gt;
    +				ambiguousKeyPossible, nameSpaceBytes);&lt;br/&gt;
    +&lt;br/&gt;
    +			Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(((Iterable&amp;lt;K&amp;gt;)()-&amp;gt;iteratorWrapper).spliterator(), false);&lt;br/&gt;
    +			return targetStream.onClose(() -&amp;gt; &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				try {
    +					iteratorWrapper.close();
    +				} catch (Exception ex) {
    +					LOG.warn(&quot;Release RocksIteratorWrapper failed.&quot;, ex);
    +				}    +			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;br/&gt;
    +		}  catch (Exception ex) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    As mentioned in my previous comment, this `try-catch` block is not required when we create the iterator further down, where no more exceptions can happen, i.e.&lt;br/&gt;
    ```&lt;br/&gt;
    (...)&lt;br/&gt;
    		RocksIterator iterator = db.newIterator(columnInfo.f0);&lt;br/&gt;
    		iterator.seekToFirst();&lt;/p&gt;

&lt;p&gt;    		final RocksIteratorWrapper&amp;lt;K&amp;gt; iteratorWrapper = new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes,&lt;br/&gt;
    			ambiguousKeyPossible, nameSpaceBytes);&lt;/p&gt;

&lt;p&gt;    		Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(((Iterable&amp;lt;K&amp;gt;) () -&amp;gt; iteratorWrapper).spliterator(), false);&lt;br/&gt;
    		return targetStream.onClose(iterator::close);&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="16372771" author="githubbot" created="Thu, 22 Feb 2018 12:57:54 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169946803&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169946803&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -253,22 +257,61 @@ public RocksDBKeyedStateBackend(&lt;br/&gt;
     		this.restoredKvStateMetaInfos = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
     		this.materializedSstFiles = new TreeMap&amp;lt;&amp;gt;();&lt;br/&gt;
     		this.backendUID = UUID.randomUUID();&lt;br/&gt;
    +		this.namespaceOutputStream = new ByteArrayOutputStreamWithPos(8);&lt;br/&gt;
     		LOG.debug(&quot;Setting initial keyed backend uid for operator {} to {}.&quot;, this.operatorIdentifier, this.backendUID);&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public &amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace) {&lt;br/&gt;
    +	public &amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace, TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer) {&lt;br/&gt;
     		Tuple2&amp;lt;ColumnFamilyHandle, ?&amp;gt; columnInfo = kvStateInformation.get(state);&lt;br/&gt;
     		if (columnInfo == null) 
{
     			return Stream.empty();
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;RocksIterator iterator = db.newIterator(columnInfo.f0);&lt;/li&gt;
	&lt;li&gt;iterator.seekToFirst();&lt;br/&gt;
    +		RocksIterator iterator = null;&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			iterator = db.newIterator(columnInfo.f0);&lt;br/&gt;
    +			iterator.seekToFirst();&lt;br/&gt;
    +&lt;br/&gt;
    +			boolean ambiguousKeyPossible = AbstractRocksDBState.AbstractRocksDBUtils.isAmbiguousKeyPossible(keySerializer, namespaceSerializer);&lt;br/&gt;
    +			final byte[] nameSpaceBytes;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Iterable&amp;lt;K&amp;gt; iterable = () -&amp;gt; new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes);&lt;/li&gt;
	&lt;li&gt;Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(iterable.spliterator(), false);&lt;/li&gt;
	&lt;li&gt;return targetStream.onClose(iterator::close);&lt;br/&gt;
    +			try 
{
    +				namespaceOutputStream.reset();
    +				AbstractRocksDBState.AbstractRocksDBUtils.writeNameSpace(
    +					namespace,
    +					namespaceSerializer,
    +					namespaceOutputStream,
    +					new DataOutputViewStreamWrapper(namespaceOutputStream),
    +					ambiguousKeyPossible);
    +				nameSpaceBytes = namespaceOutputStream.toByteArray();
    +			}
&lt;p&gt; catch (IOException ex) &lt;/p&gt;
{
    +				throw new FlinkRuntimeException(&quot;Failed to get keys from RocksDB state backend.&quot;, ex);
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			final RocksIteratorWrapper&amp;lt;K&amp;gt; iteratorWrapper = new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes,&lt;br/&gt;
    +				ambiguousKeyPossible, nameSpaceBytes);&lt;br/&gt;
    +&lt;br/&gt;
    +			Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(((Iterable&amp;lt;K&amp;gt;)()-&amp;gt;iteratorWrapper).spliterator(), false);&lt;br/&gt;
    +			return targetStream.onClose(() -&amp;gt; &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				try {
    +					iteratorWrapper.close();
    +				} catch (Exception ex) {
    +					LOG.warn(&quot;Release RocksIteratorWrapper failed.&quot;, ex);
    +				}    +			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;br/&gt;
    +		}  catch (Exception ex) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    As mentioned in my previous comment, we can solve this without any `try-catch` here, just create the native iterator further down, where no more exception can happen, i.e.&lt;br/&gt;
    ```&lt;br/&gt;
    (...)&lt;br/&gt;
    		RocksIterator iterator = db.newIterator(columnInfo.f0);&lt;br/&gt;
    		iterator.seekToFirst();&lt;/p&gt;

&lt;p&gt;    		final RocksIteratorWrapper&amp;lt;K&amp;gt; iteratorWrapper = new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes,&lt;br/&gt;
    			ambiguousKeyPossible, nameSpaceBytes);&lt;/p&gt;

&lt;p&gt;    		Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(((Iterable&amp;lt;K&amp;gt;) () -&amp;gt; iteratorWrapper).spliterator(), false);&lt;br/&gt;
    		return targetStream.onClose(iteratorWrapper::close);&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="16372778" author="githubbot" created="Thu, 22 Feb 2018 13:02:22 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169947880&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169947880&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBRocksIteratorWrapperTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,147 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.contrib.streaming.state;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.JobID;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.core.memory.ByteArrayOutputStreamWithPos;&lt;br/&gt;
    +import org.apache.flink.core.memory.DataOutputViewStreamWrapper;&lt;br/&gt;
    +import org.apache.flink.runtime.execution.Environment;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.DummyEnvironment;&lt;br/&gt;
    +import org.apache.flink.runtime.query.TaskKvStateRegistry;&lt;br/&gt;
    +import org.apache.flink.runtime.state.KeyGroupRange;&lt;br/&gt;
    +import org.apache.flink.runtime.state.filesystem.FsStateBackend;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.TemporaryFolder;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.rocksdb.ColumnFamilyHandle;&lt;br/&gt;
    +import org.rocksdb.RocksIterator;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.ArrayList;&lt;br/&gt;
    +import java.util.Comparator;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import java.util.function.Function;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the RocksIteratorWrapper.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RocksDBRocksIteratorWrapperTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public final TemporaryFolder tmp = new TemporaryFolder();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testIterator() throws Exception&lt;/p&gt;
{
    +
    +		// test for keyGroupPrefixBytes == 1 &amp;amp;&amp;amp; ambiguousKeyPossible == false
    +		testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -&amp;gt; i);
    +
    +		// test for keyGroupPrefixBytes == 1 &amp;amp;&amp;amp; ambiguousKeyPossible == true
    +		testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -&amp;gt; String.valueOf(i));
    +
    +		// test for keyGroupPrefixBytes == 2 &amp;amp;&amp;amp; ambiguousKeyPossible == false
    +		testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -&amp;gt; i);
    +
    +		// test for keyGroupPrefixBytes == 2 &amp;amp;&amp;amp; ambiguousKeyPossible == true
    +		testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -&amp;gt; String.valueOf(i));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	&amp;lt;K&amp;gt; void testIteratorHelper(&lt;br/&gt;
    +		TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
    +		TypeSerializer namespaceSerializer,&lt;br/&gt;
    +		int maxKeyGroupNumber,&lt;br/&gt;
    +		Function&amp;lt;Integer, K&amp;gt; getKeyFunc) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		String testStateName = &quot;aha&quot;;&lt;br/&gt;
    +		String namespace = &quot;ns&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +		String dbPath = tmp.newFolder().getAbsolutePath();&lt;br/&gt;
    +		String checkpointPath = tmp.newFolder().toURI().toString();&lt;br/&gt;
    +		RocksDBStateBackend backend = new RocksDBStateBackend(new FsStateBackend(checkpointPath), true);&lt;br/&gt;
    +		backend.setDbStoragePath(dbPath);&lt;br/&gt;
    +&lt;br/&gt;
    +		Environment env = new DummyEnvironment(&quot;TestTask&quot;, 1, 0);&lt;br/&gt;
    +&lt;br/&gt;
    +		RocksDBKeyedStateBackend&amp;lt;K&amp;gt; keyedStateBackend = (RocksDBKeyedStateBackend&amp;lt;K&amp;gt;) backend.createKeyedStateBackend(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This object must be disposed in the end or other tests could eventually fail with JVM crashes.&lt;/p&gt;</comment>
                            <comment id="16372780" author="githubbot" created="Thu, 22 Feb 2018 13:03:00 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169948011&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169948011&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBRocksIteratorWrapperTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,147 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.contrib.streaming.state;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.JobID;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.core.memory.ByteArrayOutputStreamWithPos;&lt;br/&gt;
    +import org.apache.flink.core.memory.DataOutputViewStreamWrapper;&lt;br/&gt;
    +import org.apache.flink.runtime.execution.Environment;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.DummyEnvironment;&lt;br/&gt;
    +import org.apache.flink.runtime.query.TaskKvStateRegistry;&lt;br/&gt;
    +import org.apache.flink.runtime.state.KeyGroupRange;&lt;br/&gt;
    +import org.apache.flink.runtime.state.filesystem.FsStateBackend;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.TemporaryFolder;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.rocksdb.ColumnFamilyHandle;&lt;br/&gt;
    +import org.rocksdb.RocksIterator;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.ArrayList;&lt;br/&gt;
    +import java.util.Comparator;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import java.util.function.Function;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the RocksIteratorWrapper.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RocksDBRocksIteratorWrapperTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public final TemporaryFolder tmp = new TemporaryFolder();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testIterator() throws Exception&lt;/p&gt;
{
    +
    +		// test for keyGroupPrefixBytes == 1 &amp;amp;&amp;amp; ambiguousKeyPossible == false
    +		testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -&amp;gt; i);
    +
    +		// test for keyGroupPrefixBytes == 1 &amp;amp;&amp;amp; ambiguousKeyPossible == true
    +		testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -&amp;gt; String.valueOf(i));
    +
    +		// test for keyGroupPrefixBytes == 2 &amp;amp;&amp;amp; ambiguousKeyPossible == false
    +		testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -&amp;gt; i);
    +
    +		// test for keyGroupPrefixBytes == 2 &amp;amp;&amp;amp; ambiguousKeyPossible == true
    +		testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -&amp;gt; String.valueOf(i));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	&amp;lt;K&amp;gt; void testIteratorHelper(&lt;br/&gt;
    +		TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
    +		TypeSerializer namespaceSerializer,&lt;br/&gt;
    +		int maxKeyGroupNumber,&lt;br/&gt;
    +		Function&amp;lt;Integer, K&amp;gt; getKeyFunc) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		String testStateName = &quot;aha&quot;;&lt;br/&gt;
    +		String namespace = &quot;ns&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +		String dbPath = tmp.newFolder().getAbsolutePath();&lt;br/&gt;
    +		String checkpointPath = tmp.newFolder().toURI().toString();&lt;br/&gt;
    +		RocksDBStateBackend backend = new RocksDBStateBackend(new FsStateBackend(checkpointPath), true);&lt;br/&gt;
    +		backend.setDbStoragePath(dbPath);&lt;br/&gt;
    +&lt;br/&gt;
    +		Environment env = new DummyEnvironment(&quot;TestTask&quot;, 1, 0);&lt;br/&gt;
    +&lt;br/&gt;
    +		RocksDBKeyedStateBackend&amp;lt;K&amp;gt; keyedStateBackend = (RocksDBKeyedStateBackend&amp;lt;K&amp;gt;) backend.createKeyedStateBackend(&lt;br/&gt;
    +			env,&lt;br/&gt;
    +			new JobID(),&lt;br/&gt;
    +			&quot;Test&quot;,&lt;br/&gt;
    +			keySerializer,&lt;br/&gt;
    +			maxKeyGroupNumber,&lt;br/&gt;
    +			new KeyGroupRange(0, maxKeyGroupNumber - 1),&lt;br/&gt;
    +			mock(TaskKvStateRegistry.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		keyedStateBackend.restore(null);&lt;br/&gt;
    +&lt;br/&gt;
    +		ValueState&amp;lt;String&amp;gt; testState = keyedStateBackend.getPartitionedState(&lt;br/&gt;
    +			namespace,&lt;br/&gt;
    +			namespaceSerializer,&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;String&amp;gt;(testStateName, String.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		// insert record&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; 1000; ++i) &lt;/p&gt;
{
    +			keyedStateBackend.setCurrentKey(getKeyFunc.apply(i));
    +			testState.update(String.valueOf(i));
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		ColumnFamilyHandle handle = keyedStateBackend.getColumnFamilyHandle(testStateName);&lt;br/&gt;
    +		RocksIterator iterator = keyedStateBackend.db.newIterator(handle);&lt;br/&gt;
    +		iterator.seekToFirst();&lt;br/&gt;
    +&lt;br/&gt;
    +		ByteArrayOutputStreamWithPos outputStream = new ByteArrayOutputStreamWithPos(8);&lt;br/&gt;
    +		boolean ambiguousKeyPossible = AbstractRocksDBState.AbstractRocksDBUtils.isAmbiguousKeyPossible(keySerializer, namespaceSerializer);&lt;br/&gt;
    +		AbstractRocksDBState.AbstractRocksDBUtils.writeNameSpace(&lt;br/&gt;
    +			namespace,&lt;br/&gt;
    +			namespaceSerializer,&lt;br/&gt;
    +			outputStream,&lt;br/&gt;
    +			new DataOutputViewStreamWrapper(outputStream),&lt;br/&gt;
    +			ambiguousKeyPossible);&lt;br/&gt;
    +&lt;br/&gt;
    +		byte[] nameSpaceBytes = outputStream.toByteArray();&lt;br/&gt;
    +&lt;br/&gt;
    +		RocksDBKeyedStateBackend.RocksIteratorWrapper&amp;lt;K&amp;gt; iteratorWrapper = new RocksDBKeyedStateBackend.RocksIteratorWrapper(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Same here, this is never closed. A test should also check that calling the wrapper&apos;s close closes the native iterator.&lt;/p&gt;</comment>
                            <comment id="16372783" author="githubbot" created="Thu, 22 Feb 2018 13:05:01 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169948460&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169948460&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBRocksIteratorWrapperTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,147 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.contrib.streaming.state;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.JobID;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.core.memory.ByteArrayOutputStreamWithPos;&lt;br/&gt;
    +import org.apache.flink.core.memory.DataOutputViewStreamWrapper;&lt;br/&gt;
    +import org.apache.flink.runtime.execution.Environment;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.DummyEnvironment;&lt;br/&gt;
    +import org.apache.flink.runtime.query.TaskKvStateRegistry;&lt;br/&gt;
    +import org.apache.flink.runtime.state.KeyGroupRange;&lt;br/&gt;
    +import org.apache.flink.runtime.state.filesystem.FsStateBackend;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.TemporaryFolder;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.rocksdb.ColumnFamilyHandle;&lt;br/&gt;
    +import org.rocksdb.RocksIterator;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.ArrayList;&lt;br/&gt;
    +import java.util.Comparator;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import java.util.function.Function;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the RocksIteratorWrapper.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RocksDBRocksIteratorWrapperTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public final TemporaryFolder tmp = new TemporaryFolder();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testIterator() throws Exception&lt;/p&gt;
{
    +
    +		// test for keyGroupPrefixBytes == 1 &amp;amp;&amp;amp; ambiguousKeyPossible == false
    +		testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -&amp;gt; i);
    +
    +		// test for keyGroupPrefixBytes == 1 &amp;amp;&amp;amp; ambiguousKeyPossible == true
    +		testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -&amp;gt; String.valueOf(i));
    +
    +		// test for keyGroupPrefixBytes == 2 &amp;amp;&amp;amp; ambiguousKeyPossible == false
    +		testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -&amp;gt; i);
    +
    +		// test for keyGroupPrefixBytes == 2 &amp;amp;&amp;amp; ambiguousKeyPossible == true
    +		testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -&amp;gt; String.valueOf(i));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	&amp;lt;K&amp;gt; void testIteratorHelper(&lt;br/&gt;
    +		TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
    +		TypeSerializer namespaceSerializer,&lt;br/&gt;
    +		int maxKeyGroupNumber,&lt;br/&gt;
    +		Function&amp;lt;Integer, K&amp;gt; getKeyFunc) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		String testStateName = &quot;aha&quot;;&lt;br/&gt;
    +		String namespace = &quot;ns&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +		String dbPath = tmp.newFolder().getAbsolutePath();&lt;br/&gt;
    +		String checkpointPath = tmp.newFolder().toURI().toString();&lt;br/&gt;
    +		RocksDBStateBackend backend = new RocksDBStateBackend(new FsStateBackend(checkpointPath), true);&lt;br/&gt;
    +		backend.setDbStoragePath(dbPath);&lt;br/&gt;
    +&lt;br/&gt;
    +		Environment env = new DummyEnvironment(&quot;TestTask&quot;, 1, 0);&lt;br/&gt;
    +&lt;br/&gt;
    +		RocksDBKeyedStateBackend&amp;lt;K&amp;gt; keyedStateBackend = (RocksDBKeyedStateBackend&amp;lt;K&amp;gt;) backend.createKeyedStateBackend(&lt;br/&gt;
    +			env,&lt;br/&gt;
    +			new JobID(),&lt;br/&gt;
    +			&quot;Test&quot;,&lt;br/&gt;
    +			keySerializer,&lt;br/&gt;
    +			maxKeyGroupNumber,&lt;br/&gt;
    +			new KeyGroupRange(0, maxKeyGroupNumber - 1),&lt;br/&gt;
    +			mock(TaskKvStateRegistry.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		keyedStateBackend.restore(null);&lt;br/&gt;
    +&lt;br/&gt;
    +		ValueState&amp;lt;String&amp;gt; testState = keyedStateBackend.getPartitionedState(&lt;br/&gt;
    +			namespace,&lt;br/&gt;
    +			namespaceSerializer,&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;String&amp;gt;(testStateName, String.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		// insert record&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; 1000; ++i) &lt;/p&gt;
{
    +			keyedStateBackend.setCurrentKey(getKeyFunc.apply(i));
    +			testState.update(String.valueOf(i));
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		ColumnFamilyHandle handle = keyedStateBackend.getColumnFamilyHandle(testStateName);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Another native object that must be closed, before `keyedStateBackend` is disposed.&lt;/p&gt;</comment>
                            <comment id="16372785" author="githubbot" created="Thu, 22 Feb 2018 13:08:55 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169949298&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169949298&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +2034,87 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt;, AutoCloseable {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private final boolean ambiguousKeyPossible;&lt;br/&gt;
    +		private K nextKey;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				boolean ambiguousKeyPossible,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
    +			this.ambiguousKeyPossible = ambiguousKeyPossible;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			final int basicLength = namespaceBytesLength + keyGroupPrefixBytes;&lt;br/&gt;
    +			while (nextKey == null &amp;amp;&amp;amp; iterator.isValid()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					byte[] key = iterator.key();&lt;br/&gt;
    +					if (key.length &amp;gt;= basicLength) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The outer if could become part of the matcher function, or at least we can combine bot `if` statements with `&amp;amp;&amp;amp;`.&lt;/p&gt;</comment>
                            <comment id="16372788" author="githubbot" created="Thu, 22 Feb 2018 13:10:56 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169949734&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169949734&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +2034,87 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    `thread safe`, without the `ty`&lt;/p&gt;</comment>
                            <comment id="16372790" author="githubbot" created="Thu, 22 Feb 2018 13:15:32 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169950751&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169950751&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/AbstractRocksDBState.java &amp;#8212;&lt;br/&gt;
    @@ -161,107 +160,131 @@ protected void writeKeyWithGroupAndNamespace(&lt;br/&gt;
     		Preconditions.checkNotNull(key, &quot;No key set. This method should not be called outside of a keyed context.&quot;);&lt;/p&gt;

&lt;p&gt;     		keySerializationStream.reset();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;writeKeyGroup(keyGroup, keySerializationDataOutputView);&lt;/li&gt;
	&lt;li&gt;writeKey(key, keySerializationStream, keySerializationDataOutputView);&lt;/li&gt;
	&lt;li&gt;writeNameSpace(namespace, keySerializationStream, keySerializationDataOutputView);&lt;br/&gt;
    +		AbstractRocksDBUtils.writeKeyGroup(keyGroup, backend.getKeyGroupPrefixBytes(), keySerializationDataOutputView);&lt;br/&gt;
    +		AbstractRocksDBUtils.writeKey(key, backend.getKeySerializer(), keySerializationStream, keySerializationDataOutputView, ambiguousKeyPossible);&lt;br/&gt;
    +		AbstractRocksDBUtils.writeNameSpace(namespace, namespaceSerializer, keySerializationStream, keySerializationDataOutputView, ambiguousKeyPossible);&lt;br/&gt;
     	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private void writeKeyGroup(&lt;/li&gt;
	&lt;li&gt;int keyGroup,&lt;/li&gt;
	&lt;li&gt;DataOutputView keySerializationDateDataOutputView) throws IOException {&lt;/li&gt;
	&lt;li&gt;for (int i = backend.getKeyGroupPrefixBytes(); --i &amp;gt;= 0&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
{
    -			keySerializationDateDataOutputView.writeByte(keyGroup &amp;gt;&amp;gt;&amp;gt; (i &amp;lt;&amp;lt; 3));
    -		}
&lt;p&gt;    +	protected Tuple3&amp;lt;Integer, K, N&amp;gt; readKeyWithGroupAndNamespace(ByteArrayInputStreamWithPos inputStream, DataInputView inputView) throws IOException &lt;/p&gt;
{
    +		int keyGroup = AbstractRocksDBUtils.readKeyGroup(backend.getKeyGroupPrefixBytes(), inputView);
    +		K key = AbstractRocksDBUtils.readKey(backend.getKeySerializer(), inputStream, inputView, ambiguousKeyPossible);
    +		N namespace = AbstractRocksDBUtils.readNamespace(namespaceSerializer, inputStream, inputView, ambiguousKeyPossible);
    +
    +		return new Tuple3&amp;lt;&amp;gt;(keyGroup, key, namespace);
     	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private void writeKey(&lt;/li&gt;
	&lt;li&gt;K key,&lt;/li&gt;
	&lt;li&gt;ByteArrayOutputStreamWithPos keySerializationStream,&lt;/li&gt;
	&lt;li&gt;DataOutputView keySerializationDataOutputView) throws IOException {&lt;/li&gt;
	&lt;li&gt;//write key&lt;/li&gt;
	&lt;li&gt;int beforeWrite = keySerializationStream.getPosition();&lt;/li&gt;
	&lt;li&gt;backend.getKeySerializer().serialize(key, keySerializationDataOutputView);&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;if (ambiguousKeyPossible) {&lt;/li&gt;
	&lt;li&gt;//write size of key&lt;/li&gt;
	&lt;li&gt;writeLengthFrom(beforeWrite, keySerializationStream,&lt;/li&gt;
	&lt;li&gt;keySerializationDataOutputView);&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Utils for RocksDB state serialization and deserialization.&lt;br/&gt;
    + 	 */&lt;br/&gt;
    +	static class AbstractRocksDBUtils {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The name of this class already suggests that it might better go to its own file, maybe as `RocksDBKeySerializationUtils`. Now that the methods are public and used in different places, I also suggest to have a test to guard their behavior against accidental code changes.&lt;/p&gt;</comment>
                            <comment id="16372816" author="githubbot" created="Thu, 22 Feb 2018 13:42:21 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169957582&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169957582&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -253,22 +257,61 @@ public RocksDBKeyedStateBackend(&lt;br/&gt;
     		this.restoredKvStateMetaInfos = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
     		this.materializedSstFiles = new TreeMap&amp;lt;&amp;gt;();&lt;br/&gt;
     		this.backendUID = UUID.randomUUID();&lt;br/&gt;
    +		this.namespaceOutputStream = new ByteArrayOutputStreamWithPos(8);&lt;br/&gt;
     		LOG.debug(&quot;Setting initial keyed backend uid for operator {} to {}.&quot;, this.operatorIdentifier, this.backendUID);&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public &amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace) {&lt;br/&gt;
    +	public &amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace, TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer) {&lt;br/&gt;
     		Tuple2&amp;lt;ColumnFamilyHandle, ?&amp;gt; columnInfo = kvStateInformation.get(state);&lt;br/&gt;
     		if (columnInfo == null) 
{
     			return Stream.empty();
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;RocksIterator iterator = db.newIterator(columnInfo.f0);&lt;/li&gt;
	&lt;li&gt;iterator.seekToFirst();&lt;br/&gt;
    +		RocksIterator iterator = null;&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			iterator = db.newIterator(columnInfo.f0);&lt;br/&gt;
    +			iterator.seekToFirst();&lt;br/&gt;
    +&lt;br/&gt;
    +			boolean ambiguousKeyPossible = AbstractRocksDBState.AbstractRocksDBUtils.isAmbiguousKeyPossible(keySerializer, namespaceSerializer);&lt;br/&gt;
    +			final byte[] nameSpaceBytes;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Iterable&amp;lt;K&amp;gt; iterable = () -&amp;gt; new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes);&lt;/li&gt;
	&lt;li&gt;Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(iterable.spliterator(), false);&lt;/li&gt;
	&lt;li&gt;return targetStream.onClose(iterator::close);&lt;br/&gt;
    +			try 
{
    +				namespaceOutputStream.reset();
    +				AbstractRocksDBState.AbstractRocksDBUtils.writeNameSpace(
    +					namespace,
    +					namespaceSerializer,
    +					namespaceOutputStream,
    +					new DataOutputViewStreamWrapper(namespaceOutputStream),
    +					ambiguousKeyPossible);
    +				nameSpaceBytes = namespaceOutputStream.toByteArray();
    +			}
&lt;p&gt; catch (IOException ex) &lt;/p&gt;
{
    +				throw new FlinkRuntimeException(&quot;Failed to get keys from RocksDB state backend.&quot;, ex);
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			final RocksIteratorWrapper&amp;lt;K&amp;gt; iteratorWrapper = new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes,&lt;br/&gt;
    +				ambiguousKeyPossible, nameSpaceBytes);&lt;br/&gt;
    +&lt;br/&gt;
    +			Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(((Iterable&amp;lt;K&amp;gt;)()-&amp;gt;iteratorWrapper).spliterator(), false);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I think `Spliterators.spliteratorUnknownSize(iteratorWrapper, Spliterator.ORDERED)` might be the cleaner way to get a stream from the iterator.&lt;/p&gt;</comment>
                            <comment id="16372921" author="githubbot" created="Thu, 22 Feb 2018 15:13:35 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169988602&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169988602&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/KeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -61,8 +61,9 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;over it keys are not supported.&lt;/li&gt;
	&lt;li&gt;@param state State variable for which existing keys will be returned.&lt;/li&gt;
	&lt;li&gt;@param namespace Namespace for which existing keys will be returned.&lt;br/&gt;
    +	 * @param namespaceSerializer the serializer for the namespace.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace);&lt;br/&gt;
    +	&amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace, TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Aha, I also noticed that `RegisteredKeyedBackendStateMetaInfo` contains the namespace serializer. But there is one thing that confuses me, I found that it looks like one `ColumnFamilyHandle` can correspond to multiple namespace serializer but I am not sure about this, so I introduced this additional parameter. Am I misunderstanding something? Can one `ColumnFamilyHandle` only correspond to one namespace serializer?&lt;/p&gt;</comment>
                            <comment id="16372923" author="githubbot" created="Thu, 22 Feb 2018 15:17:27 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169989983&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169989983&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -207,6 +208,9 @@&lt;br/&gt;
     	/** Unique ID of this backend. */&lt;br/&gt;
     	private UUID backendUID;&lt;/p&gt;

&lt;p&gt;    +	/** The byte array for namespace serialization in getKeys(). */&lt;br/&gt;
    +	private final ByteArrayOutputStreamWithPos namespaceOutputStream;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I would choose to create one of there per` getKeys(...)`.. I think it is cleaner to me than put it into `RocksDBKeyedStateBackend`, cause it is only used in `getKeys()` for now. &lt;/p&gt;</comment>
                            <comment id="16372925" author="githubbot" created="Thu, 22 Feb 2018 15:17:40 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169990041&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169990041&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +2034,87 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt;, AutoCloseable {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private final boolean ambiguousKeyPossible;&lt;br/&gt;
    +		private K nextKey;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				boolean ambiguousKeyPossible,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
    +			this.ambiguousKeyPossible = ambiguousKeyPossible;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			final int basicLength = namespaceBytesLength + keyGroupPrefixBytes;&lt;br/&gt;
    +			while (nextKey == null &amp;amp;&amp;amp; iterator.isValid()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					byte[] key = iterator.key();&lt;br/&gt;
    +					if (key.length &amp;gt;= basicLength) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +						if (isMatchingNameSpace(key)) {
    +							ByteArrayInputStreamWithPos inputStream =
    +								new ByteArrayInputStreamWithPos(key, keyGroupPrefixBytes, key.length - keyGroupPrefixBytes);
    +							DataInputViewStreamWrapper dataInput = new DataInputViewStreamWrapper(inputStream);
    +							K value = AbstractRocksDBState.AbstractRocksDBUtils.readKey(
    +								keySerializer,
    +								inputStream,
    +								dataInput,
    +								ambiguousKeyPossible);
    +							nextKey = value;
    +						}    +					}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +					iterator.next();&lt;br/&gt;
    +				} catch (IOException e) &lt;/p&gt;
{
    +					throw new FlinkRuntimeException(&quot;Failed to access state [&quot; + state + &quot;]&quot;, e);
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +			return nextKey != null;&lt;br/&gt;
     		}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public K next() {&lt;br/&gt;
     			if (!hasNext()) &lt;/p&gt;
{
     				throw new NoSuchElementException(&quot;Failed to access state [&quot; + state + &quot;]&quot;);
     			}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try 
{
    -				byte[] key = iterator.key();
    -					DataInputViewStreamWrapper dataInput = new DataInputViewStreamWrapper(
    -					new ByteArrayInputStreamWithPos(key, keyGroupPrefixBytes, key.length - keyGroupPrefixBytes));
    -				K value = keySerializer.deserialize(dataInput);
    -				iterator.next();
    -				return value;
    -			}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    -				throw new FlinkRuntimeException(&quot;Failed to access state [&quot; + state + &quot;]&quot;, e);
    +
    +			K tmpKey = nextKey;
    +			nextKey = null;
    +			return tmpKey;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		private boolean isMatchingNameSpace(byte[] key) {&lt;br/&gt;
    +&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			for (int i = 1; i &amp;lt;= namespaceBytesLength; ++i) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				if (key[key.length - i] != namespaceBytes[namespaceBytesLength - i]) {
    +					return false;
    +				}     			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +			return true;&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public void close() throws Exception {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    &#128077; addressing&lt;/p&gt;</comment>
                            <comment id="16372927" author="githubbot" created="Thu, 22 Feb 2018 15:18:55 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169990518&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169990518&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -253,22 +257,61 @@ public RocksDBKeyedStateBackend(&lt;br/&gt;
     		this.restoredKvStateMetaInfos = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
     		this.materializedSstFiles = new TreeMap&amp;lt;&amp;gt;();&lt;br/&gt;
     		this.backendUID = UUID.randomUUID();&lt;br/&gt;
    +		this.namespaceOutputStream = new ByteArrayOutputStreamWithPos(8);&lt;br/&gt;
     		LOG.debug(&quot;Setting initial keyed backend uid for operator {} to {}.&quot;, this.operatorIdentifier, this.backendUID);&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public &amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace) {&lt;br/&gt;
    +	public &amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace, TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer) {&lt;br/&gt;
     		Tuple2&amp;lt;ColumnFamilyHandle, ?&amp;gt; columnInfo = kvStateInformation.get(state);&lt;br/&gt;
     		if (columnInfo == null) 
{
     			return Stream.empty();
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;RocksIterator iterator = db.newIterator(columnInfo.f0);&lt;/li&gt;
	&lt;li&gt;iterator.seekToFirst();&lt;br/&gt;
    +		RocksIterator iterator = null;&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			iterator = db.newIterator(columnInfo.f0);&lt;br/&gt;
    +			iterator.seekToFirst();&lt;br/&gt;
    +&lt;br/&gt;
    +			boolean ambiguousKeyPossible = AbstractRocksDBState.AbstractRocksDBUtils.isAmbiguousKeyPossible(keySerializer, namespaceSerializer);&lt;br/&gt;
    +			final byte[] nameSpaceBytes;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Iterable&amp;lt;K&amp;gt; iterable = () -&amp;gt; new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes);&lt;/li&gt;
	&lt;li&gt;Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(iterable.spliterator(), false);&lt;/li&gt;
	&lt;li&gt;return targetStream.onClose(iterator::close);&lt;br/&gt;
    +			try 
{
    +				namespaceOutputStream.reset();
    +				AbstractRocksDBState.AbstractRocksDBUtils.writeNameSpace(
    +					namespace,
    +					namespaceSerializer,
    +					namespaceOutputStream,
    +					new DataOutputViewStreamWrapper(namespaceOutputStream),
    +					ambiguousKeyPossible);
    +				nameSpaceBytes = namespaceOutputStream.toByteArray();
    +			}
&lt;p&gt; catch (IOException ex) &lt;/p&gt;
{
    +				throw new FlinkRuntimeException(&quot;Failed to get keys from RocksDB state backend.&quot;, ex);
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			final RocksIteratorWrapper&amp;lt;K&amp;gt; iteratorWrapper = new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes,&lt;br/&gt;
    +				ambiguousKeyPossible, nameSpaceBytes);&lt;br/&gt;
    +&lt;br/&gt;
    +			Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(((Iterable&amp;lt;K&amp;gt;)()-&amp;gt;iteratorWrapper).spliterator(), false);&lt;br/&gt;
    +			return targetStream.onClose(() -&amp;gt; &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				try {
    +					iteratorWrapper.close();
    +				} catch (Exception ex) {
    +					LOG.warn(&quot;Release RocksIteratorWrapper failed.&quot;, ex);
    +				}    +			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;br/&gt;
    +		}  catch (Exception ex) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    &#128077; I think I misunderstand your thought before... addressing&lt;/p&gt;</comment>
                            <comment id="16372928" author="githubbot" created="Thu, 22 Feb 2018 15:19:20 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169990649&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169990649&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBRocksIteratorWrapperTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,147 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.contrib.streaming.state;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.JobID;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.core.memory.ByteArrayOutputStreamWithPos;&lt;br/&gt;
    +import org.apache.flink.core.memory.DataOutputViewStreamWrapper;&lt;br/&gt;
    +import org.apache.flink.runtime.execution.Environment;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.DummyEnvironment;&lt;br/&gt;
    +import org.apache.flink.runtime.query.TaskKvStateRegistry;&lt;br/&gt;
    +import org.apache.flink.runtime.state.KeyGroupRange;&lt;br/&gt;
    +import org.apache.flink.runtime.state.filesystem.FsStateBackend;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.TemporaryFolder;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.rocksdb.ColumnFamilyHandle;&lt;br/&gt;
    +import org.rocksdb.RocksIterator;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.ArrayList;&lt;br/&gt;
    +import java.util.Comparator;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import java.util.function.Function;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the RocksIteratorWrapper.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RocksDBRocksIteratorWrapperTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public final TemporaryFolder tmp = new TemporaryFolder();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testIterator() throws Exception&lt;/p&gt;
{
    +
    +		// test for keyGroupPrefixBytes == 1 &amp;amp;&amp;amp; ambiguousKeyPossible == false
    +		testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -&amp;gt; i);
    +
    +		// test for keyGroupPrefixBytes == 1 &amp;amp;&amp;amp; ambiguousKeyPossible == true
    +		testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -&amp;gt; String.valueOf(i));
    +
    +		// test for keyGroupPrefixBytes == 2 &amp;amp;&amp;amp; ambiguousKeyPossible == false
    +		testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -&amp;gt; i);
    +
    +		// test for keyGroupPrefixBytes == 2 &amp;amp;&amp;amp; ambiguousKeyPossible == true
    +		testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -&amp;gt; String.valueOf(i));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	&amp;lt;K&amp;gt; void testIteratorHelper(&lt;br/&gt;
    +		TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
    +		TypeSerializer namespaceSerializer,&lt;br/&gt;
    +		int maxKeyGroupNumber,&lt;br/&gt;
    +		Function&amp;lt;Integer, K&amp;gt; getKeyFunc) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		String testStateName = &quot;aha&quot;;&lt;br/&gt;
    +		String namespace = &quot;ns&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +		String dbPath = tmp.newFolder().getAbsolutePath();&lt;br/&gt;
    +		String checkpointPath = tmp.newFolder().toURI().toString();&lt;br/&gt;
    +		RocksDBStateBackend backend = new RocksDBStateBackend(new FsStateBackend(checkpointPath), true);&lt;br/&gt;
    +		backend.setDbStoragePath(dbPath);&lt;br/&gt;
    +&lt;br/&gt;
    +		Environment env = new DummyEnvironment(&quot;TestTask&quot;, 1, 0);&lt;br/&gt;
    +&lt;br/&gt;
    +		RocksDBKeyedStateBackend&amp;lt;K&amp;gt; keyedStateBackend = (RocksDBKeyedStateBackend&amp;lt;K&amp;gt;) backend.createKeyedStateBackend(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Nice catch! Addressing&lt;/p&gt;</comment>
                            <comment id="16372929" author="githubbot" created="Thu, 22 Feb 2018 15:19:35 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169990722&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169990722&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBRocksIteratorWrapperTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,147 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.contrib.streaming.state;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.JobID;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.core.memory.ByteArrayOutputStreamWithPos;&lt;br/&gt;
    +import org.apache.flink.core.memory.DataOutputViewStreamWrapper;&lt;br/&gt;
    +import org.apache.flink.runtime.execution.Environment;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.DummyEnvironment;&lt;br/&gt;
    +import org.apache.flink.runtime.query.TaskKvStateRegistry;&lt;br/&gt;
    +import org.apache.flink.runtime.state.KeyGroupRange;&lt;br/&gt;
    +import org.apache.flink.runtime.state.filesystem.FsStateBackend;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.TemporaryFolder;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.rocksdb.ColumnFamilyHandle;&lt;br/&gt;
    +import org.rocksdb.RocksIterator;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.ArrayList;&lt;br/&gt;
    +import java.util.Comparator;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import java.util.function.Function;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the RocksIteratorWrapper.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RocksDBRocksIteratorWrapperTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public final TemporaryFolder tmp = new TemporaryFolder();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testIterator() throws Exception&lt;/p&gt;
{
    +
    +		// test for keyGroupPrefixBytes == 1 &amp;amp;&amp;amp; ambiguousKeyPossible == false
    +		testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -&amp;gt; i);
    +
    +		// test for keyGroupPrefixBytes == 1 &amp;amp;&amp;amp; ambiguousKeyPossible == true
    +		testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -&amp;gt; String.valueOf(i));
    +
    +		// test for keyGroupPrefixBytes == 2 &amp;amp;&amp;amp; ambiguousKeyPossible == false
    +		testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -&amp;gt; i);
    +
    +		// test for keyGroupPrefixBytes == 2 &amp;amp;&amp;amp; ambiguousKeyPossible == true
    +		testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -&amp;gt; String.valueOf(i));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	&amp;lt;K&amp;gt; void testIteratorHelper(&lt;br/&gt;
    +		TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
    +		TypeSerializer namespaceSerializer,&lt;br/&gt;
    +		int maxKeyGroupNumber,&lt;br/&gt;
    +		Function&amp;lt;Integer, K&amp;gt; getKeyFunc) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		String testStateName = &quot;aha&quot;;&lt;br/&gt;
    +		String namespace = &quot;ns&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +		String dbPath = tmp.newFolder().getAbsolutePath();&lt;br/&gt;
    +		String checkpointPath = tmp.newFolder().toURI().toString();&lt;br/&gt;
    +		RocksDBStateBackend backend = new RocksDBStateBackend(new FsStateBackend(checkpointPath), true);&lt;br/&gt;
    +		backend.setDbStoragePath(dbPath);&lt;br/&gt;
    +&lt;br/&gt;
    +		Environment env = new DummyEnvironment(&quot;TestTask&quot;, 1, 0);&lt;br/&gt;
    +&lt;br/&gt;
    +		RocksDBKeyedStateBackend&amp;lt;K&amp;gt; keyedStateBackend = (RocksDBKeyedStateBackend&amp;lt;K&amp;gt;) backend.createKeyedStateBackend(&lt;br/&gt;
    +			env,&lt;br/&gt;
    +			new JobID(),&lt;br/&gt;
    +			&quot;Test&quot;,&lt;br/&gt;
    +			keySerializer,&lt;br/&gt;
    +			maxKeyGroupNumber,&lt;br/&gt;
    +			new KeyGroupRange(0, maxKeyGroupNumber - 1),&lt;br/&gt;
    +			mock(TaskKvStateRegistry.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		keyedStateBackend.restore(null);&lt;br/&gt;
    +&lt;br/&gt;
    +		ValueState&amp;lt;String&amp;gt; testState = keyedStateBackend.getPartitionedState(&lt;br/&gt;
    +			namespace,&lt;br/&gt;
    +			namespaceSerializer,&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;String&amp;gt;(testStateName, String.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		// insert record&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; 1000; ++i) &lt;/p&gt;
{
    +			keyedStateBackend.setCurrentKey(getKeyFunc.apply(i));
    +			testState.update(String.valueOf(i));
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		ColumnFamilyHandle handle = keyedStateBackend.getColumnFamilyHandle(testStateName);&lt;br/&gt;
    +		RocksIterator iterator = keyedStateBackend.db.newIterator(handle);&lt;br/&gt;
    +		iterator.seekToFirst();&lt;br/&gt;
    +&lt;br/&gt;
    +		ByteArrayOutputStreamWithPos outputStream = new ByteArrayOutputStreamWithPos(8);&lt;br/&gt;
    +		boolean ambiguousKeyPossible = AbstractRocksDBState.AbstractRocksDBUtils.isAmbiguousKeyPossible(keySerializer, namespaceSerializer);&lt;br/&gt;
    +		AbstractRocksDBState.AbstractRocksDBUtils.writeNameSpace(&lt;br/&gt;
    +			namespace,&lt;br/&gt;
    +			namespaceSerializer,&lt;br/&gt;
    +			outputStream,&lt;br/&gt;
    +			new DataOutputViewStreamWrapper(outputStream),&lt;br/&gt;
    +			ambiguousKeyPossible);&lt;br/&gt;
    +&lt;br/&gt;
    +		byte[] nameSpaceBytes = outputStream.toByteArray();&lt;br/&gt;
    +&lt;br/&gt;
    +		RocksDBKeyedStateBackend.RocksIteratorWrapper&amp;lt;K&amp;gt; iteratorWrapper = new RocksDBKeyedStateBackend.RocksIteratorWrapper(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Nice catch! Addressing&lt;/p&gt;</comment>
                            <comment id="16372930" author="githubbot" created="Thu, 22 Feb 2018 15:19:45 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169990779&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169990779&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBRocksIteratorWrapperTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,147 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.contrib.streaming.state;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.JobID;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.core.memory.ByteArrayOutputStreamWithPos;&lt;br/&gt;
    +import org.apache.flink.core.memory.DataOutputViewStreamWrapper;&lt;br/&gt;
    +import org.apache.flink.runtime.execution.Environment;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.DummyEnvironment;&lt;br/&gt;
    +import org.apache.flink.runtime.query.TaskKvStateRegistry;&lt;br/&gt;
    +import org.apache.flink.runtime.state.KeyGroupRange;&lt;br/&gt;
    +import org.apache.flink.runtime.state.filesystem.FsStateBackend;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.TemporaryFolder;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.rocksdb.ColumnFamilyHandle;&lt;br/&gt;
    +import org.rocksdb.RocksIterator;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.ArrayList;&lt;br/&gt;
    +import java.util.Comparator;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import java.util.function.Function;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the RocksIteratorWrapper.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RocksDBRocksIteratorWrapperTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public final TemporaryFolder tmp = new TemporaryFolder();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testIterator() throws Exception&lt;/p&gt;
{
    +
    +		// test for keyGroupPrefixBytes == 1 &amp;amp;&amp;amp; ambiguousKeyPossible == false
    +		testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -&amp;gt; i);
    +
    +		// test for keyGroupPrefixBytes == 1 &amp;amp;&amp;amp; ambiguousKeyPossible == true
    +		testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 128, i -&amp;gt; String.valueOf(i));
    +
    +		// test for keyGroupPrefixBytes == 2 &amp;amp;&amp;amp; ambiguousKeyPossible == false
    +		testIteratorHelper(IntSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -&amp;gt; i);
    +
    +		// test for keyGroupPrefixBytes == 2 &amp;amp;&amp;amp; ambiguousKeyPossible == true
    +		testIteratorHelper(StringSerializer.INSTANCE, StringSerializer.INSTANCE, 256, i -&amp;gt; String.valueOf(i));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	&amp;lt;K&amp;gt; void testIteratorHelper(&lt;br/&gt;
    +		TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
    +		TypeSerializer namespaceSerializer,&lt;br/&gt;
    +		int maxKeyGroupNumber,&lt;br/&gt;
    +		Function&amp;lt;Integer, K&amp;gt; getKeyFunc) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		String testStateName = &quot;aha&quot;;&lt;br/&gt;
    +		String namespace = &quot;ns&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +		String dbPath = tmp.newFolder().getAbsolutePath();&lt;br/&gt;
    +		String checkpointPath = tmp.newFolder().toURI().toString();&lt;br/&gt;
    +		RocksDBStateBackend backend = new RocksDBStateBackend(new FsStateBackend(checkpointPath), true);&lt;br/&gt;
    +		backend.setDbStoragePath(dbPath);&lt;br/&gt;
    +&lt;br/&gt;
    +		Environment env = new DummyEnvironment(&quot;TestTask&quot;, 1, 0);&lt;br/&gt;
    +&lt;br/&gt;
    +		RocksDBKeyedStateBackend&amp;lt;K&amp;gt; keyedStateBackend = (RocksDBKeyedStateBackend&amp;lt;K&amp;gt;) backend.createKeyedStateBackend(&lt;br/&gt;
    +			env,&lt;br/&gt;
    +			new JobID(),&lt;br/&gt;
    +			&quot;Test&quot;,&lt;br/&gt;
    +			keySerializer,&lt;br/&gt;
    +			maxKeyGroupNumber,&lt;br/&gt;
    +			new KeyGroupRange(0, maxKeyGroupNumber - 1),&lt;br/&gt;
    +			mock(TaskKvStateRegistry.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		keyedStateBackend.restore(null);&lt;br/&gt;
    +&lt;br/&gt;
    +		ValueState&amp;lt;String&amp;gt; testState = keyedStateBackend.getPartitionedState(&lt;br/&gt;
    +			namespace,&lt;br/&gt;
    +			namespaceSerializer,&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;String&amp;gt;(testStateName, String.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		// insert record&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; 1000; ++i) &lt;/p&gt;
{
    +			keyedStateBackend.setCurrentKey(getKeyFunc.apply(i));
    +			testState.update(String.valueOf(i));
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		ColumnFamilyHandle handle = keyedStateBackend.getColumnFamilyHandle(testStateName);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Nice catch! Addressing&lt;/p&gt;</comment>
                            <comment id="16372932" author="githubbot" created="Thu, 22 Feb 2018 15:20:21 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169990980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169990980&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +2034,87 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt;, AutoCloseable {&lt;br/&gt;
     		private final RocksIterator iterator;&lt;br/&gt;
     		private final String state;&lt;br/&gt;
     		private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     		private final int keyGroupPrefixBytes;&lt;br/&gt;
    +		private final byte[] namespaceBytes;&lt;br/&gt;
    +		private final boolean ambiguousKeyPossible;&lt;br/&gt;
    +		private K nextKey;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		public RocksIteratorWrapper(&lt;br/&gt;
     				RocksIterator iterator,&lt;br/&gt;
     				String state,&lt;br/&gt;
     				TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;int keyGroupPrefixBytes) {&lt;br/&gt;
    +				int keyGroupPrefixBytes,&lt;br/&gt;
    +				boolean ambiguousKeyPossible,&lt;br/&gt;
    +				byte[] namespaceBytes) 
{
     			this.iterator = Preconditions.checkNotNull(iterator);
     			this.state = Preconditions.checkNotNull(state);
     			this.keySerializer = Preconditions.checkNotNull(keySerializer);
     			this.keyGroupPrefixBytes = Preconditions.checkNotNull(keyGroupPrefixBytes);
    +			this.namespaceBytes = Preconditions.checkNotNull(namespaceBytes);
    +			this.nextKey = null;
    +			this.ambiguousKeyPossible = ambiguousKeyPossible;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     		@Override&lt;br/&gt;
     		public boolean hasNext() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return iterator.isValid();&lt;br/&gt;
    +			final int namespaceBytesLength = namespaceBytes.length;&lt;br/&gt;
    +			final int basicLength = namespaceBytesLength + keyGroupPrefixBytes;&lt;br/&gt;
    +			while (nextKey == null &amp;amp;&amp;amp; iterator.isValid()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					byte[] key = iterator.key();&lt;br/&gt;
    +					if (key.length &amp;gt;= basicLength) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Addressing&lt;/p&gt;</comment>
                            <comment id="16372933" author="githubbot" created="Thu, 22 Feb 2018 15:20:30 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169991026&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169991026&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -1991,43 +2034,87 @@ public int numStateEntries() &lt;/p&gt;
{
     		return count;
     	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static class RocksIteratorWrapper&amp;lt;K&amp;gt; implements Iterator&amp;lt;K&amp;gt; {&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * This class is not thread safety.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    &#128077; &lt;/p&gt;</comment>
                            <comment id="16372934" author="githubbot" created="Thu, 22 Feb 2018 15:20:40 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169991080&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169991080&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/AbstractRocksDBState.java &amp;#8212;&lt;br/&gt;
    @@ -161,107 +160,131 @@ protected void writeKeyWithGroupAndNamespace(&lt;br/&gt;
     		Preconditions.checkNotNull(key, &quot;No key set. This method should not be called outside of a keyed context.&quot;);&lt;/p&gt;

&lt;p&gt;     		keySerializationStream.reset();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;writeKeyGroup(keyGroup, keySerializationDataOutputView);&lt;/li&gt;
	&lt;li&gt;writeKey(key, keySerializationStream, keySerializationDataOutputView);&lt;/li&gt;
	&lt;li&gt;writeNameSpace(namespace, keySerializationStream, keySerializationDataOutputView);&lt;br/&gt;
    +		AbstractRocksDBUtils.writeKeyGroup(keyGroup, backend.getKeyGroupPrefixBytes(), keySerializationDataOutputView);&lt;br/&gt;
    +		AbstractRocksDBUtils.writeKey(key, backend.getKeySerializer(), keySerializationStream, keySerializationDataOutputView, ambiguousKeyPossible);&lt;br/&gt;
    +		AbstractRocksDBUtils.writeNameSpace(namespace, namespaceSerializer, keySerializationStream, keySerializationDataOutputView, ambiguousKeyPossible);&lt;br/&gt;
     	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private void writeKeyGroup(&lt;/li&gt;
	&lt;li&gt;int keyGroup,&lt;/li&gt;
	&lt;li&gt;DataOutputView keySerializationDateDataOutputView) throws IOException {&lt;/li&gt;
	&lt;li&gt;for (int i = backend.getKeyGroupPrefixBytes(); --i &amp;gt;= 0&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
{
    -			keySerializationDateDataOutputView.writeByte(keyGroup &amp;gt;&amp;gt;&amp;gt; (i &amp;lt;&amp;lt; 3));
    -		}
&lt;p&gt;    +	protected Tuple3&amp;lt;Integer, K, N&amp;gt; readKeyWithGroupAndNamespace(ByteArrayInputStreamWithPos inputStream, DataInputView inputView) throws IOException &lt;/p&gt;
{
    +		int keyGroup = AbstractRocksDBUtils.readKeyGroup(backend.getKeyGroupPrefixBytes(), inputView);
    +		K key = AbstractRocksDBUtils.readKey(backend.getKeySerializer(), inputStream, inputView, ambiguousKeyPossible);
    +		N namespace = AbstractRocksDBUtils.readNamespace(namespaceSerializer, inputStream, inputView, ambiguousKeyPossible);
    +
    +		return new Tuple3&amp;lt;&amp;gt;(keyGroup, key, namespace);
     	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private void writeKey(&lt;/li&gt;
	&lt;li&gt;K key,&lt;/li&gt;
	&lt;li&gt;ByteArrayOutputStreamWithPos keySerializationStream,&lt;/li&gt;
	&lt;li&gt;DataOutputView keySerializationDataOutputView) throws IOException {&lt;/li&gt;
	&lt;li&gt;//write key&lt;/li&gt;
	&lt;li&gt;int beforeWrite = keySerializationStream.getPosition();&lt;/li&gt;
	&lt;li&gt;backend.getKeySerializer().serialize(key, keySerializationDataOutputView);&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;if (ambiguousKeyPossible) {&lt;/li&gt;
	&lt;li&gt;//write size of key&lt;/li&gt;
	&lt;li&gt;writeLengthFrom(beforeWrite, keySerializationStream,&lt;/li&gt;
	&lt;li&gt;keySerializationDataOutputView);&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Utils for RocksDB state serialization and deserialization.&lt;br/&gt;
    + 	 */&lt;br/&gt;
    +	static class AbstractRocksDBUtils {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Addressing&lt;/p&gt;</comment>
                            <comment id="16372936" author="githubbot" created="Thu, 22 Feb 2018 15:20:48 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169991126&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169991126&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -253,22 +257,61 @@ public RocksDBKeyedStateBackend(&lt;br/&gt;
     		this.restoredKvStateMetaInfos = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
     		this.materializedSstFiles = new TreeMap&amp;lt;&amp;gt;();&lt;br/&gt;
     		this.backendUID = UUID.randomUUID();&lt;br/&gt;
    +		this.namespaceOutputStream = new ByteArrayOutputStreamWithPos(8);&lt;br/&gt;
     		LOG.debug(&quot;Setting initial keyed backend uid for operator {} to {}.&quot;, this.operatorIdentifier, this.backendUID);&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public &amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace) {&lt;br/&gt;
    +	public &amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace, TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer) {&lt;br/&gt;
     		Tuple2&amp;lt;ColumnFamilyHandle, ?&amp;gt; columnInfo = kvStateInformation.get(state);&lt;br/&gt;
     		if (columnInfo == null) 
{
     			return Stream.empty();
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;RocksIterator iterator = db.newIterator(columnInfo.f0);&lt;/li&gt;
	&lt;li&gt;iterator.seekToFirst();&lt;br/&gt;
    +		RocksIterator iterator = null;&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			iterator = db.newIterator(columnInfo.f0);&lt;br/&gt;
    +			iterator.seekToFirst();&lt;br/&gt;
    +&lt;br/&gt;
    +			boolean ambiguousKeyPossible = AbstractRocksDBState.AbstractRocksDBUtils.isAmbiguousKeyPossible(keySerializer, namespaceSerializer);&lt;br/&gt;
    +			final byte[] nameSpaceBytes;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Iterable&amp;lt;K&amp;gt; iterable = () -&amp;gt; new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes);&lt;/li&gt;
	&lt;li&gt;Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(iterable.spliterator(), false);&lt;/li&gt;
	&lt;li&gt;return targetStream.onClose(iterator::close);&lt;br/&gt;
    +			try 
{
    +				namespaceOutputStream.reset();
    +				AbstractRocksDBState.AbstractRocksDBUtils.writeNameSpace(
    +					namespace,
    +					namespaceSerializer,
    +					namespaceOutputStream,
    +					new DataOutputViewStreamWrapper(namespaceOutputStream),
    +					ambiguousKeyPossible);
    +				nameSpaceBytes = namespaceOutputStream.toByteArray();
    +			}
&lt;p&gt; catch (IOException ex) &lt;/p&gt;
{
    +				throw new FlinkRuntimeException(&quot;Failed to get keys from RocksDB state backend.&quot;, ex);
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			final RocksIteratorWrapper&amp;lt;K&amp;gt; iteratorWrapper = new RocksIteratorWrapper&amp;lt;&amp;gt;(iterator, state, keySerializer, keyGroupPrefixBytes,&lt;br/&gt;
    +				ambiguousKeyPossible, nameSpaceBytes);&lt;br/&gt;
    +&lt;br/&gt;
    +			Stream&amp;lt;K&amp;gt; targetStream = StreamSupport.stream(((Iterable&amp;lt;K&amp;gt;)()-&amp;gt;iteratorWrapper).spliterator(), false);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    &#128077; &lt;/p&gt;</comment>
                            <comment id="16372937" author="githubbot" created="Thu, 22 Feb 2018 15:22:10 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169991617&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169991617&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/KeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -61,8 +61,9 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;over it keys are not supported.&lt;/li&gt;
	&lt;li&gt;@param state State variable for which existing keys will be returned.&lt;/li&gt;
	&lt;li&gt;@param namespace Namespace for which existing keys will be returned.&lt;br/&gt;
    +	 * @param namespaceSerializer the serializer for the namespace.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace);&lt;br/&gt;
    +	&amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace, TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Currently, each registered state has its own column family, so that should be ok. What made you think that this does not hold? (asking in case you found something that should be fixed)&lt;/p&gt;</comment>
                            <comment id="16372938" author="githubbot" created="Thu, 22 Feb 2018 15:22:40 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169991823&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169991823&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBKeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -207,6 +208,9 @@&lt;br/&gt;
     	/** Unique ID of this backend. */&lt;br/&gt;
     	private UUID backendUID;&lt;/p&gt;

&lt;p&gt;    +	/** The byte array for namespace serialization in getKeys(). */&lt;br/&gt;
    +	private final ByteArrayOutputStreamWithPos namespaceOutputStream;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Ok, sounds good &#128077; &lt;/p&gt;</comment>
                            <comment id="16372946" author="githubbot" created="Thu, 22 Feb 2018 15:28:41 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518#discussion_r169993867&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518#discussion_r169993867&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/KeyedStateBackend.java &amp;#8212;&lt;br/&gt;
    @@ -61,8 +61,9 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;over it keys are not supported.&lt;/li&gt;
	&lt;li&gt;@param state State variable for which existing keys will be returned.&lt;/li&gt;
	&lt;li&gt;@param namespace Namespace for which existing keys will be returned.&lt;br/&gt;
    +	 * @param namespaceSerializer the serializer for the namespace.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace);&lt;br/&gt;
    +	&amp;lt;N&amp;gt; Stream&amp;lt;K&amp;gt; getKeys(String state, N namespace, TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Checked! It is me that misunderstand something. The `getPartitionedState confused me, it just reset the `namespace` but not reset the `namespaceSerializer` for the `previous` state. Please just ignore me... Addressing this.&lt;/p&gt;</comment>
                            <comment id="16374152" author="githubbot" created="Fri, 23 Feb 2018 09:49:45 +0000"  >&lt;p&gt;Github user StefanRRichter commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks a lot for your efforts @sihuazhou ! Changes look good now and I will merge this.&lt;/p&gt;</comment>
                            <comment id="16374175" author="githubbot" created="Fri, 23 Feb 2018 10:00:19 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5518&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5518&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16374177" author="srichter" created="Fri, 23 Feb 2018 10:01:37 +0000"  >&lt;p&gt;Merged in&#160;eeac022f05.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 38 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3qa7z:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>