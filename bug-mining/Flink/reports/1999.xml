<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:30:28 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-7067] Cancel with savepoint does not restart checkpoint scheduler on failure</title>
                <link>https://issues.apache.org/jira/browse/FLINK-7067</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;The `CancelWithSavepoint` action of the JobManager first stops the checkpoint scheduler, then triggers a savepoint, and cancels the job after the savepoint completes.&lt;/p&gt;

&lt;p&gt;If the savepoint fails, the command should not have any side effects and we don&apos;t cancel the job. The issue is that the checkpoint scheduler is not restarted though.&lt;/p&gt;
</description>
                <environment></environment>
        <key id="13084229">FLINK-7067</key>
            <summary>Cancel with savepoint does not restart checkpoint scheduler on failure</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="uce">Ufuk Celebi</assignee>
                                    <reporter username="uce">Ufuk Celebi</reporter>
                        <labels>
                    </labels>
                <created>Mon, 3 Jul 2017 12:07:11 +0000</created>
                <updated>Wed, 2 Oct 2019 17:44:25 +0000</updated>
                            <resolved>Mon, 12 Mar 2018 15:17:50 +0000</resolved>
                                    <version>1.3.1</version>
                                    <fixVersion>1.3.4</fixVersion>
                    <fixVersion>1.4.0</fixVersion>
                                    <component>Runtime / State Backends</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="16073807" author="githubbot" created="Tue, 4 Jul 2017 15:16:42 +0000"  >&lt;p&gt;GitHub user uce opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4254&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7067&quot; title=&quot;Cancel with savepoint does not restart checkpoint scheduler on failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7067&quot;&gt;&lt;del&gt;FLINK-7067&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;jobmanager&amp;#93;&lt;/span&gt; Fix side effects after failed cancel-job-with-savepoint&lt;/p&gt;

&lt;p&gt;    If a cancel-job-with-savepoint request fails, this has an unintended side effect on the respective job if it has periodic checkpoints enabled. The periodic checkpoint scheduler is stopped before triggering the savepoint, but not restarted if a savepoint fails and the job is not cancelled.&lt;/p&gt;

&lt;p&gt;    This fix makes sure that the periodic checkpoint scheduler is restarted iff periodic checkpoints were enabled before.&lt;/p&gt;

&lt;p&gt;    I have the test in a separate commit, because it uses Reflection to update a private field with a spied upon instance of the CheckpointCoordinator in order to test the expected behaviour. This is super fragile and ugly, but the alternatives require a large refactoring (use factories that can be set during tests) or don&apos;t test this corner case behaviour. The separate commit makes it easier to remove/revert it at a future point in time.&lt;/p&gt;


&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/uce/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/uce/flink&lt;/a&gt; 7067-restart_checkpoint_scheduler&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4254.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4254.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4254&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 7294de0ef77a346b7b38d4b3fcdc421f7fd6855b&lt;br/&gt;
Author: Ufuk Celebi &amp;lt;uce@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-07-04T14:39:02Z&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;tests&amp;#93;&lt;/span&gt; Reduce visibility of helper class methods&lt;/p&gt;

&lt;p&gt;    There is no need to make the helper methods public. No other class&lt;br/&gt;
    should even use this inner test helper invokable.&lt;/p&gt;

&lt;p&gt;commit ce924bc146d3cf97e0c5ddcc1ba16610b2fc8d49&lt;br/&gt;
Author: Ufuk Celebi &amp;lt;uce@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-07-04T14:53:54Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7067&quot; title=&quot;Cancel with savepoint does not restart checkpoint scheduler on failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7067&quot;&gt;&lt;del&gt;FLINK-7067&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;jobmanager&amp;#93;&lt;/span&gt; Add test for cancel-job-with-savepoint side effects&lt;/p&gt;

&lt;p&gt;    I have this test in a separate commit, because it uses Reflection&lt;br/&gt;
    to update private field with a spied upon instance of the&lt;br/&gt;
    CheckpointCoordinator in order to test the expected behaviour. This&lt;br/&gt;
    makes it easier to remove/revert at a future point in time.&lt;/p&gt;

&lt;p&gt;    This is super fragile and ugly, but the alternatives require a&lt;br/&gt;
    large refactoring (use factories that can be set during tests)&lt;br/&gt;
    or don&apos;t test this corner case behaviour.&lt;/p&gt;

&lt;p&gt;commit 94aa444cbd7099d7830e06efe3525a717becb740&lt;br/&gt;
Author: Ufuk Celebi &amp;lt;uce@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-07-04T15:01:32Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7067&quot; title=&quot;Cancel with savepoint does not restart checkpoint scheduler on failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7067&quot;&gt;&lt;del&gt;FLINK-7067&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;jobmanager&amp;#93;&lt;/span&gt; Fix side effects after failed cancel-job-with-savepoint&lt;/p&gt;

&lt;p&gt;    Problem: If a cancel-job-with-savepoint request fails, this has an&lt;br/&gt;
    unintended side effect on the respective job if it has periodic&lt;br/&gt;
    checkpoints enabled. The periodic checkpoint scheduler is stopped&lt;br/&gt;
    before triggering the savepoint, but not restarted if a savepoint&lt;br/&gt;
    fails and the job is not cancelled.&lt;/p&gt;

&lt;p&gt;    This commit makes sure that the periodic checkpoint scheduler is&lt;br/&gt;
    restarted iff periodic checkpoints were enabled before.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16074341" author="githubbot" created="Wed, 5 Jul 2017 07:24:45 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4254#discussion_r125570975&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4254#discussion_r125570975&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java &amp;#8212;&lt;br/&gt;
    @@ -940,6 +955,177 @@ public void testCancelWithSavepoint() throws Exception {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/**&lt;br/&gt;
    +	 * Tests that a failed cancel-job-with-savepoint request does not accidentally disable&lt;br/&gt;
    +	 * periodic checkpoints.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testCancelJobWithSavepointFailurePeriodicCheckpoints() throws Exception &lt;/p&gt;
{
    +		testCancelJobWithSavepointFailure(true);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Tests that a failed cancel-job-with-savepoint request does not accidentally enable&lt;br/&gt;
    +	 * periodic checkpoints.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testCancelJobWithSavepointFailureNoPeriodicCheckpoints() throws Exception &lt;/p&gt;
{
    +		testCancelJobWithSavepointFailure(false);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Tests that a failed savepoint does not cancel the job and that there are no&lt;br/&gt;
    +	 * unintended side effects.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param enablePeriodicCheckpoints Flag to indicate whether to enable periodic checkpoints. We&lt;br/&gt;
    +	 * need to test both here in order to verify that we don&apos;t accidentally disable or enable&lt;br/&gt;
    +	 * checkpoints after a failed cancel-job-with-savepoint request.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testCancelJobWithSavepointFailure(&lt;br/&gt;
    +		boolean enablePeriodicCheckpoints) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		long checkpointInterval = enablePeriodicCheckpoints ? 3600000 : Long.MAX_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		// Savepoint target&lt;br/&gt;
    +		File savepointTarget = tmpFolder.newFolder();&lt;br/&gt;
    +		savepointTarget.deleteOnExit();&lt;br/&gt;
    +&lt;br/&gt;
    +		// Timeout for Akka messages&lt;br/&gt;
    +		FiniteDuration askTimeout = new FiniteDuration(30, TimeUnit.SECONDS);&lt;br/&gt;
    +&lt;br/&gt;
    +		// A source that declines savepoints, simulating the behaviour&lt;br/&gt;
    +		// of a failed savepoint.&lt;br/&gt;
    +		JobVertex sourceVertex = new JobVertex(&quot;Source&quot;);&lt;br/&gt;
    +		sourceVertex.setInvokableClass(FailOnSavepointStatefulTask.class);&lt;br/&gt;
    +		sourceVertex.setParallelism(1);&lt;br/&gt;
    +		JobGraph jobGraph = new JobGraph(&quot;TestingJob&quot;, sourceVertex);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ActorSystem actorSystem = AkkaUtils.createLocalActorSystem(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			Tuple2&amp;lt;ActorRef, ActorRef&amp;gt; master = JobManager.startJobManagerActors(&lt;br/&gt;
    +				new Configuration(),&lt;br/&gt;
    +				actorSystem,&lt;br/&gt;
    +				TestingUtils.defaultExecutor(),&lt;br/&gt;
    +				TestingUtils.defaultExecutor(),&lt;br/&gt;
    +				highAvailabilityServices,&lt;br/&gt;
    +				Option.apply(&quot;jm&quot;),&lt;br/&gt;
    +				Option.apply(&quot;arch&quot;),&lt;br/&gt;
    +				TestingJobManager.class,&lt;br/&gt;
    +				TestingMemoryArchivist.class);&lt;br/&gt;
    +&lt;br/&gt;
    +			UUID leaderId = LeaderRetrievalUtils.retrieveLeaderSessionId(&lt;br/&gt;
    +				highAvailabilityServices.getJobManagerLeaderRetriever(HighAvailabilityServices.DEFAULT_JOB_ID),&lt;br/&gt;
    +				TestingUtils.TESTING_TIMEOUT());&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorGateway jobManager = new AkkaActorGateway(master._1(), leaderId);&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorRef taskManagerRef = TaskManager.startTaskManagerComponentsAndActor(&lt;br/&gt;
    +				new Configuration(),&lt;br/&gt;
    +				ResourceID.generate(),&lt;br/&gt;
    +				actorSystem,&lt;br/&gt;
    +				highAvailabilityServices,&lt;br/&gt;
    +				&quot;localhost&quot;,&lt;br/&gt;
    +				Option.apply(&quot;tm&quot;),&lt;br/&gt;
    +				true,&lt;br/&gt;
    +				TestingTaskManager.class);&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorGateway taskManager = new AkkaActorGateway(taskManagerRef, leaderId);&lt;br/&gt;
    +&lt;br/&gt;
    +			// Wait until connected&lt;br/&gt;
    +			Object msg = new TestingTaskManagerMessages.NotifyWhenRegisteredAtJobManager(jobManager.actor());&lt;br/&gt;
    +			Await.ready(taskManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			JobCheckpointingSettings snapshottingSettings = new JobCheckpointingSettings(&lt;br/&gt;
    +				Collections.singletonList(sourceVertex.getID()),&lt;br/&gt;
    +				Collections.singletonList(sourceVertex.getID()),&lt;br/&gt;
    +				Collections.singletonList(sourceVertex.getID()),&lt;br/&gt;
    +				checkpointInterval,&lt;br/&gt;
    +				3600000,&lt;br/&gt;
    +				0,&lt;br/&gt;
    +				Integer.MAX_VALUE,&lt;br/&gt;
    +				ExternalizedCheckpointSettings.none(),&lt;br/&gt;
    +				null,&lt;br/&gt;
    +				true);&lt;br/&gt;
    +&lt;br/&gt;
    +			jobGraph.setSnapshotSettings(snapshottingSettings);&lt;br/&gt;
    +&lt;br/&gt;
    +			// Submit job graph&lt;br/&gt;
    +			msg = new JobManagerMessages.SubmitJob(jobGraph, ListeningBehaviour.DETACHED);&lt;br/&gt;
    +			Await.ready(jobManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			// Wait for all tasks to be running&lt;br/&gt;
    +			msg = new TestingJobManagerMessages.WaitForAllVerticesToBeRunning(jobGraph.getJobID());&lt;br/&gt;
    +			Await.ready(jobManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			// ----------------------------------------------------------------&lt;br/&gt;
    +			// Super ugly... sorry! But this is one of the few bad options&lt;br/&gt;
    +			// to test this here. Ideally, we would have a factory that we&lt;br/&gt;
    +			// can set in tests as desired. But we don&apos;t. So here we go...&lt;br/&gt;
    +			msg = new RequestExecutionGraph(jobGraph.getJobID());&lt;br/&gt;
    +			Object result = Await.result(jobManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			ExecutionGraph eg;&lt;br/&gt;
    +			if (result instanceof ExecutionGraphFound) &lt;/p&gt;
{
    +				// Sorry...
    +				eg = (ExecutionGraph) ((ExecutionGraphFound) result).executionGraph();
    +			}
&lt;p&gt; else &lt;/p&gt;
{
    +				throw new RuntimeException(&quot;Could not access ExecutionGraph for job with &quot;
    +					+ &quot;ID &quot; + jobGraph.getJobID() + &quot;. Response: &quot; + result.toString());
    +
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			Field field = eg.getClass().getDeclaredField(&quot;checkpointCoordinator&quot;);&lt;br/&gt;
    +			field.setAccessible(true);&lt;br/&gt;
    +			CheckpointCoordinator coord = (CheckpointCoordinator) field.get(eg);&lt;br/&gt;
    +			CheckpointCoordinator spiedCoord = Mockito.spy(coord);&lt;br/&gt;
    +			field.set(eg, spiedCoord);&lt;br/&gt;
    +			// ----------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +			// Cancel with savepoint&lt;br/&gt;
    +			msg = new JobManagerMessages.CancelJobWithSavepoint(jobGraph.getJobID(),&lt;br/&gt;
    +				savepointTarget.getAbsolutePath());&lt;br/&gt;
    +			CancellationResponse cancelResp = (CancellationResponse) Await.result(&lt;br/&gt;
    +				jobManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			if (cancelResp instanceof CancellationFailure) {&lt;br/&gt;
    +				if (enablePeriodicCheckpoints) {&lt;br/&gt;
    +					// Verify checkpoint scheduler deactivated and reactivated.&lt;br/&gt;
    +					// A call to start checkpoint scheduler calls stop scheduler&lt;br/&gt;
    +					// again. Therefore, we verify two calls for stop. Since we&lt;br/&gt;
    +					// spy (I know...) on the coordinator after the job has&lt;br/&gt;
    +					// started, we don&apos;t count calls before spying.&lt;br/&gt;
    +					verify(spiedCoord, times(1)).startCheckpointScheduler();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Could we not re-attempt a cancel-with-savepoint? If the coordinator is shutdown it will fail; if it was restarted it should succeed (provided we adjust the failing source to only fail the first time). Then we wouldn&apos;t need the spying but would actually just test observable behavior.&lt;/p&gt;</comment>
                            <comment id="16074542" author="githubbot" created="Wed, 5 Jul 2017 10:21:48 +0000"  >&lt;p&gt;Github user uce commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4254#discussion_r125606557&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4254#discussion_r125606557&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java &amp;#8212;&lt;br/&gt;
    @@ -940,6 +955,177 @@ public void testCancelWithSavepoint() throws Exception {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/**&lt;br/&gt;
    +	 * Tests that a failed cancel-job-with-savepoint request does not accidentally disable&lt;br/&gt;
    +	 * periodic checkpoints.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testCancelJobWithSavepointFailurePeriodicCheckpoints() throws Exception &lt;/p&gt;
{
    +		testCancelJobWithSavepointFailure(true);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Tests that a failed cancel-job-with-savepoint request does not accidentally enable&lt;br/&gt;
    +	 * periodic checkpoints.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testCancelJobWithSavepointFailureNoPeriodicCheckpoints() throws Exception &lt;/p&gt;
{
    +		testCancelJobWithSavepointFailure(false);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Tests that a failed savepoint does not cancel the job and that there are no&lt;br/&gt;
    +	 * unintended side effects.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param enablePeriodicCheckpoints Flag to indicate whether to enable periodic checkpoints. We&lt;br/&gt;
    +	 * need to test both here in order to verify that we don&apos;t accidentally disable or enable&lt;br/&gt;
    +	 * checkpoints after a failed cancel-job-with-savepoint request.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testCancelJobWithSavepointFailure(&lt;br/&gt;
    +		boolean enablePeriodicCheckpoints) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		long checkpointInterval = enablePeriodicCheckpoints ? 3600000 : Long.MAX_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		// Savepoint target&lt;br/&gt;
    +		File savepointTarget = tmpFolder.newFolder();&lt;br/&gt;
    +		savepointTarget.deleteOnExit();&lt;br/&gt;
    +&lt;br/&gt;
    +		// Timeout for Akka messages&lt;br/&gt;
    +		FiniteDuration askTimeout = new FiniteDuration(30, TimeUnit.SECONDS);&lt;br/&gt;
    +&lt;br/&gt;
    +		// A source that declines savepoints, simulating the behaviour&lt;br/&gt;
    +		// of a failed savepoint.&lt;br/&gt;
    +		JobVertex sourceVertex = new JobVertex(&quot;Source&quot;);&lt;br/&gt;
    +		sourceVertex.setInvokableClass(FailOnSavepointStatefulTask.class);&lt;br/&gt;
    +		sourceVertex.setParallelism(1);&lt;br/&gt;
    +		JobGraph jobGraph = new JobGraph(&quot;TestingJob&quot;, sourceVertex);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ActorSystem actorSystem = AkkaUtils.createLocalActorSystem(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			Tuple2&amp;lt;ActorRef, ActorRef&amp;gt; master = JobManager.startJobManagerActors(&lt;br/&gt;
    +				new Configuration(),&lt;br/&gt;
    +				actorSystem,&lt;br/&gt;
    +				TestingUtils.defaultExecutor(),&lt;br/&gt;
    +				TestingUtils.defaultExecutor(),&lt;br/&gt;
    +				highAvailabilityServices,&lt;br/&gt;
    +				Option.apply(&quot;jm&quot;),&lt;br/&gt;
    +				Option.apply(&quot;arch&quot;),&lt;br/&gt;
    +				TestingJobManager.class,&lt;br/&gt;
    +				TestingMemoryArchivist.class);&lt;br/&gt;
    +&lt;br/&gt;
    +			UUID leaderId = LeaderRetrievalUtils.retrieveLeaderSessionId(&lt;br/&gt;
    +				highAvailabilityServices.getJobManagerLeaderRetriever(HighAvailabilityServices.DEFAULT_JOB_ID),&lt;br/&gt;
    +				TestingUtils.TESTING_TIMEOUT());&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorGateway jobManager = new AkkaActorGateway(master._1(), leaderId);&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorRef taskManagerRef = TaskManager.startTaskManagerComponentsAndActor(&lt;br/&gt;
    +				new Configuration(),&lt;br/&gt;
    +				ResourceID.generate(),&lt;br/&gt;
    +				actorSystem,&lt;br/&gt;
    +				highAvailabilityServices,&lt;br/&gt;
    +				&quot;localhost&quot;,&lt;br/&gt;
    +				Option.apply(&quot;tm&quot;),&lt;br/&gt;
    +				true,&lt;br/&gt;
    +				TestingTaskManager.class);&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorGateway taskManager = new AkkaActorGateway(taskManagerRef, leaderId);&lt;br/&gt;
    +&lt;br/&gt;
    +			// Wait until connected&lt;br/&gt;
    +			Object msg = new TestingTaskManagerMessages.NotifyWhenRegisteredAtJobManager(jobManager.actor());&lt;br/&gt;
    +			Await.ready(taskManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			JobCheckpointingSettings snapshottingSettings = new JobCheckpointingSettings(&lt;br/&gt;
    +				Collections.singletonList(sourceVertex.getID()),&lt;br/&gt;
    +				Collections.singletonList(sourceVertex.getID()),&lt;br/&gt;
    +				Collections.singletonList(sourceVertex.getID()),&lt;br/&gt;
    +				checkpointInterval,&lt;br/&gt;
    +				3600000,&lt;br/&gt;
    +				0,&lt;br/&gt;
    +				Integer.MAX_VALUE,&lt;br/&gt;
    +				ExternalizedCheckpointSettings.none(),&lt;br/&gt;
    +				null,&lt;br/&gt;
    +				true);&lt;br/&gt;
    +&lt;br/&gt;
    +			jobGraph.setSnapshotSettings(snapshottingSettings);&lt;br/&gt;
    +&lt;br/&gt;
    +			// Submit job graph&lt;br/&gt;
    +			msg = new JobManagerMessages.SubmitJob(jobGraph, ListeningBehaviour.DETACHED);&lt;br/&gt;
    +			Await.ready(jobManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			// Wait for all tasks to be running&lt;br/&gt;
    +			msg = new TestingJobManagerMessages.WaitForAllVerticesToBeRunning(jobGraph.getJobID());&lt;br/&gt;
    +			Await.ready(jobManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			// ----------------------------------------------------------------&lt;br/&gt;
    +			// Super ugly... sorry! But this is one of the few bad options&lt;br/&gt;
    +			// to test this here. Ideally, we would have a factory that we&lt;br/&gt;
    +			// can set in tests as desired. But we don&apos;t. So here we go...&lt;br/&gt;
    +			msg = new RequestExecutionGraph(jobGraph.getJobID());&lt;br/&gt;
    +			Object result = Await.result(jobManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			ExecutionGraph eg;&lt;br/&gt;
    +			if (result instanceof ExecutionGraphFound) &lt;/p&gt;
{
    +				// Sorry...
    +				eg = (ExecutionGraph) ((ExecutionGraphFound) result).executionGraph();
    +			}
&lt;p&gt; else &lt;/p&gt;
{
    +				throw new RuntimeException(&quot;Could not access ExecutionGraph for job with &quot;
    +					+ &quot;ID &quot; + jobGraph.getJobID() + &quot;. Response: &quot; + result.toString());
    +
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			Field field = eg.getClass().getDeclaredField(&quot;checkpointCoordinator&quot;);&lt;br/&gt;
    +			field.setAccessible(true);&lt;br/&gt;
    +			CheckpointCoordinator coord = (CheckpointCoordinator) field.get(eg);&lt;br/&gt;
    +			CheckpointCoordinator spiedCoord = Mockito.spy(coord);&lt;br/&gt;
    +			field.set(eg, spiedCoord);&lt;br/&gt;
    +			// ----------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +			// Cancel with savepoint&lt;br/&gt;
    +			msg = new JobManagerMessages.CancelJobWithSavepoint(jobGraph.getJobID(),&lt;br/&gt;
    +				savepointTarget.getAbsolutePath());&lt;br/&gt;
    +			CancellationResponse cancelResp = (CancellationResponse) Await.result(&lt;br/&gt;
    +				jobManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			if (cancelResp instanceof CancellationFailure) {&lt;br/&gt;
    +				if (enablePeriodicCheckpoints) {&lt;br/&gt;
    +					// Verify checkpoint scheduler deactivated and reactivated.&lt;br/&gt;
    +					// A call to start checkpoint scheduler calls stop scheduler&lt;br/&gt;
    +					// again. Therefore, we verify two calls for stop. Since we&lt;br/&gt;
    +					// spy (I know...) on the coordinator after the job has&lt;br/&gt;
    +					// started, we don&apos;t count calls before spying.&lt;br/&gt;
    +					verify(spiedCoord, times(1)).startCheckpointScheduler();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    The thing is that the stopping of the scheduler is part of the expected behaviour of cancel-with-job-savepoint, because we don&apos;t want any checkpoints between the savepoint and cancel job (&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-4717&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-4717&lt;/a&gt;). I think for that we do need the spying &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; It was simply not fully tested before... Does this make sense or am I missing your point?&lt;/p&gt;
</comment>
                            <comment id="16090415" author="githubbot" created="Mon, 17 Jul 2017 19:25:32 +0000"  >&lt;p&gt;Github user StephanEwen commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4254&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I think this is a meaningful fix.&lt;/p&gt;

&lt;p&gt;    I would suggest to do the tests different, though. The tests of the CheckpointCoordinator overdo the mockito stuff so heavily that it becomes an extremely hard job to change anything in the CheckpointCoordinator. Mocks are super maintenance heavy, compared to actual test implementations of interfaces or classes.&lt;/p&gt;</comment>
                            <comment id="16095990" author="aljoscha" created="Fri, 21 Jul 2017 09:00:31 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=uce&quot; class=&quot;user-hover&quot; rel=&quot;uce&quot;&gt;uce&lt;/a&gt; Since this seems like a good fix I&apos;d like to get it into 1.3.2. What&apos;s the status of the PR, do you think this can be done by this week? If not we should think about demoting it from &quot;blocker&quot; and releasing it with the next bug fix release.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                            <comment id="16096109" author="uce" created="Fri, 21 Jul 2017 10:25:41 +0000"  >&lt;p&gt;I agree with Stephan&apos;s opinion. That&apos;s why I also have the test as a separate commit and corresponding comments in the tests/PR description.&lt;/p&gt;

&lt;p&gt;I think for the bugfix release, we have two options:&lt;br/&gt;
1) Merge it as is including the test&lt;br/&gt;
2) Merge it without the test&lt;/p&gt;

&lt;p&gt;Option 3) would be to refactor the tests, but unfortunately I think that requires refactoring the main line code. Maybe &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; has an idea to do this or adjust the test without much overhead?&lt;/p&gt;</comment>
                            <comment id="16098090" author="aljoscha" created="Mon, 24 Jul 2017 08:46:48 +0000"  >&lt;p&gt;Moving to 1.3.3 to unblock 1.3.2. If we make it in time it can still go into 1.3.2, though.&lt;/p&gt;</comment>
                            <comment id="16209038" author="till.rohrmann" created="Wed, 18 Oct 2017 09:18:26 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=uce&quot; class=&quot;user-hover&quot; rel=&quot;uce&quot;&gt;uce&lt;/a&gt; are you still working on this issue so that it makes it into the 1.4 release?&lt;/p&gt;</comment>
                            <comment id="16210839" author="uce" created="Thu, 19 Oct 2017 10:20:10 +0000"  >&lt;p&gt;Hey Till, I think the fix is done from my side. The open question is what we do with the test:&lt;br/&gt;
1) Keep the test although it over uses Mockito (due to how we expose the CheckpointCoordinator etc.)&lt;br/&gt;
2) Remove the test&lt;br/&gt;
3) Refactor what needs to be refactored and then rewrite the test&lt;/p&gt;

&lt;p&gt;I don&apos;t have time for 3), but I am fine with both 1) or 2). What do you propose?&lt;/p&gt;</comment>
                            <comment id="16212373" author="githubbot" created="Fri, 20 Oct 2017 08:45:02 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4254#discussion_r145907824&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4254#discussion_r145907824&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java &amp;#8212;&lt;br/&gt;
    @@ -940,6 +955,177 @@ public void testCancelWithSavepoint() throws Exception {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/**&lt;br/&gt;
    +	 * Tests that a failed cancel-job-with-savepoint request does not accidentally disable&lt;br/&gt;
    +	 * periodic checkpoints.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testCancelJobWithSavepointFailurePeriodicCheckpoints() throws Exception &lt;/p&gt;
{
    +		testCancelJobWithSavepointFailure(true);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Tests that a failed cancel-job-with-savepoint request does not accidentally enable&lt;br/&gt;
    +	 * periodic checkpoints.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testCancelJobWithSavepointFailureNoPeriodicCheckpoints() throws Exception &lt;/p&gt;
{
    +		testCancelJobWithSavepointFailure(false);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Tests that a failed savepoint does not cancel the job and that there are no&lt;br/&gt;
    +	 * unintended side effects.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param enablePeriodicCheckpoints Flag to indicate whether to enable periodic checkpoints. We&lt;br/&gt;
    +	 * need to test both here in order to verify that we don&apos;t accidentally disable or enable&lt;br/&gt;
    +	 * checkpoints after a failed cancel-job-with-savepoint request.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testCancelJobWithSavepointFailure(&lt;br/&gt;
    +		boolean enablePeriodicCheckpoints) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		long checkpointInterval = enablePeriodicCheckpoints ? 3600000 : Long.MAX_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		// Savepoint target&lt;br/&gt;
    +		File savepointTarget = tmpFolder.newFolder();&lt;br/&gt;
    +		savepointTarget.deleteOnExit();&lt;br/&gt;
    +&lt;br/&gt;
    +		// Timeout for Akka messages&lt;br/&gt;
    +		FiniteDuration askTimeout = new FiniteDuration(30, TimeUnit.SECONDS);&lt;br/&gt;
    +&lt;br/&gt;
    +		// A source that declines savepoints, simulating the behaviour&lt;br/&gt;
    +		// of a failed savepoint.&lt;br/&gt;
    +		JobVertex sourceVertex = new JobVertex(&quot;Source&quot;);&lt;br/&gt;
    +		sourceVertex.setInvokableClass(FailOnSavepointStatefulTask.class);&lt;br/&gt;
    +		sourceVertex.setParallelism(1);&lt;br/&gt;
    +		JobGraph jobGraph = new JobGraph(&quot;TestingJob&quot;, sourceVertex);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ActorSystem actorSystem = AkkaUtils.createLocalActorSystem(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			Tuple2&amp;lt;ActorRef, ActorRef&amp;gt; master = JobManager.startJobManagerActors(&lt;br/&gt;
    +				new Configuration(),&lt;br/&gt;
    +				actorSystem,&lt;br/&gt;
    +				TestingUtils.defaultExecutor(),&lt;br/&gt;
    +				TestingUtils.defaultExecutor(),&lt;br/&gt;
    +				highAvailabilityServices,&lt;br/&gt;
    +				Option.apply(&quot;jm&quot;),&lt;br/&gt;
    +				Option.apply(&quot;arch&quot;),&lt;br/&gt;
    +				TestingJobManager.class,&lt;br/&gt;
    +				TestingMemoryArchivist.class);&lt;br/&gt;
    +&lt;br/&gt;
    +			UUID leaderId = LeaderRetrievalUtils.retrieveLeaderSessionId(&lt;br/&gt;
    +				highAvailabilityServices.getJobManagerLeaderRetriever(HighAvailabilityServices.DEFAULT_JOB_ID),&lt;br/&gt;
    +				TestingUtils.TESTING_TIMEOUT());&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorGateway jobManager = new AkkaActorGateway(master._1(), leaderId);&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorRef taskManagerRef = TaskManager.startTaskManagerComponentsAndActor(&lt;br/&gt;
    +				new Configuration(),&lt;br/&gt;
    +				ResourceID.generate(),&lt;br/&gt;
    +				actorSystem,&lt;br/&gt;
    +				highAvailabilityServices,&lt;br/&gt;
    +				&quot;localhost&quot;,&lt;br/&gt;
    +				Option.apply(&quot;tm&quot;),&lt;br/&gt;
    +				true,&lt;br/&gt;
    +				TestingTaskManager.class);&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorGateway taskManager = new AkkaActorGateway(taskManagerRef, leaderId);&lt;br/&gt;
    +&lt;br/&gt;
    +			// Wait until connected&lt;br/&gt;
    +			Object msg = new TestingTaskManagerMessages.NotifyWhenRegisteredAtJobManager(jobManager.actor());&lt;br/&gt;
    +			Await.ready(taskManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			JobCheckpointingSettings snapshottingSettings = new JobCheckpointingSettings(&lt;br/&gt;
    +				Collections.singletonList(sourceVertex.getID()),&lt;br/&gt;
    +				Collections.singletonList(sourceVertex.getID()),&lt;br/&gt;
    +				Collections.singletonList(sourceVertex.getID()),&lt;br/&gt;
    +				checkpointInterval,&lt;br/&gt;
    +				3600000,&lt;br/&gt;
    +				0,&lt;br/&gt;
    +				Integer.MAX_VALUE,&lt;br/&gt;
    +				ExternalizedCheckpointSettings.none(),&lt;br/&gt;
    +				null,&lt;br/&gt;
    +				true);&lt;br/&gt;
    +&lt;br/&gt;
    +			jobGraph.setSnapshotSettings(snapshottingSettings);&lt;br/&gt;
    +&lt;br/&gt;
    +			// Submit job graph&lt;br/&gt;
    +			msg = new JobManagerMessages.SubmitJob(jobGraph, ListeningBehaviour.DETACHED);&lt;br/&gt;
    +			Await.ready(jobManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			// Wait for all tasks to be running&lt;br/&gt;
    +			msg = new TestingJobManagerMessages.WaitForAllVerticesToBeRunning(jobGraph.getJobID());&lt;br/&gt;
    +			Await.ready(jobManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			// ----------------------------------------------------------------&lt;br/&gt;
    +			// Super ugly... sorry! But this is one of the few bad options&lt;br/&gt;
    +			// to test this here. Ideally, we would have a factory that we&lt;br/&gt;
    +			// can set in tests as desired. But we don&apos;t. So here we go...&lt;br/&gt;
    +			msg = new RequestExecutionGraph(jobGraph.getJobID());&lt;br/&gt;
    +			Object result = Await.result(jobManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			ExecutionGraph eg;&lt;br/&gt;
    +			if (result instanceof ExecutionGraphFound) &lt;/p&gt;
{
    +				// Sorry...
    +				eg = (ExecutionGraph) ((ExecutionGraphFound) result).executionGraph();
    +			}
&lt;p&gt; else &lt;/p&gt;
{
    +				throw new RuntimeException(&quot;Could not access ExecutionGraph for job with &quot;
    +					+ &quot;ID &quot; + jobGraph.getJobID() + &quot;. Response: &quot; + result.toString());
    +
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			Field field = eg.getClass().getDeclaredField(&quot;checkpointCoordinator&quot;);&lt;br/&gt;
    +			field.setAccessible(true);&lt;br/&gt;
    +			CheckpointCoordinator coord = (CheckpointCoordinator) field.get(eg);&lt;br/&gt;
    +			CheckpointCoordinator spiedCoord = Mockito.spy(coord);&lt;br/&gt;
    +			field.set(eg, spiedCoord);&lt;br/&gt;
    +			// ----------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +			// Cancel with savepoint&lt;br/&gt;
    +			msg = new JobManagerMessages.CancelJobWithSavepoint(jobGraph.getJobID(),&lt;br/&gt;
    +				savepointTarget.getAbsolutePath());&lt;br/&gt;
    +			CancellationResponse cancelResp = (CancellationResponse) Await.result(&lt;br/&gt;
    +				jobManager.ask(msg, askTimeout), askTimeout);&lt;br/&gt;
    +&lt;br/&gt;
    +			if (cancelResp instanceof CancellationFailure) {&lt;br/&gt;
    +				if (enablePeriodicCheckpoints) {&lt;br/&gt;
    +					// Verify checkpoint scheduler deactivated and reactivated.&lt;br/&gt;
    +					// A call to start checkpoint scheduler calls stop scheduler&lt;br/&gt;
    +					// again. Therefore, we verify two calls for stop. Since we&lt;br/&gt;
    +					// spy (I know...) on the coordinator after the job has&lt;br/&gt;
    +					// started, we don&apos;t count calls before spying.&lt;br/&gt;
    +					verify(spiedCoord, times(1)).startCheckpointScheduler();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Can&apos;t we check that the submitted tasks sees another checkpoint barrier after a savepoint has been triggered? That way we would get around spying on the `CheckpointCoordinator`.&lt;/p&gt;</comment>
                            <comment id="16212374" author="githubbot" created="Fri, 20 Oct 2017 08:45:02 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4254#discussion_r145907545&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4254#discussion_r145907545&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java &amp;#8212;&lt;br/&gt;
    @@ -940,6 +955,177 @@ public void testCancelWithSavepoint() throws Exception {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/**&lt;br/&gt;
    +	 * Tests that a failed cancel-job-with-savepoint request does not accidentally disable&lt;br/&gt;
    +	 * periodic checkpoints.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testCancelJobWithSavepointFailurePeriodicCheckpoints() throws Exception &lt;/p&gt;
{
    +		testCancelJobWithSavepointFailure(true);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Tests that a failed cancel-job-with-savepoint request does not accidentally enable&lt;br/&gt;
    +	 * periodic checkpoints.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testCancelJobWithSavepointFailureNoPeriodicCheckpoints() throws Exception &lt;/p&gt;
{
    +		testCancelJobWithSavepointFailure(false);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Tests that a failed savepoint does not cancel the job and that there are no&lt;br/&gt;
    +	 * unintended side effects.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param enablePeriodicCheckpoints Flag to indicate whether to enable periodic checkpoints. We&lt;br/&gt;
    +	 * need to test both here in order to verify that we don&apos;t accidentally disable or enable&lt;br/&gt;
    +	 * checkpoints after a failed cancel-job-with-savepoint request.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testCancelJobWithSavepointFailure(&lt;br/&gt;
    +		boolean enablePeriodicCheckpoints) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		long checkpointInterval = enablePeriodicCheckpoints ? 3600000 : Long.MAX_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		// Savepoint target&lt;br/&gt;
    +		File savepointTarget = tmpFolder.newFolder();&lt;br/&gt;
    +		savepointTarget.deleteOnExit();&lt;br/&gt;
    +&lt;br/&gt;
    +		// Timeout for Akka messages&lt;br/&gt;
    +		FiniteDuration askTimeout = new FiniteDuration(30, TimeUnit.SECONDS);&lt;br/&gt;
    +&lt;br/&gt;
    +		// A source that declines savepoints, simulating the behaviour&lt;br/&gt;
    +		// of a failed savepoint.&lt;br/&gt;
    +		JobVertex sourceVertex = new JobVertex(&quot;Source&quot;);&lt;br/&gt;
    +		sourceVertex.setInvokableClass(FailOnSavepointStatefulTask.class);&lt;br/&gt;
    +		sourceVertex.setParallelism(1);&lt;br/&gt;
    +		JobGraph jobGraph = new JobGraph(&quot;TestingJob&quot;, sourceVertex);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ActorSystem actorSystem = AkkaUtils.createLocalActorSystem(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			Tuple2&amp;lt;ActorRef, ActorRef&amp;gt; master = JobManager.startJobManagerActors(&lt;br/&gt;
    +				new Configuration(),&lt;br/&gt;
    +				actorSystem,&lt;br/&gt;
    +				TestingUtils.defaultExecutor(),&lt;br/&gt;
    +				TestingUtils.defaultExecutor(),&lt;br/&gt;
    +				highAvailabilityServices,&lt;br/&gt;
    +				Option.apply(&quot;jm&quot;),&lt;br/&gt;
    +				Option.apply(&quot;arch&quot;),&lt;br/&gt;
    +				TestingJobManager.class,&lt;br/&gt;
    +				TestingMemoryArchivist.class);&lt;br/&gt;
    +&lt;br/&gt;
    +			UUID leaderId = LeaderRetrievalUtils.retrieveLeaderSessionId(&lt;br/&gt;
    +				highAvailabilityServices.getJobManagerLeaderRetriever(HighAvailabilityServices.DEFAULT_JOB_ID),&lt;br/&gt;
    +				TestingUtils.TESTING_TIMEOUT());&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorGateway jobManager = new AkkaActorGateway(master._1(), leaderId);&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorRef taskManagerRef = TaskManager.startTaskManagerComponentsAndActor(&lt;br/&gt;
    +				new Configuration(),&lt;br/&gt;
    +				ResourceID.generate(),&lt;br/&gt;
    +				actorSystem,&lt;br/&gt;
    +				highAvailabilityServices,&lt;br/&gt;
    +				&quot;localhost&quot;,&lt;br/&gt;
    +				Option.apply(&quot;tm&quot;),&lt;br/&gt;
    +				true,&lt;br/&gt;
    +				TestingTaskManager.class);&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorGateway taskManager = new AkkaActorGateway(taskManagerRef, leaderId);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Can&apos;t we simply use a `TestingCluster` here for all the setup work?&lt;/p&gt;</comment>
                            <comment id="16212376" author="till.rohrmann" created="Fri, 20 Oct 2017 08:47:21 +0000"  >&lt;p&gt;I actually would like to go with &lt;/p&gt;

&lt;p&gt;4) relax the test a bit by checking whether we see a checkpoint barrier after seeing a savepoint barrier in the submitted task.&lt;/p&gt;

&lt;p&gt;I think this should be fairly little work and I would really like to include this fix in the upcoming release. What do you think?&lt;/p&gt;</comment>
                            <comment id="16212449" author="githubbot" created="Fri, 20 Oct 2017 09:59:13 +0000"  >&lt;p&gt;Github user uce commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4254#discussion_r145923787&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4254#discussion_r145923787&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/JobManagerTest.java &amp;#8212;&lt;br/&gt;
    @@ -940,6 +955,177 @@ public void testCancelWithSavepoint() throws Exception {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/**&lt;br/&gt;
    +	 * Tests that a failed cancel-job-with-savepoint request does not accidentally disable&lt;br/&gt;
    +	 * periodic checkpoints.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testCancelJobWithSavepointFailurePeriodicCheckpoints() throws Exception &lt;/p&gt;
{
    +		testCancelJobWithSavepointFailure(true);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Tests that a failed cancel-job-with-savepoint request does not accidentally enable&lt;br/&gt;
    +	 * periodic checkpoints.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testCancelJobWithSavepointFailureNoPeriodicCheckpoints() throws Exception &lt;/p&gt;
{
    +		testCancelJobWithSavepointFailure(false);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Tests that a failed savepoint does not cancel the job and that there are no&lt;br/&gt;
    +	 * unintended side effects.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param enablePeriodicCheckpoints Flag to indicate whether to enable periodic checkpoints. We&lt;br/&gt;
    +	 * need to test both here in order to verify that we don&apos;t accidentally disable or enable&lt;br/&gt;
    +	 * checkpoints after a failed cancel-job-with-savepoint request.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testCancelJobWithSavepointFailure(&lt;br/&gt;
    +		boolean enablePeriodicCheckpoints) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		long checkpointInterval = enablePeriodicCheckpoints ? 3600000 : Long.MAX_VALUE;&lt;br/&gt;
    +&lt;br/&gt;
    +		// Savepoint target&lt;br/&gt;
    +		File savepointTarget = tmpFolder.newFolder();&lt;br/&gt;
    +		savepointTarget.deleteOnExit();&lt;br/&gt;
    +&lt;br/&gt;
    +		// Timeout for Akka messages&lt;br/&gt;
    +		FiniteDuration askTimeout = new FiniteDuration(30, TimeUnit.SECONDS);&lt;br/&gt;
    +&lt;br/&gt;
    +		// A source that declines savepoints, simulating the behaviour&lt;br/&gt;
    +		// of a failed savepoint.&lt;br/&gt;
    +		JobVertex sourceVertex = new JobVertex(&quot;Source&quot;);&lt;br/&gt;
    +		sourceVertex.setInvokableClass(FailOnSavepointStatefulTask.class);&lt;br/&gt;
    +		sourceVertex.setParallelism(1);&lt;br/&gt;
    +		JobGraph jobGraph = new JobGraph(&quot;TestingJob&quot;, sourceVertex);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ActorSystem actorSystem = AkkaUtils.createLocalActorSystem(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			Tuple2&amp;lt;ActorRef, ActorRef&amp;gt; master = JobManager.startJobManagerActors(&lt;br/&gt;
    +				new Configuration(),&lt;br/&gt;
    +				actorSystem,&lt;br/&gt;
    +				TestingUtils.defaultExecutor(),&lt;br/&gt;
    +				TestingUtils.defaultExecutor(),&lt;br/&gt;
    +				highAvailabilityServices,&lt;br/&gt;
    +				Option.apply(&quot;jm&quot;),&lt;br/&gt;
    +				Option.apply(&quot;arch&quot;),&lt;br/&gt;
    +				TestingJobManager.class,&lt;br/&gt;
    +				TestingMemoryArchivist.class);&lt;br/&gt;
    +&lt;br/&gt;
    +			UUID leaderId = LeaderRetrievalUtils.retrieveLeaderSessionId(&lt;br/&gt;
    +				highAvailabilityServices.getJobManagerLeaderRetriever(HighAvailabilityServices.DEFAULT_JOB_ID),&lt;br/&gt;
    +				TestingUtils.TESTING_TIMEOUT());&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorGateway jobManager = new AkkaActorGateway(master._1(), leaderId);&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorRef taskManagerRef = TaskManager.startTaskManagerComponentsAndActor(&lt;br/&gt;
    +				new Configuration(),&lt;br/&gt;
    +				ResourceID.generate(),&lt;br/&gt;
    +				actorSystem,&lt;br/&gt;
    +				highAvailabilityServices,&lt;br/&gt;
    +				&quot;localhost&quot;,&lt;br/&gt;
    +				Option.apply(&quot;tm&quot;),&lt;br/&gt;
    +				true,&lt;br/&gt;
    +				TestingTaskManager.class);&lt;br/&gt;
    +&lt;br/&gt;
    +			ActorGateway taskManager = new AkkaActorGateway(taskManagerRef, leaderId);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Definitely +1&lt;/p&gt;</comment>
                            <comment id="16212463" author="githubbot" created="Fri, 20 Oct 2017 10:11:21 +0000"  >&lt;p&gt;Github user uce commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4254&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @tillrohrmann Thanks for looking over this. The `TestingCluster` is definitely preferable. I don&apos;t recall how I ended up with the custom setup instead of the `TestingCluster`.&lt;/p&gt;

&lt;p&gt;    I changed the test to wait for another checkpoint after the failed savepoint. I also considered this for the initial PR, but went with mocking in order to test the case that periodic checkpoints were not activated before the cancellation &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;. I think the current variant is a good compromise between completeness and simplicity though.&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; As seen in the diff of `JobManager.scala`, we only activate the periodic scheduler after a failed cancellation iff it was activated before cancellation. This case can&apos;t be tested robustly with the current approach. We could wait for some time and if no checkpoint arrives in that time consider checkpoints as not accidentally activated, but that&apos;s not robust. I would therefore ignore this case if you don&apos;t have another idea.&lt;/p&gt;
</comment>
                            <comment id="16212530" author="githubbot" created="Fri, 20 Oct 2017 12:07:34 +0000"  >&lt;p&gt;Github user tillrohrmann commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4254&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I think it&apos;s alright that way.&lt;/p&gt;</comment>
                            <comment id="16212593" author="githubbot" created="Fri, 20 Oct 2017 12:41:47 +0000"  >&lt;p&gt;Github user uce commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4254&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Cool! I&apos;ll rebase this and merge after Travis gives the green light.&lt;/p&gt;</comment>
                            <comment id="16215050" author="githubbot" created="Mon, 23 Oct 2017 12:33:31 +0000"  >&lt;p&gt;Github user uce commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4254&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Travis gave the green light, merging this now.&lt;/p&gt;</comment>
                            <comment id="16215054" author="githubbot" created="Mon, 23 Oct 2017 12:35:58 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4254&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16215075" author="githubbot" created="Mon, 23 Oct 2017 12:45:12 +0000"  >&lt;p&gt;GitHub user uce opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4888&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4888&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;backport&amp;#93;&lt;/span&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7067&quot; title=&quot;Cancel with savepoint does not restart checkpoint scheduler on failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7067&quot;&gt;&lt;del&gt;FLINK-7067&lt;/del&gt;&lt;/a&gt; Resume checkpointing after failed cancel-job-with-savepoint&lt;/p&gt;

&lt;p&gt;    This is a backport of #4254. I will merge this as soon as Travis gives the green light.&lt;/p&gt;


&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/uce/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/uce/flink&lt;/a&gt; 7067-backport&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4888.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4888.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4888&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 9226c3a15f8037851110fbdecf775cad99da771f&lt;br/&gt;
Author: Ufuk Celebi &amp;lt;uce@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-07-04T14:39:02Z&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;hotfix&amp;#93;&lt;/span&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;tests&amp;#93;&lt;/span&gt; Reduce visibility of helper class methods&lt;/p&gt;

&lt;p&gt;    There is no need to make the helper methods public. No other class&lt;br/&gt;
    should even use this inner test helper invokable.&lt;/p&gt;

&lt;p&gt;commit c571929ce476f17d02ee22df0b5170b0eb322c2d&lt;br/&gt;
Author: Ufuk Celebi &amp;lt;uce@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-07-04T15:01:32Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7067&quot; title=&quot;Cancel with savepoint does not restart checkpoint scheduler on failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7067&quot;&gt;&lt;del&gt;FLINK-7067&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;jobmanager&amp;#93;&lt;/span&gt; Resume periodic checkpoints after failed cancel-job-with-savepoint&lt;/p&gt;

&lt;p&gt;    Problem: If a cancel-job-with-savepoint request fails, this has an&lt;br/&gt;
    unintended side effect on the respective job if it has periodic&lt;br/&gt;
    checkpoints enabled. The periodic checkpoint scheduler is stopped&lt;br/&gt;
    before triggering the savepoint, but not restarted if a savepoint&lt;br/&gt;
    fails and the job is not cancelled.&lt;/p&gt;

&lt;p&gt;    This commit makes sure that the periodic checkpoint scheduler is&lt;br/&gt;
    restarted iff periodic checkpoints were enabled before.&lt;/p&gt;

&lt;p&gt;    This closes #4254.&lt;/p&gt;

&lt;p&gt;commit 074630a2fbd6dbdc7ff775ee9fb5d46c088dbc6d&lt;br/&gt;
Author: Ufuk Celebi &amp;lt;uce@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-10-23T12:42:46Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7067&quot; title=&quot;Cancel with savepoint does not restart checkpoint scheduler on failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7067&quot;&gt;&lt;del&gt;FLINK-7067&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;jobmanager&amp;#93;&lt;/span&gt; Backport to 1.3&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16215357" author="githubbot" created="Mon, 23 Oct 2017 16:10:08 +0000"  >&lt;p&gt;Github user uce commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4888&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4888&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @aljoscha Getting the following message in two of the builds in &lt;a href=&quot;https://travis-ci.org/apache/flink/builds/291523047:&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://travis-ci.org/apache/flink/builds/291523047:&lt;/a&gt;&lt;br/&gt;
    ```&lt;br/&gt;
    ==============================================================================&lt;br/&gt;
    Compilation/test failure detected, skipping shaded dependency check.&lt;br/&gt;
    ==============================================================================&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    Ever seen this?&lt;/p&gt;</comment>
                            <comment id="16216512" author="githubbot" created="Tue, 24 Oct 2017 08:22:01 +0000"  >&lt;p&gt;Github user uce commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4888&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4888&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    All failed tests are due to a similar issue that seems not to be related to the tests. Merging...&lt;/p&gt;</comment>
                            <comment id="16216514" author="uce" created="Tue, 24 Oct 2017 08:23:51 +0000"  >&lt;p&gt;Fixed in e8e2913 (release-1.3), e49bc42 (master).&lt;/p&gt;</comment>
                            <comment id="16216515" author="githubbot" created="Tue, 24 Oct 2017 08:24:11 +0000"  >&lt;p&gt;Github user uce closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4888&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4888&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16216516" author="githubbot" created="Tue, 24 Oct 2017 08:24:43 +0000"  >&lt;p&gt;Github user uce commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4888&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4888&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Merged in e8e2913.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 4 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3h0yn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>