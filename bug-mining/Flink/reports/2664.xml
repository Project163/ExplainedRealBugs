<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:35:23 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-9788] ExecutionGraph Inconsistency prevents Job from recovering</title>
                <link>https://issues.apache.org/jira/browse/FLINK-9788</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;Deployment mode: YARN job mode with HA&lt;/p&gt;

&lt;p&gt;After killing many TaskManagers in succession, the state of the ExecutionGraph ran into an inconsistent state, which prevented job recovery. The following stacktrace was logged in the JobManager log several hundred times per second:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;-08 16:47:18,855 INFO  org.apache.flink.runtime.executiongraph.ExecutionGraph        - Job General purpose test job (37a794195840700b98feb23e99f7ea24) switched from state RESTARTING to RESTARTING.
2018-07-08 16:47:18,856 INFO  org.apache.flink.runtime.executiongraph.ExecutionGraph        - Restarting the job General purpose test job (37a794195840700b98feb23e99f7ea24).
2018-07-08 16:47:18,857 DEBUG org.apache.flink.runtime.executiongraph.ExecutionGraph        - Resetting execution vertex Source: Custom Source -&amp;gt; Timestamps/Watermarks (1/10) for new execution.
2018-07-08 16:47:18,857 WARN  org.apache.flink.runtime.executiongraph.ExecutionGraph        - Failed to restart the job.
java.lang.IllegalStateException: Cannot reset a vertex that is in non-terminal state CREATED
        at org.apache.flink.runtime.executiongraph.ExecutionVertex.resetForNewExecution(ExecutionVertex.java:610)
        at org.apache.flink.runtime.executiongraph.ExecutionJobVertex.resetForNewExecution(ExecutionJobVertex.java:573)
        at org.apache.flink.runtime.executiongraph.ExecutionGraph.restart(ExecutionGraph.java:1251)
        at org.apache.flink.runtime.executiongraph.restart.ExecutionGraphRestartCallback.triggerFullRecovery(ExecutionGraphRestartCallback.java:59)
        at org.apache.flink.runtime.executiongraph.restart.FixedDelayRestartStrategy$1.run(FixedDelayRestartStrategy.java:68)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The resulting jobmanager log file was 4.7 GB in size. Find attached the first 5000 lines of the log file. &lt;/p&gt;</description>
                <environment>&lt;p&gt;Rev: 4a06160&lt;br/&gt;
Hadoop 2.8.3&lt;/p&gt;</environment>
        <key id="13171109">FLINK-9788</key>
            <summary>ExecutionGraph Inconsistency prevents Job from recovering</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="trohrmann">Till Rohrmann</assignee>
                                    <reporter username="gjy">Gary Yao</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Tue, 10 Jul 2018 10:27:39 +0000</created>
                <updated>Thu, 28 Feb 2019 13:20:32 +0000</updated>
                            <resolved>Thu, 11 Oct 2018 15:01:40 +0000</resolved>
                                    <version>1.6.0</version>
                                    <fixVersion>1.5.5</fixVersion>
                    <fixVersion>1.6.2</fixVersion>
                    <fixVersion>1.7.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="16642744" author="sleepy" created="Tue, 9 Oct 2018 03:28:02 +0000"  >&lt;p&gt;After checking the log file, I believe this is a critical bug. If the scenario happens below, the job would never recover as the log shows.&lt;br/&gt;
1. A failover happens due to lost of TM, ExecutionGraph tries to restart itself&lt;br/&gt;
2. The restarter(1) is in ExecutionGraph.restart(), resetting all executions&lt;br/&gt;
3. Another fatal error happens, it triggers ExecutionGraph.failGlobal, the state of ExecutionGraph is RESTARTING, it would increase the global version and try to restart ExecutionGraph too&lt;br/&gt;
4. The restarter(1) would fail, due to the global version is mismatched, some executions are resetted to CREATED, some executions are not&lt;br/&gt;
5. As the restarter(1) is failed, it would trigger another failGlobal without changing the state of ExecutionGraph (RESTARTING)&lt;br/&gt;
6. Some executions resetted in step 4 would fail forever in restarting&lt;/p&gt;

&lt;p&gt;I believe the problem is that the state RESTARTING of ExecutionGraph is not a safe state that we can do the restarting without any cancelation. Maybe we should do a cancelation while the state is RESTARTING. &lt;/p&gt;</comment>
                            <comment id="16642919" author="till.rohrmann" created="Tue, 9 Oct 2018 07:49:31 +0000"  >&lt;p&gt;Arg, this sounds quite bad. Thanks a lot for diagnosing the problem &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=SleePy&quot; class=&quot;user-hover&quot; rel=&quot;SleePy&quot;&gt;SleePy&lt;/a&gt;. We should definitely fix this problem for 1.7. I&apos;ll mark it as a blocker.&lt;/p&gt;

&lt;p&gt;I could think of two high level solutions here:&lt;br/&gt;
1. Ignore failures if one is in state RESTARTING because it must originate from the previous run. Here we need to check whether &lt;tt&gt;failGlobal&lt;/tt&gt; is really only called by a running &lt;tt&gt;ExecutionGraph&lt;/tt&gt;&lt;br/&gt;
2. Cancel the subsumed restarting operation such that eventually the latest restarting operation will succeed.&lt;/p&gt;</comment>
                            <comment id="16642938" author="till.rohrmann" created="Tue, 9 Oct 2018 08:12:18 +0000"  >&lt;p&gt;Looking at the code, I think the problem is that we don&apos;t cancel the newly created/reset &lt;tt&gt;Executions&lt;/tt&gt;. &lt;tt&gt;ExecutionVertex:579&lt;/tt&gt; would then always fail when trying to be reset. The problem seems to originate in the &lt;tt&gt;ExecutionGraph#failGlobal&lt;/tt&gt; method where we don&apos;t cancel &lt;tt&gt;Executions&lt;/tt&gt; if the &lt;tt&gt;ExecutionGraph&lt;/tt&gt; is in state &lt;tt&gt;RESTARTING&lt;/tt&gt;. I think we could solve the problem by allowing the state transition &lt;tt&gt;RESTARTING --&amp;gt; FAILING&lt;/tt&gt; by simply removing the &lt;tt&gt;RESTARTING&lt;/tt&gt; branch in &lt;tt&gt;#failGlobal&lt;/tt&gt;. That way, we would also cancel all newly created &lt;tt&gt;Executions&lt;/tt&gt; before trying to restart.&lt;/p&gt;</comment>
                            <comment id="16642989" author="sleepy" created="Tue, 9 Oct 2018 08:50:54 +0000"  >&lt;p&gt;+1&lt;br/&gt;
I think &apos;allowing the state transition RESTARTING --&amp;gt; FAILING&apos; works.&lt;br/&gt;
Nice and simple way to solve this.&lt;/p&gt;</comment>
                            <comment id="16643253" author="githubbot" created="Tue, 9 Oct 2018 12:27:03 +0000"  >&lt;p&gt;tillrohrmann opened a new pull request #6810: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9788&quot; title=&quot;ExecutionGraph Inconsistency prevents Job from recovering&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9788&quot;&gt;&lt;del&gt;FLINK-9788&lt;/del&gt;&lt;/a&gt; Fix ExecutionGraph inconsistency for global failures when restarting&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6810&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6810&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   The problem was that a concurrent global failure could start a concurrent&lt;br/&gt;
   restart operation without terminating the previous operation. Terminating&lt;br/&gt;
   the previous restart operation means to cancel all current Executions and&lt;br/&gt;
   wait for cancellation completion. Due to the missing wait, it could happen&lt;br/&gt;
   that previously reset Executions are being tried to reset again. This violates&lt;br/&gt;
   a sanity check and would lead to a restart loop.&lt;/p&gt;

&lt;p&gt;   The problem is fixed by not distinguishing between a fail which happens in&lt;br/&gt;
   state JobStatus.RESTARTING and in any other state. Due to this, we will always&lt;br/&gt;
   cancel all existing Executions and only trigger the restart after all Executions&lt;br/&gt;
   have reached a terminal state.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Remove `RESTARTING` branch from `ExecutionGraph#failGlobal`&lt;/li&gt;
	&lt;li&gt;Use `expectedGlobalVersion` when resetting `Executions` in `ExecutionGraph#restart`&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added `ExecutionGraphRestartTest#testConcurrentFailureWhileRestarting`&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (no)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (no)&lt;/li&gt;
	&lt;li&gt;The serializers: (no)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (no)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (*&lt;b&gt;yes&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: (no)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (no)&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? (not applicable)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16643257" author="githubbot" created="Tue, 9 Oct 2018 12:28:58 +0000"  >&lt;p&gt;tillrohrmann opened a new pull request #6811: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9788&quot; title=&quot;ExecutionGraph Inconsistency prevents Job from recovering&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9788&quot;&gt;&lt;del&gt;FLINK-9788&lt;/del&gt;&lt;/a&gt; Fix ExecutionGraph inconsistency for global failures when restarting&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6811&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6811&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Backport of #6810 for `release-1.6`.&lt;/p&gt;


&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16643564" author="githubbot" created="Tue, 9 Oct 2018 14:53:06 +0000"  >&lt;p&gt;ifndef-SleePy commented on issue #6810: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9788&quot; title=&quot;ExecutionGraph Inconsistency prevents Job from recovering&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9788&quot;&gt;&lt;del&gt;FLINK-9788&lt;/del&gt;&lt;/a&gt; Fix ExecutionGraph inconsistency for global failures when restarting&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6810#issuecomment-428224140&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6810#issuecomment-428224140&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   +1 LGTM, nice testing!&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16646450" author="githubbot" created="Thu, 11 Oct 2018 13:55:43 +0000"  >&lt;p&gt;StefanRRichter commented on issue #6810: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9788&quot; title=&quot;ExecutionGraph Inconsistency prevents Job from recovering&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9788&quot;&gt;&lt;del&gt;FLINK-9788&lt;/del&gt;&lt;/a&gt; Fix ExecutionGraph inconsistency for global failures when restarting&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6810#issuecomment-428964847&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6810#issuecomment-428964847&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   LGTM &#128077; &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16646547" author="githubbot" created="Thu, 11 Oct 2018 14:57:14 +0000"  >&lt;p&gt;tillrohrmann commented on issue #6810: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9788&quot; title=&quot;ExecutionGraph Inconsistency prevents Job from recovering&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9788&quot;&gt;&lt;del&gt;FLINK-9788&lt;/del&gt;&lt;/a&gt; Fix ExecutionGraph inconsistency for global failures when restarting&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6810#issuecomment-428987592&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6810#issuecomment-428987592&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Thanks for the review @ifndef-SleePy and @StefanRRichter. Merging this PR.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16646551" author="githubbot" created="Thu, 11 Oct 2018 14:59:19 +0000"  >&lt;p&gt;tillrohrmann closed pull request #6810: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9788&quot; title=&quot;ExecutionGraph Inconsistency prevents Job from recovering&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9788&quot;&gt;&lt;del&gt;FLINK-9788&lt;/del&gt;&lt;/a&gt; Fix ExecutionGraph inconsistency for global failures when restarting&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6810&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6810&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java&lt;br/&gt;
index acb1e16fe71..0be1ff27420 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java&lt;br/&gt;
@@ -1151,18 +1151,7 @@ public void failGlobal(Throwable t) {&lt;br/&gt;
 				current == JobStatus.SUSPENDED ||&lt;br/&gt;
 				current.isGloballyTerminalState()) &lt;/p&gt;
{
 				return;
-			}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;else if (current == JobStatus.RESTARTING) {&lt;/li&gt;
	&lt;li&gt;// we handle &apos;failGlobal()&apos; while in &apos;RESTARTING&apos; as a safety net in case something&lt;/li&gt;
	&lt;li&gt;// has gone wrong in &apos;RESTARTING&apos; and we need to re-attempt the restarts&lt;/li&gt;
	&lt;li&gt;initFailureCause(t);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final long globalVersionForRestart = incrementGlobalModVersion();&lt;/li&gt;
	&lt;li&gt;if (tryRestartOrFail(globalVersionForRestart)) 
{
-					return;
-				}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;else if (transitionState(current, JobStatus.FAILING, t)) 
{
+			}
&lt;p&gt; else if (transitionState(current, JobStatus.FAILING, t)) {&lt;br/&gt;
 				initFailureCause(t);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 				// make sure no concurrent local or global actions interfere with the failover&lt;br/&gt;
@@ -1240,7 +1229,7 @@ public void restart(long expectedGlobalVersion) &lt;/p&gt;
{
 						colGroups.add(cgroup);
 					}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;jv.resetForNewExecution(resetTimestamp, globalModVersion);&lt;br/&gt;
+					jv.resetForNewExecution(resetTimestamp, expectedGlobalVersion);&lt;br/&gt;
 				}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 				for (int i = 0; i &amp;lt; stateTimestamps.length; i++) {&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java&lt;br/&gt;
index 9b98de78143..91510d1af54 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java&lt;br/&gt;
@@ -25,6 +25,7 @@&lt;br/&gt;
 import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
 import org.apache.flink.core.testutils.OneShotLatch;&lt;br/&gt;
+import org.apache.flink.runtime.JobException;&lt;br/&gt;
 import org.apache.flink.runtime.akka.AkkaUtils;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.ScheduledExecutor;&lt;br/&gt;
@@ -57,12 +58,15 @@&lt;br/&gt;
 import org.apache.flink.runtime.testingUtils.TestingUtils;&lt;br/&gt;
 import org.apache.flink.runtime.testtasks.NoOpInvokable;&lt;br/&gt;
 import org.apache.flink.util.ExceptionUtils;&lt;br/&gt;
+import org.apache.flink.util.FlinkException;&lt;br/&gt;
 import org.apache.flink.util.SerializedValue;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;/p&gt;

&lt;p&gt; import org.junit.After;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+import javax.annotation.Nonnull;&lt;br/&gt;
+&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.net.InetAddress;&lt;br/&gt;
 import java.util.Iterator;&lt;br/&gt;
@@ -86,15 +90,20 @@&lt;br/&gt;
 import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.finishAllVertices;&lt;br/&gt;
 import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.switchToRunning;&lt;br/&gt;
 import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.waitUntilJobStatus;&lt;br/&gt;
+import static org.hamcrest.Matchers.is;&lt;br/&gt;
 import static org.junit.Assert.assertEquals;&lt;br/&gt;
+import static org.junit.Assert.assertNotEquals;&lt;br/&gt;
 import static org.junit.Assert.assertNotNull;&lt;br/&gt;
+import static org.junit.Assert.assertThat;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;br/&gt;
 import static org.junit.Assert.fail;&lt;br/&gt;
-import static org.mockito.Mockito.spy;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * Tests the restart behaviour of the &lt;/p&gt;
{@link ExecutionGraph}.&lt;br/&gt;
+ */&lt;br/&gt;
 public class ExecutionGraphRestartTest extends TestLogger {&lt;br/&gt;
 &lt;br/&gt;
-	private final static int NUM_TASKS = 31;&lt;br/&gt;
+	private static final int NUM_TASKS = 31;&lt;br/&gt;
 &lt;br/&gt;
 	private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(4);&lt;br/&gt;
 &lt;br/&gt;
@@ -113,9 +122,7 @@ public void testNoManualRestart() throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 		eg.getAllExecutionVertices().iterator().next().fail(new Exception(&quot;Test Exception&quot;));&lt;br/&gt;
 &lt;br/&gt;
-		for (ExecutionVertex vertex : eg.getAllExecutionVertices()) {
-			vertex.getCurrentExecutionAttempt().cancelingComplete();
-		}&lt;br/&gt;
+		completeCanceling(eg);&lt;br/&gt;
 &lt;br/&gt;
 		assertEquals(JobStatus.FAILED, eg.getState());&lt;br/&gt;
 &lt;br/&gt;
@@ -125,9 +132,19 @@ public void testNoManualRestart() throws Exception {
 		assertEquals(JobStatus.FAILED, eg.getState());
 	}&lt;br/&gt;
 &lt;br/&gt;
+	private void completeCanceling(ExecutionGraph eg) {
+		executeOperationForAllExecutions(eg, Execution::cancelingComplete);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private void executeOperationForAllExecutions(ExecutionGraph eg, Consumer&amp;lt;Execution&amp;gt; operation) {&lt;br/&gt;
+		for (ExecutionVertex vertex : eg.getAllExecutionVertices()) {
+			operation.accept(vertex.getCurrentExecutionAttempt());
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testRestartAutomatically() throws Exception {&lt;br/&gt;
-		RestartStrategy restartStrategy = new FixedDelayRestartStrategy(1, 1000);&lt;br/&gt;
+		RestartStrategy restartStrategy = new FixedDelayRestartStrategy(1, 0L);&lt;br/&gt;
 		Tuple2&amp;lt;ExecutionGraph, Instance&amp;gt; executionGraphInstanceTuple = createExecutionGraph(restartStrategy);&lt;br/&gt;
 		ExecutionGraph eg = executionGraphInstanceTuple.f0;&lt;br/&gt;
 &lt;br/&gt;
@@ -207,23 +224,21 @@ public void testFailWhileRestarting() throws Exception {&lt;br/&gt;
 		// Kill the instance and wait for the job to restart&lt;br/&gt;
 		instance.markDead();&lt;br/&gt;
 &lt;br/&gt;
-		Deadline deadline = TestingUtils.TESTING_DURATION().fromNow();&lt;br/&gt;
-&lt;br/&gt;
-		while (deadline.hasTimeLeft() &amp;amp;&amp;amp;&lt;br/&gt;
-			executionGraph.getState() != JobStatus.RESTARTING) {
-
-			Thread.sleep(100);
-		}&lt;br/&gt;
+		waitUntilJobStatus(executionGraph, JobStatus.RESTARTING, TestingUtils.TESTING_DURATION().toMillis());&lt;br/&gt;
 &lt;br/&gt;
 		assertEquals(JobStatus.RESTARTING, executionGraph.getState());&lt;br/&gt;
 &lt;br/&gt;
-		// The restarting should not fail with an ordinary exception&lt;br/&gt;
-		executionGraph.failGlobal(new Exception(&quot;Test exception&quot;));&lt;br/&gt;
+		// If we fail when being in RESTARTING, then we should try to restart again&lt;br/&gt;
+		final long globalModVersion = executionGraph.getGlobalModVersion();&lt;br/&gt;
+		final Exception testException = new Exception(&quot;Test exception&quot;);&lt;br/&gt;
+		executionGraph.failGlobal(testException);&lt;br/&gt;
 &lt;br/&gt;
+		assertNotEquals(globalModVersion, executionGraph.getGlobalModVersion());&lt;br/&gt;
 		assertEquals(JobStatus.RESTARTING, executionGraph.getState());&lt;br/&gt;
+		assertEquals(testException, executionGraph.getFailureCause()); // we should have updated the failure cause&lt;br/&gt;
 &lt;br/&gt;
 		// but it should fail when sending a SuppressRestartsException&lt;br/&gt;
-		executionGraph.failGlobal(new SuppressRestartsException(new Exception(&quot;Test exception&quot;)));&lt;br/&gt;
+		executionGraph.failGlobal(new SuppressRestartsException(new Exception(&quot;Suppress restart exception&quot;)));&lt;br/&gt;
 &lt;br/&gt;
 		assertEquals(JobStatus.FAILED, executionGraph.getState());&lt;br/&gt;
 &lt;br/&gt;
@@ -254,9 +269,7 @@ public void testCancelWhileFailing() throws Exception {&lt;br/&gt;
 		assertEquals(JobStatus.CANCELLING, graph.getState());&lt;br/&gt;
 &lt;br/&gt;
 		// let all tasks finish cancelling&lt;br/&gt;
-		for (ExecutionVertex vertex : graph.getVerticesTopologically().iterator().next().getTaskVertices()) {-			vertex.getCurrentExecutionAttempt().cancelingComplete();-		}&lt;br/&gt;
+		completeCanceling(graph);&lt;br/&gt;
 &lt;br/&gt;
 		assertEquals(JobStatus.CANCELED, graph.getState());&lt;br/&gt;
 	}&lt;br/&gt;
@@ -267,11 +280,7 @@ public void testFailWhileCanceling() throws Exception {&lt;br/&gt;
 		final ExecutionGraph graph = createExecutionGraph(restartStrategy).f0;&lt;br/&gt;
 &lt;br/&gt;
 		assertEquals(JobStatus.RUNNING, graph.getState());&lt;br/&gt;
-&lt;br/&gt;
-		// switch all tasks to running&lt;br/&gt;
-		for (ExecutionVertex vertex : graph.getVerticesTopologically().iterator().next().getTaskVertices()) {
-			vertex.getCurrentExecutionAttempt().switchToRunning();
-		}&lt;br/&gt;
+		switchAllTasksToRunning(graph);&lt;br/&gt;
 &lt;br/&gt;
 		graph.cancel();&lt;br/&gt;
 &lt;br/&gt;
@@ -282,13 +291,15 @@ public void testFailWhileCanceling() throws Exception {&lt;br/&gt;
 		assertEquals(JobStatus.FAILING, graph.getState());&lt;br/&gt;
 &lt;br/&gt;
 		// let all tasks finish cancelling&lt;br/&gt;
-		for (ExecutionVertex vertex : graph.getVerticesTopologically().iterator().next().getTaskVertices()) {
-			vertex.getCurrentExecutionAttempt().cancelingComplete();
-		}&lt;br/&gt;
+		completeCanceling(graph);&lt;br/&gt;
 &lt;br/&gt;
 		assertEquals(JobStatus.FAILED, graph.getState());&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	private void switchAllTasksToRunning(ExecutionGraph graph) {
+		executeOperationForAllExecutions(graph, Execution::switchToRunning);
+	}&lt;br/&gt;
+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testNoRestartOnSuppressException() throws Exception {&lt;br/&gt;
 		final ExecutionGraph eg = createExecutionGraph(new FixedDelayRestartStrategy(Integer.MAX_VALUE, 0)).f0;&lt;br/&gt;
@@ -299,9 +310,7 @@ public void testNoRestartOnSuppressException() throws Exception {&lt;br/&gt;
 &lt;br/&gt;
 		assertEquals(JobStatus.FAILING, eg.getState());&lt;br/&gt;
 &lt;br/&gt;
-		for (ExecutionVertex vertex : eg.getAllExecutionVertices()) {-			vertex.getCurrentExecutionAttempt().cancelingComplete();-		}&lt;br/&gt;
+		completeCanceling(eg);&lt;br/&gt;
 &lt;br/&gt;
 		eg.waitUntilTerminal();&lt;br/&gt;
 		assertEquals(JobStatus.FAILED, eg.getState());&lt;br/&gt;
@@ -330,7 +339,7 @@ public void testFailingExecutionAfterRestart() throws Exception {&lt;br/&gt;
 		JobVertex sender = ExecutionGraphTestUtils.createJobVertex(&quot;Task1&quot;, 1, NoOpInvokable.class);&lt;br/&gt;
 		JobVertex receiver = ExecutionGraphTestUtils.createJobVertex(&quot;Task2&quot;, 1, NoOpInvokable.class);&lt;br/&gt;
 		JobGraph jobGraph = new JobGraph(&quot;Pointwise job&quot;, sender, receiver);&lt;br/&gt;
-		ExecutionGraph eg = newExecutionGraph(new FixedDelayRestartStrategy(1, 1000), scheduler);&lt;br/&gt;
+		ExecutionGraph eg = newExecutionGraph(new FixedDelayRestartStrategy(1, 0L), scheduler);&lt;br/&gt;
 		eg.attachJobGraph(jobGraph.getVerticesSortedTopologicallyFromSources());&lt;br/&gt;
 &lt;br/&gt;
 		assertEquals(JobStatus.CREATED, eg.getState());&lt;br/&gt;
@@ -766,6 +775,68 @@ public void testRestartWithSlotSharingAndNotEnoughResources() throws Exception {&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;br/&gt;
 &lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that the {@link ExecutionGraph}
&lt;p&gt; can handle concurrent failures while&lt;br/&gt;
+	 * being in the RESTARTING state.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testConcurrentFailureWhileRestarting() throws Exception {&lt;br/&gt;
+		final long timeout = 5000L;&lt;br/&gt;
+&lt;br/&gt;
+		final CountDownLatch countDownLatch = new CountDownLatch(2);&lt;br/&gt;
+		final CountDownLatchRestartStrategy restartStrategy = new CountDownLatchRestartStrategy(countDownLatch);&lt;br/&gt;
+		final ExecutionGraph executionGraph = createSimpleExecutionGraph(restartStrategy, new TestingSlotProvider(ignored -&amp;gt; new CompletableFuture&amp;lt;&amp;gt;()));&lt;br/&gt;
+&lt;br/&gt;
+		executionGraph.setQueuedSchedulingAllowed(true);&lt;br/&gt;
+		executionGraph.scheduleForExecution();&lt;br/&gt;
+&lt;br/&gt;
+		assertThat(executionGraph.getState(), is(JobStatus.RUNNING));&lt;br/&gt;
+&lt;br/&gt;
+		executionGraph.failGlobal(new FlinkException(&quot;Test exception&quot;));&lt;br/&gt;
+&lt;br/&gt;
+		executor.execute(() -&amp;gt; {&lt;br/&gt;
+			countDownLatch.countDown();&lt;br/&gt;
+			try &lt;/p&gt;
{
+				countDownLatch.await();
+			}
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
+				ExceptionUtils.rethrow(e);
+			}
&lt;p&gt;+&lt;br/&gt;
+			executionGraph.failGlobal(new FlinkException(&quot;Concurrent exception&quot;));&lt;br/&gt;
+		});&lt;br/&gt;
+&lt;br/&gt;
+		waitUntilJobStatus(executionGraph, JobStatus.RUNNING, timeout);&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private static final class CountDownLatchRestartStrategy implements RestartStrategy {&lt;br/&gt;
+&lt;br/&gt;
+		private final CountDownLatch countDownLatch;&lt;br/&gt;
+&lt;br/&gt;
+		private CountDownLatchRestartStrategy(CountDownLatch countDownLatch) &lt;/p&gt;
{
+			this.countDownLatch = countDownLatch;
+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public boolean canRestart() &lt;/p&gt;
{
+			return true;
+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public void restart(RestartCallback restarter, ScheduledExecutor executor) {&lt;br/&gt;
+			executor.execute(() -&amp;gt; {&lt;br/&gt;
+				countDownLatch.countDown();&lt;br/&gt;
+&lt;br/&gt;
+				try &lt;/p&gt;
{
+					countDownLatch.await();
+				}
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
+					ExceptionUtils.rethrow(e);
+				}
&lt;p&gt;+&lt;br/&gt;
+				restarter.triggerFullRecovery();&lt;br/&gt;
+			});&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	// ------------------------------------------------------------------------&lt;br/&gt;
 	//  Utilities&lt;br/&gt;
 	// ------------------------------------------------------------------------&lt;br/&gt;
@@ -846,14 +917,6 @@ public void run() {&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt; 	private static Tuple2&amp;lt;ExecutionGraph, Instance&amp;gt; createExecutionGraph(RestartStrategy restartStrategy) throws Exception &lt;/p&gt;
{
-		return createExecutionGraph(restartStrategy, false);
-	}
&lt;p&gt;-&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static Tuple2&amp;lt;ExecutionGraph, Instance&amp;gt; createSpyExecutionGraph(RestartStrategy restartStrategy) throws Exception 
{
-		return createExecutionGraph(restartStrategy, true);
-	}
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;private static Tuple2&amp;lt;ExecutionGraph, Instance&amp;gt; createExecutionGraph(RestartStrategy restartStrategy, boolean isSpy) throws Exception {&lt;br/&gt;
 		Instance instance = ExecutionGraphTestUtils.getInstance(&lt;br/&gt;
 			new ActorTaskManagerGateway(&lt;br/&gt;
 				new SimpleActorGateway(TestingUtils.directExecutionContext())),&lt;br/&gt;
@@ -862,15 +925,7 @@ public void run() {&lt;br/&gt;
 		Scheduler scheduler = new Scheduler(TestingUtils.defaultExecutionContext());&lt;br/&gt;
 		scheduler.newInstanceAvailable(instance);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;JobVertex sender = ExecutionGraphTestUtils.createJobVertex(&quot;Task&quot;, NUM_TASKS, NoOpInvokable.class);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;JobGraph jobGraph = new JobGraph(&quot;Pointwise job&quot;, sender);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;ExecutionGraph eg = newExecutionGraph(restartStrategy, scheduler);&lt;/li&gt;
	&lt;li&gt;if (isSpy) 
{
-			eg = spy(eg);
-		}&lt;/li&gt;
	&lt;li&gt;eg.attachJobGraph(jobGraph.getVerticesSortedTopologicallyFromSources());&lt;br/&gt;
+		ExecutionGraph eg = createSimpleExecutionGraph(restartStrategy, scheduler);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		assertEquals(JobStatus.CREATED, eg.getState());&lt;/p&gt;

&lt;p&gt;@@ -879,7 +934,23 @@ public void run() &lt;/p&gt;
{
 		return new Tuple2&amp;lt;&amp;gt;(eg, instance);
 	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static ExecutionGraph newExecutionGraph(RestartStrategy restartStrategy, Scheduler scheduler) throws IOException {&lt;br/&gt;
+	private static ExecutionGraph createSimpleExecutionGraph(RestartStrategy restartStrategy, SlotProvider slotProvider) throws IOException, JobException 
{
+		JobGraph jobGraph = createJobGraph(NUM_TASKS);
+
+		ExecutionGraph eg = newExecutionGraph(restartStrategy, slotProvider);
+		eg.attachJobGraph(jobGraph.getVerticesSortedTopologicallyFromSources());
+
+		return eg;
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private static JobGraph createJobGraph(int parallelism) &lt;/p&gt;
{
+		JobVertex sender = ExecutionGraphTestUtils.createJobVertex(&quot;Task&quot;, parallelism, NoOpInvokable.class);
+
+		return new JobGraph(&quot;Pointwise job&quot;, sender);
+	}
&lt;p&gt;+&lt;br/&gt;
+	private static ExecutionGraph newExecutionGraph(RestartStrategy restartStrategy, SlotProvider slotProvider) throws IOException &lt;/p&gt;
{
 		return new ExecutionGraph(
 			TestingUtils.defaultExecutor(),
 			TestingUtils.defaultExecutor(),
@@ -889,7 +960,7 @@ private static ExecutionGraph newExecutionGraph(RestartStrategy restartStrategy,
 			new SerializedValue&amp;lt;&amp;gt;(new ExecutionConfig()),
 			AkkaUtils.getDefaultTimeout(),
 			restartStrategy,
-			scheduler);
+			slotProvider);
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	private static void restartAfterFailure(ExecutionGraph eg, FiniteDuration timeout, boolean haltAfterRestart) throws InterruptedException, TimeoutException {&lt;br/&gt;
@@ -922,8 +993,10 @@ private static void waitForAllResourcesToBeAssignedAfterAsyncRestart(ExecutionGr&lt;/p&gt;

&lt;p&gt; 	private static void waitForAsyncRestart(ExecutionGraph eg, FiniteDuration timeout) throws InterruptedException {&lt;br/&gt;
 		Deadline deadline = timeout.fromNow();&lt;br/&gt;
+		long waitingTime = 10L;&lt;br/&gt;
 		while (deadline.hasTimeLeft() &amp;amp;&amp;amp; eg.getState() != JobStatus.RUNNING) &lt;/p&gt;
{
-			Thread.sleep(100);
+			Thread.sleep(waitingTime);
+			waitingTime = Math.min(waitingTime &amp;lt;&amp;lt; 1, 100L);
 		}
&lt;p&gt; 	}&lt;/p&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16646559" author="till.rohrmann" created="Thu, 11 Oct 2018 15:01:40 +0000"  >&lt;p&gt;Fixed via&lt;br/&gt;
1.7.0: &lt;a href=&quot;https://github.com/apache/flink/commit/5ae68f85fa4182d94608583b133e8162c4f8f07d&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/commit/5ae68f85fa4182d94608583b133e8162c4f8f07d&lt;/a&gt;&lt;br/&gt;
1.6.2: &lt;a href=&quot;https://github.com/apache/flink/commit/15a90891a840aff53260a8819e1120cd310f7336&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/commit/15a90891a840aff53260a8819e1120cd310f7336&lt;/a&gt;&lt;br/&gt;
1.5.5: &lt;a href=&quot;https://github.com/apache/flink/commit/d13015e23c805e1aaefdc7d8037f2fa87ea74830&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/commit/d13015e23c805e1aaefdc7d8037f2fa87ea74830&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12930986" name="jobmanager_5000.log" size="1077080" author="gjy" created="Tue, 10 Jul 2018 10:20:01 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 5 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3vpv3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>