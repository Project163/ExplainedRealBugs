<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:48:37 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-18646] Managed memory released check can block RPC thread</title>
                <link>https://issues.apache.org/jira/browse/FLINK-18646</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;UnsafeMemoryBudget#verifyEmpty, called on slot freeing, needs time to wait on GC of all allocated/released managed memory. If there are a lot of segments to GC then it can take time to finish the check. If&#160;slot freeing happens in RPC thread, the GC waiting can block it and TM risks to miss its heartbeat.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13318259">FLINK-18646</key>
            <summary>Managed memory released check can block RPC thread</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="azagrebin">Andrey Zagrebin</assignee>
                                    <reporter username="azagrebin">Andrey Zagrebin</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Mon, 20 Jul 2020 13:20:51 +0000</created>
                <updated>Wed, 26 Aug 2020 15:32:48 +0000</updated>
                            <resolved>Thu, 13 Aug 2020 08:19:45 +0000</resolved>
                                    <version>1.10.1</version>
                    <version>1.11.0</version>
                    <version>1.12.0</version>
                                    <fixVersion>1.10.2</fixVersion>
                    <fixVersion>1.11.2</fixVersion>
                    <fixVersion>1.12.0</fixVersion>
                                    <component>Runtime / Task</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>11</watches>
                                                                                                                <comments>
                            <comment id="17161235" author="azagrebin" created="Mon, 20 Jul 2020 13:21:36 +0000"  >&lt;p&gt;The easiest solution could be to always wait for GC in another thread.&lt;/p&gt;

&lt;p&gt;cc &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trohrmann&quot; class=&quot;user-hover&quot; rel=&quot;trohrmann&quot;&gt;trohrmann&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=TsReaper&quot; class=&quot;user-hover&quot; rel=&quot;TsReaper&quot;&gt;TsReaper&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17161786" author="tsreaper" created="Tue, 21 Jul 2020 07:08:45 +0000"  >&lt;p&gt;I discover this problem when running TPCDS 10T benchmark. The&#160;&lt;tt&gt;System.gc()&lt;/tt&gt; in the infinite loop of &lt;tt&gt;UnsafeMemoryBudget#reserveMemory&lt;/tt&gt; is called about 400 times before the task slot is released.&lt;/p&gt;

&lt;p&gt;I think this issue is caused by the usage of &lt;tt&gt;JavaGcCleanerWrapper.tryRunPendingCleaners()&lt;/tt&gt;. In Java8, &lt;tt&gt;JavaGcCleanerWrapper.tryRunPendingCleaners()&lt;/tt&gt; actually calls &lt;tt&gt;java.lang.ref.Reference.tryHandlePending(false)&lt;/tt&gt; and it only runs 1 cleaner each call. If there are lots of pending cleaners, the infinite loop containing &lt;tt&gt;System.gc()&lt;/tt&gt; might run multiple times before exiting (the cleaner of other slots might run before the cleaner of the current slot). So it seems that we need to change&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!JavaGcCleanerWrapper.tryRunPendingCleaners()) {
    &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.sleep(sleepTime);
    sleepTime &amp;lt;&amp;lt;= 1;
    sleeps++;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (JavaGcCleanerWrapper.tryRunPendingCleaners()) {}

&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.sleep(sleepTime);
sleepTime &amp;lt;&amp;lt;= 1;
sleeps++;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Also, it will be better if the cleaner only cleans the segments in its own thread.&lt;/p&gt;</comment>
                            <comment id="17161825" author="azagrebin" created="Tue, 21 Jul 2020 07:40:47 +0000"  >&lt;p&gt;I do not think that&#160;&lt;tt&gt;System.gc()&lt;/tt&gt;&#160;is actually doing something all the time, it is just a hint to JVM that it is allowed to spent more time for GC. Anyways we can indeed remove it to see whether it helps.&lt;br/&gt;
 &#160;&lt;br/&gt;
 If&#160;&lt;tt&gt;tryRunPendingCleaners == true&lt;/tt&gt;&#160;there will be no&#160;&lt;tt&gt;sleeps&lt;/tt&gt;&#160;and the outer loop is basically&#160;&lt;tt&gt;while (tryRunPendingCleaners)&#160;plus&#160;{{System.gc()&lt;/tt&gt;, which is almost noop hint according to logs.}}. Also generally, it is not optimal for each reserve operation to wait for all cleaners by&#160;&lt;tt&gt;while (tryRunPendingCleaners)&lt;/tt&gt;&#160;without trying to reserve because the reserve operation might want to reserve just a bit and needs to wait for a couple of cleaners.&lt;/p&gt;

&lt;p&gt;The cleaners are already supposed to clean in some GC background threads. By calling&#160;&lt;tt&gt;tryRunPendingCleaners&lt;/tt&gt;&#160;, we just try to speed it up giving it another thread and more CPU if the available memory is exhausted. Therefore, it makes sense to allocate a thread for the check because otherwise it waits for the full GC of the slot managed memory in RPC thread. I would try this in&#160;&lt;tt&gt;TaskSlot&lt;/tt&gt;:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
CompletableFuture&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Void&lt;/span&gt;&amp;gt; closeAsync(Throwable cause) {
	.....
	ExecutorService executor = Executors.newSingleThreadExecutor(); &lt;span class=&quot;code-comment&quot;&gt;// &amp;lt;------------
&lt;/span&gt;	&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; CompletableFuture&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Void&lt;/span&gt;&amp;gt; cleanupFuture = FutureUtils
	  .waitForAll(tasks.values().stream().map(TaskSlotPayload::getTerminationFuture).collect(Collectors.toList()))
		.thenRunAsync(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;::verifyMemoryFreed, executor) &lt;span class=&quot;code-comment&quot;&gt;// &amp;lt;------------
&lt;/span&gt;		.thenRunAsync(() -&amp;gt; {
			&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.memoryManager.shutdown();
			executor.shutdown(); &lt;span class=&quot;code-comment&quot;&gt;// &amp;lt;------------
&lt;/span&gt;		});
        ....
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="17161847" author="tsreaper" created="Tue, 21 Jul 2020 08:06:03 +0000"  >&lt;p&gt;&lt;b&gt;&lt;em&gt;the reserve operation might want to reserve just a bit and needs to wait for a couple of cleaners&lt;/em&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;I agree with this.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;&lt;em&gt;System.gc(), which is almost noop hint&lt;/em&gt;&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;For this I have some doubts. &lt;tt&gt;System.gc()&lt;/tt&gt; is indeed just a hint, but we cannot make sure when the GC will happen after this method is called. It is possible that GC happens immediately after the call. I think we should only call &lt;tt&gt;System.gc()&lt;/tt&gt; when &lt;tt&gt;tryRunPendingCleaners&lt;/tt&gt; returns false, otherwise there are still pending cleaners and there is no need to hint for another GC.&lt;/p&gt;

&lt;p&gt;I&apos;ve added some logs before calling &lt;tt&gt;System.gc()&lt;/tt&gt; in the infinite loop, and there are obvious gaps which are caused by full GCs.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;image-wrap&quot; style=&quot;&quot;&gt;&lt;img src=&quot;https://issues.apache.org/jira/secure/attachment/13008062/13008062_log1.png&quot; style=&quot;border: 0px solid black&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;image-wrap&quot; style=&quot;&quot;&gt;&lt;img src=&quot;https://issues.apache.org/jira/secure/attachment/13008063/13008063_log2.png&quot; style=&quot;border: 0px solid black&quot; /&gt;&lt;/span&gt;&lt;/p&gt;</comment>
                            <comment id="17161853" author="azagrebin" created="Tue, 21 Jul 2020 08:13:48 +0000"  >&lt;p&gt;GC gaps are not always so not clear how much it slows things down. I agree the best is to try w/o always calling GC.&lt;br/&gt;
 I agree It makes sense to continue calling GC only if tryRunPendingCleaners is false and memory still cannot be allocated.&lt;br/&gt;
 The original idea was to retry GC only after a lot of waiting&#160;&lt;tt&gt;RETRIGGER_GC_AFTER_SLEEPS.&lt;/tt&gt;&lt;br/&gt;
 It was a further optimisation comparing to the Java code for direct memory allocation.&lt;/p&gt;</comment>
                            <comment id="17161865" author="lzljs3620320" created="Tue, 21 Jul 2020 08:33:24 +0000"  >&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/2414105/why-is-it-bad-practice-to-call-system-gc&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://stackoverflow.com/questions/2414105/why-is-it-bad-practice-to-call-system-gc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Calling System.gc() multiple times seems to be costly. Although it&apos;s a hint, it can lead to a meaningless rush of the JVM.&lt;/p&gt;

&lt;p&gt;The codes look not so complicate, maybe &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=TsReaper&quot; class=&quot;user-hover&quot; rel=&quot;TsReaper&quot;&gt;TsReaper&lt;/a&gt;&#160;you can try again&#160;benchmark after trying w/o always calling GC.&lt;/p&gt;</comment>
                            <comment id="17162693" author="azagrebin" created="Wed, 22 Jul 2020 10:40:14 +0000"  >&lt;p&gt;I agree we should not trigger GC if the cleaner queue processing is active. If we cannot still allocate memory and there are no ready cleaners detected by GC, we have to re-trigger GC or fail after sleeping and timeout.&lt;/p&gt;

&lt;p&gt;We can increase timeout for slot closing verification (off-loaded to another thread) because we have to wait for GC of all segments to make sure there is no leak. Normal reservation should probably have smaller timeout to fail faster in case of leaks, especially if we do not use it in a way similar to verification: allocate all, release and then re-allocate all again.&lt;/p&gt;

&lt;p&gt;All-in-all, the timeouts have to be tuned. If we still find ourselves often hitting the global limit, the global managed memory limit (not per slot) could also compensate for GC and/or we should not allocate all available memory and keep some buffer to compensate for GC which is usually the case for direct memory.&lt;/p&gt;</comment>
                            <comment id="17163083" author="till.rohrmann" created="Wed, 22 Jul 2020 21:30:38 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=TsReaper&quot; class=&quot;user-hover&quot; rel=&quot;TsReaper&quot;&gt;TsReaper&lt;/a&gt; do you know how the high number of GC calls happens? Looking at the code, we must have increased the &lt;tt&gt;sleeps&lt;/tt&gt; counter to 9 and then after calling &lt;tt&gt;System.gc()&lt;/tt&gt; once &lt;tt&gt;JavaGcCleanerWrapper.tryRunPendingCleaners()&lt;/tt&gt; must return &lt;tt&gt;true&lt;/tt&gt; for several calls which will keep the counter at 9 and calling &lt;tt&gt;System.gc()&lt;/tt&gt; for every pending cleaner. This looks not like an intended behavior to me.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=azagrebin&quot; class=&quot;user-hover&quot; rel=&quot;azagrebin&quot;&gt;azagrebin&lt;/a&gt; how long do we have to wait until we can expect that all segments have been detected by GC so that we can run the respective cleaners? What do you mean with keeping some buffer to compensate for GC? What do you mean with hitting the global limit?&lt;/p&gt;</comment>
                            <comment id="17163285" author="azagrebin" created="Thu, 23 Jul 2020 07:32:50 +0000"  >&lt;blockquote&gt;&lt;p&gt;do you know how the high number of GC calls happens?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;From the offline discussion: 400 actual GCs, the number of System.gc() calls is indeed high for each while iteration&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Looking at the code, we must have increased the&#160;&lt;tt&gt;sleeps&lt;/tt&gt;&#160;counter to 9 and then after calling&#160;&lt;tt&gt;System.gc()&lt;/tt&gt;&#160;once&#160;&lt;tt&gt;JavaGcCleanerWrapper.tryRunPendingCleaners()&lt;/tt&gt;&#160;must return&#160;&lt;tt&gt;true&lt;/tt&gt;&#160;for several calls which will keep the counter at 9 and calling&#160;&lt;tt&gt;System.gc()&lt;/tt&gt;&#160;for every pending cleaner. This looks not like an intended behavior to me.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;From the offline discussion: this is true, it was overlooked. That is why it makes sense to call GC only if &apos;tryRunPendingCleaners&apos; is false after sleep and memory still cannot be allocated. I have already a fix for it in a branch.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;how long do we have to wait until we can expect that all segments have been detected by GC so that we can run the respective cleaners?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;JVM waits for 9 sleeps (0,5) for direct memory but it is generally used for large global limit and allocations which are small relative to the limit which requires to GC only so much as asked.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;What do you mean with keeping some buffer to compensate for GC?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;If 120 Mb is the actual memory that can be used then make the interface limit of 100 Mb. Keep 20 Mb to allocate more actual memory than 100Mb if some memory is not GC&apos;ed yet.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;What do you mean with hitting the global limit?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;When we allocated all available actual memory, some of which is released but not GC&apos;ed yet, and we try to allocate more assuming that we released some and it should be available.&lt;/p&gt;</comment>
                            <comment id="17166346" author="azagrebin" created="Tue, 28 Jul 2020 11:20:26 +0000"  >&lt;p&gt;merged into master by 3d056c8fea72ca40b663d12570913679be87c0a9&lt;br/&gt;
 merged into 1.11 by bcc97082639280ab14f465463fb07b27167c37e3&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=TsReaper&quot; class=&quot;user-hover&quot; rel=&quot;TsReaper&quot;&gt;TsReaper&lt;/a&gt;&#160;I am closing the issue as the verification should not block the RPC thread any more. Reopen it if you notice any problems with it. If there are still problems with the normal memory allocation timeout (given there is no real leak), we can discuss it in another issue.&lt;/p&gt;</comment>
                            <comment id="17176303" author="till.rohrmann" created="Wed, 12 Aug 2020 12:17:28 +0000"  >&lt;p&gt;Do we need to backport this ticket to Flink 1.10.2 &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=azagrebin&quot; class=&quot;user-hover&quot; rel=&quot;azagrebin&quot;&gt;azagrebin&lt;/a&gt; because the issue causing this problem is also part of this release?&lt;/p&gt;</comment>
                            <comment id="17176830" author="till.rohrmann" created="Thu, 13 Aug 2020 08:19:45 +0000"  >&lt;p&gt;Fixed via&lt;/p&gt;

&lt;p&gt;1.10.2: 3e17833eec5f5062260eaef2cc06421dabbd7f56&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310560">
                    <name>Problem/Incident</name>
                                            <outwardlinks description="causes">
                                        <issuelink>
            <issuekey id="13324640">FLINK-19055</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is caused by">
                                        <issuelink>
            <issuekey id="13281453">FLINK-15758</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="13008062" name="log1.png" size="531128" author="TsReaper" created="Tue, 21 Jul 2020 08:03:33 +0000"/>
                            <attachment id="13008063" name="log2.png" size="149953" author="TsReaper" created="Tue, 21 Jul 2020 08:03:33 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 13 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z0h0g8:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>