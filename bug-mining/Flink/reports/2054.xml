<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:30:53 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-4500] Cassandra sink can lose messages</title>
                <link>https://issues.apache.org/jira/browse/FLINK-4500</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;The problem is the same as I pointed out with the Kafka producer sink (&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-4027&quot; title=&quot;FlinkKafkaProducer09 sink can lose messages&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-4027&quot;&gt;&lt;del&gt;FLINK-4027&lt;/del&gt;&lt;/a&gt;).  The CassandraTupleSink&apos;s send() and CassandraPojoSink&apos;s send() both send data asynchronously to Cassandra and record whether an error occurs via a future callback.  But CassandraSinkBase does not implement Checkpointed, so it can&apos;t stop checkpoint from happening even though the are Cassandra queries in flight from the checkpoint that may fail.  If they do fail, they would subsequently not be replayed when the job recovered, and would thus be lost.&lt;/p&gt;

&lt;p&gt;In addition, &lt;br/&gt;
CassandraSinkBase&apos;s close should check whether there is a pending exception and throw it, rather than silently close.  It should also wait for any pending async queries to complete and check their status before closing.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13000202">FLINK-4500</key>
            <summary>Cassandra sink can lose messages</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mcfongtw">Michael Fong</assignee>
                                    <reporter username="elevy">Elias Levy</reporter>
                        <labels>
                    </labels>
                <created>Thu, 25 Aug 2016 22:52:42 +0000</created>
                <updated>Tue, 14 Nov 2017 14:17:23 +0000</updated>
                            <resolved>Fri, 10 Nov 2017 10:11:18 +0000</resolved>
                                    <version>1.1.0</version>
                                    <fixVersion>1.4.0</fixVersion>
                                    <component>Connectors / Cassandra</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="16008756" author="zentol" created="Fri, 12 May 2017 21:49:33 +0000"  >&lt;p&gt;The second part of this issue (tracking in-flight records) was addressed in&lt;br/&gt;
1.3 with a85b1881d184c02075441f57f3364ec80b2d4f4d&lt;br/&gt;
1.4 with 948bb9f674a9c4cf95491f3d9a92b38eed6b64e8.&lt;/p&gt;</comment>
                            <comment id="16124486" author="mcfongtw" created="Sat, 12 Aug 2017 06:40:23 +0000"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;I would like to help implement Checkpointed in CassandraSinkBase class to ensure the in-flight mutation would be completed before a checkpoint was requested. &lt;/p&gt;

&lt;p&gt;Regards,&lt;/p&gt;</comment>
                            <comment id="16125541" author="zentol" created="Mon, 14 Aug 2017 11:01:27 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mcfongtw&quot; class=&quot;user-hover&quot; rel=&quot;mcfongtw&quot;&gt;mcfongtw&lt;/a&gt; feel free to work on this issue, I have given you contributor permissions and you can now assign issues to yourself.&lt;/p&gt;</comment>
                            <comment id="16139448" author="mcfongtw" created="Thu, 24 Aug 2017 01:35:39 +0000"  >&lt;p&gt;I plan to design the first part of the requirement on existing implementation by&lt;br/&gt;
1. implements CheckedpointedFunction&lt;br/&gt;
2. leverage AtomicInteger updatesPending to make sure all in-flight records will be flushed to sink when checkpoint performs. &lt;br/&gt;
3. As other data connectors, there will be a flag to turn on or off to the honor the promise during checkpointing.  &lt;/p&gt;

&lt;p&gt;For the reference, the second part was addressed by &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5101&quot; title=&quot;Test CassandraConnectorITCase instable&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5101&quot;&gt;&lt;del&gt;FLINK-5101&lt;/del&gt;&lt;/a&gt; in the earlier comments. &lt;/p&gt;</comment>
                            <comment id="16142979" author="githubbot" created="Sun, 27 Aug 2017 01:16:53 +0000"  >&lt;p&gt;GitHub user mcfongtw opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-4500&quot; title=&quot;Cassandra sink can lose messages&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-4500&quot;&gt;&lt;del&gt;FLINK-4500&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;C* Connector&amp;#93;&lt;/span&gt; CassandraSinkBase implements CheckpointedFunction&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;br/&gt;
    Have CassandraSinkBase to implement CheckpointedFunction so that all in-flight mutation message could be sent to C* sink before a checkpoint performs. As a result, the checkpoint would be complete. &lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul&gt;
	&lt;li&gt;Implement CheckpointedFunction to (optionally) wait on all pending records being flushed to the C* sink before checkpoint performs (or closing connection).&lt;/li&gt;
	&lt;li&gt;Add debugging message in CassandraSinkBase.&lt;/li&gt;
	&lt;li&gt;Add unit tests for simple / multi-threaded message dispatching for successful / failed scenarios&lt;/li&gt;
	&lt;li&gt;Add unit tests for failure handling logics on errors thrown at different stages.&lt;/li&gt;
	&lt;li&gt;Add unit tests for flushing pending records when checkpoint performs.&lt;/li&gt;
	&lt;li&gt;Provide a Immediate / Delayed type of ResultSetFuture for testing purposes.&lt;/li&gt;
	&lt;li&gt;Add CassandraBaseTest in suppression list to use guava imports&lt;/li&gt;
	&lt;li&gt;In log4j-test settings, change root log level to INFO and enable ALL level against some test classes.&lt;/li&gt;
&lt;/ul&gt;



&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This change is already covered by existing tests, such as &lt;b&gt;CassandraBaseTest&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;    This change added tests and can be verified as follows:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Add unit tests for simple / multi-threaded message dispatching for successful / failed scenarios&lt;/li&gt;
	&lt;li&gt;Add unit tests for failure handling logics on errors thrown at different stages.&lt;/li&gt;
	&lt;li&gt;Add unit tests for flushing pending records when checkpoint performs.&lt;/li&gt;
	&lt;li&gt;Provide a Immediate / Delayed type of ResultSetFuture for testing purposes.&lt;/li&gt;
	&lt;li&gt;Add CassandraBaseTest in suppression list to use guava imports&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;The serializers: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (yes / *&lt;b&gt;no&lt;/b&gt;* (maybe) )&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)&lt;/li&gt;
&lt;/ul&gt;




&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/mcfongtw/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/mcfongtw/flink&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-4500&quot; title=&quot;Cassandra sink can lose messages&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-4500&quot;&gt;&lt;del&gt;FLINK-4500&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4605&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit caefe390bf2aaa22d996cc24a31a3ba76241fb23&lt;br/&gt;
Author: Michael Fong &amp;lt;mcfong.open@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-08-14T12:57:06Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-4500&quot; title=&quot;Cassandra sink can lose messages&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-4500&quot;&gt;&lt;del&gt;FLINK-4500&lt;/del&gt;&lt;/a&gt; CassandraSinkBase implements CheckpointedFunction&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Implement CheckpointedFunction to (optionally) wait on all pending records being flushed to the C* sink before taking a snapshot (or closing connection).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Add debugging message in CassandraSinkBase.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Add unit tests for simple / multi-threaded message dispatching for successful / failed scenarios&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Add unit tests for failure handling logics on errors thrown at different stages.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Add unit tests for flushing pending records when checkpoint performs.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Provide a Immediate / Delayed type of ResultSetFuture for testing purposes.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Add CassandraBaseTest in suppression list to use guava imports&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In log4j-test settings, change root log level to INFO and enable ALL level against some test classes.&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;</comment>
                            <comment id="16160180" author="mcfongtw" created="Sun, 10 Sep 2017 02:44:54 +0000"  >&lt;p&gt;There is a PR &lt;a href=&quot;https://github.com/apache/flink/pull/4605&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605&lt;/a&gt; looking for reviewer. Thanks!&lt;/p&gt;

&lt;p&gt;Regards,&lt;/p&gt;

&lt;p&gt;Michael&lt;/p&gt;</comment>
                            <comment id="16170335" author="githubbot" created="Mon, 18 Sep 2017 17:23:28 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139482615&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139482615&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    empty method that can be removed&lt;/p&gt;</comment>
                            <comment id="16170336" author="githubbot" created="Mon, 18 Sep 2017 17:23:28 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139482849&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139482849&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception &lt;/p&gt;
{
    +		ClusterBuilder builder = mock(ClusterBuilder.class);
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);
    +		casSinkFunc.setFlushOnCheckpoint(true);
    +		casSinkFunc.open(new Configuration());
    +
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +
    +		casSinkFunc.close();
    +
    +		//Final pending updates should be zero
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on close() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnClose() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +
    +			casSinkFunc.close();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error from close()
    +
    +			Assert.assertTrue(e.getMessage().contains(&quot;Error while sending value&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    we usually put the fail within the ```try``` block  (also applies to other tests)&lt;/p&gt;</comment>
                            <comment id="16170337" author="githubbot" created="Mon, 18 Sep 2017 17:23:28 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139483098&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139483098&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception &lt;/p&gt;
{
    +		ClusterBuilder builder = mock(ClusterBuilder.class);
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);
    +		casSinkFunc.setFlushOnCheckpoint(true);
    +		casSinkFunc.open(new Configuration());
    +
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +
    +		casSinkFunc.close();
    +
    +		//Final pending updates should be zero
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on close() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnClose() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +
    +			casSinkFunc.close();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error from close()
    +
    +			Assert.assertTrue(e.getMessage().contains(&quot;Error while sending value&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on invoke() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	//TODO: should unitfy error handling logic in CassandraSinkBase&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    this comment doesn&apos;t make sense here, if anything it should be put into `CassandraSinkBase`.&lt;/p&gt;</comment>
                            <comment id="16170338" author="githubbot" created="Mon, 18 Sep 2017 17:23:28 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139484328&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139484328&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception &lt;/p&gt;
{
    +		ClusterBuilder builder = mock(ClusterBuilder.class);
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);
    +		casSinkFunc.setFlushOnCheckpoint(true);
    +		casSinkFunc.open(new Configuration());
    +
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +
    +		casSinkFunc.close();
    +
    +		//Final pending updates should be zero
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on close() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnClose() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +
    +			casSinkFunc.close();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error from close()
    +
    +			Assert.assertTrue(e.getMessage().contains(&quot;Error while sending value&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on invoke() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	//TODO: should unitfy error handling logic in CassandraSinkBase&lt;br/&gt;
    +	//Exception would have been thrown from invoke(), but asyncError was not set null, hence it was rethrown in close()&lt;br/&gt;
    +	@Ignore&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnInvoke() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error thrown from invoke()
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			casSinkFunc.close();
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown when checkpoint performs if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnCheckpoint() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(casSinkFunc));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.snapshot(123L, 123L);
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			//expected async error from snapshotState()
    +
    +			Assert.assertTrue(e.getCause() instanceof IllegalStateException);
    +			Assert.assertTrue(e.getCause().getMessage().contains(&quot;Failed to send data to Cassandra&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			casSinkFunc.close();
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Multi Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that CassandraSinkBase would flush all in-flight message on close(), accompanied with concurrent&lt;br/&gt;
    +	 * message delivery successfully via a thraedpool.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testFlushOnPendingRecordsOnCloseWithSuccessfulMessage() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService threadPool = Executors.newFixedThreadPool(MAX_THREAD_POOL_SIZE);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; MAX_THREAD_NUM; i++) {&lt;br/&gt;
    +			threadPool.submit(() -&amp;gt; {&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +
    +					casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.DELAYED_SUCCESS);
    +				}
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
    +					LOG.error(&quot;Error while dispatching sending message to Cassandra sink =&amp;gt; {} &quot;, e);&lt;br/&gt;
    +				}&lt;br/&gt;
    +			});&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		//wait until the first message has been dispatched and invoked&lt;br/&gt;
    +		Thread.sleep(500);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    these waits are too long. They increase the test execution times, and are usually a sign that the test isn&apos;t really stable.&lt;/p&gt;</comment>
                            <comment id="16170339" author="githubbot" created="Mon, 18 Sep 2017 17:23:28 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139482897&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139482897&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception &lt;/p&gt;
{
    +		ClusterBuilder builder = mock(ClusterBuilder.class);
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);
    +		casSinkFunc.setFlushOnCheckpoint(true);
    +		casSinkFunc.open(new Configuration());
    +
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +
    +		casSinkFunc.close();
    +
    +		//Final pending updates should be zero
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on close() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnClose() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +
    +			casSinkFunc.close();
    +		}
&lt;p&gt; catch (IOException e) {&lt;br/&gt;
    +			//expected async error from close()&lt;br/&gt;
    +&lt;br/&gt;
    +			Assert.assertTrue(e.getMessage().contains(&quot;Error while sending value&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +			//Final pending updates should be zero&lt;br/&gt;
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());&lt;br/&gt;
    +&lt;br/&gt;
    +			//done&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    unnecessary comment (also applies to other tests)&lt;/p&gt;</comment>
                            <comment id="16170340" author="githubbot" created="Mon, 18 Sep 2017 17:23:28 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139482886&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139482886&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception &lt;/p&gt;
{
    +		ClusterBuilder builder = mock(ClusterBuilder.class);
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);
    +		casSinkFunc.setFlushOnCheckpoint(true);
    +		casSinkFunc.open(new Configuration());
    +
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +
    +		casSinkFunc.close();
    +
    +		//Final pending updates should be zero
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on close() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnClose() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +
    +			casSinkFunc.close();
    +		}
&lt;p&gt; catch (IOException e) {&lt;br/&gt;
    +			//expected async error from close()&lt;br/&gt;
    +&lt;br/&gt;
    +			Assert.assertTrue(e.getMessage().contains(&quot;Error while sending value&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +			//Final pending updates should be zero&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    unnecessary comment  (also applies to other tests)&lt;/p&gt;</comment>
                            <comment id="16170341" author="githubbot" created="Mon, 18 Sep 2017 17:23:29 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139483818&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139483818&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception &lt;/p&gt;
{
    +		ClusterBuilder builder = mock(ClusterBuilder.class);
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);
    +		casSinkFunc.setFlushOnCheckpoint(true);
    +		casSinkFunc.open(new Configuration());
    +
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +
    +		casSinkFunc.close();
    +
    +		//Final pending updates should be zero
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on close() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnClose() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +
    +			casSinkFunc.close();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error from close()
    +
    +			Assert.assertTrue(e.getMessage().contains(&quot;Error while sending value&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on invoke() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	//TODO: should unitfy error handling logic in CassandraSinkBase&lt;br/&gt;
    +	//Exception would have been thrown from invoke(), but asyncError was not set null, hence it was rethrown in close()&lt;br/&gt;
    +	@Ignore&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnInvoke() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error thrown from invoke()
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			casSinkFunc.close();
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown when checkpoint performs if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnCheckpoint() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(casSinkFunc));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.snapshot(123L, 123L);
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			//expected async error from snapshotState()
    +
    +			Assert.assertTrue(e.getCause() instanceof IllegalStateException);
    +			Assert.assertTrue(e.getCause().getMessage().contains(&quot;Failed to send data to Cassandra&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			casSinkFunc.close();
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Multi Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that CassandraSinkBase would flush all in-flight message on close(), accompanied with concurrent&lt;br/&gt;
    +	 * message delivery successfully via a thraedpool.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testFlushOnPendingRecordsOnCloseWithSuccessfulMessage() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService threadPool = Executors.newFixedThreadPool(MAX_THREAD_POOL_SIZE);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    For a given sink instance invoke() is only called by a single thread, so we&apos;re testing undefined behavior here by using multiple threads. (also applies to other tests)&lt;/p&gt;</comment>
                            <comment id="16170342" author="githubbot" created="Mon, 18 Sep 2017 17:23:29 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139482639&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139482639&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    empty method that can be removed&lt;/p&gt;</comment>
                            <comment id="16170343" author="githubbot" created="Mon, 18 Sep 2017 17:23:29 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139482708&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139482708&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.close();&lt;br/&gt;
    +&lt;br/&gt;
    +		//Final pending updates should be zero&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    unnecessary comment&lt;/p&gt;</comment>
                            <comment id="16170344" author="githubbot" created="Mon, 18 Sep 2017 17:23:29 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139485057&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139485057&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception &lt;/p&gt;
{
    +		ClusterBuilder builder = mock(ClusterBuilder.class);
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);
    +		casSinkFunc.setFlushOnCheckpoint(true);
    +		casSinkFunc.open(new Configuration());
    +
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +
    +		casSinkFunc.close();
    +
    +		//Final pending updates should be zero
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on close() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnClose() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +
    +			casSinkFunc.close();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error from close()
    +
    +			Assert.assertTrue(e.getMessage().contains(&quot;Error while sending value&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on invoke() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	//TODO: should unitfy error handling logic in CassandraSinkBase&lt;br/&gt;
    +	//Exception would have been thrown from invoke(), but asyncError was not set null, hence it was rethrown in close()&lt;br/&gt;
    +	@Ignore&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnInvoke() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error thrown from invoke()
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			casSinkFunc.close();
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown when checkpoint performs if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnCheckpoint() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(casSinkFunc));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.snapshot(123L, 123L);
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			//expected async error from snapshotState()
    +
    +			Assert.assertTrue(e.getCause() instanceof IllegalStateException);
    +			Assert.assertTrue(e.getCause().getMessage().contains(&quot;Failed to send data to Cassandra&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			casSinkFunc.close();
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Multi Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that CassandraSinkBase would flush all in-flight message on close(), accompanied with concurrent&lt;br/&gt;
    +	 * message delivery successfully via a thraedpool.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testFlushOnPendingRecordsOnCloseWithSuccessfulMessage() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService threadPool = Executors.newFixedThreadPool(MAX_THREAD_POOL_SIZE);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; MAX_THREAD_NUM; i++) {&lt;br/&gt;
    +			threadPool.submit(() -&amp;gt; {&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +
    +					casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.DELAYED_SUCCESS);
    +				} catch (Exception e) {&lt;br/&gt;
    +					LOG.error(&quot;Error while dispatching sending message to Cassandra sink =&amp;gt; {} &quot;, e);&lt;br/&gt;
    +				}&lt;br/&gt;
    +			});&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		//wait until the first message has been dispatched and invoked&lt;br/&gt;
    +		Thread.sleep(500);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.close();&lt;br/&gt;
    +&lt;br/&gt;
    +		threadPool.shutdown();&lt;br/&gt;
    +		threadPool.awaitTermination(10, TimeUnit.SECONDS);&lt;br/&gt;
    +&lt;br/&gt;
    +		//Final pending updates should be zero&lt;br/&gt;
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that CassandraSinkBase would flush all in-flight message when checkpoint performs, accompanied&lt;br/&gt;
    +	 * with concurrent message delivery successfully via a thraedpool.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testFlushOnPendingRecordsOnCheckpoint() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService threadPool = Executors.newFixedThreadPool(MAX_THREAD_POOL_SIZE);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +				new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(casSinkFunc));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; MAX_THREAD_NUM; i++) {&lt;br/&gt;
    +			threadPool.submit(() -&amp;gt; {&lt;br/&gt;
    +				try {    +    +					casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.DELAYED_SUCCESS);    +				}
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
    +					LOG.error(&quot;Error while dispatching sending message to Cassandra sink =&amp;gt; {} &quot;, e);&lt;br/&gt;
    +				}&lt;br/&gt;
    +			});&lt;br/&gt;
    +			Thread.sleep(500);&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		//wait until the first message has been dispatched and invoked&lt;br/&gt;
    +		Thread.sleep(500);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.snapshot(123L, 123L);&lt;br/&gt;
    +&lt;br/&gt;
    +		threadPool.shutdown();&lt;br/&gt;
    +		threadPool.awaitTermination(10, TimeUnit.SECONDS);&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that CassandraSinkBase would NOT flush all in-flight message when checkpoint performs.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testDoNotFlushOnPendingRecordsOnCheckpoint() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService threadPool = Executors.newFixedThreadPool(MAX_THREAD_POOL_SIZE);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(false);&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(casSinkFunc));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; MAX_THREAD_NUM; i++) {&lt;br/&gt;
    +			threadPool.submit(() -&amp;gt; {&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +
    +					casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.DELAYED_SUCCESS);
    +				}
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
    +					LOG.error(&quot;Error while dispatching sending message to Cassandra sink =&amp;gt; {} &quot;, e);&lt;br/&gt;
    +				}&lt;br/&gt;
    +			});&lt;br/&gt;
    +			Thread.sleep(500);&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		//wait until the first message has been dispatched and invoked&lt;br/&gt;
    +		Thread.sleep(500);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.snapshot(123L, 123L);&lt;br/&gt;
    +		//Final pending records # &amp;gt; 0&lt;br/&gt;
    +		Assert.assertTrue(casSinkFunc.getNumOfPendingRecords() &amp;gt; 0);&lt;br/&gt;
    +&lt;br/&gt;
    +		threadPool.shutdown();&lt;br/&gt;
    +		threadPool.awaitTermination(10, TimeUnit.SECONDS);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that CassandraSinkBase would flush all in-flight message on close(), accompanied with concurrent&lt;br/&gt;
    +	 * thread dispatched message failure via a thraedpool.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testFlushOnPendingRecordsOnCloseWithFailedMessage() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService threadPool = Executors.newFixedThreadPool(MAX_THREAD_POOL_SIZE);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			for (int i = 0; i &amp;lt; MAX_THREAD_NUM; i++) {&lt;br/&gt;
    +				threadPool.submit(() -&amp;gt; {&lt;br/&gt;
    +					try &lt;/p&gt;
{
    +
    +						casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.DELAYED_FAILURE);
    +					}
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
    +						LOG.error(&quot;Error while dispatching sending message to Cassandra sink =&amp;gt; {} &quot;, e);&lt;br/&gt;
    +					}&lt;br/&gt;
    +&lt;br/&gt;
    +				});&lt;br/&gt;
    +			}&lt;br/&gt;
    +			//wait until the first message has been dispatched and invoked&lt;br/&gt;
    +			Thread.sleep(500);&lt;br/&gt;
    +&lt;br/&gt;
    +			casSinkFunc.close();&lt;br/&gt;
    +		} catch (IOException e) &lt;/p&gt;
{
    +			//expected async error from close()
    +		}
&lt;p&gt; finally &lt;/p&gt;
{
    +			//wait for all message dispatching threads to end
    +			threadPool.shutdown();
    +			threadPool.awaitTermination(10, TimeUnit.SECONDS);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		//Final pending updates should be zero&lt;br/&gt;
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	////////////////////////////////&lt;br/&gt;
    +	// Utilities&lt;br/&gt;
    +	///////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	private enum PredeterminedResult &lt;/p&gt;
{
    +		IMMEDIATE_SUCCESS,
    +		IMMEDIATE_FAILURE,
    +		IMMEDIATE_CANCELLATION,
    +		DELAYED_SUCCESS,
    +		DELAYED_FAILURE
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static class DummyCassandraSinkBase&amp;lt;IN, V&amp;gt; extends CassandraSinkBase&amp;lt;IN, V&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		DummyCassandraSinkBase(ClusterBuilder clusterBuilder) &lt;/p&gt;
{
    +			super(clusterBuilder);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public ListenableFuture&amp;lt;V&amp;gt; send(IN value) &lt;/p&gt;
{
    +			return (ListenableFuture&amp;lt;V&amp;gt;) session.executeAsync(DUMMY_QUERY_STMT);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static class MockCassandraSinkBase&amp;lt;IN&amp;gt; extends CassandraSinkBase&amp;lt;IN, ResultSet&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		MockCassandraSinkBase(ClusterBuilder clusterBuilder) &lt;/p&gt;
{
    +			super(clusterBuilder);
    +
    +			cluster = mock(Cluster.class);
    +			session = mock(Session.class);
    +			when(builder.getCluster()).thenReturn(cluster);
    +			when(cluster.connect()).thenReturn(session);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public void invokeWithImmediateResult(IN value, PredeterminedResult result) throws Exception {&lt;br/&gt;
    +			when(session.executeAsync(DUMMY_QUERY_STMT)).thenAnswer(new Answer&amp;lt;ResultSetFuture&amp;gt;() {&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public ResultSetFuture answer(InvocationOnMock invocationOnMock) throws Throwable {&lt;br/&gt;
    +						ResultSetFuture predeterminedFuture = null;&lt;br/&gt;
    +&lt;br/&gt;
    +						switch (result) &lt;/p&gt;
{
    +							case IMMEDIATE_FAILURE:
    +								predeterminedFuture = ResultSetFutures.immediateFailedFuture(new IllegalStateException(&quot;Immediate Failure!&quot;));
    +								break;
    +
    +							case IMMEDIATE_CANCELLATION:
    +								predeterminedFuture = ResultSetFutures.immediateCancelledFuture();
    +								break;
    +
    +							case DELAYED_FAILURE:
    +								predeterminedFuture = ResultSetFutures.delayedFailedFuture(new IllegalStateException(&quot;Delayed Failure!&quot;));
    +								break;
    +
    +							case DELAYED_SUCCESS:
    +								predeterminedFuture = ResultSetFutures.delayedFuture(null);
    +								break;
    +							//If not specified, set result to Successful
    +							default:
    +							case IMMEDIATE_SUCCESS:
    +								predeterminedFuture = ResultSetFutures.immediateFuture(null);
    +								break;
    +						}
&lt;p&gt;    +&lt;br/&gt;
    +						log.info(&quot;Invoke with {} of {}&quot;, value, result.name());&lt;br/&gt;
    +&lt;br/&gt;
    +						return predeterminedFuture;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				}&lt;br/&gt;
    +			);&lt;br/&gt;
    +			invoke(value);&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		@Override&lt;br/&gt;
    +		public ListenableFuture&amp;lt;ResultSet&amp;gt; send(IN value) &lt;/p&gt;
{
    +			return (ListenableFuture&amp;lt;ResultSet&amp;gt;) session.executeAsync(DUMMY_QUERY_STMT);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public static void main(String[] args) throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    remove&lt;/p&gt;</comment>
                            <comment id="16170345" author="githubbot" created="Mon, 18 Sep 2017 17:23:29 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139482771&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139482771&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception &lt;/p&gt;
{
    +		ClusterBuilder builder = mock(ClusterBuilder.class);
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);
    +		casSinkFunc.setFlushOnCheckpoint(true);
    +		casSinkFunc.open(new Configuration());
    +
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +
    +		casSinkFunc.close();
    +
    +		//Final pending updates should be zero
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on close() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnClose() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try {&lt;br/&gt;
    +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    remove empty line&lt;/p&gt;</comment>
                            <comment id="16170346" author="githubbot" created="Mon, 18 Sep 2017 17:23:29 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139485608&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139485608&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    remove this line for clarity purposes as close() should never be called&lt;/p&gt;</comment>
                            <comment id="16170347" author="githubbot" created="Mon, 18 Sep 2017 17:23:29 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139484838&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139484838&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception &lt;/p&gt;
{
    +		ClusterBuilder builder = mock(ClusterBuilder.class);
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);
    +		casSinkFunc.setFlushOnCheckpoint(true);
    +		casSinkFunc.open(new Configuration());
    +
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +
    +		casSinkFunc.close();
    +
    +		//Final pending updates should be zero
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on close() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnClose() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +
    +			casSinkFunc.close();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error from close()
    +
    +			Assert.assertTrue(e.getMessage().contains(&quot;Error while sending value&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on invoke() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	//TODO: should unitfy error handling logic in CassandraSinkBase&lt;br/&gt;
    +	//Exception would have been thrown from invoke(), but asyncError was not set null, hence it was rethrown in close()&lt;br/&gt;
    +	@Ignore&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnInvoke() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error thrown from invoke()
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			casSinkFunc.close();
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown when checkpoint performs if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnCheckpoint() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(casSinkFunc));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.snapshot(123L, 123L);
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			//expected async error from snapshotState()
    +
    +			Assert.assertTrue(e.getCause() instanceof IllegalStateException);
    +			Assert.assertTrue(e.getCause().getMessage().contains(&quot;Failed to send data to Cassandra&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			casSinkFunc.close();
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Multi Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that CassandraSinkBase would flush all in-flight message on close(), accompanied with concurrent&lt;br/&gt;
    +	 * message delivery successfully via a thraedpool.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testFlushOnPendingRecordsOnCloseWithSuccessfulMessage() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService threadPool = Executors.newFixedThreadPool(MAX_THREAD_POOL_SIZE);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; MAX_THREAD_NUM; i++) {&lt;br/&gt;
    +			threadPool.submit(() -&amp;gt; {&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +
    +					casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.DELAYED_SUCCESS);
    +				} catch (Exception e) {&lt;br/&gt;
    +					LOG.error(&quot;Error while dispatching sending message to Cassandra sink =&amp;gt; {} &quot;, e);&lt;br/&gt;
    +				}&lt;br/&gt;
    +			});&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		//wait until the first message has been dispatched and invoked&lt;br/&gt;
    +		Thread.sleep(500);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.close();&lt;br/&gt;
    +&lt;br/&gt;
    +		threadPool.shutdown();&lt;br/&gt;
    +		threadPool.awaitTermination(10, TimeUnit.SECONDS);&lt;br/&gt;
    +&lt;br/&gt;
    +		//Final pending updates should be zero&lt;br/&gt;
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that CassandraSinkBase would flush all in-flight message when checkpoint performs, accompanied&lt;br/&gt;
    +	 * with concurrent message delivery successfully via a thraedpool.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testFlushOnPendingRecordsOnCheckpoint() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService threadPool = Executors.newFixedThreadPool(MAX_THREAD_POOL_SIZE);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +				new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(casSinkFunc));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; MAX_THREAD_NUM; i++) {&lt;br/&gt;
    +			threadPool.submit(() -&amp;gt; {&lt;br/&gt;
    +				try {    +    +					casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.DELAYED_SUCCESS);    +				}
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
    +					LOG.error(&quot;Error while dispatching sending message to Cassandra sink =&amp;gt; {} &quot;, e);&lt;br/&gt;
    +				}&lt;br/&gt;
    +			});&lt;br/&gt;
    +			Thread.sleep(500);&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		//wait until the first message has been dispatched and invoked&lt;br/&gt;
    +		Thread.sleep(500);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.snapshot(123L, 123L);&lt;br/&gt;
    +&lt;br/&gt;
    +		threadPool.shutdown();&lt;br/&gt;
    +		threadPool.awaitTermination(10, TimeUnit.SECONDS);&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that CassandraSinkBase would NOT flush all in-flight message when checkpoint performs.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testDoNotFlushOnPendingRecordsOnCheckpoint() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService threadPool = Executors.newFixedThreadPool(MAX_THREAD_POOL_SIZE);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(false);&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(casSinkFunc));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; MAX_THREAD_NUM; i++) {&lt;br/&gt;
    +			threadPool.submit(() -&amp;gt; {&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +
    +					casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.DELAYED_SUCCESS);
    +				}
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
    +					LOG.error(&quot;Error while dispatching sending message to Cassandra sink =&amp;gt; {} &quot;, e);&lt;br/&gt;
    +				}&lt;br/&gt;
    +			});&lt;br/&gt;
    +			Thread.sleep(500);&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		//wait until the first message has been dispatched and invoked&lt;br/&gt;
    +		Thread.sleep(500);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.snapshot(123L, 123L);&lt;br/&gt;
    +		//Final pending records # &amp;gt; 0&lt;br/&gt;
    +		Assert.assertTrue(casSinkFunc.getNumOfPendingRecords() &amp;gt; 0);&lt;br/&gt;
    +&lt;br/&gt;
    +		threadPool.shutdown();&lt;br/&gt;
    +		threadPool.awaitTermination(10, TimeUnit.SECONDS);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that CassandraSinkBase would flush all in-flight message on close(), accompanied with concurrent&lt;br/&gt;
    +	 * thread dispatched message failure via a thraedpool.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    typo: thraedpool -&amp;gt; threadpool&lt;/p&gt;</comment>
                            <comment id="16170348" author="githubbot" created="Mon, 18 Sep 2017 17:23:30 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139484760&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139484760&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/main/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBase.java &amp;#8212;&lt;br/&gt;
    @@ -37,29 +41,49 @@&lt;br/&gt;
      *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param &amp;lt;IN&amp;gt; Type of the elements emitted by this sink&lt;br/&gt;
      */&lt;br/&gt;
    -public abstract class CassandraSinkBase&amp;lt;IN, V&amp;gt; extends RichSinkFunction&amp;lt;IN&amp;gt; {&lt;br/&gt;
    +public abstract class CassandraSinkBase&amp;lt;IN, V&amp;gt; extends RichSinkFunction&amp;lt;IN&amp;gt; implements CheckpointedFunction {&lt;br/&gt;
     	protected final Logger log = LoggerFactory.getLogger(getClass());&lt;br/&gt;
     	protected transient Cluster cluster;&lt;br/&gt;
     	protected transient Session session;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected transient volatile Throwable exception;&lt;br/&gt;
    +	protected transient volatile Throwable asyncError;&lt;br/&gt;
     	protected transient FutureCallback&amp;lt;V&amp;gt; callback;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final ClusterBuilder builder;&lt;br/&gt;
    +	protected final ClusterBuilder builder;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     	private final AtomicInteger updatesPending = new AtomicInteger();&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * If true, the producer will wait until all outstanding action requests have been sent to C*.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private boolean flushOnCheckpoint = true;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    this should be a constructor argument and final.&lt;/p&gt;</comment>
                            <comment id="16171231" author="githubbot" created="Tue, 19 Sep 2017 07:28:18 +0000"  >&lt;p&gt;Github user mcfongtw commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139615174&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139615174&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception &lt;/p&gt;
{
    +		ClusterBuilder builder = mock(ClusterBuilder.class);
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);
    +		casSinkFunc.setFlushOnCheckpoint(true);
    +		casSinkFunc.open(new Configuration());
    +
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +
    +		casSinkFunc.close();
    +
    +		//Final pending updates should be zero
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on close() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnClose() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +
    +			casSinkFunc.close();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error from close()
    +
    +			Assert.assertTrue(e.getMessage().contains(&quot;Error while sending value&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on invoke() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	//TODO: should unitfy error handling logic in CassandraSinkBase&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Will do. Thanks&lt;/p&gt;</comment>
                            <comment id="16171323" author="githubbot" created="Tue, 19 Sep 2017 08:44:06 +0000"  >&lt;p&gt;Github user mcfongtw commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139630504&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139630504&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/main/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBase.java &amp;#8212;&lt;br/&gt;
    @@ -37,29 +41,49 @@&lt;br/&gt;
      *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param &amp;lt;IN&amp;gt; Type of the elements emitted by this sink&lt;br/&gt;
      */&lt;br/&gt;
    -public abstract class CassandraSinkBase&amp;lt;IN, V&amp;gt; extends RichSinkFunction&amp;lt;IN&amp;gt; {&lt;br/&gt;
    +public abstract class CassandraSinkBase&amp;lt;IN, V&amp;gt; extends RichSinkFunction&amp;lt;IN&amp;gt; implements CheckpointedFunction {&lt;br/&gt;
     	protected final Logger log = LoggerFactory.getLogger(getClass());&lt;br/&gt;
     	protected transient Cluster cluster;&lt;br/&gt;
     	protected transient Session session;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected transient volatile Throwable exception;&lt;br/&gt;
    +	protected transient volatile Throwable asyncError;&lt;br/&gt;
     	protected transient FutureCallback&amp;lt;V&amp;gt; callback;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final ClusterBuilder builder;&lt;br/&gt;
    +	protected final ClusterBuilder builder;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     	private final AtomicInteger updatesPending = new AtomicInteger();&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * If true, the producer will wait until all outstanding action requests have been sent to C*.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private boolean flushOnCheckpoint = true;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Should we default this setting as true then? Making it final does not allow to reset the flag after obj is constructed. Further, should this behavior be applied to all other SinkBase / Producer classes in the future?&lt;/p&gt;</comment>
                            <comment id="16171344" author="githubbot" created="Tue, 19 Sep 2017 08:54:09 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139632915&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139632915&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/main/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBase.java &amp;#8212;&lt;br/&gt;
    @@ -37,29 +41,49 @@&lt;br/&gt;
      *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param &amp;lt;IN&amp;gt; Type of the elements emitted by this sink&lt;br/&gt;
      */&lt;br/&gt;
    -public abstract class CassandraSinkBase&amp;lt;IN, V&amp;gt; extends RichSinkFunction&amp;lt;IN&amp;gt; {&lt;br/&gt;
    +public abstract class CassandraSinkBase&amp;lt;IN, V&amp;gt; extends RichSinkFunction&amp;lt;IN&amp;gt; implements CheckpointedFunction {&lt;br/&gt;
     	protected final Logger log = LoggerFactory.getLogger(getClass());&lt;br/&gt;
     	protected transient Cluster cluster;&lt;br/&gt;
     	protected transient Session session;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected transient volatile Throwable exception;&lt;br/&gt;
    +	protected transient volatile Throwable asyncError;&lt;br/&gt;
     	protected transient FutureCallback&amp;lt;V&amp;gt; callback;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final ClusterBuilder builder;&lt;br/&gt;
    +	protected final ClusterBuilder builder;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     	private final AtomicInteger updatesPending = new AtomicInteger();&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * If true, the producer will wait until all outstanding action requests have been sent to C*.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private boolean flushOnCheckpoint = true;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    The default should be true. Every CassandraSinkBase subclass should accept a constructor argument that is passed on to the CassandraSinkBase constructor. Additionally, the CassandraSinkBuilder should be extended to allow setting this flag to false if desired.&lt;/p&gt;

</comment>
                            <comment id="16171509" author="githubbot" created="Tue, 19 Sep 2017 10:54:39 +0000"  >&lt;p&gt;Github user mcfongtw commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139658146&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139658146&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/main/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBase.java &amp;#8212;&lt;br/&gt;
    @@ -37,29 +41,49 @@&lt;br/&gt;
      *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param &amp;lt;IN&amp;gt; Type of the elements emitted by this sink&lt;br/&gt;
      */&lt;br/&gt;
    -public abstract class CassandraSinkBase&amp;lt;IN, V&amp;gt; extends RichSinkFunction&amp;lt;IN&amp;gt; {&lt;br/&gt;
    +public abstract class CassandraSinkBase&amp;lt;IN, V&amp;gt; extends RichSinkFunction&amp;lt;IN&amp;gt; implements CheckpointedFunction {&lt;br/&gt;
     	protected final Logger log = LoggerFactory.getLogger(getClass());&lt;br/&gt;
     	protected transient Cluster cluster;&lt;br/&gt;
     	protected transient Session session;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected transient volatile Throwable exception;&lt;br/&gt;
    +	protected transient volatile Throwable asyncError;&lt;br/&gt;
     	protected transient FutureCallback&amp;lt;V&amp;gt; callback;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final ClusterBuilder builder;&lt;br/&gt;
    +	protected final ClusterBuilder builder;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     	private final AtomicInteger updatesPending = new AtomicInteger();&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * If true, the producer will wait until all outstanding action requests have been sent to C*.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private boolean flushOnCheckpoint = true;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Got your points on the behaviors to subclasses to CassandraSinkBase, but I was wondering if some of these &apos;common behavior&apos; should be or would be unified across different data sink, KafKa ES, etc.  They all currently have slightly different implantation though. &lt;/p&gt;</comment>
                            <comment id="16171519" author="githubbot" created="Tue, 19 Sep 2017 11:05:12 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139660015&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139660015&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/main/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBase.java &amp;#8212;&lt;br/&gt;
    @@ -37,29 +41,49 @@&lt;br/&gt;
      *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param &amp;lt;IN&amp;gt; Type of the elements emitted by this sink&lt;br/&gt;
      */&lt;br/&gt;
    -public abstract class CassandraSinkBase&amp;lt;IN, V&amp;gt; extends RichSinkFunction&amp;lt;IN&amp;gt; {&lt;br/&gt;
    +public abstract class CassandraSinkBase&amp;lt;IN, V&amp;gt; extends RichSinkFunction&amp;lt;IN&amp;gt; implements CheckpointedFunction {&lt;br/&gt;
     	protected final Logger log = LoggerFactory.getLogger(getClass());&lt;br/&gt;
     	protected transient Cluster cluster;&lt;br/&gt;
     	protected transient Session session;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected transient volatile Throwable exception;&lt;br/&gt;
    +	protected transient volatile Throwable asyncError;&lt;br/&gt;
     	protected transient FutureCallback&amp;lt;V&amp;gt; callback;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final ClusterBuilder builder;&lt;br/&gt;
    +	protected final ClusterBuilder builder;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     	private final AtomicInteger updatesPending = new AtomicInteger();&lt;/p&gt;

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * If true, the producer will wait until all outstanding action requests have been sent to C*.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private boolean flushOnCheckpoint = true;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Ideally all sinks should behave the same way, but that would be out of scope for PR in particular.&lt;/p&gt;</comment>
                            <comment id="16171644" author="githubbot" created="Tue, 19 Sep 2017 13:06:06 +0000"  >&lt;p&gt;Github user mcfongtw commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139685362&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139685362&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception &lt;/p&gt;
{
    +		ClusterBuilder builder = mock(ClusterBuilder.class);
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);
    +		casSinkFunc.setFlushOnCheckpoint(true);
    +		casSinkFunc.open(new Configuration());
    +
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +
    +		casSinkFunc.close();
    +
    +		//Final pending updates should be zero
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on close() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnClose() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +
    +			casSinkFunc.close();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error from close()
    +
    +			Assert.assertTrue(e.getMessage().contains(&quot;Error while sending value&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on invoke() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	//TODO: should unitfy error handling logic in CassandraSinkBase&lt;br/&gt;
    +	//Exception would have been thrown from invoke(), but asyncError was not set null, hence it was rethrown in close()&lt;br/&gt;
    +	@Ignore&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnInvoke() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error thrown from invoke()
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			casSinkFunc.close();
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown when checkpoint performs if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnCheckpoint() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(casSinkFunc));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.snapshot(123L, 123L);
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			//expected async error from snapshotState()
    +
    +			Assert.assertTrue(e.getCause() instanceof IllegalStateException);
    +			Assert.assertTrue(e.getCause().getMessage().contains(&quot;Failed to send data to Cassandra&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			casSinkFunc.close();
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Multi Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that CassandraSinkBase would flush all in-flight message on close(), accompanied with concurrent&lt;br/&gt;
    +	 * message delivery successfully via a thraedpool.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testFlushOnPendingRecordsOnCloseWithSuccessfulMessage() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService threadPool = Executors.newFixedThreadPool(MAX_THREAD_POOL_SIZE);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Okay. I can get rid of those multi-threading tests with mocks to mimic scenarios to ensure it will wait upon flushing all pending records before checkpoint was triggered. &lt;/p&gt;</comment>
                            <comment id="16171647" author="githubbot" created="Tue, 19 Sep 2017 13:06:46 +0000"  >&lt;p&gt;Github user mcfongtw commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139685528&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139685528&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception &lt;/p&gt;
{
    +		ClusterBuilder builder = mock(ClusterBuilder.class);
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);
    +		casSinkFunc.setFlushOnCheckpoint(true);
    +		casSinkFunc.open(new Configuration());
    +
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +
    +		casSinkFunc.close();
    +
    +		//Final pending updates should be zero
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on close() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnClose() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +
    +			casSinkFunc.close();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error from close()
    +
    +			Assert.assertTrue(e.getMessage().contains(&quot;Error while sending value&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on invoke() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	//TODO: should unitfy error handling logic in CassandraSinkBase&lt;br/&gt;
    +	//Exception would have been thrown from invoke(), but asyncError was not set null, hence it was rethrown in close()&lt;br/&gt;
    +	@Ignore&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnInvoke() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error thrown from invoke()
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			casSinkFunc.close();
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown when checkpoint performs if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnCheckpoint() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(casSinkFunc));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.snapshot(123L, 123L);
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			//expected async error from snapshotState()
    +
    +			Assert.assertTrue(e.getCause() instanceof IllegalStateException);
    +			Assert.assertTrue(e.getCause().getMessage().contains(&quot;Failed to send data to Cassandra&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			casSinkFunc.close();
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Multi Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that CassandraSinkBase would flush all in-flight message on close(), accompanied with concurrent&lt;br/&gt;
    +	 * message delivery successfully via a thraedpool.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testFlushOnPendingRecordsOnCloseWithSuccessfulMessage() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		ExecutorService threadPool = Executors.newFixedThreadPool(MAX_THREAD_POOL_SIZE);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; MAX_THREAD_NUM; i++) {&lt;br/&gt;
    +			threadPool.submit(() -&amp;gt; {&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +
    +					casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.DELAYED_SUCCESS);
    +				}
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
    +					LOG.error(&quot;Error while dispatching sending message to Cassandra sink =&amp;gt; {} &quot;, e);&lt;br/&gt;
    +				}&lt;br/&gt;
    +			});&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		//wait until the first message has been dispatched and invoked&lt;br/&gt;
    +		Thread.sleep(500);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Will rewrite these with more deterministic way, similar from the comment above. &lt;/p&gt;</comment>
                            <comment id="16173073" author="githubbot" created="Wed, 20 Sep 2017 12:09:09 +0000"  >&lt;p&gt;Github user mcfongtw commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605#discussion_r139950435&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605#discussion_r139950435&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-cassandra/src/test/java/org/apache/flink/streaming/connectors/cassandra/CassandraSinkBaseTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,469 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
    + * contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
    + * this work for additional information regarding copyright ownership.&lt;br/&gt;
    + * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
    + * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
    + * the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.connectors.cassandra;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.StreamSink;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.datastax.driver.core.Cluster;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSet;&lt;br/&gt;
    +import com.datastax.driver.core.ResultSetFuture;&lt;br/&gt;
    +import com.datastax.driver.core.Session;&lt;br/&gt;
    +import com.datastax.driver.core.exceptions.NoHostAvailableException;&lt;br/&gt;
    +import com.google.common.util.concurrent.ListenableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Assert;&lt;br/&gt;
    +import org.junit.BeforeClass;&lt;br/&gt;
    +import org.junit.Ignore;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.slf4j.Logger;&lt;br/&gt;
    +import org.slf4j.LoggerFactory;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.concurrent.ExecutorService;&lt;br/&gt;
    +import java.util.concurrent.Executors;&lt;br/&gt;
    +import java.util.concurrent.TimeUnit;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.mockito.Mockito.mock;&lt;br/&gt;
    +import static org.powermock.api.mockito.PowerMockito.when;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the &lt;/p&gt;
{@link CassandraSinkBase}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class CassandraSinkBaseTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final Logger LOG = LoggerFactory.getLogger(CassandraSinkBaseTest.class);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_QUERY_STMT = &quot;CQL_Dummy_Stmt&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final String DUMMY_MESSAGE = &quot;Dummy_msg&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_NUM = 3;&lt;br/&gt;
    +&lt;br/&gt;
    +	private static final int MAX_THREAD_POOL_SIZE = 2;&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doSetUp() throws Exception &lt;/p&gt;
{
    +
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@BeforeClass&lt;br/&gt;
    +	public static void doTearDown() throws Exception {    +    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures a NoHostAvailableException would be thrown if a contact point added does not exist.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test(expected = NoHostAvailableException.class)&lt;br/&gt;
    +	public void testCasHostNotFoundErrorHandling() throws Exception {&lt;br/&gt;
    +		CassandraSinkBase base = new DummyCassandraSinkBase&amp;lt;&amp;gt;(new ClusterBuilder() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			protected Cluster buildCluster(Cluster.Builder builder) &lt;/p&gt;
{
    +				return builder
    +					.addContactPoint(&quot;127.0.0.1&quot;)
    +					.withoutJMXReporting()
    +					.withoutMetrics().build();
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		base.open(new Configuration());&lt;br/&gt;
    +		base.close();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +	// Single Thread Test&lt;br/&gt;
    +	///////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures the message could be delivered successfully to sink.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSimpleSuccessfulPath() throws Exception &lt;/p&gt;
{
    +		ClusterBuilder builder = mock(ClusterBuilder.class);
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);
    +		casSinkFunc.setFlushOnCheckpoint(true);
    +		casSinkFunc.open(new Configuration());
    +
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_SUCCESS);
    +
    +		casSinkFunc.close();
    +
    +		//Final pending updates should be zero
    +		Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensures that an asyncError would be thrown on close() if previously message delivery failed.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorThrownOnClose() throws Exception {&lt;br/&gt;
    +		ClusterBuilder builder = mock(ClusterBuilder.class);&lt;br/&gt;
    +		MockCassandraSinkBase casSinkFunc = new MockCassandraSinkBase&amp;lt;&amp;gt;(builder);&lt;br/&gt;
    +		casSinkFunc.setFlushOnCheckpoint(true);&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.open(new Configuration());&lt;br/&gt;
    +&lt;br/&gt;
    +		casSinkFunc.invokeWithImmediateResult(DUMMY_MESSAGE, PredeterminedResult.IMMEDIATE_FAILURE);&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +
    +			casSinkFunc.close();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			//expected async error from close()
    +
    +			Assert.assertTrue(e.getMessage().contains(&quot;Error while sending value&quot;));
    +
    +			//Final pending updates should be zero
    +			Assert.assertEquals(0, casSinkFunc.getNumOfPendingRecords());
    +
    +			//done
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    That is right. Thanks.&lt;/p&gt;</comment>
                            <comment id="16182579" author="githubbot" created="Wed, 27 Sep 2017 13:43:58 +0000"  >&lt;p&gt;Github user mcfongtw commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @zentol, could you also take another look if the revision has addressed the concerns? Thank you.&lt;/p&gt;</comment>
                            <comment id="16241624" author="githubbot" created="Tue, 7 Nov 2017 07:31:29 +0000"  >&lt;p&gt;Github user mcfongtw commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Hi, @zentol, since there are some conflicts in this branch and a bit out of date from current master, I will rebase on this branch. However, I need to know if you are planning to review and merge this PR recently; otherwise, I could do that in later time. &lt;/p&gt;</comment>
                            <comment id="16243753" author="githubbot" created="Wed, 8 Nov 2017 11:18:28 +0000"  >&lt;p&gt;Github user zentol commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I&apos;ve rebased this locally (along with some cleanup) and will merge it later today.&lt;/p&gt;</comment>
                            <comment id="16244995" author="githubbot" created="Thu, 9 Nov 2017 00:25:11 +0000"  >&lt;p&gt;Github user mcfongtw commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @zentol , cool! Thanks for reviewing it!&lt;/p&gt;</comment>
                            <comment id="16247304" author="githubbot" created="Fri, 10 Nov 2017 10:10:58 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16247305" author="zentol" created="Fri, 10 Nov 2017 10:11:18 +0000"  >&lt;p&gt;1.4: 896f13da1d35fcae46600eb54a055bbfd6f6e8fc&lt;br/&gt;
1.5: 775d7fed1ac8230c92997ead3c702004679614a4&lt;/p&gt;</comment>
                            <comment id="16247315" author="githubbot" created="Fri, 10 Nov 2017 10:20:29 +0000"  >&lt;p&gt;Github user zentol commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I had to modify the PR more than i initially expected.&lt;/p&gt;

&lt;p&gt;    I removed the option to disable the new behavior again; after thinking about it more i came to the conclusion that silently losing data is never an acceptable behavior.&lt;br/&gt;
    I also rewrote the tests to be more straight-forward. &lt;/p&gt;</comment>
                            <comment id="16248266" author="githubbot" created="Sat, 11 Nov 2017 01:44:12 +0000"  >&lt;p&gt;Github user mcfongtw commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4605&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4605&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Hi, @zentol , thanks for reviewing this PR. I recalled that I put a &lt;span class=&quot;error&quot;&gt;&amp;#91;caveat &amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-release-1.4/dev/connectors/cassandra.html#checkpointing-and-fault-tolerance)about&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://ci.apache.org/projects/flink/flink-docs-release-1.4/dev/connectors/cassandra.html#checkpointing-and-fault-tolerance)about&lt;/a&gt; this potential data loss in the latest C* connector documents. Since this fix is committed, would you like me to open another PR just to remove that warning message from document?&lt;/p&gt;</comment>
                            <comment id="16249046" author="githubbot" created="Mon, 13 Nov 2017 02:24:52 +0000"  >&lt;p&gt;GitHub user mcfongtw opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5002&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5002&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;hotfix&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;docs&amp;#93;&lt;/span&gt; Remove the caveat about Cassandra connector.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    Remove a caveat in Cassandra connector docs.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    As &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-4500&quot; title=&quot;Cassandra sink can lose messages&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-4500&quot;&gt;&lt;del&gt;FLINK-4500&lt;/del&gt;&lt;/a&gt; being committed, Cassandra connector would now flush pending mutations properly when a checkpoint was triggered. Thus, remove the related caveat from documents. &lt;/p&gt;





&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/mcfongtw/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/mcfongtw/flink&lt;/a&gt; hotfix-doc&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5002.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5002.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #5002&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit e6d13baa2544c1ac0504199f685b12872451d0e1&lt;br/&gt;
Author: Michael Fong &amp;lt;mcfong.open@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-11-13T02:17:02Z&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;hotfix&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;docs&amp;#93;&lt;/span&gt; Remove the caveat about Cassandra connector.&lt;/p&gt;

&lt;p&gt;    As &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-4500&quot; title=&quot;Cassandra sink can lose messages&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-4500&quot;&gt;&lt;del&gt;FLINK-4500&lt;/del&gt;&lt;/a&gt; being committed, Cassandra connector would now flush pending mutations properly when a checkpoint was triggered.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16251434" author="githubbot" created="Tue, 14 Nov 2017 14:17:23 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5002&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5002&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 1 week ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i32tfz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>