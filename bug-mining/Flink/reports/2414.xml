<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:33:25 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-8780] Add Broadcast State documentation.</title>
                <link>https://issues.apache.org/jira/browse/FLINK-8780</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description></description>
                <environment></environment>
        <key id="13140913">FLINK-8780</key>
            <summary>Add Broadcast State documentation.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kkl0u">Kostas Kloudas</assignee>
                                    <reporter username="kkl0u">Kostas Kloudas</reporter>
                        <labels>
                    </labels>
                <created>Mon, 26 Feb 2018 12:45:46 +0000</created>
                <updated>Thu, 28 Feb 2019 10:45:57 +0000</updated>
                            <resolved>Mon, 14 May 2018 12:13:00 +0000</resolved>
                                    <version>1.5.0</version>
                                    <fixVersion>1.5.0</fixVersion>
                                    <component>API / DataStream</component>
                    <component>Documentation</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16454392" author="githubbot" created="Thu, 26 Apr 2018 15:25:25 +0000"  >&lt;p&gt;GitHub user kl0u opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8780&quot; title=&quot;Add Broadcast State documentation.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8780&quot;&gt;&lt;del&gt;FLINK-8780&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;docs&amp;#93;&lt;/span&gt; Add Broadcast State documentation.&lt;/p&gt;

&lt;p&gt;    R @fhueske &lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/kl0u/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/kl0u/flink&lt;/a&gt; broadcast-docs-inv2&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #5922&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 678d6904e4560e8dcd6884e0b8f4d5cef61baa62&lt;br/&gt;
Author: kkloudas &amp;lt;kkloudas@...&amp;gt;&lt;br/&gt;
Date:   2018-04-26T10:23:58Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8780&quot; title=&quot;Add Broadcast State documentation.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8780&quot;&gt;&lt;del&gt;FLINK-8780&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;docs&amp;#93;&lt;/span&gt; Add Broadcast State documentation.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16458516" author="githubbot" created="Mon, 30 Apr 2018 12:23:21 +0000"  >&lt;p&gt;Github user alpinegizmo commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r184969718&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r184969718&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,281 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) described operator state which is either *&lt;b&gt;evenly&lt;/b&gt;* distributed among the parallel&lt;br/&gt;
    +tasks of an operator, or state which *&lt;b&gt;upon restore&lt;/b&gt;&lt;b&gt;, its partial (task) states are **unioned&lt;/b&gt;* and the whole state is &lt;br/&gt;
    +used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use-cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use-cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to streams whose elements are &lt;b&gt;broadcasted&lt;/b&gt;,&lt;br/&gt;
    + 3. the only operation available to a stream with broadcast state is to be &lt;b&gt;connected&lt;/b&gt; to another keyed or non-keyed stream,&lt;br/&gt;
    + 4. such a broadcast stream can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolve over time. &lt;br/&gt;
    +&lt;br/&gt;
    +In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other&lt;br/&gt;
    +stream will contain the `Rules`.&lt;br/&gt;
    +&lt;br/&gt;
    +Starting from the stream of `Items`, we just need to &lt;b&gt;key it&lt;/b&gt; by `Color`, as we want pairs of the same color. This will&lt;br/&gt;
    +make sure that elements of the same color end up on the same physical machine.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +// key the shapes by color&lt;br/&gt;
    +KeyedStream&amp;lt;Item, Color&amp;gt; colorPartitionedStream = shapeStream&lt;br/&gt;
    +                        .keyBy(new KeySelector&amp;lt;Shape, Color&amp;gt;(){...});&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks &lt;br/&gt;
    +should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast &lt;br/&gt;
    +the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules&lt;br/&gt;
    +will be stored.&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +&lt;br/&gt;
    +// a map descriptor to store the name of the rule (string) and the rule itself.&lt;br/&gt;
    +MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +				&quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +				BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +				TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {})&lt;br/&gt;
    +		);&lt;br/&gt;
    +		&lt;br/&gt;
    +// broadcast the rules and create the broadcast state&lt;br/&gt;
    +BroadcastStream&amp;lt;Rule&amp;gt; ruleBroadcastStream = ruleStream&lt;br/&gt;
    +                        .broadcast(ruleStateDescriptor);&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in order to evaluate the `Rules` against the incoming elements from the `Item` stream, we need to:&lt;br/&gt;
    +    1) connect the two streams and &lt;br/&gt;
    +    2) specify our match detecting logic. &lt;br/&gt;
    +&lt;br/&gt;
    +Connecting a stream (keyed or non-keyed) with a `BroadcastStream` can be done by calling `connect()` on the &lt;br/&gt;
    +non-broadcasted stream, with the `BroadcastStream` as an argument. This will return a `BroadcastConnectedStream`, on &lt;br/&gt;
    +which we can call `process()` with a special type of `CoProcessFunction`. The function will contain our matching logic. &lt;br/&gt;
    +The exact type of the function depends on the type of the non-broadcasted stream: &lt;br/&gt;
    + - if that is *&lt;b&gt;keyed&lt;/b&gt;*, then the function is a `KeyedBroadcastProcessFunction`. &lt;br/&gt;
    + - if it is *&lt;b&gt;non-keyed&lt;/b&gt;*, the function is a `BroadcastProcessFunction`. &lt;br/&gt;
    + &lt;br/&gt;
    + Given that our non-broadcasted stream is keyed, the following snippet includes the above calls:&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The connect should be called on the non-broadcasted stream, with the `BroadcastStream`&lt;br/&gt;
    +   as an argument.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +DataStream&amp;lt;Match&amp;gt; output = colorPartitionedStream&lt;br/&gt;
    +                 .connect(ruleBroadcastStream)&lt;br/&gt;
    +                 .process(&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     // type arguments in our KeyedBroadcastProcessFunction represent: &lt;br/&gt;
    +                     //   1. the key of the keyed stream&lt;br/&gt;
    +                     //   2. the type of elements in the non-broadcast side&lt;br/&gt;
    +                     //   3. the type of elements in the broadcast side&lt;br/&gt;
    +                     //   4. the type of the result, here a string&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {
    +                         // my matching logic
    +                     }&lt;br/&gt;
    +                 )&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +### BroadcastProcessFunction and KeyedBroadcastProcessFunction&lt;br/&gt;
    +&lt;br/&gt;
    +As in the case of a `CoProcessFunction`, these methods have two &quot;sides&quot;, one is responsible for processing incoming &lt;br/&gt;
    +elements in the broadcasted stream and one is used for the non-broadcasted one. This is reflected in the methods to be &lt;br/&gt;
    +implemented, which are presented below.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +public abstract class BroadcastProcessFunction&amp;lt;IN1, IN2, OUT&amp;gt; extends BaseBroadcastProcessFunction {
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +public abstract class KeyedBroadcastProcessFunction&amp;lt;KS, IN1, IN2, OUT&amp;gt; &lt;/p&gt;
{
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public void onTimer(long timestamp, OnTimerContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}
&lt;p&gt;    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +The first thing to notice is that both functions require the implementation of the `processBroadcastElement()` method &lt;br/&gt;
    +for processing elements in the broadcast side and the `processElement()` for elements in the non-broadcasted side. &lt;br/&gt;
    +&lt;br/&gt;
    +The two methods differ in the context they are provided. The non-broadcast side has a `ReadOnlyContext`, while the &lt;br/&gt;
    +broadcasted side has a `Context`. &lt;br/&gt;
    +&lt;br/&gt;
    +Both of these contexts (`ctx` in the following enumeration):&lt;br/&gt;
    + 1. give access to the broadcast state: `ctx.getBroadcastState(MapStateDescriptor&amp;lt;K, V&amp;gt; stateDescriptor)`&lt;br/&gt;
    + 2. allow to query the timestamp of the element: `ctx.timestamp()`, &lt;br/&gt;
    + 3. get the current watermark: `ctx.currentWatermark()`&lt;br/&gt;
    + 4. get the current processing time: `ctx.currentProcessingTime()`, and &lt;br/&gt;
    + 5. emit elements to side-outputs: `ctx.output(OutputTag&amp;lt;X&amp;gt; outputTag, X value)`. &lt;br/&gt;
    +&lt;br/&gt;
    +The `stateDescriptor` in the `getBroadcastState()` should be identical to the one in the `.broadcast(ruleStateDescriptor)` &lt;br/&gt;
    +above.&lt;br/&gt;
    +&lt;br/&gt;
    +The difference lies in the type of access each one gives to the broadcast state. The broadcasted side has &lt;br/&gt;
    +*&lt;b&gt;read-write access&lt;/b&gt;* to it, while the non-broadcast side has *&lt;b&gt;read-only access&lt;/b&gt;* (thus the names). The reason for this&lt;br/&gt;
    +is that in Flink there is no cross-task communication. So, to guarantee that the contents in the Broadcast State are the&lt;br/&gt;
    +same across all parallel instances of our operator, we give read-write access only to the broadcast side, which sees the&lt;br/&gt;
    +same elements across all tasks, and we require the computation on each incoming element on that side to be identical &lt;br/&gt;
    +across all tasks. Ignoring this rule would break the consistency guarantees of the state, leading to inconsistent and &lt;br/&gt;
    +often difficult to debug results.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The logic implemented in `processBroadcast()` must have the same determinstic behavior &lt;br/&gt;
    +  across all parallel instances!&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, due to the fact that the `KeyedBroadcastProcessFunction` is (on one &quot;side&quot;) operating on a keyed stream, it &lt;br/&gt;
    +exposes some functionality which is not available to the `BroadcastProcessFunction`. That is:&lt;br/&gt;
    + 1. the `ReadOnlyContext` in the `processElement()` method gives access to Flink&apos;s underlying timer service, which allows&lt;br/&gt;
    +  to register event and/or processing time timers. When a timer fires, the `onTimer()` (shown above) is invoked with an &lt;br/&gt;
    +  `OnTimerContext` which exposes the same functionality as the `ReadOnlyContext` plus &lt;br/&gt;
    +   - the ability to ask if the timer that fired was an event or processing time one and &lt;br/&gt;
    +   - to query the key associated with the timer.&lt;br/&gt;
    +&lt;br/&gt;
    +  This is aligned with the `onTimer()` method of the `KeyedProcessFunction`. &lt;br/&gt;
    + 2. the `Context` in the `processBroadcastElement()` method contains the method &lt;br/&gt;
    + `applyToKeyedState(StateDescriptor&amp;lt;S, VS&amp;gt; stateDescriptor, KeyedStateFunction&amp;lt;KS, S&amp;gt; function)`. This allows to &lt;br/&gt;
    +  register a `KeyedStateFunction` to be *&lt;b&gt;applied to all states of all keys&lt;/b&gt;* associated with the provided `stateDescriptor`. &lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; Registering timers is only possible at `processElement()` of the `KeyedBroadcastProcessFunction`&lt;br/&gt;
    +  and only there. It is not possible in the `processBroadcastElement()` method, as there is no key associated to the &lt;br/&gt;
    +  broadcasted elements.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +  &lt;br/&gt;
    +Coming back to our original example, our `KeyedBroadcastProcessFunction` could look like the following:&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +    // store partial matches, i.e. first elements of the pair waiting for their second element&lt;br/&gt;
    +    // we keep a list as we may have many first elements waiting&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; mapStateDesc =&lt;br/&gt;
    +	    new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +	        &quot;items&quot;,&lt;br/&gt;
    +	        BasicTypeInfo.STRING_TYPE_INFO, &lt;br/&gt;
    +	        new ListTypeInfo&amp;lt;&amp;gt;(Item.class));&lt;br/&gt;
    +&lt;br/&gt;
    +    // identical to our ruleStateDescriptor above&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = &lt;br/&gt;
    +        new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +    	    &quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +    		BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +    		TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {}));&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processBroadcastElement(Rule value, &lt;br/&gt;
    +	                                    Context ctx, &lt;br/&gt;
    +	                                    Collector&amp;lt;String&amp;gt; out) throws Exception {
    +	    ctx.getBroadcastState(ruleStateDescriptor).put(value.name, value);
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processElement(Item value, &lt;br/&gt;
    +	                           ReadOnlyContext ctx, &lt;br/&gt;
    +	                           Collector&amp;lt;String&amp;gt; out) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +        final MapState&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; state = getRuntimeContext().getMapState(mapStateDesc);&lt;br/&gt;
    +        final Shape shape = value.getShape();&lt;br/&gt;
    +    &lt;br/&gt;
    +        for (Map.Entry&amp;lt;String, Rule&amp;gt; entry: &lt;br/&gt;
    +                ctx.getBroadcastState(ruleStateDescriptor).immutableEntries()) {&lt;br/&gt;
    +            final String ruleName = entry.getKey();&lt;br/&gt;
    +            final Rule rule = entry.getValue();&lt;br/&gt;
    +    &lt;br/&gt;
    +            List&amp;lt;Item&amp;gt; stored = state.get(ruleName);&lt;br/&gt;
    +            if (stored == null) {
    +                stored = new ArrayList&amp;lt;&amp;gt;();
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (shape == rule.second &amp;amp;&amp;amp; !stored.isEmpty()) {&lt;br/&gt;
    +                for (Item i : stored) {
    +                    out.collect(&quot;MATCH: &quot; + i + &quot; - &quot; + value);
    +                }&lt;br/&gt;
    +                stored.clear();&lt;br/&gt;
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            // there is  no else{} to cover if rule.first == rule.second&lt;br/&gt;
    +            if (shape.equals(rule.first)) {
    +                stored.add(value);
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (stored.isEmpty()) {
    +                state.remove(ruleName);
    +            } else {
    +                state.put(ruleName, stored);
    +            }&lt;br/&gt;
    +        }&lt;br/&gt;
    +	}&lt;br/&gt;
    +}&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +## Important Considerations&lt;br/&gt;
    +&lt;br/&gt;
    +After describing the offered APIs, this section focuses on the important things to keep in mind when using broadcast &lt;br/&gt;
    +state. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;There is no cross-task communication:&lt;/b&gt;* As stated earlier, this is the reason why only the broadcast side of a &lt;br/&gt;
    +`(Keyed)-BroadcastProcessFunction` can modify the contents of the broadcast state. In addition, the user has to make &lt;br/&gt;
    +sure that all tasks modify the contents of the broadcast state in the same way for each incoming element. In other &lt;br/&gt;
    +case, different tasks may have different contents, which can lead to inconsistent results.&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;Order of events in Broadcast State may differ across tasks:&lt;/b&gt;* Although broadcasting the elements of a stream &lt;br/&gt;
    +guarantees that all elements will go to all downstream tasks, elements may arrive in different order on each task. This&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    ... may arrive in a different order on each task&lt;/p&gt;</comment>
                            <comment id="16458517" author="githubbot" created="Mon, 30 Apr 2018 12:23:21 +0000"  >&lt;p&gt;Github user alpinegizmo commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r184971409&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r184971409&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,281 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) described operator state which is either *&lt;b&gt;evenly&lt;/b&gt;* distributed among the parallel&lt;br/&gt;
    +tasks of an operator, or state which *&lt;b&gt;upon restore&lt;/b&gt;&lt;b&gt;, its partial (task) states are **unioned&lt;/b&gt;* and the whole state is &lt;br/&gt;
    +used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I find this intro paragraph confusing. Would it be correct to rewrite it like this?&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) describes operator state which *&lt;b&gt;upon restore&lt;/b&gt;* is either *&lt;b&gt;evenly&lt;/b&gt;* distributed among the parallel tasks of an operator, or *&lt;b&gt;unioned&lt;/b&gt;*, with the whole state being used to initialize the restored parallel tasks.&lt;/p&gt;</comment>
                            <comment id="16458518" author="githubbot" created="Mon, 30 Apr 2018 12:23:21 +0000"  >&lt;p&gt;Github user alpinegizmo commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r184970245&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r184970245&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,281 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) described operator state which is either *&lt;b&gt;evenly&lt;/b&gt;* distributed among the parallel&lt;br/&gt;
    +tasks of an operator, or state which *&lt;b&gt;upon restore&lt;/b&gt;&lt;b&gt;, its partial (task) states are **unioned&lt;/b&gt;* and the whole state is &lt;br/&gt;
    +used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use-cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use-cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to streams whose elements are &lt;b&gt;broadcasted&lt;/b&gt;,&lt;br/&gt;
    + 3. the only operation available to a stream with broadcast state is to be &lt;b&gt;connected&lt;/b&gt; to another keyed or non-keyed stream,&lt;br/&gt;
    + 4. such a broadcast stream can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolve over time. &lt;br/&gt;
    +&lt;br/&gt;
    +In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other&lt;br/&gt;
    +stream will contain the `Rules`.&lt;br/&gt;
    +&lt;br/&gt;
    +Starting from the stream of `Items`, we just need to &lt;b&gt;key it&lt;/b&gt; by `Color`, as we want pairs of the same color. This will&lt;br/&gt;
    +make sure that elements of the same color end up on the same physical machine.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +// key the shapes by color&lt;br/&gt;
    +KeyedStream&amp;lt;Item, Color&amp;gt; colorPartitionedStream = shapeStream&lt;br/&gt;
    +                        .keyBy(new KeySelector&amp;lt;Shape, Color&amp;gt;(){...});&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks &lt;br/&gt;
    +should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast &lt;br/&gt;
    +the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules&lt;br/&gt;
    +will be stored.&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +&lt;br/&gt;
    +// a map descriptor to store the name of the rule (string) and the rule itself.&lt;br/&gt;
    +MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +				&quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +				BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +				TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {})&lt;br/&gt;
    +		);&lt;br/&gt;
    +		&lt;br/&gt;
    +// broadcast the rules and create the broadcast state&lt;br/&gt;
    +BroadcastStream&amp;lt;Rule&amp;gt; ruleBroadcastStream = ruleStream&lt;br/&gt;
    +                        .broadcast(ruleStateDescriptor);&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in order to evaluate the `Rules` against the incoming elements from the `Item` stream, we need to:&lt;br/&gt;
    +    1) connect the two streams and &lt;br/&gt;
    +    2) specify our match detecting logic. &lt;br/&gt;
    +&lt;br/&gt;
    +Connecting a stream (keyed or non-keyed) with a `BroadcastStream` can be done by calling `connect()` on the &lt;br/&gt;
    +non-broadcasted stream, with the `BroadcastStream` as an argument. This will return a `BroadcastConnectedStream`, on &lt;br/&gt;
    +which we can call `process()` with a special type of `CoProcessFunction`. The function will contain our matching logic. &lt;br/&gt;
    +The exact type of the function depends on the type of the non-broadcasted stream: &lt;br/&gt;
    + - if that is *&lt;b&gt;keyed&lt;/b&gt;*, then the function is a `KeyedBroadcastProcessFunction`. &lt;br/&gt;
    + - if it is *&lt;b&gt;non-keyed&lt;/b&gt;*, the function is a `BroadcastProcessFunction`. &lt;br/&gt;
    + &lt;br/&gt;
    + Given that our non-broadcasted stream is keyed, the following snippet includes the above calls:&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The connect should be called on the non-broadcasted stream, with the `BroadcastStream`&lt;br/&gt;
    +   as an argument.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +DataStream&amp;lt;Match&amp;gt; output = colorPartitionedStream&lt;br/&gt;
    +                 .connect(ruleBroadcastStream)&lt;br/&gt;
    +                 .process(&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     // type arguments in our KeyedBroadcastProcessFunction represent: &lt;br/&gt;
    +                     //   1. the key of the keyed stream&lt;br/&gt;
    +                     //   2. the type of elements in the non-broadcast side&lt;br/&gt;
    +                     //   3. the type of elements in the broadcast side&lt;br/&gt;
    +                     //   4. the type of the result, here a string&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {
    +                         // my matching logic
    +                     }&lt;br/&gt;
    +                 )&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +### BroadcastProcessFunction and KeyedBroadcastProcessFunction&lt;br/&gt;
    +&lt;br/&gt;
    +As in the case of a `CoProcessFunction`, these methods have two &quot;sides&quot;, one is responsible for processing incoming &lt;br/&gt;
    +elements in the broadcasted stream and one is used for the non-broadcasted one. This is reflected in the methods to be &lt;br/&gt;
    +implemented, which are presented below.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +public abstract class BroadcastProcessFunction&amp;lt;IN1, IN2, OUT&amp;gt; extends BaseBroadcastProcessFunction {
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +public abstract class KeyedBroadcastProcessFunction&amp;lt;KS, IN1, IN2, OUT&amp;gt; &lt;/p&gt;
{
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public void onTimer(long timestamp, OnTimerContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}
&lt;p&gt;    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +The first thing to notice is that both functions require the implementation of the `processBroadcastElement()` method &lt;br/&gt;
    +for processing elements in the broadcast side and the `processElement()` for elements in the non-broadcasted side. &lt;br/&gt;
    +&lt;br/&gt;
    +The two methods differ in the context they are provided. The non-broadcast side has a `ReadOnlyContext`, while the &lt;br/&gt;
    +broadcasted side has a `Context`. &lt;br/&gt;
    +&lt;br/&gt;
    +Both of these contexts (`ctx` in the following enumeration):&lt;br/&gt;
    + 1. give access to the broadcast state: `ctx.getBroadcastState(MapStateDescriptor&amp;lt;K, V&amp;gt; stateDescriptor)`&lt;br/&gt;
    + 2. allow to query the timestamp of the element: `ctx.timestamp()`, &lt;br/&gt;
    + 3. get the current watermark: `ctx.currentWatermark()`&lt;br/&gt;
    + 4. get the current processing time: `ctx.currentProcessingTime()`, and &lt;br/&gt;
    + 5. emit elements to side-outputs: `ctx.output(OutputTag&amp;lt;X&amp;gt; outputTag, X value)`. &lt;br/&gt;
    +&lt;br/&gt;
    +The `stateDescriptor` in the `getBroadcastState()` should be identical to the one in the `.broadcast(ruleStateDescriptor)` &lt;br/&gt;
    +above.&lt;br/&gt;
    +&lt;br/&gt;
    +The difference lies in the type of access each one gives to the broadcast state. The broadcasted side has &lt;br/&gt;
    +*&lt;b&gt;read-write access&lt;/b&gt;* to it, while the non-broadcast side has *&lt;b&gt;read-only access&lt;/b&gt;* (thus the names). The reason for this&lt;br/&gt;
    +is that in Flink there is no cross-task communication. So, to guarantee that the contents in the Broadcast State are the&lt;br/&gt;
    +same across all parallel instances of our operator, we give read-write access only to the broadcast side, which sees the&lt;br/&gt;
    +same elements across all tasks, and we require the computation on each incoming element on that side to be identical &lt;br/&gt;
    +across all tasks. Ignoring this rule would break the consistency guarantees of the state, leading to inconsistent and &lt;br/&gt;
    +often difficult to debug results.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The logic implemented in `processBroadcast()` must have the same determinstic behavior &lt;br/&gt;
    +  across all parallel instances!&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, due to the fact that the `KeyedBroadcastProcessFunction` is (on one &quot;side&quot;) operating on a keyed stream, it &lt;br/&gt;
    +exposes some functionality which is not available to the `BroadcastProcessFunction`. That is:&lt;br/&gt;
    + 1. the `ReadOnlyContext` in the `processElement()` method gives access to Flink&apos;s underlying timer service, which allows&lt;br/&gt;
    +  to register event and/or processing time timers. When a timer fires, the `onTimer()` (shown above) is invoked with an &lt;br/&gt;
    +  `OnTimerContext` which exposes the same functionality as the `ReadOnlyContext` plus &lt;br/&gt;
    +   - the ability to ask if the timer that fired was an event or processing time one and &lt;br/&gt;
    +   - to query the key associated with the timer.&lt;br/&gt;
    +&lt;br/&gt;
    +  This is aligned with the `onTimer()` method of the `KeyedProcessFunction`. &lt;br/&gt;
    + 2. the `Context` in the `processBroadcastElement()` method contains the method &lt;br/&gt;
    + `applyToKeyedState(StateDescriptor&amp;lt;S, VS&amp;gt; stateDescriptor, KeyedStateFunction&amp;lt;KS, S&amp;gt; function)`. This allows to &lt;br/&gt;
    +  register a `KeyedStateFunction` to be *&lt;b&gt;applied to all states of all keys&lt;/b&gt;* associated with the provided `stateDescriptor`. &lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; Registering timers is only possible at `processElement()` of the `KeyedBroadcastProcessFunction`&lt;br/&gt;
    +  and only there. It is not possible in the `processBroadcastElement()` method, as there is no key associated to the &lt;br/&gt;
    +  broadcasted elements.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +  &lt;br/&gt;
    +Coming back to our original example, our `KeyedBroadcastProcessFunction` could look like the following:&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +    // store partial matches, i.e. first elements of the pair waiting for their second element&lt;br/&gt;
    +    // we keep a list as we may have many first elements waiting&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; mapStateDesc =&lt;br/&gt;
    +	    new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +	        &quot;items&quot;,&lt;br/&gt;
    +	        BasicTypeInfo.STRING_TYPE_INFO, &lt;br/&gt;
    +	        new ListTypeInfo&amp;lt;&amp;gt;(Item.class));&lt;br/&gt;
    +&lt;br/&gt;
    +    // identical to our ruleStateDescriptor above&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = &lt;br/&gt;
    +        new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +    	    &quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +    		BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +    		TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {}));&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processBroadcastElement(Rule value, &lt;br/&gt;
    +	                                    Context ctx, &lt;br/&gt;
    +	                                    Collector&amp;lt;String&amp;gt; out) throws Exception {
    +	    ctx.getBroadcastState(ruleStateDescriptor).put(value.name, value);
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processElement(Item value, &lt;br/&gt;
    +	                           ReadOnlyContext ctx, &lt;br/&gt;
    +	                           Collector&amp;lt;String&amp;gt; out) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +        final MapState&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; state = getRuntimeContext().getMapState(mapStateDesc);&lt;br/&gt;
    +        final Shape shape = value.getShape();&lt;br/&gt;
    +    &lt;br/&gt;
    +        for (Map.Entry&amp;lt;String, Rule&amp;gt; entry: &lt;br/&gt;
    +                ctx.getBroadcastState(ruleStateDescriptor).immutableEntries()) {&lt;br/&gt;
    +            final String ruleName = entry.getKey();&lt;br/&gt;
    +            final Rule rule = entry.getValue();&lt;br/&gt;
    +    &lt;br/&gt;
    +            List&amp;lt;Item&amp;gt; stored = state.get(ruleName);&lt;br/&gt;
    +            if (stored == null) {
    +                stored = new ArrayList&amp;lt;&amp;gt;();
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (shape == rule.second &amp;amp;&amp;amp; !stored.isEmpty()) {&lt;br/&gt;
    +                for (Item i : stored) {
    +                    out.collect(&quot;MATCH: &quot; + i + &quot; - &quot; + value);
    +                }&lt;br/&gt;
    +                stored.clear();&lt;br/&gt;
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            // there is  no else{} to cover if rule.first == rule.second&lt;br/&gt;
    +            if (shape.equals(rule.first)) {
    +                stored.add(value);
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (stored.isEmpty()) {
    +                state.remove(ruleName);
    +            } else {
    +                state.put(ruleName, stored);
    +            }&lt;br/&gt;
    +        }&lt;br/&gt;
    +	}&lt;br/&gt;
    +}&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +## Important Considerations&lt;br/&gt;
    +&lt;br/&gt;
    +After describing the offered APIs, this section focuses on the important things to keep in mind when using broadcast &lt;br/&gt;
    +state. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;There is no cross-task communication:&lt;/b&gt;* As stated earlier, this is the reason why only the broadcast side of a &lt;br/&gt;
    +`(Keyed)-BroadcastProcessFunction` can modify the contents of the broadcast state. In addition, the user has to make &lt;br/&gt;
    +sure that all tasks modify the contents of the broadcast state in the same way for each incoming element. In other &lt;br/&gt;
    +case, different tasks may have different contents, which can lead to inconsistent results.&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;Order of events in Broadcast State may differ across tasks:&lt;/b&gt;* Although broadcasting the elements of a stream &lt;br/&gt;
    +guarantees that all elements will go to all downstream tasks, elements may arrive in different order on each task. This&lt;br/&gt;
    +implies that although all tasks will (eventually) have the same elements in their broadcast state, these may not be in&lt;br/&gt;
    +the same order.&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;All tasks checkpoint their state:&lt;/b&gt;* Although all tasks have the same elements when a checkpoint takes place &lt;br/&gt;
    +(checkpoint barriers do not overpass elements), all tasks checkpoint their state, and not only one of them. This is a &lt;br/&gt;
    +design decision to avoid having all tasks upon restore reading from the same file. This design decision avoids creating &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    to avoid having all tasks read from the same file during a restore.&lt;/p&gt;</comment>
                            <comment id="16458519" author="githubbot" created="Mon, 30 Apr 2018 12:23:21 +0000"  >&lt;p&gt;Github user alpinegizmo commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r184969214&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r184969214&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,281 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) described operator state which is either *&lt;b&gt;evenly&lt;/b&gt;* distributed among the parallel&lt;br/&gt;
    +tasks of an operator, or state which *&lt;b&gt;upon restore&lt;/b&gt;&lt;b&gt;, its partial (task) states are **unioned&lt;/b&gt;* and the whole state is &lt;br/&gt;
    +used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use-cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use-cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to streams whose elements are &lt;b&gt;broadcasted&lt;/b&gt;,&lt;br/&gt;
    + 3. the only operation available to a stream with broadcast state is to be &lt;b&gt;connected&lt;/b&gt; to another keyed or non-keyed stream,&lt;br/&gt;
    + 4. such a broadcast stream can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolve over time. &lt;br/&gt;
    +&lt;br/&gt;
    +In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other&lt;br/&gt;
    +stream will contain the `Rules`.&lt;br/&gt;
    +&lt;br/&gt;
    +Starting from the stream of `Items`, we just need to &lt;b&gt;key it&lt;/b&gt; by `Color`, as we want pairs of the same color. This will&lt;br/&gt;
    +make sure that elements of the same color end up on the same physical machine.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +// key the shapes by color&lt;br/&gt;
    +KeyedStream&amp;lt;Item, Color&amp;gt; colorPartitionedStream = shapeStream&lt;br/&gt;
    +                        .keyBy(new KeySelector&amp;lt;Shape, Color&amp;gt;(){...});&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks &lt;br/&gt;
    +should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast &lt;br/&gt;
    +the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules&lt;br/&gt;
    +will be stored.&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +&lt;br/&gt;
    +// a map descriptor to store the name of the rule (string) and the rule itself.&lt;br/&gt;
    +MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +				&quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +				BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +				TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {})&lt;br/&gt;
    +		);&lt;br/&gt;
    +		&lt;br/&gt;
    +// broadcast the rules and create the broadcast state&lt;br/&gt;
    +BroadcastStream&amp;lt;Rule&amp;gt; ruleBroadcastStream = ruleStream&lt;br/&gt;
    +                        .broadcast(ruleStateDescriptor);&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in order to evaluate the `Rules` against the incoming elements from the `Item` stream, we need to:&lt;br/&gt;
    +    1) connect the two streams and &lt;br/&gt;
    +    2) specify our match detecting logic. &lt;br/&gt;
    +&lt;br/&gt;
    +Connecting a stream (keyed or non-keyed) with a `BroadcastStream` can be done by calling `connect()` on the &lt;br/&gt;
    +non-broadcasted stream, with the `BroadcastStream` as an argument. This will return a `BroadcastConnectedStream`, on &lt;br/&gt;
    +which we can call `process()` with a special type of `CoProcessFunction`. The function will contain our matching logic. &lt;br/&gt;
    +The exact type of the function depends on the type of the non-broadcasted stream: &lt;br/&gt;
    + - if that is *&lt;b&gt;keyed&lt;/b&gt;*, then the function is a `KeyedBroadcastProcessFunction`. &lt;br/&gt;
    + - if it is *&lt;b&gt;non-keyed&lt;/b&gt;*, the function is a `BroadcastProcessFunction`. &lt;br/&gt;
    + &lt;br/&gt;
    + Given that our non-broadcasted stream is keyed, the following snippet includes the above calls:&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The connect should be called on the non-broadcasted stream, with the `BroadcastStream`&lt;br/&gt;
    +   as an argument.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +DataStream&amp;lt;Match&amp;gt; output = colorPartitionedStream&lt;br/&gt;
    +                 .connect(ruleBroadcastStream)&lt;br/&gt;
    +                 .process(&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     // type arguments in our KeyedBroadcastProcessFunction represent: &lt;br/&gt;
    +                     //   1. the key of the keyed stream&lt;br/&gt;
    +                     //   2. the type of elements in the non-broadcast side&lt;br/&gt;
    +                     //   3. the type of elements in the broadcast side&lt;br/&gt;
    +                     //   4. the type of the result, here a string&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {
    +                         // my matching logic
    +                     }&lt;br/&gt;
    +                 )&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +### BroadcastProcessFunction and KeyedBroadcastProcessFunction&lt;br/&gt;
    +&lt;br/&gt;
    +As in the case of a `CoProcessFunction`, these methods have two &quot;sides&quot;, one is responsible for processing incoming &lt;br/&gt;
    +elements in the broadcasted stream and one is used for the non-broadcasted one. This is reflected in the methods to be &lt;br/&gt;
    +implemented, which are presented below.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +public abstract class BroadcastProcessFunction&amp;lt;IN1, IN2, OUT&amp;gt; extends BaseBroadcastProcessFunction {
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +public abstract class KeyedBroadcastProcessFunction&amp;lt;KS, IN1, IN2, OUT&amp;gt; &lt;/p&gt;
{
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public void onTimer(long timestamp, OnTimerContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}
&lt;p&gt;    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +The first thing to notice is that both functions require the implementation of the `processBroadcastElement()` method &lt;br/&gt;
    +for processing elements in the broadcast side and the `processElement()` for elements in the non-broadcasted side. &lt;br/&gt;
    +&lt;br/&gt;
    +The two methods differ in the context they are provided. The non-broadcast side has a `ReadOnlyContext`, while the &lt;br/&gt;
    +broadcasted side has a `Context`. &lt;br/&gt;
    +&lt;br/&gt;
    +Both of these contexts (`ctx` in the following enumeration):&lt;br/&gt;
    + 1. give access to the broadcast state: `ctx.getBroadcastState(MapStateDescriptor&amp;lt;K, V&amp;gt; stateDescriptor)`&lt;br/&gt;
    + 2. allow to query the timestamp of the element: `ctx.timestamp()`, &lt;br/&gt;
    + 3. get the current watermark: `ctx.currentWatermark()`&lt;br/&gt;
    + 4. get the current processing time: `ctx.currentProcessingTime()`, and &lt;br/&gt;
    + 5. emit elements to side-outputs: `ctx.output(OutputTag&amp;lt;X&amp;gt; outputTag, X value)`. &lt;br/&gt;
    +&lt;br/&gt;
    +The `stateDescriptor` in the `getBroadcastState()` should be identical to the one in the `.broadcast(ruleStateDescriptor)` &lt;br/&gt;
    +above.&lt;br/&gt;
    +&lt;br/&gt;
    +The difference lies in the type of access each one gives to the broadcast state. The broadcasted side has &lt;br/&gt;
    +*&lt;b&gt;read-write access&lt;/b&gt;* to it, while the non-broadcast side has *&lt;b&gt;read-only access&lt;/b&gt;* (thus the names). The reason for this&lt;br/&gt;
    +is that in Flink there is no cross-task communication. So, to guarantee that the contents in the Broadcast State are the&lt;br/&gt;
    +same across all parallel instances of our operator, we give read-write access only to the broadcast side, which sees the&lt;br/&gt;
    +same elements across all tasks, and we require the computation on each incoming element on that side to be identical &lt;br/&gt;
    +across all tasks. Ignoring this rule would break the consistency guarantees of the state, leading to inconsistent and &lt;br/&gt;
    +often difficult to debug results.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The logic implemented in `processBroadcast()` must have the same determinstic behavior &lt;br/&gt;
    +  across all parallel instances!&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, due to the fact that the `KeyedBroadcastProcessFunction` is (on one &quot;side&quot;) operating on a keyed stream, it &lt;br/&gt;
    +exposes some functionality which is not available to the `BroadcastProcessFunction`. That is:&lt;br/&gt;
    + 1. the `ReadOnlyContext` in the `processElement()` method gives access to Flink&apos;s underlying timer service, which allows&lt;br/&gt;
    +  to register event and/or processing time timers. When a timer fires, the `onTimer()` (shown above) is invoked with an &lt;br/&gt;
    +  `OnTimerContext` which exposes the same functionality as the `ReadOnlyContext` plus &lt;br/&gt;
    +   - the ability to ask if the timer that fired was an event or processing time one and &lt;br/&gt;
    +   - to query the key associated with the timer.&lt;br/&gt;
    +&lt;br/&gt;
    +  This is aligned with the `onTimer()` method of the `KeyedProcessFunction`. &lt;br/&gt;
    + 2. the `Context` in the `processBroadcastElement()` method contains the method &lt;br/&gt;
    + `applyToKeyedState(StateDescriptor&amp;lt;S, VS&amp;gt; stateDescriptor, KeyedStateFunction&amp;lt;KS, S&amp;gt; function)`. This allows to &lt;br/&gt;
    +  register a `KeyedStateFunction` to be *&lt;b&gt;applied to all states of all keys&lt;/b&gt;* associated with the provided `stateDescriptor`. &lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; Registering timers is only possible at `processElement()` of the `KeyedBroadcastProcessFunction`&lt;br/&gt;
    +  and only there. It is not possible in the `processBroadcastElement()` method, as there is no key associated to the &lt;br/&gt;
    +  broadcasted elements.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +  &lt;br/&gt;
    +Coming back to our original example, our `KeyedBroadcastProcessFunction` could look like the following:&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +    // store partial matches, i.e. first elements of the pair waiting for their second element&lt;br/&gt;
    +    // we keep a list as we may have many first elements waiting&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; mapStateDesc =&lt;br/&gt;
    +	    new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +	        &quot;items&quot;,&lt;br/&gt;
    +	        BasicTypeInfo.STRING_TYPE_INFO, &lt;br/&gt;
    +	        new ListTypeInfo&amp;lt;&amp;gt;(Item.class));&lt;br/&gt;
    +&lt;br/&gt;
    +    // identical to our ruleStateDescriptor above&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = &lt;br/&gt;
    +        new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +    	    &quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +    		BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +    		TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {}));&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processBroadcastElement(Rule value, &lt;br/&gt;
    +	                                    Context ctx, &lt;br/&gt;
    +	                                    Collector&amp;lt;String&amp;gt; out) throws Exception {
    +	    ctx.getBroadcastState(ruleStateDescriptor).put(value.name, value);
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processElement(Item value, &lt;br/&gt;
    +	                           ReadOnlyContext ctx, &lt;br/&gt;
    +	                           Collector&amp;lt;String&amp;gt; out) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +        final MapState&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; state = getRuntimeContext().getMapState(mapStateDesc);&lt;br/&gt;
    +        final Shape shape = value.getShape();&lt;br/&gt;
    +    &lt;br/&gt;
    +        for (Map.Entry&amp;lt;String, Rule&amp;gt; entry: &lt;br/&gt;
    +                ctx.getBroadcastState(ruleStateDescriptor).immutableEntries()) {&lt;br/&gt;
    +            final String ruleName = entry.getKey();&lt;br/&gt;
    +            final Rule rule = entry.getValue();&lt;br/&gt;
    +    &lt;br/&gt;
    +            List&amp;lt;Item&amp;gt; stored = state.get(ruleName);&lt;br/&gt;
    +            if (stored == null) {
    +                stored = new ArrayList&amp;lt;&amp;gt;();
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (shape == rule.second &amp;amp;&amp;amp; !stored.isEmpty()) {&lt;br/&gt;
    +                for (Item i : stored) {
    +                    out.collect(&quot;MATCH: &quot; + i + &quot; - &quot; + value);
    +                }&lt;br/&gt;
    +                stored.clear();&lt;br/&gt;
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            // there is  no else{} to cover if rule.first == rule.second&lt;br/&gt;
    +            if (shape.equals(rule.first)) {
    +                stored.add(value);
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (stored.isEmpty()) {
    +                state.remove(ruleName);
    +            } else {
    +                state.put(ruleName, stored);
    +            }&lt;br/&gt;
    +        }&lt;br/&gt;
    +	}&lt;br/&gt;
    +}&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +## Important Considerations&lt;br/&gt;
    +&lt;br/&gt;
    +After describing the offered APIs, this section focuses on the important things to keep in mind when using broadcast &lt;br/&gt;
    +state. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;There is no cross-task communication:&lt;/b&gt;* As stated earlier, this is the reason why only the broadcast side of a &lt;br/&gt;
    +`(Keyed)-BroadcastProcessFunction` can modify the contents of the broadcast state. In addition, the user has to make &lt;br/&gt;
    +sure that all tasks modify the contents of the broadcast state in the same way for each incoming element. In other &lt;br/&gt;
    +case, different tasks may have different contents, which can lead to inconsistent results.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Otherwise different tasks might have different contents, leading to inconsistent results.&lt;/p&gt;</comment>
                            <comment id="16458520" author="githubbot" created="Mon, 30 Apr 2018 12:23:21 +0000"  >&lt;p&gt;Github user alpinegizmo commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r184968333&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r184968333&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,281 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) described operator state which is either *&lt;b&gt;evenly&lt;/b&gt;* distributed among the parallel&lt;br/&gt;
    +tasks of an operator, or state which *&lt;b&gt;upon restore&lt;/b&gt;&lt;b&gt;, its partial (task) states are **unioned&lt;/b&gt;* and the whole state is &lt;br/&gt;
    +used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use-cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use-cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to streams whose elements are &lt;b&gt;broadcasted&lt;/b&gt;,&lt;br/&gt;
    + 3. the only operation available to a stream with broadcast state is to be &lt;b&gt;connected&lt;/b&gt; to another keyed or non-keyed stream,&lt;br/&gt;
    + 4. such a broadcast stream can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolve over time. &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    the set of interesting patterns evolves over time.&lt;/p&gt;</comment>
                            <comment id="16458521" author="githubbot" created="Mon, 30 Apr 2018 12:23:21 +0000"  >&lt;p&gt;Github user alpinegizmo commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r184971516&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r184971516&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,281 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) described operator state which is either *&lt;b&gt;evenly&lt;/b&gt;* distributed among the parallel&lt;br/&gt;
    +tasks of an operator, or state which *&lt;b&gt;upon restore&lt;/b&gt;&lt;b&gt;, its partial (task) states are **unioned&lt;/b&gt;* and the whole state is &lt;br/&gt;
    +used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use-cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    use cases (no hyphen)&lt;/p&gt;</comment>
                            <comment id="16458522" author="githubbot" created="Mon, 30 Apr 2018 12:23:21 +0000"  >&lt;p&gt;Github user alpinegizmo commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r184969839&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r184969839&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,281 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) described operator state which is either *&lt;b&gt;evenly&lt;/b&gt;* distributed among the parallel&lt;br/&gt;
    +tasks of an operator, or state which *&lt;b&gt;upon restore&lt;/b&gt;&lt;b&gt;, its partial (task) states are **unioned&lt;/b&gt;* and the whole state is &lt;br/&gt;
    +used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use-cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use-cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to streams whose elements are &lt;b&gt;broadcasted&lt;/b&gt;,&lt;br/&gt;
    + 3. the only operation available to a stream with broadcast state is to be &lt;b&gt;connected&lt;/b&gt; to another keyed or non-keyed stream,&lt;br/&gt;
    + 4. such a broadcast stream can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolve over time. &lt;br/&gt;
    +&lt;br/&gt;
    +In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other&lt;br/&gt;
    +stream will contain the `Rules`.&lt;br/&gt;
    +&lt;br/&gt;
    +Starting from the stream of `Items`, we just need to &lt;b&gt;key it&lt;/b&gt; by `Color`, as we want pairs of the same color. This will&lt;br/&gt;
    +make sure that elements of the same color end up on the same physical machine.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +// key the shapes by color&lt;br/&gt;
    +KeyedStream&amp;lt;Item, Color&amp;gt; colorPartitionedStream = shapeStream&lt;br/&gt;
    +                        .keyBy(new KeySelector&amp;lt;Shape, Color&amp;gt;(){...});&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks &lt;br/&gt;
    +should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast &lt;br/&gt;
    +the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules&lt;br/&gt;
    +will be stored.&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +&lt;br/&gt;
    +// a map descriptor to store the name of the rule (string) and the rule itself.&lt;br/&gt;
    +MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +				&quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +				BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +				TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {})&lt;br/&gt;
    +		);&lt;br/&gt;
    +		&lt;br/&gt;
    +// broadcast the rules and create the broadcast state&lt;br/&gt;
    +BroadcastStream&amp;lt;Rule&amp;gt; ruleBroadcastStream = ruleStream&lt;br/&gt;
    +                        .broadcast(ruleStateDescriptor);&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in order to evaluate the `Rules` against the incoming elements from the `Item` stream, we need to:&lt;br/&gt;
    +    1) connect the two streams and &lt;br/&gt;
    +    2) specify our match detecting logic. &lt;br/&gt;
    +&lt;br/&gt;
    +Connecting a stream (keyed or non-keyed) with a `BroadcastStream` can be done by calling `connect()` on the &lt;br/&gt;
    +non-broadcasted stream, with the `BroadcastStream` as an argument. This will return a `BroadcastConnectedStream`, on &lt;br/&gt;
    +which we can call `process()` with a special type of `CoProcessFunction`. The function will contain our matching logic. &lt;br/&gt;
    +The exact type of the function depends on the type of the non-broadcasted stream: &lt;br/&gt;
    + - if that is *&lt;b&gt;keyed&lt;/b&gt;*, then the function is a `KeyedBroadcastProcessFunction`. &lt;br/&gt;
    + - if it is *&lt;b&gt;non-keyed&lt;/b&gt;*, the function is a `BroadcastProcessFunction`. &lt;br/&gt;
    + &lt;br/&gt;
    + Given that our non-broadcasted stream is keyed, the following snippet includes the above calls:&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The connect should be called on the non-broadcasted stream, with the `BroadcastStream`&lt;br/&gt;
    +   as an argument.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +DataStream&amp;lt;Match&amp;gt; output = colorPartitionedStream&lt;br/&gt;
    +                 .connect(ruleBroadcastStream)&lt;br/&gt;
    +                 .process(&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     // type arguments in our KeyedBroadcastProcessFunction represent: &lt;br/&gt;
    +                     //   1. the key of the keyed stream&lt;br/&gt;
    +                     //   2. the type of elements in the non-broadcast side&lt;br/&gt;
    +                     //   3. the type of elements in the broadcast side&lt;br/&gt;
    +                     //   4. the type of the result, here a string&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {
    +                         // my matching logic
    +                     }&lt;br/&gt;
    +                 )&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +### BroadcastProcessFunction and KeyedBroadcastProcessFunction&lt;br/&gt;
    +&lt;br/&gt;
    +As in the case of a `CoProcessFunction`, these methods have two &quot;sides&quot;, one is responsible for processing incoming &lt;br/&gt;
    +elements in the broadcasted stream and one is used for the non-broadcasted one. This is reflected in the methods to be &lt;br/&gt;
    +implemented, which are presented below.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +public abstract class BroadcastProcessFunction&amp;lt;IN1, IN2, OUT&amp;gt; extends BaseBroadcastProcessFunction {
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +public abstract class KeyedBroadcastProcessFunction&amp;lt;KS, IN1, IN2, OUT&amp;gt; &lt;/p&gt;
{
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public void onTimer(long timestamp, OnTimerContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}
&lt;p&gt;    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +The first thing to notice is that both functions require the implementation of the `processBroadcastElement()` method &lt;br/&gt;
    +for processing elements in the broadcast side and the `processElement()` for elements in the non-broadcasted side. &lt;br/&gt;
    +&lt;br/&gt;
    +The two methods differ in the context they are provided. The non-broadcast side has a `ReadOnlyContext`, while the &lt;br/&gt;
    +broadcasted side has a `Context`. &lt;br/&gt;
    +&lt;br/&gt;
    +Both of these contexts (`ctx` in the following enumeration):&lt;br/&gt;
    + 1. give access to the broadcast state: `ctx.getBroadcastState(MapStateDescriptor&amp;lt;K, V&amp;gt; stateDescriptor)`&lt;br/&gt;
    + 2. allow to query the timestamp of the element: `ctx.timestamp()`, &lt;br/&gt;
    + 3. get the current watermark: `ctx.currentWatermark()`&lt;br/&gt;
    + 4. get the current processing time: `ctx.currentProcessingTime()`, and &lt;br/&gt;
    + 5. emit elements to side-outputs: `ctx.output(OutputTag&amp;lt;X&amp;gt; outputTag, X value)`. &lt;br/&gt;
    +&lt;br/&gt;
    +The `stateDescriptor` in the `getBroadcastState()` should be identical to the one in the `.broadcast(ruleStateDescriptor)` &lt;br/&gt;
    +above.&lt;br/&gt;
    +&lt;br/&gt;
    +The difference lies in the type of access each one gives to the broadcast state. The broadcasted side has &lt;br/&gt;
    +*&lt;b&gt;read-write access&lt;/b&gt;* to it, while the non-broadcast side has *&lt;b&gt;read-only access&lt;/b&gt;* (thus the names). The reason for this&lt;br/&gt;
    +is that in Flink there is no cross-task communication. So, to guarantee that the contents in the Broadcast State are the&lt;br/&gt;
    +same across all parallel instances of our operator, we give read-write access only to the broadcast side, which sees the&lt;br/&gt;
    +same elements across all tasks, and we require the computation on each incoming element on that side to be identical &lt;br/&gt;
    +across all tasks. Ignoring this rule would break the consistency guarantees of the state, leading to inconsistent and &lt;br/&gt;
    +often difficult to debug results.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The logic implemented in `processBroadcast()` must have the same determinstic behavior &lt;br/&gt;
    +  across all parallel instances!&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, due to the fact that the `KeyedBroadcastProcessFunction` is (on one &quot;side&quot;) operating on a keyed stream, it &lt;br/&gt;
    +exposes some functionality which is not available to the `BroadcastProcessFunction`. That is:&lt;br/&gt;
    + 1. the `ReadOnlyContext` in the `processElement()` method gives access to Flink&apos;s underlying timer service, which allows&lt;br/&gt;
    +  to register event and/or processing time timers. When a timer fires, the `onTimer()` (shown above) is invoked with an &lt;br/&gt;
    +  `OnTimerContext` which exposes the same functionality as the `ReadOnlyContext` plus &lt;br/&gt;
    +   - the ability to ask if the timer that fired was an event or processing time one and &lt;br/&gt;
    +   - to query the key associated with the timer.&lt;br/&gt;
    +&lt;br/&gt;
    +  This is aligned with the `onTimer()` method of the `KeyedProcessFunction`. &lt;br/&gt;
    + 2. the `Context` in the `processBroadcastElement()` method contains the method &lt;br/&gt;
    + `applyToKeyedState(StateDescriptor&amp;lt;S, VS&amp;gt; stateDescriptor, KeyedStateFunction&amp;lt;KS, S&amp;gt; function)`. This allows to &lt;br/&gt;
    +  register a `KeyedStateFunction` to be *&lt;b&gt;applied to all states of all keys&lt;/b&gt;* associated with the provided `stateDescriptor`. &lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; Registering timers is only possible at `processElement()` of the `KeyedBroadcastProcessFunction`&lt;br/&gt;
    +  and only there. It is not possible in the `processBroadcastElement()` method, as there is no key associated to the &lt;br/&gt;
    +  broadcasted elements.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +  &lt;br/&gt;
    +Coming back to our original example, our `KeyedBroadcastProcessFunction` could look like the following:&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +    // store partial matches, i.e. first elements of the pair waiting for their second element&lt;br/&gt;
    +    // we keep a list as we may have many first elements waiting&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; mapStateDesc =&lt;br/&gt;
    +	    new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +	        &quot;items&quot;,&lt;br/&gt;
    +	        BasicTypeInfo.STRING_TYPE_INFO, &lt;br/&gt;
    +	        new ListTypeInfo&amp;lt;&amp;gt;(Item.class));&lt;br/&gt;
    +&lt;br/&gt;
    +    // identical to our ruleStateDescriptor above&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = &lt;br/&gt;
    +        new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +    	    &quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +    		BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +    		TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {}));&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processBroadcastElement(Rule value, &lt;br/&gt;
    +	                                    Context ctx, &lt;br/&gt;
    +	                                    Collector&amp;lt;String&amp;gt; out) throws Exception {
    +	    ctx.getBroadcastState(ruleStateDescriptor).put(value.name, value);
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processElement(Item value, &lt;br/&gt;
    +	                           ReadOnlyContext ctx, &lt;br/&gt;
    +	                           Collector&amp;lt;String&amp;gt; out) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +        final MapState&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; state = getRuntimeContext().getMapState(mapStateDesc);&lt;br/&gt;
    +        final Shape shape = value.getShape();&lt;br/&gt;
    +    &lt;br/&gt;
    +        for (Map.Entry&amp;lt;String, Rule&amp;gt; entry: &lt;br/&gt;
    +                ctx.getBroadcastState(ruleStateDescriptor).immutableEntries()) {&lt;br/&gt;
    +            final String ruleName = entry.getKey();&lt;br/&gt;
    +            final Rule rule = entry.getValue();&lt;br/&gt;
    +    &lt;br/&gt;
    +            List&amp;lt;Item&amp;gt; stored = state.get(ruleName);&lt;br/&gt;
    +            if (stored == null) {
    +                stored = new ArrayList&amp;lt;&amp;gt;();
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (shape == rule.second &amp;amp;&amp;amp; !stored.isEmpty()) {&lt;br/&gt;
    +                for (Item i : stored) {
    +                    out.collect(&quot;MATCH: &quot; + i + &quot; - &quot; + value);
    +                }&lt;br/&gt;
    +                stored.clear();&lt;br/&gt;
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            // there is  no else{} to cover if rule.first == rule.second&lt;br/&gt;
    +            if (shape.equals(rule.first)) {
    +                stored.add(value);
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (stored.isEmpty()) {
    +                state.remove(ruleName);
    +            } else {
    +                state.put(ruleName, stored);
    +            }&lt;br/&gt;
    +        }&lt;br/&gt;
    +	}&lt;br/&gt;
    +}&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +## Important Considerations&lt;br/&gt;
    +&lt;br/&gt;
    +After describing the offered APIs, this section focuses on the important things to keep in mind when using broadcast &lt;br/&gt;
    +state. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;There is no cross-task communication:&lt;/b&gt;* As stated earlier, this is the reason why only the broadcast side of a &lt;br/&gt;
    +`(Keyed)-BroadcastProcessFunction` can modify the contents of the broadcast state. In addition, the user has to make &lt;br/&gt;
    +sure that all tasks modify the contents of the broadcast state in the same way for each incoming element. In other &lt;br/&gt;
    +case, different tasks may have different contents, which can lead to inconsistent results.&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;Order of events in Broadcast State may differ across tasks:&lt;/b&gt;* Although broadcasting the elements of a stream &lt;br/&gt;
    +guarantees that all elements will go to all downstream tasks, elements may arrive in different order on each task. This&lt;br/&gt;
    +implies that although all tasks will (eventually) have the same elements in their broadcast state, these may not be in&lt;br/&gt;
    +the same order.&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;All tasks checkpoint their state:&lt;/b&gt;* Although all tasks have the same elements when a checkpoint takes place &lt;br/&gt;
    +(checkpoint barriers do not overpass elements), all tasks checkpoint their state, and not only one of them. This is a &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    and not just one of them&lt;/p&gt;</comment>
                            <comment id="16460708" author="githubbot" created="Wed, 2 May 2018 08:29:13 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r185417488&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r185417488&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,281 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) described operator state which is either *&lt;b&gt;evenly&lt;/b&gt;* distributed among the parallel&lt;br/&gt;
    +tasks of an operator, or state which *&lt;b&gt;upon restore&lt;/b&gt;&lt;b&gt;, its partial (task) states are **unioned&lt;/b&gt;* and the whole state is &lt;br/&gt;
    +used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use-cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use-cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to streams whose elements are &lt;b&gt;broadcasted&lt;/b&gt;,&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This is a bit confusing, as far as I understood it.&lt;/p&gt;

&lt;p&gt;    The broadcast state is available to both the broadcast input as well as the non-broadcasted input, i.e. the broadcast state can be read on both `map1` and `map2` of a co-flat map.&lt;br/&gt;
    However, it can only be updated on the broadcast input.&lt;/p&gt;</comment>
                            <comment id="16460814" author="githubbot" created="Wed, 2 May 2018 10:09:50 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r185449653&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r185449653&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,281 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) described operator state which is either *&lt;b&gt;evenly&lt;/b&gt;* distributed among the parallel&lt;br/&gt;
    +tasks of an operator, or state which *&lt;b&gt;upon restore&lt;/b&gt;&lt;b&gt;, its partial (task) states are **unioned&lt;/b&gt;* and the whole state is &lt;br/&gt;
    +used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use-cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use-cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to streams whose elements are &lt;b&gt;broadcasted&lt;/b&gt;,&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Here I was only trying to point out that in order to have broadcast state, the elements of the  stream should be broadcasted, &lt;b&gt;i.e.&lt;/b&gt; `broadcast(stateDesc)`. I was not referring to the access rights. This is contrary to other states that any stream can have them &lt;b&gt;e.g.&lt;/b&gt; through the runtime context.&lt;/p&gt;</comment>
                            <comment id="16460821" author="githubbot" created="Wed, 2 May 2018 10:17:20 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks a lot for the comments @alpinegizmo and @tzulitai ! I integrated most of them and I am not sure how to integrate your comment @tzulitai . Do you have any proposal on how this can be made clearer?&lt;/p&gt;</comment>
                            <comment id="16460828" author="githubbot" created="Wed, 2 May 2018 10:21:22 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r185452174&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r185452174&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,281 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) described operator state which is either *&lt;b&gt;evenly&lt;/b&gt;* distributed among the parallel&lt;br/&gt;
    +tasks of an operator, or state which *&lt;b&gt;upon restore&lt;/b&gt;&lt;b&gt;, its partial (task) states are **unioned&lt;/b&gt;* and the whole state is &lt;br/&gt;
    +used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use-cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use-cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to streams whose elements are &lt;b&gt;broadcasted&lt;/b&gt;,&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    How about,&lt;br/&gt;
    &quot;it is only available to operators which have a broadcasted input stream&quot;?&lt;/p&gt;

&lt;p&gt;    This might only be a matter of personal preference, so please take this as a grain of salt.&lt;br/&gt;
    It&apos;s just that I somehow find it easier to understand when thinking in terms of states and operators.&lt;/p&gt;</comment>
                            <comment id="16460840" author="githubbot" created="Wed, 2 May 2018 10:31:00 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    This seems like a nice suggestion.&lt;br/&gt;
    I will do that and let&#8217;s see how it reads afterwards.&lt;/p&gt;

&lt;p&gt;    &amp;gt; On May 2, 2018, at 12:21 PM, Tzu-Li Tai &amp;lt;notifications@github.com&amp;gt; wrote:&lt;br/&gt;
    &amp;gt; &lt;br/&gt;
    &amp;gt; @tzulitai commented on this pull request.&lt;br/&gt;
    &amp;gt; &lt;br/&gt;
    &amp;gt; In docs/dev/stream/state/broadcast_state.md &amp;lt;&lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r185452174&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r185452174&lt;/a&gt;&amp;gt;:&lt;br/&gt;
    &amp;gt; &lt;br/&gt;
    &amp;gt; &amp;gt; +&lt;br/&gt;
    &amp;gt; +* ToC&lt;br/&gt;
    &amp;gt; +{:toc}&lt;br/&gt;
    &amp;gt; +&lt;br/&gt;
    &amp;gt; +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) described operator state which is either *&lt;b&gt;evenly&lt;/b&gt;* distributed among the parallel&lt;br/&gt;
    &amp;gt; +tasks of an operator, or state which *&lt;b&gt;upon restore&lt;/b&gt;&lt;b&gt;, its partial (task) states are **unioned&lt;/b&gt;* and the whole state is &lt;br/&gt;
    &amp;gt; +used to initialize the restored parallel tasks.&lt;br/&gt;
    &amp;gt; +&lt;br/&gt;
    &amp;gt; +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use-cases&lt;br/&gt;
    &amp;gt; +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    &amp;gt; +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    &amp;gt; +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    &amp;gt; +elements coming from another stream. Having the above type of use-cases in mind, broadcast state differs from the rest &lt;br/&gt;
    &amp;gt; +of operator states in that:&lt;br/&gt;
    &amp;gt; + 1. it has a map format,&lt;br/&gt;
    &amp;gt; + 2. it is only available to streams whose elements are &lt;b&gt;broadcasted&lt;/b&gt;,&lt;br/&gt;
    &amp;gt; How about,&lt;br/&gt;
    &amp;gt; &quot;it is only available to operators which have a broadcasted input stream&quot;?&lt;br/&gt;
    &amp;gt; &lt;br/&gt;
    &amp;gt; This might only be a matter of personal preference, so please take this as a grain of salt.&lt;br/&gt;
    &amp;gt; It&apos;s just that I somehow find it easier to understand when thinking in terms of states and operators.&lt;br/&gt;
    &amp;gt; &lt;br/&gt;
    &amp;gt; &#8212;&lt;br/&gt;
    &amp;gt; You are receiving this because you authored the thread.&lt;br/&gt;
    &amp;gt; Reply to this email directly, view it on GitHub &amp;lt;&lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r185452174&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r185452174&lt;/a&gt;&amp;gt;, or mute the thread &amp;lt;&lt;a href=&quot;https://github.com/notifications/unsubscribe-auth/ACS1qBiVh_nUWs6pz4XUSVk0w1mxN78Rks5tuYisgaJpZM4TlZsp&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/notifications/unsubscribe-auth/ACS1qBiVh_nUWs6pz4XUSVk0w1mxN78Rks5tuYisgaJpZM4TlZsp&lt;/a&gt;&amp;gt;.&lt;br/&gt;
    &amp;gt; &lt;/p&gt;

</comment>
                            <comment id="16460920" author="githubbot" created="Wed, 2 May 2018 11:47:53 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks a lot for the reviews! I pushed a commit that integrates your comments. Let me know if now it looks ok.&lt;/p&gt;</comment>
                            <comment id="16465541" author="githubbot" created="Mon, 7 May 2018 07:16:06 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r186339587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r186339587&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -25,27 +25,25 @@ under the License.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;ToC&lt;br/&gt;
     {:toc}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) described operator state which is either *&lt;b&gt;evenly&lt;/b&gt;* distributed among the parallel&lt;br/&gt;
    -tasks of an operator, or state which *&lt;b&gt;upon restore&lt;/b&gt;&lt;b&gt;, its partial (task) states are **unioned&lt;/b&gt;* and the whole state is &lt;br/&gt;
    -used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) describes operator state which upon restore is either evenly distributed among the &lt;br/&gt;
    +parallel tasks of an operator, or unioned, with the whole state being used to initialize the restored parallel tasks.&lt;/p&gt;

&lt;p&gt;    -A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use-cases&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use cases&lt;br/&gt;
     where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
     and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
     natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    -elements coming from another stream. Having the above type of use-cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +elements coming from another stream. Having the above type of use cases in mind, broadcast state differs from the rest &lt;br/&gt;
     of operator states in that:&lt;br/&gt;
      1. it has a map format,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;2. it is only available to streams whose elements are &lt;b&gt;broadcasted&lt;/b&gt;,&lt;/li&gt;
	&lt;li&gt;3. the only operation available to a stream with broadcast state is to be &lt;b&gt;connected&lt;/b&gt; to another keyed or non-keyed stream,&lt;/li&gt;
	&lt;li&gt;4. such a broadcast stream can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    + 2. it is only available to specific operators that have as inputs a &lt;b&gt;broadcasted&lt;/b&gt; stream and a &lt;b&gt;non-broadcasted&lt;/b&gt; one, and
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This looks good now (from what I read of it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; )!&lt;/p&gt;</comment>
                            <comment id="16465542" author="githubbot" created="Mon, 7 May 2018 07:16:06 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r186340110&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r186340110&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/index.md &amp;#8212;&lt;br/&gt;
    @@ -49,6 +49,7 @@ Where to go next?&lt;br/&gt;
     -----------------&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html): Shows how to use state in a Flink application and explains the different kinds of state.&lt;br/&gt;
    +* &lt;span class=&quot;error&quot;&gt;&amp;#91;The Broadcast State Pattern&amp;#93;&lt;/span&gt;(broadcast_state.html): Explains how to connect a broadcast with a non-broadcast stream and use state to exchange information between them. 
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    how to connect a broadcast &quot;stream&quot; with a ...&lt;br/&gt;
    missing &quot;stream&quot; word&lt;/p&gt;</comment>
                            <comment id="16465543" author="githubbot" created="Mon, 7 May 2018 07:16:07 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r186340944&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r186340944&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,279 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) describes operator state which upon restore is either evenly distributed among the &lt;br/&gt;
    +parallel tasks of an operator, or unioned, with the whole state being used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to specific operators that have as inputs a &lt;b&gt;broadcasted&lt;/b&gt; stream and a &lt;b&gt;non-broadcasted&lt;/b&gt; one, and&lt;br/&gt;
    + 3. such an operator can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolves over time. &lt;br/&gt;
    +&lt;br/&gt;
    +In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other&lt;br/&gt;
    +stream will contain the `Rules`.&lt;br/&gt;
    +&lt;br/&gt;
    +Starting from the stream of `Items`, we just need to &lt;b&gt;key it&lt;/b&gt; by `Color`, as we want pairs of the same color. This will&lt;br/&gt;
    +make sure that elements of the same color end up on the same physical machine.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +// key the shapes by color&lt;br/&gt;
    +KeyedStream&amp;lt;Item, Color&amp;gt; colorPartitionedStream = shapeStream&lt;br/&gt;
    +                        .keyBy(new KeySelector&amp;lt;Shape, Color&amp;gt;(){...});&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks &lt;br/&gt;
    +should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast &lt;br/&gt;
    +the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules&lt;br/&gt;
    +will be stored.&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +&lt;br/&gt;
    +// a map descriptor to store the name of the rule (string) and the rule itself.&lt;br/&gt;
    +MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +				&quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +				BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +				TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {})&lt;br/&gt;
    +		);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    After rendering, this seems a bit off. Maybe we don&apos;t need it on a separate new line?&lt;/p&gt;</comment>
                            <comment id="16465544" author="githubbot" created="Mon, 7 May 2018 07:16:07 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r186341059&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r186341059&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,279 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) describes operator state which upon restore is either evenly distributed among the &lt;br/&gt;
    +parallel tasks of an operator, or unioned, with the whole state being used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to specific operators that have as inputs a &lt;b&gt;broadcasted&lt;/b&gt; stream and a &lt;b&gt;non-broadcasted&lt;/b&gt; one, and&lt;br/&gt;
    + 3. such an operator can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolves over time. &lt;br/&gt;
    +&lt;br/&gt;
    +In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other&lt;br/&gt;
    +stream will contain the `Rules`.&lt;br/&gt;
    +&lt;br/&gt;
    +Starting from the stream of `Items`, we just need to &lt;b&gt;key it&lt;/b&gt; by `Color`, as we want pairs of the same color. This will&lt;br/&gt;
    +make sure that elements of the same color end up on the same physical machine.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +// key the shapes by color&lt;br/&gt;
    +KeyedStream&amp;lt;Item, Color&amp;gt; colorPartitionedStream = shapeStream&lt;br/&gt;
    +                        .keyBy(new KeySelector&amp;lt;Shape, Color&amp;gt;(){...});&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks &lt;br/&gt;
    +should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast &lt;br/&gt;
    +the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules&lt;br/&gt;
    +will be stored.&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +&lt;br/&gt;
    +// a map descriptor to store the name of the rule (string) and the rule itself.&lt;br/&gt;
    +MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +				&quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +				BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +				TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {})&lt;br/&gt;
    +		);&lt;br/&gt;
    +		&lt;br/&gt;
    +// broadcast the rules and create the broadcast state&lt;br/&gt;
    +BroadcastStream&amp;lt;Rule&amp;gt; ruleBroadcastStream = ruleStream&lt;br/&gt;
    +                        .broadcast(ruleStateDescriptor);&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +Finally, in order to evaluate the `Rules` against the incoming elements from the `Item` stream, we need to:&lt;br/&gt;
    +    1) connect the two streams and &lt;br/&gt;
    +    2) specify our match detecting logic. &lt;br/&gt;
    +&lt;br/&gt;
    +Connecting a stream (keyed or non-keyed) with a `BroadcastStream` can be done by calling `connect()` on the &lt;br/&gt;
    +non-broadcasted stream, with the `BroadcastStream` as an argument. This will return a `BroadcastConnectedStream`, on &lt;br/&gt;
    +which we can call `process()` with a special type of `CoProcessFunction`. The function will contain our matching logic. &lt;br/&gt;
    +The exact type of the function depends on the type of the non-broadcasted stream: &lt;br/&gt;
    + - if that is *&lt;b&gt;keyed&lt;/b&gt;*, then the function is a `KeyedBroadcastProcessFunction`. &lt;br/&gt;
    + - if it is *&lt;b&gt;non-keyed&lt;/b&gt;*, the function is a `BroadcastProcessFunction`. &lt;br/&gt;
    + &lt;br/&gt;
    + Given that our non-broadcasted stream is keyed, the following snippet includes the above calls:&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The connect should be called on the non-broadcasted stream, with the `BroadcastStream`&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    The BroadcastStream actually isn&apos;t formatted as a code font after rendering.&lt;/p&gt;</comment>
                            <comment id="16465545" author="githubbot" created="Mon, 7 May 2018 07:16:07 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r186341293&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r186341293&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,279 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) describes operator state which upon restore is either evenly distributed among the &lt;br/&gt;
    +parallel tasks of an operator, or unioned, with the whole state being used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to specific operators that have as inputs a &lt;b&gt;broadcasted&lt;/b&gt; stream and a &lt;b&gt;non-broadcasted&lt;/b&gt; one, and&lt;br/&gt;
    + 3. such an operator can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolves over time. &lt;br/&gt;
    +&lt;br/&gt;
    +In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other&lt;br/&gt;
    +stream will contain the `Rules`.&lt;br/&gt;
    +&lt;br/&gt;
    +Starting from the stream of `Items`, we just need to &lt;b&gt;key it&lt;/b&gt; by `Color`, as we want pairs of the same color. This will&lt;br/&gt;
    +make sure that elements of the same color end up on the same physical machine.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +// key the shapes by color&lt;br/&gt;
    +KeyedStream&amp;lt;Item, Color&amp;gt; colorPartitionedStream = shapeStream&lt;br/&gt;
    +                        .keyBy(new KeySelector&amp;lt;Shape, Color&amp;gt;(){...});&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks &lt;br/&gt;
    +should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast &lt;br/&gt;
    +the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules&lt;br/&gt;
    +will be stored.&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +&lt;br/&gt;
    +// a map descriptor to store the name of the rule (string) and the rule itself.&lt;br/&gt;
    +MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +				&quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +				BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +				TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {})&lt;br/&gt;
    +		);&lt;br/&gt;
    +		&lt;br/&gt;
    +// broadcast the rules and create the broadcast state&lt;br/&gt;
    +BroadcastStream&amp;lt;Rule&amp;gt; ruleBroadcastStream = ruleStream&lt;br/&gt;
    +                        .broadcast(ruleStateDescriptor);&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +Finally, in order to evaluate the `Rules` against the incoming elements from the `Item` stream, we need to:&lt;br/&gt;
    +    1) connect the two streams and &lt;br/&gt;
    +    2) specify our match detecting logic. &lt;br/&gt;
    +&lt;br/&gt;
    +Connecting a stream (keyed or non-keyed) with a `BroadcastStream` can be done by calling `connect()` on the &lt;br/&gt;
    +non-broadcasted stream, with the `BroadcastStream` as an argument. This will return a `BroadcastConnectedStream`, on &lt;br/&gt;
    +which we can call `process()` with a special type of `CoProcessFunction`. The function will contain our matching logic. &lt;br/&gt;
    +The exact type of the function depends on the type of the non-broadcasted stream: &lt;br/&gt;
    + - if that is *&lt;b&gt;keyed&lt;/b&gt;*, then the function is a `KeyedBroadcastProcessFunction`. &lt;br/&gt;
    + - if it is *&lt;b&gt;non-keyed&lt;/b&gt;*, the function is a `BroadcastProcessFunction`. &lt;br/&gt;
    + &lt;br/&gt;
    + Given that our non-broadcasted stream is keyed, the following snippet includes the above calls:&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The connect should be called on the non-broadcasted stream, with the `BroadcastStream`&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    What happens if the user calls connect on the wrong (broadcasted) stream?&lt;br/&gt;
    Is there an exception? If so it might make sense to clarify that here.&lt;/p&gt;</comment>
                            <comment id="16465546" author="githubbot" created="Mon, 7 May 2018 07:16:07 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r186341885&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r186341885&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,279 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) describes operator state which upon restore is either evenly distributed among the &lt;br/&gt;
    +parallel tasks of an operator, or unioned, with the whole state being used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to specific operators that have as inputs a &lt;b&gt;broadcasted&lt;/b&gt; stream and a &lt;b&gt;non-broadcasted&lt;/b&gt; one, and&lt;br/&gt;
    + 3. such an operator can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolves over time. &lt;br/&gt;
    +&lt;br/&gt;
    +In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other&lt;br/&gt;
    +stream will contain the `Rules`.&lt;br/&gt;
    +&lt;br/&gt;
    +Starting from the stream of `Items`, we just need to &lt;b&gt;key it&lt;/b&gt; by `Color`, as we want pairs of the same color. This will&lt;br/&gt;
    +make sure that elements of the same color end up on the same physical machine.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +// key the shapes by color&lt;br/&gt;
    +KeyedStream&amp;lt;Item, Color&amp;gt; colorPartitionedStream = shapeStream&lt;br/&gt;
    +                        .keyBy(new KeySelector&amp;lt;Shape, Color&amp;gt;(){...});&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks &lt;br/&gt;
    +should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast &lt;br/&gt;
    +the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules&lt;br/&gt;
    +will be stored.&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +&lt;br/&gt;
    +// a map descriptor to store the name of the rule (string) and the rule itself.&lt;br/&gt;
    +MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +				&quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +				BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +				TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {})&lt;br/&gt;
    +		);&lt;br/&gt;
    +		&lt;br/&gt;
    +// broadcast the rules and create the broadcast state&lt;br/&gt;
    +BroadcastStream&amp;lt;Rule&amp;gt; ruleBroadcastStream = ruleStream&lt;br/&gt;
    +                        .broadcast(ruleStateDescriptor);&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in order to evaluate the `Rules` against the incoming elements from the `Item` stream, we need to:&lt;br/&gt;
    +    1) connect the two streams and &lt;br/&gt;
    +    2) specify our match detecting logic. &lt;br/&gt;
    +&lt;br/&gt;
    +Connecting a stream (keyed or non-keyed) with a `BroadcastStream` can be done by calling `connect()` on the &lt;br/&gt;
    +non-broadcasted stream, with the `BroadcastStream` as an argument. This will return a `BroadcastConnectedStream`, on &lt;br/&gt;
    +which we can call `process()` with a special type of `CoProcessFunction`. The function will contain our matching logic. &lt;br/&gt;
    +The exact type of the function depends on the type of the non-broadcasted stream: &lt;br/&gt;
    + - if that is *&lt;b&gt;keyed&lt;/b&gt;*, then the function is a `KeyedBroadcastProcessFunction`. &lt;br/&gt;
    + - if it is *&lt;b&gt;non-keyed&lt;/b&gt;*, the function is a `BroadcastProcessFunction`. &lt;br/&gt;
    + &lt;br/&gt;
    + Given that our non-broadcasted stream is keyed, the following snippet includes the above calls:&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The connect should be called on the non-broadcasted stream, with the `BroadcastStream`&lt;br/&gt;
    +   as an argument.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +DataStream&amp;lt;Match&amp;gt; output = colorPartitionedStream&lt;br/&gt;
    +                 .connect(ruleBroadcastStream)&lt;br/&gt;
    +                 .process(&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     // type arguments in our KeyedBroadcastProcessFunction represent: &lt;br/&gt;
    +                     //   1. the key of the keyed stream&lt;br/&gt;
    +                     //   2. the type of elements in the non-broadcast side&lt;br/&gt;
    +                     //   3. the type of elements in the broadcast side&lt;br/&gt;
    +                     //   4. the type of the result, here a string&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {
    +                         // my matching logic
    +                     }&lt;br/&gt;
    +                 )&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +### BroadcastProcessFunction and KeyedBroadcastProcessFunction&lt;br/&gt;
    +&lt;br/&gt;
    +As in the case of a `CoProcessFunction`, these methods have two &quot;sides&quot;, one is responsible for processing incoming &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    maybe we can just say -&lt;/p&gt;

&lt;p&gt;    As in the case of a `CoProcessFunction`, these functions have two process methods to implement; one is ......&lt;br/&gt;
    IMO, its more direct, and more formal. What do you think?&lt;/p&gt;</comment>
                            <comment id="16465547" author="githubbot" created="Mon, 7 May 2018 07:16:07 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r186342816&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r186342816&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,279 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) describes operator state which upon restore is either evenly distributed among the &lt;br/&gt;
    +parallel tasks of an operator, or unioned, with the whole state being used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to specific operators that have as inputs a &lt;b&gt;broadcasted&lt;/b&gt; stream and a &lt;b&gt;non-broadcasted&lt;/b&gt; one, and&lt;br/&gt;
    + 3. such an operator can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolves over time. &lt;br/&gt;
    +&lt;br/&gt;
    +In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other&lt;br/&gt;
    +stream will contain the `Rules`.&lt;br/&gt;
    +&lt;br/&gt;
    +Starting from the stream of `Items`, we just need to &lt;b&gt;key it&lt;/b&gt; by `Color`, as we want pairs of the same color. This will&lt;br/&gt;
    +make sure that elements of the same color end up on the same physical machine.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +// key the shapes by color&lt;br/&gt;
    +KeyedStream&amp;lt;Item, Color&amp;gt; colorPartitionedStream = shapeStream&lt;br/&gt;
    +                        .keyBy(new KeySelector&amp;lt;Shape, Color&amp;gt;(){...});&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks &lt;br/&gt;
    +should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast &lt;br/&gt;
    +the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules&lt;br/&gt;
    +will be stored.&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +&lt;br/&gt;
    +// a map descriptor to store the name of the rule (string) and the rule itself.&lt;br/&gt;
    +MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +				&quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +				BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +				TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {})&lt;br/&gt;
    +		);&lt;br/&gt;
    +		&lt;br/&gt;
    +// broadcast the rules and create the broadcast state&lt;br/&gt;
    +BroadcastStream&amp;lt;Rule&amp;gt; ruleBroadcastStream = ruleStream&lt;br/&gt;
    +                        .broadcast(ruleStateDescriptor);&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in order to evaluate the `Rules` against the incoming elements from the `Item` stream, we need to:&lt;br/&gt;
    +    1) connect the two streams and &lt;br/&gt;
    +    2) specify our match detecting logic. &lt;br/&gt;
    +&lt;br/&gt;
    +Connecting a stream (keyed or non-keyed) with a `BroadcastStream` can be done by calling `connect()` on the &lt;br/&gt;
    +non-broadcasted stream, with the `BroadcastStream` as an argument. This will return a `BroadcastConnectedStream`, on &lt;br/&gt;
    +which we can call `process()` with a special type of `CoProcessFunction`. The function will contain our matching logic. &lt;br/&gt;
    +The exact type of the function depends on the type of the non-broadcasted stream: &lt;br/&gt;
    + - if that is *&lt;b&gt;keyed&lt;/b&gt;*, then the function is a `KeyedBroadcastProcessFunction`. &lt;br/&gt;
    + - if it is *&lt;b&gt;non-keyed&lt;/b&gt;*, the function is a `BroadcastProcessFunction`. &lt;br/&gt;
    + &lt;br/&gt;
    + Given that our non-broadcasted stream is keyed, the following snippet includes the above calls:&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The connect should be called on the non-broadcasted stream, with the `BroadcastStream`&lt;br/&gt;
    +   as an argument.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +DataStream&amp;lt;Match&amp;gt; output = colorPartitionedStream&lt;br/&gt;
    +                 .connect(ruleBroadcastStream)&lt;br/&gt;
    +                 .process(&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     // type arguments in our KeyedBroadcastProcessFunction represent: &lt;br/&gt;
    +                     //   1. the key of the keyed stream&lt;br/&gt;
    +                     //   2. the type of elements in the non-broadcast side&lt;br/&gt;
    +                     //   3. the type of elements in the broadcast side&lt;br/&gt;
    +                     //   4. the type of the result, here a string&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {
    +                         // my matching logic
    +                     }&lt;br/&gt;
    +                 )&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +### BroadcastProcessFunction and KeyedBroadcastProcessFunction&lt;br/&gt;
    +&lt;br/&gt;
    +As in the case of a `CoProcessFunction`, these methods have two &quot;sides&quot;, one is responsible for processing incoming &lt;br/&gt;
    +elements in the broadcasted stream and one is used for the non-broadcasted one. This is reflected in the methods to be &lt;br/&gt;
    +implemented, which are presented below.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +public abstract class BroadcastProcessFunction&amp;lt;IN1, IN2, OUT&amp;gt; extends BaseBroadcastProcessFunction {
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +public abstract class KeyedBroadcastProcessFunction&amp;lt;KS, IN1, IN2, OUT&amp;gt; &lt;/p&gt;
{
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public void onTimer(long timestamp, OnTimerContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}
&lt;p&gt;    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +The first thing to notice is that both functions require the implementation of the `processBroadcastElement()` method &lt;br/&gt;
    +for processing elements in the broadcast side and the `processElement()` for elements in the non-broadcasted side. &lt;br/&gt;
    +&lt;br/&gt;
    +The two methods differ in the context they are provided. The non-broadcast side has a `ReadOnlyContext`, while the &lt;br/&gt;
    +broadcasted side has a `Context`. &lt;br/&gt;
    +&lt;br/&gt;
    +Both of these contexts (`ctx` in the following enumeration):&lt;br/&gt;
    + 1. give access to the broadcast state: `ctx.getBroadcastState(MapStateDescriptor&amp;lt;K, V&amp;gt; stateDescriptor)`&lt;br/&gt;
    + 2. allow to query the timestamp of the element: `ctx.timestamp()`, &lt;br/&gt;
    + 3. get the current watermark: `ctx.currentWatermark()`&lt;br/&gt;
    + 4. get the current processing time: `ctx.currentProcessingTime()`, and &lt;br/&gt;
    + 5. emit elements to side-outputs: `ctx.output(OutputTag&amp;lt;X&amp;gt; outputTag, X value)`. &lt;br/&gt;
    +&lt;br/&gt;
    +The `stateDescriptor` in the `getBroadcastState()` should be identical to the one in the `.broadcast(ruleStateDescriptor)` &lt;br/&gt;
    +above.&lt;br/&gt;
    +&lt;br/&gt;
    +The difference lies in the type of access each one gives to the broadcast state. The broadcasted side has &lt;br/&gt;
    +*&lt;b&gt;read-write access&lt;/b&gt;* to it, while the non-broadcast side has *&lt;b&gt;read-only access&lt;/b&gt;* (thus the names). The reason for this&lt;br/&gt;
    +is that in Flink there is no cross-task communication. So, to guarantee that the contents in the Broadcast State are the&lt;br/&gt;
    +same across all parallel instances of our operator, we give read-write access only to the broadcast side, which sees the&lt;br/&gt;
    +same elements across all tasks, and we require the computation on each incoming element on that side to be identical &lt;br/&gt;
    +across all tasks. Ignoring this rule would break the consistency guarantees of the state, leading to inconsistent and &lt;br/&gt;
    +often difficult to debug results.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The logic implemented in `processBroadcast()` must have the same determinstic behavior &lt;br/&gt;
    +  across all parallel instances!&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, due to the fact that the `KeyedBroadcastProcessFunction` is (on one &quot;side&quot;) operating on a keyed stream, it &lt;br/&gt;
    +exposes some functionality which is not available to the `BroadcastProcessFunction`. That is:&lt;br/&gt;
    + 1. the `ReadOnlyContext` in the `processElement()` method gives access to Flink&apos;s underlying timer service, which allows&lt;br/&gt;
    +  to register event and/or processing time timers. When a timer fires, the `onTimer()` (shown above) is invoked with an &lt;br/&gt;
    +  `OnTimerContext` which exposes the same functionality as the `ReadOnlyContext` plus &lt;br/&gt;
    +   - the ability to ask if the timer that fired was an event or processing time one and &lt;br/&gt;
    +   - to query the key associated with the timer.&lt;br/&gt;
    +&lt;br/&gt;
    +  This is aligned with the `onTimer()` method of the `KeyedProcessFunction`. &lt;br/&gt;
    + 2. the `Context` in the `processBroadcastElement()` method contains the method &lt;br/&gt;
    + `applyToKeyedState(StateDescriptor&amp;lt;S, VS&amp;gt; stateDescriptor, KeyedStateFunction&amp;lt;KS, S&amp;gt; function)`. This allows to &lt;br/&gt;
    +  register a `KeyedStateFunction` to be *&lt;b&gt;applied to all states of all keys&lt;/b&gt;* associated with the provided `stateDescriptor`. &lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; Registering timers is only possible at `processElement()` of the `KeyedBroadcastProcessFunction`&lt;br/&gt;
    +  and only there. It is not possible in the `processBroadcastElement()` method, as there is no key associated to the &lt;br/&gt;
    +  broadcasted elements.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +  &lt;br/&gt;
    +Coming back to our original example, our `KeyedBroadcastProcessFunction` could look like the following:&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +    // store partial matches, i.e. first elements of the pair waiting for their second element&lt;br/&gt;
    +    // we keep a list as we may have many first elements waiting&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; mapStateDesc =&lt;br/&gt;
    +	    new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +	        &quot;items&quot;,&lt;br/&gt;
    +	        BasicTypeInfo.STRING_TYPE_INFO, &lt;br/&gt;
    +	        new ListTypeInfo&amp;lt;&amp;gt;(Item.class));&lt;br/&gt;
    +&lt;br/&gt;
    +    // identical to our ruleStateDescriptor above&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = &lt;br/&gt;
    +        new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +    	    &quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +    		BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +    		TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {}));&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processBroadcastElement(Rule value, &lt;br/&gt;
    +	                                    Context ctx, &lt;br/&gt;
    +	                                    Collector&amp;lt;String&amp;gt; out) throws Exception {
    +	    ctx.getBroadcastState(ruleStateDescriptor).put(value.name, value);
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processElement(Item value, &lt;br/&gt;
    +	                           ReadOnlyContext ctx, &lt;br/&gt;
    +	                           Collector&amp;lt;String&amp;gt; out) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +        final MapState&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; state = getRuntimeContext().getMapState(mapStateDesc);&lt;br/&gt;
    +        final Shape shape = value.getShape();&lt;br/&gt;
    +    &lt;br/&gt;
    +        for (Map.Entry&amp;lt;String, Rule&amp;gt; entry: &lt;br/&gt;
    +                ctx.getBroadcastState(ruleStateDescriptor).immutableEntries()) {&lt;br/&gt;
    +            final String ruleName = entry.getKey();&lt;br/&gt;
    +            final Rule rule = entry.getValue();&lt;br/&gt;
    +    &lt;br/&gt;
    +            List&amp;lt;Item&amp;gt; stored = state.get(ruleName);&lt;br/&gt;
    +            if (stored == null) {
    +                stored = new ArrayList&amp;lt;&amp;gt;();
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (shape == rule.second &amp;amp;&amp;amp; !stored.isEmpty()) {&lt;br/&gt;
    +                for (Item i : stored) {
    +                    out.collect(&quot;MATCH: &quot; + i + &quot; - &quot; + value);
    +                }&lt;br/&gt;
    +                stored.clear();&lt;br/&gt;
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            // there is  no else{} to cover if rule.first == rule.second&lt;br/&gt;
    +            if (shape.equals(rule.first)) {
    +                stored.add(value);
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (stored.isEmpty()) {
    +                state.remove(ruleName);
    +            } else {
    +                state.put(ruleName, stored);
    +            }&lt;br/&gt;
    +        }&lt;br/&gt;
    +	}&lt;br/&gt;
    +}&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +## Important Considerations&lt;br/&gt;
    +&lt;br/&gt;
    +After describing the offered APIs, this section focuses on the important things to keep in mind when using broadcast &lt;br/&gt;
    +state. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;There is no cross-task communication:&lt;/b&gt;* As stated earlier, this is the reason why only the broadcast side of a &lt;br/&gt;
    +`(Keyed)-BroadcastProcessFunction` can modify the contents of the broadcast state. In addition, the user has to make &lt;br/&gt;
    +sure that all tasks modify the contents of the broadcast state in the same way for each incoming element. Otherwise,&lt;br/&gt;
    +different tasks might have different contents, leading to inconsistent results.&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;Order of events in Broadcast State may differ across tasks:&lt;/b&gt;* Although broadcasting the elements of a stream &lt;br/&gt;
    +guarantees that all elements will go to all downstream tasks, elements may arrive in a different order on each task. &lt;br/&gt;
    +This implies that although all tasks will (eventually) have the same elements in their broadcast state, these may not &lt;br/&gt;
    +be in the same order.&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;All tasks checkpoint their state:&lt;/b&gt;* Although all tasks have the same elements when a checkpoint takes place &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This sections refers to broadcast state only, correct (the round-robin read, avoiding hotspots, etc.)?&lt;br/&gt;
    The problem here is that this sections refers to &quot;state&quot; only, and not broadcast state, so some users might find it slightly confusing.&lt;/p&gt;</comment>
                            <comment id="16465548" author="githubbot" created="Mon, 7 May 2018 07:16:07 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r186341972&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r186341972&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,279 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) describes operator state which upon restore is either evenly distributed among the &lt;br/&gt;
    +parallel tasks of an operator, or unioned, with the whole state being used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to specific operators that have as inputs a &lt;b&gt;broadcasted&lt;/b&gt; stream and a &lt;b&gt;non-broadcasted&lt;/b&gt; one, and&lt;br/&gt;
    + 3. such an operator can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolves over time. &lt;br/&gt;
    +&lt;br/&gt;
    +In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other&lt;br/&gt;
    +stream will contain the `Rules`.&lt;br/&gt;
    +&lt;br/&gt;
    +Starting from the stream of `Items`, we just need to &lt;b&gt;key it&lt;/b&gt; by `Color`, as we want pairs of the same color. This will&lt;br/&gt;
    +make sure that elements of the same color end up on the same physical machine.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +// key the shapes by color&lt;br/&gt;
    +KeyedStream&amp;lt;Item, Color&amp;gt; colorPartitionedStream = shapeStream&lt;br/&gt;
    +                        .keyBy(new KeySelector&amp;lt;Shape, Color&amp;gt;(){...});&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks &lt;br/&gt;
    +should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast &lt;br/&gt;
    +the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules&lt;br/&gt;
    +will be stored.&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +&lt;br/&gt;
    +// a map descriptor to store the name of the rule (string) and the rule itself.&lt;br/&gt;
    +MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +				&quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +				BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +				TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {})&lt;br/&gt;
    +		);&lt;br/&gt;
    +		&lt;br/&gt;
    +// broadcast the rules and create the broadcast state&lt;br/&gt;
    +BroadcastStream&amp;lt;Rule&amp;gt; ruleBroadcastStream = ruleStream&lt;br/&gt;
    +                        .broadcast(ruleStateDescriptor);&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in order to evaluate the `Rules` against the incoming elements from the `Item` stream, we need to:&lt;br/&gt;
    +    1) connect the two streams and &lt;br/&gt;
    +    2) specify our match detecting logic. &lt;br/&gt;
    +&lt;br/&gt;
    +Connecting a stream (keyed or non-keyed) with a `BroadcastStream` can be done by calling `connect()` on the &lt;br/&gt;
    +non-broadcasted stream, with the `BroadcastStream` as an argument. This will return a `BroadcastConnectedStream`, on &lt;br/&gt;
    +which we can call `process()` with a special type of `CoProcessFunction`. The function will contain our matching logic. &lt;br/&gt;
    +The exact type of the function depends on the type of the non-broadcasted stream: &lt;br/&gt;
    + - if that is *&lt;b&gt;keyed&lt;/b&gt;*, then the function is a `KeyedBroadcastProcessFunction`. &lt;br/&gt;
    + - if it is *&lt;b&gt;non-keyed&lt;/b&gt;*, the function is a `BroadcastProcessFunction`. &lt;br/&gt;
    + &lt;br/&gt;
    + Given that our non-broadcasted stream is keyed, the following snippet includes the above calls:&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The connect should be called on the non-broadcasted stream, with the `BroadcastStream`&lt;br/&gt;
    +   as an argument.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +DataStream&amp;lt;Match&amp;gt; output = colorPartitionedStream&lt;br/&gt;
    +                 .connect(ruleBroadcastStream)&lt;br/&gt;
    +                 .process(&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     // type arguments in our KeyedBroadcastProcessFunction represent: &lt;br/&gt;
    +                     //   1. the key of the keyed stream&lt;br/&gt;
    +                     //   2. the type of elements in the non-broadcast side&lt;br/&gt;
    +                     //   3. the type of elements in the broadcast side&lt;br/&gt;
    +                     //   4. the type of the result, here a string&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {
    +                         // my matching logic
    +                     }&lt;br/&gt;
    +                 )&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +### BroadcastProcessFunction and KeyedBroadcastProcessFunction&lt;br/&gt;
    +&lt;br/&gt;
    +As in the case of a `CoProcessFunction`, these methods have two &quot;sides&quot;, one is responsible for processing incoming &lt;br/&gt;
    +elements in the broadcasted stream and one is used for the non-broadcasted one. This is reflected in the methods to be &lt;br/&gt;
    +implemented, which are presented below.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +public abstract class BroadcastProcessFunction&amp;lt;IN1, IN2, OUT&amp;gt; extends BaseBroadcastProcessFunction {
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +public abstract class KeyedBroadcastProcessFunction&amp;lt;KS, IN1, IN2, OUT&amp;gt; &lt;/p&gt;
{
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public void onTimer(long timestamp, OnTimerContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}
&lt;p&gt;    +&lt;/p&gt;
{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +The first thing to notice is that both functions require the implementation of the `processBroadcastElement()` method &lt;br/&gt;
    +for processing elements in the broadcast side and the `processElement()` for elements in the non-broadcasted side. &lt;br/&gt;
    +&lt;br/&gt;
    +The two methods differ in the context they are provided. The non-broadcast side has a `ReadOnlyContext`, while the &lt;br/&gt;
    +broadcasted side has a `Context`. &lt;br/&gt;
    +&lt;br/&gt;
    +Both of these contexts (`ctx` in the following enumeration):&lt;br/&gt;
    + 1. give access to the broadcast state: `ctx.getBroadcastState(MapStateDescriptor&amp;lt;K, V&amp;gt; stateDescriptor)`&lt;br/&gt;
    + 2. allow to query the timestamp of the element: `ctx.timestamp()`, &lt;br/&gt;
    + 3. get the current watermark: `ctx.currentWatermark()`&lt;br/&gt;
    + 4. get the current processing time: `ctx.currentProcessingTime()`, and &lt;br/&gt;
    + 5. emit elements to side-outputs: `ctx.output(OutputTag&amp;lt;X&amp;gt; outputTag, X value)`. &lt;br/&gt;
    +&lt;br/&gt;
    +The `stateDescriptor` in the `getBroadcastState()` should be identical to the one in the `.broadcast(ruleStateDescriptor)` &lt;br/&gt;
    +above.&lt;br/&gt;
    +&lt;br/&gt;
    +The difference lies in the type of access each one gives to the broadcast state. The broadcasted side has &lt;br/&gt;
    +*&lt;b&gt;read-write access&lt;/b&gt;* to it, while the non-broadcast side has *&lt;b&gt;read-only access&lt;/b&gt;* (thus the names). The reason for this&lt;br/&gt;
    +is that in Flink there is no cross-task communication. So, to guarantee that the contents in the Broadcast State are the&lt;br/&gt;
    +same across all parallel instances of our operator, we give read-write access only to the broadcast side, which sees the&lt;br/&gt;
    +same elements across all tasks, and we require the computation on each incoming element on that side to be identical &lt;br/&gt;
    +across all tasks. Ignoring this rule would break the consistency guarantees of the state, leading to inconsistent and &lt;br/&gt;
    +often difficult to debug results.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The logic implemented in `processBroadcast()` must have the same determinstic behavior &lt;br/&gt;
    +  across all parallel instances!&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, due to the fact that the `KeyedBroadcastProcessFunction` is (on one &quot;side&quot;) operating on a keyed stream, it &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Same comment here about the use of wording on &quot;side&quot;.&lt;/p&gt;</comment>
                            <comment id="16465549" author="githubbot" created="Mon, 7 May 2018 07:16:07 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r186342376&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r186342376&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,279 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) describes operator state which upon restore is either evenly distributed among the &lt;br/&gt;
    +parallel tasks of an operator, or unioned, with the whole state being used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to specific operators that have as inputs a &lt;b&gt;broadcasted&lt;/b&gt; stream and a &lt;b&gt;non-broadcasted&lt;/b&gt; one, and&lt;br/&gt;
    + 3. such an operator can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolves over time. &lt;br/&gt;
    +&lt;br/&gt;
    +In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other&lt;br/&gt;
    +stream will contain the `Rules`.&lt;br/&gt;
    +&lt;br/&gt;
    +Starting from the stream of `Items`, we just need to &lt;b&gt;key it&lt;/b&gt; by `Color`, as we want pairs of the same color. This will&lt;br/&gt;
    +make sure that elements of the same color end up on the same physical machine.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +// key the shapes by color&lt;br/&gt;
    +KeyedStream&amp;lt;Item, Color&amp;gt; colorPartitionedStream = shapeStream&lt;br/&gt;
    +                        .keyBy(new KeySelector&amp;lt;Shape, Color&amp;gt;(){...});&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks &lt;br/&gt;
    +should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast &lt;br/&gt;
    +the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules&lt;br/&gt;
    +will be stored.&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +&lt;br/&gt;
    +// a map descriptor to store the name of the rule (string) and the rule itself.&lt;br/&gt;
    +MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +				&quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +				BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +				TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {})&lt;br/&gt;
    +		);&lt;br/&gt;
    +		&lt;br/&gt;
    +// broadcast the rules and create the broadcast state&lt;br/&gt;
    +BroadcastStream&amp;lt;Rule&amp;gt; ruleBroadcastStream = ruleStream&lt;br/&gt;
    +                        .broadcast(ruleStateDescriptor);&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in order to evaluate the `Rules` against the incoming elements from the `Item` stream, we need to:&lt;br/&gt;
    +    1) connect the two streams and &lt;br/&gt;
    +    2) specify our match detecting logic. &lt;br/&gt;
    +&lt;br/&gt;
    +Connecting a stream (keyed or non-keyed) with a `BroadcastStream` can be done by calling `connect()` on the &lt;br/&gt;
    +non-broadcasted stream, with the `BroadcastStream` as an argument. This will return a `BroadcastConnectedStream`, on &lt;br/&gt;
    +which we can call `process()` with a special type of `CoProcessFunction`. The function will contain our matching logic. &lt;br/&gt;
    +The exact type of the function depends on the type of the non-broadcasted stream: &lt;br/&gt;
    + - if that is *&lt;b&gt;keyed&lt;/b&gt;*, then the function is a `KeyedBroadcastProcessFunction`. &lt;br/&gt;
    + - if it is *&lt;b&gt;non-keyed&lt;/b&gt;*, the function is a `BroadcastProcessFunction`. &lt;br/&gt;
    + &lt;br/&gt;
    + Given that our non-broadcasted stream is keyed, the following snippet includes the above calls:&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The connect should be called on the non-broadcasted stream, with the `BroadcastStream`&lt;br/&gt;
    +   as an argument.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +DataStream&amp;lt;Match&amp;gt; output = colorPartitionedStream&lt;br/&gt;
    +                 .connect(ruleBroadcastStream)&lt;br/&gt;
    +                 .process(&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     // type arguments in our KeyedBroadcastProcessFunction represent: &lt;br/&gt;
    +                     //   1. the key of the keyed stream&lt;br/&gt;
    +                     //   2. the type of elements in the non-broadcast side&lt;br/&gt;
    +                     //   3. the type of elements in the broadcast side&lt;br/&gt;
    +                     //   4. the type of the result, here a string&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {
    +                         // my matching logic
    +                     }&lt;br/&gt;
    +                 )&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +### BroadcastProcessFunction and KeyedBroadcastProcessFunction&lt;br/&gt;
    +&lt;br/&gt;
    +As in the case of a `CoProcessFunction`, these methods have two &quot;sides&quot;, one is responsible for processing incoming &lt;br/&gt;
    +elements in the broadcasted stream and one is used for the non-broadcasted one. This is reflected in the methods to be &lt;br/&gt;
    +implemented, which are presented below.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +public abstract class BroadcastProcessFunction&amp;lt;IN1, IN2, OUT&amp;gt; extends BaseBroadcastProcessFunction {
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +public abstract class KeyedBroadcastProcessFunction&amp;lt;KS, IN1, IN2, OUT&amp;gt; &lt;/p&gt;
{
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public void onTimer(long timestamp, OnTimerContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}
&lt;p&gt;    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +The first thing to notice is that both functions require the implementation of the `processBroadcastElement()` method &lt;br/&gt;
    +for processing elements in the broadcast side and the `processElement()` for elements in the non-broadcasted side. &lt;br/&gt;
    +&lt;br/&gt;
    +The two methods differ in the context they are provided. The non-broadcast side has a `ReadOnlyContext`, while the &lt;br/&gt;
    +broadcasted side has a `Context`. &lt;br/&gt;
    +&lt;br/&gt;
    +Both of these contexts (`ctx` in the following enumeration):&lt;br/&gt;
    + 1. give access to the broadcast state: `ctx.getBroadcastState(MapStateDescriptor&amp;lt;K, V&amp;gt; stateDescriptor)`&lt;br/&gt;
    + 2. allow to query the timestamp of the element: `ctx.timestamp()`, &lt;br/&gt;
    + 3. get the current watermark: `ctx.currentWatermark()`&lt;br/&gt;
    + 4. get the current processing time: `ctx.currentProcessingTime()`, and &lt;br/&gt;
    + 5. emit elements to side-outputs: `ctx.output(OutputTag&amp;lt;X&amp;gt; outputTag, X value)`. &lt;br/&gt;
    +&lt;br/&gt;
    +The `stateDescriptor` in the `getBroadcastState()` should be identical to the one in the `.broadcast(ruleStateDescriptor)` &lt;br/&gt;
    +above.&lt;br/&gt;
    +&lt;br/&gt;
    +The difference lies in the type of access each one gives to the broadcast state. The broadcasted side has &lt;br/&gt;
    +*&lt;b&gt;read-write access&lt;/b&gt;* to it, while the non-broadcast side has *&lt;b&gt;read-only access&lt;/b&gt;* (thus the names). The reason for this&lt;br/&gt;
    +is that in Flink there is no cross-task communication. So, to guarantee that the contents in the Broadcast State are the&lt;br/&gt;
    +same across all parallel instances of our operator, we give read-write access only to the broadcast side, which sees the&lt;br/&gt;
    +same elements across all tasks, and we require the computation on each incoming element on that side to be identical &lt;br/&gt;
    +across all tasks. Ignoring this rule would break the consistency guarantees of the state, leading to inconsistent and &lt;br/&gt;
    +often difficult to debug results.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The logic implemented in `processBroadcast()` must have the same determinstic behavior &lt;br/&gt;
    +  across all parallel instances!&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, due to the fact that the `KeyedBroadcastProcessFunction` is (on one &quot;side&quot;) operating on a keyed stream, it &lt;br/&gt;
    +exposes some functionality which is not available to the `BroadcastProcessFunction`. That is:&lt;br/&gt;
    + 1. the `ReadOnlyContext` in the `processElement()` method gives access to Flink&apos;s underlying timer service, which allows&lt;br/&gt;
    +  to register event and/or processing time timers. When a timer fires, the `onTimer()` (shown above) is invoked with an &lt;br/&gt;
    +  `OnTimerContext` which exposes the same functionality as the `ReadOnlyContext` plus &lt;br/&gt;
    +   - the ability to ask if the timer that fired was an event or processing time one and &lt;br/&gt;
    +   - to query the key associated with the timer.&lt;br/&gt;
    +&lt;br/&gt;
    +  This is aligned with the `onTimer()` method of the `KeyedProcessFunction`. &lt;br/&gt;
    + 2. the `Context` in the `processBroadcastElement()` method contains the method &lt;br/&gt;
    + `applyToKeyedState(StateDescriptor&amp;lt;S, VS&amp;gt; stateDescriptor, KeyedStateFunction&amp;lt;KS, S&amp;gt; function)`. This allows to &lt;br/&gt;
    +  register a `KeyedStateFunction` to be *&lt;b&gt;applied to all states of all keys&lt;/b&gt;* associated with the provided `stateDescriptor`. &lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; Registering timers is only possible at `processElement()` of the `KeyedBroadcastProcessFunction`&lt;br/&gt;
    +  and only there. It is not possible in the `processBroadcastElement()` method, as there is no key associated to the &lt;br/&gt;
    +  broadcasted elements.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +  &lt;br/&gt;
    +Coming back to our original example, our `KeyedBroadcastProcessFunction` could look like the following:&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +    // store partial matches, i.e. first elements of the pair waiting for their second element&lt;br/&gt;
    +    // we keep a list as we may have many first elements waiting&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; mapStateDesc =&lt;br/&gt;
    +	    new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +	        &quot;items&quot;,&lt;br/&gt;
    +	        BasicTypeInfo.STRING_TYPE_INFO, &lt;br/&gt;
    +	        new ListTypeInfo&amp;lt;&amp;gt;(Item.class));&lt;br/&gt;
    +&lt;br/&gt;
    +    // identical to our ruleStateDescriptor above&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = &lt;br/&gt;
    +        new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +    	    &quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +    		BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +    		TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {}));&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processBroadcastElement(Rule value, &lt;br/&gt;
    +	                                    Context ctx, &lt;br/&gt;
    +	                                    Collector&amp;lt;String&amp;gt; out) throws Exception {
    +	    ctx.getBroadcastState(ruleStateDescriptor).put(value.name, value);
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processElement(Item value, &lt;br/&gt;
    +	                           ReadOnlyContext ctx, &lt;br/&gt;
    +	                           Collector&amp;lt;String&amp;gt; out) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +        final MapState&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; state = getRuntimeContext().getMapState(mapStateDesc);&lt;br/&gt;
    +        final Shape shape = value.getShape();&lt;br/&gt;
    +    &lt;br/&gt;
    +        for (Map.Entry&amp;lt;String, Rule&amp;gt; entry: &lt;br/&gt;
    +                ctx.getBroadcastState(ruleStateDescriptor).immutableEntries()) {&lt;br/&gt;
    +            final String ruleName = entry.getKey();&lt;br/&gt;
    +            final Rule rule = entry.getValue();&lt;br/&gt;
    +    &lt;br/&gt;
    +            List&amp;lt;Item&amp;gt; stored = state.get(ruleName);&lt;br/&gt;
    +            if (stored == null) {
    +                stored = new ArrayList&amp;lt;&amp;gt;();
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (shape == rule.second &amp;amp;&amp;amp; !stored.isEmpty()) {&lt;br/&gt;
    +                for (Item i : stored) {
    +                    out.collect(&quot;MATCH: &quot; + i + &quot; - &quot; + value);
    +                }&lt;br/&gt;
    +                stored.clear();&lt;br/&gt;
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            // there is  no else{} to cover if rule.first == rule.second&lt;br/&gt;
    +            if (shape.equals(rule.first)) {
    +                stored.add(value);
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (stored.isEmpty()) {
    +                state.remove(ruleName);
    +            } else {
    +                state.put(ruleName, stored);
    +            }&lt;br/&gt;
    +        }&lt;br/&gt;
    +	}&lt;br/&gt;
    +}&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +## Important Considerations&lt;br/&gt;
    +&lt;br/&gt;
    +After describing the offered APIs, this section focuses on the important things to keep in mind when using broadcast &lt;br/&gt;
    +state. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;There is no cross-task communication:&lt;/b&gt;* As stated earlier, this is the reason why only the broadcast side of a &lt;br/&gt;
    +`(Keyed)-BroadcastProcessFunction` can modify the contents of the broadcast state. In addition, the user has to make &lt;br/&gt;
    +sure that all tasks modify the contents of the broadcast state in the same way for each incoming element. Otherwise,&lt;br/&gt;
    +different tasks might have different contents, leading to inconsistent results.&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;Order of events in Broadcast State may differ across tasks:&lt;/b&gt;* Although broadcasting the elements of a stream &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Maybe we should simply clearly state that, the state update for each incoming element *&lt;b&gt;CANNOT&lt;/b&gt;* be order-depending.&lt;/p&gt;</comment>
                            <comment id="16474066" author="githubbot" created="Mon, 14 May 2018 11:43:40 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r187922328&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r187922328&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,279 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) describes operator state which upon restore is either evenly distributed among the &lt;br/&gt;
    +parallel tasks of an operator, or unioned, with the whole state being used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to specific operators that have as inputs a &lt;b&gt;broadcasted&lt;/b&gt; stream and a &lt;b&gt;non-broadcasted&lt;/b&gt; one, and&lt;br/&gt;
    + 3. such an operator can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolves over time. &lt;br/&gt;
    +&lt;br/&gt;
    +In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other&lt;br/&gt;
    +stream will contain the `Rules`.&lt;br/&gt;
    +&lt;br/&gt;
    +Starting from the stream of `Items`, we just need to &lt;b&gt;key it&lt;/b&gt; by `Color`, as we want pairs of the same color. This will&lt;br/&gt;
    +make sure that elements of the same color end up on the same physical machine.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +// key the shapes by color&lt;br/&gt;
    +KeyedStream&amp;lt;Item, Color&amp;gt; colorPartitionedStream = shapeStream&lt;br/&gt;
    +                        .keyBy(new KeySelector&amp;lt;Shape, Color&amp;gt;(){...});&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks &lt;br/&gt;
    +should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast &lt;br/&gt;
    +the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules&lt;br/&gt;
    +will be stored.&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +&lt;br/&gt;
    +// a map descriptor to store the name of the rule (string) and the rule itself.&lt;br/&gt;
    +MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +				&quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +				BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +				TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {})&lt;br/&gt;
    +		);&lt;br/&gt;
    +		&lt;br/&gt;
    +// broadcast the rules and create the broadcast state&lt;br/&gt;
    +BroadcastStream&amp;lt;Rule&amp;gt; ruleBroadcastStream = ruleStream&lt;br/&gt;
    +                        .broadcast(ruleStateDescriptor);&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +Finally, in order to evaluate the `Rules` against the incoming elements from the `Item` stream, we need to:&lt;br/&gt;
    +    1) connect the two streams and &lt;br/&gt;
    +    2) specify our match detecting logic. &lt;br/&gt;
    +&lt;br/&gt;
    +Connecting a stream (keyed or non-keyed) with a `BroadcastStream` can be done by calling `connect()` on the &lt;br/&gt;
    +non-broadcasted stream, with the `BroadcastStream` as an argument. This will return a `BroadcastConnectedStream`, on &lt;br/&gt;
    +which we can call `process()` with a special type of `CoProcessFunction`. The function will contain our matching logic. &lt;br/&gt;
    +The exact type of the function depends on the type of the non-broadcasted stream: &lt;br/&gt;
    + - if that is *&lt;b&gt;keyed&lt;/b&gt;*, then the function is a `KeyedBroadcastProcessFunction`. &lt;br/&gt;
    + - if it is *&lt;b&gt;non-keyed&lt;/b&gt;*, the function is a `BroadcastProcessFunction`. &lt;br/&gt;
    + &lt;br/&gt;
    + Given that our non-broadcasted stream is keyed, the following snippet includes the above calls:&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The connect should be called on the non-broadcasted stream, with the `BroadcastStream`&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    It is not even available as an option to call `connect()` in this case. The `broadcast(descriptor)` will give you a `BroadcastStream` back that has no available transformations. You can only use it as an argument for a `connect()`.&lt;/p&gt;</comment>
                            <comment id="16474071" author="githubbot" created="Mon, 14 May 2018 11:53:15 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922#discussion_r187924456&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922#discussion_r187924456&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: docs/dev/stream/state/broadcast_state.md &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,279 @@&lt;br/&gt;
    +---&lt;br/&gt;
    +title: &quot;The Broadcast State Pattern&quot;&lt;br/&gt;
    +nav-parent_id: streaming_state&lt;br/&gt;
    +nav-pos: 2&lt;br/&gt;
    +---&lt;br/&gt;
    +&amp;lt;!--&lt;br/&gt;
    +Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    +or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    +distributed with this work for additional information&lt;br/&gt;
    +regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    +to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    +&quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    +with the License.  You may obtain a copy of the License at&lt;br/&gt;
    +&lt;br/&gt;
    +  &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Unless required by applicable law or agreed to in writing,&lt;br/&gt;
    +software distributed under the License is distributed on an&lt;br/&gt;
    +&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&lt;br/&gt;
    +KIND, either express or implied.  See the License for the&lt;br/&gt;
    +specific language governing permissions and limitations&lt;br/&gt;
    +under the License.&lt;br/&gt;
    +--&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +* ToC&lt;br/&gt;
    +{:toc}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;span class=&quot;error&quot;&gt;&amp;#91;Working with State&amp;#93;&lt;/span&gt;(state.html) describes operator state which upon restore is either evenly distributed among the &lt;br/&gt;
    +parallel tasks of an operator, or unioned, with the whole state being used to initialize the restored parallel tasks.&lt;br/&gt;
    +&lt;br/&gt;
    +A third type of supported &lt;b&gt;operator state&lt;/b&gt; is the &lt;b&gt;Broadcast State&lt;/b&gt;. Broadcast state was introduced to support use cases&lt;br/&gt;
    +where some data coming from one stream is required to be broadcasted to all downstream tasks, where it is stored locally&lt;br/&gt;
    +and is used to process all incoming elements on the other stream. As an example where broadcast state can emerge as a &lt;br/&gt;
    +natural fit, one can imagine a low-throughput stream containing a set of rules which we want to evaluate against all &lt;br/&gt;
    +elements coming from another stream. Having the above type of use cases in mind, broadcast state differs from the rest &lt;br/&gt;
    +of operator states in that:&lt;br/&gt;
    + 1. it has a map format,&lt;br/&gt;
    + 2. it is only available to specific operators that have as inputs a &lt;b&gt;broadcasted&lt;/b&gt; stream and a &lt;b&gt;non-broadcasted&lt;/b&gt; one, and&lt;br/&gt;
    + 3. such an operator can have &lt;b&gt;multiple broadcast states&lt;/b&gt; with different names.&lt;br/&gt;
    +&lt;br/&gt;
    +## Provided APIs&lt;br/&gt;
    +&lt;br/&gt;
    +To show the provided APIs, we will start with an example before presenting their full functionality. As our running &lt;br/&gt;
    +example, we will use the case where we have a stream of objects of different colors and shapes and we want to find pairs&lt;br/&gt;
    +of objects of the same color that follow a certain pattern, &lt;b&gt;e.g.&lt;/b&gt; a rectangle followed by a triangle. We assume that&lt;br/&gt;
    +the set of interesting patterns evolves over time. &lt;br/&gt;
    +&lt;br/&gt;
    +In this example, the first stream will contain elements of type `Item` with a `Color` and a `Shape` property. The other&lt;br/&gt;
    +stream will contain the `Rules`.&lt;br/&gt;
    +&lt;br/&gt;
    +Starting from the stream of `Items`, we just need to &lt;b&gt;key it&lt;/b&gt; by `Color`, as we want pairs of the same color. This will&lt;br/&gt;
    +make sure that elements of the same color end up on the same physical machine.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +// key the shapes by color&lt;br/&gt;
    +KeyedStream&amp;lt;Item, Color&amp;gt; colorPartitionedStream = shapeStream&lt;br/&gt;
    +                        .keyBy(new KeySelector&amp;lt;Shape, Color&amp;gt;(){...});&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Moving on to the `Rules`, the stream containing them should be broadcasted to all downstream tasks, and these tasks &lt;br/&gt;
    +should store them locally so that they can evaluate them against all incoming `Items`. The snippet below will i) broadcast &lt;br/&gt;
    +the stream of rules and ii) using the provided `MapStateDescriptor`, it will create the broadcast state where the rules&lt;br/&gt;
    +will be stored.&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +&lt;br/&gt;
    +// a map descriptor to store the name of the rule (string) and the rule itself.&lt;br/&gt;
    +MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +				&quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +				BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +				TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {})&lt;br/&gt;
    +		);&lt;br/&gt;
    +		&lt;br/&gt;
    +// broadcast the rules and create the broadcast state&lt;br/&gt;
    +BroadcastStream&amp;lt;Rule&amp;gt; ruleBroadcastStream = ruleStream&lt;br/&gt;
    +                        .broadcast(ruleStateDescriptor);&lt;br/&gt;
    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, in order to evaluate the `Rules` against the incoming elements from the `Item` stream, we need to:&lt;br/&gt;
    +    1) connect the two streams and &lt;br/&gt;
    +    2) specify our match detecting logic. &lt;br/&gt;
    +&lt;br/&gt;
    +Connecting a stream (keyed or non-keyed) with a `BroadcastStream` can be done by calling `connect()` on the &lt;br/&gt;
    +non-broadcasted stream, with the `BroadcastStream` as an argument. This will return a `BroadcastConnectedStream`, on &lt;br/&gt;
    +which we can call `process()` with a special type of `CoProcessFunction`. The function will contain our matching logic. &lt;br/&gt;
    +The exact type of the function depends on the type of the non-broadcasted stream: &lt;br/&gt;
    + - if that is *&lt;b&gt;keyed&lt;/b&gt;*, then the function is a `KeyedBroadcastProcessFunction`. &lt;br/&gt;
    + - if it is *&lt;b&gt;non-keyed&lt;/b&gt;*, the function is a `BroadcastProcessFunction`. &lt;br/&gt;
    + &lt;br/&gt;
    + Given that our non-broadcasted stream is keyed, the following snippet includes the above calls:&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The connect should be called on the non-broadcasted stream, with the `BroadcastStream`&lt;br/&gt;
    +   as an argument.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +DataStream&amp;lt;Match&amp;gt; output = colorPartitionedStream&lt;br/&gt;
    +                 .connect(ruleBroadcastStream)&lt;br/&gt;
    +                 .process(&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     // type arguments in our KeyedBroadcastProcessFunction represent: &lt;br/&gt;
    +                     //   1. the key of the keyed stream&lt;br/&gt;
    +                     //   2. the type of elements in the non-broadcast side&lt;br/&gt;
    +                     //   3. the type of elements in the broadcast side&lt;br/&gt;
    +                     //   4. the type of the result, here a string&lt;br/&gt;
    +                     &lt;br/&gt;
    +                     new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {
    +                         // my matching logic
    +                     }&lt;br/&gt;
    +                 )&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +### BroadcastProcessFunction and KeyedBroadcastProcessFunction&lt;br/&gt;
    +&lt;br/&gt;
    +As in the case of a `CoProcessFunction`, these methods have two &quot;sides&quot;, one is responsible for processing incoming &lt;br/&gt;
    +elements in the broadcasted stream and one is used for the non-broadcasted one. This is reflected in the methods to be &lt;br/&gt;
    +implemented, which are presented below.&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;/p&gt;
{% highlight java %}&lt;br/&gt;
    +public abstract class BroadcastProcessFunction&amp;lt;IN1, IN2, OUT&amp;gt; extends BaseBroadcastProcessFunction {
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}&lt;br/&gt;
    +{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}
&lt;p&gt;    +public abstract class KeyedBroadcastProcessFunction&amp;lt;KS, IN1, IN2, OUT&amp;gt; &lt;/p&gt;
{
    +
    +    public abstract void processElement(IN1 value, ReadOnlyContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public abstract void processBroadcastElement(IN2 value, Context ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +
    +    public void onTimer(long timestamp, OnTimerContext ctx, Collector&amp;lt;OUT&amp;gt; out) throws Exception;
    +}
&lt;p&gt;    +&lt;/p&gt;
{% endhighlight %}&lt;br/&gt;
    +&lt;br/&gt;
    +The first thing to notice is that both functions require the implementation of the `processBroadcastElement()` method &lt;br/&gt;
    +for processing elements in the broadcast side and the `processElement()` for elements in the non-broadcasted side. &lt;br/&gt;
    +&lt;br/&gt;
    +The two methods differ in the context they are provided. The non-broadcast side has a `ReadOnlyContext`, while the &lt;br/&gt;
    +broadcasted side has a `Context`. &lt;br/&gt;
    +&lt;br/&gt;
    +Both of these contexts (`ctx` in the following enumeration):&lt;br/&gt;
    + 1. give access to the broadcast state: `ctx.getBroadcastState(MapStateDescriptor&amp;lt;K, V&amp;gt; stateDescriptor)`&lt;br/&gt;
    + 2. allow to query the timestamp of the element: `ctx.timestamp()`, &lt;br/&gt;
    + 3. get the current watermark: `ctx.currentWatermark()`&lt;br/&gt;
    + 4. get the current processing time: `ctx.currentProcessingTime()`, and &lt;br/&gt;
    + 5. emit elements to side-outputs: `ctx.output(OutputTag&amp;lt;X&amp;gt; outputTag, X value)`. &lt;br/&gt;
    +&lt;br/&gt;
    +The `stateDescriptor` in the `getBroadcastState()` should be identical to the one in the `.broadcast(ruleStateDescriptor)` &lt;br/&gt;
    +above.&lt;br/&gt;
    +&lt;br/&gt;
    +The difference lies in the type of access each one gives to the broadcast state. The broadcasted side has &lt;br/&gt;
    +*&lt;b&gt;read-write access&lt;/b&gt;* to it, while the non-broadcast side has *&lt;b&gt;read-only access&lt;/b&gt;* (thus the names). The reason for this&lt;br/&gt;
    +is that in Flink there is no cross-task communication. So, to guarantee that the contents in the Broadcast State are the&lt;br/&gt;
    +same across all parallel instances of our operator, we give read-write access only to the broadcast side, which sees the&lt;br/&gt;
    +same elements across all tasks, and we require the computation on each incoming element on that side to be identical &lt;br/&gt;
    +across all tasks. Ignoring this rule would break the consistency guarantees of the state, leading to inconsistent and &lt;br/&gt;
    +often difficult to debug results.&lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; The logic implemented in `processBroadcast()` must have the same determinstic behavior &lt;br/&gt;
    +  across all parallel instances!&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +&lt;br/&gt;
    +Finally, due to the fact that the `KeyedBroadcastProcessFunction` is (on one &quot;side&quot;) operating on a keyed stream, it &lt;br/&gt;
    +exposes some functionality which is not available to the `BroadcastProcessFunction`. That is:&lt;br/&gt;
    + 1. the `ReadOnlyContext` in the `processElement()` method gives access to Flink&apos;s underlying timer service, which allows&lt;br/&gt;
    +  to register event and/or processing time timers. When a timer fires, the `onTimer()` (shown above) is invoked with an &lt;br/&gt;
    +  `OnTimerContext` which exposes the same functionality as the `ReadOnlyContext` plus &lt;br/&gt;
    +   - the ability to ask if the timer that fired was an event or processing time one and &lt;br/&gt;
    +   - to query the key associated with the timer.&lt;br/&gt;
    +&lt;br/&gt;
    +  This is aligned with the `onTimer()` method of the `KeyedProcessFunction`. &lt;br/&gt;
    + 2. the `Context` in the `processBroadcastElement()` method contains the method &lt;br/&gt;
    + `applyToKeyedState(StateDescriptor&amp;lt;S, VS&amp;gt; stateDescriptor, KeyedStateFunction&amp;lt;KS, S&amp;gt; function)`. This allows to &lt;br/&gt;
    +  register a `KeyedStateFunction` to be *&lt;b&gt;applied to all states of all keys&lt;/b&gt;* associated with the provided `stateDescriptor`. &lt;br/&gt;
    +&lt;br/&gt;
    +&amp;lt;div class=&quot;alert alert-info&quot;&amp;gt;&lt;br/&gt;
    +  &amp;lt;strong&amp;gt;Attention:&amp;lt;/strong&amp;gt; Registering timers is only possible at `processElement()` of the `KeyedBroadcastProcessFunction`&lt;br/&gt;
    +  and only there. It is not possible in the `processBroadcastElement()` method, as there is no key associated to the &lt;br/&gt;
    +  broadcasted elements.&lt;br/&gt;
    +&amp;lt;/div&amp;gt;&lt;br/&gt;
    +  &lt;br/&gt;
    +Coming back to our original example, our `KeyedBroadcastProcessFunction` could look like the following:&lt;br/&gt;
    +&lt;br/&gt;
    +{% highlight java %}&lt;br/&gt;
    +new KeyedBroadcastProcessFunction&amp;lt;Color, Item, Rule, String&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +    // store partial matches, i.e. first elements of the pair waiting for their second element&lt;br/&gt;
    +    // we keep a list as we may have many first elements waiting&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; mapStateDesc =&lt;br/&gt;
    +	    new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +	        &quot;items&quot;,&lt;br/&gt;
    +	        BasicTypeInfo.STRING_TYPE_INFO, &lt;br/&gt;
    +	        new ListTypeInfo&amp;lt;&amp;gt;(Item.class));&lt;br/&gt;
    +&lt;br/&gt;
    +    // identical to our ruleStateDescriptor above&lt;br/&gt;
    +    private final MapStateDescriptor&amp;lt;String, Rule&amp;gt; ruleStateDescriptor = &lt;br/&gt;
    +        new MapStateDescriptor&amp;lt;&amp;gt;(&lt;br/&gt;
    +    	    &quot;RulesBroadcastState&quot;,&lt;br/&gt;
    +    		BasicTypeInfo.STRING_TYPE_INFO,&lt;br/&gt;
    +    		TypeInformation.of(new TypeHint&amp;lt;Rule&amp;gt;() {}));&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processBroadcastElement(Rule value, &lt;br/&gt;
    +	                                    Context ctx, &lt;br/&gt;
    +	                                    Collector&amp;lt;String&amp;gt; out) throws Exception {
    +	    ctx.getBroadcastState(ruleStateDescriptor).put(value.name, value);
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void processElement(Item value, &lt;br/&gt;
    +	                           ReadOnlyContext ctx, &lt;br/&gt;
    +	                           Collector&amp;lt;String&amp;gt; out) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +        final MapState&amp;lt;String, List&amp;lt;Item&amp;gt;&amp;gt; state = getRuntimeContext().getMapState(mapStateDesc);&lt;br/&gt;
    +        final Shape shape = value.getShape();&lt;br/&gt;
    +    &lt;br/&gt;
    +        for (Map.Entry&amp;lt;String, Rule&amp;gt; entry: &lt;br/&gt;
    +                ctx.getBroadcastState(ruleStateDescriptor).immutableEntries()) {&lt;br/&gt;
    +            final String ruleName = entry.getKey();&lt;br/&gt;
    +            final Rule rule = entry.getValue();&lt;br/&gt;
    +    &lt;br/&gt;
    +            List&amp;lt;Item&amp;gt; stored = state.get(ruleName);&lt;br/&gt;
    +            if (stored == null) {
    +                stored = new ArrayList&amp;lt;&amp;gt;();
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (shape == rule.second &amp;amp;&amp;amp; !stored.isEmpty()) {&lt;br/&gt;
    +                for (Item i : stored) {
    +                    out.collect(&quot;MATCH: &quot; + i + &quot; - &quot; + value);
    +                }&lt;br/&gt;
    +                stored.clear();&lt;br/&gt;
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            // there is  no else{} to cover if rule.first == rule.second&lt;br/&gt;
    +            if (shape.equals(rule.first)) {
    +                stored.add(value);
    +            }&lt;br/&gt;
    +    &lt;br/&gt;
    +            if (stored.isEmpty()) {
    +                state.remove(ruleName);
    +            } else {
    +                state.put(ruleName, stored);
    +            }&lt;br/&gt;
    +        }&lt;br/&gt;
    +	}&lt;br/&gt;
    +}&lt;br/&gt;
    +{% endhighlight %}
&lt;p&gt;    +&lt;br/&gt;
    +## Important Considerations&lt;br/&gt;
    +&lt;br/&gt;
    +After describing the offered APIs, this section focuses on the important things to keep in mind when using broadcast &lt;br/&gt;
    +state. These are:&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;There is no cross-task communication:&lt;/b&gt;* As stated earlier, this is the reason why only the broadcast side of a &lt;br/&gt;
    +`(Keyed)-BroadcastProcessFunction` can modify the contents of the broadcast state. In addition, the user has to make &lt;br/&gt;
    +sure that all tasks modify the contents of the broadcast state in the same way for each incoming element. Otherwise,&lt;br/&gt;
    +different tasks might have different contents, leading to inconsistent results.&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;Order of events in Broadcast State may differ across tasks:&lt;/b&gt;* Although broadcasting the elements of a stream &lt;br/&gt;
    +guarantees that all elements will go to all downstream tasks, elements may arrive in a different order on each task. &lt;br/&gt;
    +This implies that although all tasks will (eventually) have the same elements in their broadcast state, these may not &lt;br/&gt;
    +be in the same order.&lt;br/&gt;
    +&lt;br/&gt;
    +  - *&lt;b&gt;All tasks checkpoint their state:&lt;/b&gt;* Although all tasks have the same elements when a checkpoint takes place &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Correct. I will include the word &quot;broadcast&quot;.&lt;/p&gt;</comment>
                            <comment id="16474083" author="githubbot" created="Mon, 14 May 2018 12:03:19 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for the review! Merging this.&lt;/p&gt;</comment>
                            <comment id="16474093" author="githubbot" created="Mon, 14 May 2018 12:11:11 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5922&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5922&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16474095" author="kkl0u" created="Mon, 14 May 2018 12:13:00 +0000"  >&lt;p&gt;Merged on master with&#160;e2cc831764fa1f3d1069aa09f0bcf5c74c7ae830&lt;/p&gt;

&lt;p&gt;and on release-1.5 with&#160;0a26dfaa5ddb39250edb6ca5c1f023774d0455bf&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310560">
                    <name>Problem/Incident</name>
                                            <outwardlinks description="causes">
                                        <issuelink>
            <issuekey id="13177105">FLINK-10072</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 27 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3qld3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>