<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:35:41 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-9635] Local recovery scheduling can cause spread out of tasks</title>
                <link>https://issues.apache.org/jira/browse/FLINK-9635</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;In order to make local recovery work, Flink&apos;s scheduling was changed such that it tries to be rescheduled to its previous location. In order to not occupy slots which have state of other tasks cached, the strategy will request a new slot if the old slot identified by the previous allocation id is no longer present. This also applies to newly allocated slots because there is no distinction between new or already used. This behaviour can cause that every tasks gets deployed to its own slot if the &lt;tt&gt;SlotPool&lt;/tt&gt; has released all slots in the meantime, for example. The consequence could be that a job can no longer be executed after a failure because it needs more slots than before.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13167339">FLINK-9635</key>
            <summary>Local recovery scheduling can cause spread out of tasks</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="srichter">Stefan Richter</assignee>
                                    <reporter username="trohrmann">Till Rohrmann</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Thu, 21 Jun 2018 08:06:19 +0000</created>
                <updated>Thu, 18 Apr 2019 12:40:24 +0000</updated>
                            <resolved>Thu, 1 Nov 2018 10:36:32 +0000</resolved>
                                    <version>1.5.0</version>
                    <version>1.6.2</version>
                                    <fixVersion>1.6.3</fixVersion>
                    <fixVersion>1.7.0</fixVersion>
                                    <component>Runtime / Coordination</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                                                                <comments>
                            <comment id="16546775" author="deepaks4077" created="Tue, 17 Jul 2018 15:20:55 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=till.rohrmann&quot; class=&quot;user-hover&quot; rel=&quot;till.rohrmann&quot;&gt;till.rohrmann&lt;/a&gt;, does this issue still need to be resolved, seeing as &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9583&quot; title=&quot;Wrong number of TaskManagers&amp;#39; slots after recovery.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9583&quot;&gt;&lt;del&gt;FLINK-9583&lt;/del&gt;&lt;/a&gt; has been closed? I suppose this Jira tracks the long-term solution?&lt;/p&gt;</comment>
                            <comment id="16547741" author="till.rohrmann" created="Wed, 18 Jul 2018 12:19:16 +0000"  >&lt;p&gt;Yes it still needs to be resolved. &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9583&quot; title=&quot;Wrong number of TaskManagers&amp;#39; slots after recovery.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9583&quot;&gt;&lt;del&gt;FLINK-9583&lt;/del&gt;&lt;/a&gt; is just a quick-fix which does not solve the problem if local recovery is enabled.&lt;/p&gt;</comment>
                            <comment id="16635168" author="gyfora" created="Tue, 2 Oct 2018 08:51:33 +0000"  >&lt;p&gt;Should we consider this issue a blocker? I know the proper fix is very hard and a lot of effort but the current state is very unsafe as well.&lt;/p&gt;</comment>
                            <comment id="16641027" author="till.rohrmann" created="Sun, 7 Oct 2018 10:48:56 +0000"  >&lt;p&gt;The problem exists since Flink &lt;tt&gt;1.5.0&lt;/tt&gt;. Therefore, I would not make it a blocker for &lt;tt&gt;1.7.0&lt;/tt&gt;. However, the community is actively working on fixing this problem for &lt;tt&gt;1.7.0&lt;/tt&gt;. So I hope that we can include a fix for this problem.&lt;/p&gt;</comment>
                            <comment id="16667366" author="githubbot" created="Mon, 29 Oct 2018 15:40:58 +0000"  >&lt;p&gt;StefanRRichter opened a new pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   This change fixes the task spread-out problem in scheduling with local recovery. The solution is based on creating a global set of all previous allocation ids as blacklist to avoid, but all other allocation ids are now free to take again.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   This PR contains a subset of the changes from #6898 and focuses almost purely on the fix of local recovery.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   Improved `SchedulingITCase` should work now, including previously ignored tests.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (no)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (no)&lt;/li&gt;
	&lt;li&gt;The serializers: (no)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (no)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (no)&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: (no)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (no)&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? (not applicable)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668529" author="githubbot" created="Tue, 30 Oct 2018 10:55:14 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229250429&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229250429&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -902,14 +905,14 @@ public void scheduleForExecution() throws JobException {&lt;br/&gt;
 	private CompletableFuture&amp;lt;Void&amp;gt; scheduleLazy(SlotProvider slotProvider) {&lt;/p&gt;

&lt;p&gt; 		final ArrayList&amp;lt;CompletableFuture&amp;lt;Void&amp;gt;&amp;gt; schedulingFutures = new ArrayList&amp;lt;&amp;gt;(numVerticesTotal);&lt;br/&gt;
-&lt;br/&gt;
 		// simply take the vertices without inputs.&lt;br/&gt;
 		for (ExecutionJobVertex ejv : verticesInCreationOrder) {&lt;br/&gt;
 			if (ejv.getJobVertex().isInputVertex()) {&lt;br/&gt;
 				final CompletableFuture&amp;lt;Void&amp;gt; schedulingJobVertexFuture = ejv.scheduleAll(&lt;br/&gt;
 					slotProvider,&lt;br/&gt;
 					allowQueuedScheduling,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LocationPreferenceConstraint.ALL); // since it is an input vertex, the input based location preferences should be empty&lt;br/&gt;
+					LocationPreferenceConstraint.ALL,// since it is an input vertex, the input based location preferences should be empty&lt;br/&gt;
+					Collections.emptySet()); // we provide empty set because we currently don&apos;t want to trigger a computation in the batch case&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Comment could be updated.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668530" author="githubbot" created="Tue, 30 Oct 2018 10:55:14 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229250999&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229250999&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -479,15 +482,20 @@ public void connectToPredecessors(Map&amp;lt;IntermediateDataSetID, IntermediateResult&amp;gt;&lt;br/&gt;
 	public CompletableFuture&amp;lt;Void&amp;gt; scheduleAll(&lt;br/&gt;
 			SlotProvider slotProvider,&lt;br/&gt;
 			boolean queued,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
+			LocationPreferenceConstraint locationPreferenceConstraint,&lt;br/&gt;
+			@Nonnull Set&amp;lt;AllocationID&amp;gt; allPreviousExecutionGraphAllocationIds) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   JavaDoc has not been updated.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668531" author="githubbot" created="Tue, 30 Oct 2018 10:55:14 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229251102&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229251102&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -450,6 +455,7 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {&lt;br/&gt;
 			SlotProvider slotProvider,&lt;br/&gt;
 			boolean queued,&lt;br/&gt;
 			LocationPreferenceConstraint locationPreferenceConstraint,&lt;br/&gt;
+			@Nonnull Set&amp;lt;AllocationID&amp;gt; allPreviousExecutionGraphAllocationIds,&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   JavaDoc has not been updated.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668532" author="githubbot" created="Tue, 30 Oct 2018 10:55:14 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229250625&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229250625&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -939,13 +942,18 @@ public void scheduleForExecution() throws JobException {&lt;br/&gt;
 		// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
 		final ArrayList&amp;lt;CompletableFuture&amp;lt;Execution&amp;gt;&amp;gt; allAllocationFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;/p&gt;

&lt;p&gt;+		// a (temporary) optimization to avoid collecting the previous allocations for all executions again and again&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Comment is also not 100% correct anymore, I think.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668533" author="githubbot" created="Tue, 30 Oct 2018 10:55:14 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229253693&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229253693&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PreviousAllocationSchedulingStrategy.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -48,35 +50,68 @@ private PreviousAllocationSchedulingStrategy() {}&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public &amp;lt;IN, OUT&amp;gt; OUT findMatchWithLocality(&lt;br/&gt;
 			@Nonnull SlotProfile slotProfile,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Nonnull Stream&amp;lt;IN&amp;gt; candidates,&lt;/li&gt;
	&lt;li&gt;@Nonnull Function&amp;lt;IN, SlotContext&amp;gt; contextExtractor,&lt;br/&gt;
+			@Nonnull Supplier&amp;lt;Stream&amp;lt;IN&amp;gt;&amp;gt; candidates,&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Not sure whether `Supplier&amp;lt;Stream&amp;lt;IN&amp;gt;&amp;gt;` is the best construct to be able to iterate over a collection of `IN` multiple times. I think either `Collection` or `Iterable` serve a better purpose here.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668534" author="githubbot" created="Tue, 30 Oct 2018 10:55:15 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229257342&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229257342&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexSchedulingTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -71,7 +71,7 @@ public void testSlotReleasedWhenScheduledImmediately() {&lt;/p&gt;

&lt;p&gt; 			assertEquals(ExecutionState.CREATED, vertex.getExecutionState());&lt;br/&gt;
 			// try to deploy to the slot&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL);&lt;br/&gt;
+			vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL, null);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Same here with `null` in this file.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668535" author="githubbot" created="Tue, 30 Oct 2018 10:55:15 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229259226&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229259226&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -1582,12 +1599,18 @@ void clear() {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;An implementation of the 
{@link SlotOwner}
&lt;p&gt; and &lt;/p&gt;
{@link SlotProvider}
&lt;p&gt; interfaces&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;that delegates methods as RPC calls to the SlotPool&apos;s RPC gateway.&lt;br/&gt;
 	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static class ProviderAndOwner implements SlotOwner, SlotProvider {&lt;br/&gt;
+	public static class ProviderAndOwner implements SlotOwner, SlotProvider {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		private final SlotPoolGateway gateway;&lt;br/&gt;
+		private final boolean requiresPreviousAllocationsForScheduling;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ProviderAndOwner(SlotPoolGateway gateway) {&lt;br/&gt;
+		ProviderAndOwner(SlotPoolGateway gateway, boolean requiresPreviousAllocationsForScheduling) 
{
 			this.gateway = gateway;
+			this.requiresPreviousAllocationsForScheduling = requiresPreviousAllocationsForScheduling;
+		}
&lt;p&gt;+&lt;br/&gt;
+		public boolean requiresPreviousAllocationsForScheduling() {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   This is a bit ugly imo but I don&apos;t see a better solution at the moment &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668536" author="githubbot" created="Tue, 30 Oct 2018 10:55:15 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229251157&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229251157&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -402,13 +405,15 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {&lt;br/&gt;
 	public CompletableFuture&amp;lt;Void&amp;gt; scheduleForExecution(&lt;br/&gt;
 			SlotProvider slotProvider,&lt;br/&gt;
 			boolean queued,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
+			LocationPreferenceConstraint locationPreferenceConstraint,&lt;br/&gt;
+			@Nonnull Set&amp;lt;AllocationID&amp;gt; allPreviousExecutionGraphAllocationIds) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   JavaDoc has not been updated.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668537" author="githubbot" created="Tue, 30 Oct 2018 10:55:15 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229257277&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229257277&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexCancelTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -454,7 +454,7 @@ public void testScheduleOrDeployAfterCancel() {&lt;br/&gt;
 			// it can occur as the result of races&lt;br/&gt;
 			{&lt;br/&gt;
 				Scheduler scheduler = mock(Scheduler.class);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL);&lt;br/&gt;
+				vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL, null);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   should not be `null` in this file I guess&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668538" author="githubbot" created="Tue, 30 Oct 2018 10:55:15 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229257454&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229257454&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/FailoverRegionTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -157,7 +157,7 @@ public void testMultiRegionsFailover() throws Exception {&lt;/p&gt;

&lt;p&gt; 		assertEquals(JobStatus.RUNNING, strategy.getFailoverRegion(ev11).getState());&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ev21.scheduleForExecution(slotProvider, true, LocationPreferenceConstraint.ALL);&lt;br/&gt;
+		ev21.scheduleForExecution(slotProvider, true, LocationPreferenceConstraint.ALL, null);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Same here with `null` in this file.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668539" author="githubbot" created="Tue, 30 Oct 2018 10:55:15 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229255838&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229255838&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -742,40 +761,52 @@ private void stashRequestWaitingForResourceManager(final PendingRequest pendingR&lt;br/&gt;
 	// ------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt; 	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public CompletableFuture&amp;lt;Acknowledge&amp;gt; releaseSlot(SlotRequestId slotRequestId, @Nullable SlotSharingGroupId slotSharingGroupId, Throwable cause) {&lt;br/&gt;
+	public CompletableFuture&amp;lt;Acknowledge&amp;gt; releaseSlot(&lt;br/&gt;
+		SlotRequestId slotRequestId,&lt;br/&gt;
+		@Nullable SlotSharingGroupId slotSharingGroupId,&lt;br/&gt;
+		Throwable cause) {&lt;br/&gt;
+&lt;br/&gt;
 		log.debug(&quot;Releasing slot &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt; because: {}&quot;, slotRequestId, cause != null ? cause.getMessage() : &quot;null&quot;);&lt;br/&gt;
+		return (slotSharingGroupId != null) ?&lt;br/&gt;
+			releaseSharedSlot(slotRequestId, slotSharingGroupId, cause) :&lt;br/&gt;
+			releaseSingleSlot(slotRequestId, cause);&lt;br/&gt;
+	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (slotSharingGroupId != null) {&lt;/li&gt;
	&lt;li&gt;final SlotSharingManager multiTaskSlotManager = slotSharingManagers.get(slotSharingGroupId);&lt;br/&gt;
+	private CompletableFuture&amp;lt;Acknowledge&amp;gt; releaseSharedSlot(&lt;br/&gt;
+		SlotRequestId slotRequestId,&lt;br/&gt;
+		@Nonnull SlotSharingGroupId slotSharingGroupId, Throwable cause) {&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (multiTaskSlotManager != null) {&lt;/li&gt;
	&lt;li&gt;final SlotSharingManager.TaskSlot taskSlot = multiTaskSlotManager.getTaskSlot(slotRequestId);&lt;br/&gt;
+		final SlotSharingManager multiTaskSlotManager = slotSharingManagers.get(slotSharingGroupId);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (taskSlot != null) 
{
-					taskSlot.release(cause);
-				}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;log.debug(&quot;Could not find slot &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt; in slot sharing group {}. Ignoring release slot request.&quot;, slotRequestId, slotSharingGroupId);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
+		if (multiTaskSlotManager != null) {&lt;br/&gt;
+			final SlotSharingManager.TaskSlot taskSlot = multiTaskSlotManager.getTaskSlot(slotRequestId);&lt;br/&gt;
+&lt;br/&gt;
+			if (taskSlot != null) 
{
+				taskSlot.release(cause);
 			}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;log.debug(&quot;Could not find slot sharing group {}. Ignoring release slot request.&quot;, slotSharingGroupId);&lt;br/&gt;
+				log.debug(&quot;Could not find slot &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt; in slot sharing group {}. Ignoring release slot request.&quot;, slotRequestId, slotSharingGroupId);&lt;br/&gt;
 			}&lt;br/&gt;
 		} else {&lt;/li&gt;
	&lt;li&gt;final PendingRequest pendingRequest = removePendingRequest(slotRequestId);&lt;br/&gt;
+			log.debug(&quot;Could not find slot sharing group {}. Ignoring release slot request.&quot;, slotSharingGroupId);&lt;br/&gt;
+		}&lt;br/&gt;
+		return CompletableFuture.completedFuture(Acknowledge.get());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   This line could be moved to `releaseSlot` since this method as well as `releaseSingleSlot` simply return a completed future.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668540" author="githubbot" created="Tue, 30 Oct 2018 10:55:15 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229258870&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229258870&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/clusterframework/types/SlotProfileTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -124,18 +124,31 @@ public void matchPreviousAllocationOverridesPreferredLocation() {&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt; 	@Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void matchPreviousLocationNotAvailable() {&lt;br/&gt;
+	public void matchPreviousLocationNotAvailableButByLocality() 
{
 
 		SlotProfile slotProfile = new SlotProfile(resourceProfile, Collections.singletonList(tml4), Collections.singletonList(aidX));
 		SlotContext match = runMatching(slotProfile);
 
-		Assert.assertEquals(null, match);
+		Assert.assertEquals(ssc4, match);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void matchPreviousLocationNotAvailableAndAllBlacklisted() {&lt;br/&gt;
+		HashSet&amp;lt;AllocationID&amp;gt; blacklisted = new HashSet&amp;lt;&amp;gt;(4);&lt;br/&gt;
+		blacklisted.add(aid1);&lt;br/&gt;
+		blacklisted.add(aid2);&lt;br/&gt;
+		blacklisted.add(aid3);&lt;br/&gt;
+		blacklisted.add(aid4);&lt;br/&gt;
+		SlotProfile slotProfile = new SlotProfile(resourceProfile, Collections.singletonList(tml4), Collections.singletonList(aidX), blacklisted);&lt;br/&gt;
+		SlotContext match = runMatching(slotProfile);&lt;br/&gt;
+&lt;br/&gt;
+		Assert.assertNull(match);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   We should also add a test where not all allocations are black listed and a test where all are blacklisted but the preferred allocation is contained in this set.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668541" author="githubbot" created="Tue, 30 Oct 2018 10:55:15 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229257170&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229257170&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -107,6 +107,7 @@ public void testSlotReleaseOnFailedResourceAssignment() throws Exception {&lt;br/&gt;
 			slotProvider,&lt;br/&gt;
 			false,&lt;br/&gt;
 			LocationPreferenceConstraint.ALL,&lt;br/&gt;
+			null,&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   This should not be `null` but instead `Collections.emptySet` I guess.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668542" author="githubbot" created="Tue, 30 Oct 2018 10:55:15 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229258079&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229258079&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotInfo.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,58 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.jobmaster;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;&lt;br/&gt;
+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Interface that provides basic information in the context of a slot.&lt;br/&gt;
+ */&lt;br/&gt;
+public interface SlotInfo {&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Gets the id under which the slot has been allocated on the TaskManager. This id uniquely identifies the&lt;br/&gt;
+	 * physical slot.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return The id under which the slot has been allocated on the TaskManager&lt;br/&gt;
+	 */&lt;br/&gt;
+	AllocationID getAllocationId();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Gets the location info of the TaskManager that offers this slot.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return The location info of the TaskManager that offers this slot&lt;br/&gt;
+	 */&lt;br/&gt;
+	TaskManagerLocation getTaskManagerLocation();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Gets the number of the slot.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return The number of the slot on the TaskManager.&lt;br/&gt;
+	 */&lt;br/&gt;
+	int getPhysicalSlotNumber();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the resource profile of the slot.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return the resource profile of the slot.&lt;br/&gt;
+	 */&lt;br/&gt;
+	ResourceProfile getResourceProfile();&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I&apos;m not sure whether we need this method here at the moment.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668676" author="githubbot" created="Tue, 30 Oct 2018 13:08:54 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229297185&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229297185&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -1582,12 +1599,18 @@ void clear() {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;An implementation of the 
{@link SlotOwner}
&lt;p&gt; and &lt;/p&gt;
{@link SlotProvider}
&lt;p&gt; interfaces&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;that delegates methods as RPC calls to the SlotPool&apos;s RPC gateway.&lt;br/&gt;
 	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static class ProviderAndOwner implements SlotOwner, SlotProvider {&lt;br/&gt;
+	public static class ProviderAndOwner implements SlotOwner, SlotProvider {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		private final SlotPoolGateway gateway;&lt;br/&gt;
+		private final boolean requiresPreviousAllocationsForScheduling;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ProviderAndOwner(SlotPoolGateway gateway) {&lt;br/&gt;
+		ProviderAndOwner(SlotPoolGateway gateway, boolean requiresPreviousAllocationsForScheduling) 
{
 			this.gateway = gateway;
+			this.requiresPreviousAllocationsForScheduling = requiresPreviousAllocationsForScheduling;
+		}
&lt;p&gt;+&lt;br/&gt;
+		public boolean requiresPreviousAllocationsForScheduling() {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   I agree, and had the same problem. It will naturally go away when we continue with changes to the scheduling.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668678" author="githubbot" created="Tue, 30 Oct 2018 13:09:27 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229297355&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229297355&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotInfo.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,58 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.jobmaster;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;&lt;br/&gt;
+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Interface that provides basic information in the context of a slot.&lt;br/&gt;
+ */&lt;br/&gt;
+public interface SlotInfo {&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Gets the id under which the slot has been allocated on the TaskManager. This id uniquely identifies the&lt;br/&gt;
+	 * physical slot.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return The id under which the slot has been allocated on the TaskManager&lt;br/&gt;
+	 */&lt;br/&gt;
+	AllocationID getAllocationId();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Gets the location info of the TaskManager that offers this slot.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return The location info of the TaskManager that offers this slot&lt;br/&gt;
+	 */&lt;br/&gt;
+	TaskManagerLocation getTaskManagerLocation();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Gets the number of the slot.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return The number of the slot on the TaskManager.&lt;br/&gt;
+	 */&lt;br/&gt;
+	int getPhysicalSlotNumber();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the resource profile of the slot.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return the resource profile of the slot.&lt;br/&gt;
+	 */&lt;br/&gt;
+	ResourceProfile getResourceProfile();&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Ok, I move it back up into `SlotContext` for now, but expect that it will land here in the longer run.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668679" author="githubbot" created="Tue, 30 Oct 2018 13:12:03 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229298268&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229298268&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PreviousAllocationSchedulingStrategy.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -48,35 +50,68 @@ private PreviousAllocationSchedulingStrategy() {}&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public &amp;lt;IN, OUT&amp;gt; OUT findMatchWithLocality(&lt;br/&gt;
 			@Nonnull SlotProfile slotProfile,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Nonnull Stream&amp;lt;IN&amp;gt; candidates,&lt;/li&gt;
	&lt;li&gt;@Nonnull Function&amp;lt;IN, SlotContext&amp;gt; contextExtractor,&lt;br/&gt;
+			@Nonnull Supplier&amp;lt;Stream&amp;lt;IN&amp;gt;&amp;gt; candidates,&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   I think both ways have their pros and cons, if we use a supplier for stream, we can benefit from the lazy evaluation of streaming. In one case for scheduling where we need to iterate the stream twice, havign a collection would be better. I feel ok with both variants if you think `Collection` is preferable.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668738" author="githubbot" created="Tue, 30 Oct 2018 13:48:58 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229311115&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229311115&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PreviousAllocationSchedulingStrategy.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -48,35 +50,68 @@ private PreviousAllocationSchedulingStrategy() {}&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public &amp;lt;IN, OUT&amp;gt; OUT findMatchWithLocality(&lt;br/&gt;
 			@Nonnull SlotProfile slotProfile,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Nonnull Stream&amp;lt;IN&amp;gt; candidates,&lt;/li&gt;
	&lt;li&gt;@Nonnull Function&amp;lt;IN, SlotContext&amp;gt; contextExtractor,&lt;br/&gt;
+			@Nonnull Supplier&amp;lt;Stream&amp;lt;IN&amp;gt;&amp;gt; candidates,&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Let&apos;s keep it like it is.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668739" author="githubbot" created="Tue, 30 Oct 2018 13:48:58 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229310831&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229310831&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotContext.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -58,4 +36,11 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@return The gateway that can be used to send messages to the TaskManager.&lt;br/&gt;
 	 */&lt;br/&gt;
 	TaskManagerGateway getTaskManagerGateway();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the resource profile of the slot.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return the resource profile of the slot.&lt;br/&gt;
+	 */&lt;br/&gt;
+	ResourceProfile getResourceProfile();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Do we need to add this method in this PR?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16668753" author="githubbot" created="Tue, 30 Oct 2018 14:06:48 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#discussion_r229319663&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#discussion_r229319663&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotContext.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -58,4 +36,11 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@return The gateway that can be used to send messages to the TaskManager.&lt;br/&gt;
 	 */&lt;br/&gt;
 	TaskManagerGateway getTaskManagerGateway();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the resource profile of the slot.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @return the resource profile of the slot.&lt;br/&gt;
+	 */&lt;br/&gt;
+	ResourceProfile getResourceProfile();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Agreed, we can remove it completely for this PR.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16669061" author="githubbot" created="Tue, 30 Oct 2018 17:09:14 +0000"  >&lt;p&gt;StefanRRichter commented on issue #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961#issuecomment-434388623&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961#issuecomment-434388623&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Thanks for the review @tillrohrmann! Travis looks good, proceeding with the merge.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16669099" author="githubbot" created="Tue, 30 Oct 2018 17:34:34 +0000"  >&lt;p&gt;asfgit closed pull request #6961: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; Fix scheduling for local recovery&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6961&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6961&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/clusterframework/types/SlotProfile.java b/flink-runtime/src/main/java/org/apache/flink/runtime/clusterframework/types/SlotProfile.java&lt;br/&gt;
index 7cb364d687f..ab682a02dd1 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/clusterframework/types/SlotProfile.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/clusterframework/types/SlotProfile.java&lt;br/&gt;
@@ -25,6 +25,7 @@&lt;/p&gt;

&lt;p&gt; import java.util.Collection;&lt;br/&gt;
 import java.util.Collections;&lt;br/&gt;
+import java.util.Set;&lt;/p&gt;

&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A slot profile describes the profile of a slot into which a task wants to be scheduled. The profile contains&lt;br/&gt;
@@ -47,16 +48,30 @@&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/** This contains desired allocation ids of the slot. */&lt;br/&gt;
 	@Nonnull&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final Collection&amp;lt;AllocationID&amp;gt; priorAllocations;&lt;br/&gt;
+	private final Collection&amp;lt;AllocationID&amp;gt; preferredAllocations;&lt;br/&gt;
+&lt;br/&gt;
+	/** This contains all prior allocation ids from the whole execution graph. */&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private final Set&amp;lt;AllocationID&amp;gt; previousExecutionGraphAllocations;&lt;br/&gt;
+&lt;br/&gt;
+	public SlotProfile(&lt;br/&gt;
+		@Nonnull ResourceProfile resourceProfile,&lt;br/&gt;
+		@Nonnull Collection&amp;lt;TaskManagerLocation&amp;gt; preferredLocations,&lt;br/&gt;
+		@Nonnull Collection&amp;lt;AllocationID&amp;gt; preferredAllocations) 
{
+
+		this(resourceProfile, preferredLocations, preferredAllocations, Collections.emptySet());
+	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	public SlotProfile(&lt;br/&gt;
 		@Nonnull ResourceProfile resourceProfile,&lt;br/&gt;
 		@Nonnull Collection&amp;lt;TaskManagerLocation&amp;gt; preferredLocations,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Nonnull Collection&amp;lt;AllocationID&amp;gt; priorAllocations) {&lt;br/&gt;
+		@Nonnull Collection&amp;lt;AllocationID&amp;gt; preferredAllocations,&lt;br/&gt;
+		@Nonnull Set&amp;lt;AllocationID&amp;gt; previousExecutionGraphAllocations) 
{
 
 		this.resourceProfile = resourceProfile;
 		this.preferredLocations = preferredLocations;
-		this.priorAllocations = priorAllocations;
+		this.preferredAllocations = preferredAllocations;
+		this.previousExecutionGraphAllocations = previousExecutionGraphAllocations;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;br/&gt;
@@ -79,8 +94,18 @@ public ResourceProfile getResourceProfile() {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns the desired allocation ids for the slot.&lt;br/&gt;
 	 */&lt;br/&gt;
 	@Nonnull&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public Collection&amp;lt;AllocationID&amp;gt; getPriorAllocations() {&lt;/li&gt;
	&lt;li&gt;return priorAllocations;&lt;br/&gt;
+	public Collection&amp;lt;AllocationID&amp;gt; getPreferredAllocations() 
{
+		return preferredAllocations;
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns a set of all previous allocation ids from the execution graph.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * This is optional and can be empty if unused.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	public Set&amp;lt;AllocationID&amp;gt; getPreviousExecutionGraphAllocations() &lt;/p&gt;
{
+		return previousExecutionGraphAllocations;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java&lt;br/&gt;
index 801f35a41dc..cbf51037b8b 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java&lt;br/&gt;
@@ -58,6 +58,7 @@&lt;/p&gt;

&lt;p&gt; import org.slf4j.Logger;&lt;/p&gt;

&lt;p&gt;+import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.util.ArrayList;&lt;br/&gt;
@@ -65,6 +66,7 @@&lt;br/&gt;
 import java.util.Collections;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Map;&lt;br/&gt;
+import java.util.Set;&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;br/&gt;
 import java.util.concurrent.CompletionException;&lt;br/&gt;
 import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
@@ -385,7 +387,8 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) &lt;/p&gt;
{
 		return scheduleForExecution(
 			resourceProvider,
 			allowQueued,
-			LocationPreferenceConstraint.ANY);
+			LocationPreferenceConstraint.ANY,
+			Collections.emptySet());
 	}

&lt;p&gt; 	/**&lt;br/&gt;
@@ -397,18 +400,22 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param queued Flag to indicate whether the scheduler may queue this task if it cannot&lt;/li&gt;
	&lt;li&gt;immediately deploy it.&lt;/li&gt;
	&lt;li&gt;@param locationPreferenceConstraint constraint for the location preferences&lt;br/&gt;
+	 * @param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph.&lt;br/&gt;
+	 *                                                 Can be empty if the allocation ids are not required for scheduling.&lt;/li&gt;
	&lt;li&gt;@return Future which is completed once the Execution has been deployed&lt;br/&gt;
 	 */&lt;br/&gt;
 	public CompletableFuture&amp;lt;Void&amp;gt; scheduleForExecution(&lt;br/&gt;
 			SlotProvider slotProvider,&lt;br/&gt;
 			boolean queued,&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
+			LocationPreferenceConstraint locationPreferenceConstraint,&lt;br/&gt;
+			@Nonnull Set&amp;lt;AllocationID&amp;gt; allPreviousExecutionGraphAllocationIds) {&lt;br/&gt;
 		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout();&lt;br/&gt;
 		try {&lt;br/&gt;
 			final CompletableFuture&amp;lt;Execution&amp;gt; allocationFuture = allocateAndAssignSlotForExecution(&lt;br/&gt;
 				slotProvider,&lt;br/&gt;
 				queued,&lt;br/&gt;
 				locationPreferenceConstraint,&lt;br/&gt;
+				allPreviousExecutionGraphAllocationIds,&lt;br/&gt;
 				allocationTimeout);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			// IMPORTANT: We have to use the synchronous handle operation (direct executor) here so&lt;br/&gt;
@@ -441,6 +448,8 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param slotProvider to obtain a new slot from&lt;/li&gt;
	&lt;li&gt;@param queued if the allocation can be queued&lt;/li&gt;
	&lt;li&gt;@param locationPreferenceConstraint constraint for the location preferences&lt;br/&gt;
+	 * @param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph.&lt;br/&gt;
+	 *                                                 Can be empty if the allocation ids are not required for scheduling.&lt;/li&gt;
	&lt;li&gt;@param allocationTimeout rpcTimeout for allocating a new slot&lt;/li&gt;
	&lt;li&gt;@return Future which is completed with this execution once the slot has been assigned&lt;/li&gt;
	&lt;li&gt;or with an exception if an error occurred.&lt;br/&gt;
@@ -450,6 +459,7 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {&lt;br/&gt;
 			SlotProvider slotProvider,&lt;br/&gt;
 			boolean queued,&lt;br/&gt;
 			LocationPreferenceConstraint locationPreferenceConstraint,&lt;br/&gt;
+			@Nonnull Set&amp;lt;AllocationID&amp;gt; allPreviousExecutionGraphAllocationIds,&lt;br/&gt;
 			Time allocationTimeout) throws IllegalExecutionStateException {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		checkNotNull(slotProvider);&lt;br/&gt;
@@ -495,7 +505,8 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {&lt;br/&gt;
 							new SlotProfile(&lt;br/&gt;
 								ResourceProfile.UNKNOWN,&lt;br/&gt;
 								preferredLocations,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;previousAllocationIDs),&lt;br/&gt;
+								previousAllocationIDs,&lt;br/&gt;
+								allPreviousExecutionGraphAllocationIds),&lt;br/&gt;
 							allocationTimeout));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			// register call back to cancel slot request in case that the execution gets canceled&lt;br/&gt;
@@ -739,7 +750,8 @@ else if (numConsumers == 0) &lt;/p&gt;
{
 							consumerVertex.scheduleForExecution(
 								executionGraph.getSlotProvider(),
 								executionGraph.isQueuedSchedulingAllowed(),
-								LocationPreferenceConstraint.ANY); // there must be at least one known location
+								LocationPreferenceConstraint.ANY, // there must be at least one known location
+								Collections.emptySet());
 						}
&lt;p&gt; catch (Throwable t) {&lt;br/&gt;
 							consumerVertex.fail(new IllegalStateException(&quot;Could not schedule consumer &quot; +&lt;br/&gt;
 									&quot;vertex &quot; + consumerVertex, t));&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java&lt;br/&gt;
index 76cfbe1286d..3b55e009116 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java&lt;br/&gt;
@@ -40,6 +40,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointStatsTracker;&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpointStore;&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.MasterTriggerRestoreHook;&lt;br/&gt;
+import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.FutureUtils.ConjunctFuture;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.ScheduledExecutorServiceAdapter;&lt;br/&gt;
@@ -60,6 +61,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroup;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.scheduler.LocationPreferenceConstraint;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;&lt;br/&gt;
+import org.apache.flink.runtime.jobmaster.slotpool.SlotPool;&lt;br/&gt;
 import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;&lt;br/&gt;
 import org.apache.flink.runtime.query.KvStateLocationRegistry;&lt;br/&gt;
 import org.apache.flink.runtime.state.SharedStateRegistry;&lt;br/&gt;
@@ -91,6 +93,7 @@&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Map;&lt;br/&gt;
 import java.util.NoSuchElementException;&lt;br/&gt;
+import java.util.Set;&lt;br/&gt;
 import java.util.concurrent.CancellationException;&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;br/&gt;
 import java.util.concurrent.CompletionException;&lt;br/&gt;
@@ -902,14 +905,14 @@ public void scheduleForExecution() throws JobException {&lt;br/&gt;
 	private CompletableFuture&amp;lt;Void&amp;gt; scheduleLazy(SlotProvider slotProvider) {&lt;/p&gt;

&lt;p&gt; 		final ArrayList&amp;lt;CompletableFuture&amp;lt;Void&amp;gt;&amp;gt; schedulingFutures = new ArrayList&amp;lt;&amp;gt;(numVerticesTotal);&lt;br/&gt;
-&lt;br/&gt;
 		// simply take the vertices without inputs.&lt;br/&gt;
 		for (ExecutionJobVertex ejv : verticesInCreationOrder) {&lt;br/&gt;
 			if (ejv.getJobVertex().isInputVertex()) &lt;/p&gt;
{
 				final CompletableFuture&amp;lt;Void&amp;gt; schedulingJobVertexFuture = ejv.scheduleAll(
 					slotProvider,
 					allowQueuedScheduling,
-					LocationPreferenceConstraint.ALL); // since it is an input vertex, the input based location preferences should be empty
+					LocationPreferenceConstraint.ALL,// since it is an input vertex, the input based location preferences should be empty
+					Collections.emptySet());
 
 				schedulingFutures.add(schedulingJobVertexFuture);
 			}
&lt;p&gt;@@ -939,6 +942,9 @@ public void scheduleForExecution() throws JobException {&lt;br/&gt;
 		// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
 		final ArrayList&amp;lt;CompletableFuture&amp;lt;Execution&amp;gt;&amp;gt; allAllocationFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;/p&gt;

&lt;p&gt;+		final Set&amp;lt;AllocationID&amp;gt; allPreviousAllocationIds =&lt;br/&gt;
+			Collections.unmodifiableSet(computeAllPriorAllocationIdsIfRequiredByScheduling());&lt;br/&gt;
+&lt;br/&gt;
 		// allocate the slots (obtain all their futures&lt;br/&gt;
 		for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
 			// these calls are not blocking, they only return futures&lt;br/&gt;
@@ -946,6 +952,7 @@ public void scheduleForExecution() throws JobException {&lt;br/&gt;
 				slotProvider,&lt;br/&gt;
 				queued,&lt;br/&gt;
 				LocationPreferenceConstraint.ALL,&lt;br/&gt;
+				allPreviousAllocationIds,&lt;br/&gt;
 				timeout);&lt;/p&gt;

&lt;p&gt; 			allAllocationFutures.addAll(allocationFutures);&lt;br/&gt;
@@ -1676,6 +1683,35 @@ public void updateAccumulators(AccumulatorSnapshot accumulatorSnapshot) {&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * Computes and returns a set with the prior allocation ids from all execution vertices in the graph.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private Set&amp;lt;AllocationID&amp;gt; computeAllPriorAllocationIds() {&lt;br/&gt;
+		HashSet&amp;lt;AllocationID&amp;gt; allPreviousAllocationIds = new HashSet&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
+		for (ExecutionVertex executionVertex : getAllExecutionVertices()) {&lt;br/&gt;
+			AllocationID latestPriorAllocation = executionVertex.getLatestPriorAllocation();&lt;br/&gt;
+			if (latestPriorAllocation != null) &lt;/p&gt;
{
+				allPreviousAllocationIds.add(latestPriorAllocation);
+			}
&lt;p&gt;+		}&lt;br/&gt;
+		return allPreviousAllocationIds;&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the result of &lt;/p&gt;
{@link #computeAllPriorAllocationIds()}
&lt;p&gt;, but only if the scheduling really requires it.&lt;br/&gt;
+	 * Otherwise this method simply returns an empty set.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private Set&amp;lt;AllocationID&amp;gt; computeAllPriorAllocationIdsIfRequiredByScheduling() {&lt;br/&gt;
+		// This is a temporary optimization to avoid computing all previous allocations if not required&lt;br/&gt;
+		// This can go away when we progress with the implementation of the Scheduler.&lt;br/&gt;
+		if (slotProvider instanceof SlotPool.ProviderAndOwner&lt;br/&gt;
+			&amp;amp;&amp;amp; ((SlotPool.ProviderAndOwner) slotProvider).requiresPreviousAllocationsForScheduling()) &lt;/p&gt;
{
+			return computeAllPriorAllocationIds();
+		}
&lt;p&gt; else &lt;/p&gt;
{
+			return Collections.emptySet();
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
 	// --------------------------------------------------------------------------------------------&lt;br/&gt;
 	//  Listeners &amp;amp; Observers&lt;br/&gt;
 	// --------------------------------------------------------------------------------------------&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java&lt;br/&gt;
index 6da1e0db892..2ab1d686410 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java&lt;br/&gt;
@@ -34,6 +34,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.accumulators.StringifiedAccumulatorResult;&lt;br/&gt;
 import org.apache.flink.runtime.blob.BlobWriter;&lt;br/&gt;
 import org.apache.flink.runtime.blob.PermanentBlobKey;&lt;br/&gt;
+import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
 import org.apache.flink.runtime.execution.ExecutionState;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.IntermediateDataSet;&lt;br/&gt;
@@ -54,6 +55,7 @@&lt;/p&gt;

&lt;p&gt; import org.slf4j.Logger;&lt;/p&gt;

&lt;p&gt;+import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.io.IOException;&lt;br/&gt;
@@ -64,6 +66,7 @@&lt;br/&gt;
 import java.util.HashMap;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Map;&lt;br/&gt;
+import java.util.Set;&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -474,12 +477,15 @@ public void connectToPredecessors(Map&amp;lt;IntermediateDataSetID, IntermediateResult&amp;gt;&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param slotProvider to allocate the slots from&lt;/li&gt;
	&lt;li&gt;@param queued if the allocations can be queued&lt;/li&gt;
	&lt;li&gt;@param locationPreferenceConstraint constraint for the location preferences&lt;br/&gt;
+	 * @param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph.&lt;br/&gt;
+	 *                                                 Can be empty if the allocation ids are not required for scheduling.&lt;/li&gt;
	&lt;li&gt;@return Future which is completed once all 
{@link Execution}
&lt;p&gt; could be deployed&lt;br/&gt;
 	 */&lt;br/&gt;
 	public CompletableFuture&amp;lt;Void&amp;gt; scheduleAll(&lt;br/&gt;
 			SlotProvider slotProvider,&lt;br/&gt;
 			boolean queued,&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
+			LocationPreferenceConstraint locationPreferenceConstraint,&lt;br/&gt;
+			@Nonnull Set&amp;lt;AllocationID&amp;gt; allPreviousExecutionGraphAllocationIds) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final ExecutionVertex[] vertices = this.taskVertices;&lt;/p&gt;

&lt;p&gt;@@ -487,7 +493,11 @@ public void connectToPredecessors(Map&amp;lt;IntermediateDataSetID, IntermediateResult&amp;gt;&lt;/p&gt;

&lt;p&gt; 		// kick off the tasks&lt;br/&gt;
 		for (ExecutionVertex ev : vertices) &lt;/p&gt;
{
-			scheduleFutures.add(ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint));
+			scheduleFutures.add(ev.scheduleForExecution(
+				slotProvider,
+				queued,
+				locationPreferenceConstraint,
+				allPreviousExecutionGraphAllocationIds));
 		}

&lt;p&gt; 		return FutureUtils.waitForAll(scheduleFutures);&lt;br/&gt;
@@ -503,12 +513,14 @@ public void connectToPredecessors(Map&amp;lt;IntermediateDataSetID, IntermediateResult&amp;gt;&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param resourceProvider The resource provider from whom the slots are requested.&lt;/li&gt;
	&lt;li&gt;@param queued if the allocation can be queued&lt;/li&gt;
	&lt;li&gt;@param locationPreferenceConstraint constraint for the location preferences&lt;br/&gt;
+	 * @param allPreviousExecutionGraphAllocationIds the allocation ids of all previous executions in the execution job graph.&lt;/li&gt;
	&lt;li&gt;@param allocationTimeout timeout for allocating the individual slots&lt;br/&gt;
 	 */&lt;br/&gt;
 	public Collection&amp;lt;CompletableFuture&amp;lt;Execution&amp;gt;&amp;gt; allocateResourcesForAll(&lt;br/&gt;
 			SlotProvider resourceProvider,&lt;br/&gt;
 			boolean queued,&lt;br/&gt;
 			LocationPreferenceConstraint locationPreferenceConstraint,&lt;br/&gt;
+			@Nonnull Set&amp;lt;AllocationID&amp;gt; allPreviousExecutionGraphAllocationIds,&lt;br/&gt;
 			Time allocationTimeout) 
{
 		final ExecutionVertex[] vertices = this.taskVertices;
 		final CompletableFuture&amp;lt;Execution&amp;gt;[] slots = new CompletableFuture[vertices.length];
@@ -522,6 +534,7 @@ public void connectToPredecessors(Map&amp;lt;IntermediateDataSetID, IntermediateResult&amp;gt;
 				resourceProvider,
 				queued,
 				locationPreferenceConstraint,
+				allPreviousExecutionGraphAllocationIds,
 				allocationTimeout);
 			slots[i] = allocationFuture;
 		}
&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java&lt;br/&gt;
index e4228011830..a0747296c53 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java&lt;br/&gt;
@@ -56,6 +56,7 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import org.slf4j.Logger;&lt;/p&gt;

&lt;p&gt;+import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.io.IOException;&lt;br/&gt;
@@ -617,17 +618,21 @@ public Execution resetForNewExecution(final long timestamp, final long originati&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param slotProvider to allocate the slots from&lt;/li&gt;
	&lt;li&gt;@param queued if the allocation can be queued&lt;/li&gt;
	&lt;li&gt;@param locationPreferenceConstraint constraint for the location preferences&lt;br/&gt;
+	 * @param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph.&lt;br/&gt;
+	 *                                                 Can be empty if the allocation ids are not required for scheduling.&lt;/li&gt;
	&lt;li&gt;@return Future which is completed once the execution is deployed. The future&lt;/li&gt;
	&lt;li&gt;can also completed exceptionally.&lt;br/&gt;
 	 */&lt;br/&gt;
 	public CompletableFuture&amp;lt;Void&amp;gt; scheduleForExecution(&lt;br/&gt;
 			SlotProvider slotProvider,&lt;br/&gt;
 			boolean queued,&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
+			LocationPreferenceConstraint locationPreferenceConstraint,&lt;br/&gt;
+			@Nonnull Set&amp;lt;AllocationID&amp;gt; allPreviousExecutionGraphAllocationIds) 
{
 		return this.currentExecution.scheduleForExecution(
 			slotProvider,
 			queued,
-			locationPreferenceConstraint);
+			locationPreferenceConstraint,
+			allPreviousExecutionGraphAllocationIds);
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	@VisibleForTesting&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/FailoverRegion.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/FailoverRegion.java&lt;br/&gt;
index 0b00c0e039d..f3ba48e75ab 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/FailoverRegion.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/FailoverRegion.java&lt;br/&gt;
@@ -18,6 +18,7 @@&lt;/p&gt;

&lt;p&gt; package org.apache.flink.runtime.executiongraph.failover;&lt;/p&gt;

&lt;p&gt;+import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
 import org.apache.flink.runtime.executiongraph.Execution;&lt;br/&gt;
 import org.apache.flink.runtime.executiongraph.ExecutionGraph;&lt;br/&gt;
@@ -212,6 +213,15 @@ private void restart(long globalModVersionOfFailover) &lt;/p&gt;
{
 							connectedExecutionVertexes, false, false);
 				}
&lt;p&gt; 				*/&lt;br/&gt;
+&lt;br/&gt;
+				HashSet&amp;lt;AllocationID&amp;gt; previousAllocationsInRegion = new HashSet&amp;lt;&amp;gt;(connectedExecutionVertexes.size());&lt;br/&gt;
+				for (ExecutionVertex connectedExecutionVertex : connectedExecutionVertexes) {&lt;br/&gt;
+					AllocationID latestPriorAllocation = connectedExecutionVertex.getLatestPriorAllocation();&lt;br/&gt;
+					if (latestPriorAllocation != null) &lt;/p&gt;
{
+						previousAllocationsInRegion.add(latestPriorAllocation);
+					}
&lt;p&gt;+				}&lt;br/&gt;
+&lt;br/&gt;
 				//TODO, use restart strategy to schedule them.&lt;br/&gt;
 				//restart all connected ExecutionVertexes&lt;br/&gt;
 				for (ExecutionVertex ev : connectedExecutionVertexes) {&lt;br/&gt;
@@ -219,7 +229,8 @@ private void restart(long globalModVersionOfFailover) &lt;/p&gt;
{
 						ev.scheduleForExecution(
 							executionGraph.getSlotProvider(),
 							executionGraph.isQueuedSchedulingAllowed(),
-							LocationPreferenceConstraint.ANY); // some inputs not belonging to the failover region might have failed concurrently
+							LocationPreferenceConstraint.ANY,
+							previousAllocationsInRegion); // some inputs not belonging to the failover region might have failed concurrently
 					}
&lt;p&gt; 					catch (Throwable e) {&lt;br/&gt;
 						failover(globalModVersionOfFailover);&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/instance/SimpleSlotContext.java b/flink-runtime/src/main/java/org/apache/flink/runtime/instance/SimpleSlotContext.java&lt;br/&gt;
index 95dd1f6f9e6..282fd2ccf4e 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/instance/SimpleSlotContext.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/instance/SimpleSlotContext.java&lt;br/&gt;
@@ -19,8 +19,8 @@&lt;br/&gt;
 package org.apache.flink.runtime.instance;&lt;/p&gt;

&lt;p&gt; import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
-import org.apache.flink.runtime.jobmaster.SlotContext;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;&lt;br/&gt;
+import org.apache.flink.runtime.jobmaster.SlotContext;&lt;br/&gt;
 import org.apache.flink.runtime.taskmanager.TaskManagerLocation;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;/p&gt;

&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotContext.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotContext.java&lt;br/&gt;
index 38781676842..8777edd2fe7 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotContext.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotContext.java&lt;br/&gt;
@@ -18,37 +18,14 @@&lt;/p&gt;

&lt;p&gt; package org.apache.flink.runtime.jobmaster;&lt;/p&gt;

&lt;p&gt;-import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;&lt;br/&gt;
-import org.apache.flink.runtime.taskmanager.TaskManagerLocation;&lt;/p&gt;

&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Interface for the context of a 
{@link LogicalSlot}
&lt;p&gt;. This context contains information&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;about the underlying allocated slot and how to communicate with the TaskManager on which&lt;/li&gt;
	&lt;li&gt;it was allocated.&lt;br/&gt;
  */&lt;br/&gt;
-public interface SlotContext {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Gets the id under which the slot has been allocated on the TaskManager. This id uniquely identifies the&lt;/li&gt;
	&lt;li&gt;* physical slot.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @return The id under which the slot has been allocated on the TaskManager&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;AllocationID getAllocationId();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Gets the location info of the TaskManager that offers this slot.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @return The location info of the TaskManager that offers this slot&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;TaskManagerLocation getTaskManagerLocation();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Gets the number of the slot.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @return The number of the slot on the TaskManager.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;int getPhysicalSlotNumber();&lt;br/&gt;
+public interface SlotContext extends SlotInfo {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Gets the actor gateway that can be used to send messages to the TaskManager.&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotInfo.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotInfo.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..fd33aacfd6c
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;/dev/null&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotInfo.java&lt;br/&gt;
@@ -0,0 +1,50 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.jobmaster;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Interface that provides basic information in the context of a slot.&lt;br/&gt;
+ */&lt;br/&gt;
+public interface SlotInfo 
{
+
+	/**
+	 * Gets the id under which the slot has been allocated on the TaskManager. This id uniquely identifies the
+	 * physical slot.
+	 *
+	 * @return The id under which the slot has been allocated on the TaskManager
+	 */
+	AllocationID getAllocationId();
+
+	/**
+	 * Gets the location info of the TaskManager that offers this slot.
+	 *
+	 * @return The location info of the TaskManager that offers this slot
+	 */
+	TaskManagerLocation getTaskManagerLocation();
+
+	/**
+	 * Gets the number of the slot.
+	 *
+	 * @return The number of the slot on the TaskManager.
+	 */
+	int getPhysicalSlotNumber();
+}
&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AllocatedSlot.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AllocatedSlot.java&lt;br/&gt;
index 75195cd9378..e4e583c09d6 100644&lt;/p&gt;&lt;/li&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AllocatedSlot.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AllocatedSlot.java&lt;br/&gt;
@@ -92,6 +92,7 @@ public SlotID getSlotId() {&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@return The ID under which the slot is allocated&lt;br/&gt;
 	 */&lt;br/&gt;
+	@Override&lt;br/&gt;
 	public AllocationID getAllocationId() 
{
 		return allocationId;
 	}
&lt;p&gt;@@ -121,6 +122,7 @@ public ResourceProfile getResourceProfile() {&lt;br/&gt;
 	 *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@return The location info of the TaskManager that offers this slot&lt;br/&gt;
 	 */&lt;br/&gt;
+	@Override&lt;br/&gt;
 	public TaskManagerLocation getTaskManagerLocation() 
{
 		return taskManagerLocation;
 	}
&lt;p&gt;@@ -132,6 +134,7 @@ public TaskManagerLocation getTaskManagerLocation() {&lt;br/&gt;
 	 *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@return The actor gateway that can be used to send messages to the TaskManager.&lt;br/&gt;
 	 */&lt;br/&gt;
+	@Override&lt;br/&gt;
 	public TaskManagerGateway getTaskManagerGateway() 
{
 		return taskManagerGateway;
 	}
&lt;p&gt;@@ -142,6 +145,7 @@ public TaskManagerGateway getTaskManagerGateway() {&lt;br/&gt;
 	 *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@return Physical slot number of the allocated slot&lt;br/&gt;
 	 */&lt;br/&gt;
+	@Override&lt;br/&gt;
 	public int getPhysicalSlotNumber() 
{
 		return physicalSlotNumber;
 	}
&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/LocationPreferenceSchedulingStrategy.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/LocationPreferenceSchedulingStrategy.java&lt;br/&gt;
index 25e884c32dd..bc90be65ac5 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/LocationPreferenceSchedulingStrategy.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/LocationPreferenceSchedulingStrategy.java&lt;br/&gt;
@@ -21,7 +21,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.types.SlotProfile;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.scheduler.Locality;&lt;br/&gt;
-import org.apache.flink.runtime.jobmaster.SlotContext;&lt;br/&gt;
+import org.apache.flink.runtime.jobmaster.SlotInfo;&lt;br/&gt;
 import org.apache.flink.runtime.taskmanager.TaskManagerLocation;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
@@ -34,6 +34,7 @@&lt;br/&gt;
 import java.util.function.BiFunction;&lt;br/&gt;
 import java.util.function.Function;&lt;br/&gt;
 import java.util.function.Predicate;&lt;br/&gt;
+import java.util.function.Supplier;&lt;br/&gt;
 import java.util.stream.Stream;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -54,11 +55,26 @@&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public &amp;lt;IN, OUT&amp;gt; OUT findMatchWithLocality(&lt;br/&gt;
 			@Nonnull SlotProfile slotProfile,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Nonnull Stream&amp;lt;IN&amp;gt; candidates,&lt;/li&gt;
	&lt;li&gt;@Nonnull Function&amp;lt;IN, SlotContext&amp;gt; contextExtractor,&lt;br/&gt;
+			@Nonnull Supplier&amp;lt;Stream&amp;lt;IN&amp;gt;&amp;gt; candidates,&lt;br/&gt;
+			@Nonnull Function&amp;lt;IN, SlotInfo&amp;gt; contextExtractor,&lt;br/&gt;
 			@Nonnull Predicate&amp;lt;IN&amp;gt; additionalRequirementsFilter,&lt;br/&gt;
 			@Nonnull BiFunction&amp;lt;IN, Locality, OUT&amp;gt; resultProducer) 
{
 
+		return doFindMatchWithLocality(
+			slotProfile,
+			candidates.get(),
+			contextExtractor,
+			additionalRequirementsFilter,
+			resultProducer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	protected  &amp;lt;IN, OUT&amp;gt; OUT doFindMatchWithLocality(&lt;br/&gt;
+		@Nonnull SlotProfile slotProfile,&lt;br/&gt;
+		@Nonnull Stream&amp;lt;IN&amp;gt; candidates,&lt;br/&gt;
+		@Nonnull Function&amp;lt;IN, SlotInfo&amp;gt; contextExtractor,&lt;br/&gt;
+		@Nonnull Predicate&amp;lt;IN&amp;gt; additionalRequirementsFilter,&lt;br/&gt;
+		@Nonnull BiFunction&amp;lt;IN, Locality, OUT&amp;gt; resultProducer) {&lt;br/&gt;
 		Collection&amp;lt;TaskManagerLocation&amp;gt; locationPreferences = slotProfile.getPreferredLocations();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// if we have no location preferences, we can only filter by the additional requirements.&lt;br/&gt;
@@ -88,7 +104,7 @@&lt;br/&gt;
 		while (iterator.hasNext()) {&lt;br/&gt;
 			IN candidate = iterator.next();&lt;br/&gt;
 			if (additionalRequirementsFilter.test(candidate)) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;SlotContext slotContext = contextExtractor.apply(candidate);&lt;br/&gt;
+				SlotInfo slotContext = contextExtractor.apply(candidate);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 				// this gets candidate is local-weigh&lt;br/&gt;
 				Integer localWeigh = preferredResourceIDs.getOrDefault(slotContext.getTaskManagerLocation().getResourceID(), 0);&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PreviousAllocationSchedulingStrategy.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PreviousAllocationSchedulingStrategy.java&lt;br/&gt;
index 9b1872ec363..d2193ad7022 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PreviousAllocationSchedulingStrategy.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PreviousAllocationSchedulingStrategy.java&lt;br/&gt;
@@ -21,15 +21,17 @@&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.types.SlotProfile;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.scheduler.Locality;&lt;br/&gt;
-import org.apache.flink.runtime.jobmaster.SlotContext;&lt;br/&gt;
+import org.apache.flink.runtime.jobmaster.SlotInfo;&lt;/p&gt;

&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.util.Collection;&lt;br/&gt;
+import java.util.Set;&lt;br/&gt;
 import java.util.function.BiFunction;&lt;br/&gt;
 import java.util.function.Function;&lt;br/&gt;
 import java.util.function.Predicate;&lt;br/&gt;
+import java.util.function.Supplier;&lt;br/&gt;
 import java.util.stream.Stream;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -48,35 +50,68 @@ private PreviousAllocationSchedulingStrategy() {}&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public &amp;lt;IN, OUT&amp;gt; OUT findMatchWithLocality(&lt;br/&gt;
 			@Nonnull SlotProfile slotProfile,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Nonnull Stream&amp;lt;IN&amp;gt; candidates,&lt;/li&gt;
	&lt;li&gt;@Nonnull Function&amp;lt;IN, SlotContext&amp;gt; contextExtractor,&lt;br/&gt;
+			@Nonnull Supplier&amp;lt;Stream&amp;lt;IN&amp;gt;&amp;gt; candidates,&lt;br/&gt;
+			@Nonnull Function&amp;lt;IN, SlotInfo&amp;gt; contextExtractor,&lt;br/&gt;
 			@Nonnull Predicate&amp;lt;IN&amp;gt; additionalRequirementsFilter,&lt;br/&gt;
 			@Nonnull BiFunction&amp;lt;IN, Locality, OUT&amp;gt; resultProducer) {&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Collection&amp;lt;AllocationID&amp;gt; priorAllocations = slotProfile.getPriorAllocations();&lt;br/&gt;
+		Collection&amp;lt;AllocationID&amp;gt; priorAllocations = slotProfile.getPreferredAllocations();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		if (priorAllocations.isEmpty()) &lt;/p&gt;
{
-			return super.findMatchWithLocality(slotProfile, candidates, contextExtractor, additionalRequirementsFilter, resultProducer);
+			return super.findMatchWithLocality(
+				slotProfile,
+				candidates,
+				contextExtractor,
+				additionalRequirementsFilter,
+				resultProducer);
 		}
&lt;p&gt; else &lt;/p&gt;
{
-			return findPreviousAllocation(candidates, contextExtractor, additionalRequirementsFilter, resultProducer, priorAllocations);
+			return findPreviousAllocation(
+				slotProfile,
+				candidates,
+				contextExtractor,
+				additionalRequirementsFilter,
+				resultProducer,
+				priorAllocations);
 		}
&lt;p&gt; 	}&lt;/p&gt;

&lt;p&gt; 	@Nullable&lt;br/&gt;
 	private &amp;lt;IN, OUT&amp;gt; OUT findPreviousAllocation(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Nonnull Stream&amp;lt;IN&amp;gt; candidates,&lt;/li&gt;
	&lt;li&gt;@Nonnull Function&amp;lt;IN, SlotContext&amp;gt; contextExtractor,&lt;br/&gt;
+			@Nonnull SlotProfile slotProfile,&lt;br/&gt;
+			@Nonnull Supplier&amp;lt;Stream&amp;lt;IN&amp;gt;&amp;gt; candidates,&lt;br/&gt;
+			@Nonnull Function&amp;lt;IN, SlotInfo&amp;gt; contextExtractor,&lt;br/&gt;
 			@Nonnull Predicate&amp;lt;IN&amp;gt; additionalRequirementsFilter,&lt;br/&gt;
 			@Nonnull BiFunction&amp;lt;IN, Locality, OUT&amp;gt; resultProducer,&lt;/li&gt;
	&lt;li&gt;Collection&amp;lt;AllocationID&amp;gt; priorAllocations) {&lt;br/&gt;
+			@Nonnull Collection&amp;lt;AllocationID&amp;gt; priorAllocations) {&lt;br/&gt;
+&lt;br/&gt;
 		Predicate&amp;lt;IN&amp;gt; filterByAllocation =&lt;/li&gt;
	&lt;li&gt;(candidate) -&amp;gt; priorAllocations.contains(contextExtractor.apply(candidate).getAllocationId());&lt;br/&gt;
+			(IN candidate) -&amp;gt; priorAllocations.contains(contextExtractor.apply(candidate).getAllocationId());&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return candidates&lt;br/&gt;
+		OUT previousAllocationCandidate = candidates&lt;br/&gt;
+			.get()&lt;br/&gt;
 			.filter(filterByAllocation.and(additionalRequirementsFilter))&lt;br/&gt;
 			.findFirst()&lt;/li&gt;
	&lt;li&gt;.map((result) -&amp;gt; resultProducer.apply(result, Locality.LOCAL)) // TODO introduce special locality?&lt;br/&gt;
+			.map((IN result) -&amp;gt; resultProducer.apply(result, Locality.LOCAL)) // TODO introduce special locality?&lt;br/&gt;
 			.orElse(null);&lt;br/&gt;
+&lt;br/&gt;
+		if (previousAllocationCandidate != null) 
{
+			return previousAllocationCandidate;
+		}
&lt;p&gt;+&lt;br/&gt;
+		Set&amp;lt;AllocationID&amp;gt; blackListedAllocationIDs = slotProfile.getPreviousExecutionGraphAllocations();&lt;br/&gt;
+		Stream&amp;lt;IN&amp;gt; candidateStream = candidates.get();&lt;br/&gt;
+		if (!blackListedAllocationIDs.isEmpty()) &lt;/p&gt;
{
+			candidateStream = candidateStream.filter(
+				(IN candidate) -&amp;gt; !blackListedAllocationIDs.contains(
+					contextExtractor.apply(candidate).getAllocationId()));
+		}
&lt;p&gt;+&lt;br/&gt;
+		return doFindMatchWithLocality(&lt;br/&gt;
+			slotProfile,&lt;br/&gt;
+			candidateStream,&lt;br/&gt;
+			contextExtractor,&lt;br/&gt;
+			additionalRequirementsFilter,&lt;br/&gt;
+			resultProducer);&lt;br/&gt;
 	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	public static PreviousAllocationSchedulingStrategy getInstance() &lt;/p&gt;
{
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SchedulingStrategy.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SchedulingStrategy.java
index fb27a214eff..89b2d05cada 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SchedulingStrategy.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SchedulingStrategy.java
@@ -21,6 +21,7 @@
 import org.apache.flink.runtime.clusterframework.types.SlotProfile;
 import org.apache.flink.runtime.jobmanager.scheduler.Locality;
 import org.apache.flink.runtime.jobmaster.SlotContext;
+import org.apache.flink.runtime.jobmaster.SlotInfo;
 
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
@@ -28,6 +29,7 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 import java.util.function.Predicate;
+import java.util.function.Supplier;
 import java.util.stream.Stream;
 
 /**
@@ -53,8 +55,8 @@
 	@Nullable
 	&amp;lt;IN, OUT&amp;gt; OUT findMatchWithLocality(
 		@Nonnull SlotProfile slotProfile,
-		@Nonnull Stream&amp;lt;IN&amp;gt; candidates,
-		@Nonnull Function&amp;lt;IN, SlotContext&amp;gt; contextExtractor,
+		@Nonnull Supplier&amp;lt;Stream&amp;lt;IN&amp;gt;&amp;gt; candidates,
+		@Nonnull Function&amp;lt;IN, SlotInfo&amp;gt; contextExtractor,
 		@Nonnull Predicate&amp;lt;IN&amp;gt; additionalRequirementsFilter,
 		@Nonnull BiFunction&amp;lt;IN, Locality, OUT&amp;gt; resultProducer);
 }
&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java&lt;br/&gt;
index b53ee93e643..34d5cdc49c3 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java&lt;br/&gt;
@@ -55,6 +55,7 @@&lt;br/&gt;
 import org.apache.flink.util.FlinkException;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;/p&gt;

&lt;p&gt;+import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.util.ArrayList;&lt;br/&gt;
@@ -171,7 +172,9 @@ public SlotPool(&lt;br/&gt;
 		this.pendingRequests = new DualKeyMap&amp;lt;&amp;gt;(16);&lt;br/&gt;
 		this.waitingForResourceManager = new HashMap&amp;lt;&amp;gt;(16);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.providerAndOwner = new ProviderAndOwner(getSelfGateway(SlotPoolGateway.class));&lt;br/&gt;
+		this.providerAndOwner = new ProviderAndOwner(&lt;br/&gt;
+			getSelfGateway(SlotPoolGateway.class),&lt;br/&gt;
+			schedulingStrategy instanceof PreviousAllocationSchedulingStrategy);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		this.slotSharingManagers = new HashMap&amp;lt;&amp;gt;(4);&lt;/p&gt;

&lt;p&gt;@@ -326,76 +329,93 @@ public void disconnectResourceManager() {&lt;/p&gt;

&lt;p&gt; 		log.debug(&quot;Received slot request &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt; for task: {}&quot;, slotRequestId, task.getTaskToExecute());&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final SlotSharingGroupId slotSharingGroupId = task.getSlotSharingGroupId();&lt;br/&gt;
+		if (task.getSlotSharingGroupId() == null) 
{
+			return allocateSingleSlot(slotRequestId, slotProfile, allowQueuedScheduling, allocationTimeout);
+		}
&lt;p&gt; else &lt;/p&gt;
{
+			return allocateSharedSlot(slotRequestId, task, slotProfile, allowQueuedScheduling, allocationTimeout);
+		}
&lt;p&gt;+	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (slotSharingGroupId != null) {&lt;/li&gt;
	&lt;li&gt;// allocate slot with slot sharing&lt;/li&gt;
	&lt;li&gt;final SlotSharingManager multiTaskSlotManager = slotSharingManagers.computeIfAbsent(&lt;/li&gt;
	&lt;li&gt;slotSharingGroupId,&lt;/li&gt;
	&lt;li&gt;id -&amp;gt; new SlotSharingManager(&lt;/li&gt;
	&lt;li&gt;id,&lt;/li&gt;
	&lt;li&gt;this,&lt;/li&gt;
	&lt;li&gt;providerAndOwner));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;if (task.getCoLocationConstraint() != null) {&lt;/li&gt;
	&lt;li&gt;multiTaskSlotLocality = allocateCoLocatedMultiTaskSlot(&lt;/li&gt;
	&lt;li&gt;task.getCoLocationConstraint(),&lt;/li&gt;
	&lt;li&gt;multiTaskSlotManager,&lt;/li&gt;
	&lt;li&gt;slotProfile,&lt;/li&gt;
	&lt;li&gt;allowQueuedScheduling,&lt;/li&gt;
	&lt;li&gt;allocationTimeout);&lt;br/&gt;
+	private CompletableFuture&amp;lt;LogicalSlot&amp;gt; allocateSingleSlot(&lt;br/&gt;
+		SlotRequestId slotRequestId,&lt;br/&gt;
+		SlotProfile slotProfile,&lt;br/&gt;
+		boolean allowQueuedScheduling,&lt;br/&gt;
+		Time allocationTimeout) {&lt;br/&gt;
+		// request an allocated slot to assign a single logical slot to&lt;br/&gt;
+		CompletableFuture&amp;lt;SlotAndLocality&amp;gt; slotAndLocalityFuture = requestAllocatedSlot(&lt;br/&gt;
+			slotRequestId,&lt;br/&gt;
+			slotProfile,&lt;br/&gt;
+			allowQueuedScheduling,&lt;br/&gt;
+			allocationTimeout);&lt;br/&gt;
+&lt;br/&gt;
+		return slotAndLocalityFuture.thenApply(&lt;br/&gt;
+			(SlotAndLocality slotAndLocality) -&amp;gt; {&lt;br/&gt;
+				final AllocatedSlot allocatedSlot = slotAndLocality.getSlot();&lt;br/&gt;
+&lt;br/&gt;
+				final SingleLogicalSlot singleTaskSlot = new SingleLogicalSlot(&lt;br/&gt;
+					slotRequestId,&lt;br/&gt;
+					allocatedSlot,&lt;br/&gt;
+					null,&lt;br/&gt;
+					slotAndLocality.getLocality(),&lt;br/&gt;
+					providerAndOwner);&lt;br/&gt;
+&lt;br/&gt;
+				if (allocatedSlot.tryAssignPayload(singleTaskSlot)) 
{
+					return singleTaskSlot;
 				}
&lt;p&gt; else &lt;/p&gt;
{
-					multiTaskSlotLocality = allocateMultiTaskSlot(
-						task.getJobVertexId(),
-						multiTaskSlotManager,
-						slotProfile,
-						allowQueuedScheduling,
-						allocationTimeout);
+					final FlinkException flinkException =
+						new FlinkException(&quot;Could not assign payload to allocated slot &quot; + allocatedSlot.getAllocationId() + &apos;.&apos;);
+					releaseSingleSlot(slotRequestId, flinkException);
+					throw new CompletionException(flinkException);
 				}&lt;/li&gt;
	&lt;li&gt;} catch (NoResourceAvailableException noResourceException) 
{
-				return FutureUtils.completedExceptionally(noResourceException);
-			}
&lt;p&gt;+			});&lt;br/&gt;
+	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// sanity check&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(!multiTaskSlotLocality.getMultiTaskSlot().contains(task.getJobVertexId()));&lt;br/&gt;
+	private CompletableFuture&amp;lt;LogicalSlot&amp;gt; allocateSharedSlot(&lt;br/&gt;
+		SlotRequestId slotRequestId,&lt;br/&gt;
+		ScheduledUnit task,&lt;br/&gt;
+		SlotProfile slotProfile,&lt;br/&gt;
+		boolean allowQueuedScheduling,&lt;br/&gt;
+		Time allocationTimeout) 
{
 
-			final SlotSharingManager.SingleTaskSlot leaf = multiTaskSlotLocality.getMultiTaskSlot().allocateSingleTaskSlot(
-				slotRequestId,
-				task.getJobVertexId(),
-				multiTaskSlotLocality.getLocality());
+		// allocate slot with slot sharing
+		final SlotSharingManager multiTaskSlotManager = slotSharingManagers.computeIfAbsent(
+			task.getSlotSharingGroupId(),
+			id -&amp;gt; new SlotSharingManager(
+				id,
+				this,
+				providerAndOwner));
 
-			return leaf.getLogicalSlotFuture();
-		}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// request an allocated slot to assign a single logical slot to&lt;/li&gt;
	&lt;li&gt;CompletableFuture&amp;lt;SlotAndLocality&amp;gt; slotAndLocalityFuture = requestAllocatedSlot(&lt;/li&gt;
	&lt;li&gt;slotRequestId,&lt;/li&gt;
	&lt;li&gt;slotProfile,&lt;/li&gt;
	&lt;li&gt;allowQueuedScheduling,&lt;/li&gt;
	&lt;li&gt;allocationTimeout);&lt;br/&gt;
+		final SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality;&lt;br/&gt;
+&lt;br/&gt;
+		try 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			if (task.getCoLocationConstraint() != null) {
+				multiTaskSlotLocality = allocateCoLocatedMultiTaskSlot(
+					task.getCoLocationConstraint(),
+					multiTaskSlotManager,
+					slotProfile,
+					allowQueuedScheduling,
+					allocationTimeout);
+			} else {
+				multiTaskSlotLocality = allocateMultiTaskSlot(
+					task.getJobVertexId(),
+					multiTaskSlotManager,
+					slotProfile,
+					allowQueuedScheduling,
+					allocationTimeout);
+			}+		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; catch (NoResourceAvailableException noResourceException) &lt;/p&gt;
{
+			return FutureUtils.completedExceptionally(noResourceException);
+		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return slotAndLocalityFuture.thenApply(&lt;/li&gt;
	&lt;li&gt;(SlotAndLocality slotAndLocality) -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;final AllocatedSlot allocatedSlot = slotAndLocality.getSlot();&lt;br/&gt;
+		// sanity check&lt;br/&gt;
+		Preconditions.checkState(!multiTaskSlotLocality.getMultiTaskSlot().contains(task.getJobVertexId()));&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final SingleLogicalSlot singleTaskSlot = new SingleLogicalSlot(&lt;/li&gt;
	&lt;li&gt;slotRequestId,&lt;/li&gt;
	&lt;li&gt;allocatedSlot,&lt;/li&gt;
	&lt;li&gt;null,&lt;/li&gt;
	&lt;li&gt;slotAndLocality.getLocality(),&lt;/li&gt;
	&lt;li&gt;providerAndOwner);&lt;br/&gt;
+		final SlotSharingManager.SingleTaskSlot leaf = multiTaskSlotLocality.getMultiTaskSlot().allocateSingleTaskSlot(&lt;br/&gt;
+			slotRequestId,&lt;br/&gt;
+			task.getJobVertexId(),&lt;br/&gt;
+			multiTaskSlotLocality.getLocality());&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (allocatedSlot.tryAssignPayload(singleTaskSlot)) 
{
-						return singleTaskSlot;
-					}
&lt;p&gt; else &lt;/p&gt;
{
-						final FlinkException flinkException = new FlinkException(&quot;Could not assign payload to allocated slot &quot; + allocatedSlot.getAllocationId() + &apos;.&apos;);
-						releaseSlot(slotRequestId, null, flinkException);
-						throw new CompletionException(flinkException);
-					}&lt;/li&gt;
	&lt;li&gt;});&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
+		return leaf.getLogicalSlotFuture();&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;br/&gt;
@@ -439,12 +459,13 @@ public void disconnectResourceManager() &lt;/p&gt;
{
 			slotProfile = new SlotProfile(
 				slotProfile.getResourceProfile(),
 				Collections.singleton(coLocationConstraint.getLocation()),
-				slotProfile.getPriorAllocations());
+				slotProfile.getPreferredAllocations());
 		}

&lt;p&gt; 		// get a new multi task slot&lt;br/&gt;
 		final SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality = allocateMultiTaskSlot(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;coLocationConstraint.getGroupId(), multiTaskSlotManager,&lt;br/&gt;
+			coLocationConstraint.getGroupId(),&lt;br/&gt;
+			multiTaskSlotManager,&lt;br/&gt;
 			slotProfile,&lt;br/&gt;
 			allowQueuedScheduling,&lt;br/&gt;
 			allocationTimeout);&lt;br/&gt;
@@ -549,9 +570,8 @@ public void disconnectResourceManager() {&lt;br/&gt;
 		if (multiTaskSlotLocality != null) {&lt;br/&gt;
 			// prefer slot sharing group slots over unused slots&lt;br/&gt;
 			if (polledSlotAndLocality != null) 
{
-				releaseSlot(
+				releaseSingleSlot(
 					allocatedSlotRequestId,
-					null,
 					new FlinkException(&quot;Locality constraint is not better fulfilled by allocated slot.&quot;));
 			}
&lt;p&gt; 			return multiTaskSlotLocality;&lt;br/&gt;
@@ -588,9 +608,8 @@ public void disconnectResourceManager() {&lt;br/&gt;
 								}&lt;br/&gt;
 							}&lt;br/&gt;
 						} else &lt;/p&gt;
{
-							releaseSlot(
+							releaseSingleSlot(
 								allocatedSlotRequestId,
-								null,
 								new FlinkException(&quot;Could not find task slot with &quot; + multiTaskSlotRequestId + &apos;.&apos;));
 						}
&lt;p&gt; 					});&lt;br/&gt;
@@ -742,41 +761,56 @@ private void stashRequestWaitingForResourceManager(final PendingRequest pendingR&lt;br/&gt;
 	// ------------------------------------------------------------------------&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public CompletableFuture&amp;lt;Acknowledge&amp;gt; releaseSlot(SlotRequestId slotRequestId, @Nullable SlotSharingGroupId slotSharingGroupId, Throwable cause) {&lt;br/&gt;
+	public CompletableFuture&amp;lt;Acknowledge&amp;gt; releaseSlot(&lt;br/&gt;
+		SlotRequestId slotRequestId,&lt;br/&gt;
+		@Nullable SlotSharingGroupId slotSharingGroupId,&lt;br/&gt;
+		Throwable cause) {&lt;br/&gt;
+&lt;br/&gt;
 		log.debug(&quot;Releasing slot &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt; because: {}&quot;, slotRequestId, cause != null ? cause.getMessage() : &quot;null&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		if (slotSharingGroupId != null) &lt;/p&gt;
{
-			final SlotSharingManager multiTaskSlotManager = slotSharingManagers.get(slotSharingGroupId);
+			releaseSharedSlot(slotRequestId, slotSharingGroupId, cause);
+		}
&lt;p&gt; else &lt;/p&gt;
{
+			releaseSingleSlot(slotRequestId, cause);
+		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (multiTaskSlotManager != null) 
{
-				final SlotSharingManager.TaskSlot taskSlot = multiTaskSlotManager.getTaskSlot(slotRequestId);
+		return CompletableFuture.completedFuture(Acknowledge.get());
+	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (taskSlot != null) 
{
-					taskSlot.release(cause);
-				}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;log.debug(&quot;Could not find slot &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt; in slot sharing group {}. Ignoring release slot request.&quot;, slotRequestId, slotSharingGroupId);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
+	private void releaseSharedSlot(&lt;br/&gt;
+		SlotRequestId slotRequestId,&lt;br/&gt;
+		@Nonnull SlotSharingGroupId slotSharingGroupId, Throwable cause) {&lt;br/&gt;
+&lt;br/&gt;
+		final SlotSharingManager multiTaskSlotManager = slotSharingManagers.get(slotSharingGroupId);&lt;br/&gt;
+&lt;br/&gt;
+		if (multiTaskSlotManager != null) {&lt;br/&gt;
+			final SlotSharingManager.TaskSlot taskSlot = multiTaskSlotManager.getTaskSlot(slotRequestId);&lt;br/&gt;
+&lt;br/&gt;
+			if (taskSlot != null) 
{
+				taskSlot.release(cause);
 			}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;log.debug(&quot;Could not find slot sharing group {}. Ignoring release slot request.&quot;, slotSharingGroupId);&lt;br/&gt;
+				log.debug(&quot;Could not find slot &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt; in slot sharing group {}. Ignoring release slot request.&quot;, slotRequestId, slotSharingGroupId);&lt;br/&gt;
 			}&lt;br/&gt;
 		} else {&lt;/li&gt;
	&lt;li&gt;final PendingRequest pendingRequest = removePendingRequest(slotRequestId);&lt;br/&gt;
+			log.debug(&quot;Could not find slot sharing group {}. Ignoring release slot request.&quot;, slotSharingGroupId);&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (pendingRequest != null) 
{
-				failPendingRequest(pendingRequest, new FlinkException(&quot;Pending slot request with &quot; + slotRequestId + &quot; has been released.&quot;));
-			}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;final AllocatedSlot allocatedSlot = allocatedSlots.remove(slotRequestId);&lt;br/&gt;
+	private void releaseSingleSlot(SlotRequestId slotRequestId, Throwable cause) {&lt;br/&gt;
+		final PendingRequest pendingRequest = removePendingRequest(slotRequestId);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (allocatedSlot != null) 
{
-					allocatedSlot.releasePayload(cause);
-					tryFulfillSlotRequestOrMakeAvailable(allocatedSlot);
-				}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;log.debug(&quot;There is no allocated slot &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt;. Ignoring the release slot request.&quot;, slotRequestId);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
+		if (pendingRequest != null) 
{
+			failPendingRequest(pendingRequest, new FlinkException(&quot;Pending slot request with &quot; + slotRequestId + &quot; has been released.&quot;));
+		}
&lt;p&gt; else {&lt;br/&gt;
+			final AllocatedSlot allocatedSlot = allocatedSlots.remove(slotRequestId);&lt;br/&gt;
+&lt;br/&gt;
+			if (allocatedSlot != null) &lt;/p&gt;
{
+				allocatedSlot.releasePayload(cause);
+				tryFulfillSlotRequestOrMakeAvailable(allocatedSlot);
+			}
&lt;p&gt; else {&lt;br/&gt;
+				log.debug(&quot;There is no allocated slot &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt;. Ignoring the release slot request.&quot;, slotRequestId);&lt;br/&gt;
 			}&lt;br/&gt;
 		}&lt;br/&gt;
-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;return CompletableFuture.completedFuture(Acknowledge.get());&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;br/&gt;
@@ -876,17 +910,13 @@ private PendingRequest pollMatchingPendingRequest(final AllocatedSlot slot) {&lt;br/&gt;
 		validateRunsInMainThread();&lt;/p&gt;

&lt;p&gt; 		List&amp;lt;CompletableFuture&amp;lt;Optional&amp;lt;SlotOffer&amp;gt;&amp;gt;&amp;gt; acceptedSlotOffers = offers.stream().map(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;offer -&amp;gt; 
{
-				CompletableFuture&amp;lt;Optional&amp;lt;SlotOffer&amp;gt;&amp;gt; acceptedSlotOffer = offerSlot(
-						taskManagerLocation,
-						taskManagerGateway,
-						offer)
-					.thenApply(
-						(acceptedSlot) -&amp;gt; acceptedSlot ? Optional.of(offer) : Optional.empty()
-					);
-
-				return acceptedSlotOffer;
-			}
&lt;p&gt;+			offer -&amp;gt; offerSlot(&lt;br/&gt;
+					taskManagerLocation,&lt;br/&gt;
+					taskManagerGateway,&lt;br/&gt;
+					offer)&lt;br/&gt;
+				.&amp;lt;Optional&amp;lt;SlotOffer&amp;gt;&amp;gt;thenApply(&lt;br/&gt;
+					(acceptedSlot) -&amp;gt; acceptedSlot ? Optional.of(offer) : Optional.empty()&lt;br/&gt;
+				)&lt;br/&gt;
 		).collect(Collectors.toList());&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		CompletableFuture&amp;lt;Collection&amp;lt;Optional&amp;lt;SlotOffer&amp;gt;&amp;gt;&amp;gt; optionalSlotOffers = FutureUtils.combineAll(acceptedSlotOffers);&lt;br/&gt;
@@ -1378,11 +1408,7 @@ int size() {&lt;/p&gt;

&lt;p&gt; 		@VisibleForTesting&lt;br/&gt;
 		Set&amp;lt;AllocatedSlot&amp;gt; getSlotsForTaskManager(ResourceID resourceId) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (allocatedSlotsByTaskManager.containsKey(resourceId)) 
{
-				return allocatedSlotsByTaskManager.get(resourceId);
-			}
&lt;p&gt; else &lt;/p&gt;
{
-				return Collections.emptySet();
-			}
&lt;p&gt;+			return allocatedSlotsByTaskManager.getOrDefault(resourceId, Collections.emptySet());&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -1423,18 +1449,12 @@ void add(final AllocatedSlot slot, final long timestamp) {&lt;br/&gt;
 				final ResourceID resourceID = slot.getTaskManagerLocation().getResourceID();&lt;br/&gt;
 				final String host = slot.getTaskManagerLocation().getFQDNHostname();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Set&amp;lt;AllocatedSlot&amp;gt; slotsForTaskManager = availableSlotsByTaskManager.get(resourceID);&lt;/li&gt;
	&lt;li&gt;if (slotsForTaskManager == null) 
{
-					slotsForTaskManager = new HashSet&amp;lt;&amp;gt;();
-					availableSlotsByTaskManager.put(resourceID, slotsForTaskManager);
-				}
&lt;p&gt;+				Set&amp;lt;AllocatedSlot&amp;gt; slotsForTaskManager =&lt;br/&gt;
+					availableSlotsByTaskManager.computeIfAbsent(resourceID, k -&amp;gt; new HashSet&amp;lt;&amp;gt;());&lt;br/&gt;
 				slotsForTaskManager.add(slot);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Set&amp;lt;AllocatedSlot&amp;gt; slotsForHost = availableSlotsByHost.get(host);&lt;/li&gt;
	&lt;li&gt;if (slotsForHost == null) 
{
-					slotsForHost = new HashSet&amp;lt;&amp;gt;();
-					availableSlotsByHost.put(host, slotsForHost);
-				}
&lt;p&gt;+				Set&amp;lt;AllocatedSlot&amp;gt; slotsForHost =&lt;br/&gt;
+					availableSlotsByHost.computeIfAbsent(host, k -&amp;gt; new HashSet&amp;lt;&amp;gt;());&lt;br/&gt;
 				slotsForHost.add(slot);&lt;br/&gt;
 			}&lt;br/&gt;
 			else {&lt;br/&gt;
@@ -1475,7 +1495,7 @@ SlotAndLocality poll(SchedulingStrategy schedulingStrategy, SlotProfile slotProf&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			SlotAndLocality matchingSlotAndLocality = schedulingStrategy.findMatchWithLocality(&lt;br/&gt;
 				slotProfile,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;slotAndTimestamps.stream(),&lt;br/&gt;
+				slotAndTimestamps::stream,&lt;br/&gt;
 				SlotAndTimestamp::slot,&lt;br/&gt;
 				(SlotAndTimestamp slot) -&amp;gt; slot.slot().getResourceProfile().isMatching(slotProfile.getResourceProfile()),&lt;br/&gt;
 				(SlotAndTimestamp slotAndTimestamp, Locality locality) -&amp;gt; {&lt;br/&gt;
@@ -1582,12 +1602,18 @@ void clear() {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;An implementation of the 
{@link SlotOwner}
&lt;p&gt; and &lt;/p&gt;
{@link SlotProvider}
&lt;p&gt; interfaces&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;that delegates methods as RPC calls to the SlotPool&apos;s RPC gateway.&lt;br/&gt;
 	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static class ProviderAndOwner implements SlotOwner, SlotProvider {&lt;br/&gt;
+	public static class ProviderAndOwner implements SlotOwner, SlotProvider {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		private final SlotPoolGateway gateway;&lt;br/&gt;
+		private final boolean requiresPreviousAllocationsForScheduling;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ProviderAndOwner(SlotPoolGateway gateway) {&lt;br/&gt;
+		ProviderAndOwner(SlotPoolGateway gateway, boolean requiresPreviousAllocationsForScheduling) 
{
 			this.gateway = gateway;
+			this.requiresPreviousAllocationsForScheduling = requiresPreviousAllocationsForScheduling;
+		}
&lt;p&gt;+&lt;br/&gt;
+		public boolean requiresPreviousAllocationsForScheduling() &lt;/p&gt;
{
+			return requiresPreviousAllocationsForScheduling;
 		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		@Override&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManager.java&lt;br/&gt;
index ef288a26469..af5582752d9 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManager.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManager.java&lt;br/&gt;
@@ -186,7 +186,7 @@ MultiTaskSlotLocality getResolvedRootSlot(AbstractID groupId, SchedulingStrategy&lt;br/&gt;
 		Collection&amp;lt;Set&amp;lt;MultiTaskSlot&amp;gt;&amp;gt; resolvedRootSlotsValues = this.resolvedRootSlots.values();&lt;br/&gt;
 		return matcher.findMatchWithLocality(&lt;br/&gt;
 			slotProfile,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;resolvedRootSlotsValues.stream().flatMap(Collection::stream),&lt;br/&gt;
+			() -&amp;gt; resolvedRootSlotsValues.stream().flatMap(Collection::stream),&lt;br/&gt;
 			(MultiTaskSlot multiTaskSlot) -&amp;gt; multiTaskSlot.getSlotContextFuture().join(),&lt;br/&gt;
 			(MultiTaskSlot multiTaskSlot) -&amp;gt; !multiTaskSlot.contains(groupId),&lt;br/&gt;
 			MultiTaskSlotLocality::of);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/clusterframework/types/SlotProfileTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/clusterframework/types/SlotProfileTest.java&lt;br/&gt;
index 6a826aa23e1..ee491499b77 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/clusterframework/types/SlotProfileTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/clusterframework/types/SlotProfileTest.java&lt;br/&gt;
@@ -124,18 +124,59 @@ public void matchPreviousAllocationOverridesPreferredLocation() {&lt;br/&gt;
 	}&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	@Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void matchPreviousLocationNotAvailable() {&lt;br/&gt;
+	public void matchPreviousLocationNotAvailableButByLocality() 
{
 
 		SlotProfile slotProfile = new SlotProfile(resourceProfile, Collections.singletonList(tml4), Collections.singletonList(aidX));
 		SlotContext match = runMatching(slotProfile);
 
-		Assert.assertEquals(null, match);
+		Assert.assertEquals(ssc4, match);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void matchPreviousLocationNotAvailableAndAllOthersBlacklisted() &lt;/p&gt;
{
+		HashSet&amp;lt;AllocationID&amp;gt; blacklisted = new HashSet&amp;lt;&amp;gt;(4);
+		blacklisted.add(aid1);
+		blacklisted.add(aid2);
+		blacklisted.add(aid3);
+		blacklisted.add(aid4);
+		SlotProfile slotProfile = new SlotProfile(resourceProfile, Collections.singletonList(tml4), Collections.singletonList(aidX), blacklisted);
+		SlotContext match = runMatching(slotProfile);
+
+		// there should be no valid option left and we expect null as return
+		Assert.assertNull(match);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void matchPreviousLocationNotAvailableAndSomeOthersBlacklisted() &lt;/p&gt;
{
+		HashSet&amp;lt;AllocationID&amp;gt; blacklisted = new HashSet&amp;lt;&amp;gt;(3);
+		blacklisted.add(aid1);
+		blacklisted.add(aid3);
+		blacklisted.add(aid4);
+		SlotProfile slotProfile = new SlotProfile(resourceProfile, Collections.singletonList(tml4), Collections.singletonList(aidX), blacklisted);
+		SlotContext match = runMatching(slotProfile);
+
+		// we expect that the candidate that is not blacklisted is returned
+		Assert.assertEquals(ssc2, match);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void matchPreviousLocationAvailableButAlsoBlacklisted() &lt;/p&gt;
{
+		HashSet&amp;lt;AllocationID&amp;gt; blacklisted = new HashSet&amp;lt;&amp;gt;(4);
+		blacklisted.add(aid1);
+		blacklisted.add(aid2);
+		blacklisted.add(aid3);
+		blacklisted.add(aid4);
+		SlotProfile slotProfile = new SlotProfile(resourceProfile, Collections.singletonList(tml3), Collections.singletonList(aid3), blacklisted);
+		SlotContext match = runMatching(slotProfile);
+
+		// available previous allocation should override blacklisting
+		Assert.assertEquals(ssc3, match);
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	private SlotContext runMatching(SlotProfile slotProfile) {&lt;br/&gt;
 		return schedulingStrategy.findMatchWithLocality(&lt;br/&gt;
 			slotProfile,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;candidates.stream(),&lt;br/&gt;
+			candidates::stream,&lt;br/&gt;
 			(candidate) -&amp;gt; candidate,&lt;br/&gt;
 			(candidate) -&amp;gt; true,&lt;br/&gt;
 			(candidate, locality) -&amp;gt; candidate);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java&lt;br/&gt;
index 56fd7e12369..74724629eea 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java&lt;br/&gt;
@@ -107,6 +107,7 @@ public void testSlotReleaseOnFailedResourceAssignment() throws Exception {&lt;br/&gt;
 			slotProvider,&lt;br/&gt;
 			false,&lt;br/&gt;
 			LocationPreferenceConstraint.ALL,&lt;br/&gt;
+			Collections.emptySet(),&lt;br/&gt;
 			TestingUtils.infiniteTime());&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		assertFalse(allocationFuture.isDone());&lt;br/&gt;
@@ -156,6 +157,7 @@ public void testSlotReleaseOnExecutionCancellationInScheduled() throws Exception&lt;br/&gt;
 			slotProvider,&lt;br/&gt;
 			false,&lt;br/&gt;
 			LocationPreferenceConstraint.ALL,&lt;br/&gt;
+			Collections.emptySet(),&lt;br/&gt;
 			TestingUtils.infiniteTime());&lt;/p&gt;

&lt;p&gt; 		assertTrue(allocationFuture.isDone());&lt;br/&gt;
@@ -205,6 +207,7 @@ public void testSlotReleaseOnExecutionCancellationInRunning() throws Exception {&lt;br/&gt;
 			slotProvider,&lt;br/&gt;
 			false,&lt;br/&gt;
 			LocationPreferenceConstraint.ALL,&lt;br/&gt;
+			Collections.emptySet(),&lt;br/&gt;
 			TestingUtils.infiniteTime());&lt;/p&gt;

&lt;p&gt; 		assertTrue(allocationFuture.isDone());&lt;br/&gt;
@@ -254,6 +257,7 @@ public void testSlotAllocationCancellationWhenExecutionCancelled() throws Except&lt;br/&gt;
 			slotProvider,&lt;br/&gt;
 			false,&lt;br/&gt;
 			LocationPreferenceConstraint.ALL,&lt;br/&gt;
+			Collections.emptySet(),&lt;br/&gt;
 			TestingUtils.infiniteTime());&lt;/p&gt;

&lt;p&gt; 		assertThat(allocationFuture.isDone(), is(false));&lt;br/&gt;
@@ -357,7 +361,7 @@ public void testTerminationFutureIsCompletedAfterSlotRelease() throws Exception&lt;/p&gt;

&lt;p&gt; 		ExecutionVertex executionVertex = executionJobVertex.getTaskVertices()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;executionVertex.scheduleForExecution(slotProvider, false, LocationPreferenceConstraint.ANY).get();&lt;br/&gt;
+		executionVertex.scheduleForExecution(slotProvider, false, LocationPreferenceConstraint.ANY, Collections.emptySet()).get();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		Execution currentExecutionAttempt = executionVertex.getCurrentExecutionAttempt();&lt;/p&gt;

&lt;p&gt;@@ -417,7 +421,7 @@ public void testTaskRestoreStateIsNulledAfterDeployment() throws Exception &lt;/p&gt;
{
 		assertThat(execution.getTaskRestore(), is(notNullValue()));
 
 		// schedule the execution vertex and wait for its deployment
-		executionVertex.scheduleForExecution(slotProvider, false, LocationPreferenceConstraint.ANY).get();
+		executionVertex.scheduleForExecution(slotProvider, false, LocationPreferenceConstraint.ANY, Collections.emptySet()).get();
 
 		assertThat(execution.getTaskRestore(), is(nullValue()));
 	}
&lt;p&gt;@@ -479,7 +483,8 @@ public void testEagerSchedulingFailureReturnsSlot() throws Exception {&lt;br/&gt;
 			final CompletableFuture&amp;lt;Void&amp;gt; schedulingFuture = execution.scheduleForExecution(&lt;br/&gt;
 				slotProvider,&lt;br/&gt;
 				false,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LocationPreferenceConstraint.ANY);&lt;br/&gt;
+				LocationPreferenceConstraint.ANY,&lt;br/&gt;
+				Collections.emptySet());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			try {&lt;br/&gt;
 				schedulingFuture.get();&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexCancelTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexCancelTest.java&lt;br/&gt;
index cd613f0f50a..41894767b6a 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexCancelTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexCancelTest.java&lt;br/&gt;
@@ -40,6 +40,7 @@&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt; import java.io.IOException;&lt;br/&gt;
+import java.util.Collections;&lt;/p&gt;

&lt;p&gt; import scala.concurrent.ExecutionContext;&lt;/p&gt;

&lt;p&gt;@@ -454,7 +455,7 @@ public void testScheduleOrDeployAfterCancel() {&lt;br/&gt;
 			// it can occur as the result of races&lt;/p&gt;
 			{
 				Scheduler scheduler = mock(Scheduler.class);
-				vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL);
+				vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL, Collections.emptySet());
 
 				assertEquals(ExecutionState.CANCELED, vertex.getExecutionState());
 			}
&lt;p&gt;@@ -493,7 +494,7 @@ public void testActionsWhileCancelling() &lt;/p&gt;
{
 				setVertexState(vertex, ExecutionState.CANCELING);
 
 				Scheduler scheduler = mock(Scheduler.class);
-				vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL);
+				vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL, Collections.emptySet());
 			}
&lt;p&gt; 			catch (Exception e) {&lt;br/&gt;
 				fail(&quot;should not throw an exception&quot;);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexSchedulingTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexSchedulingTest.java&lt;br/&gt;
index 51d1827e668..6bfcb7ff5d0 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexSchedulingTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexSchedulingTest.java&lt;br/&gt;
@@ -36,6 +36,7 @@&lt;/p&gt;

&lt;p&gt; import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+import java.util.Collections;&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;/p&gt;

&lt;p&gt; import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.getExecutionVertex;&lt;br/&gt;
@@ -71,7 +72,7 @@ public void testSlotReleasedWhenScheduledImmediately() {&lt;/p&gt;

&lt;p&gt; 			assertEquals(ExecutionState.CREATED, vertex.getExecutionState());&lt;br/&gt;
 			// try to deploy to the slot&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL);&lt;br/&gt;
+			vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL, Collections.emptySet());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			// will have failed&lt;br/&gt;
 			assertEquals(ExecutionState.FAILED, vertex.getExecutionState());&lt;br/&gt;
@@ -103,7 +104,7 @@ public void testSlotReleasedWhenScheduledQueued() {&lt;/p&gt;

&lt;p&gt; 			assertEquals(ExecutionState.CREATED, vertex.getExecutionState());&lt;br/&gt;
 			// try to deploy to the slot&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;vertex.scheduleForExecution(scheduler, true, LocationPreferenceConstraint.ALL);&lt;br/&gt;
+			vertex.scheduleForExecution(scheduler, true, LocationPreferenceConstraint.ALL, Collections.emptySet());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			// future has not yet a slot&lt;br/&gt;
 			assertEquals(ExecutionState.SCHEDULED, vertex.getExecutionState());&lt;br/&gt;
@@ -138,7 +139,7 @@ public void testScheduleToDeploying() &lt;/p&gt;
{
 			assertEquals(ExecutionState.CREATED, vertex.getExecutionState());
 
 			// try to deploy to the slot
-			vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL);
+			vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL, Collections.emptySet());
 			assertEquals(ExecutionState.DEPLOYING, vertex.getExecutionState());
 		}
&lt;p&gt; 		catch (Exception e) {&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/FailoverRegionTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/FailoverRegionTest.java&lt;br/&gt;
index c411393990c..a53debfd0b8 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/FailoverRegionTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/FailoverRegionTest.java&lt;br/&gt;
@@ -49,6 +49,7 @@&lt;/p&gt;

&lt;p&gt; import java.util.ArrayList;&lt;br/&gt;
 import java.util.Arrays;&lt;br/&gt;
+import java.util.Collections;&lt;br/&gt;
 import java.util.Iterator;&lt;br/&gt;
 import java.util.List;&lt;/p&gt;

&lt;p&gt;@@ -157,7 +158,7 @@ public void testMultiRegionsFailover() throws Exception {&lt;/p&gt;

&lt;p&gt; 		assertEquals(JobStatus.RUNNING, strategy.getFailoverRegion(ev11).getState());&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ev21.scheduleForExecution(slotProvider, true, LocationPreferenceConstraint.ALL);&lt;br/&gt;
+		ev21.scheduleForExecution(slotProvider, true, LocationPreferenceConstraint.ALL, Collections.emptySet());&lt;br/&gt;
 		ev21.getCurrentExecutionAttempt().fail(new Exception(&quot;New fail&quot;));&lt;br/&gt;
 		assertEquals(JobStatus.CANCELLING, strategy.getFailoverRegion(ev11).getState());&lt;br/&gt;
 		assertEquals(JobStatus.RUNNING, strategy.getFailoverRegion(ev22).getState());&lt;br/&gt;
@@ -170,7 +171,7 @@ public void testMultiRegionsFailover() throws Exception {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ev11.getCurrentExecutionAttempt().markFinished();&lt;br/&gt;
 		ev21.getCurrentExecutionAttempt().markFinished();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ev22.scheduleForExecution(slotProvider, true, LocationPreferenceConstraint.ALL);&lt;br/&gt;
+		ev22.scheduleForExecution(slotProvider, true, LocationPreferenceConstraint.ALL, Collections.emptySet());&lt;br/&gt;
 		ev22.getCurrentExecutionAttempt().markFinished();&lt;br/&gt;
 		assertEquals(JobStatus.RUNNING, strategy.getFailoverRegion(ev11).getState());&lt;br/&gt;
 		assertEquals(JobStatus.RUNNING, strategy.getFailoverRegion(ev22).getState());&lt;br/&gt;
diff --git a/flink-tests/src/test/java/org/apache/flink/test/runtime/SchedulingITCase.java b/flink-tests/src/test/java/org/apache/flink/test/runtime/SchedulingITCase.java&lt;br/&gt;
index 0344d71879b..fb28c2c75a4 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-tests/src/test/java/org/apache/flink/test/runtime/SchedulingITCase.java&lt;br/&gt;
+++ b/flink-tests/src/test/java/org/apache/flink/test/runtime/SchedulingITCase.java&lt;br/&gt;
@@ -41,7 +41,6 @@&lt;br/&gt;
 import org.apache.flink.util.FlinkException;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-import org.junit.Ignore;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
@@ -50,6 +49,7 @@&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;br/&gt;
 import java.util.concurrent.atomic.AtomicBoolean;&lt;/p&gt;

&lt;p&gt;+import static org.apache.flink.configuration.JobManagerOptions.EXECUTION_FAILOVER_STRATEGY;&lt;br/&gt;
 import static org.hamcrest.Matchers.is;&lt;br/&gt;
 import static org.junit.Assert.assertThat;&lt;/p&gt;

&lt;p&gt;@@ -72,13 +72,26 @@ public void testDisablingLocalRecovery() throws Exception {&lt;/p&gt;

&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Tests that if local recovery is enabled we won&apos;t spread&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* out tasks when recovering.&lt;br/&gt;
+	 * out tasks when recovering for global failover.&lt;br/&gt;
 	 */&lt;br/&gt;
 	@Test&lt;/li&gt;
	&lt;li&gt;@Ignore(&quot;The test should not pass until &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; has been fixed&quot;)&lt;/li&gt;
	&lt;li&gt;public void testLocalRecovery() throws Exception {&lt;br/&gt;
+	public void testLocalRecoveryFull() throws Exception 
{
+		testLocalRecoveryInternal(&quot;full&quot;);
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that if local recovery is enabled we won&apos;t spread&lt;br/&gt;
+	 * out tasks when recovering for regional failover.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testLocalRecoveryRegion() throws Exception &lt;/p&gt;
{
+		testLocalRecoveryInternal(&quot;region&quot;);
+	}
&lt;p&gt;+&lt;br/&gt;
+	private void testLocalRecoveryInternal(String failoverStrategyValue) throws Exception &lt;/p&gt;
{
 		final Configuration configuration = new Configuration();
 		configuration.setBoolean(CheckpointingOptions.LOCAL_RECOVERY, true);
+		configuration.setString(EXECUTION_FAILOVER_STRATEGY.key(), failoverStrategyValue);
 
 		executeSchedulingTest(configuration);
 	}&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16669105" author="srichter" created="Tue, 30 Oct 2018 17:37:04 +0000"  >&lt;p&gt;Merged in:&lt;br/&gt;
master: c8a6471a58&lt;/p&gt;</comment>
                            <comment id="16669884" author="githubbot" created="Wed, 31 Oct 2018 10:18:34 +0000"  >&lt;p&gt;StefanRRichter opened a new pull request #6972: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;scheduling&amp;#93;&lt;/span&gt; Avoid task spread-out in scheduling with loc&#8230;&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6972&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6972&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   &#8230;al recovery&lt;/p&gt;

&lt;p&gt;   This PR is just a backport of &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt;, PR #6961 to the release-1.6 branch.&lt;/p&gt;


&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16671441" author="githubbot" created="Thu, 1 Nov 2018 10:35:50 +0000"  >&lt;p&gt;tillrohrmann closed pull request #6972: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;scheduling&amp;#93;&lt;/span&gt; Avoid task spread-out in scheduling with loc&#8230;&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6972&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6972&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/clusterframework/types/SlotProfile.java b/flink-runtime/src/main/java/org/apache/flink/runtime/clusterframework/types/SlotProfile.java&lt;br/&gt;
index 7cb364d687f..ab682a02dd1 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/clusterframework/types/SlotProfile.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/clusterframework/types/SlotProfile.java&lt;br/&gt;
@@ -25,6 +25,7 @@&lt;/p&gt;

&lt;p&gt; import java.util.Collection;&lt;br/&gt;
 import java.util.Collections;&lt;br/&gt;
+import java.util.Set;&lt;/p&gt;

&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A slot profile describes the profile of a slot into which a task wants to be scheduled. The profile contains&lt;br/&gt;
@@ -47,16 +48,30 @@&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/** This contains desired allocation ids of the slot. */&lt;br/&gt;
 	@Nonnull&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final Collection&amp;lt;AllocationID&amp;gt; priorAllocations;&lt;br/&gt;
+	private final Collection&amp;lt;AllocationID&amp;gt; preferredAllocations;&lt;br/&gt;
+&lt;br/&gt;
+	/** This contains all prior allocation ids from the whole execution graph. */&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private final Set&amp;lt;AllocationID&amp;gt; previousExecutionGraphAllocations;&lt;br/&gt;
+&lt;br/&gt;
+	public SlotProfile(&lt;br/&gt;
+		@Nonnull ResourceProfile resourceProfile,&lt;br/&gt;
+		@Nonnull Collection&amp;lt;TaskManagerLocation&amp;gt; preferredLocations,&lt;br/&gt;
+		@Nonnull Collection&amp;lt;AllocationID&amp;gt; preferredAllocations) 
{
+
+		this(resourceProfile, preferredLocations, preferredAllocations, Collections.emptySet());
+	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	public SlotProfile(&lt;br/&gt;
 		@Nonnull ResourceProfile resourceProfile,&lt;br/&gt;
 		@Nonnull Collection&amp;lt;TaskManagerLocation&amp;gt; preferredLocations,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Nonnull Collection&amp;lt;AllocationID&amp;gt; priorAllocations) {&lt;br/&gt;
+		@Nonnull Collection&amp;lt;AllocationID&amp;gt; preferredAllocations,&lt;br/&gt;
+		@Nonnull Set&amp;lt;AllocationID&amp;gt; previousExecutionGraphAllocations) 
{
 
 		this.resourceProfile = resourceProfile;
 		this.preferredLocations = preferredLocations;
-		this.priorAllocations = priorAllocations;
+		this.preferredAllocations = preferredAllocations;
+		this.previousExecutionGraphAllocations = previousExecutionGraphAllocations;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;br/&gt;
@@ -79,8 +94,18 @@ public ResourceProfile getResourceProfile() {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns the desired allocation ids for the slot.&lt;br/&gt;
 	 */&lt;br/&gt;
 	@Nonnull&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public Collection&amp;lt;AllocationID&amp;gt; getPriorAllocations() {&lt;/li&gt;
	&lt;li&gt;return priorAllocations;&lt;br/&gt;
+	public Collection&amp;lt;AllocationID&amp;gt; getPreferredAllocations() 
{
+		return preferredAllocations;
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns a set of all previous allocation ids from the execution graph.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * This is optional and can be empty if unused.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	public Set&amp;lt;AllocationID&amp;gt; getPreviousExecutionGraphAllocations() &lt;/p&gt;
{
+		return previousExecutionGraphAllocations;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java&lt;br/&gt;
index 801f35a41dc..cbf51037b8b 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java&lt;br/&gt;
@@ -58,6 +58,7 @@&lt;/p&gt;

&lt;p&gt; import org.slf4j.Logger;&lt;/p&gt;

&lt;p&gt;+import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.util.ArrayList;&lt;br/&gt;
@@ -65,6 +66,7 @@&lt;br/&gt;
 import java.util.Collections;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Map;&lt;br/&gt;
+import java.util.Set;&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;br/&gt;
 import java.util.concurrent.CompletionException;&lt;br/&gt;
 import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
@@ -385,7 +387,8 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) &lt;/p&gt;
{
 		return scheduleForExecution(
 			resourceProvider,
 			allowQueued,
-			LocationPreferenceConstraint.ANY);
+			LocationPreferenceConstraint.ANY,
+			Collections.emptySet());
 	}

&lt;p&gt; 	/**&lt;br/&gt;
@@ -397,18 +400,22 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param queued Flag to indicate whether the scheduler may queue this task if it cannot&lt;/li&gt;
	&lt;li&gt;immediately deploy it.&lt;/li&gt;
	&lt;li&gt;@param locationPreferenceConstraint constraint for the location preferences&lt;br/&gt;
+	 * @param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph.&lt;br/&gt;
+	 *                                                 Can be empty if the allocation ids are not required for scheduling.&lt;/li&gt;
	&lt;li&gt;@return Future which is completed once the Execution has been deployed&lt;br/&gt;
 	 */&lt;br/&gt;
 	public CompletableFuture&amp;lt;Void&amp;gt; scheduleForExecution(&lt;br/&gt;
 			SlotProvider slotProvider,&lt;br/&gt;
 			boolean queued,&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
+			LocationPreferenceConstraint locationPreferenceConstraint,&lt;br/&gt;
+			@Nonnull Set&amp;lt;AllocationID&amp;gt; allPreviousExecutionGraphAllocationIds) {&lt;br/&gt;
 		final Time allocationTimeout = vertex.getExecutionGraph().getAllocationTimeout();&lt;br/&gt;
 		try {&lt;br/&gt;
 			final CompletableFuture&amp;lt;Execution&amp;gt; allocationFuture = allocateAndAssignSlotForExecution(&lt;br/&gt;
 				slotProvider,&lt;br/&gt;
 				queued,&lt;br/&gt;
 				locationPreferenceConstraint,&lt;br/&gt;
+				allPreviousExecutionGraphAllocationIds,&lt;br/&gt;
 				allocationTimeout);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			// IMPORTANT: We have to use the synchronous handle operation (direct executor) here so&lt;br/&gt;
@@ -441,6 +448,8 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param slotProvider to obtain a new slot from&lt;/li&gt;
	&lt;li&gt;@param queued if the allocation can be queued&lt;/li&gt;
	&lt;li&gt;@param locationPreferenceConstraint constraint for the location preferences&lt;br/&gt;
+	 * @param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph.&lt;br/&gt;
+	 *                                                 Can be empty if the allocation ids are not required for scheduling.&lt;/li&gt;
	&lt;li&gt;@param allocationTimeout rpcTimeout for allocating a new slot&lt;/li&gt;
	&lt;li&gt;@return Future which is completed with this execution once the slot has been assigned&lt;/li&gt;
	&lt;li&gt;or with an exception if an error occurred.&lt;br/&gt;
@@ -450,6 +459,7 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {&lt;br/&gt;
 			SlotProvider slotProvider,&lt;br/&gt;
 			boolean queued,&lt;br/&gt;
 			LocationPreferenceConstraint locationPreferenceConstraint,&lt;br/&gt;
+			@Nonnull Set&amp;lt;AllocationID&amp;gt; allPreviousExecutionGraphAllocationIds,&lt;br/&gt;
 			Time allocationTimeout) throws IllegalExecutionStateException {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		checkNotNull(slotProvider);&lt;br/&gt;
@@ -495,7 +505,8 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {&lt;br/&gt;
 							new SlotProfile(&lt;br/&gt;
 								ResourceProfile.UNKNOWN,&lt;br/&gt;
 								preferredLocations,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;previousAllocationIDs),&lt;br/&gt;
+								previousAllocationIDs,&lt;br/&gt;
+								allPreviousExecutionGraphAllocationIds),&lt;br/&gt;
 							allocationTimeout));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			// register call back to cancel slot request in case that the execution gets canceled&lt;br/&gt;
@@ -739,7 +750,8 @@ else if (numConsumers == 0) &lt;/p&gt;
{
 							consumerVertex.scheduleForExecution(
 								executionGraph.getSlotProvider(),
 								executionGraph.isQueuedSchedulingAllowed(),
-								LocationPreferenceConstraint.ANY); // there must be at least one known location
+								LocationPreferenceConstraint.ANY, // there must be at least one known location
+								Collections.emptySet());
 						}
&lt;p&gt; catch (Throwable t) {&lt;br/&gt;
 							consumerVertex.fail(new IllegalStateException(&quot;Could not schedule consumer &quot; +&lt;br/&gt;
 									&quot;vertex &quot; + consumerVertex, t));&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java&lt;br/&gt;
index 0be1ff27420..3b55e009116 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java&lt;br/&gt;
@@ -40,6 +40,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CheckpointStatsTracker;&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpointStore;&lt;br/&gt;
 import org.apache.flink.runtime.checkpoint.MasterTriggerRestoreHook;&lt;br/&gt;
+import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.FutureUtils.ConjunctFuture;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.ScheduledExecutorServiceAdapter;&lt;br/&gt;
@@ -60,6 +61,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroup;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.scheduler.LocationPreferenceConstraint;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;&lt;br/&gt;
+import org.apache.flink.runtime.jobmaster.slotpool.SlotPool;&lt;br/&gt;
 import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;&lt;br/&gt;
 import org.apache.flink.runtime.query.KvStateLocationRegistry;&lt;br/&gt;
 import org.apache.flink.runtime.state.SharedStateRegistry;&lt;br/&gt;
@@ -91,6 +93,7 @@&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Map;&lt;br/&gt;
 import java.util.NoSuchElementException;&lt;br/&gt;
+import java.util.Set;&lt;br/&gt;
 import java.util.concurrent.CancellationException;&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;br/&gt;
 import java.util.concurrent.CompletionException;&lt;br/&gt;
@@ -902,14 +905,14 @@ public void scheduleForExecution() throws JobException {&lt;br/&gt;
 	private CompletableFuture&amp;lt;Void&amp;gt; scheduleLazy(SlotProvider slotProvider) {&lt;/p&gt;

&lt;p&gt; 		final ArrayList&amp;lt;CompletableFuture&amp;lt;Void&amp;gt;&amp;gt; schedulingFutures = new ArrayList&amp;lt;&amp;gt;(numVerticesTotal);&lt;br/&gt;
-&lt;br/&gt;
 		// simply take the vertices without inputs.&lt;br/&gt;
 		for (ExecutionJobVertex ejv : verticesInCreationOrder) {&lt;br/&gt;
 			if (ejv.getJobVertex().isInputVertex()) &lt;/p&gt;
{
 				final CompletableFuture&amp;lt;Void&amp;gt; schedulingJobVertexFuture = ejv.scheduleAll(
 					slotProvider,
 					allowQueuedScheduling,
-					LocationPreferenceConstraint.ALL); // since it is an input vertex, the input based location preferences should be empty
+					LocationPreferenceConstraint.ALL,// since it is an input vertex, the input based location preferences should be empty
+					Collections.emptySet());
 
 				schedulingFutures.add(schedulingJobVertexFuture);
 			}
&lt;p&gt;@@ -939,6 +942,9 @@ public void scheduleForExecution() throws JobException {&lt;br/&gt;
 		// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
 		final ArrayList&amp;lt;CompletableFuture&amp;lt;Execution&amp;gt;&amp;gt; allAllocationFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;/p&gt;

&lt;p&gt;+		final Set&amp;lt;AllocationID&amp;gt; allPreviousAllocationIds =&lt;br/&gt;
+			Collections.unmodifiableSet(computeAllPriorAllocationIdsIfRequiredByScheduling());&lt;br/&gt;
+&lt;br/&gt;
 		// allocate the slots (obtain all their futures&lt;br/&gt;
 		for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
 			// these calls are not blocking, they only return futures&lt;br/&gt;
@@ -946,7 +952,8 @@ public void scheduleForExecution() throws JobException &lt;/p&gt;
{
 				slotProvider,
 				queued,
 				LocationPreferenceConstraint.ALL,
-				allocationTimeout);
+				allPreviousAllocationIds,
+				timeout);
 
 			allAllocationFutures.addAll(allocationFutures);
 		}
&lt;p&gt;@@ -1676,6 +1683,35 @@ public void updateAccumulators(AccumulatorSnapshot accumulatorSnapshot) {&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * Computes and returns a set with the prior allocation ids from all execution vertices in the graph.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private Set&amp;lt;AllocationID&amp;gt; computeAllPriorAllocationIds() {&lt;br/&gt;
+		HashSet&amp;lt;AllocationID&amp;gt; allPreviousAllocationIds = new HashSet&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
+		for (ExecutionVertex executionVertex : getAllExecutionVertices()) {&lt;br/&gt;
+			AllocationID latestPriorAllocation = executionVertex.getLatestPriorAllocation();&lt;br/&gt;
+			if (latestPriorAllocation != null) &lt;/p&gt;
{
+				allPreviousAllocationIds.add(latestPriorAllocation);
+			}
&lt;p&gt;+		}&lt;br/&gt;
+		return allPreviousAllocationIds;&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Returns the result of &lt;/p&gt;
{@link #computeAllPriorAllocationIds()}
&lt;p&gt;, but only if the scheduling really requires it.&lt;br/&gt;
+	 * Otherwise this method simply returns an empty set.&lt;br/&gt;
+	 */&lt;br/&gt;
+	private Set&amp;lt;AllocationID&amp;gt; computeAllPriorAllocationIdsIfRequiredByScheduling() {&lt;br/&gt;
+		// This is a temporary optimization to avoid computing all previous allocations if not required&lt;br/&gt;
+		// This can go away when we progress with the implementation of the Scheduler.&lt;br/&gt;
+		if (slotProvider instanceof SlotPool.ProviderAndOwner&lt;br/&gt;
+			&amp;amp;&amp;amp; ((SlotPool.ProviderAndOwner) slotProvider).requiresPreviousAllocationsForScheduling()) &lt;/p&gt;
{
+			return computeAllPriorAllocationIds();
+		}
&lt;p&gt; else &lt;/p&gt;
{
+			return Collections.emptySet();
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
 	// --------------------------------------------------------------------------------------------&lt;br/&gt;
 	//  Listeners &amp;amp; Observers&lt;br/&gt;
 	// --------------------------------------------------------------------------------------------&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java&lt;br/&gt;
index 6da1e0db892..2ab1d686410 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java&lt;br/&gt;
@@ -34,6 +34,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.accumulators.StringifiedAccumulatorResult;&lt;br/&gt;
 import org.apache.flink.runtime.blob.BlobWriter;&lt;br/&gt;
 import org.apache.flink.runtime.blob.PermanentBlobKey;&lt;br/&gt;
+import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
 import org.apache.flink.runtime.execution.ExecutionState;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.IntermediateDataSet;&lt;br/&gt;
@@ -54,6 +55,7 @@&lt;/p&gt;

&lt;p&gt; import org.slf4j.Logger;&lt;/p&gt;

&lt;p&gt;+import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.io.IOException;&lt;br/&gt;
@@ -64,6 +66,7 @@&lt;br/&gt;
 import java.util.HashMap;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Map;&lt;br/&gt;
+import java.util.Set;&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -474,12 +477,15 @@ public void connectToPredecessors(Map&amp;lt;IntermediateDataSetID, IntermediateResult&amp;gt;&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param slotProvider to allocate the slots from&lt;/li&gt;
	&lt;li&gt;@param queued if the allocations can be queued&lt;/li&gt;
	&lt;li&gt;@param locationPreferenceConstraint constraint for the location preferences&lt;br/&gt;
+	 * @param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph.&lt;br/&gt;
+	 *                                                 Can be empty if the allocation ids are not required for scheduling.&lt;/li&gt;
	&lt;li&gt;@return Future which is completed once all 
{@link Execution}
&lt;p&gt; could be deployed&lt;br/&gt;
 	 */&lt;br/&gt;
 	public CompletableFuture&amp;lt;Void&amp;gt; scheduleAll(&lt;br/&gt;
 			SlotProvider slotProvider,&lt;br/&gt;
 			boolean queued,&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
+			LocationPreferenceConstraint locationPreferenceConstraint,&lt;br/&gt;
+			@Nonnull Set&amp;lt;AllocationID&amp;gt; allPreviousExecutionGraphAllocationIds) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final ExecutionVertex[] vertices = this.taskVertices;&lt;/p&gt;

&lt;p&gt;@@ -487,7 +493,11 @@ public void connectToPredecessors(Map&amp;lt;IntermediateDataSetID, IntermediateResult&amp;gt;&lt;/p&gt;

&lt;p&gt; 		// kick off the tasks&lt;br/&gt;
 		for (ExecutionVertex ev : vertices) &lt;/p&gt;
{
-			scheduleFutures.add(ev.scheduleForExecution(slotProvider, queued, locationPreferenceConstraint));
+			scheduleFutures.add(ev.scheduleForExecution(
+				slotProvider,
+				queued,
+				locationPreferenceConstraint,
+				allPreviousExecutionGraphAllocationIds));
 		}

&lt;p&gt; 		return FutureUtils.waitForAll(scheduleFutures);&lt;br/&gt;
@@ -503,12 +513,14 @@ public void connectToPredecessors(Map&amp;lt;IntermediateDataSetID, IntermediateResult&amp;gt;&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param resourceProvider The resource provider from whom the slots are requested.&lt;/li&gt;
	&lt;li&gt;@param queued if the allocation can be queued&lt;/li&gt;
	&lt;li&gt;@param locationPreferenceConstraint constraint for the location preferences&lt;br/&gt;
+	 * @param allPreviousExecutionGraphAllocationIds the allocation ids of all previous executions in the execution job graph.&lt;/li&gt;
	&lt;li&gt;@param allocationTimeout timeout for allocating the individual slots&lt;br/&gt;
 	 */&lt;br/&gt;
 	public Collection&amp;lt;CompletableFuture&amp;lt;Execution&amp;gt;&amp;gt; allocateResourcesForAll(&lt;br/&gt;
 			SlotProvider resourceProvider,&lt;br/&gt;
 			boolean queued,&lt;br/&gt;
 			LocationPreferenceConstraint locationPreferenceConstraint,&lt;br/&gt;
+			@Nonnull Set&amp;lt;AllocationID&amp;gt; allPreviousExecutionGraphAllocationIds,&lt;br/&gt;
 			Time allocationTimeout) 
{
 		final ExecutionVertex[] vertices = this.taskVertices;
 		final CompletableFuture&amp;lt;Execution&amp;gt;[] slots = new CompletableFuture[vertices.length];
@@ -522,6 +534,7 @@ public void connectToPredecessors(Map&amp;lt;IntermediateDataSetID, IntermediateResult&amp;gt;
 				resourceProvider,
 				queued,
 				locationPreferenceConstraint,
+				allPreviousExecutionGraphAllocationIds,
 				allocationTimeout);
 			slots[i] = allocationFuture;
 		}
&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java&lt;br/&gt;
index e4228011830..a0747296c53 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java&lt;br/&gt;
@@ -56,6 +56,7 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import org.slf4j.Logger;&lt;/p&gt;

&lt;p&gt;+import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.io.IOException;&lt;br/&gt;
@@ -617,17 +618,21 @@ public Execution resetForNewExecution(final long timestamp, final long originati&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param slotProvider to allocate the slots from&lt;/li&gt;
	&lt;li&gt;@param queued if the allocation can be queued&lt;/li&gt;
	&lt;li&gt;@param locationPreferenceConstraint constraint for the location preferences&lt;br/&gt;
+	 * @param allPreviousExecutionGraphAllocationIds set with all previous allocation ids in the job graph.&lt;br/&gt;
+	 *                                                 Can be empty if the allocation ids are not required for scheduling.&lt;/li&gt;
	&lt;li&gt;@return Future which is completed once the execution is deployed. The future&lt;/li&gt;
	&lt;li&gt;can also completed exceptionally.&lt;br/&gt;
 	 */&lt;br/&gt;
 	public CompletableFuture&amp;lt;Void&amp;gt; scheduleForExecution(&lt;br/&gt;
 			SlotProvider slotProvider,&lt;br/&gt;
 			boolean queued,&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LocationPreferenceConstraint locationPreferenceConstraint) {&lt;br/&gt;
+			LocationPreferenceConstraint locationPreferenceConstraint,&lt;br/&gt;
+			@Nonnull Set&amp;lt;AllocationID&amp;gt; allPreviousExecutionGraphAllocationIds) 
{
 		return this.currentExecution.scheduleForExecution(
 			slotProvider,
 			queued,
-			locationPreferenceConstraint);
+			locationPreferenceConstraint,
+			allPreviousExecutionGraphAllocationIds);
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	@VisibleForTesting&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/FailoverRegion.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/FailoverRegion.java&lt;br/&gt;
index 0b00c0e039d..f3ba48e75ab 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/FailoverRegion.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/FailoverRegion.java&lt;br/&gt;
@@ -18,6 +18,7 @@&lt;/p&gt;

&lt;p&gt; package org.apache.flink.runtime.executiongraph.failover;&lt;/p&gt;

&lt;p&gt;+import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
 import org.apache.flink.runtime.concurrent.FutureUtils;&lt;br/&gt;
 import org.apache.flink.runtime.executiongraph.Execution;&lt;br/&gt;
 import org.apache.flink.runtime.executiongraph.ExecutionGraph;&lt;br/&gt;
@@ -212,6 +213,15 @@ private void restart(long globalModVersionOfFailover) &lt;/p&gt;
{
 							connectedExecutionVertexes, false, false);
 				}
&lt;p&gt; 				*/&lt;br/&gt;
+&lt;br/&gt;
+				HashSet&amp;lt;AllocationID&amp;gt; previousAllocationsInRegion = new HashSet&amp;lt;&amp;gt;(connectedExecutionVertexes.size());&lt;br/&gt;
+				for (ExecutionVertex connectedExecutionVertex : connectedExecutionVertexes) {&lt;br/&gt;
+					AllocationID latestPriorAllocation = connectedExecutionVertex.getLatestPriorAllocation();&lt;br/&gt;
+					if (latestPriorAllocation != null) &lt;/p&gt;
{
+						previousAllocationsInRegion.add(latestPriorAllocation);
+					}
&lt;p&gt;+				}&lt;br/&gt;
+&lt;br/&gt;
 				//TODO, use restart strategy to schedule them.&lt;br/&gt;
 				//restart all connected ExecutionVertexes&lt;br/&gt;
 				for (ExecutionVertex ev : connectedExecutionVertexes) {&lt;br/&gt;
@@ -219,7 +229,8 @@ private void restart(long globalModVersionOfFailover) &lt;/p&gt;
{
 						ev.scheduleForExecution(
 							executionGraph.getSlotProvider(),
 							executionGraph.isQueuedSchedulingAllowed(),
-							LocationPreferenceConstraint.ANY); // some inputs not belonging to the failover region might have failed concurrently
+							LocationPreferenceConstraint.ANY,
+							previousAllocationsInRegion); // some inputs not belonging to the failover region might have failed concurrently
 					}
&lt;p&gt; 					catch (Throwable e) {&lt;br/&gt;
 						failover(globalModVersionOfFailover);&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/instance/SimpleSlotContext.java b/flink-runtime/src/main/java/org/apache/flink/runtime/instance/SimpleSlotContext.java&lt;br/&gt;
index 95dd1f6f9e6..282fd2ccf4e 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/instance/SimpleSlotContext.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/instance/SimpleSlotContext.java&lt;br/&gt;
@@ -19,8 +19,8 @@&lt;br/&gt;
 package org.apache.flink.runtime.instance;&lt;/p&gt;

&lt;p&gt; import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
-import org.apache.flink.runtime.jobmaster.SlotContext;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;&lt;br/&gt;
+import org.apache.flink.runtime.jobmaster.SlotContext;&lt;br/&gt;
 import org.apache.flink.runtime.taskmanager.TaskManagerLocation;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;/p&gt;

&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotContext.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotContext.java&lt;br/&gt;
index 38781676842..8777edd2fe7 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotContext.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotContext.java&lt;br/&gt;
@@ -18,37 +18,14 @@&lt;/p&gt;

&lt;p&gt; package org.apache.flink.runtime.jobmaster;&lt;/p&gt;

&lt;p&gt;-import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;&lt;br/&gt;
-import org.apache.flink.runtime.taskmanager.TaskManagerLocation;&lt;/p&gt;

&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Interface for the context of a 
{@link LogicalSlot}
&lt;p&gt;. This context contains information&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;about the underlying allocated slot and how to communicate with the TaskManager on which&lt;/li&gt;
	&lt;li&gt;it was allocated.&lt;br/&gt;
  */&lt;br/&gt;
-public interface SlotContext {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Gets the id under which the slot has been allocated on the TaskManager. This id uniquely identifies the&lt;/li&gt;
	&lt;li&gt;* physical slot.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @return The id under which the slot has been allocated on the TaskManager&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;AllocationID getAllocationId();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Gets the location info of the TaskManager that offers this slot.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @return The location info of the TaskManager that offers this slot&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;TaskManagerLocation getTaskManagerLocation();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Gets the number of the slot.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @return The number of the slot on the TaskManager.&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;int getPhysicalSlotNumber();&lt;br/&gt;
+public interface SlotContext extends SlotInfo {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Gets the actor gateway that can be used to send messages to the TaskManager.&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotInfo.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotInfo.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..fd33aacfd6c
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;/dev/null&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/SlotInfo.java&lt;br/&gt;
@@ -0,0 +1,50 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.jobmaster;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Interface that provides basic information in the context of a slot.&lt;br/&gt;
+ */&lt;br/&gt;
+public interface SlotInfo 
{
+
+	/**
+	 * Gets the id under which the slot has been allocated on the TaskManager. This id uniquely identifies the
+	 * physical slot.
+	 *
+	 * @return The id under which the slot has been allocated on the TaskManager
+	 */
+	AllocationID getAllocationId();
+
+	/**
+	 * Gets the location info of the TaskManager that offers this slot.
+	 *
+	 * @return The location info of the TaskManager that offers this slot
+	 */
+	TaskManagerLocation getTaskManagerLocation();
+
+	/**
+	 * Gets the number of the slot.
+	 *
+	 * @return The number of the slot on the TaskManager.
+	 */
+	int getPhysicalSlotNumber();
+}
&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AllocatedSlot.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AllocatedSlot.java&lt;br/&gt;
index 75195cd9378..e4e583c09d6 100644&lt;/p&gt;&lt;/li&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AllocatedSlot.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AllocatedSlot.java&lt;br/&gt;
@@ -92,6 +92,7 @@ public SlotID getSlotId() {&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@return The ID under which the slot is allocated&lt;br/&gt;
 	 */&lt;br/&gt;
+	@Override&lt;br/&gt;
 	public AllocationID getAllocationId() 
{
 		return allocationId;
 	}
&lt;p&gt;@@ -121,6 +122,7 @@ public ResourceProfile getResourceProfile() {&lt;br/&gt;
 	 *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@return The location info of the TaskManager that offers this slot&lt;br/&gt;
 	 */&lt;br/&gt;
+	@Override&lt;br/&gt;
 	public TaskManagerLocation getTaskManagerLocation() 
{
 		return taskManagerLocation;
 	}
&lt;p&gt;@@ -132,6 +134,7 @@ public TaskManagerLocation getTaskManagerLocation() {&lt;br/&gt;
 	 *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@return The actor gateway that can be used to send messages to the TaskManager.&lt;br/&gt;
 	 */&lt;br/&gt;
+	@Override&lt;br/&gt;
 	public TaskManagerGateway getTaskManagerGateway() 
{
 		return taskManagerGateway;
 	}
&lt;p&gt;@@ -142,6 +145,7 @@ public TaskManagerGateway getTaskManagerGateway() {&lt;br/&gt;
 	 *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@return Physical slot number of the allocated slot&lt;br/&gt;
 	 */&lt;br/&gt;
+	@Override&lt;br/&gt;
 	public int getPhysicalSlotNumber() 
{
 		return physicalSlotNumber;
 	}
&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/LocationPreferenceSchedulingStrategy.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/LocationPreferenceSchedulingStrategy.java&lt;br/&gt;
index 25e884c32dd..bc90be65ac5 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/LocationPreferenceSchedulingStrategy.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/LocationPreferenceSchedulingStrategy.java&lt;br/&gt;
@@ -21,7 +21,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.types.SlotProfile;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.scheduler.Locality;&lt;br/&gt;
-import org.apache.flink.runtime.jobmaster.SlotContext;&lt;br/&gt;
+import org.apache.flink.runtime.jobmaster.SlotInfo;&lt;br/&gt;
 import org.apache.flink.runtime.taskmanager.TaskManagerLocation;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
@@ -34,6 +34,7 @@&lt;br/&gt;
 import java.util.function.BiFunction;&lt;br/&gt;
 import java.util.function.Function;&lt;br/&gt;
 import java.util.function.Predicate;&lt;br/&gt;
+import java.util.function.Supplier;&lt;br/&gt;
 import java.util.stream.Stream;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -54,11 +55,26 @@&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public &amp;lt;IN, OUT&amp;gt; OUT findMatchWithLocality(&lt;br/&gt;
 			@Nonnull SlotProfile slotProfile,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Nonnull Stream&amp;lt;IN&amp;gt; candidates,&lt;/li&gt;
	&lt;li&gt;@Nonnull Function&amp;lt;IN, SlotContext&amp;gt; contextExtractor,&lt;br/&gt;
+			@Nonnull Supplier&amp;lt;Stream&amp;lt;IN&amp;gt;&amp;gt; candidates,&lt;br/&gt;
+			@Nonnull Function&amp;lt;IN, SlotInfo&amp;gt; contextExtractor,&lt;br/&gt;
 			@Nonnull Predicate&amp;lt;IN&amp;gt; additionalRequirementsFilter,&lt;br/&gt;
 			@Nonnull BiFunction&amp;lt;IN, Locality, OUT&amp;gt; resultProducer) 
{
 
+		return doFindMatchWithLocality(
+			slotProfile,
+			candidates.get(),
+			contextExtractor,
+			additionalRequirementsFilter,
+			resultProducer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	protected  &amp;lt;IN, OUT&amp;gt; OUT doFindMatchWithLocality(&lt;br/&gt;
+		@Nonnull SlotProfile slotProfile,&lt;br/&gt;
+		@Nonnull Stream&amp;lt;IN&amp;gt; candidates,&lt;br/&gt;
+		@Nonnull Function&amp;lt;IN, SlotInfo&amp;gt; contextExtractor,&lt;br/&gt;
+		@Nonnull Predicate&amp;lt;IN&amp;gt; additionalRequirementsFilter,&lt;br/&gt;
+		@Nonnull BiFunction&amp;lt;IN, Locality, OUT&amp;gt; resultProducer) {&lt;br/&gt;
 		Collection&amp;lt;TaskManagerLocation&amp;gt; locationPreferences = slotProfile.getPreferredLocations();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		// if we have no location preferences, we can only filter by the additional requirements.&lt;br/&gt;
@@ -88,7 +104,7 @@&lt;br/&gt;
 		while (iterator.hasNext()) {&lt;br/&gt;
 			IN candidate = iterator.next();&lt;br/&gt;
 			if (additionalRequirementsFilter.test(candidate)) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;SlotContext slotContext = contextExtractor.apply(candidate);&lt;br/&gt;
+				SlotInfo slotContext = contextExtractor.apply(candidate);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 				// this gets candidate is local-weigh&lt;br/&gt;
 				Integer localWeigh = preferredResourceIDs.getOrDefault(slotContext.getTaskManagerLocation().getResourceID(), 0);&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PreviousAllocationSchedulingStrategy.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PreviousAllocationSchedulingStrategy.java&lt;br/&gt;
index 9b1872ec363..d2193ad7022 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PreviousAllocationSchedulingStrategy.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PreviousAllocationSchedulingStrategy.java&lt;br/&gt;
@@ -21,15 +21,17 @@&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
 import org.apache.flink.runtime.clusterframework.types.SlotProfile;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.scheduler.Locality;&lt;br/&gt;
-import org.apache.flink.runtime.jobmaster.SlotContext;&lt;br/&gt;
+import org.apache.flink.runtime.jobmaster.SlotInfo;&lt;/p&gt;

&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.util.Collection;&lt;br/&gt;
+import java.util.Set;&lt;br/&gt;
 import java.util.function.BiFunction;&lt;br/&gt;
 import java.util.function.Function;&lt;br/&gt;
 import java.util.function.Predicate;&lt;br/&gt;
+import java.util.function.Supplier;&lt;br/&gt;
 import java.util.stream.Stream;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -48,35 +50,68 @@ private PreviousAllocationSchedulingStrategy() {}&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public &amp;lt;IN, OUT&amp;gt; OUT findMatchWithLocality(&lt;br/&gt;
 			@Nonnull SlotProfile slotProfile,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Nonnull Stream&amp;lt;IN&amp;gt; candidates,&lt;/li&gt;
	&lt;li&gt;@Nonnull Function&amp;lt;IN, SlotContext&amp;gt; contextExtractor,&lt;br/&gt;
+			@Nonnull Supplier&amp;lt;Stream&amp;lt;IN&amp;gt;&amp;gt; candidates,&lt;br/&gt;
+			@Nonnull Function&amp;lt;IN, SlotInfo&amp;gt; contextExtractor,&lt;br/&gt;
 			@Nonnull Predicate&amp;lt;IN&amp;gt; additionalRequirementsFilter,&lt;br/&gt;
 			@Nonnull BiFunction&amp;lt;IN, Locality, OUT&amp;gt; resultProducer) {&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Collection&amp;lt;AllocationID&amp;gt; priorAllocations = slotProfile.getPriorAllocations();&lt;br/&gt;
+		Collection&amp;lt;AllocationID&amp;gt; priorAllocations = slotProfile.getPreferredAllocations();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		if (priorAllocations.isEmpty()) &lt;/p&gt;
{
-			return super.findMatchWithLocality(slotProfile, candidates, contextExtractor, additionalRequirementsFilter, resultProducer);
+			return super.findMatchWithLocality(
+				slotProfile,
+				candidates,
+				contextExtractor,
+				additionalRequirementsFilter,
+				resultProducer);
 		}
&lt;p&gt; else &lt;/p&gt;
{
-			return findPreviousAllocation(candidates, contextExtractor, additionalRequirementsFilter, resultProducer, priorAllocations);
+			return findPreviousAllocation(
+				slotProfile,
+				candidates,
+				contextExtractor,
+				additionalRequirementsFilter,
+				resultProducer,
+				priorAllocations);
 		}
&lt;p&gt; 	}&lt;/p&gt;

&lt;p&gt; 	@Nullable&lt;br/&gt;
 	private &amp;lt;IN, OUT&amp;gt; OUT findPreviousAllocation(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Nonnull Stream&amp;lt;IN&amp;gt; candidates,&lt;/li&gt;
	&lt;li&gt;@Nonnull Function&amp;lt;IN, SlotContext&amp;gt; contextExtractor,&lt;br/&gt;
+			@Nonnull SlotProfile slotProfile,&lt;br/&gt;
+			@Nonnull Supplier&amp;lt;Stream&amp;lt;IN&amp;gt;&amp;gt; candidates,&lt;br/&gt;
+			@Nonnull Function&amp;lt;IN, SlotInfo&amp;gt; contextExtractor,&lt;br/&gt;
 			@Nonnull Predicate&amp;lt;IN&amp;gt; additionalRequirementsFilter,&lt;br/&gt;
 			@Nonnull BiFunction&amp;lt;IN, Locality, OUT&amp;gt; resultProducer,&lt;/li&gt;
	&lt;li&gt;Collection&amp;lt;AllocationID&amp;gt; priorAllocations) {&lt;br/&gt;
+			@Nonnull Collection&amp;lt;AllocationID&amp;gt; priorAllocations) {&lt;br/&gt;
+&lt;br/&gt;
 		Predicate&amp;lt;IN&amp;gt; filterByAllocation =&lt;/li&gt;
	&lt;li&gt;(candidate) -&amp;gt; priorAllocations.contains(contextExtractor.apply(candidate).getAllocationId());&lt;br/&gt;
+			(IN candidate) -&amp;gt; priorAllocations.contains(contextExtractor.apply(candidate).getAllocationId());&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return candidates&lt;br/&gt;
+		OUT previousAllocationCandidate = candidates&lt;br/&gt;
+			.get()&lt;br/&gt;
 			.filter(filterByAllocation.and(additionalRequirementsFilter))&lt;br/&gt;
 			.findFirst()&lt;/li&gt;
	&lt;li&gt;.map((result) -&amp;gt; resultProducer.apply(result, Locality.LOCAL)) // TODO introduce special locality?&lt;br/&gt;
+			.map((IN result) -&amp;gt; resultProducer.apply(result, Locality.LOCAL)) // TODO introduce special locality?&lt;br/&gt;
 			.orElse(null);&lt;br/&gt;
+&lt;br/&gt;
+		if (previousAllocationCandidate != null) 
{
+			return previousAllocationCandidate;
+		}
&lt;p&gt;+&lt;br/&gt;
+		Set&amp;lt;AllocationID&amp;gt; blackListedAllocationIDs = slotProfile.getPreviousExecutionGraphAllocations();&lt;br/&gt;
+		Stream&amp;lt;IN&amp;gt; candidateStream = candidates.get();&lt;br/&gt;
+		if (!blackListedAllocationIDs.isEmpty()) &lt;/p&gt;
{
+			candidateStream = candidateStream.filter(
+				(IN candidate) -&amp;gt; !blackListedAllocationIDs.contains(
+					contextExtractor.apply(candidate).getAllocationId()));
+		}
&lt;p&gt;+&lt;br/&gt;
+		return doFindMatchWithLocality(&lt;br/&gt;
+			slotProfile,&lt;br/&gt;
+			candidateStream,&lt;br/&gt;
+			contextExtractor,&lt;br/&gt;
+			additionalRequirementsFilter,&lt;br/&gt;
+			resultProducer);&lt;br/&gt;
 	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	public static PreviousAllocationSchedulingStrategy getInstance() &lt;/p&gt;
{
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SchedulingStrategy.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SchedulingStrategy.java
index fb27a214eff..89b2d05cada 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SchedulingStrategy.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SchedulingStrategy.java
@@ -21,6 +21,7 @@
 import org.apache.flink.runtime.clusterframework.types.SlotProfile;
 import org.apache.flink.runtime.jobmanager.scheduler.Locality;
 import org.apache.flink.runtime.jobmaster.SlotContext;
+import org.apache.flink.runtime.jobmaster.SlotInfo;
 
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
@@ -28,6 +29,7 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 import java.util.function.Predicate;
+import java.util.function.Supplier;
 import java.util.stream.Stream;
 
 /**
@@ -53,8 +55,8 @@
 	@Nullable
 	&amp;lt;IN, OUT&amp;gt; OUT findMatchWithLocality(
 		@Nonnull SlotProfile slotProfile,
-		@Nonnull Stream&amp;lt;IN&amp;gt; candidates,
-		@Nonnull Function&amp;lt;IN, SlotContext&amp;gt; contextExtractor,
+		@Nonnull Supplier&amp;lt;Stream&amp;lt;IN&amp;gt;&amp;gt; candidates,
+		@Nonnull Function&amp;lt;IN, SlotInfo&amp;gt; contextExtractor,
 		@Nonnull Predicate&amp;lt;IN&amp;gt; additionalRequirementsFilter,
 		@Nonnull BiFunction&amp;lt;IN, Locality, OUT&amp;gt; resultProducer);
 }
&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java&lt;br/&gt;
index 13f0462455c..fdf0fa9e485 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java&lt;br/&gt;
@@ -54,6 +54,7 @@&lt;br/&gt;
 import org.apache.flink.util.FlinkException;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;/p&gt;

&lt;p&gt;+import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.util.ArrayList;&lt;br/&gt;
@@ -170,7 +171,9 @@ public SlotPool(&lt;br/&gt;
 		this.pendingRequests = new DualKeyMap&amp;lt;&amp;gt;(16);&lt;br/&gt;
 		this.waitingForResourceManager = new HashMap&amp;lt;&amp;gt;(16);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.providerAndOwner = new ProviderAndOwner(getSelfGateway(SlotPoolGateway.class));&lt;br/&gt;
+		this.providerAndOwner = new ProviderAndOwner(&lt;br/&gt;
+			getSelfGateway(SlotPoolGateway.class),&lt;br/&gt;
+			schedulingStrategy instanceof PreviousAllocationSchedulingStrategy);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		this.slotSharingManagers = new HashMap&amp;lt;&amp;gt;(4);&lt;/p&gt;

&lt;p&gt;@@ -325,76 +328,93 @@ public void disconnectResourceManager() {&lt;/p&gt;

&lt;p&gt; 		log.debug(&quot;Received slot request &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt; for task: {}&quot;, slotRequestId, task.getTaskToExecute());&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final SlotSharingGroupId slotSharingGroupId = task.getSlotSharingGroupId();&lt;br/&gt;
+		if (task.getSlotSharingGroupId() == null) 
{
+			return allocateSingleSlot(slotRequestId, slotProfile, allowQueuedScheduling, allocationTimeout);
+		}
&lt;p&gt; else &lt;/p&gt;
{
+			return allocateSharedSlot(slotRequestId, task, slotProfile, allowQueuedScheduling, allocationTimeout);
+		}
&lt;p&gt;+	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (slotSharingGroupId != null) {&lt;/li&gt;
	&lt;li&gt;// allocate slot with slot sharing&lt;/li&gt;
	&lt;li&gt;final SlotSharingManager multiTaskSlotManager = slotSharingManagers.computeIfAbsent(&lt;/li&gt;
	&lt;li&gt;slotSharingGroupId,&lt;/li&gt;
	&lt;li&gt;id -&amp;gt; new SlotSharingManager(&lt;/li&gt;
	&lt;li&gt;id,&lt;/li&gt;
	&lt;li&gt;this,&lt;/li&gt;
	&lt;li&gt;providerAndOwner));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;if (task.getCoLocationConstraint() != null) {&lt;/li&gt;
	&lt;li&gt;multiTaskSlotLocality = allocateCoLocatedMultiTaskSlot(&lt;/li&gt;
	&lt;li&gt;task.getCoLocationConstraint(),&lt;/li&gt;
	&lt;li&gt;multiTaskSlotManager,&lt;/li&gt;
	&lt;li&gt;slotProfile,&lt;/li&gt;
	&lt;li&gt;allowQueuedScheduling,&lt;/li&gt;
	&lt;li&gt;allocationTimeout);&lt;br/&gt;
+	private CompletableFuture&amp;lt;LogicalSlot&amp;gt; allocateSingleSlot(&lt;br/&gt;
+		SlotRequestId slotRequestId,&lt;br/&gt;
+		SlotProfile slotProfile,&lt;br/&gt;
+		boolean allowQueuedScheduling,&lt;br/&gt;
+		Time allocationTimeout) {&lt;br/&gt;
+		// request an allocated slot to assign a single logical slot to&lt;br/&gt;
+		CompletableFuture&amp;lt;SlotAndLocality&amp;gt; slotAndLocalityFuture = requestAllocatedSlot(&lt;br/&gt;
+			slotRequestId,&lt;br/&gt;
+			slotProfile,&lt;br/&gt;
+			allowQueuedScheduling,&lt;br/&gt;
+			allocationTimeout);&lt;br/&gt;
+&lt;br/&gt;
+		return slotAndLocalityFuture.thenApply(&lt;br/&gt;
+			(SlotAndLocality slotAndLocality) -&amp;gt; {&lt;br/&gt;
+				final AllocatedSlot allocatedSlot = slotAndLocality.getSlot();&lt;br/&gt;
+&lt;br/&gt;
+				final SingleLogicalSlot singleTaskSlot = new SingleLogicalSlot(&lt;br/&gt;
+					slotRequestId,&lt;br/&gt;
+					allocatedSlot,&lt;br/&gt;
+					null,&lt;br/&gt;
+					slotAndLocality.getLocality(),&lt;br/&gt;
+					providerAndOwner);&lt;br/&gt;
+&lt;br/&gt;
+				if (allocatedSlot.tryAssignPayload(singleTaskSlot)) 
{
+					return singleTaskSlot;
 				}
&lt;p&gt; else &lt;/p&gt;
{
-					multiTaskSlotLocality = allocateMultiTaskSlot(
-						task.getJobVertexId(),
-						multiTaskSlotManager,
-						slotProfile,
-						allowQueuedScheduling,
-						allocationTimeout);
+					final FlinkException flinkException =
+						new FlinkException(&quot;Could not assign payload to allocated slot &quot; + allocatedSlot.getAllocationId() + &apos;.&apos;);
+					releaseSingleSlot(slotRequestId, flinkException);
+					throw new CompletionException(flinkException);
 				}&lt;/li&gt;
	&lt;li&gt;} catch (NoResourceAvailableException noResourceException) 
{
-				return FutureUtils.completedExceptionally(noResourceException);
-			}
&lt;p&gt;+			});&lt;br/&gt;
+	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// sanity check&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(!multiTaskSlotLocality.getMultiTaskSlot().contains(task.getJobVertexId()));&lt;br/&gt;
+	private CompletableFuture&amp;lt;LogicalSlot&amp;gt; allocateSharedSlot(&lt;br/&gt;
+		SlotRequestId slotRequestId,&lt;br/&gt;
+		ScheduledUnit task,&lt;br/&gt;
+		SlotProfile slotProfile,&lt;br/&gt;
+		boolean allowQueuedScheduling,&lt;br/&gt;
+		Time allocationTimeout) 
{
 
-			final SlotSharingManager.SingleTaskSlot leaf = multiTaskSlotLocality.getMultiTaskSlot().allocateSingleTaskSlot(
-				slotRequestId,
-				task.getJobVertexId(),
-				multiTaskSlotLocality.getLocality());
+		// allocate slot with slot sharing
+		final SlotSharingManager multiTaskSlotManager = slotSharingManagers.computeIfAbsent(
+			task.getSlotSharingGroupId(),
+			id -&amp;gt; new SlotSharingManager(
+				id,
+				this,
+				providerAndOwner));
 
-			return leaf.getLogicalSlotFuture();
-		}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// request an allocated slot to assign a single logical slot to&lt;/li&gt;
	&lt;li&gt;CompletableFuture&amp;lt;SlotAndLocality&amp;gt; slotAndLocalityFuture = requestAllocatedSlot(&lt;/li&gt;
	&lt;li&gt;slotRequestId,&lt;/li&gt;
	&lt;li&gt;slotProfile,&lt;/li&gt;
	&lt;li&gt;allowQueuedScheduling,&lt;/li&gt;
	&lt;li&gt;allocationTimeout);&lt;br/&gt;
+		final SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return slotAndLocalityFuture.thenApply(&lt;/li&gt;
	&lt;li&gt;(SlotAndLocality slotAndLocality) -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;final AllocatedSlot allocatedSlot = slotAndLocality.getSlot();&lt;br/&gt;
+		try 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			if (task.getCoLocationConstraint() != null) {
+				multiTaskSlotLocality = allocateCoLocatedMultiTaskSlot(
+					task.getCoLocationConstraint(),
+					multiTaskSlotManager,
+					slotProfile,
+					allowQueuedScheduling,
+					allocationTimeout);
+			} else {
+				multiTaskSlotLocality = allocateMultiTaskSlot(
+					task.getJobVertexId(),
+					multiTaskSlotManager,
+					slotProfile,
+					allowQueuedScheduling,
+					allocationTimeout);
+			}+		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; catch (NoResourceAvailableException noResourceException) &lt;/p&gt;
{
+			return FutureUtils.completedExceptionally(noResourceException);
+		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final SingleLogicalSlot singleTaskSlot = new SingleLogicalSlot(&lt;/li&gt;
	&lt;li&gt;slotRequestId,&lt;/li&gt;
	&lt;li&gt;allocatedSlot,&lt;/li&gt;
	&lt;li&gt;null,&lt;/li&gt;
	&lt;li&gt;slotAndLocality.getLocality(),&lt;/li&gt;
	&lt;li&gt;providerAndOwner);&lt;br/&gt;
+		// sanity check&lt;br/&gt;
+		Preconditions.checkState(!multiTaskSlotLocality.getMultiTaskSlot().contains(task.getJobVertexId()));&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (allocatedSlot.tryAssignPayload(singleTaskSlot)) 
{
-						return singleTaskSlot;
-					}
&lt;p&gt; else &lt;/p&gt;
{
-						final FlinkException flinkException = new FlinkException(&quot;Could not assign payload to allocated slot &quot; + allocatedSlot.getAllocationId() + &apos;.&apos;);
-						releaseSlot(slotRequestId, null, flinkException);
-						throw new CompletionException(flinkException);
-					}&lt;/li&gt;
	&lt;li&gt;});&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
+		final SlotSharingManager.SingleTaskSlot leaf = multiTaskSlotLocality.getMultiTaskSlot().allocateSingleTaskSlot(&lt;br/&gt;
+			slotRequestId,&lt;br/&gt;
+			task.getJobVertexId(),&lt;br/&gt;
+			multiTaskSlotLocality.getLocality());&lt;br/&gt;
+&lt;br/&gt;
+		return leaf.getLogicalSlotFuture();&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;br/&gt;
@@ -438,12 +458,13 @@ public void disconnectResourceManager() &lt;/p&gt;
{
 			slotProfile = new SlotProfile(
 				slotProfile.getResourceProfile(),
 				Collections.singleton(coLocationConstraint.getLocation()),
-				slotProfile.getPriorAllocations());
+				slotProfile.getPreferredAllocations());
 		}

&lt;p&gt; 		// get a new multi task slot&lt;br/&gt;
 		final SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality = allocateMultiTaskSlot(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;coLocationConstraint.getGroupId(), multiTaskSlotManager,&lt;br/&gt;
+			coLocationConstraint.getGroupId(),&lt;br/&gt;
+			multiTaskSlotManager,&lt;br/&gt;
 			slotProfile,&lt;br/&gt;
 			allowQueuedScheduling,&lt;br/&gt;
 			allocationTimeout);&lt;br/&gt;
@@ -548,9 +569,8 @@ public void disconnectResourceManager() {&lt;br/&gt;
 		if (multiTaskSlotLocality != null) {&lt;br/&gt;
 			// prefer slot sharing group slots over unused slots&lt;br/&gt;
 			if (polledSlotAndLocality != null) 
{
-				releaseSlot(
+				releaseSingleSlot(
 					allocatedSlotRequestId,
-					null,
 					new FlinkException(&quot;Locality constraint is not better fulfilled by allocated slot.&quot;));
 			}
&lt;p&gt; 			return multiTaskSlotLocality;&lt;br/&gt;
@@ -587,9 +607,8 @@ public void disconnectResourceManager() {&lt;br/&gt;
 								}&lt;br/&gt;
 							}&lt;br/&gt;
 						} else &lt;/p&gt;
{
-							releaseSlot(
+							releaseSingleSlot(
 								allocatedSlotRequestId,
-								null,
 								new FlinkException(&quot;Could not find task slot with &quot; + multiTaskSlotRequestId + &apos;.&apos;));
 						}
&lt;p&gt; 					});&lt;br/&gt;
@@ -741,41 +760,56 @@ private void stashRequestWaitingForResourceManager(final PendingRequest pendingR&lt;br/&gt;
 	// ------------------------------------------------------------------------&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public CompletableFuture&amp;lt;Acknowledge&amp;gt; releaseSlot(SlotRequestId slotRequestId, @Nullable SlotSharingGroupId slotSharingGroupId, Throwable cause) {&lt;br/&gt;
+	public CompletableFuture&amp;lt;Acknowledge&amp;gt; releaseSlot(&lt;br/&gt;
+		SlotRequestId slotRequestId,&lt;br/&gt;
+		@Nullable SlotSharingGroupId slotSharingGroupId,&lt;br/&gt;
+		Throwable cause) {&lt;br/&gt;
+&lt;br/&gt;
 		log.debug(&quot;Releasing slot &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt; because: {}&quot;, slotRequestId, cause != null ? cause.getMessage() : &quot;null&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		if (slotSharingGroupId != null) &lt;/p&gt;
{
-			final SlotSharingManager multiTaskSlotManager = slotSharingManagers.get(slotSharingGroupId);
+			releaseSharedSlot(slotRequestId, slotSharingGroupId, cause);
+		}
&lt;p&gt; else &lt;/p&gt;
{
+			releaseSingleSlot(slotRequestId, cause);
+		}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (multiTaskSlotManager != null) 
{
-				final SlotSharingManager.TaskSlot taskSlot = multiTaskSlotManager.getTaskSlot(slotRequestId);
+		return CompletableFuture.completedFuture(Acknowledge.get());
+	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (taskSlot != null) 
{
-					taskSlot.release(cause);
-				}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;log.debug(&quot;Could not find slot &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt; in slot sharing group {}. Ignoring release slot request.&quot;, slotRequestId, slotSharingGroupId);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
+	private void releaseSharedSlot(&lt;br/&gt;
+		SlotRequestId slotRequestId,&lt;br/&gt;
+		@Nonnull SlotSharingGroupId slotSharingGroupId, Throwable cause) {&lt;br/&gt;
+&lt;br/&gt;
+		final SlotSharingManager multiTaskSlotManager = slotSharingManagers.get(slotSharingGroupId);&lt;br/&gt;
+&lt;br/&gt;
+		if (multiTaskSlotManager != null) {&lt;br/&gt;
+			final SlotSharingManager.TaskSlot taskSlot = multiTaskSlotManager.getTaskSlot(slotRequestId);&lt;br/&gt;
+&lt;br/&gt;
+			if (taskSlot != null) 
{
+				taskSlot.release(cause);
 			}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;log.debug(&quot;Could not find slot sharing group {}. Ignoring release slot request.&quot;, slotSharingGroupId);&lt;br/&gt;
+				log.debug(&quot;Could not find slot &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt; in slot sharing group {}. Ignoring release slot request.&quot;, slotRequestId, slotSharingGroupId);&lt;br/&gt;
 			}&lt;br/&gt;
 		} else {&lt;/li&gt;
	&lt;li&gt;final PendingRequest pendingRequest = removePendingRequest(slotRequestId);&lt;br/&gt;
+			log.debug(&quot;Could not find slot sharing group {}. Ignoring release slot request.&quot;, slotSharingGroupId);&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (pendingRequest != null) 
{
-				failPendingRequest(pendingRequest, new FlinkException(&quot;Pending slot request with &quot; + slotRequestId + &quot; has been released.&quot;));
-			}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;final AllocatedSlot allocatedSlot = allocatedSlots.remove(slotRequestId);&lt;br/&gt;
+	private void releaseSingleSlot(SlotRequestId slotRequestId, Throwable cause) {&lt;br/&gt;
+		final PendingRequest pendingRequest = removePendingRequest(slotRequestId);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (allocatedSlot != null) 
{
-					allocatedSlot.releasePayload(cause);
-					tryFulfillSlotRequestOrMakeAvailable(allocatedSlot);
-				}
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;log.debug(&quot;There is no allocated slot &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt;. Ignoring the release slot request.&quot;, slotRequestId);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
+		if (pendingRequest != null) 
{
+			failPendingRequest(pendingRequest, new FlinkException(&quot;Pending slot request with &quot; + slotRequestId + &quot; has been released.&quot;));
+		}
&lt;p&gt; else {&lt;br/&gt;
+			final AllocatedSlot allocatedSlot = allocatedSlots.remove(slotRequestId);&lt;br/&gt;
+&lt;br/&gt;
+			if (allocatedSlot != null) &lt;/p&gt;
{
+				allocatedSlot.releasePayload(cause);
+				tryFulfillSlotRequestOrMakeAvailable(allocatedSlot);
+			}
&lt;p&gt; else {&lt;br/&gt;
+				log.debug(&quot;There is no allocated slot &lt;span class=&quot;error&quot;&gt;&amp;#91;{}&amp;#93;&lt;/span&gt;. Ignoring the release slot request.&quot;, slotRequestId);&lt;br/&gt;
 			}&lt;br/&gt;
 		}&lt;br/&gt;
-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;return CompletableFuture.completedFuture(Acknowledge.get());&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;br/&gt;
@@ -875,17 +909,13 @@ private PendingRequest pollMatchingPendingRequest(final AllocatedSlot slot) {&lt;br/&gt;
 		validateRunsInMainThread();&lt;/p&gt;

&lt;p&gt; 		List&amp;lt;CompletableFuture&amp;lt;Optional&amp;lt;SlotOffer&amp;gt;&amp;gt;&amp;gt; acceptedSlotOffers = offers.stream().map(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;offer -&amp;gt; 
{
-				CompletableFuture&amp;lt;Optional&amp;lt;SlotOffer&amp;gt;&amp;gt; acceptedSlotOffer = offerSlot(
-						taskManagerLocation,
-						taskManagerGateway,
-						offer)
-					.thenApply(
-						(acceptedSlot) -&amp;gt; acceptedSlot ? Optional.of(offer) : Optional.empty()
-					);
-
-				return acceptedSlotOffer;
-			}
&lt;p&gt;+			offer -&amp;gt; offerSlot(&lt;br/&gt;
+					taskManagerLocation,&lt;br/&gt;
+					taskManagerGateway,&lt;br/&gt;
+					offer)&lt;br/&gt;
+				.&amp;lt;Optional&amp;lt;SlotOffer&amp;gt;&amp;gt;thenApply(&lt;br/&gt;
+					(acceptedSlot) -&amp;gt; acceptedSlot ? Optional.of(offer) : Optional.empty()&lt;br/&gt;
+				)&lt;br/&gt;
 		).collect(Collectors.toList());&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		CompletableFuture&amp;lt;Collection&amp;lt;Optional&amp;lt;SlotOffer&amp;gt;&amp;gt;&amp;gt; optionalSlotOffers = FutureUtils.combineAll(acceptedSlotOffers);&lt;br/&gt;
@@ -1359,11 +1389,7 @@ int size() {&lt;/p&gt;

&lt;p&gt; 		@VisibleForTesting&lt;br/&gt;
 		Set&amp;lt;AllocatedSlot&amp;gt; getSlotsForTaskManager(ResourceID resourceId) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (allocatedSlotsByTaskManager.containsKey(resourceId)) 
{
-				return allocatedSlotsByTaskManager.get(resourceId);
-			}
&lt;p&gt; else &lt;/p&gt;
{
-				return Collections.emptySet();
-			}
&lt;p&gt;+			return allocatedSlotsByTaskManager.getOrDefault(resourceId, Collections.emptySet());&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -1404,18 +1430,12 @@ void add(final AllocatedSlot slot, final long timestamp) {&lt;br/&gt;
 				final ResourceID resourceID = slot.getTaskManagerLocation().getResourceID();&lt;br/&gt;
 				final String host = slot.getTaskManagerLocation().getFQDNHostname();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Set&amp;lt;AllocatedSlot&amp;gt; slotsForTaskManager = availableSlotsByTaskManager.get(resourceID);&lt;/li&gt;
	&lt;li&gt;if (slotsForTaskManager == null) 
{
-					slotsForTaskManager = new HashSet&amp;lt;&amp;gt;();
-					availableSlotsByTaskManager.put(resourceID, slotsForTaskManager);
-				}
&lt;p&gt;+				Set&amp;lt;AllocatedSlot&amp;gt; slotsForTaskManager =&lt;br/&gt;
+					availableSlotsByTaskManager.computeIfAbsent(resourceID, k -&amp;gt; new HashSet&amp;lt;&amp;gt;());&lt;br/&gt;
 				slotsForTaskManager.add(slot);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Set&amp;lt;AllocatedSlot&amp;gt; slotsForHost = availableSlotsByHost.get(host);&lt;/li&gt;
	&lt;li&gt;if (slotsForHost == null) 
{
-					slotsForHost = new HashSet&amp;lt;&amp;gt;();
-					availableSlotsByHost.put(host, slotsForHost);
-				}
&lt;p&gt;+				Set&amp;lt;AllocatedSlot&amp;gt; slotsForHost =&lt;br/&gt;
+					availableSlotsByHost.computeIfAbsent(host, k -&amp;gt; new HashSet&amp;lt;&amp;gt;());&lt;br/&gt;
 				slotsForHost.add(slot);&lt;br/&gt;
 			}&lt;br/&gt;
 			else {&lt;br/&gt;
@@ -1456,7 +1476,7 @@ SlotAndLocality poll(SchedulingStrategy schedulingStrategy, SlotProfile slotProf&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			SlotAndLocality matchingSlotAndLocality = schedulingStrategy.findMatchWithLocality(&lt;br/&gt;
 				slotProfile,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;slotAndTimestamps.stream(),&lt;br/&gt;
+				slotAndTimestamps::stream,&lt;br/&gt;
 				SlotAndTimestamp::slot,&lt;br/&gt;
 				(SlotAndTimestamp slot) -&amp;gt; slot.slot().getResourceProfile().isMatching(slotProfile.getResourceProfile()),&lt;br/&gt;
 				(SlotAndTimestamp slotAndTimestamp, Locality locality) -&amp;gt; {&lt;br/&gt;
@@ -1563,12 +1583,18 @@ void clear() {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;An implementation of the 
{@link SlotOwner}
&lt;p&gt; and &lt;/p&gt;
{@link SlotProvider}
&lt;p&gt; interfaces&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;that delegates methods as RPC calls to the SlotPool&apos;s RPC gateway.&lt;br/&gt;
 	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static class ProviderAndOwner implements SlotOwner, SlotProvider {&lt;br/&gt;
+	public static class ProviderAndOwner implements SlotOwner, SlotProvider {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		private final SlotPoolGateway gateway;&lt;br/&gt;
+		private final boolean requiresPreviousAllocationsForScheduling;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ProviderAndOwner(SlotPoolGateway gateway) {&lt;br/&gt;
+		ProviderAndOwner(SlotPoolGateway gateway, boolean requiresPreviousAllocationsForScheduling) 
{
 			this.gateway = gateway;
+			this.requiresPreviousAllocationsForScheduling = requiresPreviousAllocationsForScheduling;
+		}
&lt;p&gt;+&lt;br/&gt;
+		public boolean requiresPreviousAllocationsForScheduling() &lt;/p&gt;
{
+			return requiresPreviousAllocationsForScheduling;
 		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		@Override&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManager.java&lt;br/&gt;
index afcd24f1064..80c2dd2d708 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManager.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManager.java&lt;br/&gt;
@@ -197,7 +197,7 @@ MultiTaskSlotLocality getResolvedRootSlot(AbstractID groupId, SchedulingStrategy&lt;br/&gt;
 			Collection&amp;lt;Set&amp;lt;MultiTaskSlot&amp;gt;&amp;gt; resolvedRootSlotsValues = this.resolvedRootSlots.values();&lt;br/&gt;
 			return matcher.findMatchWithLocality(&lt;br/&gt;
 				slotProfile,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;resolvedRootSlotsValues.stream().flatMap(Collection::stream),&lt;br/&gt;
+				() -&amp;gt;resolvedRootSlotsValues.stream().flatMap(Collection::stream),&lt;br/&gt;
 				(MultiTaskSlot multiTaskSlot) -&amp;gt; multiTaskSlot.getSlotContextFuture().join(),&lt;br/&gt;
 				(MultiTaskSlot multiTaskSlot) -&amp;gt; !multiTaskSlot.contains(groupId),&lt;br/&gt;
 				MultiTaskSlotLocality::of);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/clusterframework/types/SlotProfileTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/clusterframework/types/SlotProfileTest.java&lt;br/&gt;
index 6a826aa23e1..ee491499b77 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/clusterframework/types/SlotProfileTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/clusterframework/types/SlotProfileTest.java&lt;br/&gt;
@@ -124,18 +124,59 @@ public void matchPreviousAllocationOverridesPreferredLocation() {&lt;br/&gt;
 	}&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	@Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void matchPreviousLocationNotAvailable() {&lt;br/&gt;
+	public void matchPreviousLocationNotAvailableButByLocality() 
{
 
 		SlotProfile slotProfile = new SlotProfile(resourceProfile, Collections.singletonList(tml4), Collections.singletonList(aidX));
 		SlotContext match = runMatching(slotProfile);
 
-		Assert.assertEquals(null, match);
+		Assert.assertEquals(ssc4, match);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void matchPreviousLocationNotAvailableAndAllOthersBlacklisted() &lt;/p&gt;
{
+		HashSet&amp;lt;AllocationID&amp;gt; blacklisted = new HashSet&amp;lt;&amp;gt;(4);
+		blacklisted.add(aid1);
+		blacklisted.add(aid2);
+		blacklisted.add(aid3);
+		blacklisted.add(aid4);
+		SlotProfile slotProfile = new SlotProfile(resourceProfile, Collections.singletonList(tml4), Collections.singletonList(aidX), blacklisted);
+		SlotContext match = runMatching(slotProfile);
+
+		// there should be no valid option left and we expect null as return
+		Assert.assertNull(match);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void matchPreviousLocationNotAvailableAndSomeOthersBlacklisted() &lt;/p&gt;
{
+		HashSet&amp;lt;AllocationID&amp;gt; blacklisted = new HashSet&amp;lt;&amp;gt;(3);
+		blacklisted.add(aid1);
+		blacklisted.add(aid3);
+		blacklisted.add(aid4);
+		SlotProfile slotProfile = new SlotProfile(resourceProfile, Collections.singletonList(tml4), Collections.singletonList(aidX), blacklisted);
+		SlotContext match = runMatching(slotProfile);
+
+		// we expect that the candidate that is not blacklisted is returned
+		Assert.assertEquals(ssc2, match);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void matchPreviousLocationAvailableButAlsoBlacklisted() &lt;/p&gt;
{
+		HashSet&amp;lt;AllocationID&amp;gt; blacklisted = new HashSet&amp;lt;&amp;gt;(4);
+		blacklisted.add(aid1);
+		blacklisted.add(aid2);
+		blacklisted.add(aid3);
+		blacklisted.add(aid4);
+		SlotProfile slotProfile = new SlotProfile(resourceProfile, Collections.singletonList(tml3), Collections.singletonList(aid3), blacklisted);
+		SlotContext match = runMatching(slotProfile);
+
+		// available previous allocation should override blacklisting
+		Assert.assertEquals(ssc3, match);
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	private SlotContext runMatching(SlotProfile slotProfile) {&lt;br/&gt;
 		return schedulingStrategy.findMatchWithLocality(&lt;br/&gt;
 			slotProfile,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;candidates.stream(),&lt;br/&gt;
+			candidates::stream,&lt;br/&gt;
 			(candidate) -&amp;gt; candidate,&lt;br/&gt;
 			(candidate) -&amp;gt; true,&lt;br/&gt;
 			(candidate, locality) -&amp;gt; candidate);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java&lt;br/&gt;
index 56fd7e12369..74724629eea 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java&lt;br/&gt;
@@ -107,6 +107,7 @@ public void testSlotReleaseOnFailedResourceAssignment() throws Exception {&lt;br/&gt;
 			slotProvider,&lt;br/&gt;
 			false,&lt;br/&gt;
 			LocationPreferenceConstraint.ALL,&lt;br/&gt;
+			Collections.emptySet(),&lt;br/&gt;
 			TestingUtils.infiniteTime());&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		assertFalse(allocationFuture.isDone());&lt;br/&gt;
@@ -156,6 +157,7 @@ public void testSlotReleaseOnExecutionCancellationInScheduled() throws Exception&lt;br/&gt;
 			slotProvider,&lt;br/&gt;
 			false,&lt;br/&gt;
 			LocationPreferenceConstraint.ALL,&lt;br/&gt;
+			Collections.emptySet(),&lt;br/&gt;
 			TestingUtils.infiniteTime());&lt;/p&gt;

&lt;p&gt; 		assertTrue(allocationFuture.isDone());&lt;br/&gt;
@@ -205,6 +207,7 @@ public void testSlotReleaseOnExecutionCancellationInRunning() throws Exception {&lt;br/&gt;
 			slotProvider,&lt;br/&gt;
 			false,&lt;br/&gt;
 			LocationPreferenceConstraint.ALL,&lt;br/&gt;
+			Collections.emptySet(),&lt;br/&gt;
 			TestingUtils.infiniteTime());&lt;/p&gt;

&lt;p&gt; 		assertTrue(allocationFuture.isDone());&lt;br/&gt;
@@ -254,6 +257,7 @@ public void testSlotAllocationCancellationWhenExecutionCancelled() throws Except&lt;br/&gt;
 			slotProvider,&lt;br/&gt;
 			false,&lt;br/&gt;
 			LocationPreferenceConstraint.ALL,&lt;br/&gt;
+			Collections.emptySet(),&lt;br/&gt;
 			TestingUtils.infiniteTime());&lt;/p&gt;

&lt;p&gt; 		assertThat(allocationFuture.isDone(), is(false));&lt;br/&gt;
@@ -357,7 +361,7 @@ public void testTerminationFutureIsCompletedAfterSlotRelease() throws Exception&lt;/p&gt;

&lt;p&gt; 		ExecutionVertex executionVertex = executionJobVertex.getTaskVertices()&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;executionVertex.scheduleForExecution(slotProvider, false, LocationPreferenceConstraint.ANY).get();&lt;br/&gt;
+		executionVertex.scheduleForExecution(slotProvider, false, LocationPreferenceConstraint.ANY, Collections.emptySet()).get();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		Execution currentExecutionAttempt = executionVertex.getCurrentExecutionAttempt();&lt;/p&gt;

&lt;p&gt;@@ -417,7 +421,7 @@ public void testTaskRestoreStateIsNulledAfterDeployment() throws Exception &lt;/p&gt;
{
 		assertThat(execution.getTaskRestore(), is(notNullValue()));
 
 		// schedule the execution vertex and wait for its deployment
-		executionVertex.scheduleForExecution(slotProvider, false, LocationPreferenceConstraint.ANY).get();
+		executionVertex.scheduleForExecution(slotProvider, false, LocationPreferenceConstraint.ANY, Collections.emptySet()).get();
 
 		assertThat(execution.getTaskRestore(), is(nullValue()));
 	}
&lt;p&gt;@@ -479,7 +483,8 @@ public void testEagerSchedulingFailureReturnsSlot() throws Exception {&lt;br/&gt;
 			final CompletableFuture&amp;lt;Void&amp;gt; schedulingFuture = execution.scheduleForExecution(&lt;br/&gt;
 				slotProvider,&lt;br/&gt;
 				false,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;LocationPreferenceConstraint.ANY);&lt;br/&gt;
+				LocationPreferenceConstraint.ANY,&lt;br/&gt;
+				Collections.emptySet());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			try {&lt;br/&gt;
 				schedulingFuture.get();&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexCancelTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexCancelTest.java&lt;br/&gt;
index cd613f0f50a..41894767b6a 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexCancelTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexCancelTest.java&lt;br/&gt;
@@ -40,6 +40,7 @@&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt; import java.io.IOException;&lt;br/&gt;
+import java.util.Collections;&lt;/p&gt;

&lt;p&gt; import scala.concurrent.ExecutionContext;&lt;/p&gt;

&lt;p&gt;@@ -454,7 +455,7 @@ public void testScheduleOrDeployAfterCancel() {&lt;br/&gt;
 			// it can occur as the result of races&lt;/p&gt;
 			{
 				Scheduler scheduler = mock(Scheduler.class);
-				vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL);
+				vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL, Collections.emptySet());
 
 				assertEquals(ExecutionState.CANCELED, vertex.getExecutionState());
 			}
&lt;p&gt;@@ -493,7 +494,7 @@ public void testActionsWhileCancelling() &lt;/p&gt;
{
 				setVertexState(vertex, ExecutionState.CANCELING);
 
 				Scheduler scheduler = mock(Scheduler.class);
-				vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL);
+				vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL, Collections.emptySet());
 			}
&lt;p&gt; 			catch (Exception e) {&lt;br/&gt;
 				fail(&quot;should not throw an exception&quot;);&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexSchedulingTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexSchedulingTest.java&lt;br/&gt;
index 51d1827e668..6bfcb7ff5d0 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexSchedulingTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexSchedulingTest.java&lt;br/&gt;
@@ -36,6 +36,7 @@&lt;/p&gt;

&lt;p&gt; import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+import java.util.Collections;&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;/p&gt;

&lt;p&gt; import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.getExecutionVertex;&lt;br/&gt;
@@ -71,7 +72,7 @@ public void testSlotReleasedWhenScheduledImmediately() {&lt;/p&gt;

&lt;p&gt; 			assertEquals(ExecutionState.CREATED, vertex.getExecutionState());&lt;br/&gt;
 			// try to deploy to the slot&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL);&lt;br/&gt;
+			vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL, Collections.emptySet());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			// will have failed&lt;br/&gt;
 			assertEquals(ExecutionState.FAILED, vertex.getExecutionState());&lt;br/&gt;
@@ -103,7 +104,7 @@ public void testSlotReleasedWhenScheduledQueued() {&lt;/p&gt;

&lt;p&gt; 			assertEquals(ExecutionState.CREATED, vertex.getExecutionState());&lt;br/&gt;
 			// try to deploy to the slot&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;vertex.scheduleForExecution(scheduler, true, LocationPreferenceConstraint.ALL);&lt;br/&gt;
+			vertex.scheduleForExecution(scheduler, true, LocationPreferenceConstraint.ALL, Collections.emptySet());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			// future has not yet a slot&lt;br/&gt;
 			assertEquals(ExecutionState.SCHEDULED, vertex.getExecutionState());&lt;br/&gt;
@@ -138,7 +139,7 @@ public void testScheduleToDeploying() &lt;/p&gt;
{
 			assertEquals(ExecutionState.CREATED, vertex.getExecutionState());
 
 			// try to deploy to the slot
-			vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL);
+			vertex.scheduleForExecution(scheduler, false, LocationPreferenceConstraint.ALL, Collections.emptySet());
 			assertEquals(ExecutionState.DEPLOYING, vertex.getExecutionState());
 		}
&lt;p&gt; 		catch (Exception e) {&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/FailoverRegionTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/FailoverRegionTest.java&lt;br/&gt;
index c411393990c..a53debfd0b8 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/FailoverRegionTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/FailoverRegionTest.java&lt;br/&gt;
@@ -49,6 +49,7 @@&lt;/p&gt;

&lt;p&gt; import java.util.ArrayList;&lt;br/&gt;
 import java.util.Arrays;&lt;br/&gt;
+import java.util.Collections;&lt;br/&gt;
 import java.util.Iterator;&lt;br/&gt;
 import java.util.List;&lt;/p&gt;

&lt;p&gt;@@ -157,7 +158,7 @@ public void testMultiRegionsFailover() throws Exception {&lt;/p&gt;

&lt;p&gt; 		assertEquals(JobStatus.RUNNING, strategy.getFailoverRegion(ev11).getState());&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ev21.scheduleForExecution(slotProvider, true, LocationPreferenceConstraint.ALL);&lt;br/&gt;
+		ev21.scheduleForExecution(slotProvider, true, LocationPreferenceConstraint.ALL, Collections.emptySet());&lt;br/&gt;
 		ev21.getCurrentExecutionAttempt().fail(new Exception(&quot;New fail&quot;));&lt;br/&gt;
 		assertEquals(JobStatus.CANCELLING, strategy.getFailoverRegion(ev11).getState());&lt;br/&gt;
 		assertEquals(JobStatus.RUNNING, strategy.getFailoverRegion(ev22).getState());&lt;br/&gt;
@@ -170,7 +171,7 @@ public void testMultiRegionsFailover() throws Exception {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		ev11.getCurrentExecutionAttempt().markFinished();&lt;br/&gt;
 		ev21.getCurrentExecutionAttempt().markFinished();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ev22.scheduleForExecution(slotProvider, true, LocationPreferenceConstraint.ALL);&lt;br/&gt;
+		ev22.scheduleForExecution(slotProvider, true, LocationPreferenceConstraint.ALL, Collections.emptySet());&lt;br/&gt;
 		ev22.getCurrentExecutionAttempt().markFinished();&lt;br/&gt;
 		assertEquals(JobStatus.RUNNING, strategy.getFailoverRegion(ev11).getState());&lt;br/&gt;
 		assertEquals(JobStatus.RUNNING, strategy.getFailoverRegion(ev22).getState());&lt;br/&gt;
diff --git a/flink-tests/src/test/java/org/apache/flink/test/runtime/SchedulingITCase.java b/flink-tests/src/test/java/org/apache/flink/test/runtime/SchedulingITCase.java&lt;br/&gt;
index 0344d71879b..fb28c2c75a4 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-tests/src/test/java/org/apache/flink/test/runtime/SchedulingITCase.java&lt;br/&gt;
+++ b/flink-tests/src/test/java/org/apache/flink/test/runtime/SchedulingITCase.java&lt;br/&gt;
@@ -41,7 +41,6 @@&lt;br/&gt;
 import org.apache.flink.util.FlinkException;&lt;br/&gt;
 import org.apache.flink.util.TestLogger;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-import org.junit.Ignore;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
@@ -50,6 +49,7 @@&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;br/&gt;
 import java.util.concurrent.atomic.AtomicBoolean;&lt;/p&gt;

&lt;p&gt;+import static org.apache.flink.configuration.JobManagerOptions.EXECUTION_FAILOVER_STRATEGY;&lt;br/&gt;
 import static org.hamcrest.Matchers.is;&lt;br/&gt;
 import static org.junit.Assert.assertThat;&lt;/p&gt;

&lt;p&gt;@@ -72,13 +72,26 @@ public void testDisablingLocalRecovery() throws Exception {&lt;/p&gt;

&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Tests that if local recovery is enabled we won&apos;t spread&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* out tasks when recovering.&lt;br/&gt;
+	 * out tasks when recovering for global failover.&lt;br/&gt;
 	 */&lt;br/&gt;
 	@Test&lt;/li&gt;
	&lt;li&gt;@Ignore(&quot;The test should not pass until &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt; has been fixed&quot;)&lt;/li&gt;
	&lt;li&gt;public void testLocalRecovery() throws Exception {&lt;br/&gt;
+	public void testLocalRecoveryFull() throws Exception 
{
+		testLocalRecoveryInternal(&quot;full&quot;);
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that if local recovery is enabled we won&apos;t spread&lt;br/&gt;
+	 * out tasks when recovering for regional failover.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testLocalRecoveryRegion() throws Exception &lt;/p&gt;
{
+		testLocalRecoveryInternal(&quot;region&quot;);
+	}
&lt;p&gt;+&lt;br/&gt;
+	private void testLocalRecoveryInternal(String failoverStrategyValue) throws Exception &lt;/p&gt;
{
 		final Configuration configuration = new Configuration();
 		configuration.setBoolean(CheckpointingOptions.LOCAL_RECOVERY, true);
+		configuration.setString(EXECUTION_FAILOVER_STRATEGY.key(), failoverStrategyValue);
 
 		executeSchedulingTest(configuration);
 	}&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16671442" author="till.rohrmann" created="Thu, 1 Nov 2018 10:36:32 +0000"  >&lt;p&gt;Fixed in 1.6.3 via &lt;a href=&quot;https://github.com/apache/flink/commit/04df02b4728d40b59417ccc8ee281ab3298b09da&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/commit/04df02b4728d40b59417ccc8ee281ab3298b09da&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16671443" author="githubbot" created="Thu, 1 Nov 2018 10:36:32 +0000"  >&lt;p&gt;StefanRRichter commented on issue #6972: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9635&quot; title=&quot;Local recovery scheduling can cause spread out of tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9635&quot;&gt;&lt;del&gt;FLINK-9635&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;scheduling&amp;#93;&lt;/span&gt; Avoid task spread-out in scheduling with loc&#8230;&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6972#issuecomment-435000698&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6972#issuecomment-435000698&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Thanks @tillrohrmann !&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="13165994">FLINK-9583</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13228748">FLINK-12245</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13173122">FLINK-9892</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13167337">FLINK-9634</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 2 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3v2xz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310192" key="com.atlassian.jira.plugin.system.customfieldtypes:textarea">
                        <customfieldname>Release Note</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>With the improvements to Flink&amp;#39;s scheduling, it can no longer happen that recoveries require more slots than before if local recovery is enabled. Consequently, we encourage our users to use the local recovery feature which can be enabled by `state.backend.local-recovery: true`.</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>