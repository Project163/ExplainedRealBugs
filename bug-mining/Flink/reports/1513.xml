<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:27:07 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-5747] Eager Scheduling should deploy all Tasks together</title>
                <link>https://issues.apache.org/jira/browse/FLINK-5747</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;Currently, eager scheduling immediately triggers the scheduling for all vertices and their subtasks in topological order. &lt;/p&gt;

&lt;p&gt;This has two problems:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;This works only, as long as resource acquisition is &quot;synchronous&quot;. With dynamic resource acquisition in FLIP-6, the resources are returned as Futures which may complete out of order. This results in out-of-order (not in topological order) scheduling of tasks which does not work for streaming.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Deploying some tasks that depend on other tasks before it is clear that the other tasks have resources as well leads to situations where many deploy/recovery cycles happen before enough resources are available to get the job running fully.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;For eager scheduling, we should allocate all resources in one chunk and then deploy once we know that all are available.&lt;/p&gt;

&lt;p&gt;As a follow-up, the same should be done per pipelined component in lazy batch scheduling as well. That way we get lazy scheduling across blocking boundaries, and bulk (gang) scheduling in pipelined subgroups.&lt;/p&gt;

&lt;p&gt;This also does not apply for efforts of fine grained recovery, where individual tasks request replacement resources.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13041462">FLINK-5747</key>
            <summary>Eager Scheduling should deploy all Tasks together</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="sewen">Stephan Ewen</assignee>
                                    <reporter username="sewen">Stephan Ewen</reporter>
                        <labels>
                    </labels>
                <created>Wed, 8 Feb 2017 19:39:33 +0000</created>
                <updated>Wed, 2 Oct 2019 17:43:45 +0000</updated>
                            <resolved>Mon, 20 Feb 2017 00:56:20 +0000</resolved>
                                    <version>1.2.0</version>
                                    <fixVersion>1.3.0</fixVersion>
                                    <component>Runtime / Coordination</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="15863033" author="githubbot" created="Sun, 12 Feb 2017 23:24:12 +0000"  >&lt;p&gt;GitHub user StephanEwen opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5747&quot; title=&quot;Eager Scheduling should deploy all Tasks together&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5747&quot;&gt;&lt;del&gt;FLINK-5747&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;distributed coordination&amp;#93;&lt;/span&gt; Eager scheduling allocates slots and deploys tasks in bulk&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Problem Addressed&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    Currently, eager scheduling immediately triggers the scheduling for all vertices and their subtasks in topological order.&lt;/p&gt;

&lt;p&gt;    This has two problems:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;This works only, as long as resource acquisition is &quot;synchronous&quot;. With dynamic resource acquisition in FLIP-6, the resources are returned as Futures which may complete out of order. This results in out-of-order (not in topological order) scheduling of tasks which does not work for streaming.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Deploying some tasks that depend on other tasks before it is clear that the other tasks have resources as well leads to situations where many deploy/recovery cycles happen before enough resources are available to get the job running fully.&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Implemented Change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The `Execution` has separate methods to allocate a resource and to deploy the task to that resource&lt;/li&gt;
	&lt;li&gt;The *&lt;b&gt;eager&lt;/b&gt;* scheduling mode allocates all resources in one chunk and then deploys once all resources are available.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    As a utility, this implements the `FutureUtils.combineAll` method that combines the Futures of the individual resources to a combined Future.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Tests&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    The main tests are in `ExecutionGraphSchedulingTest`. The used utilities are tested in `FutureUtilsTest` and in `ExecutionGraphUtilsTest`.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/StephanEwen/incubator-flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/StephanEwen/incubator-flink&lt;/a&gt; slot_scheduling&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #3295&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 1f18cbb0d6d119fa5e5c4803201c28887b90cef5&lt;br/&gt;
Author: Stephan Ewen &amp;lt;sewen@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-02-03T19:26:23Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5747&quot; title=&quot;Eager Scheduling should deploy all Tasks together&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5747&quot;&gt;&lt;del&gt;FLINK-5747&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;distributed coordination&amp;#93;&lt;/span&gt; Eager scheduling allocates slots and deploys tasks in bulk&lt;/p&gt;

&lt;p&gt;    That way, strictly topological deployment can be guaranteed.&lt;/p&gt;

&lt;p&gt;    Also, many quick deploy/not-enough-resources/fail/recover cycles can be&lt;br/&gt;
    avoided in the cases where resources need some time to appear.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15871787" author="githubbot" created="Fri, 17 Feb 2017 12:39:32 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101731399&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101731399&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/concurrent/FutureUtils.java &amp;#8212;&lt;br/&gt;
    @@ -88,4 +100,104 @@ public RetryException(Throwable cause) &lt;/p&gt;
{
     			super(cause);
     		}
&lt;p&gt;     	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +	//  composing futures&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Creates a future that is complete once multiple other futures completed. &lt;br/&gt;
    +	 * The ConjunctFuture fails (completes exceptionally) once one of the Futures in the&lt;br/&gt;
    +	 * conjunction fails.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;The ConjunctFuture gives access to how many Futures in the conjunction have already&lt;br/&gt;
    +	 * completed successfully, via &lt;/p&gt;
{@link ConjunctFuture#getNumFuturesCompleted()}
&lt;p&gt;. &lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param futures The futures that make up the conjunction. No null entries are allowed.&lt;br/&gt;
    +	 * @return The ConjunctFuture that completes once all given futures are complete (or one fails).&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static ConjunctFuture combineAll(Collection&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt; futures) {&lt;br/&gt;
    +		checkNotNull(futures, &quot;futures&quot;);&lt;br/&gt;
    +		checkArgument(!futures.isEmpty(), &quot;futures is empty&quot;);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Couldn&apos;t an empty futures list return a completed `ConjunctFuture`? This would resemble a little bit more the &#8704; semantics.&lt;/p&gt;</comment>
                            <comment id="15871788" author="githubbot" created="Fri, 17 Feb 2017 12:39:32 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101737967&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101737967&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -292,7 +305,8 @@ public ExecutionGraph(&lt;br/&gt;
     		this.stateTimestamps = new long&lt;span class=&quot;error&quot;&gt;&amp;#91;JobStatus.values().length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
     		this.stateTimestamps&lt;span class=&quot;error&quot;&gt;&amp;#91;JobStatus.CREATED.ordinal()&amp;#93;&lt;/span&gt; = System.currentTimeMillis();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.timeout = timeout;&lt;br/&gt;
    +		this.rpcCallTimeout = timeout;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Maybe we could add a null check here. I think I forgot it initially.&lt;/p&gt;</comment>
                            <comment id="15871789" author="githubbot" created="Fri, 17 Feb 2017 12:39:32 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101747876&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101747876&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/Flip6LocalStreamEnvironment.java &amp;#8212;&lt;br/&gt;
    @@ -41,7 +41,7 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;When this environment is instantiated, it uses a default parallelism of 
{@code 1}
&lt;p&gt;. The default&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;parallelism can be set via 
{@link #setParallelism(int)}
&lt;p&gt;.&lt;br/&gt;
      */&lt;br/&gt;
    -@Public&lt;br/&gt;
    +@Internal&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    :+1:&lt;/p&gt;</comment>
                            <comment id="15871790" author="githubbot" created="Fri, 17 Feb 2017 12:39:32 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101747520&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101747520&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/concurrent/FutureUtilsTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,190 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.runtime.concurrent;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.FutureUtils.ConjunctFuture;&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.impl.FlinkCompletableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.concurrent.ExecutionException;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the utility methods in &lt;/p&gt;
{@link FutureUtils}
&lt;p&gt;    + */&lt;br/&gt;
    +public class FutureUtilsTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testConjunctFutureFailsOnEmptyAndNull() throws Exception {&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			FutureUtils.combineAll(null);
    +			fail();
    +		}
&lt;p&gt; catch (NullPointerException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			FutureUtils.combineAll(Collections.&amp;lt;Future&amp;lt;?&amp;gt;&amp;gt;emptyList());
    +			fail();
    +		}
&lt;p&gt; catch (IllegalArgumentException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			FutureUtils.combineAll(Arrays.asList(
    +					new FlinkCompletableFuture&amp;lt;Object&amp;gt;(),
    +					null,
    +					new FlinkCompletableFuture&amp;lt;Object&amp;gt;()));
    +			fail();
    +		}
&lt;p&gt; catch (NullPointerException ignored) {}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testConjunctFutureCompletion() throws Exception {&lt;br/&gt;
    +		// some futures that we combine&lt;br/&gt;
    +		CompletableFuture&amp;lt;Object&amp;gt; future1 = new FlinkCompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
    +		CompletableFuture&amp;lt;Object&amp;gt; future2 = new FlinkCompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
    +		CompletableFuture&amp;lt;Object&amp;gt; future3 = new FlinkCompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
    +		CompletableFuture&amp;lt;Object&amp;gt; future4 = new FlinkCompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
    +&lt;br/&gt;
    +		// some future is initially completed&lt;br/&gt;
    +		future2.complete(new Object());&lt;br/&gt;
    +&lt;br/&gt;
    +		// build the conjunct future&lt;br/&gt;
    +		ConjunctFuture result = FutureUtils.combineAll(Arrays.asList(future1, future2, future3, future4));&lt;br/&gt;
    +&lt;br/&gt;
    +		Future&amp;lt;Void&amp;gt; resultMapped = result.thenAccept(new AcceptFunction&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void accept(Void value) {}&lt;br/&gt;
    +		});&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Why do we add this `AcceptFunction`?&lt;/p&gt;</comment>
                            <comment id="15871791" author="githubbot" created="Fri, 17 Feb 2017 12:39:32 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101746831&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101746831&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraphUtils.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,108 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.runtime.executiongraph;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.BiFunction;&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.Future;&lt;br/&gt;
    +import org.apache.flink.runtime.instance.SimpleSlot;&lt;br/&gt;
    +import org.apache.flink.util.ExceptionUtils;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Utilities for dealing with the execution graphs and scheduling.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class ExecutionGraphUtils {&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Releases the slot represented by the given future. If the future is complete, the&lt;br/&gt;
    +	 * slot is immediately released. Otherwise, the slot is released as soon as the future&lt;br/&gt;
    +	 * is completed.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;Note that releasing the slot means cancelling any task execution currently&lt;br/&gt;
    +	 * associated with that slot.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param slotFuture The future for the slot to release.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static void releaseSlotFuture(Future&amp;lt;SimpleSlot&amp;gt; slotFuture) &lt;/p&gt;
{
    +		slotFuture.handle(ReleaseSlotFunction.INSTANCE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Releases the all the slots in the list of arrays of &lt;/p&gt;
{@code ExecutionAndSlot}
&lt;p&gt;.&lt;br/&gt;
    +	 * For each future in that collection holds: If the future is complete, its slot is&lt;br/&gt;
    +	 * immediately released. Otherwise, the slot is released as soon as the future&lt;br/&gt;
    +	 * is completed.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;This methods never throws any exceptions (subclasses of &lt;/p&gt;
{@code Exception}
&lt;p&gt;)&lt;br/&gt;
    +	 * and continues to release the remaining slots if one slot release failed. We only&lt;br/&gt;
    +	 * catch Exceptions here (and not other throwables) because the code executed while&lt;br/&gt;
    +	 * releasing slot does not involve any dynamic &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    sentence incomplete&lt;/p&gt;</comment>
                            <comment id="15871792" author="githubbot" created="Fri, 17 Feb 2017 12:39:32 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101739380&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101739380&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -754,6 +759,139 @@ public void scheduleForExecution(SlotProvider slotProvider) throws JobException&lt;br/&gt;
     		}&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;    +	private void scheduleLazy(SlotProvider slotProvider) throws NoResourceAvailableException {&lt;br/&gt;
    +		// simply take the vertices without inputs.&lt;br/&gt;
    +		for (ExecutionJobVertex ejv : this.tasks.values()) {&lt;br/&gt;
    +			if (ejv.getJobVertex().isInputVertex()) &lt;/p&gt;
{
    +				ejv.scheduleAll(slotProvider, allowQueuedScheduling);
    +			}
&lt;p&gt;    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param slotProvider  The resource provider from which the slots are allocated&lt;br/&gt;
    +	 * @param timeout       The maximum time that the deployment may take, before a&lt;br/&gt;
    +	 *                      TimeoutException is thrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void scheduleEager(SlotProvider slotProvider, final Time timeout) {&lt;br/&gt;
    +		checkState(state == JobStatus.RUNNING, &quot;job is not running currently&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		// Important: reserve all the space we need up front.&lt;br/&gt;
    +		// that way we do not have any operation that can fail between allocating the slots&lt;br/&gt;
    +		// and adding them to the list. If we had a failure in between there, that would&lt;br/&gt;
    +		// cause the slots to get lost&lt;br/&gt;
    +		final ArrayList&amp;lt;ExecutionAndSlot[]&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +		final boolean queued = allowQueuedScheduling;&lt;br/&gt;
    +&lt;br/&gt;
    +		// we use this flag to handle failures in a &apos;finally&apos; clause&lt;br/&gt;
    +		// that allows us to not go through clumsy cast-and-rethrow logic&lt;br/&gt;
    +		boolean successful = false;&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
    +			final ArrayList&amp;lt;Future&amp;lt;SimpleSlot&amp;gt;&amp;gt; slotFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +&lt;br/&gt;
    +			// allocate the slots (obtain all their futures&lt;br/&gt;
    +			for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
    +				// these calls are not blocking, they only return futures&lt;br/&gt;
    +				ExecutionAndSlot[] slots = ejv.allocateResourcesForAll(slotProvider, queued);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    However, as I see, we would have to reflect the same order in the collection because it requires a topological order.&lt;/p&gt;</comment>
                            <comment id="15871793" author="githubbot" created="Fri, 17 Feb 2017 12:39:32 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101746547&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101746547&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -754,6 +759,139 @@ public void scheduleForExecution(SlotProvider slotProvider) throws JobException&lt;br/&gt;
     		}&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;    +	private void scheduleLazy(SlotProvider slotProvider) throws NoResourceAvailableException {&lt;br/&gt;
    +		// simply take the vertices without inputs.&lt;br/&gt;
    +		for (ExecutionJobVertex ejv : this.tasks.values()) {&lt;br/&gt;
    +			if (ejv.getJobVertex().isInputVertex()) &lt;/p&gt;
{
    +				ejv.scheduleAll(slotProvider, allowQueuedScheduling);
    +			}
&lt;p&gt;    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param slotProvider  The resource provider from which the slots are allocated&lt;br/&gt;
    +	 * @param timeout       The maximum time that the deployment may take, before a&lt;br/&gt;
    +	 *                      TimeoutException is thrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void scheduleEager(SlotProvider slotProvider, final Time timeout) {&lt;br/&gt;
    +		checkState(state == JobStatus.RUNNING, &quot;job is not running currently&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		// Important: reserve all the space we need up front.&lt;br/&gt;
    +		// that way we do not have any operation that can fail between allocating the slots&lt;br/&gt;
    +		// and adding them to the list. If we had a failure in between there, that would&lt;br/&gt;
    +		// cause the slots to get lost&lt;br/&gt;
    +		final ArrayList&amp;lt;ExecutionAndSlot[]&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +		final boolean queued = allowQueuedScheduling;&lt;br/&gt;
    +&lt;br/&gt;
    +		// we use this flag to handle failures in a &apos;finally&apos; clause&lt;br/&gt;
    +		// that allows us to not go through clumsy cast-and-rethrow logic&lt;br/&gt;
    +		boolean successful = false;&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
    +			final ArrayList&amp;lt;Future&amp;lt;SimpleSlot&amp;gt;&amp;gt; slotFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +&lt;br/&gt;
    +			// allocate the slots (obtain all their futures&lt;br/&gt;
    +			for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
    +				// these calls are not blocking, they only return futures&lt;br/&gt;
    +				ExecutionAndSlot[] slots = ejv.allocateResourcesForAll(slotProvider, queued);&lt;br/&gt;
    +&lt;br/&gt;
    +				// we need to first add the slots to this list, to be safe on release&lt;br/&gt;
    +				resources.add(slots);&lt;br/&gt;
    +&lt;br/&gt;
    +				for (ExecutionAndSlot ens : slots) &lt;/p&gt;
{
    +					slotFutures.add(ens.slotFuture);
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +			// this future is complete once all slot futures are complete.&lt;br/&gt;
    +			// the future fails once one slot future fails.&lt;br/&gt;
    +			final ConjunctFuture allAllocationsComplete = FutureUtils.combineAll(slotFutures);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Just a thought: Right now we&apos;re waiting for all futures to complete. But couldn&apos;t we also create graph of dependencies mirroring the topological ordering by combining multiple `ConjunctFutures` where each `ConjunctFuture` represents the inputs of a given vertex. That way, we could speed up the deployment a little bit.&lt;/p&gt;</comment>
                            <comment id="15871794" author="githubbot" created="Fri, 17 Feb 2017 12:39:32 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101739062&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101739062&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -754,6 +759,139 @@ public void scheduleForExecution(SlotProvider slotProvider) throws JobException&lt;br/&gt;
     		}&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;    +	private void scheduleLazy(SlotProvider slotProvider) throws NoResourceAvailableException {&lt;br/&gt;
    +		// simply take the vertices without inputs.&lt;br/&gt;
    +		for (ExecutionJobVertex ejv : this.tasks.values()) {&lt;br/&gt;
    +			if (ejv.getJobVertex().isInputVertex()) &lt;/p&gt;
{
    +				ejv.scheduleAll(slotProvider, allowQueuedScheduling);
    +			}
&lt;p&gt;    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param slotProvider  The resource provider from which the slots are allocated&lt;br/&gt;
    +	 * @param timeout       The maximum time that the deployment may take, before a&lt;br/&gt;
    +	 *                      TimeoutException is thrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void scheduleEager(SlotProvider slotProvider, final Time timeout) {&lt;br/&gt;
    +		checkState(state == JobStatus.RUNNING, &quot;job is not running currently&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		// Important: reserve all the space we need up front.&lt;br/&gt;
    +		// that way we do not have any operation that can fail between allocating the slots&lt;br/&gt;
    +		// and adding them to the list. If we had a failure in between there, that would&lt;br/&gt;
    +		// cause the slots to get lost&lt;br/&gt;
    +		final ArrayList&amp;lt;ExecutionAndSlot[]&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +		final boolean queued = allowQueuedScheduling;&lt;br/&gt;
    +&lt;br/&gt;
    +		// we use this flag to handle failures in a &apos;finally&apos; clause&lt;br/&gt;
    +		// that allows us to not go through clumsy cast-and-rethrow logic&lt;br/&gt;
    +		boolean successful = false;&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
    +			final ArrayList&amp;lt;Future&amp;lt;SimpleSlot&amp;gt;&amp;gt; slotFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +&lt;br/&gt;
    +			// allocate the slots (obtain all their futures&lt;br/&gt;
    +			for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
    +				// these calls are not blocking, they only return futures&lt;br/&gt;
    +				ExecutionAndSlot[] slots = ejv.allocateResourcesForAll(slotProvider, queued);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    With the generalized `ConjunctFuture` we could return a collection if `Future&amp;lt;ExecutionAndSlots&amp;gt;` which could then be combined to a `ConjunctFuture&amp;lt;ExecutionAndSlots&amp;gt;`. When completed it would pass a `Collection&amp;lt;ExecutionAndSlots&amp;gt;` to the handle method.&lt;/p&gt;</comment>
                            <comment id="15871795" author="githubbot" created="Fri, 17 Feb 2017 12:39:32 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101737070&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101737070&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/concurrent/FutureUtils.java &amp;#8212;&lt;br/&gt;
    @@ -88,4 +100,104 @@ public RetryException(Throwable cause) &lt;/p&gt;
{
     			super(cause);
     		}
&lt;p&gt;     	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +	//  composing futures&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Creates a future that is complete once multiple other futures completed. &lt;br/&gt;
    +	 * The ConjunctFuture fails (completes exceptionally) once one of the Futures in the&lt;br/&gt;
    +	 * conjunction fails.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;The ConjunctFuture gives access to how many Futures in the conjunction have already&lt;br/&gt;
    +	 * completed successfully, via &lt;/p&gt;
{@link ConjunctFuture#getNumFuturesCompleted()}
&lt;p&gt;. &lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param futures The futures that make up the conjunction. No null entries are allowed.&lt;br/&gt;
    +	 * @return The ConjunctFuture that completes once all given futures are complete (or one fails).&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static ConjunctFuture combineAll(Collection&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt; futures) {&lt;br/&gt;
    +		checkNotNull(futures, &quot;futures&quot;);&lt;br/&gt;
    +		checkArgument(!futures.isEmpty(), &quot;futures is empty&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ConjunctFutureImpl conjunct = new ConjunctFutureImpl(futures.size());&lt;br/&gt;
    +&lt;br/&gt;
    +		for (Future&amp;lt;?&amp;gt; future : futures) &lt;/p&gt;
{
    +			future.handle(conjunct.completionHandler);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		return conjunct;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * A future that is complete once multiple other futures completed. The futures are not&lt;br/&gt;
    +	 * necessarily of the same type, which is why the type of this Future is &lt;/p&gt;
{@code Void}
&lt;p&gt;.&lt;br/&gt;
    +	 * The ConjunctFuture fails (completes exceptionally) once one of the Futures in the&lt;br/&gt;
    +	 * conjunction fails.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;The advantage of using the ConjunctFuture over chaining all the futures (such as via&lt;br/&gt;
    +	 * &lt;/p&gt;
{@link Future#thenCombine(Future, BiFunction)}
&lt;p&gt;) is that ConjunctFuture also tracks how&lt;br/&gt;
    +	 * many of the Futures are already complete.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public interface ConjunctFuture extends CompletableFuture&amp;lt;Void&amp;gt; &lt;/p&gt;
{
    +
    +		/**
    +		 * Gets the total number of Futures in the conjunction.
    +		 * @return The total number of Futures in the conjunction.
    +		 */
    +		int getNumFuturesTotal();
    +
    +		/**
    +		 * Gets the number of Futures in the conjunction that are already complete.
    +		 * @return The number of Futures in the conjunction that are already complete
    +		 */
    +		int getNumFuturesCompleted();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * The implementation of the &lt;/p&gt;
{@link ConjunctFuture}
&lt;p&gt;.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;Implementation notice: The member fields all have package-private access, because they are&lt;br/&gt;
    +	 * either accessed by an inner subclass or by the enclosing class.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private static class ConjunctFutureImpl extends FlinkCompletableFuture&amp;lt;Void&amp;gt; implements ConjunctFuture {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I like the idea of the ConjunctFuture &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I was wondering whether we can generalize it a little bit more by also collecting the actual values. Then the ConjunctFuture would effectively return a collection of the common base type of all registered futures. Here is a commit where I tried it out: &lt;a href=&quot;https://github.com/tillrohrmann/flink/commit/f1f5ab63bfe75d629230e0fc2cf37d2499d85548&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/tillrohrmann/flink/commit/f1f5ab63bfe75d629230e0fc2cf37d2499d85548&lt;/a&gt;. What do you think?&lt;/p&gt;</comment>
                            <comment id="15871827" author="githubbot" created="Fri, 17 Feb 2017 13:14:43 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101753433&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101753433&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/concurrent/FutureUtilsTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,190 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.runtime.concurrent;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.FutureUtils.ConjunctFuture;&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.impl.FlinkCompletableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.concurrent.ExecutionException;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the utility methods in &lt;/p&gt;
{@link FutureUtils}
&lt;p&gt;    + */&lt;br/&gt;
    +public class FutureUtilsTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testConjunctFutureFailsOnEmptyAndNull() throws Exception {&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			FutureUtils.combineAll(null);
    +			fail();
    +		}
&lt;p&gt; catch (NullPointerException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			FutureUtils.combineAll(Collections.&amp;lt;Future&amp;lt;?&amp;gt;&amp;gt;emptyList());
    +			fail();
    +		}
&lt;p&gt; catch (IllegalArgumentException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			FutureUtils.combineAll(Arrays.asList(
    +					new FlinkCompletableFuture&amp;lt;Object&amp;gt;(),
    +					null,
    +					new FlinkCompletableFuture&amp;lt;Object&amp;gt;()));
    +			fail();
    +		}
&lt;p&gt; catch (NullPointerException ignored) {}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testConjunctFutureCompletion() throws Exception {&lt;br/&gt;
    +		// some futures that we combine&lt;br/&gt;
    +		CompletableFuture&amp;lt;Object&amp;gt; future1 = new FlinkCompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
    +		CompletableFuture&amp;lt;Object&amp;gt; future2 = new FlinkCompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
    +		CompletableFuture&amp;lt;Object&amp;gt; future3 = new FlinkCompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
    +		CompletableFuture&amp;lt;Object&amp;gt; future4 = new FlinkCompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
    +&lt;br/&gt;
    +		// some future is initially completed&lt;br/&gt;
    +		future2.complete(new Object());&lt;br/&gt;
    +&lt;br/&gt;
    +		// build the conjunct future&lt;br/&gt;
    +		ConjunctFuture result = FutureUtils.combineAll(Arrays.asList(future1, future2, future3, future4));&lt;br/&gt;
    +&lt;br/&gt;
    +		Future&amp;lt;Void&amp;gt; resultMapped = result.thenAccept(new AcceptFunction&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void accept(Void value) {}&lt;br/&gt;
    +		});&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This is simply added as a test that applyied functions (and their result futures) are not called before completion.&lt;/p&gt;</comment>
                            <comment id="15871830" author="githubbot" created="Fri, 17 Feb 2017 13:15:45 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101753597&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101753597&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraphUtils.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,108 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.runtime.executiongraph;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.BiFunction;&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.Future;&lt;br/&gt;
    +import org.apache.flink.runtime.instance.SimpleSlot;&lt;br/&gt;
    +import org.apache.flink.util.ExceptionUtils;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Utilities for dealing with the execution graphs and scheduling.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class ExecutionGraphUtils {&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Releases the slot represented by the given future. If the future is complete, the&lt;br/&gt;
    +	 * slot is immediately released. Otherwise, the slot is released as soon as the future&lt;br/&gt;
    +	 * is completed.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;Note that releasing the slot means cancelling any task execution currently&lt;br/&gt;
    +	 * associated with that slot.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param slotFuture The future for the slot to release.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static void releaseSlotFuture(Future&amp;lt;SimpleSlot&amp;gt; slotFuture) &lt;/p&gt;
{
    +		slotFuture.handle(ReleaseSlotFunction.INSTANCE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Releases the all the slots in the list of arrays of &lt;/p&gt;
{@code ExecutionAndSlot}
&lt;p&gt;.&lt;br/&gt;
    +	 * For each future in that collection holds: If the future is complete, its slot is&lt;br/&gt;
    +	 * immediately released. Otherwise, the slot is released as soon as the future&lt;br/&gt;
    +	 * is completed.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;This methods never throws any exceptions (subclasses of &lt;/p&gt;
{@code Exception}
&lt;p&gt;)&lt;br/&gt;
    +	 * and continues to release the remaining slots if one slot release failed. We only&lt;br/&gt;
    +	 * catch Exceptions here (and not other throwables) because the code executed while&lt;br/&gt;
    +	 * releasing slot does not involve any dynamic &lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    true, will fix that&lt;/p&gt;</comment>
                            <comment id="15871835" author="githubbot" created="Fri, 17 Feb 2017 13:17:31 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101753888&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101753888&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -754,6 +759,139 @@ public void scheduleForExecution(SlotProvider slotProvider) throws JobException&lt;br/&gt;
     		}&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;    +	private void scheduleLazy(SlotProvider slotProvider) throws NoResourceAvailableException {&lt;br/&gt;
    +		// simply take the vertices without inputs.&lt;br/&gt;
    +		for (ExecutionJobVertex ejv : this.tasks.values()) {&lt;br/&gt;
    +			if (ejv.getJobVertex().isInputVertex()) &lt;/p&gt;
{
    +				ejv.scheduleAll(slotProvider, allowQueuedScheduling);
    +			}
&lt;p&gt;    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param slotProvider  The resource provider from which the slots are allocated&lt;br/&gt;
    +	 * @param timeout       The maximum time that the deployment may take, before a&lt;br/&gt;
    +	 *                      TimeoutException is thrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void scheduleEager(SlotProvider slotProvider, final Time timeout) {&lt;br/&gt;
    +		checkState(state == JobStatus.RUNNING, &quot;job is not running currently&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		// Important: reserve all the space we need up front.&lt;br/&gt;
    +		// that way we do not have any operation that can fail between allocating the slots&lt;br/&gt;
    +		// and adding them to the list. If we had a failure in between there, that would&lt;br/&gt;
    +		// cause the slots to get lost&lt;br/&gt;
    +		final ArrayList&amp;lt;ExecutionAndSlot[]&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +		final boolean queued = allowQueuedScheduling;&lt;br/&gt;
    +&lt;br/&gt;
    +		// we use this flag to handle failures in a &apos;finally&apos; clause&lt;br/&gt;
    +		// that allows us to not go through clumsy cast-and-rethrow logic&lt;br/&gt;
    +		boolean successful = false;&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
    +			final ArrayList&amp;lt;Future&amp;lt;SimpleSlot&amp;gt;&amp;gt; slotFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +&lt;br/&gt;
    +			// allocate the slots (obtain all their futures&lt;br/&gt;
    +			for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
    +				// these calls are not blocking, they only return futures&lt;br/&gt;
    +				ExecutionAndSlot[] slots = ejv.allocateResourcesForAll(slotProvider, queued);&lt;br/&gt;
    +&lt;br/&gt;
    +				// we need to first add the slots to this list, to be safe on release&lt;br/&gt;
    +				resources.add(slots);&lt;br/&gt;
    +&lt;br/&gt;
    +				for (ExecutionAndSlot ens : slots) &lt;/p&gt;
{
    +					slotFutures.add(ens.slotFuture);
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +			// this future is complete once all slot futures are complete.&lt;br/&gt;
    +			// the future fails once one slot future fails.&lt;br/&gt;
    +			final ConjunctFuture allAllocationsComplete = FutureUtils.combineAll(slotFutures);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I thought about that, and one purpose of this change is to avoid many partial deployments / failures when not all resources are available.&lt;/p&gt;

&lt;p&gt;    In the &quot;FLIP-1&quot; work, we would introduce something like &quot;domains of tasks that schedule and fail together&quot;. We can schedule them topologically independently.&lt;/p&gt;</comment>
                            <comment id="15871838" author="githubbot" created="Fri, 17 Feb 2017 13:18:10 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101753992&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101753992&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -292,7 +305,8 @@ public ExecutionGraph(&lt;br/&gt;
     		this.stateTimestamps = new long&lt;span class=&quot;error&quot;&gt;&amp;#91;JobStatus.values().length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
     		this.stateTimestamps&lt;span class=&quot;error&quot;&gt;&amp;#91;JobStatus.CREATED.ordinal()&amp;#93;&lt;/span&gt; = System.currentTimeMillis();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.timeout = timeout;&lt;br/&gt;
    +		this.rpcCallTimeout = timeout;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    will do&lt;/p&gt;</comment>
                            <comment id="15871843" author="githubbot" created="Fri, 17 Feb 2017 13:21:32 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101754578&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101754578&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/concurrent/FutureUtils.java &amp;#8212;&lt;br/&gt;
    @@ -88,4 +100,104 @@ public RetryException(Throwable cause) &lt;/p&gt;
{
     			super(cause);
     		}
&lt;p&gt;     	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +	//  composing futures&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Creates a future that is complete once multiple other futures completed. &lt;br/&gt;
    +	 * The ConjunctFuture fails (completes exceptionally) once one of the Futures in the&lt;br/&gt;
    +	 * conjunction fails.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;The ConjunctFuture gives access to how many Futures in the conjunction have already&lt;br/&gt;
    +	 * completed successfully, via &lt;/p&gt;
{@link ConjunctFuture#getNumFuturesCompleted()}
&lt;p&gt;. &lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param futures The futures that make up the conjunction. No null entries are allowed.&lt;br/&gt;
    +	 * @return The ConjunctFuture that completes once all given futures are complete (or one fails).&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static ConjunctFuture combineAll(Collection&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt; futures) {&lt;br/&gt;
    +		checkNotNull(futures, &quot;futures&quot;);&lt;br/&gt;
    +		checkArgument(!futures.isEmpty(), &quot;futures is empty&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ConjunctFutureImpl conjunct = new ConjunctFutureImpl(futures.size());&lt;br/&gt;
    +&lt;br/&gt;
    +		for (Future&amp;lt;?&amp;gt; future : futures) &lt;/p&gt;
{
    +			future.handle(conjunct.completionHandler);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		return conjunct;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * A future that is complete once multiple other futures completed. The futures are not&lt;br/&gt;
    +	 * necessarily of the same type, which is why the type of this Future is &lt;/p&gt;
{@code Void}
&lt;p&gt;.&lt;br/&gt;
    +	 * The ConjunctFuture fails (completes exceptionally) once one of the Futures in the&lt;br/&gt;
    +	 * conjunction fails.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;The advantage of using the ConjunctFuture over chaining all the futures (such as via&lt;br/&gt;
    +	 * &lt;/p&gt;
{@link Future#thenCombine(Future, BiFunction)}
&lt;p&gt;) is that ConjunctFuture also tracks how&lt;br/&gt;
    +	 * many of the Futures are already complete.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public interface ConjunctFuture extends CompletableFuture&amp;lt;Void&amp;gt; &lt;/p&gt;
{
    +
    +		/**
    +		 * Gets the total number of Futures in the conjunction.
    +		 * @return The total number of Futures in the conjunction.
    +		 */
    +		int getNumFuturesTotal();
    +
    +		/**
    +		 * Gets the number of Futures in the conjunction that are already complete.
    +		 * @return The number of Futures in the conjunction that are already complete
    +		 */
    +		int getNumFuturesCompleted();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * The implementation of the &lt;/p&gt;
{@link ConjunctFuture}
&lt;p&gt;.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;Implementation notice: The member fields all have package-private access, because they are&lt;br/&gt;
    +	 * either accessed by an inner subclass or by the enclosing class.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private static class ConjunctFutureImpl extends FlinkCompletableFuture&amp;lt;Void&amp;gt; implements ConjunctFuture {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Interesting idea. I think the linked implementation is not yet thread safe, because the BiFunction that adds the results to the collection is called concurrently as the different original futures complete. For this particular use case, we&apos;d need to also preserve the order. This is easy to change by simply pre-allocating a target array and setting the results to the positions (the completion function would need to get the target index).&lt;/p&gt;

&lt;p&gt;    I would actually like to do that as a separate follow-up, unless you object there.&lt;/p&gt;</comment>
                            <comment id="15871919" author="githubbot" created="Fri, 17 Feb 2017 14:25:17 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101765953&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101765953&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/concurrent/FutureUtils.java &amp;#8212;&lt;br/&gt;
    @@ -88,4 +100,104 @@ public RetryException(Throwable cause) &lt;/p&gt;
{
     			super(cause);
     		}
&lt;p&gt;     	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +	//  composing futures&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Creates a future that is complete once multiple other futures completed. &lt;br/&gt;
    +	 * The ConjunctFuture fails (completes exceptionally) once one of the Futures in the&lt;br/&gt;
    +	 * conjunction fails.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;The ConjunctFuture gives access to how many Futures in the conjunction have already&lt;br/&gt;
    +	 * completed successfully, via &lt;/p&gt;
{@link ConjunctFuture#getNumFuturesCompleted()}
&lt;p&gt;. &lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param futures The futures that make up the conjunction. No null entries are allowed.&lt;br/&gt;
    +	 * @return The ConjunctFuture that completes once all given futures are complete (or one fails).&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static ConjunctFuture combineAll(Collection&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt; futures) {&lt;br/&gt;
    +		checkNotNull(futures, &quot;futures&quot;);&lt;br/&gt;
    +		checkArgument(!futures.isEmpty(), &quot;futures is empty&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ConjunctFutureImpl conjunct = new ConjunctFutureImpl(futures.size());&lt;br/&gt;
    +&lt;br/&gt;
    +		for (Future&amp;lt;?&amp;gt; future : futures) &lt;/p&gt;
{
    +			future.handle(conjunct.completionHandler);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		return conjunct;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * A future that is complete once multiple other futures completed. The futures are not&lt;br/&gt;
    +	 * necessarily of the same type, which is why the type of this Future is &lt;/p&gt;
{@code Void}
&lt;p&gt;.&lt;br/&gt;
    +	 * The ConjunctFuture fails (completes exceptionally) once one of the Futures in the&lt;br/&gt;
    +	 * conjunction fails.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;The advantage of using the ConjunctFuture over chaining all the futures (such as via&lt;br/&gt;
    +	 * &lt;/p&gt;
{@link Future#thenCombine(Future, BiFunction)}
&lt;p&gt;) is that ConjunctFuture also tracks how&lt;br/&gt;
    +	 * many of the Futures are already complete.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public interface ConjunctFuture extends CompletableFuture&amp;lt;Void&amp;gt; &lt;/p&gt;
{
    +
    +		/**
    +		 * Gets the total number of Futures in the conjunction.
    +		 * @return The total number of Futures in the conjunction.
    +		 */
    +		int getNumFuturesTotal();
    +
    +		/**
    +		 * Gets the number of Futures in the conjunction that are already complete.
    +		 * @return The number of Futures in the conjunction that are already complete
    +		 */
    +		int getNumFuturesCompleted();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * The implementation of the &lt;/p&gt;
{@link ConjunctFuture}
&lt;p&gt;.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;Implementation notice: The member fields all have package-private access, because they are&lt;br/&gt;
    +	 * either accessed by an inner subclass or by the enclosing class.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private static class ConjunctFutureImpl extends FlinkCompletableFuture&amp;lt;Void&amp;gt; implements ConjunctFuture {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Doesn&apos;t the `AtomicInteger` make it thread safe? Every call to the BiFunction will manipulate a distinct array field. And the array is fixed, so no resizing operation can take place.&lt;/p&gt;

&lt;p&gt;    Btw: I think it should be `set(index, element)` instead of `add(index, element)` because of the fixed nature of the array list.&lt;/p&gt;

&lt;p&gt;    Yes please do it as a follow-up.&lt;/p&gt;</comment>
                            <comment id="15871921" author="githubbot" created="Fri, 17 Feb 2017 14:29:41 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101766842&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101766842&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -754,6 +759,139 @@ public void scheduleForExecution(SlotProvider slotProvider) throws JobException&lt;br/&gt;
     		}&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;    +	private void scheduleLazy(SlotProvider slotProvider) throws NoResourceAvailableException {&lt;br/&gt;
    +		// simply take the vertices without inputs.&lt;br/&gt;
    +		for (ExecutionJobVertex ejv : this.tasks.values()) {&lt;br/&gt;
    +			if (ejv.getJobVertex().isInputVertex()) &lt;/p&gt;
{
    +				ejv.scheduleAll(slotProvider, allowQueuedScheduling);
    +			}
&lt;p&gt;    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param slotProvider  The resource provider from which the slots are allocated&lt;br/&gt;
    +	 * @param timeout       The maximum time that the deployment may take, before a&lt;br/&gt;
    +	 *                      TimeoutException is thrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void scheduleEager(SlotProvider slotProvider, final Time timeout) {&lt;br/&gt;
    +		checkState(state == JobStatus.RUNNING, &quot;job is not running currently&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		// Important: reserve all the space we need up front.&lt;br/&gt;
    +		// that way we do not have any operation that can fail between allocating the slots&lt;br/&gt;
    +		// and adding them to the list. If we had a failure in between there, that would&lt;br/&gt;
    +		// cause the slots to get lost&lt;br/&gt;
    +		final ArrayList&amp;lt;ExecutionAndSlot[]&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +		final boolean queued = allowQueuedScheduling;&lt;br/&gt;
    +&lt;br/&gt;
    +		// we use this flag to handle failures in a &apos;finally&apos; clause&lt;br/&gt;
    +		// that allows us to not go through clumsy cast-and-rethrow logic&lt;br/&gt;
    +		boolean successful = false;&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
    +			final ArrayList&amp;lt;Future&amp;lt;SimpleSlot&amp;gt;&amp;gt; slotFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +&lt;br/&gt;
    +			// allocate the slots (obtain all their futures&lt;br/&gt;
    +			for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
    +				// these calls are not blocking, they only return futures&lt;br/&gt;
    +				ExecutionAndSlot[] slots = ejv.allocateResourcesForAll(slotProvider, queued);&lt;br/&gt;
    +&lt;br/&gt;
    +				// we need to first add the slots to this list, to be safe on release&lt;br/&gt;
    +				resources.add(slots);&lt;br/&gt;
    +&lt;br/&gt;
    +				for (ExecutionAndSlot ens : slots) &lt;/p&gt;
{
    +					slotFutures.add(ens.slotFuture);
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +			// this future is complete once all slot futures are complete.&lt;br/&gt;
    +			// the future fails once one slot future fails.&lt;br/&gt;
    +			final ConjunctFuture allAllocationsComplete = FutureUtils.combineAll(slotFutures);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Shouldn&apos;t the `fail` operations be idempotent and only take effect for the first failure?&lt;/p&gt;</comment>
                            <comment id="15871923" author="githubbot" created="Fri, 17 Feb 2017 14:30:08 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101766916&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101766916&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/concurrent/FutureUtilsTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,190 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.runtime.concurrent;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.FutureUtils.ConjunctFuture;&lt;br/&gt;
    +import org.apache.flink.runtime.concurrent.impl.FlinkCompletableFuture;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.concurrent.ExecutionException;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests for the utility methods in &lt;/p&gt;
{@link FutureUtils}
&lt;p&gt;    + */&lt;br/&gt;
    +public class FutureUtilsTest {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testConjunctFutureFailsOnEmptyAndNull() throws Exception {&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			FutureUtils.combineAll(null);
    +			fail();
    +		}
&lt;p&gt; catch (NullPointerException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			FutureUtils.combineAll(Collections.&amp;lt;Future&amp;lt;?&amp;gt;&amp;gt;emptyList());
    +			fail();
    +		}
&lt;p&gt; catch (IllegalArgumentException ignored) {}&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			FutureUtils.combineAll(Arrays.asList(
    +					new FlinkCompletableFuture&amp;lt;Object&amp;gt;(),
    +					null,
    +					new FlinkCompletableFuture&amp;lt;Object&amp;gt;()));
    +			fail();
    +		}
&lt;p&gt; catch (NullPointerException ignored) {}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testConjunctFutureCompletion() throws Exception {&lt;br/&gt;
    +		// some futures that we combine&lt;br/&gt;
    +		CompletableFuture&amp;lt;Object&amp;gt; future1 = new FlinkCompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
    +		CompletableFuture&amp;lt;Object&amp;gt; future2 = new FlinkCompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
    +		CompletableFuture&amp;lt;Object&amp;gt; future3 = new FlinkCompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
    +		CompletableFuture&amp;lt;Object&amp;gt; future4 = new FlinkCompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
    +&lt;br/&gt;
    +		// some future is initially completed&lt;br/&gt;
    +		future2.complete(new Object());&lt;br/&gt;
    +&lt;br/&gt;
    +		// build the conjunct future&lt;br/&gt;
    +		ConjunctFuture result = FutureUtils.combineAll(Arrays.asList(future1, future2, future3, future4));&lt;br/&gt;
    +&lt;br/&gt;
    +		Future&amp;lt;Void&amp;gt; resultMapped = result.thenAccept(new AcceptFunction&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void accept(Void value) {}&lt;br/&gt;
    +		});&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    ah makes sense &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15872093" author="githubbot" created="Fri, 17 Feb 2017 16:46:09 +0000"  >&lt;p&gt;Github user tillrohrmann commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    +1 for merging&lt;/p&gt;</comment>
                            <comment id="15872348" author="githubbot" created="Fri, 17 Feb 2017 19:19:35 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101827724&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101827724&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/concurrent/FutureUtils.java &amp;#8212;&lt;br/&gt;
    @@ -88,4 +100,104 @@ public RetryException(Throwable cause) &lt;/p&gt;
{
     			super(cause);
     		}
&lt;p&gt;     	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +	//  composing futures&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Creates a future that is complete once multiple other futures completed. &lt;br/&gt;
    +	 * The ConjunctFuture fails (completes exceptionally) once one of the Futures in the&lt;br/&gt;
    +	 * conjunction fails.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;The ConjunctFuture gives access to how many Futures in the conjunction have already&lt;br/&gt;
    +	 * completed successfully, via &lt;/p&gt;
{@link ConjunctFuture#getNumFuturesCompleted()}
&lt;p&gt;. &lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param futures The futures that make up the conjunction. No null entries are allowed.&lt;br/&gt;
    +	 * @return The ConjunctFuture that completes once all given futures are complete (or one fails).&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static ConjunctFuture combineAll(Collection&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt; futures) {&lt;br/&gt;
    +		checkNotNull(futures, &quot;futures&quot;);&lt;br/&gt;
    +		checkArgument(!futures.isEmpty(), &quot;futures is empty&quot;);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Yes, will change that...&lt;/p&gt;</comment>
                            <comment id="15872360" author="githubbot" created="Fri, 17 Feb 2017 19:25:36 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101829019&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101829019&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/concurrent/FutureUtils.java &amp;#8212;&lt;br/&gt;
    @@ -88,4 +100,104 @@ public RetryException(Throwable cause) &lt;/p&gt;
{
     			super(cause);
     		}
&lt;p&gt;     	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +	//  composing futures&lt;br/&gt;
    +	// ------------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Creates a future that is complete once multiple other futures completed. &lt;br/&gt;
    +	 * The ConjunctFuture fails (completes exceptionally) once one of the Futures in the&lt;br/&gt;
    +	 * conjunction fails.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;The ConjunctFuture gives access to how many Futures in the conjunction have already&lt;br/&gt;
    +	 * completed successfully, via &lt;/p&gt;
{@link ConjunctFuture#getNumFuturesCompleted()}
&lt;p&gt;. &lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param futures The futures that make up the conjunction. No null entries are allowed.&lt;br/&gt;
    +	 * @return The ConjunctFuture that completes once all given futures are complete (or one fails).&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static ConjunctFuture combineAll(Collection&amp;lt;? extends Future&amp;lt;?&amp;gt;&amp;gt; futures) {&lt;br/&gt;
    +		checkNotNull(futures, &quot;futures&quot;);&lt;br/&gt;
    +		checkArgument(!futures.isEmpty(), &quot;futures is empty&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		final ConjunctFutureImpl conjunct = new ConjunctFutureImpl(futures.size());&lt;br/&gt;
    +&lt;br/&gt;
    +		for (Future&amp;lt;?&amp;gt; future : futures) &lt;/p&gt;
{
    +			future.handle(conjunct.completionHandler);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		return conjunct;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * A future that is complete once multiple other futures completed. The futures are not&lt;br/&gt;
    +	 * necessarily of the same type, which is why the type of this Future is &lt;/p&gt;
{@code Void}
&lt;p&gt;.&lt;br/&gt;
    +	 * The ConjunctFuture fails (completes exceptionally) once one of the Futures in the&lt;br/&gt;
    +	 * conjunction fails.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;The advantage of using the ConjunctFuture over chaining all the futures (such as via&lt;br/&gt;
    +	 * &lt;/p&gt;
{@link Future#thenCombine(Future, BiFunction)}
&lt;p&gt;) is that ConjunctFuture also tracks how&lt;br/&gt;
    +	 * many of the Futures are already complete.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public interface ConjunctFuture extends CompletableFuture&amp;lt;Void&amp;gt; &lt;/p&gt;
{
    +
    +		/**
    +		 * Gets the total number of Futures in the conjunction.
    +		 * @return The total number of Futures in the conjunction.
    +		 */
    +		int getNumFuturesTotal();
    +
    +		/**
    +		 * Gets the number of Futures in the conjunction that are already complete.
    +		 * @return The number of Futures in the conjunction that are already complete
    +		 */
    +		int getNumFuturesCompleted();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * The implementation of the &lt;/p&gt;
{@link ConjunctFuture}
&lt;p&gt;.&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;Implementation notice: The member fields all have package-private access, because they are&lt;br/&gt;
    +	 * either accessed by an inner subclass or by the enclosing class.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private static class ConjunctFutureImpl extends FlinkCompletableFuture&amp;lt;Void&amp;gt; implements ConjunctFuture {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Yes, with set rather then add it should work. Since the list gets initialized with an array, I would actually just use an array in the first place.&lt;/p&gt;

&lt;p&gt;    Followup &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15872366" author="githubbot" created="Fri, 17 Feb 2017 19:28:42 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295#discussion_r101829659&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295#discussion_r101829659&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java &amp;#8212;&lt;br/&gt;
    @@ -754,6 +759,139 @@ public void scheduleForExecution(SlotProvider slotProvider) throws JobException&lt;br/&gt;
     		}&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;    +	private void scheduleLazy(SlotProvider slotProvider) throws NoResourceAvailableException {&lt;br/&gt;
    +		// simply take the vertices without inputs.&lt;br/&gt;
    +		for (ExecutionJobVertex ejv : this.tasks.values()) {&lt;br/&gt;
    +			if (ejv.getJobVertex().isInputVertex()) &lt;/p&gt;
{
    +				ejv.scheduleAll(slotProvider, allowQueuedScheduling);
    +			}
&lt;p&gt;    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * &lt;br/&gt;
    +	 * @param slotProvider  The resource provider from which the slots are allocated&lt;br/&gt;
    +	 * @param timeout       The maximum time that the deployment may take, before a&lt;br/&gt;
    +	 *                      TimeoutException is thrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void scheduleEager(SlotProvider slotProvider, final Time timeout) {&lt;br/&gt;
    +		checkState(state == JobStatus.RUNNING, &quot;job is not running currently&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		// Important: reserve all the space we need up front.&lt;br/&gt;
    +		// that way we do not have any operation that can fail between allocating the slots&lt;br/&gt;
    +		// and adding them to the list. If we had a failure in between there, that would&lt;br/&gt;
    +		// cause the slots to get lost&lt;br/&gt;
    +		final ArrayList&amp;lt;ExecutionAndSlot[]&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +		final boolean queued = allowQueuedScheduling;&lt;br/&gt;
    +&lt;br/&gt;
    +		// we use this flag to handle failures in a &apos;finally&apos; clause&lt;br/&gt;
    +		// that allows us to not go through clumsy cast-and-rethrow logic&lt;br/&gt;
    +		boolean successful = false;&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			// collecting all the slots may resize and fail in that operation without slots getting lost&lt;br/&gt;
    +			final ArrayList&amp;lt;Future&amp;lt;SimpleSlot&amp;gt;&amp;gt; slotFutures = new ArrayList&amp;lt;&amp;gt;(getNumberOfExecutionJobVertices());&lt;br/&gt;
    +&lt;br/&gt;
    +			// allocate the slots (obtain all their futures&lt;br/&gt;
    +			for (ExecutionJobVertex ejv : getVerticesTopologically()) {&lt;br/&gt;
    +				// these calls are not blocking, they only return futures&lt;br/&gt;
    +				ExecutionAndSlot[] slots = ejv.allocateResourcesForAll(slotProvider, queued);&lt;br/&gt;
    +&lt;br/&gt;
    +				// we need to first add the slots to this list, to be safe on release&lt;br/&gt;
    +				resources.add(slots);&lt;br/&gt;
    +&lt;br/&gt;
    +				for (ExecutionAndSlot ens : slots) &lt;/p&gt;
{
    +					slotFutures.add(ens.slotFuture);
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +			// this future is complete once all slot futures are complete.&lt;br/&gt;
    +			// the future fails once one slot future fails.&lt;br/&gt;
    +			final ConjunctFuture allAllocationsComplete = FutureUtils.combineAll(slotFutures);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    True, it is not incorrect. But some tasks would be already deployed if we start as soon as some futures are ready. They would need to be canceled again, which gives these not so nice fast deploy/out-of-resource/cancel/wait-for-cancellation/retry/etc loops.&lt;/p&gt;</comment>
                            <comment id="15873905" author="stephanewen" created="Mon, 20 Feb 2017 00:56:20 +0000"  >&lt;p&gt;Fixed via f113d79451ba88c487358861cc3e20aac3d19257&lt;/p&gt;</comment>
                            <comment id="15873914" author="githubbot" created="Mon, 20 Feb 2017 00:56:27 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3295&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3295&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16085555" author="sihuazhou" created="Thu, 13 Jul 2017 11:26:51 +0000"  >&lt;p&gt;Hi&#65292;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt;, there&apos;s some problems i found with Eager Scheduling in flink 1.3.x. i will be preciate if you have time to review what i&apos;ve posted in (&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7153&quot; title=&quot;Eager Scheduling can&amp;#39;t allocate source for ExecutionGraph correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7153&quot;&gt;&lt;del&gt;FLINK-7153&lt;/del&gt;&lt;/a&gt;)&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7153&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;link title&lt;/a&gt;, i will close the issue if i was wrong.&lt;br/&gt;
Thanks.  &lt;br/&gt;
Sihua zhou&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="13041463">FLINK-5748</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13041791">FLINK-5766</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 18 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i39t0n:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>