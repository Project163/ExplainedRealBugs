<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:23:36 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-3669] WindowOperator registers a lot of timers at StreamTask</title>
                <link>https://issues.apache.org/jira/browse/FLINK-3669</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;Right now, the WindowOperator registers a timer at the StreamTask for every processing-time timer that a Trigger registers. We should combine several registered trigger timers to only register one low-level timer (timer coalescing).&lt;/p&gt;</description>
                <environment></environment>
        <key id="12953826">FLINK-3669</key>
            <summary>WindowOperator registers a lot of timers at StreamTask</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="knaufk">Konstantin Knauf</assignee>
                                    <reporter username="aljoscha">Aljoscha Krettek</reporter>
                        <labels>
                    </labels>
                <created>Sun, 27 Mar 2016 07:35:21 +0000</created>
                <updated>Thu, 28 Feb 2019 11:14:44 +0000</updated>
                            <resolved>Tue, 3 May 2016 13:57:09 +0000</resolved>
                                    <version>1.0.1</version>
                                    <fixVersion>1.1.0</fixVersion>
                                    <component>API / DataStream</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="15217614" author="knaufk" created="Wed, 30 Mar 2016 07:50:23 +0000"  >&lt;p&gt;Hi Aljoscha, &lt;/p&gt;

&lt;p&gt;I think there is more to it, although this would definitely mitigate the problem. Even if we only registered one timer per second. We would still create a lot of TriggerTasks, which do not get cleaned up, when TriggerContext.deleteProcessingTimeTimer is invoked. This could still lead to GC problems, if the trigger is far in the future. &lt;/p&gt;

&lt;p&gt;When calling deleteProcessingTimerTimer shouldn&apos;t the ScheduledFuture for this timer be canceled, which together with ScheduledThreadPoolExecutor.setRemoveOnCancelPolicy(true) would remove the TriggerTask from the ExecutorService and let GC do the cleanup?&lt;/p&gt;

&lt;p&gt;Cheers, &lt;/p&gt;

&lt;p&gt;Konstantin&lt;/p&gt;</comment>
                            <comment id="15219845" author="aljoscha" created="Thu, 31 Mar 2016 13:09:28 +0000"  >&lt;p&gt;Yes, you&apos;re right that&apos;s still a problem. The issue with removing the TriggerTasks is, that a) right now, the WindowOperator does not have a handle to the ScheduledFuture and b) if we combine the triggers for a certain timestamp into one trigger we cannot simply delete that TriggerTask until we know that all timers in the WindowOperator for that timestamp have been removed. By now, I see basically three solutions for our problem:&lt;/p&gt;

&lt;p&gt;1. Create one TriggerTask per &lt;tt&gt;registerProcessingTimeTimer()&lt;/tt&gt; call of the user (as is the case now), keep the &lt;tt&gt;ScheduledFuture&lt;/tt&gt;, remove the timer when the user calls &lt;tt&gt;deleteProcessingTimeTimer()&lt;/tt&gt;&lt;br/&gt;
2. Coalesce multiple &lt;tt&gt;registerProcessingTimeTimer()&lt;/tt&gt; calls to only create one TriggerTask to reduce the burden on the &lt;tt&gt;ScheduledThreadPoolExecutor&lt;/tt&gt;, keep track of how many user triggers we have for a timestamp, remove using the &lt;tt&gt;ScheduledFuture&lt;/tt&gt; once the number drops to zero&lt;br/&gt;
3. Change the timer service to call &lt;tt&gt;trigger()&lt;/tt&gt; of the &lt;tt&gt;WindowOperator&lt;/tt&gt; on a fixed interval, say 10 ms, the logic in &lt;tt&gt;WindowOperator.trigger()&lt;/tt&gt; already internally checks which triggers should fire based on the timestamp given. This would mean that the burden on &lt;tt&gt;ScheduledThreadPoolExecutor&lt;/tt&gt; is constant does not depend on the number of keys or number of user timers registered but it is potentially wasteful. &lt;/p&gt;

&lt;p&gt;(when I say user above, I mean the &lt;tt&gt;Trigger&lt;/tt&gt; implementation)&lt;/p&gt;

&lt;p&gt;I think I would go with option 3. the granularity can be user configurable, of course. There is, of course, a tradeoff. If the user has very large windows firing all those timers is a huge waste, but the other options require to hold a data structure to keep track of things.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                            <comment id="15219865" author="knaufk" created="Thu, 31 Mar 2016 13:31:45 +0000"  >&lt;p&gt;In my opionen the 1st option is the cleanest, but I can hardly imagine a usecase for which the 3rd option would be problem, so I think it is totally fine. In this case &#180;registerProcessingTimeTimer()&#180; should document that the timestamp is &quot;ceiled&quot; to the next interval and refer to the configuration parameter.&lt;/p&gt;</comment>
                            <comment id="15221600" author="aljoscha" created="Fri, 1 Apr 2016 12:00:50 +0000"  >&lt;p&gt;Yes, the 3rd option would require additional documentation and care on the part of users, so I would probably not go for it. I&apos;ll try and come up with a quick prototype for 1. to see how it behaves. Unless you want to work on it.&lt;/p&gt;

&lt;p&gt;I also found another problem. The queue that is used for the triggers turns out to be a bottleneck because removing items from it is O&amp;#40;n&amp;#41;, so with very large key ranges this becomes very slow.&lt;/p&gt;</comment>
                            <comment id="15221677" author="knaufk" created="Fri, 1 Apr 2016 13:22:19 +0000"  >&lt;p&gt;I would like to work on it, but not today.  I will give it a try during the weekend, if that&apos;s alright. &lt;/p&gt;</comment>
                            <comment id="15221682" author="aljoscha" created="Fri, 1 Apr 2016 13:27:40 +0000"  >&lt;p&gt;Sure, no pressure!&lt;/p&gt;</comment>
                            <comment id="15223402" author="knaufk" created="Sun, 3 Apr 2016 16:55:00 +0000"  >&lt;p&gt;I tried to implement the 1.. The hard part, I think, is to store the &lt;tt&gt;ScheduledFuture}}s to in the {{WindowOperator&lt;/tt&gt;. We could use a &lt;tt&gt;Map&amp;lt;Long,ScheduledFuture&amp;gt;&lt;/tt&gt;, but this only works if we also implement timer coalescing. Besides that I am unsure about how to de/serialize this map. Could you give me pointer?&lt;/p&gt;

&lt;p&gt;Edit. Ok, serializing the future does not make sense, so it could not be checkpointed, which is not necessarily a problem, I think.  Additionally, this should be a &lt;tt&gt;Map&amp;lt;Timer, ScheduledFuture&amp;gt;&lt;/tt&gt; instead.&lt;/p&gt;</comment>
                            <comment id="15223811" author="aljoscha" created="Mon, 4 Apr 2016 08:19:04 +0000"  >&lt;p&gt;Yes, you are right about that one. I think the way to go is to just not serialize the &lt;tt&gt;SchedulesFuture&lt;/tt&gt;. Upon restore we have to set a timer on &lt;tt&gt;System.currentTimeMillis()&lt;/tt&gt;, this will trigger any of the other timers that should fire.&lt;/p&gt;

&lt;p&gt;About storing the {{ScheduledFuture}}s. That&apos;s seems tricky. If we don&apos;t do the coalescing we have an additional map that we always have to check. If we do coalescing then we have to keep track of how many timers are coalesced into one timer before we can cancel the future.&lt;/p&gt;</comment>
                            <comment id="15230891" author="knaufk" created="Thu, 7 Apr 2016 19:24:51 +0000"  >&lt;p&gt;I have a first draft here: &lt;a href=&quot;https://github.com/knaufk/flink/tree/FLINK-3669&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/knaufk/flink/tree/FLINK-3669&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I decided to go for timer coalescing. Basically I am using a &lt;tt&gt;MultiSet&lt;/tt&gt; for the Timers instead of the &lt;tt&gt;Set&lt;/tt&gt; now, to keep track of the count of equivalent Timers. I am happy about comments. Surely there are test missing.&lt;/p&gt;

&lt;p&gt;On thing we could think about is making the granularity of the coalescing configurable, i.e. coalescing all timer wihtin in 10ms or so, but this is pretty optional I think. &lt;/p&gt;</comment>
                            <comment id="15232228" author="knaufk" created="Fri, 8 Apr 2016 14:08:02 +0000"  >&lt;p&gt;Is WindowCheckpointingIT the right place to put a test of restore/snapshot state? Generally, are there any testing guidlines? &lt;/p&gt;</comment>
                            <comment id="15234552" author="aljoscha" created="Mon, 11 Apr 2016 06:29:05 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
I&apos;ll be looking at your code today.&lt;/p&gt;

&lt;p&gt;For the tests, the idea is to put tests that verify the interplay of the complete system into an *ITCase and smaller, self-contained tests into a *Test. Normally ITCases also take a lot longer to execute.&lt;/p&gt;</comment>
                            <comment id="15236970" author="aljoscha" created="Tue, 12 Apr 2016 10:32:58 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
I finally had a look at your code. It looks good but the timer coalescing is only local to one key, i.e. if two different keys register a timer for time t we still register two timers on the &lt;tt&gt;ScheduledThreadPoolExecutor&lt;/tt&gt;. Have you had a chance to test it with your job where you originally discovered the problem that the timers are not garbage collected? Maybe with the timer cleanup it is already sufficient without doing coalescing across keys.&lt;/p&gt;
</comment>
                            <comment id="15240925" author="knaufk" created="Thu, 14 Apr 2016 10:21:36 +0000"  >&lt;p&gt;Nope, sorry I do not think I will have the time in the next week &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I think it should work already though.&lt;/p&gt;

&lt;p&gt;Anyway, you are right, I will extend the timer coalescing to work across keys. I think that way it is the cleanest. &lt;/p&gt;</comment>
                            <comment id="15241151" author="aljoscha" created="Thu, 14 Apr 2016 13:31:02 +0000"  >&lt;p&gt;No worries, we all have plenty to do. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15253557" author="knaufk" created="Fri, 22 Apr 2016 08:51:09 +0000"  >&lt;p&gt;Aljoscha, could you have a  look at &lt;a href=&quot;https://github.com/knaufk/flink/tree/FLINK-3669&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/knaufk/flink/tree/FLINK-3669&lt;/a&gt;. This hopefully does timer coalescing across windows. I am still planning to add some tests, but hopefully I can make till the 1.0.3 release. Let&apos;s see. Not sure why Travis is failing for 1.0 and 2.4.1, but it seems to be unrelated to the changes.&lt;/p&gt;</comment>
                            <comment id="15253601" author="aljoscha" created="Fri, 22 Apr 2016 09:19:39 +0000"  >&lt;p&gt;I&apos;m checking it out.&lt;/p&gt;</comment>
                            <comment id="15253604" author="aljoscha" created="Fri, 22 Apr 2016 09:21:13 +0000"  >&lt;p&gt;Btw, in the future if you reference me like this &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=aljoscha&quot; class=&quot;user-hover&quot; rel=&quot;aljoscha&quot;&gt;aljoscha&lt;/a&gt; or this &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=knaufk&quot; class=&quot;user-hover&quot; rel=&quot;knaufk&quot;&gt;knaufk&lt;/a&gt; I&apos;ll get a more direct notification.&lt;/p&gt;</comment>
                            <comment id="15253666" author="aljoscha" created="Fri, 22 Apr 2016 09:56:26 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
it&apos;s almost done but I think we need both the &lt;tt&gt;processingTimeTimers&lt;/tt&gt; set and the &lt;tt&gt;processingTimeTimerTimestamps&lt;/tt&gt; MultiSet. The former is used to not add repeatedly to the queue while the latter is used for not registering a lot of timers at &lt;tt&gt;StreamTask&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;As it is now in &lt;tt&gt;registerProcessingTimeTimer&lt;/tt&gt;:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void registerProcessingTimeTimer(&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; time) {
    Timer&amp;lt;K, W&amp;gt; timer = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Timer&amp;lt;&amp;gt;(time, key, window);
    &lt;span class=&quot;code-comment&quot;&gt;//If &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; is the first timer added &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; timestamp (per key and window) register a TriggerTask and add Timer to Queue
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (processingTimeTimerTimestamps.add(time,1) == 0) {
        processingTimeTimersQueue.add(timer);
        ScheduledFuture&amp;lt;?&amp;gt; scheduledFuture= getRuntimeContext().registerTimer(time, WindowOperator.&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;);
        processingTimeTimerFutures.put(time, scheduledFuture);
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;we correctly schedule only one timer at the &lt;tt&gt;StreamTask&lt;/tt&gt; per timestamp but we also only schedule one timer in the queue. If we register a timer for the same timestamp from multiple keys we ignore the timers for all but the first key to register. I think it should be:&lt;/p&gt;
 &lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void registerProcessingTimeTimer(&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; time) {
    Timer&amp;lt;K, W&amp;gt; timer = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Timer&amp;lt;&amp;gt;(time, key, window);

    &lt;span class=&quot;code-comment&quot;&gt;// make sure we only put one timer per key into the queue
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (processingTimeTimers.add(timer)) {
        processingTimeTimersQueue.add(timer);

        &lt;span class=&quot;code-comment&quot;&gt;//If &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; is the first timer added &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; timestamp register a TriggerTask
&lt;/span&gt;        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (processingTimeTimerTimestamps.add(time, 1) == 0) {
            ScheduledFuture&amp;lt;?&amp;gt; scheduledFuture= getRuntimeContext().registerTimer(time, WindowOperator.&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;);
            processingTimeTimerFutures.put(time, scheduledFuture);
        }
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;but man, this stuff is tricky to figure out... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15258912" author="knaufk" created="Tue, 26 Apr 2016 21:01:15 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=aljoscha&quot; class=&quot;user-hover&quot; rel=&quot;aljoscha&quot;&gt;aljoscha&lt;/a&gt; Hmpf. You&apos;re right. I was actually a little bit suspicious, that I did not need any additional state &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Anyway, I pushed a new version. This time also with modifications to StreamTask to set deleteOnCancelPolicy(true). &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/knaufk/flink/tree/FLINK-3669&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/knaufk/flink/tree/FLINK-3669&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Aside: A lot of my Travis-Builds fail with a compilation problem in flink-connector-elasticsearch2 even on master (e.g. &lt;a href=&quot;https://travis-ci.org/knaufk/flink/builds/125920011&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://travis-ci.org/knaufk/flink/builds/125920011&lt;/a&gt; 3 und 5). What&apos;s the reason?&lt;/p&gt;</comment>
                            <comment id="15260086" author="aljoscha" created="Wed, 27 Apr 2016 13:01:21 +0000"  >&lt;p&gt;Thanks! I&apos;ll have a look at your branch. For the test-stability, I think there is some problem with the maven caches on Travis. We&apos;re waiting for the Infra team to respond.&lt;/p&gt;</comment>
                            <comment id="15260171" author="aljoscha" created="Wed, 27 Apr 2016 13:46:39 +0000"  >&lt;p&gt;I think we have a winner now &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Could you also test whether it solves your problem when running your job?&lt;/p&gt;

&lt;p&gt;It&apos;s also cool that you added a test for this. I changed it a bit to go through the complete checkpointing and operator lifecycle:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;@Test
	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void testRestoreAndSnapshotAreInSync() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {

		&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; WINDOW_SIZE = 3;
		&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; WINDOW_SLIDE = 1;

		TypeInformation&amp;lt;Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;&amp;gt; inputType = TypeInfoParser.parse(&lt;span class=&quot;code-quote&quot;&gt;&quot;Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;&quot;&lt;/span&gt;);

		ReducingStateDescriptor&amp;lt;Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;&amp;gt; stateDesc = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ReducingStateDescriptor&amp;lt;&amp;gt;(&lt;span class=&quot;code-quote&quot;&gt;&quot;window-contents&quot;&lt;/span&gt;,
				&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SumReducer(),
				inputType.createSerializer(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ExecutionConfig()));

		WindowOperator&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;, Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;, Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;, TimeWindow&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt; = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; WindowOperator&amp;lt;&amp;gt;(
				SlidingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS), Time.of(WINDOW_SLIDE, TimeUnit.SECONDS)),
				&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TimeWindow.Serializer(),
				&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TupleKeySelector(),
				BasicTypeInfo.STRING_TYPE_INFO.createSerializer(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ExecutionConfig()),
				stateDesc,
				&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; InternalSingleValueWindowFunction&amp;lt;&amp;gt;(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; PassThroughWindowFunction&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, TimeWindow, Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;&amp;gt;()),
				EventTimeTrigger.create());


		OneInputStreamOperatorTestHarness&amp;lt;Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;, Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;&amp;gt; testHarness =
				&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;);

		testHarness.configureForKeyedStream(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);

		&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;.setInputType(inputType, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ExecutionConfig());
		testHarness.open();

		WindowOperator.Timer&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, TimeWindow&amp;gt; timer1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; WindowOperator.Timer&amp;lt;&amp;gt;(1L, &lt;span class=&quot;code-quote&quot;&gt;&quot;key1&quot;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TimeWindow(1L, 2L));
		WindowOperator.Timer&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, TimeWindow&amp;gt; timer2 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; WindowOperator.Timer&amp;lt;&amp;gt;(3L, &lt;span class=&quot;code-quote&quot;&gt;&quot;key1&quot;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TimeWindow(1L, 2L));
		WindowOperator.Timer&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, TimeWindow&amp;gt; timer3 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; WindowOperator.Timer&amp;lt;&amp;gt;(2L, &lt;span class=&quot;code-quote&quot;&gt;&quot;key1&quot;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TimeWindow(1L, 2L));
		&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;.processingTimeTimers.add(timer1);
		&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;.processingTimeTimers.add(timer2);
		&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;.processingTimeTimers.add(timer3);
		&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;.processingTimeTimersQueue.add(timer1);
		&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;.processingTimeTimersQueue.add(timer2);
		&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;.processingTimeTimersQueue.add(timer3);

		&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;.processingTimeTimerTimestamps.add(1L, 10);
		&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;.processingTimeTimerTimestamps.add(2L, 5);
		&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;.processingTimeTimerTimestamps.add(3L, 1);


		StreamTaskState snapshot = testHarness.snapshot(0, 0);

		WindowOperator&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;, Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;, Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;, TimeWindow&amp;gt; otherOperator = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; WindowOperator&amp;lt;&amp;gt;(
				SlidingEventTimeWindows.of(Time.of(WINDOW_SIZE, TimeUnit.SECONDS), Time.of(WINDOW_SLIDE, TimeUnit.SECONDS)),
				&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TimeWindow.Serializer(),
				&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TupleKeySelector(),
				BasicTypeInfo.STRING_TYPE_INFO.createSerializer(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ExecutionConfig()),
				stateDesc,
				&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; InternalSingleValueWindowFunction&amp;lt;&amp;gt;(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; PassThroughWindowFunction&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, TimeWindow, Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;&amp;gt;()),
				EventTimeTrigger.create());

		OneInputStreamOperatorTestHarness&amp;lt;Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;, Tuple2&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;&amp;gt; otherTestHarness =
				&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(otherOperator);

		otherTestHarness.configureForKeyedStream(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TupleKeySelector(), BasicTypeInfo.STRING_TYPE_INFO);
		otherOperator.setInputType(inputType, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ExecutionConfig());

		otherTestHarness.setup();
		otherTestHarness.restore(snapshot, 0);
		otherTestHarness.open();

		Assert.assertEquals(&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;.processingTimeTimers, otherOperator.processingTimeTimers);
		Assert.assertArrayEquals(&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;.processingTimeTimersQueue.toArray(), otherOperator.processingTimeTimersQueue.toArray());
		Assert.assertEquals(&lt;span class=&quot;code-keyword&quot;&gt;operator&lt;/span&gt;.processingTimeTimerTimestamps, otherOperator.processingTimeTimerTimestamps);
	}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The test was good already but this is just something I would know since I wrote the test harnesses and the other operator tests. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; This way, we also don&apos;t need the special &lt;tt&gt;restoreStateFrom&lt;/tt&gt; and &lt;tt&gt;snapshotStateTo&lt;/tt&gt; methods.&lt;/p&gt;

&lt;p&gt;Will you open a PR?&lt;/p&gt;</comment>
                            <comment id="15260431" author="knaufk" created="Wed, 27 Apr 2016 16:30:59 +0000"  >&lt;p&gt;I made the changes as suggested, and will open a PR after the travis build later this evening. &lt;/p&gt;

&lt;p&gt;Unfortunately, I will not be able to test it with the original application (customer code).&lt;/p&gt;

&lt;p&gt;I could try to reproduce the issue locally and test it with the new version, but this will take at least till next weekend as I can only do that on my own time.&lt;/p&gt;</comment>
                            <comment id="15261744" author="aljoscha" created="Thu, 28 Apr 2016 08:25:39 +0000"  >&lt;p&gt;Thanks! Once you open the PR I will write a simple application to check how it behaves.&lt;/p&gt;</comment>
                            <comment id="15262000" author="knaufk" created="Thu, 28 Apr 2016 11:27:56 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=aljoscha&quot; class=&quot;user-hover&quot; rel=&quot;aljoscha&quot;&gt;aljoscha&lt;/a&gt; I opened a PR&lt;/p&gt;</comment>
                            <comment id="15262013" author="aljoscha" created="Thu, 28 Apr 2016 11:40:34 +0000"  >&lt;p&gt;Thanks &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Quick remark: if you include the Jira issue number in the PR title it gets linked here, i.e. &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-3669&quot; title=&quot;WindowOperator registers a lot of timers at StreamTask&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-3669&quot;&gt;&lt;del&gt;FLINK-3669&lt;/del&gt;&lt;/a&gt; Timer coalescing across keys and cleanup of unused trigger tasks&quot;&lt;/p&gt;</comment>
                            <comment id="15262485" author="knaufk" created="Thu, 28 Apr 2016 16:44:55 +0000"  >&lt;p&gt;[&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=aljoscha&quot; class=&quot;user-hover&quot; rel=&quot;aljoscha&quot;&gt;aljoscha&lt;/a&gt; Thanks, will do the next time. &lt;/p&gt;

&lt;p&gt;I tried to reproduce the issue locally with a small example &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; and got some unexpected behaviour. In the example I would not expect any output, as the processing timers are deleted way before they would trigger, but still (at least in my IDE) many windows are fired. As this only happens in &quot;high throughput&quot; scenarios I guess it is some scheduling problem, i.e. the thread which deletes the timers is not scheduled before the timer is triggered. What do you think?&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; &lt;a href=&quot;https://gist.github.com/knaufk/8870f4e7f59ed9586666c579d1d2344c&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://gist.github.com/knaufk/8870f4e7f59ed9586666c579d1d2344c&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15263974" author="aljoscha" created="Fri, 29 Apr 2016 12:21:11 +0000"  >&lt;p&gt;Ah, in the custom trigger the &lt;tt&gt;oldTimestamp&lt;/tt&gt; field is problematic. One &lt;tt&gt;Trigger&lt;/tt&gt; instance is used for all the different keys, this means that the field will change in between &lt;tt&gt;onElement()&lt;/tt&gt; calls for the same key if &lt;tt&gt;onElement()&lt;/tt&gt; is called in the meantime for a different key.&lt;/p&gt;

&lt;p&gt;For the timestamp a &lt;tt&gt;ValueState&lt;/tt&gt; could be used, the states are kept separately for each key. For an example, &lt;tt&gt;CountTrigger&lt;/tt&gt; is good, it&apos;s also the only &lt;tt&gt;Trigger&lt;/tt&gt; we currently have in Flink that uses trigger state.&lt;/p&gt;</comment>
                            <comment id="15264132" author="knaufk" created="Fri, 29 Apr 2016 14:43:01 +0000"  >&lt;p&gt;Hmpf, of course...&lt;/p&gt;</comment>
                            <comment id="15266509" author="aljoscha" created="Mon, 2 May 2016 12:30:09 +0000"  >&lt;p&gt;Is the problem gone with changing this? If yes, I&apos;d like to merge the PR then, it&apos;s a good fix for the case when users register/delete a lot of timers.&lt;/p&gt;</comment>
                            <comment id="15266976" author="knaufk" created="Mon, 2 May 2016 17:00:20 +0000"  >&lt;p&gt;The problem in the gist, yes. As I said, I could not test with the original application.&lt;/p&gt;</comment>
                            <comment id="15268419" author="aljoscha" created="Tue, 3 May 2016 09:26:38 +0000"  >&lt;p&gt;Ok, I think it&apos;s good to merge then. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15268754" author="aljoscha" created="Tue, 3 May 2016 13:57:09 +0000"  >&lt;p&gt;Fixed in &lt;a href=&quot;https://github.com/apache/flink/commit/e7586c3b2d995be164100919d7c04db003a71a90&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/commit/e7586c3b2d995be164100919d7c04db003a71a90&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=uce&quot; class=&quot;user-hover&quot; rel=&quot;uce&quot;&gt;uce&lt;/a&gt; should I also put this on the release branch?&lt;/p&gt;</comment>
                            <comment id="15270270" author="uce" created="Wed, 4 May 2016 07:51:40 +0000"  >&lt;p&gt;Yes, sir.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            9 years, 28 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2v9in:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>