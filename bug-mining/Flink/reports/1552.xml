<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:27:27 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-5874] Reject arrays as keys in DataStream API to avoid inconsistent hashing</title>
                <link>https://issues.apache.org/jira/browse/FLINK-5874</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;This issue has been reported on the mailing list twice:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;a href=&quot;http://apache-flink-user-mailing-list-archive.2336050.n4.nabble.com/Previously-working-job-fails-on-Flink-1-2-0-td11741.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://apache-flink-user-mailing-list-archive.2336050.n4.nabble.com/Previously-working-job-fails-on-Flink-1-2-0-td11741.html&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://apache-flink-user-mailing-list-archive.2336050.n4.nabble.com/Arrays-values-in-keyBy-td7530.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://apache-flink-user-mailing-list-archive.2336050.n4.nabble.com/Arrays-values-in-keyBy-td7530.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The problem is the following: We are using just Key[].hashCode() to compute the hash when shuffling data. Java&apos;s default hashCode() implementation doesn&apos;t take the arrays contents into account, but the memory address.&lt;br/&gt;
This leads to different hash code on the sender and receiver side.&lt;br/&gt;
In Flink 1.1 this means that the data is shuffled randomly and not keyed, and in Flink 1.2 the keygroups code detect a violation of the hashing.&lt;/p&gt;

&lt;p&gt;The proper fix of the problem would be to rely on Flink&apos;s &lt;tt&gt;TypeComparator&lt;/tt&gt; class, which has a type-specific hashing function. But introducing this change would break compatibility with existing code.&lt;br/&gt;
I&apos;ll file a JIRA for the 2.0 changes for that fix.&lt;/p&gt;

&lt;p&gt;For 1.2.1 and 1.3.0 we should at least reject arrays as keys.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13044907">FLINK-5874</key>
            <summary>Reject arrays as keys in DataStream API to avoid inconsistent hashing</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kkl0u">Kostas Kloudas</assignee>
                                    <reporter username="rmetzger">Robert Metzger</reporter>
                        <labels>
                    </labels>
                <created>Tue, 21 Feb 2017 17:36:23 +0000</created>
                <updated>Mon, 16 Mar 2020 15:37:37 +0000</updated>
                            <resolved>Fri, 10 Mar 2017 22:20:57 +0000</resolved>
                                    <version>1.1.4</version>
                    <version>1.2.0</version>
                                                    <component>API / DataStream</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="15903423" author="githubbot" created="Thu, 9 Mar 2017 17:17:36 +0000"  >&lt;p&gt;GitHub user kl0u opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5874&quot; title=&quot;Reject arrays as keys in DataStream API to avoid inconsistent hashing&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5874&quot;&gt;&lt;del&gt;FLINK-5874&lt;/del&gt;&lt;/a&gt; Restrict key types in the DataStream API.&lt;/p&gt;

&lt;p&gt;    Rejects a type from being a key in `DataStream.keyBy()` if it is:&lt;br/&gt;
    1. it is a POJO type but does not override the `hashCode()` and&lt;br/&gt;
       relies on the `Object.hashCode()` implementation.&lt;br/&gt;
    2. it is an array of any type.&lt;/p&gt;

&lt;p&gt;    This was also discussed with @fhueske &lt;/p&gt;

&lt;p&gt;    R @aljoscha &lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/kl0u/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/kl0u/flink&lt;/a&gt; array-keys&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #3501&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit bd00f9d37d5e3e1960b8bf1fff506293784b3039&lt;br/&gt;
Author: kl0u &amp;lt;kkloudas@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-03-08T11:11:07Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5874&quot; title=&quot;Reject arrays as keys in DataStream API to avoid inconsistent hashing&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5874&quot;&gt;&lt;del&gt;FLINK-5874&lt;/del&gt;&lt;/a&gt; Restrict key types in the DataStream API.&lt;/p&gt;

&lt;p&gt;    Reject a type from being a key in keyBy() if it is:&lt;br/&gt;
    1. it is a POJO type but does not override the hashCode() and&lt;br/&gt;
       relies on the Object.hashCode() implementation.&lt;br/&gt;
    2. it is an array of any type.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15903624" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105239687&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105239687&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/KeyedStream.java &amp;#8212;&lt;br/&gt;
    @@ -114,9 +121,53 @@ public KeyedStream(DataStream&amp;lt;T&amp;gt; dataStream, KeySelector&amp;lt;T, KEY&amp;gt; keySelector, Ty&lt;br/&gt;
     				dataStream.getTransformation(),&lt;br/&gt;
     				new KeyGroupStreamPartitioner&amp;lt;&amp;gt;(keySelector, StreamGraphGenerator.DEFAULT_LOWER_BOUND_MAX_PARALLELISM)));&lt;br/&gt;
     		this.keySelector = keySelector;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.keyType = keyType;&lt;br/&gt;
    +		this.keyType = validateKeyType(keyType);&lt;br/&gt;
     	}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
    +	private TypeInformation&amp;lt;KEY&amp;gt; validateKeyType(TypeInformation&amp;lt;KEY&amp;gt; keyType) {&lt;br/&gt;
    +		Stack&amp;lt;TypeInformation&amp;lt;?&amp;gt;&amp;gt; stack = new Stack&amp;lt;&amp;gt;();&lt;br/&gt;
    +		stack.push(keyType);&lt;br/&gt;
    +&lt;br/&gt;
    +		while (!stack.isEmpty()) {&lt;br/&gt;
    +			TypeInformation&amp;lt;?&amp;gt; typeInfo = stack.pop();&lt;br/&gt;
    +&lt;br/&gt;
    +			if (!validateKeyTypeIsHashable(typeInfo)) {&lt;br/&gt;
    +				throw new InvalidProgramException(&quot;This type (&quot; + keyType + &quot;) cannot be used as key.&quot;);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Let&apos;s include ```typeInfo``` in this exception as well to narrow it down for the user. We may even want to delay the exception until we scanned the entire type and report all invalid keys at once.&lt;/p&gt;</comment>
                            <comment id="15903625" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105240608&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105240608&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/KeyedStream.java &amp;#8212;&lt;br/&gt;
    @@ -114,9 +121,53 @@ public KeyedStream(DataStream&amp;lt;T&amp;gt; dataStream, KeySelector&amp;lt;T, KEY&amp;gt; keySelector, Ty&lt;br/&gt;
     				dataStream.getTransformation(),&lt;br/&gt;
     				new KeyGroupStreamPartitioner&amp;lt;&amp;gt;(keySelector, StreamGraphGenerator.DEFAULT_LOWER_BOUND_MAX_PARALLELISM)));&lt;br/&gt;
     		this.keySelector = keySelector;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.keyType = keyType;&lt;br/&gt;
    +		this.keyType = validateKeyType(keyType);&lt;br/&gt;
     	}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
    +	private TypeInformation&amp;lt;KEY&amp;gt; validateKeyType(TypeInformation&amp;lt;KEY&amp;gt; keyType) {&lt;br/&gt;
    +		Stack&amp;lt;TypeInformation&amp;lt;?&amp;gt;&amp;gt; stack = new Stack&amp;lt;&amp;gt;();&lt;br/&gt;
    +		stack.push(keyType);&lt;br/&gt;
    +&lt;br/&gt;
    +		while (!stack.isEmpty()) {&lt;br/&gt;
    +			TypeInformation&amp;lt;?&amp;gt; typeInfo = stack.pop();&lt;br/&gt;
    +&lt;br/&gt;
    +			if (!validateKeyTypeIsHashable(typeInfo)) &lt;/p&gt;
{
    +				throw new InvalidProgramException(&quot;This type (&quot; + keyType + &quot;) cannot be used as key.&quot;);
    +			}
&lt;p&gt;    +			&lt;br/&gt;
    +			if (typeInfo instanceof TupleTypeInfoBase) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				for (int i = 0; i &amp;lt; typeInfo.getArity(); i++) {
    +					stack.push(((TupleTypeInfoBase) typeInfo).getTypeAt(i));	
    +				}    +			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +		}&lt;br/&gt;
    +		return keyType;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Validates that a given type of element (as encoded by the provided &lt;/p&gt;
{@link TypeInformation}
&lt;p&gt;) can be&lt;br/&gt;
    +	 * used as a key in the &lt;/p&gt;
{@code DataStream.keyBy()}
&lt;p&gt; operation.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @return &lt;/p&gt;
{@code false}
&lt;p&gt; if:&lt;br/&gt;
    +	 * &amp;lt;ol&amp;gt;&lt;br/&gt;
    +	 *     &amp;lt;li&amp;gt;it is a POJO type but does not override the &lt;/p&gt;
{@link #hashCode()}
&lt;p&gt; method and relies on&lt;br/&gt;
    +	 *     the &lt;/p&gt;
{@link Object#hashCode()}
&lt;p&gt; implementation.&amp;lt;/li&amp;gt;&lt;br/&gt;
    +	 *     &amp;lt;li&amp;gt;it is an array of any type (see &lt;/p&gt;
{@link PrimitiveArrayTypeInfo}
&lt;p&gt;, &lt;/p&gt;
{@link BasicArrayTypeInfo}
&lt;p&gt;,&lt;br/&gt;
    +	 *     &lt;/p&gt;
{@link ObjectArrayTypeInfo}
&lt;p&gt;).&amp;lt;/li&amp;gt;&lt;br/&gt;
    +	 * &amp;lt;/ol&amp;gt;,&lt;br/&gt;
    +	 * &lt;/p&gt;
{@code true}
&lt;p&gt; otherwise.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private boolean validateKeyTypeIsHashable(TypeInformation&amp;lt;?&amp;gt; type) {&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			return (type instanceof PojoTypeInfo) ?&lt;br/&gt;
    +					!type.getTypeClass().getMethod(&quot;hashCode&quot;).getDeclaringClass().equals(Object.class) :&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    this method would be more readable by not inverting here, and returning true as the default.&lt;/p&gt;</comment>
                            <comment id="15903626" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105238457&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105238457&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public int[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +				int[] ks = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +				for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +					ks[i] = value.f0[i];
    +				}
&lt;p&gt;    +				return ks;&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testBasicArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value.f0;
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testObjectArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public TestClass[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +						TestClass[] ks = new TestClass&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +						for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +							ks[i] = new TestClass(value.f0[i]);
    +						}
&lt;p&gt;    +						return ks;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		ObjectArrayTypeInfo&amp;lt;TestClass[], TestClass&amp;gt; keyTypeInfo = ObjectArrayTypeInfo.getInfoFor(&lt;br/&gt;
    +				TestClass[].class, new GenericTypeInfo&amp;lt;&amp;gt;(TestClass.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, keyTypeInfo);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private &amp;lt;K&amp;gt; void testKeyRejection(KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, K&amp;gt; keySelector, TypeInformation&amp;lt;K&amp;gt; expectedKeyType) {&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] &lt;/p&gt;
{1, 2}, &quot;barfoo&quot;)&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(expectedKeyType, TypeExtractor.getKeySelectorTypes(keySelector, input.getType()));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedKeyType + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : POJOs&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJONestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] {1, 2}
&lt;p&gt;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple1&amp;lt;int[]&amp;gt;&amp;gt;(&lt;br/&gt;
    +				PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(&quot;id&quot;);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNestedArrayWorkArround() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;POJOwithHashCode, POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public POJOwithHashCode getKey(POJOwithHashCode value) throws Exception {
    +				return value;
    +			}&lt;br/&gt;
    +		}).addSink(new SinkFunction&amp;lt;POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void invoke(POJOwithHashCode value) throws Exception {&lt;br/&gt;
    +				Assert.assertEquals(value.getId(), new int[]{1, 2}
&lt;p&gt;);&lt;br/&gt;
    +			}&lt;br/&gt;
    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJOnoHashCodeKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt;() {&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public POJOnoHashCode getKey(POJOnoHashCode value) throws Exception &lt;/p&gt;
{
    +						return value;
    +					}
&lt;p&gt;    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOnoHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOnoHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : Tuples&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testTupleNestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] {1, 2}
&lt;p&gt;, &quot;test-test&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt;(&lt;br/&gt;
    +				BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;Tuple2&amp;lt;Integer[],String&amp;gt;, Tuple2&amp;lt;Integer[],String&amp;gt;&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Tuple2&amp;lt;Integer[], String&amp;gt; getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value;
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveKeyRejection() throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    what do we actually verify here?&lt;/p&gt;</comment>
                            <comment id="15903627" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105240820&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105240820&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/KeyedStream.java &amp;#8212;&lt;br/&gt;
    @@ -114,9 +121,53 @@ public KeyedStream(DataStream&amp;lt;T&amp;gt; dataStream, KeySelector&amp;lt;T, KEY&amp;gt; keySelector, Ty&lt;br/&gt;
     				dataStream.getTransformation(),&lt;br/&gt;
     				new KeyGroupStreamPartitioner&amp;lt;&amp;gt;(keySelector, StreamGraphGenerator.DEFAULT_LOWER_BOUND_MAX_PARALLELISM)));&lt;br/&gt;
     		this.keySelector = keySelector;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.keyType = keyType;&lt;br/&gt;
    +		this.keyType = validateKeyType(keyType);&lt;br/&gt;
     	}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
    +	private TypeInformation&amp;lt;KEY&amp;gt; validateKeyType(TypeInformation&amp;lt;KEY&amp;gt; keyType) {&lt;br/&gt;
    +		Stack&amp;lt;TypeInformation&amp;lt;?&amp;gt;&amp;gt; stack = new Stack&amp;lt;&amp;gt;();&lt;br/&gt;
    +		stack.push(keyType);&lt;br/&gt;
    +&lt;br/&gt;
    +		while (!stack.isEmpty()) {&lt;br/&gt;
    +			TypeInformation&amp;lt;?&amp;gt; typeInfo = stack.pop();&lt;br/&gt;
    +&lt;br/&gt;
    +			if (!validateKeyTypeIsHashable(typeInfo)) &lt;/p&gt;
{
    +				throw new InvalidProgramException(&quot;This type (&quot; + keyType + &quot;) cannot be used as key.&quot;);
    +			}
&lt;p&gt;    +			&lt;br/&gt;
    +			if (typeInfo instanceof TupleTypeInfoBase) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				for (int i = 0; i &amp;lt; typeInfo.getArity(); i++) {
    +					stack.push(((TupleTypeInfoBase) typeInfo).getTypeAt(i));	
    +				}    +			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +		}&lt;br/&gt;
    +		return keyType;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Validates that a given type of element (as encoded by the provided &lt;/p&gt;
{@link TypeInformation}
&lt;p&gt;) can be&lt;br/&gt;
    +	 * used as a key in the &lt;/p&gt;
{@code DataStream.keyBy()}
&lt;p&gt; operation.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @return &lt;/p&gt;
{@code false}
&lt;p&gt; if:&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I would shorten this to read ```returns true if the type overrides the hashcode implementation```. The details can be container in the general javadoc of the method.&lt;/p&gt;</comment>
                            <comment id="15903628" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105239060&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105239060&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    First time I&apos;m seeing this pattern and i can&apos;t help but feel that a simple try-catch block would be more readable.&lt;/p&gt;</comment>
                            <comment id="15903629" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105241562&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105241562&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public int[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +				int[] ks = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +				for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +					ks[i] = value.f0[i];
    +				}
&lt;p&gt;    +				return ks;&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testBasicArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value.f0;
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testObjectArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public TestClass[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +						TestClass[] ks = new TestClass&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +						for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +							ks[i] = new TestClass(value.f0[i]);
    +						}
&lt;p&gt;    +						return ks;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		ObjectArrayTypeInfo&amp;lt;TestClass[], TestClass&amp;gt; keyTypeInfo = ObjectArrayTypeInfo.getInfoFor(&lt;br/&gt;
    +				TestClass[].class, new GenericTypeInfo&amp;lt;&amp;gt;(TestClass.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, keyTypeInfo);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private &amp;lt;K&amp;gt; void testKeyRejection(KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, K&amp;gt; keySelector, TypeInformation&amp;lt;K&amp;gt; expectedKeyType) {&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] &lt;/p&gt;
{1, 2}, &quot;barfoo&quot;)&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(expectedKeyType, TypeExtractor.getKeySelectorTypes(keySelector, input.getType()));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedKeyType + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : POJOs&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJONestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] {1, 2}
&lt;p&gt;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple1&amp;lt;int[]&amp;gt;&amp;gt;(&lt;br/&gt;
    +				PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(&quot;id&quot;);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNestedArrayWorkArround() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;POJOwithHashCode, POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public POJOwithHashCode getKey(POJOwithHashCode value) throws Exception {
    +				return value;
    +			}&lt;br/&gt;
    +		}).addSink(new SinkFunction&amp;lt;POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void invoke(POJOwithHashCode value) throws Exception {&lt;br/&gt;
    +				Assert.assertEquals(value.getId(), new int[]{1, 2}
&lt;p&gt;);&lt;br/&gt;
    +			}&lt;br/&gt;
    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJOnoHashCodeKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt;() {&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public POJOnoHashCode getKey(POJOnoHashCode value) throws Exception &lt;/p&gt;
{
    +						return value;
    +					}
&lt;p&gt;    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOnoHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOnoHashCode(new int[] &lt;/p&gt;
{1, 2}
&lt;p&gt;));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : Tuples&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    this commit will not be seen as it is.&lt;/p&gt;</comment>
                            <comment id="15903630" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105241358&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105241358&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public int[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +				int[] ks = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +				for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +					ks[i] = value.f0[i];
    +				}
&lt;p&gt;    +				return ks;&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testBasicArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value.f0;
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testObjectArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public TestClass[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +						TestClass[] ks = new TestClass&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +						for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +							ks[i] = new TestClass(value.f0[i]);
    +						}
&lt;p&gt;    +						return ks;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		ObjectArrayTypeInfo&amp;lt;TestClass[], TestClass&amp;gt; keyTypeInfo = ObjectArrayTypeInfo.getInfoFor(&lt;br/&gt;
    +				TestClass[].class, new GenericTypeInfo&amp;lt;&amp;gt;(TestClass.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, keyTypeInfo);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private &amp;lt;K&amp;gt; void testKeyRejection(KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, K&amp;gt; keySelector, TypeInformation&amp;lt;K&amp;gt; expectedKeyType) {&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] &lt;/p&gt;
{1, 2}, &quot;barfoo&quot;)&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(expectedKeyType, TypeExtractor.getKeySelectorTypes(keySelector, input.getType()));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedKeyType + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : POJOs&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJONestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] {1, 2}
&lt;p&gt;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple1&amp;lt;int[]&amp;gt;&amp;gt;(&lt;br/&gt;
    +				PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(&quot;id&quot;);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNestedArrayWorkArround() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;POJOwithHashCode, POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public POJOwithHashCode getKey(POJOwithHashCode value) throws Exception {
    +				return value;
    +			}&lt;br/&gt;
    +		}).addSink(new SinkFunction&amp;lt;POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void invoke(POJOwithHashCode value) throws Exception {&lt;br/&gt;
    +				Assert.assertEquals(value.getId(), new int[]{1, 2}
&lt;p&gt;);&lt;br/&gt;
    +			}&lt;br/&gt;
    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJOnoHashCodeKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt;() {&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public POJOnoHashCode getKey(POJOnoHashCode value) throws Exception &lt;/p&gt;
{
    +						return value;
    +					}
&lt;p&gt;    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOnoHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOnoHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : Tuples&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testTupleNestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] {1, 2}
&lt;p&gt;, &quot;test-test&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt;(&lt;br/&gt;
    +				BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;Tuple2&amp;lt;Integer[],String&amp;gt;, Tuple2&amp;lt;Integer[],String&amp;gt;&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Tuple2&amp;lt;Integer[], String&amp;gt; getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value;
    +			}&lt;br/&gt;
    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveKeyRejection() throws Exception {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +		env.setParallelism(1);&lt;br/&gt;
    +		env.setMaxParallelism(1);&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Integer&amp;gt; input = env.fromElements(new Integer(10000));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = IntegerTypeInfo.INT_TYPE_INFO;&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedStream&amp;lt;Integer, Integer&amp;gt; keyedStream = input.keyBy(new KeySelector&amp;lt;Integer, Integer&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer getKey(Integer value) throws Exception {    +				return value;    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(expectedTypeInfo, keyedStream.getKeyType());&lt;br/&gt;
    +&lt;br/&gt;
    +		keyedStream.addSink(new SinkFunction&amp;lt;Integer&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void invoke(Integer value) throws Exception &lt;/p&gt;
{
    +				Assert.assertEquals(10000L, (long) value);
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		env.execute();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static class TestClass {&lt;br/&gt;
    +&lt;br/&gt;
    +		private final int id;&lt;br/&gt;
    +&lt;br/&gt;
    +		TestClass(int id) &lt;/p&gt;
{
    +			this.id = id;
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public static class POJOnoHashCode {&lt;br/&gt;
    +&lt;br/&gt;
    +		private int[] id;&lt;br/&gt;
    +&lt;br/&gt;
    +		public POJOnoHashCode() {}&lt;br/&gt;
    +&lt;br/&gt;
    +		public POJOnoHashCode(int[] id) {    +			this.id = id;    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public int[] getId() &lt;/p&gt;
{
    +			return id;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public void setId(int[] id) &lt;/p&gt;
{
    +			this.id = id;
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public static class POJOwithHashCode {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    You could extend PojoNoHashCode and only implement hashCode.&lt;/p&gt;</comment>
                            <comment id="15903631" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105241140&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105241140&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public int[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +				int[] ks = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +				for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +					ks[i] = value.f0[i];
    +				}
&lt;p&gt;    +				return ks;&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testBasicArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value.f0;
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testObjectArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt; keySelector =&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Do we need a separate class here or could we just throw in an Object[]?&lt;/p&gt;</comment>
                            <comment id="15903632" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105240510&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105240510&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/KeyedStream.java &amp;#8212;&lt;br/&gt;
    @@ -114,9 +121,53 @@ public KeyedStream(DataStream&amp;lt;T&amp;gt; dataStream, KeySelector&amp;lt;T, KEY&amp;gt; keySelector, Ty&lt;br/&gt;
     				dataStream.getTransformation(),&lt;br/&gt;
     				new KeyGroupStreamPartitioner&amp;lt;&amp;gt;(keySelector, StreamGraphGenerator.DEFAULT_LOWER_BOUND_MAX_PARALLELISM)));&lt;br/&gt;
     		this.keySelector = keySelector;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.keyType = keyType;&lt;br/&gt;
    +		this.keyType = validateKeyType(keyType);&lt;br/&gt;
     	}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
    +	private TypeInformation&amp;lt;KEY&amp;gt; validateKeyType(TypeInformation&amp;lt;KEY&amp;gt; keyType) {&lt;br/&gt;
    +		Stack&amp;lt;TypeInformation&amp;lt;?&amp;gt;&amp;gt; stack = new Stack&amp;lt;&amp;gt;();&lt;br/&gt;
    +		stack.push(keyType);&lt;br/&gt;
    +&lt;br/&gt;
    +		while (!stack.isEmpty()) {&lt;br/&gt;
    +			TypeInformation&amp;lt;?&amp;gt; typeInfo = stack.pop();&lt;br/&gt;
    +&lt;br/&gt;
    +			if (!validateKeyTypeIsHashable(typeInfo)) &lt;/p&gt;
{
    +				throw new InvalidProgramException(&quot;This type (&quot; + keyType + &quot;) cannot be used as key.&quot;);
    +			}
&lt;p&gt;    +			&lt;br/&gt;
    +			if (typeInfo instanceof TupleTypeInfoBase) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				for (int i = 0; i &amp;lt; typeInfo.getArity(); i++) {
    +					stack.push(((TupleTypeInfoBase) typeInfo).getTypeAt(i));	
    +				}    +			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +		}&lt;br/&gt;
    +		return keyType;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Validates that a given type of element (as encoded by the provided &lt;/p&gt;
{@link TypeInformation}
&lt;p&gt;) can be&lt;br/&gt;
    +	 * used as a key in the &lt;/p&gt;
{@code DataStream.keyBy()}
&lt;p&gt; operation.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @return &lt;/p&gt;
{@code false}
&lt;p&gt; if:&lt;br/&gt;
    +	 * &amp;lt;ol&amp;gt;&lt;br/&gt;
    +	 *     &amp;lt;li&amp;gt;it is a POJO type but does not override the &lt;/p&gt;
{@link #hashCode()}
&lt;p&gt; method and relies on&lt;br/&gt;
    +	 *     the &lt;/p&gt;
{@link Object#hashCode()}
&lt;p&gt; implementation.&amp;lt;/li&amp;gt;&lt;br/&gt;
    +	 *     &amp;lt;li&amp;gt;it is an array of any type (see &lt;/p&gt;
{@link PrimitiveArrayTypeInfo}
&lt;p&gt;, &lt;/p&gt;
{@link BasicArrayTypeInfo}
&lt;p&gt;,&lt;br/&gt;
    +	 *     &lt;/p&gt;
{@link ObjectArrayTypeInfo}
&lt;p&gt;).&amp;lt;/li&amp;gt;&lt;br/&gt;
    +	 * &amp;lt;/ol&amp;gt;,&lt;br/&gt;
    +	 * &lt;/p&gt;
{@code true}
&lt;p&gt; otherwise.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private boolean validateKeyTypeIsHashable(TypeInformation&amp;lt;?&amp;gt; type) {&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			return (type instanceof PojoTypeInfo) ?&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    we should also simply break this if statement down into multiple blocks.&lt;/p&gt;

&lt;p&gt;    i.e.&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    if (type isntanceof PojoTypeInfo) &lt;/p&gt;
{
    return //find hashCode
    }

&lt;p&gt;    if (tpye instance off XArrayTypeInfo ... ) &lt;/p&gt;
{
     return false;
    }

&lt;p&gt;    return true;&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="15903633" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105239223&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105239223&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java &amp;#8212;&lt;br/&gt;
    @@ -736,7 +736,7 @@ public void restoreState(List&amp;lt;Integer&amp;gt; state) throws Exception {&lt;/p&gt;

&lt;p&gt;     		static final ValueStateDescriptor&amp;lt;Boolean&amp;gt; descriptor = new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;seen&quot;, Boolean.class, false);&lt;br/&gt;
     		private static final long serialVersionUID = 1L;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private ValueState&amp;lt;Boolean&amp;gt; operatorState;&lt;br/&gt;
    +		private transient ValueState&amp;lt;Boolean&amp;gt; operatorState;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    unrelated change.&lt;/p&gt;</comment>
                            <comment id="15903634" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105241262&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105241262&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public int[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +				int[] ks = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +				for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +					ks[i] = value.f0[i];
    +				}
&lt;p&gt;    +				return ks;&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testBasicArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value.f0;
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testObjectArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public TestClass[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +						TestClass[] ks = new TestClass&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +						for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +							ks[i] = new TestClass(value.f0[i]);
    +						}
&lt;p&gt;    +						return ks;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		ObjectArrayTypeInfo&amp;lt;TestClass[], TestClass&amp;gt; keyTypeInfo = ObjectArrayTypeInfo.getInfoFor(&lt;br/&gt;
    +				TestClass[].class, new GenericTypeInfo&amp;lt;&amp;gt;(TestClass.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, keyTypeInfo);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private &amp;lt;K&amp;gt; void testKeyRejection(KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, K&amp;gt; keySelector, TypeInformation&amp;lt;K&amp;gt; expectedKeyType) {&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] &lt;/p&gt;
{1, 2}, &quot;barfoo&quot;)&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(expectedKeyType, TypeExtractor.getKeySelectorTypes(keySelector, input.getType()));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedKeyType + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : POJOs&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJONestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] {1, 2}
&lt;p&gt;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple1&amp;lt;int[]&amp;gt;&amp;gt;(&lt;br/&gt;
    +				PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(&quot;id&quot;);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNestedArrayWorkArround() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;POJOwithHashCode, POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public POJOwithHashCode getKey(POJOwithHashCode value) throws Exception {
    +				return value;
    +			}&lt;br/&gt;
    +		}).addSink(new SinkFunction&amp;lt;POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void invoke(POJOwithHashCode value) throws Exception {&lt;br/&gt;
    +				Assert.assertEquals(value.getId(), new int[]{1, 2}
&lt;p&gt;);&lt;br/&gt;
    +			}&lt;br/&gt;
    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJOnoHashCodeKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt;() {&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public POJOnoHashCode getKey(POJOnoHashCode value) throws Exception &lt;/p&gt;
{
    +						return value;
    +					}
&lt;p&gt;    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOnoHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOnoHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : Tuples&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testTupleNestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] {1, 2}
&lt;p&gt;, &quot;test-test&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt;(&lt;br/&gt;
    +				BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;Tuple2&amp;lt;Integer[],String&amp;gt;, Tuple2&amp;lt;Integer[],String&amp;gt;&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Tuple2&amp;lt;Integer[], String&amp;gt; getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value;
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveKeyRejection() throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    The name should be changed; as it stands i expected that this test verifies that a primitive key is rejected.&lt;/p&gt;</comment>
                            <comment id="15903635" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105241450&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105241450&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public int[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +				int[] ks = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +				for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +					ks[i] = value.f0[i];
    +				}
&lt;p&gt;    +				return ks;&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testBasicArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value.f0;
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testObjectArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public TestClass[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +						TestClass[] ks = new TestClass&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +						for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +							ks[i] = new TestClass(value.f0[i]);
    +						}
&lt;p&gt;    +						return ks;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		ObjectArrayTypeInfo&amp;lt;TestClass[], TestClass&amp;gt; keyTypeInfo = ObjectArrayTypeInfo.getInfoFor(&lt;br/&gt;
    +				TestClass[].class, new GenericTypeInfo&amp;lt;&amp;gt;(TestClass.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, keyTypeInfo);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private &amp;lt;K&amp;gt; void testKeyRejection(KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, K&amp;gt; keySelector, TypeInformation&amp;lt;K&amp;gt; expectedKeyType) {&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] &lt;/p&gt;
{1, 2}, &quot;barfoo&quot;)&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(expectedKeyType, TypeExtractor.getKeySelectorTypes(keySelector, input.getType()));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedKeyType + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : POJOs&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJONestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] {1, 2}
&lt;p&gt;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple1&amp;lt;int[]&amp;gt;&amp;gt;(&lt;br/&gt;
    +				PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(&quot;id&quot;);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNestedArrayWorkArround() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;POJOwithHashCode, POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public POJOwithHashCode getKey(POJOwithHashCode value) throws Exception {
    +				return value;
    +			}&lt;br/&gt;
    +		}).addSink(new SinkFunction&amp;lt;POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void invoke(POJOwithHashCode value) throws Exception {&lt;br/&gt;
    +				Assert.assertEquals(value.getId(), new int[]{1, 2}
&lt;p&gt;);&lt;br/&gt;
    +			}&lt;br/&gt;
    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJOnoHashCodeKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt;() {&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public POJOnoHashCode getKey(POJOnoHashCode value) throws Exception &lt;/p&gt;
{
    +						return value;
    +					}
&lt;p&gt;    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOnoHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOnoHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : Tuples&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testTupleNestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] {1, 2}
&lt;p&gt;, &quot;test-test&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt;(&lt;br/&gt;
    +				BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;Tuple2&amp;lt;Integer[],String&amp;gt;, Tuple2&amp;lt;Integer[],String&amp;gt;&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Tuple2&amp;lt;Integer[], String&amp;gt; getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value;
    +			}&lt;br/&gt;
    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveKeyRejection() throws Exception {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +		env.setParallelism(1);&lt;br/&gt;
    +		env.setMaxParallelism(1);&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Integer&amp;gt; input = env.fromElements(new Integer(10000));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = IntegerTypeInfo.INT_TYPE_INFO;&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedStream&amp;lt;Integer, Integer&amp;gt; keyedStream = input.keyBy(new KeySelector&amp;lt;Integer, Integer&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer getKey(Integer value) throws Exception {    +				return value;    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(expectedTypeInfo, keyedStream.getKeyType());&lt;br/&gt;
    +&lt;br/&gt;
    +		keyedStream.addSink(new SinkFunction&amp;lt;Integer&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void invoke(Integer value) throws Exception &lt;/p&gt;
{
    +				Assert.assertEquals(10000L, (long) value);
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		env.execute();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static class TestClass {&lt;br/&gt;
    +&lt;br/&gt;
    +		private final int id;&lt;br/&gt;
    +&lt;br/&gt;
    +		TestClass(int id) &lt;/p&gt;
{
    +			this.id = id;
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public static class POJOnoHashCode {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    the naming is also inconsistent with the other class; this class name doesn&apos;t contain &quot;with&quot;.&lt;/p&gt;</comment>
                            <comment id="15903636" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105240936&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105240936&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public int[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +				int[] ks = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +				for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +					ks[i] = value.f0[i];
    +				}
&lt;p&gt;    +				return ks;&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testBasicArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value.f0;
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testObjectArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public TestClass[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +						TestClass[] ks = new TestClass&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +						for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +							ks[i] = new TestClass(value.f0[i]);
    +						}
&lt;p&gt;    +						return ks;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		ObjectArrayTypeInfo&amp;lt;TestClass[], TestClass&amp;gt; keyTypeInfo = ObjectArrayTypeInfo.getInfoFor(&lt;br/&gt;
    +				TestClass[].class, new GenericTypeInfo&amp;lt;&amp;gt;(TestClass.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, keyTypeInfo);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private &amp;lt;K&amp;gt; void testKeyRejection(KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, K&amp;gt; keySelector, TypeInformation&amp;lt;K&amp;gt; expectedKeyType) {&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] &lt;/p&gt;
{1, 2}, &quot;barfoo&quot;)&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(expectedKeyType, TypeExtractor.getKeySelectorTypes(keySelector, input.getType()));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedKeyType + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : POJOs&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJONestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] {1, 2}
&lt;p&gt;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple1&amp;lt;int[]&amp;gt;&amp;gt;(&lt;br/&gt;
    +				PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(&quot;id&quot;);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNestedArrayWorkArround() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;POJOwithHashCode, POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public POJOwithHashCode getKey(POJOwithHashCode value) throws Exception {
    +				return value;
    +			}&lt;br/&gt;
    +		}).addSink(new SinkFunction&amp;lt;POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void invoke(POJOwithHashCode value) throws Exception {&lt;br/&gt;
    +				Assert.assertEquals(value.getId(), new int[]{1, 2}
&lt;p&gt;);&lt;br/&gt;
    +			}&lt;br/&gt;
    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJOnoHashCodeKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt;() {&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public POJOnoHashCode getKey(POJOnoHashCode value) throws Exception &lt;/p&gt;
{
    +						return value;
    +					}
&lt;p&gt;    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOnoHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOnoHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : Tuples&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testTupleNestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] {1, 2}
&lt;p&gt;, &quot;test-test&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt;(&lt;br/&gt;
    +				BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;Tuple2&amp;lt;Integer[],String&amp;gt;, Tuple2&amp;lt;Integer[],String&amp;gt;&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Tuple2&amp;lt;Integer[], String&amp;gt; getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value;
    +			}&lt;br/&gt;
    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveKeyRejection() throws Exception {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +		env.setParallelism(1);&lt;br/&gt;
    +		env.setMaxParallelism(1);&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Integer&amp;gt; input = env.fromElements(new Integer(10000));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = IntegerTypeInfo.INT_TYPE_INFO;&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedStream&amp;lt;Integer, Integer&amp;gt; keyedStream = input.keyBy(new KeySelector&amp;lt;Integer, Integer&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer getKey(Integer value) throws Exception {    +				return value;    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(expectedTypeInfo, keyedStream.getKeyType());&lt;br/&gt;
    +&lt;br/&gt;
    +		keyedStream.addSink(new SinkFunction&amp;lt;Integer&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void invoke(Integer value) throws Exception &lt;/p&gt;
{
    +				Assert.assertEquals(10000L, (long) value);
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		env.execute();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static class TestClass {&lt;br/&gt;
    +&lt;br/&gt;
    +		private final int id;&lt;br/&gt;
    +&lt;br/&gt;
    +		TestClass(int id) &lt;/p&gt;
{
    +			this.id = id;
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public static class POJOnoHashCode {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    no being lower case appears to violate the naming convention.&lt;/p&gt;</comment>
                            <comment id="15903637" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105242176&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105242176&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public int[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +				int[] ks = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +				for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +					ks[i] = value.f0[i];
    +				}
&lt;p&gt;    +				return ks;&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testBasicArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value.f0;
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testObjectArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public TestClass[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +						TestClass[] ks = new TestClass&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +						for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +							ks[i] = new TestClass(value.f0[i]);
    +						}
&lt;p&gt;    +						return ks;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		ObjectArrayTypeInfo&amp;lt;TestClass[], TestClass&amp;gt; keyTypeInfo = ObjectArrayTypeInfo.getInfoFor(&lt;br/&gt;
    +				TestClass[].class, new GenericTypeInfo&amp;lt;&amp;gt;(TestClass.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, keyTypeInfo);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private &amp;lt;K&amp;gt; void testKeyRejection(KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, K&amp;gt; keySelector, TypeInformation&amp;lt;K&amp;gt; expectedKeyType) {&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] &lt;/p&gt;
{1, 2}, &quot;barfoo&quot;)&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(expectedKeyType, TypeExtractor.getKeySelectorTypes(keySelector, input.getType()));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedKeyType + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : POJOs&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJONestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] {1, 2}
&lt;p&gt;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple1&amp;lt;int[]&amp;gt;&amp;gt;(&lt;br/&gt;
    +				PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(&quot;id&quot;);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNestedArrayWorkArround() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    The focus of this test appears to be to verify that you can use an array as a key by wrapping it in a Pojo that implements HashCode. (based on the naming).&lt;/p&gt;

&lt;p&gt;    We should probably focus more on the Pojo-with-hashCode implementation part; doesn&apos;t really matter what is contained. We are never checking that anyway.&lt;/p&gt;</comment>
                            <comment id="15903638" author="githubbot" created="Thu, 9 Mar 2017 18:59:52 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105239799&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105239799&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/KeyedStream.java &amp;#8212;&lt;br/&gt;
    @@ -114,9 +121,53 @@ public KeyedStream(DataStream&amp;lt;T&amp;gt; dataStream, KeySelector&amp;lt;T, KEY&amp;gt; keySelector, Ty&lt;br/&gt;
     				dataStream.getTransformation(),&lt;br/&gt;
     				new KeyGroupStreamPartitioner&amp;lt;&amp;gt;(keySelector, StreamGraphGenerator.DEFAULT_LOWER_BOUND_MAX_PARALLELISM)));&lt;br/&gt;
     		this.keySelector = keySelector;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.keyType = keyType;&lt;br/&gt;
    +		this.keyType = validateKeyType(keyType);&lt;br/&gt;
     	}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
    +	private TypeInformation&amp;lt;KEY&amp;gt; validateKeyType(TypeInformation&amp;lt;KEY&amp;gt; keyType) {&lt;br/&gt;
    +		Stack&amp;lt;TypeInformation&amp;lt;?&amp;gt;&amp;gt; stack = new Stack&amp;lt;&amp;gt;();&lt;br/&gt;
    +		stack.push(keyType);&lt;br/&gt;
    +&lt;br/&gt;
    +		while (!stack.isEmpty()) {&lt;br/&gt;
    +			TypeInformation&amp;lt;?&amp;gt; typeInfo = stack.pop();&lt;br/&gt;
    +&lt;br/&gt;
    +			if (!validateKeyTypeIsHashable(typeInfo)) &lt;/p&gt;
{
    +				throw new InvalidProgramException(&quot;This type (&quot; + keyType + &quot;) cannot be used as key.&quot;);
    +			}
&lt;p&gt;    +			&lt;br/&gt;
    +			if (typeInfo instanceof TupleTypeInfoBase) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				for (int i = 0; i &amp;lt; typeInfo.getArity(); i++) {
    +					stack.push(((TupleTypeInfoBase) typeInfo).getTypeAt(i));	
    +				}    +			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +		}&lt;br/&gt;
    +		return keyType;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Validates that a given type of element (as encoded by the provided &lt;/p&gt;
{@link TypeInformation}
&lt;p&gt;) can be&lt;br/&gt;
    +	 * used as a key in the &lt;/p&gt;
{@code DataStream.keyBy()}
&lt;p&gt; operation.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @return &lt;/p&gt;
{@code false}
&lt;p&gt; if:&lt;br/&gt;
    +	 * &amp;lt;ol&amp;gt;&lt;br/&gt;
    +	 *     &amp;lt;li&amp;gt;it is a POJO type but does not override the &lt;/p&gt;
{@link #hashCode()}
&lt;p&gt; method and relies on&lt;br/&gt;
    +	 *     the &lt;/p&gt;
{@link Object#hashCode()}
&lt;p&gt; implementation.&amp;lt;/li&amp;gt;&lt;br/&gt;
    +	 *     &amp;lt;li&amp;gt;it is an array of any type (see &lt;/p&gt;
{@link PrimitiveArrayTypeInfo}
&lt;p&gt;, &lt;/p&gt;
{@link BasicArrayTypeInfo}
&lt;p&gt;,&lt;br/&gt;
    +	 *     &lt;/p&gt;
{@link ObjectArrayTypeInfo}
&lt;p&gt;).&amp;lt;/li&amp;gt;&lt;br/&gt;
    +	 * &amp;lt;/ol&amp;gt;,&lt;br/&gt;
    +	 * &lt;/p&gt;
{@code true}
&lt;p&gt; otherwise.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private boolean validateKeyTypeIsHashable(TypeInformation&amp;lt;?&amp;gt; type) {&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			return (type instanceof PojoTypeInfo) ?&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    ? and : are typically at the start of a new line.&lt;/p&gt;</comment>
                            <comment id="15903639" author="githubbot" created="Thu, 9 Mar 2017 18:59:53 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105238197&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105238197&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public int[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +				int[] ks = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +				for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +					ks[i] = value.f0[i];
    +				}
&lt;p&gt;    +				return ks;&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testBasicArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value.f0;
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testObjectArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public TestClass[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +						TestClass[] ks = new TestClass&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +						for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +							ks[i] = new TestClass(value.f0[i]);
    +						}
&lt;p&gt;    +						return ks;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		ObjectArrayTypeInfo&amp;lt;TestClass[], TestClass&amp;gt; keyTypeInfo = ObjectArrayTypeInfo.getInfoFor(&lt;br/&gt;
    +				TestClass[].class, new GenericTypeInfo&amp;lt;&amp;gt;(TestClass.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, keyTypeInfo);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private &amp;lt;K&amp;gt; void testKeyRejection(KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, K&amp;gt; keySelector, TypeInformation&amp;lt;K&amp;gt; expectedKeyType) {&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] &lt;/p&gt;
{1, 2}, &quot;barfoo&quot;)&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(expectedKeyType, TypeExtractor.getKeySelectorTypes(keySelector, input.getType()));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedKeyType + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : POJOs&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJONestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] {1, 2}
&lt;p&gt;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple1&amp;lt;int[]&amp;gt;&amp;gt;(&lt;br/&gt;
    +				PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(&quot;id&quot;);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNestedArrayWorkArround() {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    type: Arround -&amp;gt; Around&lt;/p&gt;</comment>
                            <comment id="15903645" author="githubbot" created="Thu, 9 Mar 2017 19:02:03 +0000"  >&lt;p&gt;Github user zentol commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    This should work and is well tested, good job. Had a bunch of minor comments, but nothing critical.&lt;/p&gt;</comment>
                            <comment id="15904915" author="githubbot" created="Fri, 10 Mar 2017 11:15:47 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105377617&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105377617&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java &amp;#8212;&lt;br/&gt;
    @@ -736,7 +736,7 @@ public void restoreState(List&amp;lt;Integer&amp;gt; state) throws Exception {&lt;/p&gt;

&lt;p&gt;     		static final ValueStateDescriptor&amp;lt;Boolean&amp;gt; descriptor = new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;seen&quot;, Boolean.class, false);&lt;br/&gt;
     		private static final long serialVersionUID = 1L;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private ValueState&amp;lt;Boolean&amp;gt; operatorState;&lt;br/&gt;
    +		private transient ValueState&amp;lt;Boolean&amp;gt; operatorState;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    true but it is wrong and someone has to fix it at some point.&lt;/p&gt;</comment>
                            <comment id="15904917" author="githubbot" created="Fri, 10 Mar 2017 11:16:59 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105377789&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105377789&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/KeyedStream.java &amp;#8212;&lt;br/&gt;
    @@ -114,9 +121,53 @@ public KeyedStream(DataStream&amp;lt;T&amp;gt; dataStream, KeySelector&amp;lt;T, KEY&amp;gt; keySelector, Ty&lt;br/&gt;
     				dataStream.getTransformation(),&lt;br/&gt;
     				new KeyGroupStreamPartitioner&amp;lt;&amp;gt;(keySelector, StreamGraphGenerator.DEFAULT_LOWER_BOUND_MAX_PARALLELISM)));&lt;br/&gt;
     		this.keySelector = keySelector;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.keyType = keyType;&lt;br/&gt;
    +		this.keyType = validateKeyType(keyType);&lt;br/&gt;
     	}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
    +	private TypeInformation&amp;lt;KEY&amp;gt; validateKeyType(TypeInformation&amp;lt;KEY&amp;gt; keyType) {&lt;br/&gt;
    +		Stack&amp;lt;TypeInformation&amp;lt;?&amp;gt;&amp;gt; stack = new Stack&amp;lt;&amp;gt;();&lt;br/&gt;
    +		stack.push(keyType);&lt;br/&gt;
    +&lt;br/&gt;
    +		while (!stack.isEmpty()) {&lt;br/&gt;
    +			TypeInformation&amp;lt;?&amp;gt; typeInfo = stack.pop();&lt;br/&gt;
    +&lt;br/&gt;
    +			if (!validateKeyTypeIsHashable(typeInfo)) &lt;/p&gt;
{
    +				throw new InvalidProgramException(&quot;This type (&quot; + keyType + &quot;) cannot be used as key.&quot;);
    +			}
&lt;p&gt;    +			&lt;br/&gt;
    +			if (typeInfo instanceof TupleTypeInfoBase) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				for (int i = 0; i &amp;lt; typeInfo.getArity(); i++) {
    +					stack.push(((TupleTypeInfoBase) typeInfo).getTypeAt(i));	
    +				}    +			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +		}&lt;br/&gt;
    +		return keyType;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Validates that a given type of element (as encoded by the provided &lt;/p&gt;
{@link TypeInformation}
&lt;p&gt;) can be&lt;br/&gt;
    +	 * used as a key in the &lt;/p&gt;
{@code DataStream.keyBy()}
&lt;p&gt; operation.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @return &lt;/p&gt;
{@code false}
&lt;p&gt; if:&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I think it is worth having it also here for users of the method. The more the places that the user can find the required information, the better.&lt;/p&gt;</comment>
                            <comment id="15904918" author="githubbot" created="Fri, 10 Mar 2017 11:17:24 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105377853&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105377853&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/KeyedStream.java &amp;#8212;&lt;br/&gt;
    @@ -114,9 +121,53 @@ public KeyedStream(DataStream&amp;lt;T&amp;gt; dataStream, KeySelector&amp;lt;T, KEY&amp;gt; keySelector, Ty&lt;br/&gt;
     				dataStream.getTransformation(),&lt;br/&gt;
     				new KeyGroupStreamPartitioner&amp;lt;&amp;gt;(keySelector, StreamGraphGenerator.DEFAULT_LOWER_BOUND_MAX_PARALLELISM)));&lt;br/&gt;
     		this.keySelector = keySelector;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.keyType = keyType;&lt;br/&gt;
    +		this.keyType = validateKeyType(keyType);&lt;br/&gt;
     	}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
    +	private TypeInformation&amp;lt;KEY&amp;gt; validateKeyType(TypeInformation&amp;lt;KEY&amp;gt; keyType) {&lt;br/&gt;
    +		Stack&amp;lt;TypeInformation&amp;lt;?&amp;gt;&amp;gt; stack = new Stack&amp;lt;&amp;gt;();&lt;br/&gt;
    +		stack.push(keyType);&lt;br/&gt;
    +&lt;br/&gt;
    +		while (!stack.isEmpty()) {&lt;br/&gt;
    +			TypeInformation&amp;lt;?&amp;gt; typeInfo = stack.pop();&lt;br/&gt;
    +&lt;br/&gt;
    +			if (!validateKeyTypeIsHashable(typeInfo)) &lt;/p&gt;
{
    +				throw new InvalidProgramException(&quot;This type (&quot; + keyType + &quot;) cannot be used as key.&quot;);
    +			}
&lt;p&gt;    +			&lt;br/&gt;
    +			if (typeInfo instanceof TupleTypeInfoBase) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				for (int i = 0; i &amp;lt; typeInfo.getArity(); i++) {
    +					stack.push(((TupleTypeInfoBase) typeInfo).getTypeAt(i));	
    +				}    +			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +		}&lt;br/&gt;
    +		return keyType;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Validates that a given type of element (as encoded by the provided &lt;/p&gt;
{@link TypeInformation}
&lt;p&gt;) can be&lt;br/&gt;
    +	 * used as a key in the &lt;/p&gt;
{@code DataStream.keyBy()}
&lt;p&gt; operation.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @return &lt;/p&gt;
{@code false}
&lt;p&gt; if:&lt;br/&gt;
    +	 * &amp;lt;ol&amp;gt;&lt;br/&gt;
    +	 *     &amp;lt;li&amp;gt;it is a POJO type but does not override the &lt;/p&gt;
{@link #hashCode()}
&lt;p&gt; method and relies on&lt;br/&gt;
    +	 *     the &lt;/p&gt;
{@link Object#hashCode()}
&lt;p&gt; implementation.&amp;lt;/li&amp;gt;&lt;br/&gt;
    +	 *     &amp;lt;li&amp;gt;it is an array of any type (see &lt;/p&gt;
{@link PrimitiveArrayTypeInfo}
&lt;p&gt;, &lt;/p&gt;
{@link BasicArrayTypeInfo}
&lt;p&gt;,&lt;br/&gt;
    +	 *     &lt;/p&gt;
{@link ObjectArrayTypeInfo}
&lt;p&gt;).&amp;lt;/li&amp;gt;&lt;br/&gt;
    +	 * &amp;lt;/ol&amp;gt;,&lt;br/&gt;
    +	 * &lt;/p&gt;
{@code true}
&lt;p&gt; otherwise.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private boolean validateKeyTypeIsHashable(TypeInformation&amp;lt;?&amp;gt; type) {&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			return (type instanceof PojoTypeInfo) ?&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Really? I am not sure about it.&lt;/p&gt;</comment>
                            <comment id="15904928" author="githubbot" created="Fri, 10 Mar 2017 11:24:22 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105378808&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105378808&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This is the proper way of doing it. A `try catch` is of course an option, but this is more concise, and built in JUnit. &lt;/p&gt;</comment>
                            <comment id="15904931" author="githubbot" created="Fri, 10 Mar 2017 11:25:23 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105378932&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105378932&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public int[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +				int[] ks = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +				for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +					ks[i] = value.f0[i];
    +				}
&lt;p&gt;    +				return ks;&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testBasicArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value.f0;
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testObjectArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt; keySelector =&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    We can go for `Object[]`.&lt;/p&gt;</comment>
                            <comment id="15904945" author="githubbot" created="Fri, 10 Mar 2017 11:36:04 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105380399&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105380399&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public int[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +				int[] ks = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +				for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +					ks[i] = value.f0[i];
    +				}
&lt;p&gt;    +				return ks;&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testBasicArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value.f0;
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testObjectArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, TestClass[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public TestClass[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +						TestClass[] ks = new TestClass&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +						for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +							ks[i] = new TestClass(value.f0[i]);
    +						}
&lt;p&gt;    +						return ks;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		ObjectArrayTypeInfo&amp;lt;TestClass[], TestClass&amp;gt; keyTypeInfo = ObjectArrayTypeInfo.getInfoFor(&lt;br/&gt;
    +				TestClass[].class, new GenericTypeInfo&amp;lt;&amp;gt;(TestClass.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, keyTypeInfo);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private &amp;lt;K&amp;gt; void testKeyRejection(KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, K&amp;gt; keySelector, TypeInformation&amp;lt;K&amp;gt; expectedKeyType) {&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] &lt;/p&gt;
{1, 2}, &quot;barfoo&quot;)&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(expectedKeyType, TypeExtractor.getKeySelectorTypes(keySelector, input.getType()));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedKeyType + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : POJOs&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJONestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] {1, 2}
&lt;p&gt;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple1&amp;lt;int[]&amp;gt;&amp;gt;(&lt;br/&gt;
    +				PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(&quot;id&quot;);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNestedArrayWorkArround() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOwithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOwithHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;POJOwithHashCode, POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public POJOwithHashCode getKey(POJOwithHashCode value) throws Exception {
    +				return value;
    +			}&lt;br/&gt;
    +		}).addSink(new SinkFunction&amp;lt;POJOwithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void invoke(POJOwithHashCode value) throws Exception {&lt;br/&gt;
    +				Assert.assertEquals(value.getId(), new int[]{1, 2}
&lt;p&gt;);&lt;br/&gt;
    +			}&lt;br/&gt;
    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJOnoHashCodeKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;POJOnoHashCode, POJOnoHashCode&amp;gt;() {&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public POJOnoHashCode getKey(POJOnoHashCode value) throws Exception &lt;/p&gt;
{
    +						return value;
    +					}
&lt;p&gt;    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOnoHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOnoHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	// composite key tests : Tuples&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testTupleNestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] {1, 2}
&lt;p&gt;, &quot;test-test&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt;(&lt;br/&gt;
    +				BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(&quot;This type (&quot; + expectedTypeInfo + &quot;) cannot be used as key.&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;Tuple2&amp;lt;Integer[],String&amp;gt;, Tuple2&amp;lt;Integer[],String&amp;gt;&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Tuple2&amp;lt;Integer[], String&amp;gt; getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value;
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveKeyRejection() throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    The name is totally misleading, you are right. This test only verifies that we did not break anything and that even if you leave the default signature for the `keySelector` (returning `Object` although your key is of a different type) it still works.&lt;/p&gt;</comment>
                            <comment id="15905022" author="githubbot" created="Fri, 10 Mar 2017 12:52:07 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for the thorough review @zentol . I integrated the comments that I agree with and commented on the rest. If you agree with the changes, I can merge it.&lt;/p&gt;</comment>
                            <comment id="15905106" author="githubbot" created="Fri, 10 Mar 2017 13:55:39 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105400311&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105400311&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-tests/src/test/java/org/apache/flink/test/checkpointing/SavepointITCase.java &amp;#8212;&lt;br/&gt;
    @@ -736,7 +736,7 @@ public void restoreState(List&amp;lt;Integer&amp;gt; state) throws Exception {&lt;/p&gt;

&lt;p&gt;     		static final ValueStateDescriptor&amp;lt;Boolean&amp;gt; descriptor = new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;seen&quot;, Boolean.class, false);&lt;br/&gt;
     		private static final long serialVersionUID = 1L;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private ValueState&amp;lt;Boolean&amp;gt; operatorState;&lt;br/&gt;
    +		private transient ValueState&amp;lt;Boolean&amp;gt; operatorState;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    well feel free to open a new PR or create a hotfix.&lt;/p&gt;</comment>
                            <comment id="15905163" author="githubbot" created="Fri, 10 Mar 2017 14:24:12 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105405543&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105405543&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/api/datastream/KeyedStream.java &amp;#8212;&lt;br/&gt;
    @@ -114,9 +121,53 @@ public KeyedStream(DataStream&amp;lt;T&amp;gt; dataStream, KeySelector&amp;lt;T, KEY&amp;gt; keySelector, Ty&lt;br/&gt;
     				dataStream.getTransformation(),&lt;br/&gt;
     				new KeyGroupStreamPartitioner&amp;lt;&amp;gt;(keySelector, StreamGraphGenerator.DEFAULT_LOWER_BOUND_MAX_PARALLELISM)));&lt;br/&gt;
     		this.keySelector = keySelector;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.keyType = keyType;&lt;br/&gt;
    +		this.keyType = validateKeyType(keyType);&lt;br/&gt;
     	}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
    +	private TypeInformation&amp;lt;KEY&amp;gt; validateKeyType(TypeInformation&amp;lt;KEY&amp;gt; keyType) {&lt;br/&gt;
    +		Stack&amp;lt;TypeInformation&amp;lt;?&amp;gt;&amp;gt; stack = new Stack&amp;lt;&amp;gt;();&lt;br/&gt;
    +		stack.push(keyType);&lt;br/&gt;
    +&lt;br/&gt;
    +		while (!stack.isEmpty()) {&lt;br/&gt;
    +			TypeInformation&amp;lt;?&amp;gt; typeInfo = stack.pop();&lt;br/&gt;
    +&lt;br/&gt;
    +			if (!validateKeyTypeIsHashable(typeInfo)) &lt;/p&gt;
{
    +				throw new InvalidProgramException(&quot;This type (&quot; + keyType + &quot;) cannot be used as key.&quot;);
    +			}
&lt;p&gt;    +			&lt;br/&gt;
    +			if (typeInfo instanceof TupleTypeInfoBase) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				for (int i = 0; i &amp;lt; typeInfo.getArity(); i++) {
    +					stack.push(((TupleTypeInfoBase) typeInfo).getTypeAt(i));	
    +				}    +			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +		}&lt;br/&gt;
    +		return keyType;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Validates that a given type of element (as encoded by the provided &lt;/p&gt;
{@link TypeInformation}
&lt;p&gt;) can be&lt;br/&gt;
    +	 * used as a key in the &lt;/p&gt;
{@code DataStream.keyBy()}
&lt;p&gt; operation.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @return &lt;/p&gt;
{@code false}
&lt;p&gt; if:&lt;br/&gt;
    +	 * &amp;lt;ol&amp;gt;&lt;br/&gt;
    +	 *     &amp;lt;li&amp;gt;it is a POJO type but does not override the &lt;/p&gt;
{@link #hashCode()}
&lt;p&gt; method and relies on&lt;br/&gt;
    +	 *     the &lt;/p&gt;
{@link Object#hashCode()}
&lt;p&gt; implementation.&amp;lt;/li&amp;gt;&lt;br/&gt;
    +	 *     &amp;lt;li&amp;gt;it is an array of any type (see &lt;/p&gt;
{@link PrimitiveArrayTypeInfo}
&lt;p&gt;, &lt;/p&gt;
{@link BasicArrayTypeInfo}
&lt;p&gt;,&lt;br/&gt;
    +	 *     &lt;/p&gt;
{@link ObjectArrayTypeInfo}
&lt;p&gt;).&amp;lt;/li&amp;gt;&lt;br/&gt;
    +	 * &amp;lt;/ol&amp;gt;,&lt;br/&gt;
    +	 * &lt;/p&gt;
{@code true}
&lt;p&gt; otherwise.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private boolean validateKeyTypeIsHashable(TypeInformation&amp;lt;?&amp;gt; type) {&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			return (type instanceof PojoTypeInfo) ?&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    So i looked through the code base, and found 5 different patterns, so you&apos;re right, &quot;typical&quot; doesn&apos;t really fit:&lt;br/&gt;
    1:&lt;br/&gt;
    ```&lt;br/&gt;
    &amp;lt;condition&amp;gt; ? &amp;lt;then&amp;gt; : &amp;lt;else&amp;gt;&lt;br/&gt;
    ```&lt;br/&gt;
    2:&lt;br/&gt;
    ```&lt;br/&gt;
    &amp;lt;condition&amp;gt; ? &lt;br/&gt;
     &amp;lt;then&amp;gt; : &amp;lt;else&amp;gt;&lt;br/&gt;
    ```&lt;br/&gt;
    3:&lt;br/&gt;
    ```&lt;br/&gt;
    &amp;lt;condition&amp;gt; ?&lt;br/&gt;
     &amp;lt;then&amp;gt;&lt;br/&gt;
     : &amp;lt;else&amp;gt;&lt;br/&gt;
    ```&lt;br/&gt;
    4:&lt;br/&gt;
    ```&lt;br/&gt;
    &amp;lt;condition&amp;gt;&lt;br/&gt;
     ? &amp;lt;then&amp;gt;&lt;br/&gt;
     : &amp;lt;else&amp;gt;&lt;br/&gt;
    ```&lt;br/&gt;
    5:&lt;br/&gt;
    ```&lt;br/&gt;
    if &amp;lt;condition&amp;gt; ?&lt;br/&gt;
     &amp;lt;then&amp;gt; :&lt;br/&gt;
     &amp;lt;else&amp;gt;&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    In my opinion, only 1 and 4 should be used; and 1 only for short statements. Both of these options are symmetrical; the if and else statement are formatted the same way, and place important information (? and :) at the start of the line.&lt;/p&gt;

&lt;p&gt;    The point here is pattern recognition.&lt;br/&gt;
    When seeing this&lt;br/&gt;
    ```&lt;br/&gt;
    X&lt;br/&gt;
     ? Y&lt;br/&gt;
     : Z&lt;br/&gt;
    ```&lt;br/&gt;
    you can immediately see what is going on without looking at the details of the expression, nor scanning any line; the very first character gives it away. The position of ? and \: is also static, it&apos;s on the next line with an additional indent, compared to other options which may hide ? at the end of a 100 character expression (which gets especially funky with option 2 which also hides \: somewhere, so at a glace it could also just be a method call with many arguments).&lt;/p&gt;</comment>
                            <comment id="15905171" author="githubbot" created="Fri, 10 Mar 2017 14:27:51 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Done! Let me know if you have any additional comments @zentol &lt;/p&gt;</comment>
                            <comment id="15905174" author="githubbot" created="Fri, 10 Mar 2017 14:28:18 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105406325&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105406325&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Well it may be more concise, but a try catch block makes it way more obvious that this part of the code throws an exception we care about.&lt;/p&gt;

&lt;p&gt;    try-catch blocks are also more commonin the codebase, and I&apos;m wondering whether we want to introduce an inconsistency there.&lt;/p&gt;</comment>
                            <comment id="15905176" author="githubbot" created="Fri, 10 Mar 2017 14:29:22 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105406561&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105406561&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,243 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public int[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +				int[] ks = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +				for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +					ks[i] = value.f0[i];
    +				}
&lt;p&gt;    +				return ks;&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testBasicArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value.f0;
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testObjectArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Object[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Object[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public Object[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +						Object[] ks = new TestClass&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Can we use plain objects here? Then we wouldn&apos;t need the TestClass at all.&lt;/p&gt;</comment>
                            <comment id="15905177" author="githubbot" created="Fri, 10 Mar 2017 14:32:30 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105407208&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105407208&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,256 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    The thing is that if I remember correctly we discussed about how to check for exceptions earlier this year. And if I remember correctly the outcome was sth along the lines of using JUnit facilities. Feel free to correct me on this one.&lt;/p&gt;
</comment>
                            <comment id="15905180" author="githubbot" created="Fri, 10 Mar 2017 14:33:28 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501#discussion_r105407025&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501#discussion_r105407025&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/api/DataStreamTest.java &amp;#8212;&lt;br/&gt;
    @@ -906,6 +919,243 @@ public void testChannelSelectors() {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +	// KeyBy testing&lt;br/&gt;
    +	/////////////////////////////////////////////////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, int[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public int[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +				int[] ks = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +				for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +					ks[i] = value.f0[i];
    +				}
&lt;p&gt;    +				return ks;&lt;br/&gt;
    +			}&lt;br/&gt;
    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testBasicArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Integer[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Integer[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value.f0;
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testObjectArrayKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Object[]&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, Object[]&amp;gt;() {&lt;br/&gt;
    +&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public Object[] getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception {&lt;br/&gt;
    +						Object[] ks = new TestClass&lt;span class=&quot;error&quot;&gt;&amp;#91;value.f0.length&amp;#93;&lt;/span&gt;;&lt;br/&gt;
    +						for (int i = 0; i &amp;lt; ks.length; i++) &lt;/p&gt;
{
    +							ks[i] = new TestClass(value.f0[i]);
    +						}
&lt;p&gt;    +						return ks;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		ObjectArrayTypeInfo&amp;lt;Object[], Object&amp;gt; keyTypeInfo = ObjectArrayTypeInfo.getInfoFor(&lt;br/&gt;
    +				Object[].class, new GenericTypeInfo&amp;lt;&amp;gt;(Object.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		testKeyRejection(keySelector, keyTypeInfo);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private &amp;lt;K&amp;gt; void testKeyRejection(KeySelector&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;, K&amp;gt; keySelector, TypeInformation&amp;lt;K&amp;gt; expectedKeyType) {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] &lt;/p&gt;
{1, 2}, &quot;barfoo&quot;)&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.assertEquals(expectedKeyType, TypeExtractor.getKeySelectorTypes(keySelector, input.getType()));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(new StringStartsWith(&quot;Type &quot; + expectedKeyType + &quot; cannot be used as key.&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	////////////////			Composite Key Tests : POJOs			////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJOWithNestedArrayNoHashCodeKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOWithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOWithHashCode(new int[] {1, 2}
&lt;p&gt;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple1&amp;lt;int[]&amp;gt;&amp;gt;(&lt;br/&gt;
    +				PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(new StringStartsWith(&quot;Type &quot; + expectedTypeInfo + &quot; cannot be used as key.&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(&quot;id&quot;);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJOWithNestedArrayAndHashCodeWorkAround() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOWithHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOWithHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;POJOWithHashCode, POJOWithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public POJOWithHashCode getKey(POJOWithHashCode value) throws Exception {
    +				return value;
    +			}&lt;br/&gt;
    +		}).addSink(new SinkFunction&amp;lt;POJOWithHashCode&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void invoke(POJOWithHashCode value) throws Exception {&lt;br/&gt;
    +				Assert.assertEquals(value.getId(), new int[]{1, 2}
&lt;p&gt;);&lt;br/&gt;
    +			}&lt;br/&gt;
    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPOJOnoHashCodeKeyRejection() {&lt;br/&gt;
    +&lt;br/&gt;
    +		KeySelector&amp;lt;POJOWithoutHashCode, POJOWithoutHashCode&amp;gt; keySelector =&lt;br/&gt;
    +				new KeySelector&amp;lt;POJOWithoutHashCode, POJOWithoutHashCode&amp;gt;() {&lt;br/&gt;
    +					@Override&lt;br/&gt;
    +					public POJOWithoutHashCode getKey(POJOWithoutHashCode value) throws Exception &lt;/p&gt;
{
    +						return value;
    +					}
&lt;p&gt;    +				};&lt;br/&gt;
    +&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;POJOWithoutHashCode&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new POJOWithoutHashCode(new int[] &lt;/p&gt;
{1, 2}));&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(keySelector);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	////////////////			Composite Key Tests : Tuples			////////////////&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testTupleNestedArrayKeyRejection() {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt; input = env.fromElements(&lt;br/&gt;
    +				new Tuple2&amp;lt;&amp;gt;(new Integer[] {1, 2}
&lt;p&gt;, &quot;test-test&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeInformation&amp;lt;?&amp;gt; expectedTypeInfo = new TupleTypeInfo&amp;lt;Tuple2&amp;lt;Integer[], String&amp;gt;&amp;gt;(&lt;br/&gt;
    +				BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO);&lt;br/&gt;
    +&lt;br/&gt;
    +		// adjust the rule&lt;br/&gt;
    +		expectedException.expect(InvalidProgramException.class);&lt;br/&gt;
    +		expectedException.expectMessage(new StringStartsWith(&quot;Type &quot; + expectedTypeInfo + &quot; cannot be used as key.&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +		input.keyBy(new KeySelector&amp;lt;Tuple2&amp;lt;Integer[],String&amp;gt;, Tuple2&amp;lt;Integer[],String&amp;gt;&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Tuple2&amp;lt;Integer[], String&amp;gt; getKey(Tuple2&amp;lt;Integer[], String&amp;gt; value) throws Exception &lt;/p&gt;
{
    +				return value;
    +			}&lt;br/&gt;
    +		});&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testPrimitiveKeyAcceptance() throws Exception {&lt;br/&gt;
    +		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;
    +		env.setParallelism(1);&lt;br/&gt;
    +		env.setMaxParallelism(1);&lt;br/&gt;
    +&lt;br/&gt;
    +		DataStream&amp;lt;Integer&amp;gt; input = env.fromElements(new Integer(10000));&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedStream&amp;lt;Integer, Object&amp;gt; keyedStream = input.keyBy(new KeySelector&amp;lt;Integer, Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object getKey(Integer value) throws Exception {    +				return value;    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		keyedStream.addSink(new SinkFunction&amp;lt;Integer&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void invoke(Integer value) throws Exception &lt;/p&gt;
{
    +				Assert.assertEquals(10000L, (long) value);
    +			}
&lt;p&gt;    +		});&lt;br/&gt;
    +&lt;br/&gt;
    +		env.execute();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    We don&apos;t need to execute a job, correct? just the keyBy passing should be enough.&lt;/p&gt;</comment>
                            <comment id="15905201" author="githubbot" created="Fri, 10 Mar 2017 14:47:22 +0000"  >&lt;p&gt;Github user zentol commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    +1 to merge.&lt;/p&gt;</comment>
                            <comment id="15905788" author="githubbot" created="Fri, 10 Mar 2017 22:19:52 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3501&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3501&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15905789" author="kkl0u" created="Fri, 10 Mar 2017 22:20:41 +0000"  >&lt;p&gt;Merged at f15a7d2d9c9aae72bb3ac3eb2478b3ec4759401b&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13291173">FLINK-16555</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13026733">FLINK-5299</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13044908">FLINK-5875</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 36 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3ae1z:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>