<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:34:59 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-10255] Standby Dispatcher locks submitted JobGraphs</title>
                <link>https://issues.apache.org/jira/browse/FLINK-10255</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;Currently, standby &lt;tt&gt;Dispatchers&lt;/tt&gt; lock submitted &lt;tt&gt;JobGraphs&lt;/tt&gt; which are added to the &lt;tt&gt;SubmittedJobGraphStore&lt;/tt&gt; if HA mode is enabled. Locking the &lt;tt&gt;JobGraphs&lt;/tt&gt; can prevent their cleanup leaving the system in an inconsistent state.&lt;/p&gt;

&lt;p&gt;The problem is that we recover in the &lt;tt&gt;SubmittedJobGraphListener#onAddedJobGraph&lt;/tt&gt; callback which is also called if don&apos;t have the leadership the newly added &lt;tt&gt;JobGraph&lt;/tt&gt;. Recovering the &lt;tt&gt;JobGraph&lt;/tt&gt; currently locks the &lt;tt&gt;JobGraph&lt;/tt&gt;. In case that the &lt;tt&gt;Dispatcher&lt;/tt&gt; is not the leader, then we won&apos;t start that job after its recovery. However, we also don&apos;t release the &lt;tt&gt;JobGraph&lt;/tt&gt; leaving it locked.&lt;/p&gt;

&lt;p&gt;There are two possible solutions to the problem. Either we check whether we are the leader before recovering jobs or we say that recovering jobs does not lock them. Only if we can submit the recovered job we lock them. The latter approach has the advantage that it follows a quite similar code path as an initial job submission. Moreover, jobs are currently also recovered at other places. In all these places we currently would need to release the &lt;tt&gt;JobGraphs&lt;/tt&gt; if we cannot submit the recovered &lt;tt&gt;JobGraph&lt;/tt&gt; (e.g. &lt;tt&gt;Dispatcher#grantLeadership&lt;/tt&gt;).&lt;/p&gt;

&lt;p&gt;An extension of the first solution could be to stop the &lt;tt&gt;SubmittedJobGraphStore&lt;/tt&gt; while the &lt;tt&gt;Dispatcher&lt;/tt&gt; is not the leader. Then we would have to make sure that no concurrent callback from the &lt;tt&gt;SubmittedJobGraphStore#SubmittedJobGraphListener&lt;/tt&gt; can be executed after revoking leadership from the &lt;tt&gt;Dispatcher&lt;/tt&gt;.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13181923">FLINK-10255</key>
            <summary>Standby Dispatcher locks submitted JobGraphs</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="trohrmann">Till Rohrmann</assignee>
                                    <reporter username="trohrmann">Till Rohrmann</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Wed, 29 Aug 2018 13:39:23 +0000</created>
                <updated>Thu, 27 Sep 2018 07:14:22 +0000</updated>
                            <resolved>Fri, 14 Sep 2018 13:17:24 +0000</resolved>
                                    <version>1.5.3</version>
                    <version>1.6.0</version>
                    <version>1.7.0</version>
                                    <fixVersion>1.5.4</fixVersion>
                    <fixVersion>1.6.1</fixVersion>
                    <fixVersion>1.7.0</fixVersion>
                                    <component>Runtime / Coordination</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>13</watches>
                                                                                                                <comments>
                            <comment id="16609200" author="githubbot" created="Mon, 10 Sep 2018 13:37:35 +0000"  >&lt;p&gt;tillrohrmann opened a new pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   The Dispatcher should only react to the onAddedJobGraph signal if it is the leader.&lt;br/&gt;
   In all other cases the signal should be ignored since the jobs will be recovered once&lt;br/&gt;
   the Dispatcher becomes the leader.&lt;/p&gt;

&lt;p&gt;   In order to still support non-blocking job recoveries, this commit serializes all&lt;br/&gt;
   recovery operations by introducing a recoveryOperation future which first needs to&lt;br/&gt;
   complete before a subsequent operation is started. That way we can avoid race conditions&lt;br/&gt;
   between granting and revoking leadership as well as the onAddedJobGraph signals. This is&lt;br/&gt;
   important since we can only lock each JobGraph once and, thus, need to make sure that&lt;br/&gt;
   we don&apos;t release a lock of a properly recovered job in a concurrent operation.&lt;/p&gt;

&lt;p&gt;   cc @GJL &lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Only react to `SubmittedJobGraphListener#onAddedJobGraph` when being the leader&lt;/li&gt;
	&lt;li&gt;Serialize recovery operations by introducing a `recoveryOperation` future in order to avoid wrong unlocking of guarded resources&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added `ZooKeeperHADispatcherTest#testStandbyDispatcherJobExecution` and `ZooKeeperHADispatcherTest#testStandbyDispatcherJobRecovery`&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (no)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (no)&lt;/li&gt;
	&lt;li&gt;The serializers: (no)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (no)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (yes)&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: (no)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (no)&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? (not applicable)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16610111" author="githubbot" created="Tue, 11 Sep 2018 05:24:51 +0000"  >&lt;p&gt;TisonKun commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r216548720&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r216548720&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -85,5 +87,13 @@&lt;br/&gt;
 		return FutureUtils.completeAll(terminationFutures);&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	public static void stopActor(AkkaActorGateway akkaActorGateway) {&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   In this PR we introduce `stopActor` which is used at one place. After checking all our project, we have define many `stopActor` here and there. Most usages of them are from `TestingUtils` but there are also some from `MesosResourceManager` and `FlinkUntypedActorTest`. Sometimes use `PoisonPill` and sometimes use `Kill`. &lt;br/&gt;
   Apart from this PR, since all stuff interact with Akka would depend on `flink-runtime`, let&apos;s unify stopActor Utils.&lt;br/&gt;
   I think here, `ActorUtils` is the best place.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16610117" author="githubbot" created="Tue, 11 Sep 2018 05:32:25 +0000"  >&lt;p&gt;TisonKun commented on issue #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#issuecomment-420151979&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#issuecomment-420151979&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Travis show relevant failures, will take a close look later.&lt;/p&gt;

&lt;p&gt;   ```&lt;br/&gt;
   testGrantingRevokingLeadership(org.apache.flink.runtime.dispatcher.DispatcherHATest)  Time elapsed: 0.024 sec  &amp;lt;&amp;lt;&amp;lt; ERROR!&lt;br/&gt;
   org.apache.flink.runtime.util.TestingFatalErrorHandler$TestingException: java.lang.UnsupportedOperationException: Should not be called.&lt;br/&gt;
   	at org.apache.flink.runtime.util.TestingFatalErrorHandler.rethrowError(TestingFatalErrorHandler.java:51)&lt;br/&gt;
   	at org.apache.flink.runtime.dispatcher.DispatcherHATest.teardown(DispatcherHATest.java:98)&lt;br/&gt;
   Caused by: java.lang.UnsupportedOperationException: Should not be called.&lt;br/&gt;
   	at org.apache.flink.runtime.dispatcher.DispatcherHATest$BlockingSubmittedJobGraphStore.releaseJobGraph(DispatcherHATest.java:306)&lt;br/&gt;
   	at org.apache.flink.runtime.dispatcher.Dispatcher.lambda$null$26(Dispatcher.java:809)&lt;br/&gt;
   	at org.apache.flink.util.function.BiFunctionWithException.apply(BiFunctionWithException.java:49)&lt;br/&gt;
   	at java.util.concurrent.CompletableFuture.biApply(CompletableFuture.java:1105)&lt;br/&gt;
   	at java.util.concurrent.CompletableFuture$BiApply.tryFire(CompletableFuture.java:1070)&lt;br/&gt;
   	at java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:442)&lt;br/&gt;
   	at akka.dispatch.TaskInvocation.run(AbstractDispatcher.scala:39)&lt;br/&gt;
   	at akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask.exec(AbstractDispatcher.scala:415)&lt;br/&gt;
   	at scala.concurrent.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:260)&lt;br/&gt;
   	at scala.concurrent.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1339)&lt;br/&gt;
   	at scala.concurrent.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:1979)&lt;br/&gt;
   	at scala.concurrent.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:107)&lt;br/&gt;
   ```&lt;/p&gt;

&lt;p&gt;   ```&lt;br/&gt;
   Tests run: 2, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 1.45 sec &amp;lt;&amp;lt;&amp;lt; FAILURE! - in org.apache.flink.runtime.dispatcher.DispatcherHATest&lt;br/&gt;
   testGrantingRevokingLeadership(org.apache.flink.runtime.dispatcher.DispatcherHATest)  Time elapsed: 0.028 sec  &amp;lt;&amp;lt;&amp;lt; ERROR!&lt;br/&gt;
   org.apache.flink.runtime.util.TestingFatalErrorHandler$TestingException: java.lang.UnsupportedOperationException: Should not be called.&lt;br/&gt;
   	at org.apache.flink.runtime.util.TestingFatalErrorHandler.rethrowError(TestingFatalErrorHandler.java:51)&lt;br/&gt;
   	at org.apache.flink.runtime.dispatcher.DispatcherHATest.teardown(DispatcherHATest.java:98)&lt;br/&gt;
   Caused by: java.lang.UnsupportedOperationException: Should not be called.&lt;br/&gt;
   	at org.apache.flink.runtime.dispatcher.DispatcherHATest$BlockingSubmittedJobGraphStore.releaseJobGraph(DispatcherHATest.java:306)&lt;br/&gt;
   	at org.apache.flink.runtime.dispatcher.Dispatcher.lambda$null$26(Dispatcher.java:809)&lt;br/&gt;
   	at org.apache.flink.util.function.BiFunctionWithException.apply(BiFunctionWithException.java:49)&lt;br/&gt;
   	at java.util.concurrent.CompletableFuture.biApply(CompletableFuture.java:1105)&lt;br/&gt;
   	at java.util.concurrent.CompletableFuture$BiApply.tryFire(CompletableFuture.java:1070)&lt;br/&gt;
   	at java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:442)&lt;br/&gt;
   	at akka.dispatch.TaskInvocation.run(AbstractDispatcher.scala:39)&lt;br/&gt;
   	at akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask.exec(AbstractDispatcher.scala:415)&lt;br/&gt;
   	at scala.concurrent.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:260)&lt;br/&gt;
   	at scala.concurrent.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1339)&lt;br/&gt;
   	at scala.concurrent.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:1979)&lt;br/&gt;
   	at scala.concurrent.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:107)&lt;br/&gt;
   ```&lt;/p&gt;

&lt;p&gt;   ```&lt;br/&gt;
   A TaskManager should go into a clean state in case of a JobManager failure(org.apache.flink.api.scala.runtime.jobmanager.JobManagerFailsITCase)  Time elapsed: 121.247 sec  &amp;lt;&amp;lt;&amp;lt; FAILURE!&lt;br/&gt;
   java.lang.AssertionError: assertion failed: timeout (119585594930 nanoseconds) during expectMsg while waiting for Acknowledge&lt;br/&gt;
   	at scala.Predef$.assert(Predef.scala:170)&lt;br/&gt;
   	at akka.testkit.TestKitBase$class.expectMsg_internal(TestKit.scala:387)&lt;br/&gt;
   	at akka.testkit.TestKitBase$class.expectMsg(TestKit.scala:364)&lt;br/&gt;
   	at akka.testkit.TestKit.expectMsg(TestKit.scala:814)&lt;br/&gt;
   	at org.apache.flink.api.scala.runtime.jobmanager.JobManagerFailsITCase$$anonfun$1$$anonfun$apply$mcV$sp$3$$anonfun$apply$mcV$sp$4.apply$mcV$sp(JobManagerFailsITCase.scala:118)&lt;br/&gt;
   	at org.apache.flink.api.scala.runtime.jobmanager.JobManagerFailsITCase$$anonfun$1$$anonfun$apply$mcV$sp$3$$anonfun$apply$mcV$sp$4.apply(JobManagerFailsITCase.scala:104)&lt;br/&gt;
   	at org.apache.flink.api.scala.runtime.jobmanager.JobManagerFailsITCase$$anonfun$1$$anonfun$apply$mcV$sp$3$$anonfun$apply$mcV$sp$4.apply(JobManagerFailsITCase.scala:104)&lt;br/&gt;
   	at akka.testkit.TestKitBase$class.within(TestKit.scala:345)&lt;br/&gt;
   	at akka.testkit.TestKit.within(TestKit.scala:814)&lt;br/&gt;
   	at akka.testkit.TestKitBase$class.within(TestKit.scala:359)&lt;br/&gt;
   	at akka.testkit.TestKit.within(TestKit.scala:814)&lt;br/&gt;
   	at org.apache.flink.api.scala.runtime.jobmanager.JobManagerFailsITCase$$anonfun$1$$anonfun$apply$mcV$sp$3.apply$mcV$sp(JobManagerFailsITCase.scala:104)&lt;br/&gt;
   	at org.apache.flink.api.scala.runtime.jobmanager.JobManagerFailsITCase$$anonfun$1$$anonfun$apply$mcV$sp$3.apply(JobManagerFailsITCase.scala:85)&lt;br/&gt;
   	at org.apache.flink.api.scala.runtime.jobmanager.JobManagerFailsITCase$$anonfun$1$$anonfun$apply$mcV$sp$3.apply(JobManagerFailsITCase.scala:85)&lt;br/&gt;
   	at org.scalatest.Transformer$$anonfun$apply$1.apply$mcV$sp(Transformer.scala:22)&lt;br/&gt;
   	at org.scalatest.OutcomeOf$class.outcomeOf(OutcomeOf.scala:85)&lt;br/&gt;
   	at org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)&lt;br/&gt;
   	at org.scalatest.Transformer.apply(Transformer.scala:22)&lt;br/&gt;
   	at org.scalatest.Transformer.apply(Transformer.scala:20)&lt;br/&gt;
   	at org.scalatest.WordSpecLike$$anon$1.apply(WordSpecLike.scala:953)&lt;br/&gt;
   	at org.scalatest.Suite$class.withFixture(Suite.scala:1122)&lt;br/&gt;
   	at org.apache.flink.api.scala.runtime.jobmanager.JobManagerFailsITCase.withFixture(JobManagerFailsITCase.scala:37)&lt;br/&gt;
   ```&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16610223" author="githubbot" created="Tue, 11 Sep 2018 07:49:43 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r216575018&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r216575018&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/akka/ActorUtils.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -85,5 +87,13 @@&lt;br/&gt;
 		return FutureUtils.completeAll(terminationFutures);&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	public static void stopActor(AkkaActorGateway akkaActorGateway) {&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Good point. I will clean this up as a follow up.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16610263" author="githubbot" created="Tue, 11 Sep 2018 08:23:30 +0000"  >&lt;p&gt;tillrohrmann commented on issue #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#issuecomment-420190020&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#issuecomment-420190020&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Thanks for the comments @TisonKun. I&apos;ve fixed the failing `DispatcherTest#testOnAddedJobGraphWithFinishedJob`.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612172" author="githubbot" created="Wed, 12 Sep 2018 14:01:16 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217043254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217043254&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/util/function/FunctionWithThrowable.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,48 @@&lt;br/&gt;
+/*&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I think this commit should be before `&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader`, or it should be squashed.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612185" author="githubbot" created="Wed, 12 Sep 2018 14:09:19 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217043254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217043254&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/util/function/FunctionWithThrowable.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,48 @@&lt;br/&gt;
+/*&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I think this commit should be before `&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader`, or it should be squashed (`fixup`). Without this class your previous commits would not work.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612186" author="githubbot" created="Wed, 12 Sep 2018 14:09:26 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217043254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217043254&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/util/function/FunctionWithThrowable.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,48 @@&lt;br/&gt;
+/*&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I think this commit should be before `&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader`, or it should be squashed. Without this class your previous commits would not work.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612195" author="githubbot" created="Wed, 12 Sep 2018 14:14:34 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217046190&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217046190&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -861,14 +861,18 @@ public void grantLeadership(final UUID newLeaderSessionID) &lt;/p&gt;
{
 			getMainThreadExecutor());
 	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;br/&gt;
+	CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: { 		if (jobManagerRunners.containsKey(jobId)) {
 			return FutureUtils.completedExceptionally(new DispatcherException(String.format(&quot;Job with job id %s is still running.&quot;, jobId)));
 		} else {
 			return jobManagerTerminationFutures.getOrDefault(jobId, CompletableFuture.completedFuture(null));
 		} 	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	CompletableFuture&amp;lt;Void&amp;gt; getRecoveryOperation() {&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   This method has wider visibility scope than necessary, and is part of production code. I think `@VisibleForTesting` should be added.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612196" author="githubbot" created="Wed, 12 Sep 2018 14:14:34 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217045367&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217045367&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -861,14 +861,18 @@ public void grantLeadership(final UUID newLeaderSessionID) &lt;/p&gt;
{
 			getMainThreadExecutor());
 	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;br/&gt;
+	CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Should be `private`.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612197" author="githubbot" created="Wed, 12 Sep 2018 14:14:34 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217044938&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217044938&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -80,9 +80,16 @@ void completeJobExecution(ArchivedExecutionGraph archivedExecutionGraph) {&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt; 	@VisibleForTesting&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(@Nonnull JobID jobId, @Nonnull Time timeout) {&lt;br/&gt;
+	CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(@Nonnull JobID jobId, @Nonnull Time timeout) 
{
 		return callAsyncWithoutFencing(
 			() -&amp;gt; getJobTerminationFuture(jobId),
 			timeout).thenCompose(Function.identity());
 	}
&lt;p&gt;+&lt;br/&gt;
+	@VisibleForTesting&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Not sure about `@VisibleForTesting` here. This class is already a test utility. It is even in the `test` sources directory.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612198" author="githubbot" created="Wed, 12 Sep 2018 14:17:05 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217043254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217043254&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/util/function/FunctionWithThrowable.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,48 @@&lt;br/&gt;
+/*&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I think adding this file should be in a commit that is before `&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader`, or it should be squashed. Without this class your previous commits would not work.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612229" author="githubbot" created="Wed, 12 Sep 2018 14:36:39 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217058569&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217058569&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/util/function/FunctionWithThrowable.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,48 @@&lt;br/&gt;
+/*&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Yes, I will rearrange the commits before merging. Locally 3a07ee8812afb3feb2233d722311c4de08eef09a is before 868c7dd6822cee24046b486874fef5d5d7d3564d which makes it work.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612279" author="githubbot" created="Wed, 12 Sep 2018 14:59:39 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217068175&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217068175&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -80,9 +80,16 @@ void completeJobExecution(ArchivedExecutionGraph archivedExecutionGraph) {&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt; 	@VisibleForTesting&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(@Nonnull JobID jobId, @Nonnull Time timeout) {&lt;br/&gt;
+	CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(@Nonnull JobID jobId, @Nonnull Time timeout) 
{
 		return callAsyncWithoutFencing(
 			() -&amp;gt; getJobTerminationFuture(jobId),
 			timeout).thenCompose(Function.identity());
 	}
&lt;p&gt;+&lt;br/&gt;
+	@VisibleForTesting&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   You&apos;re right. Will change it.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612280" author="githubbot" created="Wed, 12 Sep 2018 15:00:45 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217068649&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217068649&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -861,14 +861,18 @@ public void grantLeadership(final UUID newLeaderSessionID) &lt;/p&gt;
{
 			getMainThreadExecutor());
 	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;br/&gt;
+	CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   It cannot be private since the `TestingDispatcher` needs to acces it.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612282" author="githubbot" created="Wed, 12 Sep 2018 15:00:55 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217068649&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217068649&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -861,14 +861,18 @@ public void grantLeadership(final UUID newLeaderSessionID) &lt;/p&gt;
{
 			getMainThreadExecutor());
 	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;br/&gt;
+	CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   It cannot be private since the `TestingDispatcher` needs to access it.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612283" author="githubbot" created="Wed, 12 Sep 2018 15:01:06 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217068791&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217068791&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -861,14 +861,18 @@ public void grantLeadership(final UUID newLeaderSessionID) &lt;/p&gt;
{
 			getMainThreadExecutor());
 	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;br/&gt;
+	CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: { 		if (jobManagerRunners.containsKey(jobId)) {
 			return FutureUtils.completedExceptionally(new DispatcherException(String.format(&quot;Job with job id %s is still running.&quot;, jobId)));
 		} else {
 			return jobManagerTerminationFutures.getOrDefault(jobId, CompletableFuture.completedFuture(null));
 		} 	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	CompletableFuture&amp;lt;Void&amp;gt; getRecoveryOperation() {&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Good point. Will add it.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612319" author="githubbot" created="Wed, 12 Sep 2018 15:22:30 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217077413&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217077413&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -861,14 +861,18 @@ public void grantLeadership(final UUID newLeaderSessionID) &lt;/p&gt;
{
 			getMainThreadExecutor());
 	}

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;br/&gt;
+	CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   True, I missed it.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612344" author="githubbot" created="Wed, 12 Sep 2018 15:35:03 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217082586&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217082586&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -879,24 +917,66 @@ public void handleError(final Exception exception) {&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	public void onAddedJobGraph(final JobID jobId) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;SubmittedJobGraph&amp;gt; recoveredJob = getRpcService().execute(&lt;/li&gt;
	&lt;li&gt;() -&amp;gt; submittedJobGraphStore.recoverJobGraph(jobId));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;/li&gt;
	&lt;li&gt;(SubmittedJobGraph submittedJobGraph) -&amp;gt; submitJob(submittedJobGraph.getJobGraph(), RpcUtils.INF_TIMEOUT),&lt;/li&gt;
	&lt;li&gt;getMainThreadExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;submissionFuture.whenComplete(&lt;/li&gt;
	&lt;li&gt;(Acknowledge acknowledge, Throwable throwable) -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;if (throwable != null) {&lt;/li&gt;
	&lt;li&gt;onFatalError(&lt;/li&gt;
	&lt;li&gt;new DispatcherException(&lt;/li&gt;
	&lt;li&gt;String.format(&quot;Could not start the added job %s&quot;, jobId),&lt;/li&gt;
	&lt;li&gt;ExceptionUtils.stripCompletionException(throwable)));&lt;br/&gt;
+		runAsync(&lt;br/&gt;
+			() -&amp;gt; {&lt;br/&gt;
+				if (!jobManagerRunners.containsKey(jobId)) {&lt;br/&gt;
+					final CompletableFuture&amp;lt;JobGraph&amp;gt; recoveredJob = recoveryOperation.thenApplyAsync(&lt;br/&gt;
+						ignored -&amp;gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+							try {
+								return recoverJob(jobId);
+							} catch (Exception e) {
+								ExceptionUtils.rethrow(e);
+							}+							return null;+						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;,&lt;br/&gt;
+						getRpcService().getExecutor());&lt;br/&gt;
+&lt;br/&gt;
+					final DispatcherId dispatcherId = getFencingToken();&lt;br/&gt;
+					final CompletableFuture&amp;lt;Void&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;br/&gt;
+						(FunctionWithThrowable&amp;lt;JobGraph, CompletableFuture&amp;lt;Void&amp;gt;, Exception&amp;gt;) (JobGraph jobGraph) -&amp;gt; tryRunRecoveredJobGraph(jobGraph, dispatcherId)&lt;br/&gt;
+							.thenAcceptAsync(&lt;br/&gt;
+								(ConsumerWithException&amp;lt;Boolean, Exception&amp;gt;) (Boolean isRecoveredJobRunning) -&amp;gt; {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Imo we are doing this wrong. The API would be much more readible with static factory methods:&lt;/p&gt;

&lt;p&gt;   ```&lt;/p&gt;

&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;{@link Consumer}
&lt;p&gt; that can throw checked exceptions.&lt;br/&gt;
    */&lt;br/&gt;
   @FunctionalInterface&lt;br/&gt;
   public interface CheckedConsumer&amp;lt;T&amp;gt; {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   	void checkedAccept(T t) throws Exception;&lt;/p&gt;

&lt;p&gt;   	static &amp;lt;T&amp;gt; Consumer&amp;lt;T&amp;gt; unchecked(CheckedConsumer&amp;lt;T&amp;gt; checkedConsumer) {&lt;br/&gt;
   		return (t) -&amp;gt; {&lt;br/&gt;
   			try &lt;/p&gt;
{
   				checkedConsumer.checkedAccept(t);
   			}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
   				ExceptionUtils.rethrow(e);
   			}
&lt;p&gt;   		};&lt;br/&gt;
   	}&lt;br/&gt;
   }&lt;br/&gt;
   ```&lt;br/&gt;
   This allows for:&lt;br/&gt;
   ```&lt;br/&gt;
   CheckedConsumer.unchecked(isRecoveredJobRunning -&amp;gt; &lt;/p&gt;
{
        ...
   }
&lt;p&gt;);&lt;br/&gt;
   ``` &lt;br/&gt;
   No casts are required. Also when interacting with the Java API, it does not matter what type of exception can be thrown. We do not need to generify the exception type in `ConsumerWithException`. &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612345" author="githubbot" created="Wed, 12 Sep 2018 15:35:25 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217082714&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217082714&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -879,24 +917,66 @@ public void handleError(final Exception exception) {&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	public void onAddedJobGraph(final JobID jobId) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;SubmittedJobGraph&amp;gt; recoveredJob = getRpcService().execute(&lt;/li&gt;
	&lt;li&gt;() -&amp;gt; submittedJobGraphStore.recoverJobGraph(jobId));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;/li&gt;
	&lt;li&gt;(SubmittedJobGraph submittedJobGraph) -&amp;gt; submitJob(submittedJobGraph.getJobGraph(), RpcUtils.INF_TIMEOUT),&lt;/li&gt;
	&lt;li&gt;getMainThreadExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;submissionFuture.whenComplete(&lt;/li&gt;
	&lt;li&gt;(Acknowledge acknowledge, Throwable throwable) -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;if (throwable != null) {&lt;/li&gt;
	&lt;li&gt;onFatalError(&lt;/li&gt;
	&lt;li&gt;new DispatcherException(&lt;/li&gt;
	&lt;li&gt;String.format(&quot;Could not start the added job %s&quot;, jobId),&lt;/li&gt;
	&lt;li&gt;ExceptionUtils.stripCompletionException(throwable)));&lt;br/&gt;
+		runAsync(&lt;br/&gt;
+			() -&amp;gt; {&lt;br/&gt;
+				if (!jobManagerRunners.containsKey(jobId)) {&lt;br/&gt;
+					final CompletableFuture&amp;lt;JobGraph&amp;gt; recoveredJob = recoveryOperation.thenApplyAsync(&lt;br/&gt;
+						ignored -&amp;gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+							try {
+								return recoverJob(jobId);
+							} catch (Exception e) {
+								ExceptionUtils.rethrow(e);
+							}+							return null;+						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;,&lt;br/&gt;
+						getRpcService().getExecutor());&lt;br/&gt;
+&lt;br/&gt;
+					final DispatcherId dispatcherId = getFencingToken();&lt;br/&gt;
+					final CompletableFuture&amp;lt;Void&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;br/&gt;
+						(FunctionWithThrowable&amp;lt;JobGraph, CompletableFuture&amp;lt;Void&amp;gt;, Exception&amp;gt;) (JobGraph jobGraph) -&amp;gt; tryRunRecoveredJobGraph(jobGraph, dispatcherId)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   See my comment regarding the `ConsumerWithException`.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612347" author="githubbot" created="Wed, 12 Sep 2018 15:36:08 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217082586&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217082586&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -879,24 +917,66 @@ public void handleError(final Exception exception) {&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	public void onAddedJobGraph(final JobID jobId) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;SubmittedJobGraph&amp;gt; recoveredJob = getRpcService().execute(&lt;/li&gt;
	&lt;li&gt;() -&amp;gt; submittedJobGraphStore.recoverJobGraph(jobId));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;/li&gt;
	&lt;li&gt;(SubmittedJobGraph submittedJobGraph) -&amp;gt; submitJob(submittedJobGraph.getJobGraph(), RpcUtils.INF_TIMEOUT),&lt;/li&gt;
	&lt;li&gt;getMainThreadExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;submissionFuture.whenComplete(&lt;/li&gt;
	&lt;li&gt;(Acknowledge acknowledge, Throwable throwable) -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;if (throwable != null) {&lt;/li&gt;
	&lt;li&gt;onFatalError(&lt;/li&gt;
	&lt;li&gt;new DispatcherException(&lt;/li&gt;
	&lt;li&gt;String.format(&quot;Could not start the added job %s&quot;, jobId),&lt;/li&gt;
	&lt;li&gt;ExceptionUtils.stripCompletionException(throwable)));&lt;br/&gt;
+		runAsync(&lt;br/&gt;
+			() -&amp;gt; {&lt;br/&gt;
+				if (!jobManagerRunners.containsKey(jobId)) {&lt;br/&gt;
+					final CompletableFuture&amp;lt;JobGraph&amp;gt; recoveredJob = recoveryOperation.thenApplyAsync(&lt;br/&gt;
+						ignored -&amp;gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+							try {
+								return recoverJob(jobId);
+							} catch (Exception e) {
+								ExceptionUtils.rethrow(e);
+							}+							return null;+						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;,&lt;br/&gt;
+						getRpcService().getExecutor());&lt;br/&gt;
+&lt;br/&gt;
+					final DispatcherId dispatcherId = getFencingToken();&lt;br/&gt;
+					final CompletableFuture&amp;lt;Void&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;br/&gt;
+						(FunctionWithThrowable&amp;lt;JobGraph, CompletableFuture&amp;lt;Void&amp;gt;, Exception&amp;gt;) (JobGraph jobGraph) -&amp;gt; tryRunRecoveredJobGraph(jobGraph, dispatcherId)&lt;br/&gt;
+							.thenAcceptAsync(&lt;br/&gt;
+								(ConsumerWithException&amp;lt;Boolean, Exception&amp;gt;) (Boolean isRecoveredJobRunning) -&amp;gt; {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Imo we are doing this wrong. The API would be much more readible with static factory methods:&lt;/p&gt;

&lt;p&gt;   ```&lt;/p&gt;

&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;{@link Consumer}
&lt;p&gt; that can throw checked exceptions.&lt;br/&gt;
    */&lt;br/&gt;
   @FunctionalInterface&lt;br/&gt;
   public interface CheckedConsumer&amp;lt;T&amp;gt; {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   	void checkedAccept(T t) throws Exception;&lt;/p&gt;

&lt;p&gt;   	static &amp;lt;T&amp;gt; Consumer&amp;lt;T&amp;gt; unchecked(CheckedConsumer&amp;lt;T&amp;gt; checkedConsumer) {&lt;br/&gt;
   		return (t) -&amp;gt; {&lt;br/&gt;
   			try &lt;/p&gt;
{
   				checkedConsumer.checkedAccept(t);
   			}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
   				ExceptionUtils.rethrow(e);
   			}
&lt;p&gt;   		};&lt;br/&gt;
   	}&lt;br/&gt;
   }&lt;br/&gt;
   ```&lt;br/&gt;
   This allows for:&lt;br/&gt;
   ```&lt;br/&gt;
   CheckedConsumer.unchecked(isRecoveredJobRunning -&amp;gt; &lt;/p&gt;
{
        ...
   }
&lt;p&gt;);&lt;br/&gt;
   ``` &lt;br/&gt;
   No casts are required. Also when interacting with the Java API, it does not matter what exact type of exception can be thrown &#8211; what matters is that the checked exception becomes a unchecked. We do not need to generify the exception type in `ConsumerWithException`. &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612349" author="githubbot" created="Wed, 12 Sep 2018 15:36:35 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217082586&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217082586&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -879,24 +917,66 @@ public void handleError(final Exception exception) {&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	public void onAddedJobGraph(final JobID jobId) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;SubmittedJobGraph&amp;gt; recoveredJob = getRpcService().execute(&lt;/li&gt;
	&lt;li&gt;() -&amp;gt; submittedJobGraphStore.recoverJobGraph(jobId));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;/li&gt;
	&lt;li&gt;(SubmittedJobGraph submittedJobGraph) -&amp;gt; submitJob(submittedJobGraph.getJobGraph(), RpcUtils.INF_TIMEOUT),&lt;/li&gt;
	&lt;li&gt;getMainThreadExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;submissionFuture.whenComplete(&lt;/li&gt;
	&lt;li&gt;(Acknowledge acknowledge, Throwable throwable) -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;if (throwable != null) {&lt;/li&gt;
	&lt;li&gt;onFatalError(&lt;/li&gt;
	&lt;li&gt;new DispatcherException(&lt;/li&gt;
	&lt;li&gt;String.format(&quot;Could not start the added job %s&quot;, jobId),&lt;/li&gt;
	&lt;li&gt;ExceptionUtils.stripCompletionException(throwable)));&lt;br/&gt;
+		runAsync(&lt;br/&gt;
+			() -&amp;gt; {&lt;br/&gt;
+				if (!jobManagerRunners.containsKey(jobId)) {&lt;br/&gt;
+					final CompletableFuture&amp;lt;JobGraph&amp;gt; recoveredJob = recoveryOperation.thenApplyAsync(&lt;br/&gt;
+						ignored -&amp;gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+							try {
+								return recoverJob(jobId);
+							} catch (Exception e) {
+								ExceptionUtils.rethrow(e);
+							}+							return null;+						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;,&lt;br/&gt;
+						getRpcService().getExecutor());&lt;br/&gt;
+&lt;br/&gt;
+					final DispatcherId dispatcherId = getFencingToken();&lt;br/&gt;
+					final CompletableFuture&amp;lt;Void&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;br/&gt;
+						(FunctionWithThrowable&amp;lt;JobGraph, CompletableFuture&amp;lt;Void&amp;gt;, Exception&amp;gt;) (JobGraph jobGraph) -&amp;gt; tryRunRecoveredJobGraph(jobGraph, dispatcherId)&lt;br/&gt;
+							.thenAcceptAsync(&lt;br/&gt;
+								(ConsumerWithException&amp;lt;Boolean, Exception&amp;gt;) (Boolean isRecoveredJobRunning) -&amp;gt; {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Imo we are doing this wrong. The code would be much more readible with static factory methods:&lt;/p&gt;

&lt;p&gt;   ```&lt;/p&gt;

&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;{@link Consumer}
&lt;p&gt; that can throw checked exceptions.&lt;br/&gt;
    */&lt;br/&gt;
   @FunctionalInterface&lt;br/&gt;
   public interface CheckedConsumer&amp;lt;T&amp;gt; {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   	void checkedAccept(T t) throws Exception;&lt;/p&gt;

&lt;p&gt;   	static &amp;lt;T&amp;gt; Consumer&amp;lt;T&amp;gt; unchecked(CheckedConsumer&amp;lt;T&amp;gt; checkedConsumer) {&lt;br/&gt;
   		return (t) -&amp;gt; {&lt;br/&gt;
   			try &lt;/p&gt;
{
   				checkedConsumer.checkedAccept(t);
   			}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
   				ExceptionUtils.rethrow(e);
   			}
&lt;p&gt;   		};&lt;br/&gt;
   	}&lt;br/&gt;
   }&lt;br/&gt;
   ```&lt;br/&gt;
   This allows for:&lt;br/&gt;
   ```&lt;br/&gt;
   CheckedConsumer.unchecked(isRecoveredJobRunning -&amp;gt; &lt;/p&gt;
{
        ...
   }
&lt;p&gt;);&lt;br/&gt;
   ``` &lt;br/&gt;
   No casts are required. Also when interacting with the Java API, it does not matter what exact type of exception can be thrown &#8211; what matters is that the checked exception becomes a unchecked. We do not need to generify the exception type in `ConsumerWithException`. &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612350" author="githubbot" created="Wed, 12 Sep 2018 15:36:56 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217082586&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217082586&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -879,24 +917,66 @@ public void handleError(final Exception exception) {&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	public void onAddedJobGraph(final JobID jobId) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;SubmittedJobGraph&amp;gt; recoveredJob = getRpcService().execute(&lt;/li&gt;
	&lt;li&gt;() -&amp;gt; submittedJobGraphStore.recoverJobGraph(jobId));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;/li&gt;
	&lt;li&gt;(SubmittedJobGraph submittedJobGraph) -&amp;gt; submitJob(submittedJobGraph.getJobGraph(), RpcUtils.INF_TIMEOUT),&lt;/li&gt;
	&lt;li&gt;getMainThreadExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;submissionFuture.whenComplete(&lt;/li&gt;
	&lt;li&gt;(Acknowledge acknowledge, Throwable throwable) -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;if (throwable != null) {&lt;/li&gt;
	&lt;li&gt;onFatalError(&lt;/li&gt;
	&lt;li&gt;new DispatcherException(&lt;/li&gt;
	&lt;li&gt;String.format(&quot;Could not start the added job %s&quot;, jobId),&lt;/li&gt;
	&lt;li&gt;ExceptionUtils.stripCompletionException(throwable)));&lt;br/&gt;
+		runAsync(&lt;br/&gt;
+			() -&amp;gt; {&lt;br/&gt;
+				if (!jobManagerRunners.containsKey(jobId)) {&lt;br/&gt;
+					final CompletableFuture&amp;lt;JobGraph&amp;gt; recoveredJob = recoveryOperation.thenApplyAsync(&lt;br/&gt;
+						ignored -&amp;gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+							try {
+								return recoverJob(jobId);
+							} catch (Exception e) {
+								ExceptionUtils.rethrow(e);
+							}+							return null;+						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;,&lt;br/&gt;
+						getRpcService().getExecutor());&lt;br/&gt;
+&lt;br/&gt;
+					final DispatcherId dispatcherId = getFencingToken();&lt;br/&gt;
+					final CompletableFuture&amp;lt;Void&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;br/&gt;
+						(FunctionWithThrowable&amp;lt;JobGraph, CompletableFuture&amp;lt;Void&amp;gt;, Exception&amp;gt;) (JobGraph jobGraph) -&amp;gt; tryRunRecoveredJobGraph(jobGraph, dispatcherId)&lt;br/&gt;
+							.thenAcceptAsync(&lt;br/&gt;
+								(ConsumerWithException&amp;lt;Boolean, Exception&amp;gt;) (Boolean isRecoveredJobRunning) -&amp;gt; {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Imo we are doing this wrong. The code would be much more readible with static factory methods:&lt;/p&gt;

&lt;p&gt;   ```&lt;/p&gt;

&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;{@link Consumer}
&lt;p&gt; that can throw checked exceptions.&lt;br/&gt;
    */&lt;br/&gt;
   @FunctionalInterface&lt;br/&gt;
   public interface CheckedConsumer&amp;lt;T&amp;gt; {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   	void checkedAccept(T t) throws Exception;&lt;/p&gt;

&lt;p&gt;   	static &amp;lt;T&amp;gt; Consumer&amp;lt;T&amp;gt; unchecked(CheckedConsumer&amp;lt;T&amp;gt; checkedConsumer) {&lt;br/&gt;
   		return (t) -&amp;gt; {&lt;br/&gt;
   			try &lt;/p&gt;
{
   				checkedConsumer.checkedAccept(t);
   			}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
   				ExceptionUtils.rethrow(e);
   			}
&lt;p&gt;   		};&lt;br/&gt;
   	}&lt;br/&gt;
   }&lt;br/&gt;
   ```&lt;br/&gt;
   This allows for:&lt;br/&gt;
   ```&lt;br/&gt;
   .thenAcceptAsync(CheckedConsumer.unchecked(isRecoveredJobRunning -&amp;gt; &lt;/p&gt;
{
        ...
   }
&lt;p&gt;);&lt;br/&gt;
   ``` &lt;br/&gt;
   No casts are required. Also when interacting with the Java API, it does not matter what exact type of exception can be thrown &#8211; what matters is that the checked exception becomes a unchecked. We do not need to generify the exception type in `ConsumerWithException`. &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612351" author="githubbot" created="Wed, 12 Sep 2018 15:37:04 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217082586&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217082586&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -879,24 +917,66 @@ public void handleError(final Exception exception) {&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	public void onAddedJobGraph(final JobID jobId) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;SubmittedJobGraph&amp;gt; recoveredJob = getRpcService().execute(&lt;/li&gt;
	&lt;li&gt;() -&amp;gt; submittedJobGraphStore.recoverJobGraph(jobId));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;/li&gt;
	&lt;li&gt;(SubmittedJobGraph submittedJobGraph) -&amp;gt; submitJob(submittedJobGraph.getJobGraph(), RpcUtils.INF_TIMEOUT),&lt;/li&gt;
	&lt;li&gt;getMainThreadExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;submissionFuture.whenComplete(&lt;/li&gt;
	&lt;li&gt;(Acknowledge acknowledge, Throwable throwable) -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;if (throwable != null) {&lt;/li&gt;
	&lt;li&gt;onFatalError(&lt;/li&gt;
	&lt;li&gt;new DispatcherException(&lt;/li&gt;
	&lt;li&gt;String.format(&quot;Could not start the added job %s&quot;, jobId),&lt;/li&gt;
	&lt;li&gt;ExceptionUtils.stripCompletionException(throwable)));&lt;br/&gt;
+		runAsync(&lt;br/&gt;
+			() -&amp;gt; {&lt;br/&gt;
+				if (!jobManagerRunners.containsKey(jobId)) {&lt;br/&gt;
+					final CompletableFuture&amp;lt;JobGraph&amp;gt; recoveredJob = recoveryOperation.thenApplyAsync(&lt;br/&gt;
+						ignored -&amp;gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+							try {
+								return recoverJob(jobId);
+							} catch (Exception e) {
+								ExceptionUtils.rethrow(e);
+							}+							return null;+						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;,&lt;br/&gt;
+						getRpcService().getExecutor());&lt;br/&gt;
+&lt;br/&gt;
+					final DispatcherId dispatcherId = getFencingToken();&lt;br/&gt;
+					final CompletableFuture&amp;lt;Void&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;br/&gt;
+						(FunctionWithThrowable&amp;lt;JobGraph, CompletableFuture&amp;lt;Void&amp;gt;, Exception&amp;gt;) (JobGraph jobGraph) -&amp;gt; tryRunRecoveredJobGraph(jobGraph, dispatcherId)&lt;br/&gt;
+							.thenAcceptAsync(&lt;br/&gt;
+								(ConsumerWithException&amp;lt;Boolean, Exception&amp;gt;) (Boolean isRecoveredJobRunning) -&amp;gt; {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Imo we are doing this wrong. The code would be much more readible with static factory methods:&lt;/p&gt;

&lt;p&gt;   ```&lt;/p&gt;

&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;{@link Consumer}
&lt;p&gt; that can throw checked exceptions.&lt;br/&gt;
    */&lt;br/&gt;
   @FunctionalInterface&lt;br/&gt;
   public interface CheckedConsumer&amp;lt;T&amp;gt; {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   	void checkedAccept(T t) throws Exception;&lt;/p&gt;

&lt;p&gt;   	static &amp;lt;T&amp;gt; Consumer&amp;lt;T&amp;gt; unchecked(CheckedConsumer&amp;lt;T&amp;gt; checkedConsumer) {&lt;br/&gt;
   		return (t) -&amp;gt; {&lt;br/&gt;
   			try &lt;/p&gt;
{
   				checkedConsumer.checkedAccept(t);
   			}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
   				ExceptionUtils.rethrow(e);
   			}
&lt;p&gt;   		};&lt;br/&gt;
   	}&lt;br/&gt;
   }&lt;br/&gt;
   ```&lt;br/&gt;
   This allows for:&lt;br/&gt;
   ```&lt;br/&gt;
   .thenAcceptAsync(CheckedConsumer.unchecked(isRecoveredJobRunning -&amp;gt; &lt;/p&gt;
{
        ...
   }
&lt;p&gt;));&lt;br/&gt;
   ...&lt;br/&gt;
   ``` &lt;br/&gt;
   No casts are required. Also when interacting with the Java API, it does not matter what exact type of exception can be thrown &#8211; what matters is that the checked exception becomes a unchecked. We do not need to generify the exception type in `ConsumerWithException`. &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612362" author="githubbot" created="Wed, 12 Sep 2018 15:40:34 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217082586&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217082586&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -879,24 +917,66 @@ public void handleError(final Exception exception) {&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	public void onAddedJobGraph(final JobID jobId) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;SubmittedJobGraph&amp;gt; recoveredJob = getRpcService().execute(&lt;/li&gt;
	&lt;li&gt;() -&amp;gt; submittedJobGraphStore.recoverJobGraph(jobId));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;/li&gt;
	&lt;li&gt;(SubmittedJobGraph submittedJobGraph) -&amp;gt; submitJob(submittedJobGraph.getJobGraph(), RpcUtils.INF_TIMEOUT),&lt;/li&gt;
	&lt;li&gt;getMainThreadExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;submissionFuture.whenComplete(&lt;/li&gt;
	&lt;li&gt;(Acknowledge acknowledge, Throwable throwable) -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;if (throwable != null) {&lt;/li&gt;
	&lt;li&gt;onFatalError(&lt;/li&gt;
	&lt;li&gt;new DispatcherException(&lt;/li&gt;
	&lt;li&gt;String.format(&quot;Could not start the added job %s&quot;, jobId),&lt;/li&gt;
	&lt;li&gt;ExceptionUtils.stripCompletionException(throwable)));&lt;br/&gt;
+		runAsync(&lt;br/&gt;
+			() -&amp;gt; {&lt;br/&gt;
+				if (!jobManagerRunners.containsKey(jobId)) {&lt;br/&gt;
+					final CompletableFuture&amp;lt;JobGraph&amp;gt; recoveredJob = recoveryOperation.thenApplyAsync(&lt;br/&gt;
+						ignored -&amp;gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+							try {
+								return recoverJob(jobId);
+							} catch (Exception e) {
+								ExceptionUtils.rethrow(e);
+							}+							return null;+						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;,&lt;br/&gt;
+						getRpcService().getExecutor());&lt;br/&gt;
+&lt;br/&gt;
+					final DispatcherId dispatcherId = getFencingToken();&lt;br/&gt;
+					final CompletableFuture&amp;lt;Void&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;br/&gt;
+						(FunctionWithThrowable&amp;lt;JobGraph, CompletableFuture&amp;lt;Void&amp;gt;, Exception&amp;gt;) (JobGraph jobGraph) -&amp;gt; tryRunRecoveredJobGraph(jobGraph, dispatcherId)&lt;br/&gt;
+							.thenAcceptAsync(&lt;br/&gt;
+								(ConsumerWithException&amp;lt;Boolean, Exception&amp;gt;) (Boolean isRecoveredJobRunning) -&amp;gt; {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Imo we are doing this wrong. The code would be much more readible with static factory methods:&lt;/p&gt;

&lt;p&gt;   ```&lt;/p&gt;

&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;{@link Consumer}
&lt;p&gt; that can throw checked exceptions.&lt;br/&gt;
    */&lt;br/&gt;
   @FunctionalInterface&lt;br/&gt;
   public interface CheckedConsumer&amp;lt;T&amp;gt; {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   	void checkedAccept(T t) throws Exception;&lt;/p&gt;

&lt;p&gt;   	static &amp;lt;T&amp;gt; Consumer&amp;lt;T&amp;gt; unchecked(CheckedConsumer&amp;lt;T&amp;gt; checkedConsumer) {&lt;br/&gt;
   		return (t) -&amp;gt; {&lt;br/&gt;
   			try &lt;/p&gt;
{
   				checkedConsumer.checkedAccept(t);
   			}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
   				ExceptionUtils.rethrow(e);
   			}
&lt;p&gt;   		};&lt;br/&gt;
   	}&lt;br/&gt;
   }&lt;br/&gt;
   ```&lt;br/&gt;
   This allows for:&lt;br/&gt;
   ```&lt;br/&gt;
   .thenAcceptAsync(CheckedConsumer.unchecked(isRecoveredJobRunning -&amp;gt; &lt;/p&gt;
{
        ...
   }
&lt;p&gt;));&lt;br/&gt;
   ...&lt;br/&gt;
   ``` &lt;br/&gt;
   No casts are required. Also when interacting with the Java API, it does not matter what exact type of exception can be thrown &#8211; what matters is that the checked exception becomes unchecked. We do not need to generify the exception type in `ConsumerWithException`. &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16612370" author="githubbot" created="Wed, 12 Sep 2018 15:42:20 +0000"  >&lt;p&gt;GJL commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217085458&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217085458&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -167,7 +181,7 @@ public void testSubmittedJobGraphRelease() throws Exception {&lt;br/&gt;
 				// recover the job&lt;br/&gt;
 				final SubmittedJobGraph submittedJobGraph = otherSubmittedJobGraphStore.recoverJobGraph(jobId);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertThat(submittedJobGraph, Matchers.is(Matchers.notNullValue()));&lt;br/&gt;
+				assertThat(submittedJobGraph, is(Matchers.notNullValue()));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   You added a static import for `is` but not for `notNullValue`. I think this should be consistent.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16613162" author="githubbot" created="Thu, 13 Sep 2018 07:57:35 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217291912&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217291912&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -879,24 +917,66 @@ public void handleError(final Exception exception) {&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	public void onAddedJobGraph(final JobID jobId) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;SubmittedJobGraph&amp;gt; recoveredJob = getRpcService().execute(&lt;/li&gt;
	&lt;li&gt;() -&amp;gt; submittedJobGraphStore.recoverJobGraph(jobId));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;/li&gt;
	&lt;li&gt;(SubmittedJobGraph submittedJobGraph) -&amp;gt; submitJob(submittedJobGraph.getJobGraph(), RpcUtils.INF_TIMEOUT),&lt;/li&gt;
	&lt;li&gt;getMainThreadExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;submissionFuture.whenComplete(&lt;/li&gt;
	&lt;li&gt;(Acknowledge acknowledge, Throwable throwable) -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;if (throwable != null) {&lt;/li&gt;
	&lt;li&gt;onFatalError(&lt;/li&gt;
	&lt;li&gt;new DispatcherException(&lt;/li&gt;
	&lt;li&gt;String.format(&quot;Could not start the added job %s&quot;, jobId),&lt;/li&gt;
	&lt;li&gt;ExceptionUtils.stripCompletionException(throwable)));&lt;br/&gt;
+		runAsync(&lt;br/&gt;
+			() -&amp;gt; {&lt;br/&gt;
+				if (!jobManagerRunners.containsKey(jobId)) {&lt;br/&gt;
+					final CompletableFuture&amp;lt;JobGraph&amp;gt; recoveredJob = recoveryOperation.thenApplyAsync(&lt;br/&gt;
+						ignored -&amp;gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+							try {
+								return recoverJob(jobId);
+							} catch (Exception e) {
+								ExceptionUtils.rethrow(e);
+							}+							return null;+						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;,&lt;br/&gt;
+						getRpcService().getExecutor());&lt;br/&gt;
+&lt;br/&gt;
+					final DispatcherId dispatcherId = getFencingToken();&lt;br/&gt;
+					final CompletableFuture&amp;lt;Void&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;br/&gt;
+						(FunctionWithThrowable&amp;lt;JobGraph, CompletableFuture&amp;lt;Void&amp;gt;, Exception&amp;gt;) (JobGraph jobGraph) -&amp;gt; tryRunRecoveredJobGraph(jobGraph, dispatcherId)&lt;br/&gt;
+							.thenAcceptAsync(&lt;br/&gt;
+								(ConsumerWithException&amp;lt;Boolean, Exception&amp;gt;) (Boolean isRecoveredJobRunning) -&amp;gt; {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Good point. I like this approach better. Will adapt the existing interfaces.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16613163" author="githubbot" created="Thu, 13 Sep 2018 07:57:54 +0000"  >&lt;p&gt;tillrohrmann commented on a change in pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#discussion_r217291997&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#discussion_r217291997&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -167,7 +181,7 @@ public void testSubmittedJobGraphRelease() throws Exception {&lt;br/&gt;
 				// recover the job&lt;br/&gt;
 				final SubmittedJobGraph submittedJobGraph = otherSubmittedJobGraphStore.recoverJobGraph(jobId);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertThat(submittedJobGraph, Matchers.is(Matchers.notNullValue()));&lt;br/&gt;
+				assertThat(submittedJobGraph, is(Matchers.notNullValue()));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Good catch. Will change it.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16613200" author="githubbot" created="Thu, 13 Sep 2018 08:36:04 +0000"  >&lt;p&gt;tillrohrmann commented on issue #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#issuecomment-420928749&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#issuecomment-420928749&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Thanks for the review @GJL. I&apos;ve addressed your comments and after Travis gives green light, I&apos;ll merge it.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16614802" author="githubbot" created="Fri, 14 Sep 2018 13:03:47 +0000"  >&lt;p&gt;asfgit closed pull request #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/flink-container/src/main/java/org/apache/flink/container/entrypoint/StandaloneJobClusterConfiguration.java b/flink-container/src/main/java/org/apache/flink/container/entrypoint/StandaloneJobClusterConfiguration.java&lt;br/&gt;
index 326e924b448..d8ad5aba8ea 100644&lt;br/&gt;
&amp;#8212; a/flink-container/src/main/java/org/apache/flink/container/entrypoint/StandaloneJobClusterConfiguration.java&lt;br/&gt;
+++ b/flink-container/src/main/java/org/apache/flink/container/entrypoint/StandaloneJobClusterConfiguration.java&lt;br/&gt;
@@ -22,6 +22,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.SavepointRestoreSettings;&lt;/p&gt;

&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
+import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.util.Properties;&lt;/p&gt;

&lt;p&gt;@@ -36,8 +37,8 @@&lt;br/&gt;
 	@Nonnull&lt;br/&gt;
 	private final SavepointRestoreSettings savepointRestoreSettings;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public StandaloneJobClusterConfiguration(@Nonnull String configDir, @Nonnull Properties dynamicProperties, @Nonnull String[] args, int restPort, @Nonnull String jobClassName, @Nonnull SavepointRestoreSettings savepointRestoreSettings) {&lt;/li&gt;
	&lt;li&gt;super(configDir, dynamicProperties, args, restPort);&lt;br/&gt;
+	public StandaloneJobClusterConfiguration(@Nonnull String configDir, @Nonnull Properties dynamicProperties, @Nonnull String[] args, @Nullable String hostname, int restPort, @Nonnull String jobClassName, @Nonnull SavepointRestoreSettings savepointRestoreSettings) 
{
+		super(configDir, dynamicProperties, args, hostname, restPort);
 		this.jobClassName = jobClassName;
 		this.savepointRestoreSettings = savepointRestoreSettings;
 	}
&lt;p&gt;diff --git a/flink-container/src/main/java/org/apache/flink/container/entrypoint/StandaloneJobClusterConfigurationParserFactory.java b/flink-container/src/main/java/org/apache/flink/container/entrypoint/StandaloneJobClusterConfigurationParserFactory.java&lt;br/&gt;
index 3c65ba864ed..17217eff018 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-container/src/main/java/org/apache/flink/container/entrypoint/StandaloneJobClusterConfigurationParserFactory.java&lt;br/&gt;
+++ b/flink-container/src/main/java/org/apache/flink/container/entrypoint/StandaloneJobClusterConfigurationParserFactory.java&lt;br/&gt;
@@ -32,6 +32,7 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import static org.apache.flink.runtime.entrypoint.parser.CommandLineOptions.CONFIG_DIR_OPTION;&lt;br/&gt;
 import static org.apache.flink.runtime.entrypoint.parser.CommandLineOptions.DYNAMIC_PROPERTY_OPTION;&lt;br/&gt;
+import static org.apache.flink.runtime.entrypoint.parser.CommandLineOptions.HOST_OPTION;&lt;br/&gt;
 import static org.apache.flink.runtime.entrypoint.parser.CommandLineOptions.REST_PORT_OPTION;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -67,6 +68,7 @@ public StandaloneJobClusterConfiguration createResult(@Nonnull CommandLine comma&lt;br/&gt;
 		final Properties dynamicProperties = commandLine.getOptionProperties(DYNAMIC_PROPERTY_OPTION.getOpt());&lt;br/&gt;
 		final String restPortString = commandLine.getOptionValue(REST_PORT_OPTION.getOpt(), &quot;-1&quot;);&lt;br/&gt;
 		final int restPort = Integer.parseInt(restPortString);&lt;br/&gt;
+		final String hostname = commandLine.getOptionValue(HOST_OPTION.getOpt());&lt;br/&gt;
 		final String jobClassName = commandLine.getOptionValue(JOB_CLASS_NAME_OPTION.getOpt());&lt;br/&gt;
 		final SavepointRestoreSettings savepointRestoreSettings = CliFrontendParser.createSavepointRestoreSettings(commandLine);&lt;/p&gt;

&lt;p&gt;@@ -74,6 +76,7 @@ public StandaloneJobClusterConfiguration createResult(@Nonnull CommandLine comma&lt;br/&gt;
 			configDir,&lt;br/&gt;
 			dynamicProperties,&lt;br/&gt;
 			commandLine.getArgs(),&lt;br/&gt;
+			hostname,&lt;br/&gt;
 			restPort,&lt;br/&gt;
 			jobClassName,&lt;br/&gt;
 			savepointRestoreSettings);&lt;br/&gt;
diff --git a/flink-core/src/main/java/org/apache/flink/util/function/BiConsumerWithException.java b/flink-core/src/main/java/org/apache/flink/util/function/BiConsumerWithException.java&lt;br/&gt;
index 5864c8a985d..6fc5b76f246 100644&lt;br/&gt;
&amp;#8212; a/flink-core/src/main/java/org/apache/flink/util/function/BiConsumerWithException.java&lt;br/&gt;
+++ b/flink-core/src/main/java/org/apache/flink/util/function/BiConsumerWithException.java&lt;br/&gt;
@@ -30,7 +30,7 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param &amp;lt;E&amp;gt; type of the thrown exception&lt;br/&gt;
  */&lt;br/&gt;
 @FunctionalInterface&lt;br/&gt;
-public interface BiConsumerWithException&amp;lt;T, U, E extends Throwable&amp;gt; extends BiConsumer&amp;lt;T, U&amp;gt; {&lt;br/&gt;
+public interface BiConsumerWithException&amp;lt;T, U, E extends Throwable&amp;gt; {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Performs this operation on the given arguments.&lt;br/&gt;
@@ -39,14 +39,23 @@&lt;/li&gt;
	&lt;li&gt;@param u the second input argument&lt;/li&gt;
	&lt;li&gt;@throws E in case of an error&lt;br/&gt;
 	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;void acceptWithException(T t, U u) throws E;&lt;br/&gt;
+	void accept(T t, U u) throws E;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;default void accept(T t, U u) {&lt;/li&gt;
	&lt;li&gt;try 
{
-			acceptWithException(t, u);
-		}
&lt;p&gt; catch (Throwable e) &lt;/p&gt;
{
-			ExceptionUtils.rethrow(e);
-		}
&lt;p&gt;+	/**&lt;br/&gt;
+	 * Convert a &lt;/p&gt;
{@link BiConsumerWithException}
&lt;p&gt; into a &lt;/p&gt;
{@link BiConsumer}.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param biConsumerWithException BiConsumer with exception to convert into a {@link BiConsumer}
&lt;p&gt;.&lt;br/&gt;
+	 * @param &amp;lt;A&amp;gt; first input type&lt;br/&gt;
+	 * @param &amp;lt;B&amp;gt; second input type&lt;br/&gt;
+	 * @return &lt;/p&gt;
{@link BiConsumer}
&lt;p&gt; which rethrows all checked exceptions as unchecked.&lt;br/&gt;
+	 */&lt;br/&gt;
+	static &amp;lt;A, B&amp;gt; BiConsumer&amp;lt;A, B&amp;gt; unchecked(BiConsumerWithException&amp;lt;A, B, ?&amp;gt; biConsumerWithException) {&lt;br/&gt;
+		return (A a, B b) -&amp;gt; &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			try {
+				biConsumerWithException.accept(a, b);
+			} catch (Throwable t) {
+				ExceptionUtils.rethrow(t);
+			}&lt;br/&gt;
+		};&lt;br/&gt;
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-core/src/main/java/org/apache/flink/util/function/BiFunctionWithException.java b/flink-core/src/main/java/org/apache/flink/util/function/BiFunctionWithException.java&lt;br/&gt;
index 967c737e584..ccba8a7e774 100644&lt;br/&gt;
&amp;#8212; a/flink-core/src/main/java/org/apache/flink/util/function/BiFunctionWithException.java&lt;br/&gt;
+++ b/flink-core/src/main/java/org/apache/flink/util/function/BiFunctionWithException.java&lt;br/&gt;
@@ -31,7 +31,7 @@&lt;br/&gt;
  * @param &amp;lt;E&amp;gt; type of the exception which can be thrown&lt;br/&gt;
  */&lt;br/&gt;
 @FunctionalInterface&lt;br/&gt;
-public interface BiFunctionWithException&amp;lt;T, U, R, E extends Throwable&amp;gt; extends BiFunction&amp;lt;T, U, R&amp;gt; {&lt;br/&gt;
+public interface BiFunctionWithException&amp;lt;T, U, R, E extends Throwable&amp;gt; {&lt;br/&gt;
 &lt;br/&gt;
 	/**&lt;br/&gt;
 	 * Apply the given values t and u to obtain the resulting value. The operation can&lt;br/&gt;
@@ -42,16 +42,25 @@&lt;br/&gt;
 	 * @return result value&lt;br/&gt;
 	 * @throws E if the operation fails&lt;br/&gt;
 	 */&lt;br/&gt;
-	R applyWithException(T t, U u) throws E;&lt;br/&gt;
+	R apply(T t, U u) throws E;&lt;br/&gt;
 &lt;br/&gt;
-	default R apply(T t, U u) {&lt;br/&gt;
-		try {
-			return applyWithException(t, u);
-		} catch (Throwable e) {
-			ExceptionUtils.rethrow(e);
-			// we have to return a value to please the compiler
-			// but we will never reach the code here
-			return null;
-		}&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Convert at {@link BiFunctionWithException} into a {@link BiFunction}.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param biFunctionWithException function with exception to convert into a function&lt;br/&gt;
+	 * @param &amp;lt;A&amp;gt; input type&lt;br/&gt;
+	 * @param &amp;lt;B&amp;gt; output type&lt;br/&gt;
+	 * @return {@link BiFunction} which throws all checked exception as an unchecked exception.&lt;br/&gt;
+	 */&lt;br/&gt;
+	static &amp;lt;A, B, C&amp;gt; BiFunction&amp;lt;A, B, C&amp;gt; unchecked(BiFunctionWithException&amp;lt;A, B, C, ?&amp;gt; biFunctionWithException) {&lt;br/&gt;
+		return (A a, B b) -&amp;gt; {&lt;br/&gt;
+			try {
+				return biFunctionWithException.apply(a, b);
+			} catch (Throwable t) {
+				ExceptionUtils.rethrow(t);
+				// we need this to appease the compiler :-(
+				return null;
+			}&lt;br/&gt;
+		};&lt;br/&gt;
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-core/src/main/java/org/apache/flink/util/function/ConsumerWithException.java b/flink-core/src/main/java/org/apache/flink/util/function/ConsumerWithException.java&lt;br/&gt;
deleted file mode 100644&lt;br/&gt;
index 09507d4e9f2..00000000000&lt;br/&gt;
&amp;#8212; a/flink-core/src/main/java/org/apache/flink/util/function/ConsumerWithException.java&lt;br/&gt;
+++ /dev/null&lt;br/&gt;
@@ -1,43 +0,0 @@&lt;br/&gt;
-/*&lt;br/&gt;
- * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
- * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
- * distributed with this work for additional information&lt;br/&gt;
- * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
- * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
- * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
- * with the License.  You may obtain a copy of the License at&lt;br/&gt;
- *&lt;br/&gt;
- *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
- *&lt;br/&gt;
- * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
- * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
- * See the License for the specific language governing permissions and&lt;br/&gt;
- * limitations under the License.&lt;br/&gt;
- */&lt;br/&gt;
-&lt;br/&gt;
-package org.apache.flink.util.function;&lt;br/&gt;
-&lt;br/&gt;
-import org.apache.flink.util.ExceptionUtils;&lt;br/&gt;
-&lt;br/&gt;
-import java.util.function.Consumer;&lt;br/&gt;
-&lt;br/&gt;
-/**&lt;br/&gt;
- * A checked extension of the {@link Consumer} interface.&lt;br/&gt;
- *&lt;br/&gt;
- * @param &amp;lt;T&amp;gt; type of the first argument&lt;br/&gt;
- * @param &amp;lt;E&amp;gt; type of the thrown exception&lt;br/&gt;
- */&lt;br/&gt;
-public interface ConsumerWithException&amp;lt;T, E extends Throwable&amp;gt; extends Consumer&amp;lt;T&amp;gt; {&lt;br/&gt;
-&lt;br/&gt;
-	void acceptWithException(T value) throws E;&lt;br/&gt;
-&lt;br/&gt;
-	@Override&lt;br/&gt;
-	default void accept(T value) {&lt;br/&gt;
-		try {
-			acceptWithException(value);
-		} catch (Throwable t) {
-			ExceptionUtils.rethrow(t);
-		}&lt;br/&gt;
-	}&lt;br/&gt;
-}&lt;br/&gt;
diff --git a/flink-core/src/main/java/org/apache/flink/util/function/FunctionUtils.java b/flink-core/src/main/java/org/apache/flink/util/function/FunctionUtils.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..678ef9f78b6&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-core/src/main/java/org/apache/flink/util/function/FunctionUtils.java&lt;br/&gt;
@@ -0,0 +1,72 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.util.function;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.util.ExceptionUtils;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.function.Consumer;&lt;br/&gt;
+import java.util.function.Function;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Utility class for Flink&apos;s functions.&lt;br/&gt;
+ */&lt;br/&gt;
+public class FunctionUtils {&lt;br/&gt;
+&lt;br/&gt;
+	private FunctionUtils() {
+		throw new UnsupportedOperationException(&quot;This class should never be instantiated.&quot;);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Convert at {@link FunctionWithException} into a {@link Function}.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param functionWithException function with exception to convert into a function&lt;br/&gt;
+	 * @param &amp;lt;A&amp;gt; input type&lt;br/&gt;
+	 * @param &amp;lt;B&amp;gt; output type&lt;br/&gt;
+	 * @return {@link Function} which throws all checked exception as an unchecked exception.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;A, B&amp;gt; Function&amp;lt;A, B&amp;gt; uncheckedFunction(FunctionWithException&amp;lt;A, B, ?&amp;gt; functionWithException) {&lt;br/&gt;
+		return (A value) -&amp;gt; {&lt;br/&gt;
+			try {
+				return functionWithException.apply(value);
+			} catch (Throwable t) {
+				ExceptionUtils.rethrow(t);
+				// we need this to appease the compiler :-(
+				return null;
+			}&lt;br/&gt;
+		};&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Converts a {@link ThrowingConsumer} into a {@link Consumer} which throws checked exceptions&lt;br/&gt;
+	 * as unchecked.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param throwingConsumer to convert into a {@link Consumer}&lt;br/&gt;
+	 * @param &amp;lt;A&amp;gt; input type&lt;br/&gt;
+	 * @return {@link Consumer} which throws all checked exceptions as unchecked&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;A&amp;gt; Consumer&amp;lt;A&amp;gt; uncheckedConsumer(ThrowingConsumer&amp;lt;A, ?&amp;gt; throwingConsumer) {&lt;br/&gt;
+		return (A value) -&amp;gt; {&lt;br/&gt;
+			try {
+				throwingConsumer.accept(value);
+			} catch (Throwable t) {+				ExceptionUtils.rethrow(t);+			}+		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;;&lt;br/&gt;
+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-core/src/main/java/org/apache/flink/util/function/ThrowingRunnable.java b/flink-core/src/main/java/org/apache/flink/util/function/ThrowingRunnable.java&lt;br/&gt;
index 4fef4207838..0dd4047a1e5 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-core/src/main/java/org/apache/flink/util/function/ThrowingRunnable.java&lt;br/&gt;
+++ b/flink-core/src/main/java/org/apache/flink/util/function/ThrowingRunnable.java&lt;br/&gt;
@@ -19,6 +19,7 @@&lt;br/&gt;
 package org.apache.flink.util.function;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import org.apache.flink.annotation.PublicEvolving;&lt;br/&gt;
+import org.apache.flink.util.ExceptionUtils;&lt;/p&gt;

&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Similar to a 
{@link Runnable}, this interface is used to capture a block of code&lt;br/&gt;
@@ -35,4 +36,21 @@&lt;br/&gt;
 	 * @throws E Exceptions may be thrown.&lt;br/&gt;
 	 */&lt;br/&gt;
 	void run() throws E;&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Converts a {@link ThrowingRunnable} into a {@link Runnable}
&lt;p&gt; which throws all checked exceptions&lt;br/&gt;
+	 * as unchecked.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param throwingRunnable to convert into a &lt;/p&gt;
{@link Runnable}&lt;br/&gt;
+	 * @return {@link Runnable}
&lt;p&gt; which throws all checked exceptions as unchecked.&lt;br/&gt;
+	 */&lt;br/&gt;
+	static Runnable unchecked(ThrowingRunnable&amp;lt;?&amp;gt; throwingRunnable) {&lt;br/&gt;
+		return () -&amp;gt; &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			try {
+				throwingRunnable.run();
+			} catch (Throwable t) {
+				ExceptionUtils.rethrow(t);
+			}+		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;;&lt;br/&gt;
+	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
index 131733924ae..e443fc21552 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java&lt;br/&gt;
@@ -25,7 +25,7 @@&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;&lt;br/&gt;
 import org.apache.flink.util.FlinkException;&lt;br/&gt;
-import org.apache.flink.util.function.ConsumerWithException;&lt;br/&gt;
+import org.apache.flink.util.function.ThrowingConsumer;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import org.apache.curator.framework.CuratorFramework;&lt;br/&gt;
 import org.apache.curator.utils.ZKPaths;&lt;br/&gt;
@@ -246,7 +246,7 @@ public void addCheckpoint(final CompletedCheckpoint checkpoint) throws Exception&lt;br/&gt;
 		LOG.debug(&quot;Added {} to {}.&quot;, checkpoint, path);&lt;br/&gt;
 	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private void tryRemoveCompletedCheckpoint(CompletedCheckpoint completedCheckpoint, ConsumerWithException&amp;lt;CompletedCheckpoint, Exception&amp;gt; discardCallback) {&lt;br/&gt;
+	private void tryRemoveCompletedCheckpoint(CompletedCheckpoint completedCheckpoint, ThrowingConsumer&amp;lt;CompletedCheckpoint, Exception&amp;gt; discardCallback) {&lt;br/&gt;
 		try {&lt;br/&gt;
 			if (tryRemove(completedCheckpoint.getCheckpointID())) {&lt;br/&gt;
 				executor.execute(() -&amp;gt; {&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
index c31e64c0adc..5279e502a93 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&lt;br/&gt;
@@ -60,11 +60,13 @@&lt;br/&gt;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;&lt;br/&gt;
 import org.apache.flink.runtime.rpc.FencedRpcEndpoint;&lt;br/&gt;
 import org.apache.flink.runtime.rpc.RpcService;&lt;br/&gt;
-import org.apache.flink.runtime.rpc.RpcUtils;&lt;br/&gt;
 import org.apache.flink.util.ExceptionUtils;&lt;br/&gt;
 import org.apache.flink.util.FlinkException;&lt;br/&gt;
 import org.apache.flink.util.Preconditions;&lt;br/&gt;
-import org.apache.flink.util.function.ConsumerWithException;&lt;br/&gt;
+import org.apache.flink.util.function.BiFunctionWithException;&lt;br/&gt;
+import org.apache.flink.util.function.FunctionUtils;&lt;br/&gt;
+import org.apache.flink.util.function.ThrowingConsumer;&lt;br/&gt;
+import org.apache.flink.util.function.ThrowingRunnable;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
 import javax.annotation.Nullable;&lt;br/&gt;
@@ -128,6 +130,8 @@&lt;/p&gt;

&lt;p&gt; 	private final Map&amp;lt;JobID, CompletableFuture&amp;lt;Void&amp;gt;&amp;gt; jobManagerTerminationFutures;&lt;/p&gt;

&lt;p&gt;+	private CompletableFuture&amp;lt;Void&amp;gt; recoveryOperation = CompletableFuture.completedFuture(null);&lt;br/&gt;
+&lt;br/&gt;
 	public Dispatcher(&lt;br/&gt;
 			RpcService rpcService,&lt;br/&gt;
 			String endpointId,&lt;br/&gt;
@@ -629,31 +633,51 @@ private void terminateJobManagerRunners() {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Recovers all jobs persisted via the submitted job graph store.&lt;br/&gt;
 	 */&lt;br/&gt;
 	@VisibleForTesting&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompletableFuture&amp;lt;Collection&amp;lt;JobGraph&amp;gt;&amp;gt; recoverJobs() {&lt;br/&gt;
+	Collection&amp;lt;JobGraph&amp;gt; recoverJobs() throws Exception {&lt;br/&gt;
 		log.info(&quot;Recovering all persisted jobs.&quot;);&lt;/li&gt;
	&lt;li&gt;return FutureUtils.supplyAsync(&lt;/li&gt;
	&lt;li&gt;() -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;final Collection&amp;lt;JobID&amp;gt; jobIds = submittedJobGraphStore.getJobIds();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;JobGraph&amp;gt; jobGraphs = new ArrayList&amp;lt;&amp;gt;(jobIds.size());&lt;br/&gt;
+		final Collection&amp;lt;JobID&amp;gt; jobIds = submittedJobGraphStore.getJobIds();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for (JobID jobId : jobIds) {&lt;/li&gt;
	&lt;li&gt;jobGraphs.add(recoverJob(jobId));&lt;br/&gt;
+		try 
{
+			return recoverJobGraphs(jobIds);
+		}
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
+			// release all recovered job graphs&lt;br/&gt;
+			for (JobID jobId : jobIds) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+				try {
+					submittedJobGraphStore.releaseJobGraph(jobId);
+				} catch (Exception ie) {
+					e.addSuppressed(ie);
 				}+			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+			throw e;&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return jobGraphs;&lt;/li&gt;
	&lt;li&gt;},&lt;/li&gt;
	&lt;li&gt;getRpcService().getExecutor());&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private Collection&amp;lt;JobGraph&amp;gt; recoverJobGraphs(Collection&amp;lt;JobID&amp;gt; jobIds) throws Exception {&lt;br/&gt;
+		final List&amp;lt;JobGraph&amp;gt; jobGraphs = new ArrayList&amp;lt;&amp;gt;(jobIds.size());&lt;br/&gt;
+&lt;br/&gt;
+		for (JobID jobId : jobIds) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			final JobGraph jobGraph = recoverJob(jobId);++			if (jobGraph == null) {
+				throw new FlinkJobNotFoundException(jobId);
+			}++			jobGraphs.add(jobGraph);+		}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+		return jobGraphs;&lt;br/&gt;
 	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	@Nullable&lt;br/&gt;
 	private JobGraph recoverJob(JobID jobId) throws Exception {&lt;br/&gt;
 		log.debug(&quot;Recover job {}.&quot;, jobId);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;SubmittedJobGraph submittedJobGraph = submittedJobGraphStore.recoverJobGraph(jobId);&lt;br/&gt;
+		final SubmittedJobGraph submittedJobGraph = submittedJobGraphStore.recoverJobGraph(jobId);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		if (submittedJobGraph != null) &lt;/p&gt;
{
 			return submittedJobGraph.getJobGraph();
 		}
&lt;p&gt; else &lt;/p&gt;
{
-			throw new FlinkJobNotFoundException(jobId);
+			return null;
 		}
&lt;p&gt; 	}&lt;/p&gt;

&lt;p&gt;@@ -768,27 +792,40 @@ private void jobMasterFailed(JobID jobId, Throwable cause) {&lt;br/&gt;
 	 */&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public void grantLeadership(final UUID newLeaderSessionID) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;log.info(&quot;Dispatcher {} was granted leadership with fencing token {}&quot;, getAddress(), newLeaderSessionID);&lt;br/&gt;
+		runAsyncWithoutFencing(&lt;br/&gt;
+			() -&amp;gt; {&lt;br/&gt;
+				log.info(&quot;Dispatcher {} was granted leadership with fencing token {}&quot;, getAddress(), newLeaderSessionID);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;Collection&amp;lt;JobGraph&amp;gt;&amp;gt; recoveredJobsFuture = recoverJobs();&lt;br/&gt;
+				final CompletableFuture&amp;lt;Collection&amp;lt;JobGraph&amp;gt;&amp;gt; recoveredJobsFuture = recoveryOperation.thenApplyAsync(&lt;br/&gt;
+					FunctionUtils.uncheckedFunction(ignored -&amp;gt; recoverJobs()),&lt;br/&gt;
+					getRpcService().getExecutor());&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;Boolean&amp;gt; fencingTokenFuture = recoveredJobsFuture.thenComposeAsync(&lt;/li&gt;
	&lt;li&gt;(Collection&amp;lt;JobGraph&amp;gt; recoveredJobs) -&amp;gt; tryAcceptLeadershipAndRunJobs(newLeaderSessionID, recoveredJobs),&lt;/li&gt;
	&lt;li&gt;getUnfencedMainThreadExecutor());&lt;br/&gt;
+				final CompletableFuture&amp;lt;Boolean&amp;gt; fencingTokenFuture = recoveredJobsFuture.thenComposeAsync(&lt;br/&gt;
+					(Collection&amp;lt;JobGraph&amp;gt; recoveredJobs) -&amp;gt; tryAcceptLeadershipAndRunJobs(newLeaderSessionID, recoveredJobs),&lt;br/&gt;
+					getUnfencedMainThreadExecutor());&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;Void&amp;gt; confirmationFuture = fencingTokenFuture.thenAcceptAsync(&lt;/li&gt;
	&lt;li&gt;(Boolean confirmLeadership) -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;if (confirmLeadership) 
{
-					leaderElectionService.confirmLeaderSessionID(newLeaderSessionID);
-				}&lt;/li&gt;
	&lt;li&gt;},&lt;/li&gt;
	&lt;li&gt;getRpcService().getExecutor());&lt;br/&gt;
+				final CompletableFuture&amp;lt;Void&amp;gt; confirmationFuture = fencingTokenFuture.thenCombineAsync(&lt;br/&gt;
+					recoveredJobsFuture,&lt;br/&gt;
+					BiFunctionWithException.unchecked((Boolean confirmLeadership, Collection&amp;lt;JobGraph&amp;gt; recoveredJobs) -&amp;gt; {&lt;br/&gt;
+						if (confirmLeadership) 
{
+							leaderElectionService.confirmLeaderSessionID(newLeaderSessionID);
+						}
&lt;p&gt; else &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+							for (JobGraph recoveredJob }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+						return null;&lt;br/&gt;
+					}),&lt;br/&gt;
+					getRpcService().getExecutor());&lt;br/&gt;
+&lt;br/&gt;
+				confirmationFuture.whenComplete(&lt;br/&gt;
+					(Void ignored, Throwable throwable) -&amp;gt; &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+						if (throwable != null) {
+							onFatalError(ExceptionUtils.stripCompletionException(throwable));
+						}+					}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;confirmationFuture.whenComplete(&lt;/li&gt;
	&lt;li&gt;(Void ignored, Throwable throwable) -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;if (throwable != null) 
{
-					onFatalError(ExceptionUtils.stripCompletionException(throwable));
-				}
&lt;p&gt;+				recoveryOperation = confirmationFuture;&lt;br/&gt;
 			});&lt;br/&gt;
 	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -813,7 +850,7 @@ public void grantLeadership(final UUID newLeaderSessionID) {&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private CompletableFuture&amp;lt;Void&amp;gt; waitForTerminatingJobManager(JobID jobId, JobGraph jobGraph, ConsumerWithException&amp;lt;JobGraph, ?&amp;gt; action) {&lt;br/&gt;
+	private CompletableFuture&amp;lt;Void&amp;gt; waitForTerminatingJobManager(JobID jobId, JobGraph jobGraph, ThrowingConsumer&amp;lt;JobGraph, ?&amp;gt; action) {&lt;br/&gt;
 		final CompletableFuture&amp;lt;Void&amp;gt; jobManagerTerminationFuture = getJobTerminationFuture(jobId)&lt;br/&gt;
 			.exceptionally((Throwable throwable) -&amp;gt; {&lt;br/&gt;
 				throw new CompletionException(&lt;br/&gt;
@@ -822,14 +859,14 @@ public void grantLeadership(final UUID newLeaderSessionID) 
{
 						throwable)); }
&lt;p&gt;);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		return jobManagerTerminationFuture.thenRunAsync(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;() -&amp;gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+			ThrowingRunnable.unchecked(() -&amp;gt; {
 				jobManagerTerminationFutures.remove(jobId);
 				action.accept(jobGraph);
-			},+			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;),&lt;br/&gt;
 			getMainThreadExecutor());&lt;br/&gt;
 	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;br/&gt;
+	CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(JobID jobId) {&lt;br/&gt;
 		if (jobManagerRunners.containsKey(jobId)) 
{
 			return FutureUtils.completedExceptionally(new DispatcherException(String.format(&quot;Job with job id %s is still running.&quot;, jobId)));
 		}
&lt;p&gt; else {&lt;br/&gt;
@@ -837,6 +874,11 @@ public void grantLeadership(final UUID newLeaderSessionID) {&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	@VisibleForTesting&lt;br/&gt;
+	CompletableFuture&amp;lt;Void&amp;gt; getRecoveryOperation() &lt;/p&gt;
{
+		return recoveryOperation;
+	}
&lt;p&gt;+&lt;br/&gt;
 	private void setNewFencingToken(@Nullable DispatcherId dispatcherId) {&lt;br/&gt;
 		// clear the state if we&apos;ve been the leader before&lt;br/&gt;
 		if (getFencingToken() != null) {&lt;br/&gt;
@@ -879,24 +921,63 @@ public void handleError(final Exception exception) {&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	public void onAddedJobGraph(final JobID jobId) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;SubmittedJobGraph&amp;gt; recoveredJob = getRpcService().execute(&lt;/li&gt;
	&lt;li&gt;() -&amp;gt; submittedJobGraphStore.recoverJobGraph(jobId));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final CompletableFuture&amp;lt;Acknowledge&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;/li&gt;
	&lt;li&gt;(SubmittedJobGraph submittedJobGraph) -&amp;gt; submitJob(submittedJobGraph.getJobGraph(), RpcUtils.INF_TIMEOUT),&lt;/li&gt;
	&lt;li&gt;getMainThreadExecutor());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;submissionFuture.whenComplete(&lt;/li&gt;
	&lt;li&gt;(Acknowledge acknowledge, Throwable throwable) -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;if (throwable != null) {&lt;/li&gt;
	&lt;li&gt;onFatalError(&lt;/li&gt;
	&lt;li&gt;new DispatcherException(&lt;/li&gt;
	&lt;li&gt;String.format(&quot;Could not start the added job %s&quot;, jobId),&lt;/li&gt;
	&lt;li&gt;ExceptionUtils.stripCompletionException(throwable)));&lt;br/&gt;
+		runAsync(&lt;br/&gt;
+			() -&amp;gt; {&lt;br/&gt;
+				if (!jobManagerRunners.containsKey(jobId)) {&lt;br/&gt;
+					// IMPORTANT: onAddedJobGraph can generate false positives and, thus, we must expect that&lt;br/&gt;
+					// the specified job is already removed from the SubmittedJobGraphStore. In this case,&lt;br/&gt;
+					// SubmittedJobGraphStore.recoverJob returns null.&lt;br/&gt;
+					final CompletableFuture&amp;lt;Optional&amp;lt;JobGraph&amp;gt;&amp;gt; recoveredJob = recoveryOperation.thenApplyAsync(&lt;br/&gt;
+						FunctionUtils.uncheckedFunction(ignored -&amp;gt; Optional.ofNullable(recoverJob(jobId))),&lt;br/&gt;
+						getRpcService().getExecutor());&lt;br/&gt;
+&lt;br/&gt;
+					final DispatcherId dispatcherId = getFencingToken();&lt;br/&gt;
+					final CompletableFuture&amp;lt;Void&amp;gt; submissionFuture = recoveredJob.thenComposeAsync(&lt;br/&gt;
+						(Optional&amp;lt;JobGraph&amp;gt; jobGraphOptional) -&amp;gt; jobGraphOptional.map(&lt;br/&gt;
+							FunctionUtils.uncheckedFunction(jobGraph -&amp;gt; tryRunRecoveredJobGraph(jobGraph, dispatcherId).thenAcceptAsync(&lt;br/&gt;
+								FunctionUtils.uncheckedConsumer((Boolean isRecoveredJobRunning) -&amp;gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+										if (!isRecoveredJobRunning) {
+											submittedJobGraphStore.releaseJobGraph(jobId);
+										}+									}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;),&lt;br/&gt;
+									getRpcService().getExecutor())))&lt;br/&gt;
+							.orElse(CompletableFuture.completedFuture(null)),&lt;br/&gt;
+						getUnfencedMainThreadExecutor());&lt;br/&gt;
+&lt;br/&gt;
+					submissionFuture.whenComplete(&lt;br/&gt;
+						(Void ignored, Throwable throwable) -&amp;gt; &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+							if (throwable != null) {
+								onFatalError(
+									new DispatcherException(
+										String.format(&quot;Could not start the added job %s&quot;, jobId),
+										ExceptionUtils.stripCompletionException(throwable)));
+							}+						}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;);&lt;br/&gt;
+&lt;br/&gt;
+					recoveryOperation = submissionFuture;&lt;br/&gt;
 				}&lt;br/&gt;
 			});&lt;br/&gt;
 	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	private CompletableFuture&amp;lt;Boolean&amp;gt; tryRunRecoveredJobGraph(JobGraph jobGraph, DispatcherId dispatcherId) throws Exception {&lt;br/&gt;
+		if (leaderElectionService.hasLeadership(dispatcherId.toUUID())) {&lt;br/&gt;
+			final JobID jobId = jobGraph.getJobID();&lt;br/&gt;
+			if (jobManagerRunners.containsKey(jobId)) {&lt;br/&gt;
+				// we must not release the job graph lock since it can only be locked once and&lt;br/&gt;
+				// is currently being executed. Once we support multiple locks, we must release&lt;br/&gt;
+				// the JobGraph here&lt;br/&gt;
+				log.debug(&quot;Ignore added JobGraph because the job {} is already running.&quot;, jobId);&lt;br/&gt;
+				return CompletableFuture.completedFuture(true);&lt;br/&gt;
+			} else if (runningJobsRegistry.getJobSchedulingStatus(jobId) != RunningJobsRegistry.JobSchedulingStatus.DONE) &lt;/p&gt;
{
+				return waitForTerminatingJobManager(jobId, jobGraph, this::runJob).thenApply(ignored -&amp;gt; true);
+			}
&lt;p&gt; else {&lt;br/&gt;
+				log.debug(&quot;Ignore added JobGraph because the job {} has already been completed.&quot;, jobId);&lt;br/&gt;
+			}&lt;br/&gt;
+		}&lt;br/&gt;
+&lt;br/&gt;
+		return CompletableFuture.completedFuture(false);&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public void onRemovedJobGraph(final JobID jobId) {&lt;br/&gt;
 		runAsync(() -&amp;gt; &lt;/p&gt;
{
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java
index ddd3751cc2a..0fd4389fc35 100755
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java
@@ -708,6 +708,12 @@ protected static Configuration loadConfiguration(EntrypointClusterConfiguration
 			configuration.setInteger(RestOptions.PORT, restPort);
 		}

&lt;p&gt;+		final String hostname = entrypointClusterConfiguration.getHostname();&lt;br/&gt;
+&lt;br/&gt;
+		if (hostname != null) &lt;/p&gt;
{
+			configuration.setString(JobManagerOptions.ADDRESS, hostname);
+		}
&lt;p&gt;+&lt;br/&gt;
 		return configuration;&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/EntrypointClusterConfiguration.java b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/EntrypointClusterConfiguration.java&lt;br/&gt;
index 75cad7aa946..3472f35d6a2 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/EntrypointClusterConfiguration.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/EntrypointClusterConfiguration.java&lt;br/&gt;
@@ -19,6 +19,7 @@&lt;br/&gt;
 package org.apache.flink.runtime.entrypoint;&lt;/p&gt;

&lt;p&gt; import javax.annotation.Nonnull;&lt;br/&gt;
+import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.util.Properties;&lt;/p&gt;

&lt;p&gt;@@ -27,14 +28,23 @@&lt;br/&gt;
  */&lt;br/&gt;
 public class EntrypointClusterConfiguration extends ClusterConfiguration {&lt;/p&gt;

&lt;p&gt;+	@Nullable&lt;br/&gt;
+	private final String hostname;&lt;br/&gt;
+&lt;br/&gt;
 	private final int restPort;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public EntrypointClusterConfiguration(@Nonnull String configDir, @Nonnull Properties dynamicProperties, @Nonnull String[] args, int restPort) {&lt;br/&gt;
+	public EntrypointClusterConfiguration(@Nonnull String configDir, @Nonnull Properties dynamicProperties, @Nonnull String[] args, @Nullable String hostname, int restPort) 
{
 		super(configDir, dynamicProperties, args);
+		this.hostname = hostname;
 		this.restPort = restPort;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	public int getRestPort() &lt;/p&gt;
{
 		return restPort;
 	}
&lt;p&gt;+&lt;br/&gt;
+	@Nullable&lt;br/&gt;
+	public String getHostname() &lt;/p&gt;
{
+		return hostname;
+	}
&lt;p&gt; }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/EntrypointClusterConfigurationParserFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/EntrypointClusterConfigurationParserFactory.java&lt;br/&gt;
index 7dfb784a79c..52f59eeef8b 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/EntrypointClusterConfigurationParserFactory.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/EntrypointClusterConfigurationParserFactory.java&lt;br/&gt;
@@ -29,6 +29,8 @@&lt;/p&gt;

&lt;p&gt; import static org.apache.flink.runtime.entrypoint.parser.CommandLineOptions.CONFIG_DIR_OPTION;&lt;br/&gt;
 import static org.apache.flink.runtime.entrypoint.parser.CommandLineOptions.DYNAMIC_PROPERTY_OPTION;&lt;br/&gt;
+import static org.apache.flink.runtime.entrypoint.parser.CommandLineOptions.EXECUTION_MODE_OPTION;&lt;br/&gt;
+import static org.apache.flink.runtime.entrypoint.parser.CommandLineOptions.HOST_OPTION;&lt;br/&gt;
 import static org.apache.flink.runtime.entrypoint.parser.CommandLineOptions.REST_PORT_OPTION;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -42,6 +44,8 @@ public Options getOptions() &lt;/p&gt;
{
 		options.addOption(CONFIG_DIR_OPTION);
 		options.addOption(REST_PORT_OPTION);
 		options.addOption(DYNAMIC_PROPERTY_OPTION);
+		options.addOption(HOST_OPTION);
+		options.addOption(EXECUTION_MODE_OPTION);
 
 		return options;
 	}
&lt;p&gt;@@ -52,11 +56,13 @@ public EntrypointClusterConfiguration createResult(@Nonnull CommandLine commandL&lt;br/&gt;
 		final Properties dynamicProperties = commandLine.getOptionProperties(DYNAMIC_PROPERTY_OPTION.getOpt());&lt;br/&gt;
 		final String restPortStr = commandLine.getOptionValue(REST_PORT_OPTION.getOpt(), &quot;-1&quot;);&lt;br/&gt;
 		final int restPort = Integer.parseInt(restPortStr);&lt;br/&gt;
+		final String hostname = commandLine.getOptionValue(HOST_OPTION.getOpt());&lt;/p&gt;

&lt;p&gt; 		return new EntrypointClusterConfiguration(&lt;br/&gt;
 			configDir,&lt;br/&gt;
 			dynamicProperties,&lt;br/&gt;
 			commandLine.getArgs(),&lt;br/&gt;
+			hostname,&lt;br/&gt;
 			restPort);&lt;br/&gt;
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/parser/CommandLineOptions.java b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/parser/CommandLineOptions.java&lt;br/&gt;
index 23c9da2485f..443014b9903 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/parser/CommandLineOptions.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/parser/CommandLineOptions.java&lt;br/&gt;
@@ -48,5 +48,26 @@&lt;br/&gt;
 		.desc(&quot;use value for given property&quot;)&lt;br/&gt;
 		.build();&lt;/p&gt;

&lt;p&gt;+	public static final Option HOST_OPTION = Option.builder(&quot;h&quot;)&lt;br/&gt;
+		.longOpt(&quot;host&quot;)&lt;br/&gt;
+		.required(false)&lt;br/&gt;
+		.hasArg(true)&lt;br/&gt;
+		.argName(&quot;hostname&quot;)&lt;br/&gt;
+		.desc(&quot;Hostname for the RPC service.&quot;)&lt;br/&gt;
+		.build();&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * @deprecated exists only for compatibility with legacy mode. Remove once legacy mode&lt;br/&gt;
+	 * and execution mode option has been removed.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Deprecated&lt;br/&gt;
+	public static final Option EXECUTION_MODE_OPTION = Option.builder(&quot;x&quot;)&lt;br/&gt;
+		.longOpt(&quot;executionMode&quot;)&lt;br/&gt;
+		.required(false)&lt;br/&gt;
+		.hasArg(true)&lt;br/&gt;
+		.argName(&quot;execution mode&quot;)&lt;br/&gt;
+		.desc(&quot;Deprecated option&quot;)&lt;br/&gt;
+		.build();&lt;br/&gt;
+&lt;br/&gt;
 	private CommandLineOptions() {}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java&lt;br/&gt;
index 4a66d32a2ac..736984e88e7 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java&lt;br/&gt;
@@ -1483,7 +1483,7 @@ private void rescaleJobGraph(Collection&amp;lt;JobVertexID&amp;gt; operators, int newParalleli&lt;br/&gt;
 				jobVertex.setMaxParallelism(executionJobVertex.getMaxParallelism());&lt;br/&gt;
 			}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;rescalingBehaviour.acceptWithException(jobVertex, newParallelism);&lt;br/&gt;
+			rescalingBehaviour.accept(jobVertex, newParallelism);&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/RescalingBehaviour.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/RescalingBehaviour.java&lt;br/&gt;
index 7de956081d8..64e2ffa1124 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/RescalingBehaviour.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/RescalingBehaviour.java&lt;br/&gt;
@@ -29,7 +29,7 @@&lt;br/&gt;
 	// rescaling is only executed if the operator can be set to the given parallelism&lt;br/&gt;
 	STRICT {&lt;br/&gt;
 		@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void acceptWithException(JobVertex jobVertex, Integer newParallelism) throws FlinkException {&lt;br/&gt;
+		public void accept(JobVertex jobVertex, Integer newParallelism) throws FlinkException {&lt;br/&gt;
 			if (jobVertex.getMaxParallelism() &amp;lt; newParallelism) {&lt;br/&gt;
 				throw new FlinkException(&quot;Cannot rescale vertex &quot; + jobVertex.getName() +&lt;br/&gt;
 					&quot; because its maximum parallelism &quot; + jobVertex.getMaxParallelism() +&lt;br/&gt;
@@ -42,7 +42,7 @@ public void acceptWithException(JobVertex jobVertex, Integer newParallelism) thr&lt;br/&gt;
 	// the new parallelism will be the minimum of the given parallelism and the maximum parallelism&lt;br/&gt;
 	RELAXED {&lt;br/&gt;
 		@Override&lt;/li&gt;
	&lt;li&gt;public void acceptWithException(JobVertex jobVertex, Integer newParallelism) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		public void accept(JobVertex jobVertex, Integer newParallelism) {
 			jobVertex.setParallelism(Math.min(jobVertex.getMaxParallelism(), newParallelism));
 		} 	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestServerEndpoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestServerEndpoint.java&lt;br/&gt;
index 28af072a10c..38da82cb7fb 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestServerEndpoint.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/RestServerEndpoint.java&lt;br/&gt;
@@ -178,6 +178,7 @@ protected void initChannel(SocketChannel ch) {&lt;br/&gt;
 				.channel(NioServerSocketChannel.class)&lt;br/&gt;
 				.childHandler(initializer);&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+			log.debug(&quot;Binding rest endpoint to {}:{}.&quot;, restBindAddress, restBindPort);&lt;br/&gt;
 			final ChannelFuture channel;&lt;br/&gt;
 			if (restBindAddress == null) &lt;/p&gt;
{
 				channel = bootstrap.bind(restBindPort);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/util/LeaderRetrievalUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/util/LeaderRetrievalUtils.java
index 4d783352459..9c8f7bd1428 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/util/LeaderRetrievalUtils.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/util/LeaderRetrievalUtils.java
@@ -23,6 +23,7 @@
 import org.apache.flink.configuration.HighAvailabilityOptions;
 import org.apache.flink.configuration.IllegalConfigurationException;
 import org.apache.flink.runtime.akka.AkkaUtils;
+import org.apache.flink.runtime.concurrent.FutureUtils;
 import org.apache.flink.runtime.instance.ActorGateway;
 import org.apache.flink.runtime.instance.AkkaActorGateway;
 import org.apache.flink.runtime.jobmanager.HighAvailabilityMode;
@@ -89,6 +90,23 @@ public static ActorGateway retrieveLeaderGateway(
 		}
&lt;p&gt; 	}&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * Retrieves the leader akka url and the current leader session ID. The values are stored in a&lt;br/&gt;
+	 * &lt;/p&gt;
{@link LeaderConnectionInfo} instance.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param leaderRetrievalService Leader retrieval service to retrieve the leader connection&lt;br/&gt;
+	 *                               information&lt;br/&gt;
+	 * @param timeout Timeout when to give up looking for the leader&lt;br/&gt;
+	 * @return LeaderConnectionInfo containing the leader&apos;s akka URL and the current leader session&lt;br/&gt;
+	 * ID&lt;br/&gt;
+	 * @throws LeaderRetrievalException&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static LeaderConnectionInfo retrieveLeaderConnectionInfo(&lt;br/&gt;
+			LeaderRetrievalService leaderRetrievalService,&lt;br/&gt;
+			Time timeout) throws LeaderRetrievalException {
+		return retrieveLeaderConnectionInfo(leaderRetrievalService, FutureUtils.toFiniteDuration(timeout));
+	}&lt;br/&gt;
+&lt;br/&gt;
 	/**&lt;br/&gt;
 	 * Retrieves the leader akka url and the current leader session ID. The values are stored in a&lt;br/&gt;
 	 * {@link LeaderConnectionInfo}
&lt;p&gt; instance.&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
index 8c3d31fc51b..b9cd0c1b720 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java&lt;br/&gt;
@@ -526,22 +526,13 @@ protected String getLockPath(String rootPath) &lt;/p&gt;
{
 				client.create().withMode(CreateMode.EPHEMERAL).forPath(getLockPath(path));
 			}
&lt;p&gt; catch (KeeperException.NodeExistsException ignored) &lt;/p&gt;
{
 				// we have already created the lock
-			}
&lt;p&gt; catch (KeeperException.NoNodeException e) &lt;/p&gt;
{
-				throw new Exception(&quot;Cannot lock the node &quot; + path + &quot; since it does not exist.&quot;, e);
 			}
&lt;p&gt; 		}&lt;/p&gt;

&lt;p&gt; 		boolean success = false;&lt;/p&gt;

&lt;p&gt; 		try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;byte[] data;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;try 
{
-				data = client.getData().forPath(path);
-			}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
-				throw new Exception(&quot;Failed to retrieve state handle data under &quot; + path +
-					&quot; from ZooKeeper.&quot;, e);
-			}
&lt;p&gt;+			byte[] data = client.getData().forPath(path);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			try {&lt;br/&gt;
 				RetrievableStateHandle&amp;lt;T&amp;gt; retrievableStateHandle = InstantiationUtil.deserializeObject(&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java&lt;br/&gt;
index cb26f4862b1..335199a2807 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherHATest.java&lt;br/&gt;
@@ -302,9 +302,7 @@ public void removeJobGraph(JobID jobId) throws Exception {&lt;br/&gt;
 		}&lt;/p&gt;

&lt;p&gt; 		@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void releaseJobGraph(JobID jobId) throws Exception 
{
-			throw new UnsupportedOperationException(&quot;Should not be called.&quot;);
-		}
&lt;p&gt;+		public void releaseJobGraph(JobID jobId) throws Exception {}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		@Override&lt;br/&gt;
 		public Collection&amp;lt;JobID&amp;gt; getJobIds() throws Exception {&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java&lt;br/&gt;
index d405fcdcf44..1af10b8c598 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java&lt;br/&gt;
@@ -319,13 +319,13 @@ public void testOnAddedJobGraphWithFinishedJob() throws Throwable &lt;/p&gt;
{
 		runningJobsRegistry.setJobFinished(TEST_JOB_ID);
 		dispatcher.onAddedJobGraph(TEST_JOB_ID);
 
-		final CompletableFuture&amp;lt;Throwable&amp;gt; errorFuture = fatalErrorHandler.getErrorFuture();
-
-		final Throwable throwable = errorFuture.get();
+		// wait until the recovery is over
+		dispatcher.getRecoverOperationFuture(TIMEOUT).get();
 
-		assertThat(throwable, instanceOf(DispatcherException.class));
+		final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 
-		fatalErrorHandler.clearError();
+		// check that we did not start executing the added JobGraph
+		assertThat(dispatcherGateway.listJobs(TIMEOUT).get(), is(empty()));
 	}

&lt;p&gt; 	/**&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
index 5141be039f7..6a623768bb2 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java&lt;br/&gt;
@@ -18,7 +18,6 @@&lt;/p&gt;

&lt;p&gt; package org.apache.flink.runtime.dispatcher;&lt;/p&gt;

&lt;p&gt;-import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
 import org.apache.flink.api.common.JobID;&lt;br/&gt;
 import org.apache.flink.api.common.time.Time;&lt;br/&gt;
 import org.apache.flink.configuration.Configuration;&lt;br/&gt;
@@ -73,16 +72,20 @@&lt;br/&gt;
 			VoidHistoryServerArchivist.INSTANCE);&lt;br/&gt;
 	}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@VisibleForTesting&lt;br/&gt;
 	void completeJobExecution(ArchivedExecutionGraph archivedExecutionGraph) 
{
 		runAsync(
 			() -&amp;gt; jobReachedGloballyTerminalState(archivedExecutionGraph));
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@VisibleForTesting&lt;/li&gt;
	&lt;li&gt;public CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(@Nonnull JobID jobId, @Nonnull Time timeout) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+	CompletableFuture&amp;lt;Void&amp;gt; getJobTerminationFuture(@Nonnull JobID jobId, @Nonnull Time timeout) {
 		return callAsyncWithoutFencing(
 			() -&amp;gt; getJobTerminationFuture(jobId),
 			timeout).thenCompose(Function.identity());
 	}++	CompletableFuture&amp;lt;Void&amp;gt; getRecoverOperationFuture(@Nonnull Time timeout) {
+		return callAsyncWithoutFencing(
+			this::getRecoveryOperation,
+			timeout).thenCompose(Function.identity());
+	} }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java&lt;br/&gt;
index dd0375886a9..b5662c064e8 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/ZooKeeperHADispatcherTest.java&lt;br/&gt;
@@ -24,17 +24,25 @@&lt;br/&gt;
 import org.apache.flink.configuration.HighAvailabilityOptions;&lt;br/&gt;
 import org.apache.flink.runtime.blob.BlobServer;&lt;br/&gt;
 import org.apache.flink.runtime.blob.VoidBlobStore;&lt;br/&gt;
+import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;&lt;br/&gt;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.HighAvailabilityServices;&lt;br/&gt;
 import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;&lt;br/&gt;
+import org.apache.flink.runtime.highavailability.zookeeper.ZooKeeperHaServices;&lt;br/&gt;
 import org.apache.flink.runtime.jobgraph.JobGraph;&lt;br/&gt;
+import org.apache.flink.runtime.jobgraph.JobStatus;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.SubmittedJobGraph;&lt;br/&gt;
 import org.apache.flink.runtime.jobmanager.ZooKeeperSubmittedJobGraphStore;&lt;br/&gt;
+import org.apache.flink.runtime.jobmaster.JobResult;&lt;br/&gt;
 import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;&lt;br/&gt;
 import org.apache.flink.runtime.messages.Acknowledge;&lt;br/&gt;
 import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;&lt;br/&gt;
 import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;&lt;br/&gt;
+import org.apache.flink.runtime.rest.handler.legacy.utils.ArchivedExecutionGraphBuilder;&lt;br/&gt;
 import org.apache.flink.runtime.rpc.RpcUtils;&lt;br/&gt;
 import org.apache.flink.runtime.rpc.TestingRpcService;&lt;br/&gt;
+import org.apache.flink.runtime.util.LeaderConnectionInfo;&lt;br/&gt;
+import org.apache.flink.runtime.util.LeaderRetrievalUtils;&lt;br/&gt;
 import org.apache.flink.runtime.util.TestingFatalErrorHandler;&lt;br/&gt;
 import org.apache.flink.runtime.util.ZooKeeperUtils;&lt;br/&gt;
 import org.apache.flink.runtime.zookeeper.ZooKeeperResource;&lt;br/&gt;
@@ -56,8 +64,13 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import java.io.IOException;&lt;br/&gt;
 import java.util.Collection;&lt;br/&gt;
+import java.util.UUID;&lt;br/&gt;
 import java.util.concurrent.CompletableFuture;&lt;/p&gt;

&lt;p&gt;+import static org.hamcrest.Matchers.empty;&lt;br/&gt;
+import static org.hamcrest.Matchers.equalTo;&lt;br/&gt;
+import static org.hamcrest.Matchers.is;&lt;br/&gt;
+import static org.hamcrest.Matchers.notNullValue;&lt;br/&gt;
 import static org.junit.Assert.assertThat;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -67,8 +80,8 @@&lt;/p&gt;

&lt;p&gt; 	private static final Time TIMEOUT = Time.seconds(10L);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@ClassRule&lt;/li&gt;
	&lt;li&gt;public static final ZooKeeperResource ZOO_KEEPER_RESOURCE = new ZooKeeperResource();&lt;br/&gt;
+	@Rule&lt;br/&gt;
+	public final ZooKeeperResource zooKeeperResource = new ZooKeeperResource();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	@ClassRule&lt;br/&gt;
 	public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();&lt;br/&gt;
@@ -87,14 +100,14 @@&lt;br/&gt;
 	@BeforeClass&lt;br/&gt;
 	public static void setupClass() throws IOException &lt;/p&gt;
{
 		configuration = new Configuration();
-		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, ZOO_KEEPER_RESOURCE.getConnectString());
 		configuration.setString(HighAvailabilityOptions.HA_STORAGE_PATH, TEMPORARY_FOLDER.newFolder().getAbsolutePath());
 		rpcService = new TestingRpcService();
 		blobServer = new BlobServer(configuration, new VoidBlobStore());
 	}

&lt;p&gt; 	@Before&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void setup() {&lt;br/&gt;
+	public void setup() throws Exception 
{
+		configuration.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString());
 		testingFatalErrorHandler = new TestingFatalErrorHandler();
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -139,7 +152,9 @@ public void testSubmittedJobGraphRelease() throws Exception {&lt;br/&gt;
 			final TestingLeaderElectionService leaderElectionService = new TestingLeaderElectionService();&lt;br/&gt;
 			testingHighAvailabilityServices.setDispatcherLeaderElectionService(leaderElectionService);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final TestingDispatcher dispatcher = createDispatcher(testingHighAvailabilityServices);&lt;br/&gt;
+			final TestingDispatcher dispatcher = createDispatcher(&lt;br/&gt;
+				testingHighAvailabilityServices,&lt;br/&gt;
+				new TestingJobManagerRunnerFactory(new CompletableFuture&amp;lt;&amp;gt;(), new CompletableFuture&amp;lt;&amp;gt;()));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			dispatcher.start();&lt;/p&gt;

&lt;p&gt;@@ -167,7 +182,7 @@ public void testSubmittedJobGraphRelease() throws Exception {&lt;br/&gt;
 				// recover the job&lt;br/&gt;
 				final SubmittedJobGraph submittedJobGraph = otherSubmittedJobGraphStore.recoverJobGraph(jobId);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertThat(submittedJobGraph, Matchers.is(Matchers.notNullValue()));&lt;br/&gt;
+				assertThat(submittedJobGraph, is(notNullValue()));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 				// check that the other submitted job graph store can remove the job graph after the original leader&lt;br/&gt;
 				// has lost its leadership&lt;br/&gt;
@@ -184,20 +199,145 @@ public void testSubmittedJobGraphRelease() throws Exception {&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt;+	/**&lt;br/&gt;
+	 * Tests that a standby Dispatcher does not interfere with the clean up of a completed&lt;br/&gt;
+	 * job.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testStandbyDispatcherJobExecution() throws Exception {&lt;br/&gt;
+		try (final TestingHighAvailabilityServices haServices1 = new TestingHighAvailabilityServices();&lt;br/&gt;
+			final TestingHighAvailabilityServices haServices2 = new TestingHighAvailabilityServices();&lt;br/&gt;
+			final CuratorFramework curatorFramework = ZooKeeperUtils.startCuratorFramework(configuration)) {&lt;br/&gt;
+&lt;br/&gt;
+			final ZooKeeperSubmittedJobGraphStore submittedJobGraphStore1 = ZooKeeperUtils.createSubmittedJobGraphs(curatorFramework, configuration);&lt;br/&gt;
+			haServices1.setSubmittedJobGraphStore(submittedJobGraphStore1);&lt;br/&gt;
+			final TestingLeaderElectionService leaderElectionService1 = new TestingLeaderElectionService();&lt;br/&gt;
+			haServices1.setDispatcherLeaderElectionService(leaderElectionService1);&lt;br/&gt;
+&lt;br/&gt;
+			final ZooKeeperSubmittedJobGraphStore submittedJobGraphStore2 = ZooKeeperUtils.createSubmittedJobGraphs(curatorFramework, configuration);&lt;br/&gt;
+			haServices2.setSubmittedJobGraphStore(submittedJobGraphStore2);&lt;br/&gt;
+			final TestingLeaderElectionService leaderElectionService2 = new TestingLeaderElectionService();&lt;br/&gt;
+			haServices2.setDispatcherLeaderElectionService(leaderElectionService2);&lt;br/&gt;
+&lt;br/&gt;
+			final CompletableFuture&amp;lt;JobGraph&amp;gt; jobGraphFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
+			final CompletableFuture&amp;lt;ArchivedExecutionGraph&amp;gt; resultFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
+			final TestingDispatcher dispatcher1 = createDispatcher(&lt;br/&gt;
+				haServices1,&lt;br/&gt;
+				new TestingJobManagerRunnerFactory(jobGraphFuture, resultFuture));&lt;br/&gt;
+&lt;br/&gt;
+			final TestingDispatcher dispatcher2 = createDispatcher(&lt;br/&gt;
+				haServices2,&lt;br/&gt;
+				new TestingJobManagerRunnerFactory(new CompletableFuture&amp;lt;&amp;gt;(), new CompletableFuture&amp;lt;&amp;gt;()));&lt;br/&gt;
+&lt;br/&gt;
+			try &lt;/p&gt;
{
+				dispatcher1.start();
+				dispatcher2.start();
+
+				leaderElectionService1.isLeader(UUID.randomUUID()).get();
+				final DispatcherGateway dispatcherGateway1 = dispatcher1.getSelfGateway(DispatcherGateway.class);
+
+				final JobGraph jobGraph = DispatcherHATest.createNonEmptyJobGraph();
+
+				dispatcherGateway1.submitJob(jobGraph, TIMEOUT).get();
+
+				final CompletableFuture&amp;lt;JobResult&amp;gt; jobResultFuture = dispatcherGateway1.requestJobResult(jobGraph.getJobID(), TIMEOUT);
+
+				jobGraphFuture.get();
+
+				// complete the job
+				resultFuture.complete(new ArchivedExecutionGraphBuilder().setJobID(jobGraph.getJobID()).setState(JobStatus.FINISHED).build());
+
+				final JobResult jobResult = jobResultFuture.get();
+
+				assertThat(jobResult.isSuccess(), is(true));
+
+				// wait for the completion of the job
+				dispatcher1.getJobTerminationFuture(jobGraph.getJobID(), TIMEOUT).get();
+
+				// change leadership
+				leaderElectionService1.notLeader();
+				leaderElectionService2.isLeader(UUID.randomUUID()).get();
+
+				// Dispatcher 2 should not recover any jobs
+				final DispatcherGateway dispatcherGateway2 = dispatcher2.getSelfGateway(DispatcherGateway.class);
+				assertThat(dispatcherGateway2.listJobs(TIMEOUT).get(), is(empty()));
+			}
&lt;p&gt; finally &lt;/p&gt;
{
+				RpcUtils.terminateRpcEndpoint(dispatcher1, TIMEOUT);
+				RpcUtils.terminateRpcEndpoint(dispatcher2, TIMEOUT);
+			}
&lt;p&gt;+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Tests that a standby &lt;/p&gt;
{@link Dispatcher}
&lt;p&gt; can recover all submitted jobs.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testStandbyDispatcherJobRecovery() throws Exception {&lt;br/&gt;
+		try (CuratorFramework curatorFramework = ZooKeeperUtils.startCuratorFramework(configuration)) {&lt;br/&gt;
+&lt;br/&gt;
+			HighAvailabilityServices haServices = null;&lt;br/&gt;
+			Dispatcher dispatcher1 = null;&lt;br/&gt;
+			Dispatcher dispatcher2 = null;&lt;br/&gt;
+&lt;br/&gt;
+			try {&lt;br/&gt;
+				haServices = new ZooKeeperHaServices(curatorFramework, rpcService.getExecutor(), configuration, new VoidBlobStore());&lt;br/&gt;
+&lt;br/&gt;
+				final CompletableFuture&amp;lt;JobGraph&amp;gt; jobGraphFuture1 = new CompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
+				dispatcher1 = createDispatcher(&lt;br/&gt;
+					haServices,&lt;br/&gt;
+					new TestingJobManagerRunnerFactory(jobGraphFuture1, new CompletableFuture&amp;lt;&amp;gt;()));&lt;br/&gt;
+				final CompletableFuture&amp;lt;JobGraph&amp;gt; jobGraphFuture2 = new CompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;
+				dispatcher2 = createDispatcher(&lt;br/&gt;
+					haServices,&lt;br/&gt;
+					new TestingJobManagerRunnerFactory(jobGraphFuture2, new CompletableFuture&amp;lt;&amp;gt;()));&lt;br/&gt;
+&lt;br/&gt;
+				dispatcher1.start();&lt;br/&gt;
+				dispatcher2.start();&lt;br/&gt;
+&lt;br/&gt;
+				final LeaderConnectionInfo leaderConnectionInfo = LeaderRetrievalUtils.retrieveLeaderConnectionInfo(haServices.getDispatcherLeaderRetriever(), TIMEOUT);&lt;br/&gt;
+&lt;br/&gt;
+				final DispatcherGateway dispatcherGateway = rpcService.connect(leaderConnectionInfo.getAddress(), DispatcherId.fromUuid(leaderConnectionInfo.getLeaderSessionID()), DispatcherGateway.class).get();&lt;br/&gt;
+&lt;br/&gt;
+				final JobGraph nonEmptyJobGraph = DispatcherHATest.createNonEmptyJobGraph();&lt;br/&gt;
+				dispatcherGateway.submitJob(nonEmptyJobGraph, TIMEOUT).get();&lt;br/&gt;
+&lt;br/&gt;
+				if (dispatcher1.getAddress().equals(leaderConnectionInfo.getAddress())) &lt;/p&gt;
{
+					dispatcher1.shutDown();
+					assertThat(jobGraphFuture2.get().getJobID(), is(equalTo(nonEmptyJobGraph.getJobID())));
+				}
&lt;p&gt; else &lt;/p&gt;
{
+					dispatcher2.shutDown();
+					assertThat(jobGraphFuture1.get().getJobID(), is(equalTo(nonEmptyJobGraph.getJobID())));
+				}
&lt;p&gt;+			} finally {&lt;br/&gt;
+				if (dispatcher1 != null) &lt;/p&gt;
{
+					RpcUtils.terminateRpcEndpoint(dispatcher1, TIMEOUT);
+				}
&lt;p&gt;+&lt;br/&gt;
+				if (dispatcher2 != null) &lt;/p&gt;
{
+					RpcUtils.terminateRpcEndpoint(dispatcher2, TIMEOUT);
+				}
&lt;p&gt;+&lt;br/&gt;
+				if (haServices != null) &lt;/p&gt;
{
+					haServices.close();
+				}
&lt;p&gt;+			}&lt;br/&gt;
+		}&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
 	@Nonnull&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private TestingDispatcher createDispatcher(TestingHighAvailabilityServices testingHighAvailabilityServices) throws Exception 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+	private TestingDispatcher createDispatcher(HighAvailabilityServices highAvailabilityServices, Dispatcher.JobManagerRunnerFactory jobManagerRunnerFactory) throws Exception {
 		return new TestingDispatcher(
 			rpcService,
-			Dispatcher.DISPATCHER_NAME + &apos;_&apos; + name.getMethodName(),
+			Dispatcher.DISPATCHER_NAME + &apos;_&apos; + name.getMethodName() + UUID.randomUUID(),
 			configuration,
-			testingHighAvailabilityServices,
+			highAvailabilityServices,
 			new TestingResourceManagerGateway(),
 			blobServer,
 			new HeartbeatServices(1000L, 1000L),
 			UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(),
 			null,
 			new MemoryArchivedExecutionGraphStore(),
-			new TestingJobManagerRunnerFactory(new CompletableFuture&amp;lt;&amp;gt;(), new CompletableFuture&amp;lt;&amp;gt;()),
+			jobManagerRunnerFactory,
 			testingFatalErrorHandler);
 	} }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/entrypoint/EntrypointClusterConfigurationParserFactoryTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/entrypoint/EntrypointClusterConfigurationParserFactoryTest.java&lt;br/&gt;
index da63b7fe046..906e9d5a663 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/test/java/org/apache/flink/runtime/entrypoint/EntrypointClusterConfigurationParserFactoryTest.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/entrypoint/EntrypointClusterConfigurationParserFactoryTest.java&lt;br/&gt;
@@ -46,7 +46,7 @@ public void testEntrypointClusterConfigurationParsing() throws FlinkParseExcepti&lt;br/&gt;
 		final String value = &quot;value&quot;;&lt;br/&gt;
 		final String arg1 = &quot;arg1&quot;;&lt;br/&gt;
 		final String arg2 = &quot;arg2&quot;;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;final String[] args = 
{&quot;--configDir&quot;, configDir, &quot;-r&quot;, String.valueOf(restPort), String.format(&quot;-D%s=%s&quot;, key, value), arg1, arg2}
&lt;p&gt;;&lt;br/&gt;
+		final String[] args = &lt;/p&gt;
{&quot;--configDir&quot;, configDir, &quot;--executionMode&quot;, &quot;cluster&quot;, &quot;--host&quot;, &quot;localhost&quot;,  &quot;-r&quot;, String.valueOf(restPort), String.format(&quot;-D%s=%s&quot;, key, value), arg1, arg2}
&lt;p&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		final EntrypointClusterConfiguration clusterConfiguration = commandLineParser.parse(args);&lt;/p&gt;

&lt;p&gt;diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java&lt;br/&gt;
index 3b9c5786ca4..bf8751547ee 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/InMemorySubmittedJobGraphStore.java&lt;br/&gt;
@@ -76,7 +76,7 @@ public synchronized SubmittedJobGraph recoverJobGraph(JobID jobId) throws Except&lt;br/&gt;
 		verifyIsStarted();&lt;/p&gt;

&lt;p&gt; 		if (recoverJobGraphFunction != null) &lt;/p&gt;
{
-			return recoverJobGraphFunction.applyWithException(jobId, storedJobs);
+			return recoverJobGraphFunction.apply(jobId, storedJobs);
 		}
&lt;p&gt; else {&lt;br/&gt;
 			return requireNonNull(&lt;br/&gt;
 				storedJobs.get(jobId),&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16614819" author="till.rohrmann" created="Fri, 14 Sep 2018 13:17:24 +0000"  >&lt;p&gt;Fixed via &lt;br/&gt;
1.7.0: 3e5d07ca349a7b010bc47d1cce9b9ad3208f55a6&lt;br/&gt;
1.6.1: b9c89d9a7af45f1b605e46c7d736c3bdc9b0d16f&lt;br/&gt;
1.5.4: 5a97f12c339ed3c0b6798c9fc0fd17910689099d&lt;/p&gt;</comment>
                            <comment id="16618729" author="githubbot" created="Tue, 18 Sep 2018 08:57:35 +0000"  >&lt;p&gt;Clarkkkkk commented on issue #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#issuecomment-422313111&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#issuecomment-422313111&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Hi @tillrohrmann , is it possible that two async operation that modifies the same recoveryOperation at the same time? Would that be serializable in that case? &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16623264" author="githubbot" created="Fri, 21 Sep 2018 08:26:39 +0000"  >&lt;p&gt;tillrohrmann commented on issue #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#issuecomment-423455756&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#issuecomment-423455756&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   I think it should not be possible to have two async recovery operations ongoing since either of them will have to wait for the other to complete. That was the idea of the fix.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16623752" author="githubbot" created="Fri, 21 Sep 2018 15:10:38 +0000"  >&lt;p&gt;Clarkkkkk commented on issue #6678: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10255&quot; title=&quot;Standby Dispatcher locks submitted JobGraphs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10255&quot;&gt;&lt;del&gt;FLINK-10255&lt;/del&gt;&lt;/a&gt; Only react to onAddedJobGraph signal when being leader&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6678#issuecomment-423567013&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6678#issuecomment-423567013&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Thanks for the reply, that&apos;ll make sense.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="13179998">FLINK-10184</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13178520">FLINK-10129</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13175977">FLINK-10011</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13179998">FLINK-10184</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 8 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3xk07:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>