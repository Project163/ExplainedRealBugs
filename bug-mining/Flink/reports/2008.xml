<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:30:31 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-7637] FlinkKinesisProducer violates at-least-once guarantees</title>
                <link>https://issues.apache.org/jira/browse/FLINK-7637</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;Currently, there is no flushing of KPL outstanding records on checkpoints in the &lt;tt&gt;FlinkKinesisProducer&lt;/tt&gt;. Likewise to the at-least-once issue on the Flink Kafka producer before, this may lead to data loss if there are asynchronous failing records after a checkpoint which the records was part of was completed.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13102906">FLINK-7637</key>
            <summary>FlinkKinesisProducer violates at-least-once guarantees</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="tzulitai">Tzu-Li (Gordon) Tai</assignee>
                                    <reporter username="tzulitai">Tzu-Li (Gordon) Tai</reporter>
                        <labels>
                    </labels>
                <created>Mon, 18 Sep 2017 09:16:03 +0000</created>
                <updated>Thu, 26 Oct 2017 10:37:51 +0000</updated>
                            <resolved>Thu, 26 Oct 2017 10:37:51 +0000</resolved>
                                                    <fixVersion>1.4.0</fixVersion>
                                    <component>Connectors / Kinesis</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="16208990" author="till.rohrmann" created="Wed, 18 Oct 2017 08:47:06 +0000"  >&lt;p&gt;Is this issue in progress?&lt;/p&gt;</comment>
                            <comment id="16208993" author="tzulitai" created="Wed, 18 Oct 2017 08:49:27 +0000"  >&lt;p&gt;Yes.&lt;/p&gt;</comment>
                            <comment id="16212403" author="githubbot" created="Fri, 20 Oct 2017 09:19:02 +0000"  >&lt;p&gt;GitHub user tzulitai opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;     &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7637&quot; title=&quot;FlinkKinesisProducer violates at-least-once guarantees&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7637&quot;&gt;&lt;del&gt;FLINK-7637&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;kinesis&amp;#93;&lt;/span&gt; Fix at-least-once guarantee in FlinkKinesisProducer&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    Prior to this PR, there is no flushing of KPL outstanding records on checkpoints in the `FlinkKinesisProducer`. Likewise to the at-least-once issue on the Flink Kafka producer before, this may lead to data loss if there are asynchronous failing records after a checkpoint which the records was part of was completed.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Fix at-least-once in the Kinesis producer by properly flushing on checkpoints.&lt;/li&gt;
	&lt;li&gt;Minor fixes (last 2 commits) that cleans up the code.&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    New unit tests are added to `FlinkKinesisProducerTest` to verify at-least-once.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): no&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: no&lt;/li&gt;
	&lt;li&gt;The serializers: no&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): no&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: no&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? no&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? n/a&lt;/li&gt;
&lt;/ul&gt;




&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/tzulitai/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/tzulitai/flink&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7637&quot; title=&quot;FlinkKinesisProducer violates at-least-once guarantees&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7637&quot;&gt;&lt;del&gt;FLINK-7637&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4871&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 3cbb6a9fd35437cc913e7535b5de1d4a6fb2d746&lt;br/&gt;
Author: Tzu-Li (Gordon) Tai &amp;lt;tzulitai@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-10-20T09:05:25Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7637&quot; title=&quot;FlinkKinesisProducer violates at-least-once guarantees&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7637&quot;&gt;&lt;del&gt;FLINK-7637&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;kinesis&amp;#93;&lt;/span&gt; Fix at-least-once guarantee in FlinkKinesisProducer&lt;/p&gt;

&lt;p&gt;    Prior to this commit, there is no flushing of KPL outstanding records on&lt;br/&gt;
    checkpoints in the FlinkKinesisProducer. Likewise to the at-least-once&lt;br/&gt;
    issue on the Flink Kafka producer before, this may lead to data loss if&lt;br/&gt;
    there are asynchronous failing records after a checkpoint which the&lt;br/&gt;
    records was part of was completed.&lt;/p&gt;

&lt;p&gt;commit a2c3019087ea277d93eb835a1f70dc6e345e4133&lt;br/&gt;
Author: Tzu-Li (Gordon) Tai &amp;lt;tzulitai@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-10-20T09:06:36Z&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;hotfix&amp;#93;&lt;/span&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;kinesis&amp;#93;&lt;/span&gt; Fix inproper test name in FlinkKinesisProducerTest&lt;/p&gt;

&lt;p&gt;commit d547dd7d690edb6ec058dfbcbdcb77b4b8727c95&lt;br/&gt;
Author: Tzu-Li (Gordon) Tai &amp;lt;tzulitai@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-10-20T09:11:00Z&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;hotfix&amp;#93;&lt;/span&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;kinesis&amp;#93;&lt;/span&gt; Properly add serialVersionUIDs to FlinkKinesisProducer classes&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16214838" author="githubbot" created="Mon, 23 Oct 2017 09:02:42 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146196771&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146196771&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducer.java &amp;#8212;&lt;br/&gt;
    @@ -207,23 +214,8 @@ public void invoke(OUT value) throws Exception {&lt;br/&gt;
     		if (this.producer == null) &lt;/p&gt;
{
     			throw new RuntimeException(&quot;Kinesis producer has been closed&quot;);
     		}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (thrownException != null) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    nit: it would be easier to review the code, if refactor (like extracting this code to a method) was in separate commit then &quot;real&quot; &quot;production&quot; changes. Especially if those production changes are pretty minimal in term of number of changes line codes &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16214839" author="githubbot" created="Mon, 23 Oct 2017 09:02:42 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146200480&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146200480&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducerTest.java &amp;#8212;&lt;br/&gt;
    @@ -49,61 +71,205 @@ public void testCreateWithNonSerializableDeserializerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided serialization schema is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testCreateWithSerializableDeserializer() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithNonSerializableCustomPartitionerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided custom partitioner is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new NonSerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithSerializableCustomPartitioner() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new SerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConsumerIsSerializable() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig);
    +		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties());
     		assertTrue(InstantiationUtil.isSerializable(consumer));
     	}

&lt;p&gt;     	// ----------------------------------------------------------------------&lt;br/&gt;
    +	// Tests to verify at-least-once guarantee&lt;br/&gt;
    +	// ----------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnInvoke() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-2&quot;));
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			// the next invoke should rethrow the async exception
    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());
    +
    +			// test succeeded
    +			return;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			testHarness.snapshot(123L, 123L);
    +		} catch (Exception e) {    +			// the next invoke should rethrow the async exception    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());    +    +			// test succeeded    +			return;    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,&lt;br/&gt;
    +	 * it should be rethrown; we set a timeout because the test will not finish if the logic is broken.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Did you forget to set the timeout?&lt;/p&gt;</comment>
                            <comment id="16214840" author="githubbot" created="Mon, 23 Oct 2017 09:02:42 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146198571&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146198571&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducer.java &amp;#8212;&lt;br/&gt;
    @@ -265,19 +257,86 @@ public void close() throws Exception {&lt;br/&gt;
     		if (kp != null) {&lt;br/&gt;
     			LOG.info(&quot;Flushing outstanding {} records&quot;, kp.getOutstandingRecordsCount());&lt;br/&gt;
     			// try to flush all outstanding records&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (kp.getOutstandingRecordsCount() &amp;gt; 0) {&lt;/li&gt;
	&lt;li&gt;kp.flush();&lt;/li&gt;
	&lt;li&gt;try 
{
    -					Thread.sleep(500);
    -				}
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
    -					LOG.warn(&quot;Flushing was interrupted.&quot;);
    -					// stop the blocking flushing and destroy producer immediately
    -					break;
    -				}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    +			flushSync(kp);&lt;br/&gt;
    +&lt;br/&gt;
     			LOG.info(&quot;Flushing done. Destroying producer instance.&quot;);&lt;br/&gt;
     			kp.destroy();&lt;br/&gt;
     		}&lt;br/&gt;
    +&lt;br/&gt;
    +		// make sure we propagate pending errors&lt;br/&gt;
    +		checkAndPropagateAsyncError();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void initializeState(FunctionInitializationContext context) throws Exception 
{
    +		// nothing to do
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void snapshotState(FunctionSnapshotContext context) throws Exception &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +		// check for asynchronous errors and fail the checkpoint if necessary    +		checkAndPropagateAsyncError();    +    +		flushSync(producer);    +		if (producer.getOutstandingRecordsCount() &amp;gt; 0) {
    +			throw new IllegalStateException(
    +				&quot;Number of outstanding records must be zero at this point: &quot; + producer.getOutstandingRecordsCount());
    +		}    +    +		// if the flushed requests has errors, we should propagate it also and fail the checkpoint    +		checkAndPropagateAsyncError();    +	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +	// --------------------------- Utilities ---------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Creates a &lt;/p&gt;
{@link KinesisProducer}
&lt;p&gt;.&lt;br/&gt;
    +	 * Exposed so that tests can inject mock producers easily.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@VisibleForTesting&lt;br/&gt;
    +	protected KinesisProducer getKinesisProducer(KinesisProducerConfiguration producerConfig) &lt;/p&gt;
{
    +		return new KinesisProducer(producerConfig);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Check if there are any asynchronous exceptions. If so, rethrow the exception.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void checkAndPropagateAsyncError() throws Exception {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I am assuming that during this moving - copy/pasting - there were no changes in the code? (Btw, that&apos;s another reason why having refactors in separate commits makes reviewing easier &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ) &lt;/p&gt;</comment>
                            <comment id="16214841" author="githubbot" created="Mon, 23 Oct 2017 09:02:42 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146204340&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146204340&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducerTest.java &amp;#8212;&lt;br/&gt;
    @@ -49,61 +71,205 @@ public void testCreateWithNonSerializableDeserializerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided serialization schema is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testCreateWithSerializableDeserializer() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithNonSerializableCustomPartitionerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided custom partitioner is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new NonSerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithSerializableCustomPartitioner() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new SerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConsumerIsSerializable() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig);
    +		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties());
     		assertTrue(InstantiationUtil.isSerializable(consumer));
     	}

&lt;p&gt;     	// ----------------------------------------------------------------------&lt;br/&gt;
    +	// Tests to verify at-least-once guarantee&lt;br/&gt;
    +	// ----------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnInvoke() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-2&quot;));
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			// the next invoke should rethrow the async exception
    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());
    +
    +			// test succeeded
    +			return;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			testHarness.snapshot(123L, 123L);
    +		} catch (Exception e) {    +			// the next invoke should rethrow the async exception    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());    +    +			// test succeeded    +			return;    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,&lt;br/&gt;
    +	 * it should be rethrown; we set a timeout because the test will not finish if the logic is broken.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;Note that this test does not test the snapshot method is blocked correctly when there are pending recorrds.&lt;br/&gt;
    +	 * The test for that is covered in testAtLeastOnceProducer.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownAfterFlush() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-2&quot;));&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-3&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		// only let the first record succeed for now&lt;br/&gt;
    +		UserRecordResult result = mock(UserRecordResult.class);&lt;br/&gt;
    +		when(result.isSuccessful()).thenReturn(true);&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).set(result);&lt;br/&gt;
    +&lt;br/&gt;
    +		CheckedThread snapshotThread = new CheckedThread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void go() throws Exception &lt;/p&gt;
{
    +				// this should block at first, since there are still two pending records that needs to be flushed
    +				testHarness.snapshot(123L, 123L);
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +		snapshotThread.start();&lt;br/&gt;
    +&lt;br/&gt;
    +		// let the 2nd message fail with an async exception&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(1).setException(new Exception(&quot;artificial async failure for 2nd message&quot;));&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			snapshotThread.sync();
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			// the next invoke should rethrow the async exception
    +			e.printStackTrace();
    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async failure for 2nd message&quot;).isPresent());
    +
    +			// test succeeded
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that the producer is not dropping buffered records;&lt;br/&gt;
    +	 * we set a timeout because the test will not finish if the logic is broken.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	@Test(timeout = 10000)&lt;br/&gt;
    +	public void testAtLeastOnceProducer() throws Throwable {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I am not sure if this test is good enough:&lt;/p&gt;

&lt;p&gt;    1. It is not testing the code that it should &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; it is using overriden version of the `FlinkKinesisProducer` - `DummyFlinkKinesisProducer` can hide bugs in the real implementation.&lt;br/&gt;
    2. Implementing it as a unit test with mocks, doesn&apos;t test for out integration with `Kinesis`. You made some assumption how `at-least-once` should be implemented, you implemented it in production code and here you are repeating the same code using the same assumptions &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    However looking at Kafka tests instability I&apos;m not sure which approach is worse... Unless those are not tests instabilities but bugs in our code, which Kafka&apos;s ITCases are triggering from time to time - this mockito based test would not discover such bugs.&lt;/p&gt;</comment>
                            <comment id="16214842" author="githubbot" created="Mon, 23 Oct 2017 09:02:42 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146197645&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146197645&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducer.java &amp;#8212;&lt;br/&gt;
    @@ -265,19 +257,86 @@ public void close() throws Exception {&lt;br/&gt;
     		if (kp != null) {&lt;br/&gt;
     			LOG.info(&quot;Flushing outstanding {} records&quot;, kp.getOutstandingRecordsCount());&lt;br/&gt;
     			// try to flush all outstanding records&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (kp.getOutstandingRecordsCount() &amp;gt; 0) {&lt;/li&gt;
	&lt;li&gt;kp.flush();&lt;/li&gt;
	&lt;li&gt;try 
{
    -					Thread.sleep(500);
    -				}
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
    -					LOG.warn(&quot;Flushing was interrupted.&quot;);
    -					// stop the blocking flushing and destroy producer immediately
    -					break;
    -				}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    +			flushSync(kp);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    why do we need this `kp` local variable? Without it, there would be no need to passe `KinesisProducer` as a param to `flushSync`, because `flushSync()` could just use `this.producer`.&lt;/p&gt;</comment>
                            <comment id="16215290" author="githubbot" created="Mon, 23 Oct 2017 15:20:42 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146301761&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146301761&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducerTest.java &amp;#8212;&lt;br/&gt;
    @@ -49,61 +71,205 @@ public void testCreateWithNonSerializableDeserializerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided serialization schema is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testCreateWithSerializableDeserializer() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithNonSerializableCustomPartitionerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided custom partitioner is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new NonSerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithSerializableCustomPartitioner() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new SerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConsumerIsSerializable() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig);
    +		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties());
     		assertTrue(InstantiationUtil.isSerializable(consumer));
     	}

&lt;p&gt;     	// ----------------------------------------------------------------------&lt;br/&gt;
    +	// Tests to verify at-least-once guarantee&lt;br/&gt;
    +	// ----------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnInvoke() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-2&quot;));
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			// the next invoke should rethrow the async exception
    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());
    +
    +			// test succeeded
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.snapshot(123L, 123L);
    +		}
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
    +			// the next invoke should rethrow the async exception&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    nit: the comment refers to `invoke`, which is probably copy-pasted form above&lt;/p&gt;</comment>
                            <comment id="16215293" author="githubbot" created="Mon, 23 Oct 2017 15:21:38 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146302059&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146302059&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducerTest.java &amp;#8212;&lt;br/&gt;
    @@ -49,61 +71,205 @@ public void testCreateWithNonSerializableDeserializerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided serialization schema is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testCreateWithSerializableDeserializer() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithNonSerializableCustomPartitionerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided custom partitioner is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new NonSerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithSerializableCustomPartitioner() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new SerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConsumerIsSerializable() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig);
    +		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties());
     		assertTrue(InstantiationUtil.isSerializable(consumer));
     	}

&lt;p&gt;     	// ----------------------------------------------------------------------&lt;br/&gt;
    +	// Tests to verify at-least-once guarantee&lt;br/&gt;
    +	// ----------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnInvoke() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-2&quot;));
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			// the next invoke should rethrow the async exception
    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());
    +
    +			// test succeeded
    +			return;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			testHarness.snapshot(123L, 123L);
    +		} catch (Exception e) {    +			// the next invoke should rethrow the async exception    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());    +    +			// test succeeded    +			return;    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,&lt;br/&gt;
    +	 * it should be rethrown; we set a timeout because the test will not finish if the logic is broken.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;Note that this test does not test the snapshot method is blocked correctly when there are pending recorrds.&lt;br/&gt;
    +	 * The test for that is covered in testAtLeastOnceProducer.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownAfterFlush() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-2&quot;));&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-3&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		// only let the first record succeed for now&lt;br/&gt;
    +		UserRecordResult result = mock(UserRecordResult.class);&lt;br/&gt;
    +		when(result.isSuccessful()).thenReturn(true);&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).set(result);&lt;br/&gt;
    +&lt;br/&gt;
    +		CheckedThread snapshotThread = new CheckedThread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void go() throws Exception &lt;/p&gt;
{
    +				// this should block at first, since there are still two pending records that needs to be flushed
    +				testHarness.snapshot(123L, 123L);
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +		snapshotThread.start();&lt;br/&gt;
    +&lt;br/&gt;
    +		// let the 2nd message fail with an async exception&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(1).setException(new Exception(&quot;artificial async failure for 2nd message&quot;));&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			snapshotThread.sync();
    +		}
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
    +			// the next invoke should rethrow the async exception&lt;br/&gt;
    +			e.printStackTrace();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Leftover printing.&lt;/p&gt;</comment>
                            <comment id="16216206" author="githubbot" created="Tue, 24 Oct 2017 02:38:04 +0000"  >&lt;p&gt;Github user bowenli86 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146440154&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146440154&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducer.java &amp;#8212;&lt;br/&gt;
    @@ -265,19 +259,86 @@ public void close() throws Exception {&lt;br/&gt;
     		if (kp != null) {&lt;br/&gt;
     			LOG.info(&quot;Flushing outstanding {} records&quot;, kp.getOutstandingRecordsCount());&lt;br/&gt;
     			// try to flush all outstanding records&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (kp.getOutstandingRecordsCount() &amp;gt; 0) {&lt;/li&gt;
	&lt;li&gt;kp.flush();&lt;/li&gt;
	&lt;li&gt;try 
{
    -					Thread.sleep(500);
    -				}
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
    -					LOG.warn(&quot;Flushing was interrupted.&quot;);
    -					// stop the blocking flushing and destroy producer immediately
    -					break;
    -				}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    +			flushSync(kp);&lt;br/&gt;
    +&lt;br/&gt;
     			LOG.info(&quot;Flushing done. Destroying producer instance.&quot;);&lt;br/&gt;
     			kp.destroy();&lt;br/&gt;
     		}&lt;br/&gt;
    +&lt;br/&gt;
    +		// make sure we propagate pending errors&lt;br/&gt;
    +		checkAndPropagateAsyncError();&lt;br/&gt;
     	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +	@Override&lt;br/&gt;
    +	public void initializeState(FunctionInitializationContext context) throws Exception &lt;/p&gt;
{
    +		// nothing to do
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void snapshotState(FunctionSnapshotContext context) throws Exception {&lt;br/&gt;
    +		// check for asynchronous errors and fail the checkpoint if necessary&lt;br/&gt;
    +		checkAndPropagateAsyncError();&lt;br/&gt;
    +&lt;br/&gt;
    +		flushSync(producer);&lt;br/&gt;
    +		if (producer.getOutstandingRecordsCount() &amp;gt; 0) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    what if records are added by another thread between the calls of `flushSync()` and `producer.getOutstandingRecordsCount()`?&lt;/p&gt;</comment>
                            <comment id="16216408" author="githubbot" created="Tue, 24 Oct 2017 06:52:29 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146466653&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146466653&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducer.java &amp;#8212;&lt;br/&gt;
    @@ -207,23 +214,8 @@ public void invoke(OUT value) throws Exception {&lt;br/&gt;
     		if (this.producer == null) &lt;/p&gt;
{
     			throw new RuntimeException(&quot;Kinesis producer has been closed&quot;);
     		}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (thrownException != null) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Will keep that in mind for the future :+1: &lt;/p&gt;</comment>
                            <comment id="16216410" author="githubbot" created="Tue, 24 Oct 2017 06:52:52 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146466699&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146466699&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducer.java &amp;#8212;&lt;br/&gt;
    @@ -265,19 +257,86 @@ public void close() throws Exception {&lt;br/&gt;
     		if (kp != null) {&lt;br/&gt;
     			LOG.info(&quot;Flushing outstanding {} records&quot;, kp.getOutstandingRecordsCount());&lt;br/&gt;
     			// try to flush all outstanding records&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (kp.getOutstandingRecordsCount() &amp;gt; 0) {&lt;/li&gt;
	&lt;li&gt;kp.flush();&lt;/li&gt;
	&lt;li&gt;try 
{
    -					Thread.sleep(500);
    -				}
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
    -					LOG.warn(&quot;Flushing was interrupted.&quot;);
    -					// stop the blocking flushing and destroy producer immediately
    -					break;
    -				}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    +			flushSync(kp);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Makes sense, will change.&lt;/p&gt;</comment>
                            <comment id="16216411" author="githubbot" created="Tue, 24 Oct 2017 06:53:20 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146466759&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146466759&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducer.java &amp;#8212;&lt;br/&gt;
    @@ -265,19 +257,86 @@ public void close() throws Exception {&lt;br/&gt;
     		if (kp != null) {&lt;br/&gt;
     			LOG.info(&quot;Flushing outstanding {} records&quot;, kp.getOutstandingRecordsCount());&lt;br/&gt;
     			// try to flush all outstanding records&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (kp.getOutstandingRecordsCount() &amp;gt; 0) {&lt;/li&gt;
	&lt;li&gt;kp.flush();&lt;/li&gt;
	&lt;li&gt;try 
{
    -					Thread.sleep(500);
    -				}
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
    -					LOG.warn(&quot;Flushing was interrupted.&quot;);
    -					// stop the blocking flushing and destroy producer immediately
    -					break;
    -				}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    +			flushSync(kp);&lt;br/&gt;
    +&lt;br/&gt;
     			LOG.info(&quot;Flushing done. Destroying producer instance.&quot;);&lt;br/&gt;
     			kp.destroy();&lt;br/&gt;
     		}&lt;br/&gt;
    +&lt;br/&gt;
    +		// make sure we propagate pending errors&lt;br/&gt;
    +		checkAndPropagateAsyncError();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void initializeState(FunctionInitializationContext context) throws Exception 
{
    +		// nothing to do
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void snapshotState(FunctionSnapshotContext context) throws Exception &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +		// check for asynchronous errors and fail the checkpoint if necessary    +		checkAndPropagateAsyncError();    +    +		flushSync(producer);    +		if (producer.getOutstandingRecordsCount() &amp;gt; 0) {
    +			throw new IllegalStateException(
    +				&quot;Number of outstanding records must be zero at this point: &quot; + producer.getOutstandingRecordsCount());
    +		}    +    +		// if the flushed requests has errors, we should propagate it also and fail the checkpoint    +		checkAndPropagateAsyncError();    +	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +	// --------------------------- Utilities ---------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Creates a &lt;/p&gt;
{@link KinesisProducer}
&lt;p&gt;.&lt;br/&gt;
    +	 * Exposed so that tests can inject mock producers easily.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@VisibleForTesting&lt;br/&gt;
    +	protected KinesisProducer getKinesisProducer(KinesisProducerConfiguration producerConfig) &lt;/p&gt;
{
    +		return new KinesisProducer(producerConfig);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Check if there are any asynchronous exceptions. If so, rethrow the exception.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void checkAndPropagateAsyncError() throws Exception {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    yes, only a refactoring of the code to a separate method.&lt;/p&gt;</comment>
                            <comment id="16216413" author="githubbot" created="Tue, 24 Oct 2017 06:53:30 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146466785&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146466785&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducerTest.java &amp;#8212;&lt;br/&gt;
    @@ -49,61 +71,205 @@ public void testCreateWithNonSerializableDeserializerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided serialization schema is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testCreateWithSerializableDeserializer() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithNonSerializableCustomPartitionerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided custom partitioner is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new NonSerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithSerializableCustomPartitioner() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new SerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConsumerIsSerializable() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig);
    +		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties());
     		assertTrue(InstantiationUtil.isSerializable(consumer));
     	}

&lt;p&gt;     	// ----------------------------------------------------------------------&lt;br/&gt;
    +	// Tests to verify at-least-once guarantee&lt;br/&gt;
    +	// ----------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnInvoke() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-2&quot;));
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			// the next invoke should rethrow the async exception
    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());
    +
    +			// test succeeded
    +			return;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			testHarness.snapshot(123L, 123L);
    +		} catch (Exception e) {    +			// the next invoke should rethrow the async exception    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());    +    +			// test succeeded    +			return;    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,&lt;br/&gt;
    +	 * it should be rethrown; we set a timeout because the test will not finish if the logic is broken.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Indeed, will add.&lt;/p&gt;</comment>
                            <comment id="16216416" author="githubbot" created="Tue, 24 Oct 2017 06:54:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146466958&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146466958&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducerTest.java &amp;#8212;&lt;br/&gt;
    @@ -49,61 +71,205 @@ public void testCreateWithNonSerializableDeserializerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided serialization schema is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testCreateWithSerializableDeserializer() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithNonSerializableCustomPartitionerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided custom partitioner is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new NonSerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithSerializableCustomPartitioner() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new SerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConsumerIsSerializable() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig);
    +		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties());
     		assertTrue(InstantiationUtil.isSerializable(consumer));
     	}

&lt;p&gt;     	// ----------------------------------------------------------------------&lt;br/&gt;
    +	// Tests to verify at-least-once guarantee&lt;br/&gt;
    +	// ----------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnInvoke() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-2&quot;));
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			// the next invoke should rethrow the async exception
    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());
    +
    +			// test succeeded
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.snapshot(123L, 123L);
    +		}
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
    +			// the next invoke should rethrow the async exception&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Good catch, will fix.&lt;/p&gt;</comment>
                            <comment id="16216419" author="githubbot" created="Tue, 24 Oct 2017 06:56:05 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146467213&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146467213&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducer.java &amp;#8212;&lt;br/&gt;
    @@ -265,19 +259,86 @@ public void close() throws Exception {&lt;br/&gt;
     		if (kp != null) {&lt;br/&gt;
     			LOG.info(&quot;Flushing outstanding {} records&quot;, kp.getOutstandingRecordsCount());&lt;br/&gt;
     			// try to flush all outstanding records&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (kp.getOutstandingRecordsCount() &amp;gt; 0) {&lt;/li&gt;
	&lt;li&gt;kp.flush();&lt;/li&gt;
	&lt;li&gt;try 
{
    -					Thread.sleep(500);
    -				}
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
    -					LOG.warn(&quot;Flushing was interrupted.&quot;);
    -					// stop the blocking flushing and destroy producer immediately
    -					break;
    -				}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    +			flushSync(kp);&lt;br/&gt;
    +&lt;br/&gt;
     			LOG.info(&quot;Flushing done. Destroying producer instance.&quot;);&lt;br/&gt;
     			kp.destroy();&lt;br/&gt;
     		}&lt;br/&gt;
    +&lt;br/&gt;
    +		// make sure we propagate pending errors&lt;br/&gt;
    +		checkAndPropagateAsyncError();&lt;br/&gt;
     	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +	@Override&lt;br/&gt;
    +	public void initializeState(FunctionInitializationContext context) throws Exception &lt;/p&gt;
{
    +		// nothing to do
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public void snapshotState(FunctionSnapshotContext context) throws Exception {&lt;br/&gt;
    +		// check for asynchronous errors and fail the checkpoint if necessary&lt;br/&gt;
    +		checkAndPropagateAsyncError();&lt;br/&gt;
    +&lt;br/&gt;
    +		flushSync(producer);&lt;br/&gt;
    +		if (producer.getOutstandingRecordsCount() &amp;gt; 0) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    @bowenli86 I don&apos;t think that would happen. Records are added to the producer only in `invoke`, which is guaranteed to not be executed concurrently with `snapshotState`.&lt;/p&gt;</comment>
                            <comment id="16216665" author="githubbot" created="Tue, 24 Oct 2017 10:17:54 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146514847&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146514847&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducerTest.java &amp;#8212;&lt;br/&gt;
    @@ -49,61 +71,205 @@ public void testCreateWithNonSerializableDeserializerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided serialization schema is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testCreateWithSerializableDeserializer() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithNonSerializableCustomPartitionerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided custom partitioner is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new NonSerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithSerializableCustomPartitioner() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new SerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConsumerIsSerializable() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig);
    +		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties());
     		assertTrue(InstantiationUtil.isSerializable(consumer));
     	}

&lt;p&gt;     	// ----------------------------------------------------------------------&lt;br/&gt;
    +	// Tests to verify at-least-once guarantee&lt;br/&gt;
    +	// ----------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnInvoke() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-2&quot;));
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			// the next invoke should rethrow the async exception
    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());
    +
    +			// test succeeded
    +			return;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			testHarness.snapshot(123L, 123L);
    +		} catch (Exception e) {    +			// the next invoke should rethrow the async exception    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());    +    +			// test succeeded    +			return;    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,&lt;br/&gt;
    +	 * it should be rethrown; we set a timeout because the test will not finish if the logic is broken.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;Note that this test does not test the snapshot method is blocked correctly when there are pending recorrds.&lt;br/&gt;
    +	 * The test for that is covered in testAtLeastOnceProducer.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownAfterFlush() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-2&quot;));&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-3&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		// only let the first record succeed for now&lt;br/&gt;
    +		UserRecordResult result = mock(UserRecordResult.class);&lt;br/&gt;
    +		when(result.isSuccessful()).thenReturn(true);&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).set(result);&lt;br/&gt;
    +&lt;br/&gt;
    +		CheckedThread snapshotThread = new CheckedThread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void go() throws Exception &lt;/p&gt;
{
    +				// this should block at first, since there are still two pending records that needs to be flushed
    +				testHarness.snapshot(123L, 123L);
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +		snapshotThread.start();&lt;br/&gt;
    +&lt;br/&gt;
    +		// let the 2nd message fail with an async exception&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(1).setException(new Exception(&quot;artificial async failure for 2nd message&quot;));&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			snapshotThread.sync();
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			// the next invoke should rethrow the async exception
    +			e.printStackTrace();
    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async failure for 2nd message&quot;).isPresent());
    +
    +			// test succeeded
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that the producer is not dropping buffered records;&lt;br/&gt;
    +	 * we set a timeout because the test will not finish if the logic is broken.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	@Test(timeout = 10000)&lt;br/&gt;
    +	public void testAtLeastOnceProducer() throws Throwable {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I can see your point. Regarding your concerns:&lt;/p&gt;

&lt;p&gt;    For 1.: I think it is still ok, since the `DummyFlinkKinesisProducer` only overrides the `getKinesisProducer` method to implement a mock producer. Also, while the `snapshotState` method is overriden, I&apos;m only overriding it to inject sync-point latches. The flushing behaviour of the `snapshotState`&apos;s implementation should still be guarded by this test.&lt;br/&gt;
    For 2.: The lack of integration tests with Kinesis has always been an issue. There simply is no simple way to implement IT tests for that.&lt;/p&gt;

&lt;p&gt;    What do you think?&lt;/p&gt;</comment>
                            <comment id="16216692" author="githubbot" created="Tue, 24 Oct 2017 10:46:38 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871#discussion_r146520929&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871#discussion_r146520929&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/FlinkKinesisProducerTest.java &amp;#8212;&lt;br/&gt;
    @@ -49,61 +71,205 @@ public void testCreateWithNonSerializableDeserializerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided serialization schema is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new NonSerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testCreateWithSerializableDeserializer() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), testConfig);
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SerializableSerializationSchema(), getStandardProperties());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithNonSerializableCustomPartitionerFails() &lt;/p&gt;
{
     		exception.expect(IllegalArgumentException.class);
     		exception.expectMessage(&quot;The provided custom partitioner is not serializable&quot;);
     
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new NonSerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConfigureWithSerializableCustomPartitioner() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig)
    +		new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties())
     			.setCustomPartitioner(new SerializableCustomPartitioner());
     	}

&lt;p&gt;     	@Test&lt;br/&gt;
     	public void testConsumerIsSerializable() &lt;/p&gt;
{
    -		Properties testConfig = new Properties();
    -		testConfig.setProperty(AWSConfigConstants.AWS_REGION, &quot;us-east-1&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_ACCESS_KEY_ID, &quot;accessKeyId&quot;);
    -		testConfig.setProperty(AWSConfigConstants.AWS_SECRET_ACCESS_KEY, &quot;secretKey&quot;);
    -
    -		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), testConfig);
    +		FlinkKinesisProducer&amp;lt;String&amp;gt; consumer = new FlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema(), getStandardProperties());
     		assertTrue(InstantiationUtil.isSerializable(consumer));
     	}

&lt;p&gt;     	// ----------------------------------------------------------------------&lt;br/&gt;
    +	// Tests to verify at-least-once guarantee&lt;br/&gt;
    +	// ----------------------------------------------------------------------&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnInvoke() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-2&quot;));
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			// the next invoke should rethrow the async exception
    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());
    +
    +			// test succeeded
    +			return;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).setException(new Exception(&quot;artificial async exception&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			testHarness.snapshot(123L, 123L);
    +		} catch (Exception e) {    +			// the next invoke should rethrow the async exception    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async exception&quot;).isPresent());    +    +			// test succeeded    +			return;    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,&lt;br/&gt;
    +	 * it should be rethrown; we set a timeout because the test will not finish if the logic is broken.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;Note that this test does not test the snapshot method is blocked correctly when there are pending recorrds.&lt;br/&gt;
    +	 * The test for that is covered in testAtLeastOnceProducer.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;ResultOfMethodCallIgnored&quot;)&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAsyncErrorRethrownAfterFlush() throws Throwable {&lt;br/&gt;
    +		final DummyFlinkKinesisProducer&amp;lt;String&amp;gt; producer = new DummyFlinkKinesisProducer&amp;lt;&amp;gt;(new SimpleStringSchema());&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;String, Object&amp;gt; testHarness =&lt;br/&gt;
    +			new OneInputStreamOperatorTestHarness&amp;lt;&amp;gt;(new StreamSink&amp;lt;&amp;gt;(producer));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-1&quot;));&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-2&quot;));&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(&quot;msg-3&quot;));&lt;br/&gt;
    +&lt;br/&gt;
    +		// only let the first record succeed for now&lt;br/&gt;
    +		UserRecordResult result = mock(UserRecordResult.class);&lt;br/&gt;
    +		when(result.isSuccessful()).thenReturn(true);&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(0).set(result);&lt;br/&gt;
    +&lt;br/&gt;
    +		CheckedThread snapshotThread = new CheckedThread() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public void go() throws Exception &lt;/p&gt;
{
    +				// this should block at first, since there are still two pending records that needs to be flushed
    +				testHarness.snapshot(123L, 123L);
    +			}
&lt;p&gt;    +		};&lt;br/&gt;
    +		snapshotThread.start();&lt;br/&gt;
    +&lt;br/&gt;
    +		// let the 2nd message fail with an async exception&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(1).setException(new Exception(&quot;artificial async failure for 2nd message&quot;));&lt;br/&gt;
    +		producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class));&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			snapshotThread.sync();
    +		}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +			// the next invoke should rethrow the async exception
    +			e.printStackTrace();
    +			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, &quot;artificial async failure for 2nd message&quot;).isPresent());
    +
    +			// test succeeded
    +			return;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		Assert.fail();&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Test ensuring that the producer is not dropping buffered records;&lt;br/&gt;
    +	 * we set a timeout because the test will not finish if the logic is broken.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	@Test(timeout = 10000)&lt;br/&gt;
    +	public void testAtLeastOnceProducer() throws Throwable {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I am still not convinced on the value of such tests (reverse implementing the production code), but I will not press it since:&lt;br/&gt;
    &amp;gt; There simply is no simple way to implement IT tests for that.&lt;/p&gt;</comment>
                            <comment id="16216701" author="githubbot" created="Tue, 24 Oct 2017 10:59:31 +0000"  >&lt;p&gt;Github user tzulitai commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @pnowojski @aljoscha @bowenli86 thanks a lot for the reviews.&lt;br/&gt;
    I&apos;ve either addressed them with the follow up commits or left comments.&lt;/p&gt;</comment>
                            <comment id="16217199" author="githubbot" created="Tue, 24 Oct 2017 16:35:38 +0000"  >&lt;p&gt;Github user bowenli86 commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    LGTM :+1: &lt;/p&gt;</comment>
                            <comment id="16218098" author="githubbot" created="Wed, 25 Oct 2017 05:03:12 +0000"  >&lt;p&gt;Github user tzulitai commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks.&lt;/p&gt;

&lt;p&gt;    I made one last change: allow direct import of non-shaded guava in `FlinkKinesisProducerTest`.&lt;br/&gt;
    The reason for this is that the Kinesis API directly exposes Guava, so we can&apos;t use the Flink shaded dependencies.&lt;/p&gt;

&lt;p&gt;    Will proceed to merge if Travis gives green.&lt;br/&gt;
    cc @aljoscha in case you want a final pass before that happens!&lt;/p&gt;</comment>
                            <comment id="16218339" author="githubbot" created="Wed, 25 Oct 2017 10:05:45 +0000"  >&lt;p&gt;Github user aljoscha commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for the heads-up but I think this looks good!&lt;/p&gt;</comment>
                            <comment id="16218378" author="githubbot" created="Wed, 25 Oct 2017 10:35:15 +0000"  >&lt;p&gt;Github user tzulitai commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Merging ..&lt;/p&gt;</comment>
                            <comment id="16218451" author="githubbot" created="Wed, 25 Oct 2017 11:54:33 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4871&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16218467" author="tzulitai" created="Wed, 25 Oct 2017 12:08:37 +0000"  >&lt;p&gt;1.4: 073b82c856c0897679d46576ec902c4e5e3a5e32.&lt;/p&gt;

&lt;p&gt;Closing this JIRA only after 1.3 Travis passes and fix is merged.&lt;br/&gt;
Awaiting travis run: &lt;a href=&quot;https://travis-ci.org/tzulitai/flink/builds/292581243?utm_source=github_status&amp;amp;utm_medium=notification&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://travis-ci.org/tzulitai/flink/builds/292581243?utm_source=github_status&amp;amp;utm_medium=notification&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16220286" author="aljoscha" created="Thu, 26 Oct 2017 10:37:40 +0000"  >&lt;p&gt;I created &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7931&quot; title=&quot;FlinkKinesisProducer violates at-least-once guarantees (1.3 branch)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7931&quot;&gt;&lt;del&gt;FLINK-7931&lt;/del&gt;&lt;/a&gt; for tracking this issue for 1.3.3 so that closing this issue can unblock 1.4.0.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10020">
                    <name>Cloners</name>
                                                                <inwardlinks description="is cloned by">
                                        <issuelink>
            <issuekey id="13112235">FLINK-7931</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 3 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3k6gf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>