<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:25:22 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-4793] Using a local method with :: notation in Java 8 causes index out of bounds</title>
                <link>https://issues.apache.org/jira/browse/FLINK-4793</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;I tried to use the toString method on an object as a map function:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;                .&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt;map(Trade::toString)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This caused an index out of bounds error:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;java.lang.ArrayIndexOutOfBoundsException: -1
	at org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(TypeExtractor.java:351)
	at org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(TypeExtractor.java:305)
	at org.apache.flink.api.java.typeutils.TypeExtractor.getMapReturnTypes(TypeExtractor.java:120)
	at org.apache.flink.streaming.api.datastream.DataStream.map(DataStream.java:506)
	at com.mapr.aggregate.AggregateTest.testAggregateTrades(AggregateTest.java:81)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:68)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;On the other hand, if I use a public static method, like this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;                .&amp;lt;Trade&amp;gt;map(Trade::fromString)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;All is good. fromString and toString are defined like this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; Trade fromString(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; mapper.readValue(s, Trade.class);
    }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; toString() {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-quote&quot;&gt;&quot;{\&quot;&lt;/span&gt;%s\&lt;span class=&quot;code-quote&quot;&gt;&quot;, %d, %d, %.2f}&quot;&lt;/span&gt;, symbol, time, volume, price);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This might be a viable restriction on what functions I can use, but there certainly should be a better error message, if so.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13011214">FLINK-4793</key>
            <summary>Using a local method with :: notation in Java 8 causes index out of bounds</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="twalthr">Timo Walther</assignee>
                                    <reporter username="tdunning">Ted Dunning</reporter>
                        <labels>
                    </labels>
                <created>Tue, 11 Oct 2016 01:37:25 +0000</created>
                <updated>Wed, 12 Oct 2016 09:06:03 +0000</updated>
                            <resolved>Wed, 12 Oct 2016 09:06:03 +0000</resolved>
                                                    <fixVersion>1.2.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="15564935" author="stephanewen" created="Tue, 11 Oct 2016 08:52:22 +0000"  >&lt;p&gt;What version is affected by this bug?&lt;br/&gt;
This looks like something that is fixed, at least for Flink 1.2.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=twalthr&quot; class=&quot;user-hover&quot; rel=&quot;twalthr&quot;&gt;twalthr&lt;/a&gt; Can you comment on this?&lt;/p&gt;</comment>
                            <comment id="15564985" author="twalthr" created="Tue, 11 Oct 2016 09:18:21 +0000"  >&lt;p&gt;I will look into this.&lt;/p&gt;</comment>
                            <comment id="15565337" author="twalthr" created="Tue, 11 Oct 2016 12:54:52 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tdunning&quot; class=&quot;user-hover&quot; rel=&quot;tdunning&quot;&gt;tdunning&lt;/a&gt; which Flink version are you using? Your issue might already be fixed in &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-3138&quot; title=&quot;Method References are not supported as lambda expressions&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-3138&quot;&gt;&lt;del&gt;FLINK-3138&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="15565341" author="twalthr" created="Tue, 11 Oct 2016 12:57:24 +0000"  >&lt;p&gt;I found another bug that I will fix in a upcoming PR. Now this should work:&lt;/p&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;	@Test
	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void testLambda() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
		ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();
		env.fromElements(&lt;span class=&quot;code-quote&quot;&gt;&quot;xx&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;xx&quot;&lt;/span&gt;).map(Trade::&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt;).map(Trade::toString).print();
	}

	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Trade {
		&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; v;
		&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Trade(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; v) {
			&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.v = v;
		}
		@Override
		&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; toString() {
			&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; v;
		}
	}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="15565439" author="githubbot" created="Tue, 11 Oct 2016 13:43:46 +0000"  >&lt;p&gt;GitHub user twalthr opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/2621&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/2621&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-4793&quot; title=&quot;Using a local method with :: notation in Java 8 causes index out of bounds&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-4793&quot;&gt;&lt;del&gt;FLINK-4793&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;types&amp;#93;&lt;/span&gt; Improve lambda constructor reference handling&lt;/p&gt;

&lt;p&gt;    Thanks for contributing to Apache Flink. Before you open your pull request, please take the following check list into consideration.&lt;br/&gt;
    If your changes take all of the items into account, feel free to open your pull request. For more information and/or questions please refer to the &lt;span class=&quot;error&quot;&gt;&amp;#91;How To Contribute guide&amp;#93;&lt;/span&gt;(&lt;a href=&quot;http://flink.apache.org/how-to-contribute.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://flink.apache.org/how-to-contribute.html&lt;/a&gt;).&lt;br/&gt;
    In addition to going through the list, please provide a meaningful description of your changes.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;x&amp;#93;&lt;/span&gt; General&lt;/li&gt;
	&lt;li&gt;The pull request references the related JIRA issue (&quot;&lt;span class=&quot;error&quot;&gt;&amp;#91;FLINK-XXX&amp;#93;&lt;/span&gt; Jira title text&quot;)&lt;/li&gt;
	&lt;li&gt;The pull request addresses only one issue&lt;/li&gt;
	&lt;li&gt;Each commit in the PR has a meaningful commit message (including the JIRA id)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;x&amp;#93;&lt;/span&gt; Documentation&lt;/li&gt;
	&lt;li&gt;Documentation has been added for new functionality&lt;/li&gt;
	&lt;li&gt;Old documentation affected by the pull request has been updated&lt;/li&gt;
	&lt;li&gt;JavaDoc for public methods has been added&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;x&amp;#93;&lt;/span&gt; Tests &amp;amp; Build&lt;/li&gt;
	&lt;li&gt;Functionality added by the pull request is covered by tests&lt;/li&gt;
	&lt;li&gt;`mvn clean verify` has been executed successfully locally or a Travis build has passed&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This PR further improves the handling of Java 8 lambdas. It improves the handling of constructor references. The following is now possible:&lt;/p&gt;

&lt;p&gt;    `env.fromElements(&quot;xx&quot;, &quot;xx&quot;).map(Trade::new).map(Trade::toString).print();`&lt;/p&gt;

&lt;p&gt;    Unfortunately, I had to add the ASM dependency to `flink-core`. I hope this is not a problem.&lt;/p&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/twalthr/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/twalthr/flink&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-4793&quot; title=&quot;Using a local method with :: notation in Java 8 causes index out of bounds&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-4793&quot;&gt;&lt;del&gt;FLINK-4793&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/2621.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/2621.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #2621&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 0e85f7273dab446f71d832bf453d3dcc96c41599&lt;br/&gt;
Author: twalthr &amp;lt;twalthr@apache.org&amp;gt;&lt;br/&gt;
Date:   2016-10-11T13:33:20Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-4793&quot; title=&quot;Using a local method with :: notation in Java 8 causes index out of bounds&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-4793&quot;&gt;&lt;del&gt;FLINK-4793&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;types&amp;#93;&lt;/span&gt; Improve lambda constructor reference handling&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15565605" author="githubbot" created="Tue, 11 Oct 2016 14:39:55 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/2621#discussion_r82807840&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/2621#discussion_r82807840&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractionUtils.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,167 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.api.java.typeutils;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.lang.reflect.Constructor;&lt;br/&gt;
    +import java.lang.reflect.Method;&lt;br/&gt;
    +import java.lang.reflect.Type;&lt;br/&gt;
    +import java.util.ArrayList;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.annotation.Internal;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.Function;&lt;br/&gt;
    +import static org.objectweb.asm.Type.getConstructorDescriptor;&lt;br/&gt;
    +import static org.objectweb.asm.Type.getMethodDescriptor;&lt;br/&gt;
    +&lt;br/&gt;
    +@Internal&lt;br/&gt;
    +public class TypeExtractionUtils {&lt;br/&gt;
    +&lt;br/&gt;
    +	private TypeExtractionUtils() &lt;/p&gt;
{
    +		// do not allow instantiation
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Similar to a Java 8 Executable but with a return type.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class LambdaExecutable {&lt;br/&gt;
    +&lt;br/&gt;
    +		private Type[] parameterTypes;&lt;br/&gt;
    +		private Type returnType;&lt;br/&gt;
    +		private String name;&lt;br/&gt;
    +		private Object executable;&lt;br/&gt;
    +&lt;br/&gt;
    +		public LambdaExecutable(Constructor&amp;lt;?&amp;gt; constructor) &lt;/p&gt;
{
    +			this.parameterTypes = constructor.getGenericParameterTypes();
    +			this.returnType = constructor.getDeclaringClass();
    +			this.name = constructor.getName();
    +			this.executable = constructor;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public LambdaExecutable(Method method) &lt;/p&gt;
{
    +			this.parameterTypes = method.getGenericParameterTypes();
    +			this.returnType = method.getGenericReturnType();
    +			this.name = method.getName();
    +			this.executable = method;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public Type[] getParameterTypes() &lt;/p&gt;
{
    +			return parameterTypes;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public Type getReturnType() &lt;/p&gt;
{
    +			return returnType;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public String getName() &lt;/p&gt;
{
    +			return name;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public boolean executablesEquals(Method m) &lt;/p&gt;
{
    +			return executable.equals(m);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public boolean executablesEquals(Constructor&amp;lt;?&amp;gt; c) &lt;/p&gt;
{
    +			return executable.equals(c);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public static LambdaExecutable checkAndExtractLambda(Function function) {&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			// get serialized lambda&lt;br/&gt;
    +			Object serializedLambda = null;&lt;br/&gt;
    +			for (Class&amp;lt;?&amp;gt; clazz = function.getClass(); clazz != null; clazz = clazz.getSuperclass()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					Method replaceMethod = clazz.getDeclaredMethod(&quot;writeReplace&quot;);&lt;br/&gt;
    +					replaceMethod.setAccessible(true);&lt;br/&gt;
    +					Object serialVersion = replaceMethod.invoke(function);&lt;br/&gt;
    +&lt;br/&gt;
    +					// check if class is a lambda function&lt;br/&gt;
    +					if (serialVersion.getClass().getName().equals(&quot;java.lang.invoke.SerializedLambda&quot;)) {&lt;br/&gt;
    +&lt;br/&gt;
    +						// check if SerializedLambda class is present&lt;br/&gt;
    +						try &lt;/p&gt;
{
    +							Class.forName(&quot;java.lang.invoke.SerializedLambda&quot;);
    +						}
&lt;p&gt;    +						catch (Exception e) &lt;/p&gt;
{
    +							throw new UnsupportedOperationException(&quot;User code tries to use lambdas, but framework is running with a Java version &amp;lt; 8&quot;);
    +						}
&lt;p&gt;    +						serializedLambda = serialVersion;&lt;br/&gt;
    +						break;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				}&lt;br/&gt;
    +				catch (NoSuchMethodException e) &lt;/p&gt;
{
    +					// thrown if the method is not there. fall through the loop
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +			// not a lambda method -&amp;gt; return null&lt;br/&gt;
    +			if (serializedLambda == null) &lt;/p&gt;
{
    +				return null;
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			// find lambda method&lt;br/&gt;
    +			Method implClassMethod = serializedLambda.getClass().getDeclaredMethod(&quot;getImplClass&quot;);&lt;br/&gt;
    +			Method implMethodNameMethod = serializedLambda.getClass().getDeclaredMethod(&quot;getImplMethodName&quot;);&lt;br/&gt;
    +			Method implMethodSig = serializedLambda.getClass().getDeclaredMethod(&quot;getImplMethodSignature&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +			String className = (String) implClassMethod.invoke(serializedLambda);&lt;br/&gt;
    +			String methodName = (String) implMethodNameMethod.invoke(serializedLambda);&lt;br/&gt;
    +			String methodSig = (String) implMethodSig.invoke(serializedLambda);&lt;br/&gt;
    +&lt;br/&gt;
    +			Class&amp;lt;?&amp;gt; implClass = Class.forName(className.replace(&apos;/&apos;, &apos;.&apos;), true, Thread.currentThread().getContextClassLoader());&lt;br/&gt;
    +&lt;br/&gt;
    +			// find constructor&lt;br/&gt;
    +			if (methodName.equals(&quot;&amp;lt;init&amp;gt;&quot;)) {&lt;br/&gt;
    +				Constructor&amp;lt;?&amp;gt;[] constructors = implClass.getDeclaredConstructors();&lt;br/&gt;
    +				for (Constructor&amp;lt;?&amp;gt; constructor : constructors) {&lt;br/&gt;
    +					if(getConstructorDescriptor(constructor).equals(methodSig)) &lt;/p&gt;
{
    +						return new LambdaExecutable(constructor);
    +					}
&lt;p&gt;    +				}&lt;br/&gt;
    +			}&lt;br/&gt;
    +			// find method&lt;br/&gt;
    +			else {&lt;br/&gt;
    +				List&amp;lt;Method&amp;gt; methods = getAllDeclaredMethods(implClass);&lt;br/&gt;
    +				for (Method method : methods) {&lt;br/&gt;
    +					if(method.getName().equals(methodName) &amp;amp;&amp;amp; getMethodDescriptor(method).equals(methodSig)) &lt;/p&gt;
{
    +						return new LambdaExecutable(method);
    +					}
&lt;p&gt;    +				}&lt;br/&gt;
    +			}&lt;br/&gt;
    +			throw new Exception(&quot;No lambda method found.&quot;);&lt;br/&gt;
    +		}&lt;br/&gt;
    +		catch (Exception e) {&lt;br/&gt;
    +			throw new RuntimeException(&quot;Could not extract lambda method out of function: &quot; + e.getClass().getSimpleName() + &quot; - &quot; + e.getMessage(), e);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    RuntimeException is usually used for programming errors (wrong arguments, null divisions, ...).&lt;br/&gt;
    Something that is expected to fail sometimes beyond the programmers control (I/O, code analysis, etc) should use checked exceptions.&lt;/p&gt;</comment>
                            <comment id="15565608" author="githubbot" created="Tue, 11 Oct 2016 14:41:04 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/2621#discussion_r82808001&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/2621#discussion_r82808001&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractionUtils.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,167 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.api.java.typeutils;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.lang.reflect.Constructor;&lt;br/&gt;
    +import java.lang.reflect.Method;&lt;br/&gt;
    +import java.lang.reflect.Type;&lt;br/&gt;
    +import java.util.ArrayList;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.annotation.Internal;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.Function;&lt;br/&gt;
    +import static org.objectweb.asm.Type.getConstructorDescriptor;&lt;br/&gt;
    +import static org.objectweb.asm.Type.getMethodDescriptor;&lt;br/&gt;
    +&lt;br/&gt;
    +@Internal&lt;br/&gt;
    +public class TypeExtractionUtils {&lt;br/&gt;
    +&lt;br/&gt;
    +	private TypeExtractionUtils() &lt;/p&gt;
{
    +		// do not allow instantiation
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Similar to a Java 8 Executable but with a return type.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class LambdaExecutable {&lt;br/&gt;
    +&lt;br/&gt;
    +		private Type[] parameterTypes;&lt;br/&gt;
    +		private Type returnType;&lt;br/&gt;
    +		private String name;&lt;br/&gt;
    +		private Object executable;&lt;br/&gt;
    +&lt;br/&gt;
    +		public LambdaExecutable(Constructor&amp;lt;?&amp;gt; constructor) &lt;/p&gt;
{
    +			this.parameterTypes = constructor.getGenericParameterTypes();
    +			this.returnType = constructor.getDeclaringClass();
    +			this.name = constructor.getName();
    +			this.executable = constructor;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public LambdaExecutable(Method method) &lt;/p&gt;
{
    +			this.parameterTypes = method.getGenericParameterTypes();
    +			this.returnType = method.getGenericReturnType();
    +			this.name = method.getName();
    +			this.executable = method;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public Type[] getParameterTypes() &lt;/p&gt;
{
    +			return parameterTypes;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public Type getReturnType() &lt;/p&gt;
{
    +			return returnType;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public String getName() &lt;/p&gt;
{
    +			return name;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public boolean executablesEquals(Method m) &lt;/p&gt;
{
    +			return executable.equals(m);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public boolean executablesEquals(Constructor&amp;lt;?&amp;gt; c) &lt;/p&gt;
{
    +			return executable.equals(c);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public static LambdaExecutable checkAndExtractLambda(Function function) {&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			// get serialized lambda&lt;br/&gt;
    +			Object serializedLambda = null;&lt;br/&gt;
    +			for (Class&amp;lt;?&amp;gt; clazz = function.getClass(); clazz != null; clazz = clazz.getSuperclass()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					Method replaceMethod = clazz.getDeclaredMethod(&quot;writeReplace&quot;);&lt;br/&gt;
    +					replaceMethod.setAccessible(true);&lt;br/&gt;
    +					Object serialVersion = replaceMethod.invoke(function);&lt;br/&gt;
    +&lt;br/&gt;
    +					// check if class is a lambda function&lt;br/&gt;
    +					if (serialVersion.getClass().getName().equals(&quot;java.lang.invoke.SerializedLambda&quot;)) {&lt;br/&gt;
    +&lt;br/&gt;
    +						// check if SerializedLambda class is present&lt;br/&gt;
    +						try &lt;/p&gt;
{
    +							Class.forName(&quot;java.lang.invoke.SerializedLambda&quot;);
    +						}
&lt;p&gt;    +						catch (Exception e) &lt;/p&gt;
{
    +							throw new UnsupportedOperationException(&quot;User code tries to use lambdas, but framework is running with a Java version &amp;lt; 8&quot;);
    +						}
&lt;p&gt;    +						serializedLambda = serialVersion;&lt;br/&gt;
    +						break;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				}&lt;br/&gt;
    +				catch (NoSuchMethodException e) &lt;/p&gt;
{
    +					// thrown if the method is not there. fall through the loop
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +			// not a lambda method -&amp;gt; return null&lt;br/&gt;
    +			if (serializedLambda == null) &lt;/p&gt;
{
    +				return null;
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			// find lambda method&lt;br/&gt;
    +			Method implClassMethod = serializedLambda.getClass().getDeclaredMethod(&quot;getImplClass&quot;);&lt;br/&gt;
    +			Method implMethodNameMethod = serializedLambda.getClass().getDeclaredMethod(&quot;getImplMethodName&quot;);&lt;br/&gt;
    +			Method implMethodSig = serializedLambda.getClass().getDeclaredMethod(&quot;getImplMethodSignature&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +			String className = (String) implClassMethod.invoke(serializedLambda);&lt;br/&gt;
    +			String methodName = (String) implMethodNameMethod.invoke(serializedLambda);&lt;br/&gt;
    +			String methodSig = (String) implMethodSig.invoke(serializedLambda);&lt;br/&gt;
    +&lt;br/&gt;
    +			Class&amp;lt;?&amp;gt; implClass = Class.forName(className.replace(&apos;/&apos;, &apos;.&apos;), true, Thread.currentThread().getContextClassLoader());&lt;br/&gt;
    +&lt;br/&gt;
    +			// find constructor&lt;br/&gt;
    +			if (methodName.equals(&quot;&amp;lt;init&amp;gt;&quot;)) {&lt;br/&gt;
    +				Constructor&amp;lt;?&amp;gt;[] constructors = implClass.getDeclaredConstructors();&lt;br/&gt;
    +				for (Constructor&amp;lt;?&amp;gt; constructor : constructors) {&lt;br/&gt;
    +					if(getConstructorDescriptor(constructor).equals(methodSig)) &lt;/p&gt;
{
    +						return new LambdaExecutable(constructor);
    +					}
&lt;p&gt;    +				}&lt;br/&gt;
    +			}&lt;br/&gt;
    +			// find method&lt;br/&gt;
    +			else {&lt;br/&gt;
    +				List&amp;lt;Method&amp;gt; methods = getAllDeclaredMethods(implClass);&lt;br/&gt;
    +				for (Method method : methods) {&lt;br/&gt;
    +					if(method.getName().equals(methodName) &amp;amp;&amp;amp; getMethodDescriptor(method).equals(methodSig)) &lt;/p&gt;
{
    +						return new LambdaExecutable(method);
    +					}
&lt;p&gt;    +				}&lt;br/&gt;
    +			}&lt;br/&gt;
    +			throw new Exception(&quot;No lambda method found.&quot;);&lt;br/&gt;
    +		}&lt;br/&gt;
    +		catch (Exception e) {&lt;br/&gt;
    +			throw new RuntimeException(&quot;Could not extract lambda method out of function: &quot; + e.getClass().getSimpleName() + &quot; - &quot; + e.getMessage(), e);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    RuntimeException is usually used for programming errors (wrong arguments, null divisions, ...).&lt;br/&gt;
    Something that is expected to fail sometimes beyond the programmers control (I/O, code analysis, etc) should use checked exceptions.&lt;/p&gt;</comment>
                            <comment id="15565660" author="githubbot" created="Tue, 11 Oct 2016 14:58:56 +0000"  >&lt;p&gt;Github user twalthr commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/2621#discussion_r82812545&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/2621#discussion_r82812545&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractionUtils.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,167 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.api.java.typeutils;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.lang.reflect.Constructor;&lt;br/&gt;
    +import java.lang.reflect.Method;&lt;br/&gt;
    +import java.lang.reflect.Type;&lt;br/&gt;
    +import java.util.ArrayList;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.annotation.Internal;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.Function;&lt;br/&gt;
    +import static org.objectweb.asm.Type.getConstructorDescriptor;&lt;br/&gt;
    +import static org.objectweb.asm.Type.getMethodDescriptor;&lt;br/&gt;
    +&lt;br/&gt;
    +@Internal&lt;br/&gt;
    +public class TypeExtractionUtils {&lt;br/&gt;
    +&lt;br/&gt;
    +	private TypeExtractionUtils() &lt;/p&gt;
{
    +		// do not allow instantiation
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Similar to a Java 8 Executable but with a return type.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class LambdaExecutable {&lt;br/&gt;
    +&lt;br/&gt;
    +		private Type[] parameterTypes;&lt;br/&gt;
    +		private Type returnType;&lt;br/&gt;
    +		private String name;&lt;br/&gt;
    +		private Object executable;&lt;br/&gt;
    +&lt;br/&gt;
    +		public LambdaExecutable(Constructor&amp;lt;?&amp;gt; constructor) &lt;/p&gt;
{
    +			this.parameterTypes = constructor.getGenericParameterTypes();
    +			this.returnType = constructor.getDeclaringClass();
    +			this.name = constructor.getName();
    +			this.executable = constructor;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public LambdaExecutable(Method method) &lt;/p&gt;
{
    +			this.parameterTypes = method.getGenericParameterTypes();
    +			this.returnType = method.getGenericReturnType();
    +			this.name = method.getName();
    +			this.executable = method;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public Type[] getParameterTypes() &lt;/p&gt;
{
    +			return parameterTypes;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public Type getReturnType() &lt;/p&gt;
{
    +			return returnType;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public String getName() &lt;/p&gt;
{
    +			return name;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public boolean executablesEquals(Method m) &lt;/p&gt;
{
    +			return executable.equals(m);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public boolean executablesEquals(Constructor&amp;lt;?&amp;gt; c) &lt;/p&gt;
{
    +			return executable.equals(c);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public static LambdaExecutable checkAndExtractLambda(Function function) {&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			// get serialized lambda&lt;br/&gt;
    +			Object serializedLambda = null;&lt;br/&gt;
    +			for (Class&amp;lt;?&amp;gt; clazz = function.getClass(); clazz != null; clazz = clazz.getSuperclass()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					Method replaceMethod = clazz.getDeclaredMethod(&quot;writeReplace&quot;);&lt;br/&gt;
    +					replaceMethod.setAccessible(true);&lt;br/&gt;
    +					Object serialVersion = replaceMethod.invoke(function);&lt;br/&gt;
    +&lt;br/&gt;
    +					// check if class is a lambda function&lt;br/&gt;
    +					if (serialVersion.getClass().getName().equals(&quot;java.lang.invoke.SerializedLambda&quot;)) {&lt;br/&gt;
    +&lt;br/&gt;
    +						// check if SerializedLambda class is present&lt;br/&gt;
    +						try &lt;/p&gt;
{
    +							Class.forName(&quot;java.lang.invoke.SerializedLambda&quot;);
    +						}
&lt;p&gt;    +						catch (Exception e) &lt;/p&gt;
{
    +							throw new UnsupportedOperationException(&quot;User code tries to use lambdas, but framework is running with a Java version &amp;lt; 8&quot;);
    +						}
&lt;p&gt;    +						serializedLambda = serialVersion;&lt;br/&gt;
    +						break;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				}&lt;br/&gt;
    +				catch (NoSuchMethodException e) &lt;/p&gt;
{
    +					// thrown if the method is not there. fall through the loop
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +			// not a lambda method -&amp;gt; return null&lt;br/&gt;
    +			if (serializedLambda == null) &lt;/p&gt;
{
    +				return null;
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			// find lambda method&lt;br/&gt;
    +			Method implClassMethod = serializedLambda.getClass().getDeclaredMethod(&quot;getImplClass&quot;);&lt;br/&gt;
    +			Method implMethodNameMethod = serializedLambda.getClass().getDeclaredMethod(&quot;getImplMethodName&quot;);&lt;br/&gt;
    +			Method implMethodSig = serializedLambda.getClass().getDeclaredMethod(&quot;getImplMethodSignature&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +			String className = (String) implClassMethod.invoke(serializedLambda);&lt;br/&gt;
    +			String methodName = (String) implMethodNameMethod.invoke(serializedLambda);&lt;br/&gt;
    +			String methodSig = (String) implMethodSig.invoke(serializedLambda);&lt;br/&gt;
    +&lt;br/&gt;
    +			Class&amp;lt;?&amp;gt; implClass = Class.forName(className.replace(&apos;/&apos;, &apos;.&apos;), true, Thread.currentThread().getContextClassLoader());&lt;br/&gt;
    +&lt;br/&gt;
    +			// find constructor&lt;br/&gt;
    +			if (methodName.equals(&quot;&amp;lt;init&amp;gt;&quot;)) {&lt;br/&gt;
    +				Constructor&amp;lt;?&amp;gt;[] constructors = implClass.getDeclaredConstructors();&lt;br/&gt;
    +				for (Constructor&amp;lt;?&amp;gt; constructor : constructors) {&lt;br/&gt;
    +					if(getConstructorDescriptor(constructor).equals(methodSig)) &lt;/p&gt;
{
    +						return new LambdaExecutable(constructor);
    +					}
&lt;p&gt;    +				}&lt;br/&gt;
    +			}&lt;br/&gt;
    +			// find method&lt;br/&gt;
    +			else {&lt;br/&gt;
    +				List&amp;lt;Method&amp;gt; methods = getAllDeclaredMethods(implClass);&lt;br/&gt;
    +				for (Method method : methods) {&lt;br/&gt;
    +					if(method.getName().equals(methodName) &amp;amp;&amp;amp; getMethodDescriptor(method).equals(methodSig)) &lt;/p&gt;
{
    +						return new LambdaExecutable(method);
    +					}
&lt;p&gt;    +				}&lt;br/&gt;
    +			}&lt;br/&gt;
    +			throw new Exception(&quot;No lambda method found.&quot;);&lt;br/&gt;
    +		}&lt;br/&gt;
    +		catch (Exception e) {&lt;br/&gt;
    +			throw new RuntimeException(&quot;Could not extract lambda method out of function: &quot; + e.getClass().getSimpleName() + &quot; - &quot; + e.getMessage(), e);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I will use an `IllegalStateException`.&lt;/p&gt;</comment>
                            <comment id="15565842" author="githubbot" created="Tue, 11 Oct 2016 16:01:51 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/2621#discussion_r82827707&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/2621#discussion_r82827707&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractionUtils.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,167 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.api.java.typeutils;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.lang.reflect.Constructor;&lt;br/&gt;
    +import java.lang.reflect.Method;&lt;br/&gt;
    +import java.lang.reflect.Type;&lt;br/&gt;
    +import java.util.ArrayList;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.annotation.Internal;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.Function;&lt;br/&gt;
    +import static org.objectweb.asm.Type.getConstructorDescriptor;&lt;br/&gt;
    +import static org.objectweb.asm.Type.getMethodDescriptor;&lt;br/&gt;
    +&lt;br/&gt;
    +@Internal&lt;br/&gt;
    +public class TypeExtractionUtils {&lt;br/&gt;
    +&lt;br/&gt;
    +	private TypeExtractionUtils() &lt;/p&gt;
{
    +		// do not allow instantiation
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Similar to a Java 8 Executable but with a return type.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class LambdaExecutable {&lt;br/&gt;
    +&lt;br/&gt;
    +		private Type[] parameterTypes;&lt;br/&gt;
    +		private Type returnType;&lt;br/&gt;
    +		private String name;&lt;br/&gt;
    +		private Object executable;&lt;br/&gt;
    +&lt;br/&gt;
    +		public LambdaExecutable(Constructor&amp;lt;?&amp;gt; constructor) &lt;/p&gt;
{
    +			this.parameterTypes = constructor.getGenericParameterTypes();
    +			this.returnType = constructor.getDeclaringClass();
    +			this.name = constructor.getName();
    +			this.executable = constructor;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public LambdaExecutable(Method method) &lt;/p&gt;
{
    +			this.parameterTypes = method.getGenericParameterTypes();
    +			this.returnType = method.getGenericReturnType();
    +			this.name = method.getName();
    +			this.executable = method;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public Type[] getParameterTypes() &lt;/p&gt;
{
    +			return parameterTypes;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public Type getReturnType() &lt;/p&gt;
{
    +			return returnType;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public String getName() &lt;/p&gt;
{
    +			return name;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public boolean executablesEquals(Method m) &lt;/p&gt;
{
    +			return executable.equals(m);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public boolean executablesEquals(Constructor&amp;lt;?&amp;gt; c) &lt;/p&gt;
{
    +			return executable.equals(c);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public static LambdaExecutable checkAndExtractLambda(Function function) {&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			// get serialized lambda&lt;br/&gt;
    +			Object serializedLambda = null;&lt;br/&gt;
    +			for (Class&amp;lt;?&amp;gt; clazz = function.getClass(); clazz != null; clazz = clazz.getSuperclass()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					Method replaceMethod = clazz.getDeclaredMethod(&quot;writeReplace&quot;);&lt;br/&gt;
    +					replaceMethod.setAccessible(true);&lt;br/&gt;
    +					Object serialVersion = replaceMethod.invoke(function);&lt;br/&gt;
    +&lt;br/&gt;
    +					// check if class is a lambda function&lt;br/&gt;
    +					if (serialVersion.getClass().getName().equals(&quot;java.lang.invoke.SerializedLambda&quot;)) {&lt;br/&gt;
    +&lt;br/&gt;
    +						// check if SerializedLambda class is present&lt;br/&gt;
    +						try &lt;/p&gt;
{
    +							Class.forName(&quot;java.lang.invoke.SerializedLambda&quot;);
    +						}
&lt;p&gt;    +						catch (Exception e) &lt;/p&gt;
{
    +							throw new UnsupportedOperationException(&quot;User code tries to use lambdas, but framework is running with a Java version &amp;lt; 8&quot;);
    +						}
&lt;p&gt;    +						serializedLambda = serialVersion;&lt;br/&gt;
    +						break;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				}&lt;br/&gt;
    +				catch (NoSuchMethodException e) &lt;/p&gt;
{
    +					// thrown if the method is not there. fall through the loop
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +			// not a lambda method -&amp;gt; return null&lt;br/&gt;
    +			if (serializedLambda == null) &lt;/p&gt;
{
    +				return null;
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			// find lambda method&lt;br/&gt;
    +			Method implClassMethod = serializedLambda.getClass().getDeclaredMethod(&quot;getImplClass&quot;);&lt;br/&gt;
    +			Method implMethodNameMethod = serializedLambda.getClass().getDeclaredMethod(&quot;getImplMethodName&quot;);&lt;br/&gt;
    +			Method implMethodSig = serializedLambda.getClass().getDeclaredMethod(&quot;getImplMethodSignature&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +			String className = (String) implClassMethod.invoke(serializedLambda);&lt;br/&gt;
    +			String methodName = (String) implMethodNameMethod.invoke(serializedLambda);&lt;br/&gt;
    +			String methodSig = (String) implMethodSig.invoke(serializedLambda);&lt;br/&gt;
    +&lt;br/&gt;
    +			Class&amp;lt;?&amp;gt; implClass = Class.forName(className.replace(&apos;/&apos;, &apos;.&apos;), true, Thread.currentThread().getContextClassLoader());&lt;br/&gt;
    +&lt;br/&gt;
    +			// find constructor&lt;br/&gt;
    +			if (methodName.equals(&quot;&amp;lt;init&amp;gt;&quot;)) {&lt;br/&gt;
    +				Constructor&amp;lt;?&amp;gt;[] constructors = implClass.getDeclaredConstructors();&lt;br/&gt;
    +				for (Constructor&amp;lt;?&amp;gt; constructor : constructors) {&lt;br/&gt;
    +					if(getConstructorDescriptor(constructor).equals(methodSig)) &lt;/p&gt;
{
    +						return new LambdaExecutable(constructor);
    +					}
&lt;p&gt;    +				}&lt;br/&gt;
    +			}&lt;br/&gt;
    +			// find method&lt;br/&gt;
    +			else {&lt;br/&gt;
    +				List&amp;lt;Method&amp;gt; methods = getAllDeclaredMethods(implClass);&lt;br/&gt;
    +				for (Method method : methods) {&lt;br/&gt;
    +					if(method.getName().equals(methodName) &amp;amp;&amp;amp; getMethodDescriptor(method).equals(methodSig)) &lt;/p&gt;
{
    +						return new LambdaExecutable(method);
    +					}
&lt;p&gt;    +				}&lt;br/&gt;
    +			}&lt;br/&gt;
    +			throw new Exception(&quot;No lambda method found.&quot;);&lt;br/&gt;
    +		}&lt;br/&gt;
    +		catch (Exception e) {&lt;br/&gt;
    +			throw new RuntimeException(&quot;Could not extract lambda method out of function: &quot; + e.getClass().getSimpleName() + &quot; - &quot; + e.getMessage(), e);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    That is another unchecked exception &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15565850" author="githubbot" created="Tue, 11 Oct 2016 16:06:03 +0000"  >&lt;p&gt;Github user twalthr commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/2621#discussion_r82828661&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/2621#discussion_r82828661&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractionUtils.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,167 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.api.java.typeutils;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.lang.reflect.Constructor;&lt;br/&gt;
    +import java.lang.reflect.Method;&lt;br/&gt;
    +import java.lang.reflect.Type;&lt;br/&gt;
    +import java.util.ArrayList;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.annotation.Internal;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.Function;&lt;br/&gt;
    +import static org.objectweb.asm.Type.getConstructorDescriptor;&lt;br/&gt;
    +import static org.objectweb.asm.Type.getMethodDescriptor;&lt;br/&gt;
    +&lt;br/&gt;
    +@Internal&lt;br/&gt;
    +public class TypeExtractionUtils {&lt;br/&gt;
    +&lt;br/&gt;
    +	private TypeExtractionUtils() &lt;/p&gt;
{
    +		// do not allow instantiation
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Similar to a Java 8 Executable but with a return type.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public static class LambdaExecutable {&lt;br/&gt;
    +&lt;br/&gt;
    +		private Type[] parameterTypes;&lt;br/&gt;
    +		private Type returnType;&lt;br/&gt;
    +		private String name;&lt;br/&gt;
    +		private Object executable;&lt;br/&gt;
    +&lt;br/&gt;
    +		public LambdaExecutable(Constructor&amp;lt;?&amp;gt; constructor) &lt;/p&gt;
{
    +			this.parameterTypes = constructor.getGenericParameterTypes();
    +			this.returnType = constructor.getDeclaringClass();
    +			this.name = constructor.getName();
    +			this.executable = constructor;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public LambdaExecutable(Method method) &lt;/p&gt;
{
    +			this.parameterTypes = method.getGenericParameterTypes();
    +			this.returnType = method.getGenericReturnType();
    +			this.name = method.getName();
    +			this.executable = method;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public Type[] getParameterTypes() &lt;/p&gt;
{
    +			return parameterTypes;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public Type getReturnType() &lt;/p&gt;
{
    +			return returnType;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public String getName() &lt;/p&gt;
{
    +			return name;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public boolean executablesEquals(Method m) &lt;/p&gt;
{
    +			return executable.equals(m);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		public boolean executablesEquals(Constructor&amp;lt;?&amp;gt; c) &lt;/p&gt;
{
    +			return executable.equals(c);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	public static LambdaExecutable checkAndExtractLambda(Function function) {&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			// get serialized lambda&lt;br/&gt;
    +			Object serializedLambda = null;&lt;br/&gt;
    +			for (Class&amp;lt;?&amp;gt; clazz = function.getClass(); clazz != null; clazz = clazz.getSuperclass()) {&lt;br/&gt;
    +				try {&lt;br/&gt;
    +					Method replaceMethod = clazz.getDeclaredMethod(&quot;writeReplace&quot;);&lt;br/&gt;
    +					replaceMethod.setAccessible(true);&lt;br/&gt;
    +					Object serialVersion = replaceMethod.invoke(function);&lt;br/&gt;
    +&lt;br/&gt;
    +					// check if class is a lambda function&lt;br/&gt;
    +					if (serialVersion.getClass().getName().equals(&quot;java.lang.invoke.SerializedLambda&quot;)) {&lt;br/&gt;
    +&lt;br/&gt;
    +						// check if SerializedLambda class is present&lt;br/&gt;
    +						try &lt;/p&gt;
{
    +							Class.forName(&quot;java.lang.invoke.SerializedLambda&quot;);
    +						}
&lt;p&gt;    +						catch (Exception e) &lt;/p&gt;
{
    +							throw new UnsupportedOperationException(&quot;User code tries to use lambdas, but framework is running with a Java version &amp;lt; 8&quot;);
    +						}
&lt;p&gt;    +						serializedLambda = serialVersion;&lt;br/&gt;
    +						break;&lt;br/&gt;
    +					}&lt;br/&gt;
    +				}&lt;br/&gt;
    +				catch (NoSuchMethodException e) &lt;/p&gt;
{
    +					// thrown if the method is not there. fall through the loop
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +&lt;br/&gt;
    +			// not a lambda method -&amp;gt; return null&lt;br/&gt;
    +			if (serializedLambda == null) &lt;/p&gt;
{
    +				return null;
    +			}
&lt;p&gt;    +&lt;br/&gt;
    +			// find lambda method&lt;br/&gt;
    +			Method implClassMethod = serializedLambda.getClass().getDeclaredMethod(&quot;getImplClass&quot;);&lt;br/&gt;
    +			Method implMethodNameMethod = serializedLambda.getClass().getDeclaredMethod(&quot;getImplMethodName&quot;);&lt;br/&gt;
    +			Method implMethodSig = serializedLambda.getClass().getDeclaredMethod(&quot;getImplMethodSignature&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +			String className = (String) implClassMethod.invoke(serializedLambda);&lt;br/&gt;
    +			String methodName = (String) implMethodNameMethod.invoke(serializedLambda);&lt;br/&gt;
    +			String methodSig = (String) implMethodSig.invoke(serializedLambda);&lt;br/&gt;
    +&lt;br/&gt;
    +			Class&amp;lt;?&amp;gt; implClass = Class.forName(className.replace(&apos;/&apos;, &apos;.&apos;), true, Thread.currentThread().getContextClassLoader());&lt;br/&gt;
    +&lt;br/&gt;
    +			// find constructor&lt;br/&gt;
    +			if (methodName.equals(&quot;&amp;lt;init&amp;gt;&quot;)) {&lt;br/&gt;
    +				Constructor&amp;lt;?&amp;gt;[] constructors = implClass.getDeclaredConstructors();&lt;br/&gt;
    +				for (Constructor&amp;lt;?&amp;gt; constructor : constructors) {&lt;br/&gt;
    +					if(getConstructorDescriptor(constructor).equals(methodSig)) &lt;/p&gt;
{
    +						return new LambdaExecutable(constructor);
    +					}
&lt;p&gt;    +				}&lt;br/&gt;
    +			}&lt;br/&gt;
    +			// find method&lt;br/&gt;
    +			else {&lt;br/&gt;
    +				List&amp;lt;Method&amp;gt; methods = getAllDeclaredMethods(implClass);&lt;br/&gt;
    +				for (Method method : methods) {&lt;br/&gt;
    +					if(method.getName().equals(methodName) &amp;amp;&amp;amp; getMethodDescriptor(method).equals(methodSig)) &lt;/p&gt;
{
    +						return new LambdaExecutable(method);
    +					}
&lt;p&gt;    +				}&lt;br/&gt;
    +			}&lt;br/&gt;
    +			throw new Exception(&quot;No lambda method found.&quot;);&lt;br/&gt;
    +		}&lt;br/&gt;
    +		catch (Exception e) {&lt;br/&gt;
    +			throw new RuntimeException(&quot;Could not extract lambda method out of function: &quot; + e.getClass().getSimpleName() + &quot; - &quot; + e.getMessage(), e);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Sorry, you are right. Ok then I will introduce a new one.&lt;/p&gt;</comment>
                            <comment id="15565919" author="tdunning" created="Tue, 11 Oct 2016 16:34:33 +0000"  >&lt;p&gt;&lt;br/&gt;
I am using a flavor of 1.1.&lt;/p&gt;</comment>
                            <comment id="15568118" author="githubbot" created="Wed, 12 Oct 2016 09:04:14 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/2621&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/2621&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15568123" author="twalthr" created="Wed, 12 Oct 2016 09:06:03 +0000"  >&lt;p&gt;Fixed in 1dda3ad009667697a620359e997e83a5ba2447dd.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            9 years, 5 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i34pan:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>