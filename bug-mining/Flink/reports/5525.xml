<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:57:54 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-23011] FLIP-27 sources are generating non-deterministic results when using event time</title>
                <link>https://issues.apache.org/jira/browse/FLINK-23011</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;FLIP-27 sources currently start in the &lt;tt&gt;StreamStatus.IDLE&lt;/tt&gt; state and they switch to &lt;tt&gt;ACTIVE&lt;/tt&gt; only after emitting first &lt;tt&gt;Watermark&lt;/tt&gt;. Until this happens, downstream operators are ignoring &lt;tt&gt;IDLE&lt;/tt&gt; inputs from calculating the input (min) watermark. &lt;/p&gt;

&lt;p&gt;An extreme example to what problem this leads to, are completely bogus results if for example one FLIP-27 source subtask is slower than others for some reason:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
env.getConfig().setAutoWatermarkInterval(2000);
env.setParallelism(2);
env.setRestartStrategy(RestartStrategies.fixedDelayRestart(&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.MAX_VALUE, 10));

DataStream&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;&amp;gt; eventStream =
        env.fromSource(
                        &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NumberSequenceSource(0, &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;.MAX_VALUE),
                        WatermarkStrategy.&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;&amp;gt;forMonotonousTimestamps()
                                .withTimestampAssigner(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LongTimestampAssigner()),
                        &lt;span class=&quot;code-quote&quot;&gt;&quot;NumberSequenceSource&quot;&lt;/span&gt;)
                .map(
                        &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RichMapFunction&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;&amp;gt;() {
                            @Override
                            &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt; map(&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt; value) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
                                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (getRuntimeContext().getIndexOfThisSubtask() == 0) {
                                    &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.sleep(1);
                                }
                                &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; 1L;
                            }
                        });

eventStream.windowAll(TumblingEventTimeWindows.of(Time.seconds(1))).sum(0).print();

(...)
&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;LongTimestampAssigner &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; SerializableTimestampAssigner&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;&amp;gt; {
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; counter = 0;

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; extractTimestamp(&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt; record, &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; recordTimeStamp) {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; counter++;
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In such case, after 2 seconds (&lt;tt&gt;setAutoWatermarkInterval&lt;/tt&gt;) the not throttled subtask (subTaskId == 1) generates very high watermarks. The other source subtask (subTaskId == 0) emits very low watermarks. If the non throttled watermark reaches the downstream &lt;tt&gt;WindowOperator&lt;/tt&gt; first, while the other input channel is still idle, it will take those high watermarks as combined input watermark for the the whole &lt;tt&gt;WindowOperator&lt;/tt&gt;. When the input channel from the throttled source subtask finally receives it&apos;s &lt;tt&gt;ACTIVE&lt;/tt&gt; status and a much lower watermark, that&apos;s already too late.&lt;/p&gt;

&lt;p&gt;Actual output of the example program:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;1596
2000
1000
1000
1000
1000
1000
1000
(...)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;while the expected output should be always &quot;2000&quot; (2000 records fitting in every 1 second global window)&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;2000
2000
2000
2000
(...)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13384131">FLINK-23011</key>
            <summary>FLIP-27 sources are generating non-deterministic results when using event time</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dwysakowicz">Dawid Wysakowicz</assignee>
                                    <reporter username="pnowojski">Piotr Nowojski</reporter>
                        <labels>
                    </labels>
                <created>Wed, 16 Jun 2021 10:10:08 +0000</created>
                <updated>Thu, 24 Jun 2021 10:15:35 +0000</updated>
                            <resolved>Tue, 22 Jun 2021 16:30:29 +0000</resolved>
                                    <version>1.14.0</version>
                                    <fixVersion>1.14.0</fixVersion>
                                    <component>API / DataStream</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                                                                <comments>
                            <comment id="17364191" author="pnowojski" created="Wed, 16 Jun 2021 10:17:02 +0000"  >&lt;p&gt;Even after fixing &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-22926&quot; title=&quot;IDLE FLIP-27 source should go ACTIVE when registering a new split&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-22926&quot;&gt;FLINK-22926&lt;/a&gt; the problem will persist, as there still would be a race condition between registering splits/switching to ACTIVE and emitting watermarks between different subtasks.&lt;/p&gt;

&lt;p&gt;Hotfix might be to force FLIP-27 source to start ACTIVE (as the legacy sources are doing). However this doesn&apos;t work if there will be more then one split assigned to single &lt;tt&gt;SourceReader&lt;/tt&gt;, and there can be a delay between assigning first and second split.&lt;/p&gt;

&lt;p&gt;The problem is that if source doesn&apos;t know about some splits, because they haven&apos;t been yet assigned (or even discovered), it can not know what watermarks would result from those unknown splits. This gets more visible if you think about some source, where discovering splits takes long time, for example some &lt;tt&gt;FileSource&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;I think the proper solution should be something like &lt;tt&gt;SplitEnumerator&lt;/tt&gt; emitting it&apos;s own watermarks, that would be capping/combined with the watermarks emitted from the sources.&lt;/p&gt;</comment>
                            <comment id="17364245" author="pnowojski" created="Wed, 16 Jun 2021 11:22:28 +0000"  >&lt;p&gt;Let me elaborate on &lt;tt&gt;FileSource&lt;/tt&gt; example. Let&apos;s say we have a bucketed file source where, split equals to a single file, with buckets (directories?) created per each hour. New files/buckets can be appearing as you go. &lt;/p&gt;

&lt;p&gt;If bucket for [12:00, 13:00) is committed, &lt;tt&gt;SplitEnumerator&lt;/tt&gt; could emit capped watermark for 13:00, and the already assigned splits will be bumping the current watermarks until this cap, as the splits are being read. Then next bucket [13:00, 14:00) is created, &lt;tt&gt;SourceReaders&lt;/tt&gt; could even start reading files from this bucket before it&#8217;s fully committed, but the watermark cap is bumped only when this next bucket is committed.&lt;/p&gt;

&lt;p&gt;It&apos;s also important in this case to automatically switch &lt;tt&gt;SourceReader&lt;/tt&gt; to idle if they don&apos;t have assigned splits. As for whatever the reason, for some buckets there can be fewer splits than parallel instances of the {{SourceReader}}s. In this case you need idleness to make progress.&lt;/p&gt;</comment>
                            <comment id="17364252" author="pnowojski" created="Wed, 16 Jun 2021 11:30:22 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=AHeise&quot; class=&quot;user-hover&quot; rel=&quot;AHeise&quot;&gt;AHeise&lt;/a&gt; suggested that as a hotfix we could block emitting watermarks/switching to &lt;tt&gt;IDLE&lt;/tt&gt; until all splits are assigned (&lt;tt&gt;SourceReader#notifyNoMoreSplits&lt;/tt&gt;). This would be a very special case of the more general solution that I was proposing with &lt;tt&gt;SplitEnumerator&lt;/tt&gt; capping the watermarks. This hotfix should work well in the cases where number of splits is determined/known from the beginning.&lt;/p&gt;</comment>
                            <comment id="17367037" author="dawidwys" created="Tue, 22 Jun 2021 06:30:16 +0000"  >&lt;p&gt;After some investigation of &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-22926&quot; title=&quot;IDLE FLIP-27 source should go ACTIVE when registering a new split&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-22926&quot;&gt;FLINK-22926&lt;/a&gt; I realized I accidently changed the behaviour for situation when there are no splits assigned. In 1.13 and older if there were no &lt;tt&gt;PartialWatermarks&lt;/tt&gt; in &lt;tt&gt;WatermarkOutputMultiplexer&lt;/tt&gt; we were not emitting the &lt;tt&gt;StreamStatus.IDLE&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;I tried reverting that behaviour in: &lt;a href=&quot;https://github.com/apache/flink/pull/16221/commits/1110cf3a53f6ccb7d09f18347ccb92f8cb346b8a&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/16221/commits/1110cf3a53f6ccb7d09f18347ccb92f8cb346b8a&lt;/a&gt;&lt;br/&gt;
I emit &lt;tt&gt;StreamStatus.IDLE&lt;/tt&gt; only if there are no splits, but the &lt;tt&gt;Watermark&lt;/tt&gt; has progressed. If it is at its initial value and there are no splits assigned yet, we do not emit &lt;tt&gt;StreamStatus&lt;/tt&gt;. Effectively that implements the workaround suggested by &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=AHeise&quot; class=&quot;user-hover&quot; rel=&quot;AHeise&quot;&gt;AHeise&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="17367057" author="pnowojski" created="Tue, 22 Jun 2021 07:15:35 +0000"  >&lt;p&gt;Ok, that&apos;s a good news. As I understand it means this issue doesn&apos;t affect any previous release, just the master branch?&lt;/p&gt;</comment>
                            <comment id="17367081" author="dawidwys" created="Tue, 22 Jun 2021 07:42:44 +0000"  >&lt;p&gt;Yes, that&apos;s correct. In past releases the FLIP-27 were ACTIVE if there were no splits.&lt;/p&gt;</comment>
                            <comment id="17367515" author="dawidwys" created="Tue, 22 Jun 2021 16:30:29 +0000"  >&lt;p&gt;Fixed in e0614e75ddec48129c30a256a4bcb70a3f8951c2&lt;/p&gt;</comment>
                            <comment id="17368003" author="stephanewen" created="Wed, 23 Jun 2021 09:52:54 +0000"  >&lt;p&gt;Some thoughts on the whole Idleness business and the cases described here:&lt;/p&gt;

&lt;p&gt;&lt;b&gt;(1) About Idleness&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Idleness inherently circumvents the core event-time mechanism. The temporary unavailability of events (data) in a partition means we cannot make any statement about event time progress (which is data-driven).&lt;/p&gt;

&lt;p&gt;However, real-world setups have the need to handle such situations (absence of data). But the behavior for that situation is very dependent on the specific data characteristics of the stream, and can really only ever be defined by a user.&lt;/p&gt;

&lt;p&gt;Therefore, I think we should have those two core rules for Idleness:&lt;/p&gt;

&lt;p&gt;    (a) Idleness should always be a user-defined thing, coming from the configured watermark strategies. The system should never trigger idleness by itself.&lt;/p&gt;

&lt;p&gt;    (b) Idleness should always refer to the situation where a source has work (splits assigned) but no data (empty partition). We should not use it in a situation where a source has no work, because in such situations there is no way to define idleness relative to stream activity (ensure that idleness is only triggered when we are sure to have fallen behind by at least X time).&lt;/p&gt;

&lt;p&gt;This means that the FLIP-27 readers should start in stat &quot;active&quot; and never switch to &quot;idle&quot; by themselves, but only when the overall watermark status (merged from all partition-specific statuses) is idle.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;(2) About Global Watermarks&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;There is currently a lack of expressiveness in the watermark system. We cannot handle the cases well where splits are in the backlog, not assigned to any reader. That is a problem most prominently for the file source at the moment, but also foreseeable for other sources.&lt;/p&gt;

&lt;p&gt;The problem is that Readers would signal watermark make progress based on their local view, lacking the knowledge that more splits are in the backlog.&lt;/p&gt;

&lt;p&gt;I think that Idleness is not the right mechanism to deal with this. What we need here is a global &quot;watermark holdback&quot; that is handled by the coordinator. Meaning the coordinator signals the readers how far they may advance their watermarks at most (based on the split backlog).&lt;/p&gt;

&lt;p&gt;For long backlogs of splits, this means that watermark alignment is inherently off and state is going to be large. But that is inherent in the nature of the way such a source generates data. We can fix that in two ways, though:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Either change the source to assign all splits immediately and read them concurrently and throttle progress on individual splits based on watermark alignment (I think this will be not super efficient)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Or advance the functionality in mixed batch/streaming execution: As long as there is a backlog of splits, execute in batch, then switch to streaming once all initial splits were processed and the source is in discovery mode for new splits. The batch execution is not sensitive to state size, which is why we don&apos;t need to worry about the drawbacks of the global watermark holdback.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="17368014" author="arvid" created="Wed, 23 Jun 2021 10:12:48 +0000"  >&lt;p&gt;Thanks for sharing your thoughts.&lt;/p&gt;

&lt;p&gt;I agree with 1(a) but I&apos;m torn on (b).&lt;/p&gt;

&lt;p&gt;If we don&apos;t use idleness in (b), we would not advance watermarks in cases where you have fewer partitions than readers. That can happen permanently (fewer kafka partitions than readers) or temporarily (kinesis currently has fewer shards but that can change later). So I think we should also use idleness here but it would be nice to differentiate the cause of idleness. &lt;/p&gt;

&lt;p&gt;I agree that we should never switch idle, active in the general framework and leave it to the source implementation. The only exception is readers that received `noMoreSplits` and drained all their splits; but that is effectively covered with END_OF_INPUT and subsequent closing of the reader.&lt;/p&gt;

&lt;p&gt;For 2). I think we see the same fundamental design issue with the current idleness that is decided per reader.&lt;/p&gt;

&lt;p&gt;Piotr and I were doing a bit of brainstorming and were thinking that a complete alternative to the current solution would be to always generate watermarks on the sources and in the case of idleness let the enumerator generate the watermarks. In certain systems, it may be easier to calculate a lower bound and propagate it to all readers.&lt;/p&gt;

&lt;p&gt;That would also allow the enumerator to not advance the watermark when it knows that splits are still in the backlog and cover situation where partitions are dynamically split/merged. I think this pretty much aligns with your idea.&lt;/p&gt;

&lt;p&gt;For me, the big question is if we need then idleness in the current form at all. If the enumerator of all sources have a meaningful way to advance the watermark and all source tasks emit these watermarks, we could get rid of StreamStatus and simplify the whole logic. I&apos;m just not sure if we can assume that all sources could implement such a behavior. I&apos;m especially struggling with continuous FileSource but it feels like watermarks are not terrible useful here anyways.&lt;/p&gt;</comment>
                            <comment id="17368119" author="stephanewen" created="Wed, 23 Jun 2021 13:36:12 +0000"  >&lt;p&gt;&lt;b&gt;About 1(b):&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;In my understanding, that is covered by the following mechanism, which we already have: When the reader gets the &lt;tt&gt;noMoreSplits&lt;/tt&gt; event and has finished all currently assigned splits, it emits a LONG_MAX watermark, thus fully and permanently unblocking the downstream eventtime progress. Having fewer partitions than readers (e.g. in Kafka) means that some readers get the end-of-partition event directly and not ever getting any partition. That would be fine.&lt;/p&gt;

&lt;p&gt;This admittedly isn&apos;t working well with Kafka partition discovery, in which case there would never be a &lt;tt&gt;noMoreSplitsEvent&lt;/tt&gt;. Then again, partition discovery breaks a lot of things (like key partition and order guarantees).&lt;/p&gt;

&lt;p&gt;I guess to make this case work, we need something like coordinator-triggered idleness, that is the only thing I can see working well. The Kafka Source&apos;s split enumerator would see that it didn&apos;t assign splits to a reader, and when being in split discovery mode, it would send a &quot;go idle&quot; event to that reader. The reader alone cannot make that decision.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;About 2&lt;/b&gt;:&lt;/p&gt;

&lt;p&gt;I kind of think about it in the exact opposite way. I agree that idleness is not per reader, but it is per split (partition), and the main purpose of it is to cover the case where a long-living split (like a Kafka or Kinesis partition/segment) have no data temporarily.&lt;br/&gt;
To my understanding, the Kafka and Kinesis case are the most common ones that we have to handle well.&lt;br/&gt;
I don&apos;t see how that can be covered be delegating the watermark assignment back to the enumerator.&lt;/p&gt;

&lt;p&gt;We could solve this without idleness by always communicating the watermark back from the reader to the enumerator, merging it there, and then rebroadcasting it from there. But that seems pretty involved and inefficient in the common case. Maybe I am overlooking something there.&lt;/p&gt;

&lt;p&gt;What I agree with is that we shouldn&apos;t be thinking about Idleness in the source design, that was what I was trying to motivate in the previous comment. Idleness is purely in the space of a partition-local Watermark Generator and only handled between WatermarkGenerators and downstream operators. The source framework never gets involved with idelness at all.&lt;/p&gt;</comment>
                            <comment id="17368244" author="arvid" created="Wed, 23 Jun 2021 14:33:50 +0000"  >&lt;p&gt;Re 1b) I agree that we already have it for static assignments. My main concern is that all more recent streaming storages seem to go into dynamic partitions (Kinesis, Pulsar, Pravega). Similarly, work-stealing is a long-term goal of FLIP-27. So having a solution that just works for Kafka with static assignment for now feels unsatisfying to me.&lt;/p&gt;

&lt;p&gt;Furthermore, with HybridSources, the issue is more pronounced. Think of a job that reads from iceberg and switches to Kafka, now some iceberg splits may be larger and take longer to ingest. At that time, the idle readers have no iceberg splits but can&apos;t close either. So we would have no watermarks until the switch to Kafka actually happens.&lt;/p&gt;

&lt;p&gt;Re 2) I like the idea of thinking in splits that would certainly also help with the unrelated event time alignment. As stated above, I don&apos;t agree on applying it only to long-living split. What happens when a storage system simply closes unused partitions after some time and reopens them when they are used finally?&lt;/p&gt;

&lt;p&gt;Watermark assignment would not happen through enumerator; just watermark generation. A reader goes idle and that tells the enumerator that it needs to generate suitable lower bounds. The enumerator periodically queries the source system for a low watermark and then sends it to ALL idle readers which in turn emit it. We could do the same just on reader level but you could easily DDoS the source system for a high degree of parallelism.&lt;/p&gt;</comment>
                            <comment id="17368343" author="stephanewen" created="Wed, 23 Jun 2021 16:51:20 +0000"  >&lt;p&gt;The dynamic partitioning case is certainly good to keep in mind. I was thinking about that in a similar way as for the file source:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;It means that we don&apos;t yet know all splits&lt;/li&gt;
	&lt;li&gt;Splits get discovered over time&lt;/li&gt;
	&lt;li&gt;But we can deduce (from metadata) the event time ranges of splits.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A Kinesis / Pulasr / Pravega source could also use the global watermark holdback: It would set the global watermark to the lowest value for which all overlapping splits (segments) are already assigned. So instead of emitting LONG_MAX, the empty reader would emit the watermark corresponding to the global holdback.&lt;/p&gt;

&lt;p&gt;As a general mechanism, this would have kind of this shape:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;When an enumerator starts, the global watermark holdback is LONG_MIN&lt;/li&gt;
	&lt;li&gt;Sources that eagerly discover and assign their splits (like Kafka w/o partition discovery) would set the global holdback to LONG_MAX immediately after assigning splits and sending the noMoreSplits.&lt;/li&gt;
	&lt;li&gt;Sources like the FileSource (or Kinesis/Pulasr/Pravega) would eagerly assign the first set of splits, then set the global watermark holdback the start of the earliest remaining split. With each next split assignment, it would advance the global watermark holdback to the start of the lowest remaining split.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think this is a bit nicer than going with idleness, because idleness semantically advances the watermark (locally) and the pulls it back, hoping that everything is still alright (that&apos;s why it is something I would only let users do explicitly, not the system).&lt;br/&gt;
In contrast this approach advances the watermark step by step, never too far (even locally). I think that makes it somewhat easier to understand and well defined. &lt;/p&gt;</comment>
                            <comment id="17368643" author="arvid" created="Thu, 24 Jun 2021 06:20:53 +0000"  >&lt;p&gt;I think we a have a large agreement here. I&apos;d open a FLIP but I still would like some clarification before that:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Does that mean, we can completely remove StreamStatus and related mechanisms? Effectively, watermark aggregation is really as simple as it gets: you take the min of all non-finished inputs. If all inputs are finished, watermark is LONG_MAX.&lt;/li&gt;
	&lt;li&gt;For multiple sources: completely drained sources emit LONG_MAX and finish, so they don&apos;t participate at all in watermark assignment.&lt;/li&gt;
	&lt;li&gt;For multiple sources: if a source is completely idle but not yet finished (bursty payloads), we may need to invent a watermark out of thin air. I think the best course in your described setup is to have idleness in the watermark generator on the enumerator that periodically advances the global watermark holdback. This is again approximate and we may be able to avoid it for sources with built-in watermarks in the first place but this is also explicitly user-defined and probably cannot be avoided.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;From an architecture&apos;s point of view, we would shift idleness and implicit watermark generation completely into the source enumerator and hide it from the downstream tasks. That gives source implementers much more freedom on the cost of having more complexity. We can solve the latter by providing building blocks and documentation.&lt;/p&gt;</comment>
                            <comment id="17368744" author="stephanewen" created="Thu, 24 Jun 2021 10:15:35 +0000"  >&lt;p&gt;I am not convinced that we should remove idleness. Idleness effectively says to temporarily advance a reader at the speed of other readers, due to a lack of better information. To provide a similar replacement, we would need to communicate watermarks from readers back to coordinators and back to other readers. That sounds a lot more complex.&lt;/p&gt;

&lt;p&gt;I would like to understand why there is such a strong desire to remove idleness. My understanding is that the idleness mechanism in the operators is pretty isolated/lightweight and doesn&apos;t add much complexity. Any added mechanism in the readers and coordinators that tries to invent a reader&apos;s watermark based on looking at other readers would easily be more complicates and less scalable and responsive.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13382348">FLINK-22890</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13382720">FLINK-22926</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 20 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z0s068:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>