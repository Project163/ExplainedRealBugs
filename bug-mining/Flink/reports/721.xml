<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:21:57 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-2624] RabbitMQ source / sink should participate in checkpointing</title>
                <link>https://issues.apache.org/jira/browse/FLINK-2624</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;The RabbitMQ connector does not offer any fault tolerance guarantees right now, because it does not participate in the checkpointing.&lt;/p&gt;

&lt;p&gt;We should integrate it in a similar was as the &lt;tt&gt;FlinkKafkaConsumer&lt;/tt&gt; is integrated.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12861860">FLINK-2624</key>
            <summary>RabbitMQ source / sink should participate in checkpointing</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="HilmiYildirim">Hilmi Yildirim</assignee>
                                    <reporter username="sewen">Stephan Ewen</reporter>
                        <labels>
                    </labels>
                <created>Fri, 4 Sep 2015 14:43:00 +0000</created>
                <updated>Wed, 12 Oct 2016 18:06:07 +0000</updated>
                            <resolved>Wed, 12 Oct 2016 18:05:46 +0000</resolved>
                                    <version>0.10.0</version>
                                    <fixVersion>1.0.0</fixVersion>
                                    <component>Connectors / Common</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="14733412" author="aljoscha" created="Mon, 7 Sep 2015 08:45:12 +0000"  >&lt;p&gt;Is it even possible with RabbitMQ to set an arbitrary read offset, as in Kafka?&lt;/p&gt;</comment>
                            <comment id="14733753" author="hilmiyildirim" created="Mon, 7 Sep 2015 14:09:49 +0000"  >&lt;p&gt;No, it is not possible to set read offsets. Unlike Kafka, RabbitMQ deletes messages  after they are acklowledged und does not keep them in the queue. Therefore, the snapshotting has to be done differently. My approach is to keep the message ids without acknowleding them. If the snapshotting is performed, then the messages are acknowledged and will be deleted from the queue.&lt;/p&gt;

&lt;p&gt;The problem is that the worker node can crash during the acknowledge phase. Therefore, the message ids have to be stored in an internal state before acknowledging them. If the acknowledgement is finished, the ids will be removed from the internal state.&lt;/p&gt;</comment>
                            <comment id="14733760" author="stephanewen" created="Mon, 7 Sep 2015 14:15:03 +0000"  >&lt;p&gt;Sounds like a good approach!&lt;/p&gt;

&lt;p&gt;Nice to see how the various different sources integrate with the checkpointing...&lt;/p&gt;</comment>
                            <comment id="14733814" author="hilmiyildirim" created="Mon, 7 Sep 2015 15:04:42 +0000"  >&lt;p&gt;Unfortunately, there is another problem. RabbitMQ delivers messages to the consumers and deletes messages if they are acknowledged. RabbitMQ does deliver a single message to only one consumer and waits for the acknowledgement until the connection is lost, e.g. the consumer crashes. If a consumer crashes, then the messages which are sent to this consumser and are not acknowledged will be sent to other consumers. For example, a consumer received messages m1,m2 and m3. If the consumer has acknowledged only m1 without m2 and m3 and he crashes, then m2 and m3 will be delivered to other conumsers.&lt;/p&gt;

&lt;p&gt;This means in our case: If a worker node crashes during the snapshotting without acknowledging all processed messages, then the state of this worker node is useless. Furthermore, the messages the consumer has acknowledged before he has crashed, are deleted.&lt;/p&gt;</comment>
                            <comment id="14734366" author="hilmiyildirim" created="Tue, 8 Sep 2015 07:33:46 +0000"  >&lt;p&gt;It is possible to ack multiple messages in one confirm. Therefore, the problem mentioned above can be solved.&lt;/p&gt;</comment>
                            <comment id="14734404" author="hilmiyildirim" created="Tue, 8 Sep 2015 08:15:04 +0000"  >&lt;p&gt;There is a problem with the method restoreState. It is only possible to restore the state of the last snapshot by reconnecting to the RabbitMQ Queue. If a worker node crashes and the connection to RabbitMQ is lost, then the messages which are not acknowledged by the worker node will be sent to other consumers.&lt;/p&gt;

&lt;p&gt;Does it cause any problems if it is only possible to restore the state of the last snapshot?&lt;/p&gt;</comment>
                            <comment id="14734431" author="stephanewen" created="Tue, 8 Sep 2015 08:48:02 +0000"  >&lt;p&gt;Is there any notion of multiple receivers, or parallel receivers in RabbitMQ?&lt;/p&gt;

&lt;p&gt;If not, then we may need to make the checkpointed version of the RabbitMQ source a non-parallel source, which runs always with parallelism one.&lt;/p&gt;</comment>
                            <comment id="14734451" author="hilmiyildirim" created="Tue, 8 Sep 2015 08:57:10 +0000"  >&lt;p&gt;Yes, RabbitMQ supports multiple receivers. If a queue has multiple consumers, then the messages are sent to them in a round robin fashion.&lt;/p&gt;</comment>
                            <comment id="14734489" author="stephanewen" created="Tue, 8 Sep 2015 09:19:26 +0000"  >&lt;p&gt;I think in that case, we should treat this as a non-parallel source. The distribution will be arbitrary and hence most likely different on a recovery run, compared to the original run.&lt;/p&gt;

&lt;p&gt;That means different sources see the messages during recovery, and could not filter duplicates.&lt;/p&gt;

&lt;p&gt;We could think later make this a parallel source, with the  heap of a write-ahead log, or so.&lt;/p&gt;
</comment>
                            <comment id="14734520" author="hilmiyildirim" created="Tue, 8 Sep 2015 09:41:02 +0000"  >&lt;p&gt;Even If we change it to a non-parallel source, the received messages will also be different on recovery if there are multiple consumers for the queue, e.g. the non-parallel source is used twice.&lt;/p&gt;

&lt;p&gt;Should I rename &quot;ConnectorSource&quot; to &quot;ParallelConnectorSource&quot;? Then I create a new class named ConnectorSource for non-parallel sources?&lt;/p&gt;</comment>
                            <comment id="14736955" author="hilmiyildirim" created="Wed, 9 Sep 2015 14:41:26 +0000"  >&lt;p&gt;I have implemented checkpointing for RabbitMQ. But the checkpointing does only work if there is only one consumer for a queue. I think that the only way to enable multi consumer checkpointing is to save all received messages. Messages can be deleted if they are included in a completed snapshot. The main issue is that, unlike Kafka, RabbitMQ is not designed for &quot;Big Data&quot; consumers.&lt;/p&gt;

&lt;p&gt;See:&lt;br/&gt;
RMQSource: &lt;a href=&quot;https://github.com/HilmiYildirim/flink/blob/RabbitMQNonParallelSnapshotting/flink-staging/flink-streaming/flink-streaming-connectors/flink-connector-rabbitmq/src/main/java/org/apache/flink/streaming/connectors/rabbitmq/RMQSource.java&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/HilmiYildirim/flink/blob/RabbitMQNonParallelSnapshotting/flink-staging/flink-streaming/flink-streaming-connectors/flink-connector-rabbitmq/src/main/java/org/apache/flink/streaming/connectors/rabbitmq/RMQSource.java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;NonParallelConnectorSource: &lt;a href=&quot;https://github.com/HilmiYildirim/flink/blob/RabbitMQNonParallelSnapshotting/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/NonParallelConnectorSource.java&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/HilmiYildirim/flink/blob/RabbitMQNonParallelSnapshotting/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/NonParallelConnectorSource.java&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14738549" author="rmetzger" created="Thu, 10 Sep 2015 10:21:13 +0000"  >&lt;p&gt;Why can&apos;t you just extend from &lt;tt&gt;RichSourceFunction&lt;/tt&gt; ? (and maybe implement &lt;tt&gt;implements ResultTypeQueryable&amp;lt;OUT&amp;gt;&lt;/tt&gt; if needed?)&lt;/p&gt;

&lt;p&gt;In the &lt;tt&gt;run()&lt;/tt&gt; method, you need to synchronize the state update (lastProcessedMessage = delivery.getEnvelope().getDeliveryTag()) and passing the element to the output collector, using the checkpoint lock from the source context. Otherwise, it can happen that the processing is not exactly once (we need to lock the while(running) loop while calling snapshotState()).&lt;/p&gt;</comment>
                            <comment id="14738555" author="rmetzger" created="Thu, 10 Sep 2015 10:33:21 +0000"  >&lt;p&gt;I see the problem with multiple consumers on the queue.&lt;br/&gt;
Maybe it would be sufficient to put a big warning into our documentation that we can not give delivery guarantees if multiple consumers are subscribed to the queue. That is really a limitation of RabbitMQ, not Flink.&lt;/p&gt;

&lt;p&gt;Do you know whether there is something like a embedded RabbitMQ server? It would be great to have one or two tests &lt;/p&gt;</comment>
                            <comment id="14738789" author="hilmiyildirim" created="Thu, 10 Sep 2015 14:08:21 +0000"  >&lt;p&gt;I have removed NonParallelConnectorSource and I have synchronized the checkpointing. If my code is ok I will do a pull request.&lt;/p&gt;

&lt;p&gt;I seems that there is no embedded RabbitMQ server (see &lt;a href=&quot;http://forum.spring.io/forum/spring-projects/integration/amqp/124243-how-can-i-start-rabbitmq-broker-during-application-startup&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://forum.spring.io/forum/spring-projects/integration/amqp/124243-how-can-i-start-rabbitmq-broker-during-application-startup&lt;/a&gt;)&lt;/p&gt;</comment>
                            <comment id="14947811" author="stephanewen" created="Wed, 7 Oct 2015 23:46:22 +0000"  >&lt;p&gt;As of recently, we have a base class for MessageQueue based sources. Can you see whether that helps your source? &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/flink/blob/master/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/MessageAcknowledingSourceBase.java&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/blob/master/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/MessageAcknowledingSourceBase.java&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14950312" author="githubbot" created="Fri, 9 Oct 2015 12:33:36 +0000"  >&lt;p&gt;GitHub user HilmiYildirim opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-2624&quot; title=&quot;RabbitMQ source / sink should participate in checkpointing&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-2624&quot;&gt;&lt;del&gt;FLINK-2624&lt;/del&gt;&lt;/a&gt;: RabbitMQSource now extends MessageAcknowledgingSourceBase.&lt;/p&gt;

&lt;p&gt;    It now participates in checkpointing.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/HilmiYildirim/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/HilmiYildirim/flink&lt;/a&gt; AckRabbitMQ&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #1243&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 50b3683c5ad0449032278600e22324784b709549&lt;br/&gt;
Author: Hilmi Yildirim &amp;lt;hilmi.yildirim@dfki.de&amp;gt;&lt;br/&gt;
Date:   2015-10-09T12:30:07Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-2624&quot; title=&quot;RabbitMQ source / sink should participate in checkpointing&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-2624&quot;&gt;&lt;del&gt;FLINK-2624&lt;/del&gt;&lt;/a&gt;: RabbitMQSource now extends MessageAcknowledgingSourceBase.&lt;br/&gt;
    It now participates in checkpointing.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="14954521" author="githubbot" created="Tue, 13 Oct 2015 07:03:44 +0000"  >&lt;p&gt;Github user rmetzger commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-147625208&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-147625208&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Hi Hilmi, &lt;br/&gt;
    thank you for your PR. We&apos;ll review it soon.&lt;/p&gt;</comment>
                            <comment id="14956434" author="githubbot" created="Wed, 14 Oct 2015 07:39:07 +0000"  >&lt;p&gt;Github user HilmiYildirim commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-147963553&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-147963553&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    There are test failures. But it seems this is not my fault.&lt;br/&gt;
    Furthermore, I have not synchronized by the checkpointingLock when calling addId. I think it is better if the synchronization is done inside the addId method. Then, someone who inherits from MessageAcknowledingSourceBase does not need to care about the synchronization.&lt;/p&gt;</comment>
                            <comment id="14960480" author="githubbot" created="Fri, 16 Oct 2015 10:16:45 +0000"  >&lt;p&gt;Github user mbalassi commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-148675785&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-148675785&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I would like to shepherd this PR.&lt;/p&gt;

&lt;p&gt;    @HilmiYildirim, I do agree with your suggestion regarding the checkpoint log. Could you change that in the PR, please?&lt;br/&gt;
    Could you also do the logging that I have suggested?&lt;/p&gt;</comment>
                            <comment id="14960756" author="githubbot" created="Fri, 16 Oct 2015 14:07:09 +0000"  >&lt;p&gt;Github user HilmiYildirim commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-148726397&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-148726397&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Done. I hope this is ok.&lt;/p&gt;</comment>
                            <comment id="14960774" author="githubbot" created="Fri, 16 Oct 2015 14:22:57 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#discussion_r42247633&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#discussion_r42247633&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/MessageAcknowledingSourceBase.java &amp;#8212;&lt;br/&gt;
    @@ -144,6 +152,20 @@ protected void addId(Id id) {&lt;/p&gt;

&lt;p&gt;     	@Override&lt;br/&gt;
     	public SerializedCheckpointData[] snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {&lt;br/&gt;
    +		if (idsForCurrentCheckpoint == null) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I think these checks are pretty redundant. The tasks should guarantee that no calls happen on non-open functions, or closed functions.&lt;/p&gt;</comment>
                            <comment id="14960790" author="githubbot" created="Fri, 16 Oct 2015 14:34:17 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#discussion_r42248976&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#discussion_r42248976&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-staging/flink-streaming/flink-streaming-connectors/flink-connector-rabbitmq/src/main/java/org/apache/flink/streaming/connectors/rabbitmq/RMQSource.java &amp;#8212;&lt;br/&gt;
    @@ -102,4 +112,18 @@ public void run(SourceContext&amp;lt;OUT&amp;gt; ctx) throws Exception {&lt;br/&gt;
     	public void cancel() &lt;/p&gt;
{
     		running = false;
     	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	protected void acknowledgeIDs(List&amp;lt;Long&amp;gt; ids) {&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			channel.basicAck(ids.get(ids.size() - 1), true);
    +		}
&lt;p&gt; catch (IOException e) {&lt;br/&gt;
    +			e.printStackTrace();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Exceptions should never be swallowed.&lt;/p&gt;</comment>
                            <comment id="14960799" author="githubbot" created="Fri, 16 Oct 2015 14:37:12 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#discussion_r42249355&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#discussion_r42249355&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-staging/flink-streaming/flink-streaming-connectors/flink-connector-rabbitmq/src/main/java/org/apache/flink/streaming/connectors/rabbitmq/RMQSource.java &amp;#8212;&lt;br/&gt;
    @@ -90,10 +99,11 @@ public void run(SourceContext&amp;lt;OUT&amp;gt; ctx) throws Exception {&lt;br/&gt;
     			delivery = consumer.nextDelivery();&lt;/p&gt;

&lt;p&gt;     			OUT result = schema.deserialize(delivery.getBody());&lt;br/&gt;
    +			addId(ctx, delivery.getEnvelope().getDeliveryTag());&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    There should be a lock scope around storing the ID and emitting the record. Have a look at the example code in the java docs of the MessageAcknowledingSourceBase class.&lt;/p&gt;</comment>
                            <comment id="14960803" author="githubbot" created="Fri, 16 Oct 2015 14:38:55 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#discussion_r42249568&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#discussion_r42249568&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/MessageAcknowledingSourceBase.java &amp;#8212;&lt;br/&gt;
    @@ -144,6 +152,20 @@ protected void addId(Id id) {&lt;/p&gt;

&lt;p&gt;     	@Override&lt;br/&gt;
     	public SerializedCheckpointData[] snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {&lt;br/&gt;
    +		if (idsForCurrentCheckpoint == null) &lt;/p&gt;
{
    +			LOG.debug(&quot;snapshotState() requested on not yet opened source; returning null.&quot;);
    +			return null;
    +		}
&lt;p&gt;    +		if (!running) &lt;/p&gt;
{
    +			LOG.debug(&quot;snapshotState() called on closed source&quot;);
    +			return null;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (LOG.isDebugEnabled()) {&lt;br/&gt;
    +			LOG.debug(&quot;Snapshotting state. Messages: {}, checkpoint id: {}, timestamp: {}&quot;,&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    The list of IDs can be very long. Not sure if it is a good idea to put that into a log statement (single line, string)&lt;/p&gt;</comment>
                            <comment id="14960806" author="githubbot" created="Fri, 16 Oct 2015 14:39:56 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#discussion_r42249695&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#discussion_r42249695&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/MessageAcknowledingSourceBase.java &amp;#8212;&lt;br/&gt;
    @@ -157,17 +179,35 @@ public void restoreState(SerializedCheckpointData[] state) throws Exception {&lt;/p&gt;

&lt;p&gt;     	@Override&lt;br/&gt;
     	public void notifyCheckpointComplete(long checkpointId) throws Exception {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for (Iterator&amp;lt;Tuple2&amp;lt;Long, List&amp;lt;Id&amp;gt;&amp;gt;&amp;gt; iter = pendingCheckpoints.iterator(); iter.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; {&lt;/li&gt;
	&lt;li&gt;Tuple2&amp;lt;Long, List&amp;lt;Id&amp;gt;&amp;gt; checkpoint = iter.next();&lt;/li&gt;
	&lt;li&gt;long id = checkpoint.f0;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;if (id &amp;lt;= checkpointId) 
{
    -				acknowledgeIDs(checkpoint.f1);
    -				iter.remove();
    -			}&lt;/li&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;break;&lt;br/&gt;
    +		if (!running) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Probably redundant&lt;/p&gt;</comment>
                            <comment id="14960808" author="githubbot" created="Fri, 16 Oct 2015 14:40:37 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#discussion_r42249791&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#discussion_r42249791&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/MessageAcknowledingSourceBase.java &amp;#8212;&lt;br/&gt;
    @@ -157,17 +179,35 @@ public void restoreState(SerializedCheckpointData[] state) throws Exception {&lt;/p&gt;

&lt;p&gt;     	@Override&lt;br/&gt;
     	public void notifyCheckpointComplete(long checkpointId) throws Exception {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for (Iterator&amp;lt;Tuple2&amp;lt;Long, List&amp;lt;Id&amp;gt;&amp;gt;&amp;gt; iter = pendingCheckpoints.iterator(); iter.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; {&lt;/li&gt;
	&lt;li&gt;Tuple2&amp;lt;Long, List&amp;lt;Id&amp;gt;&amp;gt; checkpoint = iter.next();&lt;/li&gt;
	&lt;li&gt;long id = checkpoint.f0;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;if (id &amp;lt;= checkpointId) 
{
    -				acknowledgeIDs(checkpoint.f1);
    -				iter.remove();
    -			}&lt;/li&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;break;&lt;br/&gt;
    +		if (!running) 
{
    +			LOG.debug(&quot;notifyCheckpointComplete() called on closed source&quot;);
    +			return;
    +		}
&lt;p&gt;    +		&lt;br/&gt;
    +		// only one commit operation must be in progress&lt;br/&gt;
    +		if (LOG.isDebugEnabled()) {&lt;br/&gt;
    +			LOG.debug(&quot;Committing Messages externally for checkpoint {}&quot;, checkpointId);&lt;br/&gt;
    +		}&lt;br/&gt;
    +		&lt;br/&gt;
    +		List&amp;lt;Id&amp;gt; idsOfCheckpointedMessages = new LinkedList&amp;lt;Id&amp;gt;();&lt;br/&gt;
    +		synchronized (pendingCheckpoints) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    You can skip this synchronization if the source run method properly acquires the checkpoint lock.&lt;/p&gt;</comment>
                            <comment id="14960812" author="githubbot" created="Fri, 16 Oct 2015 14:42:17 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#discussion_r42250017&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#discussion_r42250017&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/MessageAcknowledingSourceBase.java &amp;#8212;&lt;br/&gt;
    @@ -157,17 +179,35 @@ public void restoreState(SerializedCheckpointData[] state) throws Exception {&lt;/p&gt;

&lt;p&gt;     	@Override&lt;br/&gt;
     	public void notifyCheckpointComplete(long checkpointId) throws Exception {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for (Iterator&amp;lt;Tuple2&amp;lt;Long, List&amp;lt;Id&amp;gt;&amp;gt;&amp;gt; iter = pendingCheckpoints.iterator(); iter.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; {&lt;/li&gt;
	&lt;li&gt;Tuple2&amp;lt;Long, List&amp;lt;Id&amp;gt;&amp;gt; checkpoint = iter.next();&lt;/li&gt;
	&lt;li&gt;long id = checkpoint.f0;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;if (id &amp;lt;= checkpointId) 
{
    -				acknowledgeIDs(checkpoint.f1);
    -				iter.remove();
    -			}&lt;/li&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;break;&lt;br/&gt;
    +		if (!running) 
{
    +			LOG.debug(&quot;notifyCheckpointComplete() called on closed source&quot;);
    +			return;
    +		}
&lt;p&gt;    +		&lt;br/&gt;
    +		// only one commit operation must be in progress&lt;br/&gt;
    +		if (LOG.isDebugEnabled()) {&lt;br/&gt;
    +			LOG.debug(&quot;Committing Messages externally for checkpoint {}&quot;, checkpointId);&lt;br/&gt;
    +		}&lt;br/&gt;
    +		&lt;br/&gt;
    +		List&amp;lt;Id&amp;gt; idsOfCheckpointedMessages = new LinkedList&amp;lt;Id&amp;gt;();&lt;br/&gt;
    +		synchronized (pendingCheckpoints) {&lt;br/&gt;
    +			for (Iterator&amp;lt;Tuple2&amp;lt;Long, List&amp;lt;Id&amp;gt;&amp;gt;&amp;gt; iter = pendingCheckpoints.iterator(); iter.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +				Tuple2&amp;lt;Long, List&amp;lt;Id&amp;gt;&amp;gt; checkpoint = iter.next();    +				long id = checkpoint.f0;    +				    +				if (id &amp;lt;= checkpointId) {
    +					idsForCurrentCheckpoint.addAll(checkpoint.f1);
    +					acknowledgeIDs(checkpoint.f1);
    +					iter.remove();
    +				}    +				else {
    +					break;
    +				}     			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;     		}&lt;br/&gt;
    +		&lt;br/&gt;
    +		if (LOG.isInfoEnabled()) {&lt;br/&gt;
    +			LOG.info(&quot;Committing Messages with following IDs {}&quot;, idsOfCheckpointedMessages);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This will in most cases generate a gigantic log line that may bring the whole system to a stall.&lt;/p&gt;</comment>
                            <comment id="14960814" author="githubbot" created="Fri, 16 Oct 2015 14:44:40 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#discussion_r42250317&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#discussion_r42250317&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/MessageAcknowledingSourceBase.java &amp;#8212;&lt;br/&gt;
    @@ -157,17 +179,35 @@ public void restoreState(SerializedCheckpointData[] state) throws Exception {&lt;/p&gt;

&lt;p&gt;     	@Override&lt;br/&gt;
     	public void notifyCheckpointComplete(long checkpointId) throws Exception {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for (Iterator&amp;lt;Tuple2&amp;lt;Long, List&amp;lt;Id&amp;gt;&amp;gt;&amp;gt; iter = pendingCheckpoints.iterator(); iter.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; {&lt;/li&gt;
	&lt;li&gt;Tuple2&amp;lt;Long, List&amp;lt;Id&amp;gt;&amp;gt; checkpoint = iter.next();&lt;/li&gt;
	&lt;li&gt;long id = checkpoint.f0;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;if (id &amp;lt;= checkpointId) 
{
    -				acknowledgeIDs(checkpoint.f1);
    -				iter.remove();
    -			}&lt;/li&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;break;&lt;br/&gt;
    +		if (!running) 
{
    +			LOG.debug(&quot;notifyCheckpointComplete() called on closed source&quot;);
    +			return;
    +		}
&lt;p&gt;    +		&lt;br/&gt;
    +		// only one commit operation must be in progress&lt;br/&gt;
    +		if (LOG.isDebugEnabled()) {&lt;br/&gt;
    +			LOG.debug(&quot;Committing Messages externally for checkpoint {}&quot;, checkpointId);&lt;br/&gt;
    +		}&lt;br/&gt;
    +		&lt;br/&gt;
    +		List&amp;lt;Id&amp;gt; idsOfCheckpointedMessages = new LinkedList&amp;lt;Id&amp;gt;();&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The extra copying into a list only to generate a log statement seems like too much overhead.&lt;br/&gt;
    Also, logging potentially millions of IDs the log (especially on INFO level) is probably a bit overkill...&lt;/p&gt;

&lt;p&gt;    I would log the IDs on TRACE level only. Also, rather than copy the individual lists into one lists, I would save the overhead and log one line per list.&lt;/p&gt;</comment>
                            <comment id="14960820" author="githubbot" created="Fri, 16 Oct 2015 14:48:26 +0000"  >&lt;p&gt;Github user StephanEwen commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-148737070&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-148737070&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I disagree with the locking in the base class. If you look at the documenation for sources, it states how to make sure you hold the checkpoint lock when emitting the elements and updating the state (here IDs to be remembered). That is the encouraged mechanism, as it gives the exactly once guarantee&lt;/p&gt;

&lt;p&gt;    If you lock properly there, there is no need to hold any lock &lt;/p&gt;

&lt;p&gt;    In some sense all modifications to the base class are a bit tricky:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The locks are not required if you properly hold the checkpoint lock&lt;/li&gt;
	&lt;li&gt;the open/close checks are not necessary as well, this should be guaranteed by the runtime already&lt;/li&gt;
	&lt;li&gt;the logging will probably bring down the system, if used in a real setting with decent throughput.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14963179" author="githubbot" created="Mon, 19 Oct 2015 11:24:49 +0000"  >&lt;p&gt;Github user HilmiYildirim commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#discussion_r42360149&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#discussion_r42360149&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-staging/flink-streaming/flink-streaming-connectors/flink-connector-rabbitmq/src/main/java/org/apache/flink/streaming/connectors/rabbitmq/RMQSource.java &amp;#8212;&lt;br/&gt;
    @@ -102,4 +112,18 @@ public void run(SourceContext&amp;lt;OUT&amp;gt; ctx) throws Exception {&lt;br/&gt;
     	public void cancel() &lt;/p&gt;
{
     		running = false;
     	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	protected void acknowledgeIDs(List&amp;lt;Long&amp;gt; ids) {&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			channel.basicAck(ids.get(ids.size() - 1), true);
    +		}
&lt;p&gt; catch (IOException e) {&lt;br/&gt;
    +			e.printStackTrace();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Is it enough to log the exception? Because it can not be handled.&lt;/p&gt;</comment>
                            <comment id="14963191" author="githubbot" created="Mon, 19 Oct 2015 11:59:14 +0000"  >&lt;p&gt;Github user HilmiYildirim commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-149195168&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-149195168&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I adapted the code and pushed it to my repo.&lt;/p&gt;</comment>
                            <comment id="14963460" author="githubbot" created="Mon, 19 Oct 2015 15:22:39 +0000"  >&lt;p&gt;Github user HilmiYildirim commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-149248114&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-149248114&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Somehow there was an error in the push. I fixed it.&lt;/p&gt;</comment>
                            <comment id="15000342" author="githubbot" created="Wed, 11 Nov 2015 13:16:38 +0000"  >&lt;p&gt;Github user StephanEwen commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-155783584&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-155783584&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I would like to look over this in the next days and merge it if it looks good.&lt;/p&gt;

&lt;p&gt;    @HilmiYildirim Do you know of any simple way to run an embedded RabbitMQ broker in order to write some tests for this?&lt;/p&gt;</comment>
                            <comment id="15000532" author="githubbot" created="Wed, 11 Nov 2015 15:38:44 +0000"  >&lt;p&gt;Github user HilmiYildirim commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-155820098&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-155820098&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Unfortunately, I do not know a simple way to run an embedded RabbitMQ broker&lt;/p&gt;</comment>
                            <comment id="15009628" author="githubbot" created="Tue, 17 Nov 2015 21:58:56 +0000"  >&lt;p&gt;Github user rmetzger commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-157522385&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-157522385&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I think RabbitMQ is written in Erlang and does not run in the JVM. We could provide a test that expects a running RabbitMQ server somewhere (locally).&lt;/p&gt;</comment>
                            <comment id="15011023" author="githubbot" created="Wed, 18 Nov 2015 13:59:10 +0000"  >&lt;p&gt;Github user StephanEwen commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-157720650&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-157720650&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Okay. I&apos;ll try to review this and get it merged in the next days. Maybe I can even use Mockito for a minimal test...&lt;/p&gt;</comment>
                            <comment id="15029802" author="githubbot" created="Fri, 27 Nov 2015 11:56:43 +0000"  >&lt;p&gt;Github user mxm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#discussion_r46040790&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#discussion_r46040790&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-staging/flink-streaming/flink-streaming-connectors/flink-connector-rabbitmq/src/main/java/org/apache/flink/streaming/connectors/rabbitmq/RMQSource.java &amp;#8212;&lt;br/&gt;
    @@ -89,12 +99,16 @@ public void run(SourceContext&amp;lt;OUT&amp;gt; ctx) throws Exception {&lt;br/&gt;
     		while (running) {&lt;br/&gt;
     			delivery = consumer.nextDelivery();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;OUT result = schema.deserialize(delivery.getBody());&lt;/li&gt;
	&lt;li&gt;if (schema.isEndOfStream(result)) {&lt;/li&gt;
	&lt;li&gt;break;&lt;br/&gt;
    +			synchronized (ctx.getCheckpointLock()) {&lt;br/&gt;
    +				OUT result = schema.deserialize(delivery.getBody());&lt;br/&gt;
    +				addId(ctx, delivery.getEnvelope().getDeliveryTag());
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This looks like it will grow the id array infinitely when the checkpointing is disabled.&lt;/p&gt;</comment>
                            <comment id="15029868" author="githubbot" created="Fri, 27 Nov 2015 13:30:23 +0000"  >&lt;p&gt;Github user mxm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#discussion_r46046784&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#discussion_r46046784&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-staging/flink-streaming/flink-streaming-connectors/flink-connector-rabbitmq/src/main/java/org/apache/flink/streaming/connectors/rabbitmq/RMQSource.java &amp;#8212;&lt;br/&gt;
    @@ -102,4 +116,18 @@ public void run(SourceContext&amp;lt;OUT&amp;gt; ctx) throws Exception {&lt;br/&gt;
     	public void cancel() &lt;/p&gt;
{
     		running = false;
     	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	protected void acknowledgeIDs(List&amp;lt;Long&amp;gt; ids) {&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			channel.basicAck(ids.get(ids.size() - 1), true);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Since we acknowledge all ids &amp;lt;= the last stored id (the true flag), it is sufficient to store only the last id. &lt;/p&gt;</comment>
                            <comment id="15029881" author="githubbot" created="Fri, 27 Nov 2015 13:42:39 +0000"  >&lt;p&gt;Github user mxm commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-160141917&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-160141917&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    This currently only works when checkpointing is turned on. If checkpointing is turned off, not only the number of queued messages will grow unbounded, but also the messages will never be acknowledged. In terms of RabbitMQ that means that messages will be kept in the broker forever and will be redelivered once another consumer connects to the queue again.&lt;/p&gt;

&lt;p&gt;    In terms of exactly once, I&apos;m not 100% sure how we can support it. I think we have to default to per-message acknowledgments (instead of acknowledging all ids &amp;lt;= the last processed id). Only that way we can make sure that upon failure we acknowledge the right messages. The reason for that is that distribution of the messages may not be the same after a redeployment of a failed job, i.e. consumers may receive messages that have not seen the message beforehand, thus a message may be processed more than once.&lt;/p&gt;</comment>
                            <comment id="15029886" author="githubbot" created="Fri, 27 Nov 2015 13:48:15 +0000"  >&lt;p&gt;Github user mxm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#discussion_r46048074&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#discussion_r46048074&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-staging/flink-streaming/flink-streaming-connectors/flink-connector-rabbitmq/src/main/java/org/apache/flink/streaming/connectors/rabbitmq/RMQSource.java &amp;#8212;&lt;br/&gt;
    @@ -102,4 +116,18 @@ public void run(SourceContext&amp;lt;OUT&amp;gt; ctx) throws Exception {&lt;br/&gt;
     	public void cancel() &lt;/p&gt;
{
     		running = false;
     	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	protected void acknowledgeIDs(List&amp;lt;Long&amp;gt; ids) {&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			channel.basicAck(ids.get(ids.size() - 1), true);
    +		}
&lt;p&gt; catch (IOException e) {&lt;br/&gt;
    +			Log.error(&quot;Messages could not be acknowledged&quot;, e);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    If this fails, the checkpoint is incomplete. We should throw an Exception here.&lt;/p&gt;</comment>
                            <comment id="15029901" author="githubbot" created="Fri, 27 Nov 2015 14:05:15 +0000"  >&lt;p&gt;Github user mxm commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-160146335&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-160146335&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I&apos;m creating a unit test for the source which mocks the RabbitMQ classes. I would like to merge your pull request with a few changes for both the fault-tolerant and the non-fault-tolerant use case (see comments).&lt;/p&gt;</comment>
                            <comment id="15029969" author="githubbot" created="Fri, 27 Nov 2015 15:19:29 +0000"  >&lt;p&gt;Github user mxm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#discussion_r46054711&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#discussion_r46054711&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-staging/flink-streaming/flink-streaming-connectors/flink-connector-rabbitmq/src/main/java/org/apache/flink/streaming/connectors/rabbitmq/RMQSource.java &amp;#8212;&lt;br/&gt;
    @@ -102,4 +116,18 @@ public void run(SourceContext&amp;lt;OUT&amp;gt; ctx) throws Exception {&lt;br/&gt;
     	public void cancel() &lt;/p&gt;
{
     		running = false;
     	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	protected void acknowledgeIDs(List&amp;lt;Long&amp;gt; ids) {&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			channel.basicAck(ids.get(ids.size() - 1), true);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This also fails if no messages have been processed between two checkpoint intervals (-1 index).&lt;/p&gt;</comment>
                            <comment id="15031868" author="githubbot" created="Mon, 30 Nov 2015 14:48:06 +0000"  >&lt;p&gt;Github user HilmiYildirim commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-160650903&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-160650903&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Ok great&lt;/p&gt;</comment>
                            <comment id="15033788" author="githubbot" created="Tue, 1 Dec 2015 14:46:23 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15033793" author="githubbot" created="Tue, 1 Dec 2015 14:47:39 +0000"  >&lt;p&gt;Github user mxm commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1243#issuecomment-160988124&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1243#issuecomment-160988124&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thank for your contribution @HilmiYildirim. I&apos;ve merged your commit and put some changes on top of it in 9215b72422d3e638fe950b61fa01f2e4e04981a0.&lt;/p&gt;</comment>
                            <comment id="15569431" author="stephanewen" created="Wed, 12 Oct 2016 18:05:46 +0000"  >&lt;p&gt;Fixed in 9215b72422d3e638fe950b61fa01f2e4e04981a0&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            9 years, 5 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2jsnj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>