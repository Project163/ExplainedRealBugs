<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:30:31 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-7755] Null values are not correctly handled by batch inner and outer joins</title>
                <link>https://issues.apache.org/jira/browse/FLINK-7755</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;Join predicates of batch joins are not correctly evaluated according to three-value logic.&lt;br/&gt;
This affects inner as well as outer joins.&lt;/p&gt;

&lt;p&gt;The problem is that some equality predicates are only evaluated by the internal join algorithms of Flink which are based on &lt;tt&gt;TypeComparator&lt;/tt&gt;. The field &lt;tt&gt;TypeComparator&lt;/tt&gt; for &lt;tt&gt;Row&lt;/tt&gt; are implemented such that &lt;tt&gt;null == null&lt;/tt&gt; results in &lt;tt&gt;TRUE&lt;/tt&gt; to ensure correct ordering and grouping. However, three-value logic requires that &lt;tt&gt;null == null&lt;/tt&gt; results to &lt;tt&gt;UNKNOWN&lt;/tt&gt; (or null). The code generator implements this logic correctly, but for equality predicates, no code is generated.&lt;/p&gt;

&lt;p&gt;For outer joins, the problem is a bit tricker because these do not support code-generated predicates yet (see &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5520&quot; title=&quot;Disable outer joins with non-equality predicates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5520&quot;&gt;&lt;del&gt;FLINK-5520&lt;/del&gt;&lt;/a&gt;). &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5498&quot; title=&quot;Add support for left/right outer joins with non-equality predicates (and 1+ equality predicates)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5498&quot;&gt;&lt;del&gt;FLINK-5498&lt;/del&gt;&lt;/a&gt; proposes a solution for this issue.&lt;/p&gt;

&lt;p&gt;We also need to extend several of the existing tests and add null values to ensure that the join logic is correctly implemented. &lt;/p&gt;</description>
                <environment></environment>
        <key id="13106521">FLINK-7755</key>
            <summary>Null values are not correctly handled by batch inner and outer joins</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="fhueske">Fabian Hueske</assignee>
                                    <reporter username="fhueske">Fabian Hueske</reporter>
                        <labels>
                    </labels>
                <created>Mon, 2 Oct 2017 19:30:53 +0000</created>
                <updated>Tue, 24 Oct 2017 18:34:07 +0000</updated>
                            <resolved>Tue, 24 Oct 2017 18:34:07 +0000</resolved>
                                    <version>1.3.2</version>
                    <version>1.4.0</version>
                                    <fixVersion>1.4.0</fixVersion>
                                    <component>Table SQL / API</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="16208982" author="till.rohrmann" created="Wed, 18 Oct 2017 08:42:05 +0000"  >&lt;p&gt;Is this truly a blocker issue? I would assess it as critical since it might already have been included in 1.3.&lt;/p&gt;</comment>
                            <comment id="16208992" author="fhueske" created="Wed, 18 Oct 2017 08:49:24 +0000"  >&lt;p&gt;We compute wrong results. This is qualifies as a blocker, IMO.&lt;/p&gt;</comment>
                            <comment id="16209183" author="till.rohrmann" created="Wed, 18 Oct 2017 11:40:05 +0000"  >&lt;p&gt;But this bug is already present since Flink 1.3, right? I wouldn&apos;t really block 1.4 on this issue. Even though I think we should try to push hard to get it in for 1.4.&lt;/p&gt;</comment>
                            <comment id="16209189" author="fhueske" created="Wed, 18 Oct 2017 11:47:52 +0000"  >&lt;p&gt;I think we should treat this kind of bugs as blockers. &lt;br/&gt;
If something fails or doesn&apos;t work it is bad, but if it returns wrong results without users noticing its much worse, IMO.&lt;/p&gt;</comment>
                            <comment id="16210847" author="githubbot" created="Thu, 19 Oct 2017 10:26:36 +0000"  >&lt;p&gt;GitHub user fhueske opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7755&quot; title=&quot;Null values are not correctly handled by batch inner and outer joins&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7755&quot;&gt;&lt;del&gt;FLINK-7755&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;table&amp;#93;&lt;/span&gt; Fix NULL handling in batch joins.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This PR fixes a couple of issues with Table API / SQL batch joins:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Proper support for joining null values for inner and outer joins&lt;/li&gt;
	&lt;li&gt;Support for non-equi join predicates in outer joins (at least one equi-join predicate is required)&lt;/li&gt;
	&lt;li&gt;Support for local predicates on the outer input of outer joins (at least one equi-join predicate is required)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Inner &amp;amp; Outer Joins: Evaluate all join predicates in a code-gen&apos;d function (also equi-join predicates) for correct handling of three-value logic&lt;/li&gt;
	&lt;li&gt;Outer joins: translate outer joins into a sequence of GroupReduce -&amp;gt; OuterJoin -&amp;gt; GroupReduce.&lt;/li&gt;
	&lt;li&gt;The first GroupReduce groups on the full input row and deduplicates the outer side(s) of the join. A count for the number of deduplicated rows is kept.&lt;/li&gt;
	&lt;li&gt;The OuterJoin evaluates the join predicate and computes possible join pairs of left and right rows. The non-outer element of the pair can be null if the join predicate does not match.&lt;/li&gt;
	&lt;li&gt;The second GroupReduce groups again on the full input row and computes for each outer row the join result. If it was not match with any inner row, it produces a null-padded result.&lt;/li&gt;
	&lt;li&gt;The plan for left and right outer joins requires only a single initial partitioning and sort of each input. The all operators can reuse the initial sort and produce a sorted result again. A full outer join requires an additional partitioning and sorting step.&lt;/li&gt;
	&lt;li&gt;Checks for outer join translation are removed to allow outer joins with non-equi and local predicates.&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;added ITCases for the new outer join features to `JoinITCase`&lt;/li&gt;
	&lt;li&gt;added plan tests for Table API and SQL for the new outer join features&lt;/li&gt;
	&lt;li&gt;updated validation tests&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The serializers: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): *&lt;b&gt;yes&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    The documentation does not need to be adjusted because the outer join limitation were not documented. &lt;/p&gt;


&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/fhueske/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/fhueske/flink&lt;/a&gt; tableBatchNullJoin&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4858&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 1434d8d7debe207e4b8350199eded4e678885571&lt;br/&gt;
Author: Fabian Hueske &amp;lt;fhueske@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-10-15T15:55:23Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7755&quot; title=&quot;Null values are not correctly handled by batch inner and outer joins&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7755&quot;&gt;&lt;del&gt;FLINK-7755&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;table&amp;#93;&lt;/span&gt; Fix NULL handling in batch joins.&lt;/p&gt;

&lt;p&gt;    Fixes &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5498&quot; title=&quot;Add support for left/right outer joins with non-equality predicates (and 1+ equality predicates)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5498&quot;&gt;&lt;del&gt;FLINK-5498&lt;/del&gt;&lt;/a&gt; (Add support for non-equi join and local predicates to outer joins) as well.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16212508" author="githubbot" created="Fri, 20 Oct 2017 11:37:44 +0000"  >&lt;p&gt;Github user xccui commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858#discussion_r145938669&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858#discussion_r145938669&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/plan/nodes/dataset/DataSetJoin.scala &amp;#8212;&lt;br/&gt;
    @@ -156,65 +163,394 @@ class DataSetJoin(&lt;br/&gt;
         val leftDataSet = left.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;DataSetRel&amp;#93;&lt;/span&gt;.translateToPlan(tableEnv)&lt;br/&gt;
         val rightDataSet = right.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;DataSetRel&amp;#93;&lt;/span&gt;.translateToPlan(tableEnv)&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val (joinOperator, nullCheck) = joinType match {&lt;/li&gt;
	&lt;li&gt;case JoinRelType.INNER =&amp;gt; (leftDataSet.join(rightDataSet), false)&lt;/li&gt;
	&lt;li&gt;case JoinRelType.LEFT =&amp;gt; (leftDataSet.leftOuterJoin(rightDataSet), true)&lt;/li&gt;
	&lt;li&gt;case JoinRelType.RIGHT =&amp;gt; (leftDataSet.rightOuterJoin(rightDataSet), true)&lt;/li&gt;
	&lt;li&gt;case JoinRelType.FULL =&amp;gt; (leftDataSet.fullOuterJoin(rightDataSet), true)&lt;br/&gt;
    +    joinType match 
{
    +      case JoinRelType.INNER =&amp;gt;
    +        addInnerJoin(
    +          leftDataSet,
    +          rightDataSet,
    +          leftKeys.toArray,
    +          rightKeys.toArray,
    +          returnType,
    +          config)
    +      case JoinRelType.LEFT =&amp;gt;
    +        addLeftOuterJoin(
    +          leftDataSet,
    +          rightDataSet,
    +          leftKeys.toArray,
    +          rightKeys.toArray,
    +          returnType,
    +          config)
    +      case JoinRelType.RIGHT =&amp;gt;
    +        addRightOuterJoin(
    +          leftDataSet,
    +          rightDataSet,
    +          leftKeys.toArray,
    +          rightKeys.toArray,
    +          returnType,
    +          config)
    +      case JoinRelType.FULL =&amp;gt;
    +        addFullOuterJoin(
    +          leftDataSet,
    +          rightDataSet,
    +          leftKeys.toArray,
    +          rightKeys.toArray,
    +          returnType,
    +          config)
         }
&lt;p&gt;    +  }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (nullCheck &amp;amp;&amp;amp; !config.getNullCheck) 
{
    -      throw TableException(&quot;Null check in TableConfig must be enabled for outer joins.&quot;)
    -    }
&lt;p&gt;    +  private def addInnerJoin(&lt;br/&gt;
    +      left: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      right: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      leftKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      rightKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      resultType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      config: TableConfig): DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         val generator = new FunctionCodeGenerator(&lt;br/&gt;
           config,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;nullCheck,&lt;/li&gt;
	&lt;li&gt;leftDataSet.getType,&lt;/li&gt;
	&lt;li&gt;Some(rightDataSet.getType))&lt;br/&gt;
    +      false,&lt;br/&gt;
    +      left.getType,&lt;br/&gt;
    +      Some(right.getType))&lt;br/&gt;
         val conversion = generator.generateConverterResultExpression(&lt;/li&gt;
	&lt;li&gt;returnType,&lt;br/&gt;
    +      resultType,&lt;br/&gt;
           joinRowType.getFieldNames)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;var body = &quot;&quot;&lt;br/&gt;
    +    val condition = generator.generateExpression(joinCondition)&lt;br/&gt;
    +    val body =&lt;br/&gt;
    +      s&quot;&quot;&quot;&lt;br/&gt;
    +         |${condition.code}&lt;br/&gt;
    +         |if (${condition.resultTerm}) {&lt;br/&gt;
    +         |  ${conversion.code}&lt;br/&gt;
    +         |  ${generator.collectorTerm}.collect(${conversion.resultTerm});&lt;br/&gt;
    +         |}&lt;br/&gt;
    +         |&quot;&quot;&quot;.stripMargin&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (joinInfo.isEqui) {&lt;/li&gt;
	&lt;li&gt;// only equality condition&lt;/li&gt;
	&lt;li&gt;body = s&quot;&quot;&quot;&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;${conversion.code}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;${generator.collectorTerm}.collect(${conversion.resultTerm});&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&quot;&quot;&quot;.stripMargin&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;val nonEquiPredicates = joinInfo.getRemaining(this.cluster.getRexBuilder)&lt;/li&gt;
	&lt;li&gt;val condition = generator.generateExpression(nonEquiPredicates)&lt;/li&gt;
	&lt;li&gt;body = s&quot;&quot;&quot;&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;${condition.code}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;if (${condition.resultTerm}) {&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  ${conversion.code}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  ${generator.collectorTerm}.collect(${conversion.resultTerm});&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&quot;&quot;&quot;.stripMargin&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
         val genFunction = generator.generateFunction(&lt;br/&gt;
           ruleDescription,&lt;br/&gt;
           classOf[FlatJoinFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;Row, Row, Row&amp;#93;&lt;/span&gt;],&lt;br/&gt;
           body,&lt;/li&gt;
	&lt;li&gt;returnType)&lt;br/&gt;
    +      resultType)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         val joinFun = new FlatJoinRunner&lt;span class=&quot;error&quot;&gt;&amp;#91;Row, Row, Row&amp;#93;&lt;/span&gt;(&lt;br/&gt;
           genFunction.name,&lt;br/&gt;
           genFunction.code,&lt;br/&gt;
           genFunction.returnType)&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val joinOpName =&lt;/li&gt;
	&lt;li&gt;s&quot;where: (${joinConditionToString(joinRowType, joinCondition, getExpressionString)}), &quot; +&lt;/li&gt;
	&lt;li&gt;s&quot;join: (${joinSelectionToString(joinRowType)})&quot;&lt;br/&gt;
    +    left.join(right)&lt;br/&gt;
    +      .where(leftKeys: _*)&lt;br/&gt;
    +      .equalTo(rightKeys: _*)&lt;br/&gt;
    +      .`with`(joinFun)&lt;br/&gt;
    +      .name(getJoinOpName)&lt;br/&gt;
    +  }&lt;br/&gt;
    +&lt;br/&gt;
    +  private def addLeftOuterJoin(&lt;br/&gt;
    +      left: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      right: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      leftKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      rightKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      resultType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      config: TableConfig): DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +&lt;br/&gt;
    +    if (!config.getNullCheck) 
{
    +      throw TableException(&quot;Null check in TableConfig must be enabled for outer joins.&quot;)
    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    val joinOpName = getJoinOpName&lt;br/&gt;
    +&lt;br/&gt;
    +    // replace field names by indexed names for easier key handling&lt;br/&gt;
    +    val leftType = new RowTypeInfo(left.getType.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;RowTypeInfo&amp;#93;&lt;/span&gt;.getFieldTypes: _*)&lt;br/&gt;
    +    val rightType = right.getType.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;RowTypeInfo&amp;#93;&lt;/span&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +    // partition and sort left input&lt;br/&gt;
    +    // this step ensures we can reuse the sorting for all following operations&lt;br/&gt;
    +    // (groupBy-&amp;gt;join-&amp;gt;groupBy)&lt;br/&gt;
    +    val partitionedSortedLeft: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = partitionAndSort(left, leftKeys)&lt;br/&gt;
    +&lt;br/&gt;
    +    // deduplicate the rows of the left input&lt;br/&gt;
    +    val deduplicatedRowsLeft: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = deduplicateRows(partitionedSortedLeft, leftType)&lt;br/&gt;
    +&lt;br/&gt;
    +    // create JoinFunction to evaluate join predicate&lt;br/&gt;
    +    val predFun = generatePredicateFunction(leftType, rightType, config)&lt;br/&gt;
    +    val joinOutType = new RowTypeInfo(leftType, rightType, Types.INT)&lt;br/&gt;
    +    val joinFun = new LeftOuterJoinRunner(predFun.name, predFun.code, joinOutType)&lt;br/&gt;
    +&lt;br/&gt;
    +    // join left and right inputs, evaluate join predicate, and emit join pairs&lt;br/&gt;
    +    val nestedLeftKeys = leftKeys.map(i =&amp;gt; s&quot;f0.f$i&quot;)&lt;br/&gt;
    +    val joinPairs = deduplicatedRowsLeft.leftOuterJoin(right, JoinHint.REPARTITION_SORT_MERGE)&lt;br/&gt;
    +      .where(nestedLeftKeys: _*)&lt;br/&gt;
    +      .equalTo(rightKeys: _*)&lt;br/&gt;
    +      .`with`(joinFun)&lt;br/&gt;
    +      .withForwardedFieldsFirst(&quot;f0-&amp;gt;f0&quot;)&lt;br/&gt;
    +      .name(joinOpName)&lt;br/&gt;
    +&lt;br/&gt;
    +    // create GroupReduceFunction to generate the join result&lt;br/&gt;
    +    val convFun = generateConversionFunction(leftType, rightType, resultType, config)&lt;br/&gt;
    +    val reduceFun = new LeftOuterJoinGroupReduceRunner(&lt;br/&gt;
    +      convFun.name,&lt;br/&gt;
    +      convFun.code,&lt;br/&gt;
    +      convFun.returnType)&lt;br/&gt;
    +&lt;br/&gt;
    +    // convert join pairs to result.&lt;br/&gt;
    +    // This step ensures we preserve the rows of the left input.&lt;br/&gt;
    +    joinPairs&lt;br/&gt;
    +      .groupBy(&quot;f0&quot;)&lt;br/&gt;
    +      .reduceGroup(reduceFun)&lt;br/&gt;
    +      .name(joinOpName)&lt;br/&gt;
    +      .returns(resultType)&lt;br/&gt;
    +  }&lt;br/&gt;
    +&lt;br/&gt;
    +  private def addRightOuterJoin(&lt;br/&gt;
    +      left: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      right: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      leftKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      rightKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      resultType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      config: TableConfig): DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +&lt;br/&gt;
    +    if (!config.getNullCheck) {    +      throw TableException(&quot;Null check in TableConfig must be enabled for outer joins.&quot;)    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    val joinOpName = getJoinOpName&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;joinOperator&lt;/li&gt;
	&lt;li&gt;.where(leftKeys.toArray: _*)&lt;/li&gt;
	&lt;li&gt;.equalTo(rightKeys.toArray: _*)&lt;br/&gt;
    +    // replace field names by indexed names for easier key handling&lt;br/&gt;
    +    val leftType = left.getType.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;RowTypeInfo&amp;#93;&lt;/span&gt;&lt;br/&gt;
    +    val rightType = new RowTypeInfo(right.getType.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;RowTypeInfo&amp;#93;&lt;/span&gt;.getFieldTypes: _*)&lt;br/&gt;
    +&lt;br/&gt;
    +    // partition and sort right input&lt;br/&gt;
    +    // this step ensures we can reuse the sorting for all following operations&lt;br/&gt;
    +    // (groupBy-&amp;gt;join-&amp;gt;groupBy)&lt;br/&gt;
    +    val partitionedSortedRight: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = partitionAndSort(right, rightKeys)&lt;br/&gt;
    +&lt;br/&gt;
    +    // deduplicate the rows of the right input&lt;br/&gt;
    +    val deduplicatedRowsRight: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = deduplicateRows(partitionedSortedRight, rightType)&lt;br/&gt;
    +&lt;br/&gt;
    +    // create JoinFunction to evaluate join predicate&lt;br/&gt;
    +    val predFun = generatePredicateFunction(leftType, rightType, config)&lt;br/&gt;
    +    val joinOutType = new RowTypeInfo(leftType, rightType, Types.INT)&lt;br/&gt;
    +    val joinFun = new RightOuterJoinRunner(predFun.name, predFun.code, joinOutType)&lt;br/&gt;
    +&lt;br/&gt;
    +    // join left and right inputs, evaluate join predicate, and emit join pairs&lt;br/&gt;
    +    val nestedRightKeys = rightKeys.map(i =&amp;gt; s&quot;f0.f$i&quot;)&lt;br/&gt;
    +    val joinPairs = left.rightOuterJoin(deduplicatedRowsRight, JoinHint.REPARTITION_SORT_MERGE)&lt;br/&gt;
    +      .where(leftKeys: _*)&lt;br/&gt;
    +      .equalTo(nestedRightKeys: _*)&lt;br/&gt;
           .`with`(joinFun)&lt;br/&gt;
    +      .withForwardedFieldsSecond(&quot;f0-&amp;gt;f1&quot;)&lt;br/&gt;
    +      .name(joinOpName)&lt;br/&gt;
    +&lt;br/&gt;
    +    // create GroupReduceFunction to generate the join result&lt;br/&gt;
    +    val convFun = generateConversionFunction(leftType, rightType, resultType, config)&lt;br/&gt;
    +    val reduceFun = new RightOuterJoinGroupReduceRunner(&lt;br/&gt;
    +      convFun.name,&lt;br/&gt;
    +      convFun.code,&lt;br/&gt;
    +      convFun.returnType)&lt;br/&gt;
    +&lt;br/&gt;
    +    // convert join pairs to result&lt;br/&gt;
    +    // This step ensures we preserve the rows of the right input.&lt;br/&gt;
    +    joinPairs&lt;br/&gt;
    +      .groupBy(&quot;f1&quot;)&lt;br/&gt;
    +      .reduceGroup(reduceFun)&lt;br/&gt;
           .name(joinOpName)&lt;br/&gt;
    +      .returns(resultType)&lt;br/&gt;
       }&lt;br/&gt;
    +&lt;br/&gt;
    +  private def addFullOuterJoin(&lt;br/&gt;
    +      left: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      right: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      leftKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      rightKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      resultType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      config: TableConfig): DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    +    if (!config.getNullCheck) {
    +      throw TableException(&quot;Null check in TableConfig must be enabled for outer joins.&quot;)
    +    }    +    +    val joinOpName = getJoinOpName    +    +    // replace field names by indexed names for easier key handling    +    val leftType = new RowTypeInfo(left.getType.asInstanceOf[RowTypeInfo].getFieldTypes}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +  private def getJoinOpName: String = {&lt;br/&gt;
    +    s&quot;where: (${joinConditionToString(joinRowType, joinCondition, getExpressionString)}), &quot; +&lt;br/&gt;
    +      s&quot;join: (${joinSelectionToString(joinRowType)})&quot;&lt;br/&gt;
    +  }&lt;br/&gt;
    +&lt;br/&gt;
    +  /** Returns an array of indicies with some indicies being a prefix. */&lt;br/&gt;
    +  private def getFullIndiciesWithPrefix(keys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;, numFields: Int): Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt; = &lt;/p&gt;
{
    +    // get indicies of all fields which are not keys
    +    val nonKeys = (0 until numFields).filter(i =&amp;gt; !keys.contains(i))
    +    // return all field indicies prefixed by keys
    +    keys ++ nonKeys
    +  }
&lt;p&gt;    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +    * Partitions the data set on the join keys and sort it on all field with the join keys being a&lt;br/&gt;
    +    * prefix.&lt;br/&gt;
    +    */&lt;br/&gt;
    +  private def partitionAndSort(&lt;br/&gt;
    +      dataSet: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      partitionKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;): DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    +    // construct full sort keys with partitionKeys being a prefix    +    val sortKeys = getFullIndiciesWithPrefix(partitionKeys, dataSet.getType.getArity)    +    // partition    +    val partitioned}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +    * Deduplicates the rows of a data set and emits a row for each unique row with with the first&lt;br/&gt;
    +    * field being the unique row and the second field being the number of duplicates of the row.&lt;br/&gt;
    +    */&lt;br/&gt;
    +  private def deduplicateRows(&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The function name is a little bit misleading. How about `foldIdenticalRows`?&lt;/p&gt;</comment>
                            <comment id="16212509" author="githubbot" created="Fri, 20 Oct 2017 11:37:44 +0000"  >&lt;p&gt;Github user xccui commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858#discussion_r145938918&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858#discussion_r145938918&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/plan/nodes/dataset/DataSetJoin.scala &amp;#8212;&lt;br/&gt;
    @@ -156,65 +163,394 @@ class DataSetJoin(&lt;br/&gt;
         val leftDataSet = left.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;DataSetRel&amp;#93;&lt;/span&gt;.translateToPlan(tableEnv)&lt;br/&gt;
         val rightDataSet = right.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;DataSetRel&amp;#93;&lt;/span&gt;.translateToPlan(tableEnv)&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val (joinOperator, nullCheck) = joinType match {&lt;/li&gt;
	&lt;li&gt;case JoinRelType.INNER =&amp;gt; (leftDataSet.join(rightDataSet), false)&lt;/li&gt;
	&lt;li&gt;case JoinRelType.LEFT =&amp;gt; (leftDataSet.leftOuterJoin(rightDataSet), true)&lt;/li&gt;
	&lt;li&gt;case JoinRelType.RIGHT =&amp;gt; (leftDataSet.rightOuterJoin(rightDataSet), true)&lt;/li&gt;
	&lt;li&gt;case JoinRelType.FULL =&amp;gt; (leftDataSet.fullOuterJoin(rightDataSet), true)&lt;br/&gt;
    +    joinType match 
{
    +      case JoinRelType.INNER =&amp;gt;
    +        addInnerJoin(
    +          leftDataSet,
    +          rightDataSet,
    +          leftKeys.toArray,
    +          rightKeys.toArray,
    +          returnType,
    +          config)
    +      case JoinRelType.LEFT =&amp;gt;
    +        addLeftOuterJoin(
    +          leftDataSet,
    +          rightDataSet,
    +          leftKeys.toArray,
    +          rightKeys.toArray,
    +          returnType,
    +          config)
    +      case JoinRelType.RIGHT =&amp;gt;
    +        addRightOuterJoin(
    +          leftDataSet,
    +          rightDataSet,
    +          leftKeys.toArray,
    +          rightKeys.toArray,
    +          returnType,
    +          config)
    +      case JoinRelType.FULL =&amp;gt;
    +        addFullOuterJoin(
    +          leftDataSet,
    +          rightDataSet,
    +          leftKeys.toArray,
    +          rightKeys.toArray,
    +          returnType,
    +          config)
         }
&lt;p&gt;    +  }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (nullCheck &amp;amp;&amp;amp; !config.getNullCheck) 
{
    -      throw TableException(&quot;Null check in TableConfig must be enabled for outer joins.&quot;)
    -    }
&lt;p&gt;    +  private def addInnerJoin(&lt;br/&gt;
    +      left: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      right: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      leftKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      rightKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      resultType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      config: TableConfig): DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         val generator = new FunctionCodeGenerator(&lt;br/&gt;
           config,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;nullCheck,&lt;/li&gt;
	&lt;li&gt;leftDataSet.getType,&lt;/li&gt;
	&lt;li&gt;Some(rightDataSet.getType))&lt;br/&gt;
    +      false,&lt;br/&gt;
    +      left.getType,&lt;br/&gt;
    +      Some(right.getType))&lt;br/&gt;
         val conversion = generator.generateConverterResultExpression(&lt;/li&gt;
	&lt;li&gt;returnType,&lt;br/&gt;
    +      resultType,&lt;br/&gt;
           joinRowType.getFieldNames)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;var body = &quot;&quot;&lt;br/&gt;
    +    val condition = generator.generateExpression(joinCondition)&lt;br/&gt;
    +    val body =&lt;br/&gt;
    +      s&quot;&quot;&quot;&lt;br/&gt;
    +         |${condition.code}&lt;br/&gt;
    +         |if (${condition.resultTerm}) {&lt;br/&gt;
    +         |  ${conversion.code}&lt;br/&gt;
    +         |  ${generator.collectorTerm}.collect(${conversion.resultTerm});&lt;br/&gt;
    +         |}&lt;br/&gt;
    +         |&quot;&quot;&quot;.stripMargin&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (joinInfo.isEqui) {&lt;/li&gt;
	&lt;li&gt;// only equality condition&lt;/li&gt;
	&lt;li&gt;body = s&quot;&quot;&quot;&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;${conversion.code}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;${generator.collectorTerm}.collect(${conversion.resultTerm});&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&quot;&quot;&quot;.stripMargin&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;val nonEquiPredicates = joinInfo.getRemaining(this.cluster.getRexBuilder)&lt;/li&gt;
	&lt;li&gt;val condition = generator.generateExpression(nonEquiPredicates)&lt;/li&gt;
	&lt;li&gt;body = s&quot;&quot;&quot;&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;${condition.code}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;if (${condition.resultTerm}) {&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  ${conversion.code}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  ${generator.collectorTerm}.collect(${conversion.resultTerm});&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&quot;&quot;&quot;.stripMargin&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
         val genFunction = generator.generateFunction(&lt;br/&gt;
           ruleDescription,&lt;br/&gt;
           classOf[FlatJoinFunction&lt;span class=&quot;error&quot;&gt;&amp;#91;Row, Row, Row&amp;#93;&lt;/span&gt;],&lt;br/&gt;
           body,&lt;/li&gt;
	&lt;li&gt;returnType)&lt;br/&gt;
    +      resultType)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         val joinFun = new FlatJoinRunner&lt;span class=&quot;error&quot;&gt;&amp;#91;Row, Row, Row&amp;#93;&lt;/span&gt;(&lt;br/&gt;
           genFunction.name,&lt;br/&gt;
           genFunction.code,&lt;br/&gt;
           genFunction.returnType)&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val joinOpName =&lt;/li&gt;
	&lt;li&gt;s&quot;where: (${joinConditionToString(joinRowType, joinCondition, getExpressionString)}), &quot; +&lt;/li&gt;
	&lt;li&gt;s&quot;join: (${joinSelectionToString(joinRowType)})&quot;&lt;br/&gt;
    +    left.join(right)&lt;br/&gt;
    +      .where(leftKeys: _*)&lt;br/&gt;
    +      .equalTo(rightKeys: _*)&lt;br/&gt;
    +      .`with`(joinFun)&lt;br/&gt;
    +      .name(getJoinOpName)&lt;br/&gt;
    +  }&lt;br/&gt;
    +&lt;br/&gt;
    +  private def addLeftOuterJoin(&lt;br/&gt;
    +      left: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      right: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      leftKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      rightKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      resultType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      config: TableConfig): DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +&lt;br/&gt;
    +    if (!config.getNullCheck) 
{
    +      throw TableException(&quot;Null check in TableConfig must be enabled for outer joins.&quot;)
    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    val joinOpName = getJoinOpName&lt;br/&gt;
    +&lt;br/&gt;
    +    // replace field names by indexed names for easier key handling&lt;br/&gt;
    +    val leftType = new RowTypeInfo(left.getType.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;RowTypeInfo&amp;#93;&lt;/span&gt;.getFieldTypes: _*)&lt;br/&gt;
    +    val rightType = right.getType.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;RowTypeInfo&amp;#93;&lt;/span&gt;&lt;br/&gt;
    +&lt;br/&gt;
    +    // partition and sort left input&lt;br/&gt;
    +    // this step ensures we can reuse the sorting for all following operations&lt;br/&gt;
    +    // (groupBy-&amp;gt;join-&amp;gt;groupBy)&lt;br/&gt;
    +    val partitionedSortedLeft: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = partitionAndSort(left, leftKeys)&lt;br/&gt;
    +&lt;br/&gt;
    +    // deduplicate the rows of the left input&lt;br/&gt;
    +    val deduplicatedRowsLeft: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = deduplicateRows(partitionedSortedLeft, leftType)&lt;br/&gt;
    +&lt;br/&gt;
    +    // create JoinFunction to evaluate join predicate&lt;br/&gt;
    +    val predFun = generatePredicateFunction(leftType, rightType, config)&lt;br/&gt;
    +    val joinOutType = new RowTypeInfo(leftType, rightType, Types.INT)&lt;br/&gt;
    +    val joinFun = new LeftOuterJoinRunner(predFun.name, predFun.code, joinOutType)&lt;br/&gt;
    +&lt;br/&gt;
    +    // join left and right inputs, evaluate join predicate, and emit join pairs&lt;br/&gt;
    +    val nestedLeftKeys = leftKeys.map(i =&amp;gt; s&quot;f0.f$i&quot;)&lt;br/&gt;
    +    val joinPairs = deduplicatedRowsLeft.leftOuterJoin(right, JoinHint.REPARTITION_SORT_MERGE)&lt;br/&gt;
    +      .where(nestedLeftKeys: _*)&lt;br/&gt;
    +      .equalTo(rightKeys: _*)&lt;br/&gt;
    +      .`with`(joinFun)&lt;br/&gt;
    +      .withForwardedFieldsFirst(&quot;f0-&amp;gt;f0&quot;)&lt;br/&gt;
    +      .name(joinOpName)&lt;br/&gt;
    +&lt;br/&gt;
    +    // create GroupReduceFunction to generate the join result&lt;br/&gt;
    +    val convFun = generateConversionFunction(leftType, rightType, resultType, config)&lt;br/&gt;
    +    val reduceFun = new LeftOuterJoinGroupReduceRunner(&lt;br/&gt;
    +      convFun.name,&lt;br/&gt;
    +      convFun.code,&lt;br/&gt;
    +      convFun.returnType)&lt;br/&gt;
    +&lt;br/&gt;
    +    // convert join pairs to result.&lt;br/&gt;
    +    // This step ensures we preserve the rows of the left input.&lt;br/&gt;
    +    joinPairs&lt;br/&gt;
    +      .groupBy(&quot;f0&quot;)&lt;br/&gt;
    +      .reduceGroup(reduceFun)&lt;br/&gt;
    +      .name(joinOpName)&lt;br/&gt;
    +      .returns(resultType)&lt;br/&gt;
    +  }&lt;br/&gt;
    +&lt;br/&gt;
    +  private def addRightOuterJoin(&lt;br/&gt;
    +      left: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      right: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      leftKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      rightKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      resultType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      config: TableConfig): DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +&lt;br/&gt;
    +    if (!config.getNullCheck) {    +      throw TableException(&quot;Null check in TableConfig must be enabled for outer joins.&quot;)    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    val joinOpName = getJoinOpName&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;joinOperator&lt;/li&gt;
	&lt;li&gt;.where(leftKeys.toArray: _*)&lt;/li&gt;
	&lt;li&gt;.equalTo(rightKeys.toArray: _*)&lt;br/&gt;
    +    // replace field names by indexed names for easier key handling&lt;br/&gt;
    +    val leftType = left.getType.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;RowTypeInfo&amp;#93;&lt;/span&gt;&lt;br/&gt;
    +    val rightType = new RowTypeInfo(right.getType.asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;RowTypeInfo&amp;#93;&lt;/span&gt;.getFieldTypes: _*)&lt;br/&gt;
    +&lt;br/&gt;
    +    // partition and sort right input&lt;br/&gt;
    +    // this step ensures we can reuse the sorting for all following operations&lt;br/&gt;
    +    // (groupBy-&amp;gt;join-&amp;gt;groupBy)&lt;br/&gt;
    +    val partitionedSortedRight: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = partitionAndSort(right, rightKeys)&lt;br/&gt;
    +&lt;br/&gt;
    +    // deduplicate the rows of the right input&lt;br/&gt;
    +    val deduplicatedRowsRight: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = deduplicateRows(partitionedSortedRight, rightType)&lt;br/&gt;
    +&lt;br/&gt;
    +    // create JoinFunction to evaluate join predicate&lt;br/&gt;
    +    val predFun = generatePredicateFunction(leftType, rightType, config)&lt;br/&gt;
    +    val joinOutType = new RowTypeInfo(leftType, rightType, Types.INT)&lt;br/&gt;
    +    val joinFun = new RightOuterJoinRunner(predFun.name, predFun.code, joinOutType)&lt;br/&gt;
    +&lt;br/&gt;
    +    // join left and right inputs, evaluate join predicate, and emit join pairs&lt;br/&gt;
    +    val nestedRightKeys = rightKeys.map(i =&amp;gt; s&quot;f0.f$i&quot;)&lt;br/&gt;
    +    val joinPairs = left.rightOuterJoin(deduplicatedRowsRight, JoinHint.REPARTITION_SORT_MERGE)&lt;br/&gt;
    +      .where(leftKeys: _*)&lt;br/&gt;
    +      .equalTo(nestedRightKeys: _*)&lt;br/&gt;
           .`with`(joinFun)&lt;br/&gt;
    +      .withForwardedFieldsSecond(&quot;f0-&amp;gt;f1&quot;)&lt;br/&gt;
    +      .name(joinOpName)&lt;br/&gt;
    +&lt;br/&gt;
    +    // create GroupReduceFunction to generate the join result&lt;br/&gt;
    +    val convFun = generateConversionFunction(leftType, rightType, resultType, config)&lt;br/&gt;
    +    val reduceFun = new RightOuterJoinGroupReduceRunner(&lt;br/&gt;
    +      convFun.name,&lt;br/&gt;
    +      convFun.code,&lt;br/&gt;
    +      convFun.returnType)&lt;br/&gt;
    +&lt;br/&gt;
    +    // convert join pairs to result&lt;br/&gt;
    +    // This step ensures we preserve the rows of the right input.&lt;br/&gt;
    +    joinPairs&lt;br/&gt;
    +      .groupBy(&quot;f1&quot;)&lt;br/&gt;
    +      .reduceGroup(reduceFun)&lt;br/&gt;
           .name(joinOpName)&lt;br/&gt;
    +      .returns(resultType)&lt;br/&gt;
       }&lt;br/&gt;
    +&lt;br/&gt;
    +  private def addFullOuterJoin(&lt;br/&gt;
    +      left: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      right: DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      leftKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      rightKeys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      resultType: TypeInformation&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt;,&lt;br/&gt;
    +      config: TableConfig): DataSet&lt;span class=&quot;error&quot;&gt;&amp;#91;Row&amp;#93;&lt;/span&gt; = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +    +    if (!config.getNullCheck) {
    +      throw TableException(&quot;Null check in TableConfig must be enabled for outer joins.&quot;)
    +    }    +    +    val joinOpName = getJoinOpName    +    +    // replace field names by indexed names for easier key handling    +    val leftType = new RowTypeInfo(left.getType.asInstanceOf[RowTypeInfo].getFieldTypes}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +&lt;br/&gt;
    +  private def getJoinOpName: String = {&lt;br/&gt;
    +    s&quot;where: (${joinConditionToString(joinRowType, joinCondition, getExpressionString)}), &quot; +&lt;br/&gt;
    +      s&quot;join: (${joinSelectionToString(joinRowType)})&quot;&lt;br/&gt;
    +  }&lt;br/&gt;
    +&lt;br/&gt;
    +  /** Returns an array of indicies with some indicies being a prefix. */&lt;br/&gt;
    +  private def getFullIndiciesWithPrefix(keys: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;, numFields: Int): Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
    +    // get indicies of all fields which are not keys&lt;br/&gt;
    +    val nonKeys = (0 until numFields).filter(i =&amp;gt; !keys.contains&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;)&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Could be simplified with &apos;_&apos;.&lt;/p&gt;</comment>
                            <comment id="16212510" author="githubbot" created="Fri, 20 Oct 2017 11:37:44 +0000"  >&lt;p&gt;Github user xccui commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858#discussion_r145863708&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858#discussion_r145863708&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/plan/rules/dataSet/DataSetJoinRule.scala &amp;#8212;&lt;br/&gt;
    @@ -41,8 +41,7 @@ class DataSetJoinRule&lt;br/&gt;
         val joinInfo = join.analyzeCondition&lt;/p&gt;

&lt;p&gt;         // joins require an equi-condition or a conjunctive predicate with at least one equi-condition&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// and disable outer joins with non-equality predicates(see &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5520&quot; title=&quot;Disable outer joins with non-equality predicates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5520&quot;&gt;&lt;del&gt;FLINK-5520&lt;/del&gt;&lt;/a&gt;)&lt;/li&gt;
	&lt;li&gt;!joinInfo.pairs().isEmpty &amp;amp;&amp;amp; (joinInfo.isEqui || join.getJoinType == JoinRelType.INNER)&lt;br/&gt;
    +    !joinInfo.pairs().isEmpty
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The condition is checked three times in `FlinkLogicalJoin`, `DataSetJoinRule`, and `DataSetJoin`. It brings extra maintenance work every time we change the validation rule. &lt;/p&gt;</comment>
                            <comment id="16212511" author="githubbot" created="Fri, 20 Oct 2017 11:37:44 +0000"  >&lt;p&gt;Github user xccui commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858#discussion_r145863086&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858#discussion_r145863086&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/plan/nodes/logical/FlinkLogicalJoin.scala &amp;#8212;&lt;br/&gt;
    @@ -97,8 +97,7 @@ private class FlinkLogicalJoinConverter&lt;/p&gt;

&lt;p&gt;       private def hasEqualityPredicates(join: LogicalJoin, joinInfo: JoinInfo): Boolean = {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    The parameter `join` seems to be useless now.&lt;/p&gt;</comment>
                            <comment id="16213322" author="githubbot" created="Fri, 20 Oct 2017 22:03:56 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858#discussion_r146076115&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858#discussion_r146076115&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/plan/rules/dataSet/DataSetJoinRule.scala &amp;#8212;&lt;br/&gt;
    @@ -41,8 +41,7 @@ class DataSetJoinRule&lt;br/&gt;
         val joinInfo = join.analyzeCondition&lt;/p&gt;

&lt;p&gt;         // joins require an equi-condition or a conjunctive predicate with at least one equi-condition&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// and disable outer joins with non-equality predicates(see &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5520&quot; title=&quot;Disable outer joins with non-equality predicates&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5520&quot;&gt;&lt;del&gt;FLINK-5520&lt;/del&gt;&lt;/a&gt;)&lt;/li&gt;
	&lt;li&gt;!joinInfo.pairs().isEmpty &amp;amp;&amp;amp; (joinInfo.isEqui || join.getJoinType == JoinRelType.INNER)&lt;br/&gt;
    +    !joinInfo.pairs().isEmpty
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Yes, that is true but the rule are also applied in different contexts. `FlinkLogicalJoin` is used for the initial translation of batch and stream programs and `DataSetJoinRule` only for batch. I think it&apos;s OK to have these checks as safety net.&lt;/p&gt;</comment>
                            <comment id="16213326" author="githubbot" created="Fri, 20 Oct 2017 22:04:58 +0000"  >&lt;p&gt;Github user fhueske commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for the review @xccui! &lt;br/&gt;
    I&apos;ve updated the PR.&lt;br/&gt;
    Cheers, Fabian&lt;/p&gt;</comment>
                            <comment id="16215811" author="githubbot" created="Mon, 23 Oct 2017 20:50:30 +0000"  >&lt;p&gt;Github user fhueske commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I&apos;ll merge the PR in the next days.&lt;/p&gt;</comment>
                            <comment id="16216522" author="githubbot" created="Tue, 24 Oct 2017 08:30:12 +0000"  >&lt;p&gt;Github user twalthr commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I scanned through the code quickly and could not find any major issues. Well documented, well tested. +1 to merge this. Please don&apos;t fotget to update the docs.&lt;/p&gt;</comment>
                            <comment id="16216789" author="githubbot" created="Tue, 24 Oct 2017 12:15:17 +0000"  >&lt;p&gt;Github user fhueske commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for the review @twalthr. &lt;br/&gt;
    The docs don&apos;t need to be touched. The previous restrictions were not documented...&lt;/p&gt;

&lt;p&gt;    Will merge this PR.&lt;/p&gt;</comment>
                            <comment id="16216983" author="githubbot" created="Tue, 24 Oct 2017 14:22:01 +0000"  >&lt;p&gt;Github user lincoln-lil commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858#discussion_r146504940&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858#discussion_r146504940&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/plan/logical/operators.scala &amp;#8212;&lt;br/&gt;
    @@ -486,11 +486,6 @@ case class Join(&lt;br/&gt;
             s&quot;Invalid join condition: $expression. At least one equi-join predicate is &quot; +&lt;br/&gt;
               s&quot;required.&quot;)&lt;br/&gt;
         }&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (joinType != JoinType.INNER &amp;amp;&amp;amp; (nonEquiJoinPredicateFound || localPredicateFound)) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Local variable `nonEquiJoinPredicateFound` and `localPredicateFound` can be removed here,  and  `checkIfFilterCondition` method is no longer needed&lt;/p&gt;</comment>
                            <comment id="16217073" author="githubbot" created="Tue, 24 Oct 2017 15:07:03 +0000"  >&lt;p&gt;Github user fhueske commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858#discussion_r146591835&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858#discussion_r146591835&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-libraries/flink-table/src/main/scala/org/apache/flink/table/plan/logical/operators.scala &amp;#8212;&lt;br/&gt;
    @@ -486,11 +486,6 @@ case class Join(&lt;br/&gt;
             s&quot;Invalid join condition: $expression. At least one equi-join predicate is &quot; +&lt;br/&gt;
               s&quot;required.&quot;)&lt;br/&gt;
         }&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (joinType != JoinType.INNER &amp;amp;&amp;amp; (nonEquiJoinPredicateFound || localPredicateFound)) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Good point. Will remove that. Thanks @lincoln-lil!&lt;/p&gt;</comment>
                            <comment id="16217408" author="githubbot" created="Tue, 24 Oct 2017 18:30:37 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4858&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4858&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16217419" author="fhueske" created="Tue, 24 Oct 2017 18:34:07 +0000"  >&lt;p&gt;Fixed in 1.4.0 with 2a6381553e48e0145655c0aadd173813de610aa7&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 4 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3ksn3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>