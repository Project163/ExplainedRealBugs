<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:30:30 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-7623] Detecting whether an operator is restored doesn&apos;t work with chained state</title>
                <link>https://issues.apache.org/jira/browse/FLINK-7623</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;Originally reported on the ML: &lt;a href=&quot;https://lists.apache.org/thread.html/22a2cf83de3107aa81a03a921325a191c29df8aa8676798fcd497199@%3Cuser.flink.apache.org%3E&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://lists.apache.org/thread.html/22a2cf83de3107aa81a03a921325a191c29df8aa8676798fcd497199@%3Cuser.flink.apache.org%3E&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If we have a chain of operators where multiple of them have operator state, detection of the &lt;tt&gt;context.isRestored()&lt;/tt&gt; flag (of &lt;tt&gt;CheckpointedFunction&lt;/tt&gt;) does not work correctly. It&apos;s best exemplified using this minimal example where both the source and the flatMap have state:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

env
		.addSource(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MaSource()).uid(&lt;span class=&quot;code-quote&quot;&gt;&quot;source-1&quot;&lt;/span&gt;)
		.flatMap(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MaFlatMap()).uid(&lt;span class=&quot;code-quote&quot;&gt;&quot;flatMap-1&quot;&lt;/span&gt;);

env.execute(&lt;span class=&quot;code-quote&quot;&gt;&quot;testing&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If I do a savepoint with these UIDs, then change &quot;source-1&quot; to &quot;source-2&quot; and restore from the savepoint &lt;tt&gt;context.isRestored()&lt;/tt&gt; still reports &lt;tt&gt;true&lt;/tt&gt; for the source.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13102237">FLINK-7623</key>
            <summary>Detecting whether an operator is restored doesn&apos;t work with chained state</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="pnowojski">Piotr Nowojski</assignee>
                                    <reporter username="aljoscha">Aljoscha Krettek</reporter>
                        <labels>
                    </labels>
                <created>Thu, 14 Sep 2017 12:43:39 +0000</created>
                <updated>Tue, 24 Oct 2017 14:28:12 +0000</updated>
                            <resolved>Tue, 24 Oct 2017 14:15:31 +0000</resolved>
                                    <version>1.3.2</version>
                    <version>1.4.0</version>
                                    <fixVersion>1.4.0</fixVersion>
                                    <component>API / DataStream</component>
                    <component>Runtime / State Backends</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                                                                <comments>
                            <comment id="16166190" author="aljoscha" created="Thu, 14 Sep 2017 12:44:47 +0000"  >&lt;p&gt;Attached example code.&lt;/p&gt;</comment>
                            <comment id="16169987" author="zentol" created="Mon, 18 Sep 2017 13:10:38 +0000"  >&lt;p&gt;The culprit is this bit in the AbstractStreamOperator:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; void initializeState(OperatorSubtaskState stateHandles) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
	...
	&lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; restoring = (&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; != stateHandles);
	...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Instead this should be &lt;tt&gt;boolean restoring = stateHandles.hasState()&lt;/tt&gt;;&lt;/p&gt;</comment>
                            <comment id="16174974" author="aljoscha" created="Thu, 21 Sep 2017 15:45:06 +0000"  >&lt;p&gt;I think that would be incorrect, because then it would also report &quot;not restored&quot; in case the operator had no state assigned but (globally) was still restored, i.e. some other parallel instances of this operator might have state.&lt;/p&gt;</comment>
                            <comment id="16205605" author="pnowojski" created="Mon, 16 Oct 2017 09:14:18 +0000"  >&lt;p&gt;I will take a look at this in this or the following week. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=aljoscha&quot; class=&quot;user-hover&quot; rel=&quot;aljoscha&quot;&gt;aljoscha&lt;/a&gt; could you confirm that this is a release blocker?&lt;/p&gt;</comment>
                            <comment id="16205634" author="aljoscha" created="Mon, 16 Oct 2017 09:45:39 +0000"  >&lt;p&gt;Yes, it&apos;s a blocker.&lt;/p&gt;</comment>
                            <comment id="16209537" author="githubbot" created="Wed, 18 Oct 2017 15:30:39 +0000"  >&lt;p&gt;GitHub user pnowojski opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7623&quot; title=&quot;Detecting whether an operator is restored doesn&amp;#39;t work with chained state&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7623&quot;&gt;&lt;del&gt;FLINK-7623&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;tests&amp;#93;&lt;/span&gt; Add tests to make sure operator is never restored when using new operator id&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This PR adds tests coverage for correct behaviour of `ManagedInitializationContext#isRestored` flag - if application is restarted and a some operator has a new `uid`, it should return false. This bug was fixed by #4353. &lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    Please check commit messages for change log&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This PR adds `RestoreStreamTaskTest` and is not changing any productional code.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/pnowojski/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/pnowojski/flink&lt;/a&gt; f7623&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4851&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit a99d384fcd5b021b71dc703d0e9e8063bd72f89e&lt;br/&gt;
Author: Piotr Nowojski &amp;lt;piotr.nowojski@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-10-18T13:02:02Z&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;hotfix&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;streaming&amp;#93;&lt;/span&gt; Fix formatting in OperatorChain&lt;/p&gt;

&lt;p&gt;commit 5a2972d5f02521166c70ad68ad3fac0df9fad2e8&lt;br/&gt;
Author: Piotr Nowojski &amp;lt;piotr.nowojski@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-10-18T14:01:38Z&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;hotfix&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;tests&amp;#93;&lt;/span&gt; Add easier way to chain operator in StreamTaskTestHarness&lt;/p&gt;

&lt;p&gt;commit 26cabd7762458633be891b746d06595a873033b4&lt;br/&gt;
Author: Piotr Nowojski &amp;lt;piotr.nowojski@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-10-18T15:18:19Z&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;hotfix&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;tests&amp;#93;&lt;/span&gt; Extract AcknowledgeStreamMockEnvironment&lt;/p&gt;

&lt;p&gt;commit 2d6b45a55b8c63df4635a2d5506eab4b5ab590c3&lt;br/&gt;
Author: Piotr Nowojski &amp;lt;piotr.nowojski@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-10-18T13:01:37Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7623&quot; title=&quot;Detecting whether an operator is restored doesn&amp;#39;t work with chained state&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-7623&quot;&gt;&lt;del&gt;FLINK-7623&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;tests&amp;#93;&lt;/span&gt; Add tests to make sure operator is never restored when using new operator id&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16209552" author="pnowojski" created="Wed, 18 Oct 2017 15:43:02 +0000"  >&lt;p&gt;It seems like indeed this bug was fixed in &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-7213&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-7213&lt;/a&gt;. However I would like to test if &lt;tt&gt;isRestore()&lt;/tt&gt; works correctly in case of scaling up.&lt;/p&gt;</comment>
                            <comment id="16210951" author="pnowojski" created="Thu, 19 Oct 2017 12:40:11 +0000"  >&lt;p&gt;As &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=srichter&quot; class=&quot;user-hover&quot; rel=&quot;srichter&quot;&gt;srichter&lt;/a&gt; suggested I have checked for couple of more cases and current (&lt;tt&gt;1.4-SNAPSHOT&lt;/tt&gt;) behaviour is as follows:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Operator participated in checkpoint, data written -&amp;gt; &lt;tt&gt;isRestored == true&lt;/tt&gt;&lt;/li&gt;
	&lt;li&gt;Operator participated in checkpoint, but did not receive state after rescaling -&amp;gt; &lt;tt&gt;isRestored == true&lt;/tt&gt;&lt;/li&gt;
	&lt;li&gt;Operator participated in checkpoint, nothing checkpointed -&amp;gt; &lt;tt&gt;isRestored == true&lt;/tt&gt;&lt;/li&gt;
	&lt;li&gt;Operator never participated in checkpoint, or has a new uid -&amp;gt; &lt;tt&gt;isRestored == false&lt;/tt&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;EDIT: fixed one mistake - for case when nothing was checkpointed &lt;tt&gt;isRestore()&lt;/tt&gt; returns true at the moment.&lt;/p&gt;</comment>
                            <comment id="16212145" author="githubbot" created="Fri, 20 Oct 2017 04:37:56 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145877337&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145877337&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AcknowledgeStreamMockEnvironment.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,65 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.core.testutils.OneShotLatch;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetrics;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Stream environment that allows to wait for checkpoint acknowledgement.&lt;br/&gt;
    + */&lt;br/&gt;
    +class AcknowledgeStreamMockEnvironment extends StreamMockEnvironment {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I did a similar refactoring in one of my pending PRs, but it&apos;s ok because that one will probably not make it into 1.4. What I would still suggest, if you search for subclasses of `StreamMockEnvironment`, there are still more cases (some as anonymous classes) that could be replaced by a proper dummy like this.&lt;/p&gt;</comment>
                            <comment id="16212153" author="githubbot" created="Fri, 20 Oct 2017 04:46:37 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145877847&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145877847&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(4242L, 4242L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally {&lt;br/&gt;
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Maybe just a matter of personal taste, but wouldn&apos;t it be easier to simply reset the count to 0 at the beginning of each test or even have a setup method (or tearDown if you prefer to reset after the test) for that?&lt;/p&gt;</comment>
                            <comment id="16212155" author="githubbot" created="Fri, 20 Oct 2017 04:48:58 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145877990&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145877990&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(4242L, 4242L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}&lt;br/&gt;
    +		finally {    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreAfterScaleUp() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		// test empty state in case of scale up&lt;br/&gt;
    +		OperatorSubtaskState emptyHeadOperatorState = StateAssignmentOperation.operatorSubtaskStateFrom(&lt;br/&gt;
    +			new OperatorInstanceID(0, headOperatorID),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +		stateHandles.putSubtaskStateByOperatorID(headOperatorID, emptyHeadOperatorState);&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				headOperatorID,
    +				new RestoreCounterOperator(),
    +				tailOperatorID,
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithoutState() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new StatelessRestoreCounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				headOperatorID,
    +				new StatelessRestoreCounterOperator(),
    +				tailOperatorID,
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(1, StatelessRestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			StatelessRestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private AcknowledgeStreamMockEnvironment processRecords(&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Found the name of this method pretty confusing. I think it does a lot more than processing records, so maybe it is clearer if you break it down into multiple methods and give the top-level method a different name?&lt;/p&gt;</comment>
                            <comment id="16212158" author="githubbot" created="Fri, 20 Oct 2017 04:51:45 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145878181&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145878181&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(4242L, 4242L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}&lt;br/&gt;
    +		finally {    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreAfterScaleUp() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		// test empty state in case of scale up&lt;br/&gt;
    +		OperatorSubtaskState emptyHeadOperatorState = StateAssignmentOperation.operatorSubtaskStateFrom(&lt;br/&gt;
    +			new OperatorInstanceID(0, headOperatorID),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +		stateHandles.putSubtaskStateByOperatorID(headOperatorID, emptyHeadOperatorState);&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				headOperatorID,
    +				new RestoreCounterOperator(),
    +				tailOperatorID,
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithoutState() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new StatelessRestoreCounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(&lt;br/&gt;
    +				headOperatorID,&lt;br/&gt;
    +				new StatelessRestoreCounterOperator(),&lt;br/&gt;
    +				tailOperatorID,&lt;br/&gt;
    +				new RestoreCounterOperator(),&lt;br/&gt;
    +				Optional.of(stateHandles));&lt;br/&gt;
    +&lt;br/&gt;
    +			assertEquals(1, StatelessRestoreCounterOperator.RESTORE_COUNTER.get());&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    In theory, this could mean the exact opposite from the expected result because we don&apos;t know for which operator the `isRestored` was counted as `true` and for which as `false`.&lt;/p&gt;</comment>
                            <comment id="16212163" author="githubbot" created="Fri, 20 Oct 2017 04:55:35 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145878457&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145878457&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(4242L, 4242L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}&lt;br/&gt;
    +		finally {    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreAfterScaleUp() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		// test empty state in case of scale up&lt;br/&gt;
    +		OperatorSubtaskState emptyHeadOperatorState = StateAssignmentOperation.operatorSubtaskStateFrom(&lt;br/&gt;
    +			new OperatorInstanceID(0, headOperatorID),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +		stateHandles.putSubtaskStateByOperatorID(headOperatorID, emptyHeadOperatorState);&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				headOperatorID,
    +				new RestoreCounterOperator(),
    +				tailOperatorID,
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithoutState() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new StatelessRestoreCounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(&lt;br/&gt;
    +				headOperatorID,&lt;br/&gt;
    +				new StatelessRestoreCounterOperator(),&lt;br/&gt;
    +				tailOperatorID,&lt;br/&gt;
    +				new RestoreCounterOperator(),&lt;br/&gt;
    +				Optional.of(stateHandles));&lt;br/&gt;
    +&lt;br/&gt;
    +			assertEquals(1, StatelessRestoreCounterOperator.RESTORE_COUNTER.get());&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Couldn&apos;t this also be interpreted in the exact opposite way because we don&apos;t validate for which of the two operators we counted `isRestored == true`?&lt;/p&gt;</comment>
                            <comment id="16212165" author="githubbot" created="Fri, 20 Oct 2017 04:58:15 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145878649&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145878649&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(&lt;br/&gt;
    +				new OperatorID(4242L, 4242L),&lt;br/&gt;
    +				new RestoreCounterOperator(),&lt;br/&gt;
    +				new OperatorID(44L, 44L),&lt;br/&gt;
    +				new RestoreCounterOperator(),&lt;br/&gt;
    +				Optional.of(stateHandles));&lt;br/&gt;
    +&lt;br/&gt;
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Couldn&apos;t this also be interpreted in the exact opposite way because we don&apos;t validate for which of the two operators we counted `isRestored == true`? This be correct in connection with the other tests in this class, but i think the invariant is not completely clear from only this test and it is not fully self-contained.&lt;/p&gt;</comment>
                            <comment id="16212174" author="githubbot" created="Fri, 20 Oct 2017 05:14:44 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145879772&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145879772&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(4242L, 4242L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}&lt;br/&gt;
    +		finally {    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreAfterScaleUp() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		// test empty state in case of scale up&lt;br/&gt;
    +		OperatorSubtaskState emptyHeadOperatorState = StateAssignmentOperation.operatorSubtaskStateFrom(&lt;br/&gt;
    +			new OperatorInstanceID(0, headOperatorID),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +		stateHandles.putSubtaskStateByOperatorID(headOperatorID, emptyHeadOperatorState);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    One point that this test will not catch is when the behaviour of the state assignment changes or something else is used instead, e.g. producing a `null` instead of an empty `OperatorSubtaskState` and this will influence the result. I am aware that covering this probably means having an IT case or covering this with another unit test - so do you think it is worth having to also guard against this kind of code modifications?&lt;/p&gt;</comment>
                            <comment id="16212175" author="githubbot" created="Fri, 20 Oct 2017 05:15:55 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145879846&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145879846&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(4242L, 4242L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}&lt;br/&gt;
    +		finally {    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreAfterScaleUp() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		// test empty state in case of scale up&lt;br/&gt;
    +		OperatorSubtaskState emptyHeadOperatorState = StateAssignmentOperation.operatorSubtaskStateFrom(&lt;br/&gt;
    +			new OperatorInstanceID(0, headOperatorID),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +		stateHandles.putSubtaskStateByOperatorID(headOperatorID, emptyHeadOperatorState);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    The same also applies to a certain degree to all other tests: right now we assume that the reported states get passed back without any modification from the checkpoint coordinator. Again, modifications to that could change behaviour without detection from this test.&lt;/p&gt;</comment>
                            <comment id="16212183" author="githubbot" created="Fri, 20 Oct 2017 05:22:28 +0000"  >&lt;p&gt;Github user StefanRRichter commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Also from our offline discussion, I would suggest that this behaves as: if an operator with a given ID participated in a checkpoint, it should be marked as restored. From this definition, all cases should be derived. I believe this is slightly different to the current implementation. Both make sense, so I think we should agree to something. @pnowojski @aljoscha which is the better definition for you?&lt;/p&gt;</comment>
                            <comment id="16212239" author="githubbot" created="Fri, 20 Oct 2017 06:21:17 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145885868&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145885868&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(&lt;br/&gt;
    +				new OperatorID(4242L, 4242L),&lt;br/&gt;
    +				new RestoreCounterOperator(),&lt;br/&gt;
    +				new OperatorID(44L, 44L),&lt;br/&gt;
    +				new RestoreCounterOperator(),&lt;br/&gt;
    +				Optional.of(stateHandles));&lt;br/&gt;
    +&lt;br/&gt;
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Maybe keeping a set of the restored operator ids instead of a count already does the job?&lt;/p&gt;</comment>
                            <comment id="16212417" author="githubbot" created="Fri, 20 Oct 2017 09:39:46 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145903567&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145903567&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(4242L, 4242L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally {&lt;br/&gt;
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    general tearDown would not catch this, since I&apos;m using at least two different counters. However I think it will be cleaner if I refactor this code inject counter/set (newly created in each test) from the outside&lt;/p&gt;</comment>
                            <comment id="16212418" author="githubbot" created="Fri, 20 Oct 2017 09:39:46 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145915808&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145915808&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(4242L, 4242L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally {&lt;br/&gt;
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Yep, agree.&lt;/p&gt;</comment>
                            <comment id="16212419" author="githubbot" created="Fri, 20 Oct 2017 09:39:46 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145902939&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145902939&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AcknowledgeStreamMockEnvironment.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,65 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.core.testutils.OneShotLatch;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetrics;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Stream environment that allows to wait for checkpoint acknowledgement.&lt;br/&gt;
    + */&lt;br/&gt;
    +class AcknowledgeStreamMockEnvironment extends StreamMockEnvironment {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I have found only one more usage of `StreamMockEnvironment` in `AsyncWaitOperatorTest#testStateSnapshotAndRestore`.  Did you mean something more?&lt;/p&gt;

</comment>
                            <comment id="16212420" author="githubbot" created="Fri, 20 Oct 2017 09:39:46 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145917932&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145917932&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(4242L, 4242L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}&lt;br/&gt;
    +		finally {    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreAfterScaleUp() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		// test empty state in case of scale up&lt;br/&gt;
    +		OperatorSubtaskState emptyHeadOperatorState = StateAssignmentOperation.operatorSubtaskStateFrom(&lt;br/&gt;
    +			new OperatorInstanceID(0, headOperatorID),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +		stateHandles.putSubtaskStateByOperatorID(headOperatorID, emptyHeadOperatorState);&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				headOperatorID,
    +				new RestoreCounterOperator(),
    +				tailOperatorID,
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithoutState() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new StatelessRestoreCounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(&lt;br/&gt;
    +				headOperatorID,&lt;br/&gt;
    +				new StatelessRestoreCounterOperator(),&lt;br/&gt;
    +				tailOperatorID,&lt;br/&gt;
    +				new RestoreCounterOperator(),&lt;br/&gt;
    +				Optional.of(stateHandles));&lt;br/&gt;
    +&lt;br/&gt;
    +			assertEquals(1, StatelessRestoreCounterOperator.RESTORE_COUNTER.get());&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    `StatelessRestoreCounterOperator` and `RestoreCounterOperator` are using different counters. However that leads to my mistake, because this shows, that even stateless operators are getting `isRestore() == true`.&lt;/p&gt;</comment>
                            <comment id="16212421" author="githubbot" created="Fri, 20 Oct 2017 09:39:46 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145917513&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145917513&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(4242L, 4242L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}&lt;br/&gt;
    +		finally {    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreAfterScaleUp() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		// test empty state in case of scale up&lt;br/&gt;
    +		OperatorSubtaskState emptyHeadOperatorState = StateAssignmentOperation.operatorSubtaskStateFrom(&lt;br/&gt;
    +			new OperatorInstanceID(0, headOperatorID),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +		stateHandles.putSubtaskStateByOperatorID(headOperatorID, emptyHeadOperatorState);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    ad 1. - that&apos;s why I have used `StateAssignmentOperation.operatorSubtaskStateFrom`, to share this logic. I didn&apos;t want to use all of the `StateAssignmentOperation`, because it&apos;s constructor is really annoying to fulfil.&lt;/p&gt;

&lt;p&gt;    ad 2. - that&apos;s a valid concern, however writing ITCases for this might be also an overkill. And wouldn&apos;t it be to necessary to test it against every state backend, to make sure that there are no introduced quirks during (de)serialisation?&lt;/p&gt;</comment>
                            <comment id="16212422" author="githubbot" created="Fri, 20 Oct 2017 09:39:46 +0000"  >&lt;p&gt;Github user pnowojski commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145903139&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145903139&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(&lt;br/&gt;
    +				new OperatorID(4242L, 4242L),&lt;br/&gt;
    +				new RestoreCounterOperator(),&lt;br/&gt;
    +				new OperatorID(44L, 44L),&lt;br/&gt;
    +				new RestoreCounterOperator(),&lt;br/&gt;
    +				Optional.of(stateHandles));&lt;br/&gt;
    +&lt;br/&gt;
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Yes sure, keeping the set is much better idea &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16212426" author="githubbot" created="Fri, 20 Oct 2017 09:43:38 +0000"  >&lt;p&gt;Github user pnowojski commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    It appears that current behaviour is as you wished @StefanRRichter:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Operator participated in checkpoint, data written -&amp;gt; `isRestored == true`&lt;/li&gt;
	&lt;li&gt;Operator participated in checkpoint, but did not receive state after rescaling -&amp;gt; `isRestored == true`&lt;/li&gt;
	&lt;li&gt;Operator participated in checkpoint, nothing checkpointed -&amp;gt; `isRestored == true`&lt;/li&gt;
	&lt;li&gt;Operator never participated in checkpoint, or has a new uid -&amp;gt; `isRestored == false`&lt;/li&gt;
&lt;/ul&gt;

</comment>
                            <comment id="16212429" author="githubbot" created="Fri, 20 Oct 2017 09:45:24 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145920720&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145920720&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(4242L, 4242L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}&lt;br/&gt;
    +		finally {    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreAfterScaleUp() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		// test empty state in case of scale up&lt;br/&gt;
    +		OperatorSubtaskState emptyHeadOperatorState = StateAssignmentOperation.operatorSubtaskStateFrom(&lt;br/&gt;
    +			new OperatorInstanceID(0, headOperatorID),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +		stateHandles.putSubtaskStateByOperatorID(headOperatorID, emptyHeadOperatorState);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I would say it&apos;s great to have this unit test, eventually an IT case could also make sense. But this can be done in a different work / PR.&lt;/p&gt;</comment>
                            <comment id="16212431" author="githubbot" created="Fri, 20 Oct 2017 09:47:07 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145921058&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145921058&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/AcknowledgeStreamMockEnvironment.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,65 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    +import org.apache.flink.core.testutils.OneShotLatch;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetrics;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Stream environment that allows to wait for checkpoint acknowledgement.&lt;br/&gt;
    + */&lt;br/&gt;
    +class AcknowledgeStreamMockEnvironment extends StreamMockEnvironment {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    `RocksDBAsyncSnapshotTest` does something very similar in anonymous class&lt;/p&gt;</comment>
                            <comment id="16212433" author="githubbot" created="Fri, 20 Oct 2017 09:49:00 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r145921473&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r145921473&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/RestoreStreamTaskTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,325 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.tasks;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.LongSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointMetaData;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.CheckpointOptions;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.StateAssignmentOperation;&lt;br/&gt;
    +import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorID;&lt;br/&gt;
    +import org.apache.flink.runtime.jobgraph.OperatorInstanceID;&lt;br/&gt;
    +import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateInitializationContext;&lt;br/&gt;
    +import org.apache.flink.runtime.state.StateSnapshotContext;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.AbstractStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.api.operators.OneInputStreamOperator;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.util.TestHarnessUtil;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.Optional;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentLinkedQueue;&lt;br/&gt;
    +import java.util.concurrent.atomic.AtomicLong;&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.junit.Assert.assertEquals;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Tests ensuring correct behaviour of &lt;/p&gt;
{@link org.apache.flink.runtime.state.ManagedInitializationContext#isRestored}
&lt;p&gt;    + * method.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class RestoreStreamTaskTest extends TestLogger {&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestore() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(42L, 42L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithNewId() throws Exception {&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			new OperatorID(42L, 42L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			new OperatorID(44L, 44L),&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				new OperatorID(4242L, 4242L),
    +				new RestoreCounterOperator(),
    +				new OperatorID(44L, 44L),
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(1, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}&lt;br/&gt;
    +		finally {    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreAfterScaleUp() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		// test empty state in case of scale up&lt;br/&gt;
    +		OperatorSubtaskState emptyHeadOperatorState = StateAssignmentOperation.operatorSubtaskStateFrom(&lt;br/&gt;
    +			new OperatorInstanceID(0, headOperatorID),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap(),&lt;br/&gt;
    +			Collections.emptyMap());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +		stateHandles.putSubtaskStateByOperatorID(headOperatorID, emptyHeadOperatorState);&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(
    +				headOperatorID,
    +				new RestoreCounterOperator(),
    +				tailOperatorID,
    +				new RestoreCounterOperator(),
    +				Optional.of(stateHandles));
    +
    +			assertEquals(2, RestoreCounterOperator.RESTORE_COUNTER.get());
    +		}
&lt;p&gt;    +		finally &lt;/p&gt;
{
    +			RestoreCounterOperator.RESTORE_COUNTER.getAndSet(0);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRestoreWithoutState() throws Exception {&lt;br/&gt;
    +		OperatorID headOperatorID = new OperatorID(42L, 42L);&lt;br/&gt;
    +		OperatorID tailOperatorID = new OperatorID(44L, 44L);&lt;br/&gt;
    +&lt;br/&gt;
    +		AcknowledgeStreamMockEnvironment environment1 = processRecords(&lt;br/&gt;
    +			headOperatorID,&lt;br/&gt;
    +			new StatelessRestoreCounterOperator(),&lt;br/&gt;
    +			tailOperatorID,&lt;br/&gt;
    +			new CounterOperator(),&lt;br/&gt;
    +			Optional.empty());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, environment1.getCheckpointStateHandles().getSubtaskStateMappings().size());&lt;br/&gt;
    +&lt;br/&gt;
    +		TaskStateSnapshot stateHandles = environment1.getCheckpointStateHandles();&lt;br/&gt;
    +&lt;br/&gt;
    +		try {&lt;br/&gt;
    +			AcknowledgeStreamMockEnvironment environment2 = processRecords(&lt;br/&gt;
    +				headOperatorID,&lt;br/&gt;
    +				new StatelessRestoreCounterOperator(),&lt;br/&gt;
    +				tailOperatorID,&lt;br/&gt;
    +				new RestoreCounterOperator(),&lt;br/&gt;
    +				Optional.of(stateHandles));&lt;br/&gt;
    +&lt;br/&gt;
    +			assertEquals(1, StatelessRestoreCounterOperator.RESTORE_COUNTER.get());&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Oh yeah, sorry...I misread them as the same &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16212437" author="githubbot" created="Fri, 20 Oct 2017 09:49:57 +0000"  >&lt;p&gt;Github user StefanRRichter commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    That&apos;s great! In that case I would approve this &#128077; &lt;/p&gt;</comment>
                            <comment id="16216857" author="githubbot" created="Tue, 24 Oct 2017 13:04:17 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851#discussion_r146551851&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851#discussion_r146551851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTestHarness.java &amp;#8212;&lt;br/&gt;
    @@ -370,6 +371,10 @@ public void endInput() {&lt;br/&gt;
     		}&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;    +	public StreamConfigChainer setupOpertorChain(OperatorID headOperatorId, OneInputStreamOperator&amp;lt;?, ?&amp;gt; headOperator) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    nit: typo, but I&apos;ll fix while merging&lt;/p&gt;</comment>
                            <comment id="16216863" author="githubbot" created="Tue, 24 Oct 2017 13:08:20 +0000"  >&lt;p&gt;Github user aljoscha commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    It&apos;s excellent that you separated the cleanup work from the actual change. &#128077; &lt;/p&gt;</comment>
                            <comment id="16216967" author="githubbot" created="Tue, 24 Oct 2017 14:15:14 +0000"  >&lt;p&gt;Github user aljoscha commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I merged, could you please close the PR?&lt;/p&gt;</comment>
                            <comment id="16216968" author="aljoscha" created="Tue, 24 Oct 2017 14:15:31 +0000"  >&lt;p&gt;Added tests in bc32991a358889464a5b596684aa40ff3e31acbe&lt;/p&gt;</comment>
                            <comment id="16216996" author="githubbot" created="Tue, 24 Oct 2017 14:28:12 +0000"  >&lt;p&gt;Github user pnowojski commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks!&lt;/p&gt;</comment>
                            <comment id="16216997" author="githubbot" created="Tue, 24 Oct 2017 14:28:12 +0000"  >&lt;p&gt;Github user pnowojski closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4851&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4851&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10020">
                    <name>Cloners</name>
                                                                <inwardlinks description="is cloned by">
                                        <issuelink>
            <issuekey id="13111339">FLINK-7901</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12887099" name="StreamingJob.java" size="3133" author="aljoscha" created="Thu, 14 Sep 2017 12:44:37 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 4 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3k2d3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>