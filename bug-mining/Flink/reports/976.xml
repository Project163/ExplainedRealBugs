<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:23:38 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-3701] Cant call execute after first execution</title>
                <link>https://issues.apache.org/jira/browse/FLINK-3701</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;in the scala shell, local mode, version 1.0 this works:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;Scala-Flink&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt; b = env.fromElements(&lt;span class=&quot;code-quote&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;b&quot;&lt;/span&gt;)
Scala-Flink&amp;gt; b.print
Scala-Flink&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt; c = env.fromElements(&lt;span class=&quot;code-quote&quot;&gt;&quot;c&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;d&quot;&lt;/span&gt;)
Scala-Flink&amp;gt; c.print
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;in the current master (after c.print) this leads to :&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;java.lang.NullPointerException
	at org.apache.flink.api.java.ExecutionEnvironment.createProgramPlan(ExecutionEnvironment.java:1031)
	at org.apache.flink.api.java.ExecutionEnvironment.createProgramPlan(ExecutionEnvironment.java:961)
	at org.apache.flink.api.java.ScalaShellRemoteEnvironment.execute(ScalaShellRemoteEnvironment.java:70)
	at org.apache.flink.api.java.ExecutionEnvironment.execute(ExecutionEnvironment.java:855)
	at org.apache.flink.api.java.DataSet.collect(DataSet.java:410)
	at org.apache.flink.api.java.DataSet.print(DataSet.java:1605)
	at org.apache.flink.api.scala.DataSet.print(DataSet.scala:1615)
	at .&amp;lt;init&amp;gt;(&amp;lt;console&amp;gt;:56)
	at .&amp;lt;clinit&amp;gt;(&amp;lt;console&amp;gt;)
	at .&amp;lt;init&amp;gt;(&amp;lt;console&amp;gt;:7)
	at .&amp;lt;clinit&amp;gt;(&amp;lt;console&amp;gt;)
	at $print(&amp;lt;console&amp;gt;)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at scala.tools.nsc.interpreter.IMain$ReadEvalPrint.call(IMain.scala:734)
	at scala.tools.nsc.interpreter.IMain$Request.loadAndRun(IMain.scala:983)
	at scala.tools.nsc.interpreter.IMain.loadAndRunReq$1(IMain.scala:573)
	at scala.tools.nsc.interpreter.IMain.interpret(IMain.scala:604)
	at scala.tools.nsc.interpreter.IMain.interpret(IMain.scala:568)
	at scala.tools.nsc.interpreter.ILoop.reallyInterpret$1(ILoop.scala:760)
	at scala.tools.nsc.interpreter.ILoop.interpretStartingWith(ILoop.scala:805)
	at scala.tools.nsc.interpreter.ILoop.command(ILoop.scala:717)
	at scala.tools.nsc.interpreter.ILoop.processLine$1(ILoop.scala:581)
	at scala.tools.nsc.interpreter.ILoop.innerLoop$1(ILoop.scala:588)
	at scala.tools.nsc.interpreter.ILoop.loop(ILoop.scala:591)
	at scala.tools.nsc.interpreter.ILoop$$anonfun$process$1.apply$mcZ$sp(ILoop.scala:882)
	at scala.tools.nsc.interpreter.ILoop$$anonfun$process$1.apply(ILoop.scala:837)
	at scala.tools.nsc.interpreter.ILoop$$anonfun$process$1.apply(ILoop.scala:837)
	at scala.tools.nsc.util.ScalaClassLoader$.savingContextLoader(ScalaClassLoader.scala:135)
	at scala.tools.nsc.interpreter.ILoop.process(ILoop.scala:837)
	at org.apache.flink.api.scala.FlinkShell$.startShell(FlinkShell.scala:199)
	at org.apache.flink.api.scala.FlinkShell$.main(FlinkShell.scala:127)
	at org.apache.flink.api.scala.FlinkShell.main(FlinkShell.scala)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
                <environment></environment>
        <key id="12956131">FLINK-3701</key>
            <summary>Cant call execute after first execution</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mxm">Maximilian Michels</assignee>
                                    <reporter username="nikst">Nikolaas Steenbergen</reporter>
                        <labels>
                    </labels>
                <created>Tue, 5 Apr 2016 11:55:00 +0000</created>
                <updated>Sat, 14 May 2016 13:27:40 +0000</updated>
                            <resolved>Sat, 14 May 2016 13:27:39 +0000</resolved>
                                    <version>1.1.0</version>
                                    <fixVersion>1.1.0</fixVersion>
                                    <component>Scala Shell</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="15247644" author="mxm" created="Tue, 19 Apr 2016 12:22:41 +0000"  >&lt;p&gt;The issue is that the serializer lists in the &lt;tt&gt;ExecutionConfig&lt;/tt&gt; are set to null after they have been serialized for cluster shipping. A solution would be to simply clear those lists and not set them to null. This would reset them to their original state for further executions. Setting them to null can also cause other problems, i.e. when additional serializers are registered after the first execution. Perhaps you could also comment &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=till.rohrmann&quot; class=&quot;user-hover&quot; rel=&quot;till.rohrmann&quot;&gt;till.rohrmann&lt;/a&gt; if that works.&lt;/p&gt;
</comment>
                            <comment id="15247645" author="githubbot" created="Tue, 19 Apr 2016 12:25:26 +0000"  >&lt;p&gt;GitHub user mxm opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1913&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1913&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-3701&quot; title=&quot;Cant call execute after first execution&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-3701&quot;&gt;&lt;del&gt;FLINK-3701&lt;/del&gt;&lt;/a&gt; reuse serializer lists in ExecutionConfig&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-3701&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/FLINK-3701&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/mxm/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/mxm/flink&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-3701&quot; title=&quot;Cant call execute after first execution&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-3701&quot;&gt;&lt;del&gt;FLINK-3701&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1913.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1913.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #1913&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 08921d47e72ce219246d68a63e77d0745c20420d&lt;br/&gt;
Author: Maximilian Michels &amp;lt;mxm@apache.org&amp;gt;&lt;br/&gt;
Date:   2016-04-19T12:16:08Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-3701&quot; title=&quot;Cant call execute after first execution&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-3701&quot;&gt;&lt;del&gt;FLINK-3701&lt;/del&gt;&lt;/a&gt; reuse serializer lists in ExecutionConfig&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15247718" author="githubbot" created="Tue, 19 Apr 2016 13:11:14 +0000"  >&lt;p&gt;Github user mxm commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1913#issuecomment-211918388&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1913#issuecomment-211918388&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    When simply clearing the lists, we loose the registered serializers. Added another commit to make the fields transient instead of clearing the lists. That way we can reuse the `ExecutionConfig` several times with repeated serialization/deserialization of the registered serializers.&lt;/p&gt;</comment>
                            <comment id="15247847" author="till.rohrmann" created="Tue, 19 Apr 2016 14:30:30 +0000"  >&lt;p&gt;Yes that should work.&lt;/p&gt;</comment>
                            <comment id="15252172" author="githubbot" created="Thu, 21 Apr 2016 16:35:54 +0000"  >&lt;p&gt;Github user mxm commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1913#issuecomment-213003239&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1913#issuecomment-213003239&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    The problem is a bit more involved. We have basically three possible branches for the `ExecutionConfig` usage.&lt;/p&gt;

&lt;p&gt;    1. Serialization during `JobGraph`/`StreamGraph` generation and deserialization using the user code class loader during instantiating of the tasks&lt;br/&gt;
    2. Usage in `PojoSerializer` where no explicit serialization/deserialization is performed because it is assumed that the correct class loader is in place.&lt;br/&gt;
    3. Reuse of the `ExecutionConfig` for further jobs&lt;/p&gt;

&lt;p&gt;    If we alter the `ExecutionConfig` after 1) by setting the fields to `null`, we change the configuration for the next job. The `ExecutionEnvironment` reuses the config. This problem is not always visible because it depends on Akka whether the class is serialized or simply passed as a reference. If the class is serialized, then a deserialization of the lists won&apos;t affect the original reference.&lt;/p&gt;

&lt;p&gt;    As a solution, I&apos;ve wrapped the types/serializer lists in a `SerilizableCacheableValue` which keeps the value for as long as possible and deserializes using the default class loader when not explicitly deserialized during task instantiating. &lt;/p&gt;</comment>
                            <comment id="15259766" author="githubbot" created="Wed, 27 Apr 2016 08:25:02 +0000"  >&lt;p&gt;Github user mxm commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1913#issuecomment-215009127&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1913#issuecomment-215009127&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    The build passed on my branch but Apache&apos;s Travis seems to take forever: &lt;a href=&quot;https://travis-ci.org/mxm/flink/builds/125852101&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://travis-ci.org/mxm/flink/builds/125852101&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I&apos;ve rebased to the master and merged the commits. &lt;/p&gt;

&lt;p&gt;    CC @tillrohrmann Do you think this is good to merge?&lt;/p&gt;</comment>
                            <comment id="15259768" author="githubbot" created="Wed, 27 Apr 2016 08:25:38 +0000"  >&lt;p&gt;Github user mxm commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1913#issuecomment-215009253&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1913#issuecomment-215009253&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    CC @rmetzger You might want to take a look as well.&lt;/p&gt;</comment>
                            <comment id="15270314" author="githubbot" created="Wed, 4 May 2016 08:24:21 +0000"  >&lt;p&gt;Github user mxm commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1913#issuecomment-216781792&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1913#issuecomment-216781792&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    No comments? Going to merge then to make the Scala shell usable again.&lt;/p&gt;</comment>
                            <comment id="15270372" author="githubbot" created="Wed, 4 May 2016 09:25:19 +0000"  >&lt;p&gt;Github user tillrohrmann commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1913#discussion_r62011352&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1913#discussion_r62011352&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/util/SerializableCacheableValue.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,127 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.util;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.io.ObjectOutputStream;&lt;br/&gt;
    +import java.io.Serializable;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * A data structure that enables to keep a value which may be serialized/deserialized using a custom&lt;br/&gt;
    + * Classloader. The encapsulated value is kept locally for further use after a copy of the class has&lt;br/&gt;
    + * been serialized and shipped somewhere else.&lt;br/&gt;
    + *&lt;br/&gt;
    + * This is useful if we want to keep working with a value which may require a custom classloader in&lt;br/&gt;
    + * one context but is fine with the system/context Classloader in other cases. The value is cached&lt;br/&gt;
    + * as long as possible to prevent unnecessary serialization/deserialization.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class SerializableCacheableValue&amp;lt;T&amp;gt; implements Serializable {&lt;br/&gt;
    +&lt;br/&gt;
    +	/** The current cached value. Lost when serialized. */&lt;br/&gt;
    +	private transient T value;&lt;br/&gt;
    +&lt;br/&gt;
    +	private SerializedValue&amp;lt;T&amp;gt; serializedValue;&lt;br/&gt;
    +&lt;br/&gt;
    +	public SerializableCacheableValue(T value) &lt;/p&gt;
{
    +		update(value);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Custom serialization methods which always writes the latest value.&lt;br/&gt;
    +     */&lt;br/&gt;
    +	private void writeObject(ObjectOutputStream out) throws IOException &lt;/p&gt;
{
    +		// trigger serialization once more to update to the least recent value
    +		serialize();
    +		out.defaultWriteObject();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Serialization, e.g. before shipping the class&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void serialize() throws IOException {&lt;br/&gt;
    +		if (value != null) &lt;/p&gt;
{
    +			serializedValue = new SerializedValue&amp;lt;&amp;gt;(value);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Explicit deserialiation using a provided class loader.&lt;br/&gt;
    +	 * @param classLoader The class loader to use&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void deserialize(ClassLoader classLoader) {&lt;br/&gt;
    +		if (serializedValue != null) {&lt;br/&gt;
    +			try &lt;/p&gt;
{
    +				value = serializedValue.deserializeValue(classLoader);
    +			}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +				throw new RuntimeException(&quot;Attempted to deserialize serialized data &quot; +
    +					&quot; with class loader &quot; + classLoader + &quot; failed. You probably forgot to&quot; +
    +					&quot; deserialize using a custom Classloader via deserialize(Classloader).&quot;, e);
    +			}
&lt;p&gt;    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Gets the current value or deserializes it uses the current Classloader.&lt;br/&gt;
    +	 * @return the value of type T&lt;br/&gt;
    +     */&lt;br/&gt;
    +	public T get() {&lt;br/&gt;
    +		if (value == null) &lt;/p&gt;
{
    +			deserialize(getClass().getClassLoader());
    +		}
&lt;p&gt;    +		return value;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Updates the current stored value.&lt;br/&gt;
    +	 * @param value The new value of type T&lt;br/&gt;
    +     */&lt;br/&gt;
    +	public void update(T value) &lt;/p&gt;
{
    +		Preconditions.checkNotNull(value, &quot;Serializable value must not be null.&quot;);
    +		this.value = value;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public boolean equals(Object o) {&lt;br/&gt;
    +		if (this == o) &lt;/p&gt;
{
    +			return true;
    +		}
&lt;p&gt;    +		if (o == null || getClass() != o.getClass()) &lt;/p&gt;
{
    +			return false;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		SerializableCacheableValue&amp;lt;?&amp;gt; that = (SerializableCacheableValue&amp;lt;?&amp;gt;) o;&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			// serialize for equality check
    +			serialize();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			throw new RuntimeException(&quot;Error while serializing for equality check.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		return serializedValue != null &amp;amp;&amp;amp; serializedValue.equals(that.serializedValue);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    What if `that` has not been serialized?&lt;/p&gt;</comment>
                            <comment id="15270411" author="githubbot" created="Wed, 4 May 2016 09:53:46 +0000"  >&lt;p&gt;Github user tillrohrmann commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1913#issuecomment-216816200&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1913#issuecomment-216816200&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    What happens if the Akka communication is local? Would that mean that the list of registered Kryo types is shared between the `JobManager` and the `Client`? This could lead to a problem if the list of registered types is altered after submitting the first job (in detached mode). Maybe we have to create a copy of the `ExecutionConfig`.&lt;/p&gt;

&lt;p&gt;    I think we should add some tests which verify the behaviour of `SerializableCacheableValue`. Furthermore, we should add a test case for the original problem.&lt;/p&gt;

&lt;p&gt;    Apart from that, the changes look good and +1 for merging.&lt;/p&gt;</comment>
                            <comment id="15277916" author="githubbot" created="Tue, 10 May 2016 10:26:54 +0000"  >&lt;p&gt;Github user mxm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1913#discussion_r62647068&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1913#discussion_r62647068&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/util/SerializableCacheableValue.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,127 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.util;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.io.ObjectOutputStream;&lt;br/&gt;
    +import java.io.Serializable;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * A data structure that enables to keep a value which may be serialized/deserialized using a custom&lt;br/&gt;
    + * Classloader. The encapsulated value is kept locally for further use after a copy of the class has&lt;br/&gt;
    + * been serialized and shipped somewhere else.&lt;br/&gt;
    + *&lt;br/&gt;
    + * This is useful if we want to keep working with a value which may require a custom classloader in&lt;br/&gt;
    + * one context but is fine with the system/context Classloader in other cases. The value is cached&lt;br/&gt;
    + * as long as possible to prevent unnecessary serialization/deserialization.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class SerializableCacheableValue&amp;lt;T&amp;gt; implements Serializable {&lt;br/&gt;
    +&lt;br/&gt;
    +	/** The current cached value. Lost when serialized. */&lt;br/&gt;
    +	private transient T value;&lt;br/&gt;
    +&lt;br/&gt;
    +	private SerializedValue&amp;lt;T&amp;gt; serializedValue;&lt;br/&gt;
    +&lt;br/&gt;
    +	public SerializableCacheableValue(T value) &lt;/p&gt;
{
    +		update(value);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Custom serialization methods which always writes the latest value.&lt;br/&gt;
    +     */&lt;br/&gt;
    +	private void writeObject(ObjectOutputStream out) throws IOException &lt;/p&gt;
{
    +		// trigger serialization once more to update to the least recent value
    +		serialize();
    +		out.defaultWriteObject();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Serialization, e.g. before shipping the class&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void serialize() throws IOException {&lt;br/&gt;
    +		if (value != null) &lt;/p&gt;
{
    +			serializedValue = new SerializedValue&amp;lt;&amp;gt;(value);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Explicit deserialiation using a provided class loader.&lt;br/&gt;
    +	 * @param classLoader The class loader to use&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void deserialize(ClassLoader classLoader) {&lt;br/&gt;
    +		if (serializedValue != null) {&lt;br/&gt;
    +			try &lt;/p&gt;
{
    +				value = serializedValue.deserializeValue(classLoader);
    +			}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +				throw new RuntimeException(&quot;Attempted to deserialize serialized data &quot; +
    +					&quot; with class loader &quot; + classLoader + &quot; failed. You probably forgot to&quot; +
    +					&quot; deserialize using a custom Classloader via deserialize(Classloader).&quot;, e);
    +			}
&lt;p&gt;    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Gets the current value or deserializes it uses the current Classloader.&lt;br/&gt;
    +	 * @return the value of type T&lt;br/&gt;
    +     */&lt;br/&gt;
    +	public T get() {&lt;br/&gt;
    +		if (value == null) &lt;/p&gt;
{
    +			deserialize(getClass().getClassLoader());
    +		}
&lt;p&gt;    +		return value;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Updates the current stored value.&lt;br/&gt;
    +	 * @param value The new value of type T&lt;br/&gt;
    +     */&lt;br/&gt;
    +	public void update(T value) &lt;/p&gt;
{
    +		Preconditions.checkNotNull(value, &quot;Serializable value must not be null.&quot;);
    +		this.value = value;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public boolean equals(Object o) {&lt;br/&gt;
    +		if (this == o) &lt;/p&gt;
{
    +			return true;
    +		}
&lt;p&gt;    +		if (o == null || getClass() != o.getClass()) &lt;/p&gt;
{
    +			return false;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		SerializableCacheableValue&amp;lt;?&amp;gt; that = (SerializableCacheableValue&amp;lt;?&amp;gt;) o;&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			// serialize for equality check
    +			serialize();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			throw new RuntimeException(&quot;Error while serializing for equality check.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		return serializedValue != null &amp;amp;&amp;amp; serializedValue.equals(that.serializedValue);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Good catch! &lt;/p&gt;</comment>
                            <comment id="15278197" author="githubbot" created="Tue, 10 May 2016 14:41:11 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1913#discussion_r62683914&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1913#discussion_r62683914&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/util/SerializableCacheableValue.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,127 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.util;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.io.ObjectOutputStream;&lt;br/&gt;
    +import java.io.Serializable;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * A data structure that enables to keep a value which may be serialized/deserialized using a custom&lt;br/&gt;
    + * Classloader. The encapsulated value is kept locally for further use after a copy of the class has&lt;br/&gt;
    + * been serialized and shipped somewhere else.&lt;br/&gt;
    + *&lt;br/&gt;
    + * This is useful if we want to keep working with a value which may require a custom classloader in&lt;br/&gt;
    + * one context but is fine with the system/context Classloader in other cases. The value is cached&lt;br/&gt;
    + * as long as possible to prevent unnecessary serialization/deserialization.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class SerializableCacheableValue&amp;lt;T&amp;gt; implements Serializable {&lt;br/&gt;
    +&lt;br/&gt;
    +	/** The current cached value. Lost when serialized. */&lt;br/&gt;
    +	private transient T value;&lt;br/&gt;
    +&lt;br/&gt;
    +	private SerializedValue&amp;lt;T&amp;gt; serializedValue;&lt;br/&gt;
    +&lt;br/&gt;
    +	public SerializableCacheableValue(T value) &lt;/p&gt;
{
    +		update(value);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Custom serialization methods which always writes the latest value.&lt;br/&gt;
    +     */&lt;br/&gt;
    +	private void writeObject(ObjectOutputStream out) throws IOException &lt;/p&gt;
{
    +		// trigger serialization once more to update to the least recent value
    +		serialize();
    +		out.defaultWriteObject();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Serialization, e.g. before shipping the class&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void serialize() throws IOException {&lt;br/&gt;
    +		if (value != null) &lt;/p&gt;
{
    +			serializedValue = new SerializedValue&amp;lt;&amp;gt;(value);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Explicit deserialiation using a provided class loader.&lt;br/&gt;
    +	 * @param classLoader The class loader to use&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void deserialize(ClassLoader classLoader) {&lt;br/&gt;
    +		if (serializedValue != null) {&lt;br/&gt;
    +			try &lt;/p&gt;
{
    +				value = serializedValue.deserializeValue(classLoader);
    +			}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +				throw new RuntimeException(&quot;Attempted to deserialize serialized data &quot; +
    +					&quot; with class loader &quot; + classLoader + &quot; failed. You probably forgot to&quot; +
    +					&quot; deserialize using a custom Classloader via deserialize(Classloader).&quot;, e);
    +			}
&lt;p&gt;    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Gets the current value or deserializes it uses the current Classloader.&lt;br/&gt;
    +	 * @return the value of type T&lt;br/&gt;
    +     */&lt;br/&gt;
    +	public T get() {&lt;br/&gt;
    +		if (value == null) &lt;/p&gt;
{
    +			deserialize(getClass().getClassLoader());
    +		}
&lt;p&gt;    +		return value;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Updates the current stored value.&lt;br/&gt;
    +	 * @param value The new value of type T&lt;br/&gt;
    +     */&lt;br/&gt;
    +	public void update(T value) &lt;/p&gt;
{
    +		Preconditions.checkNotNull(value, &quot;Serializable value must not be null.&quot;);
    +		this.value = value;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public boolean equals(Object o) {&lt;br/&gt;
    +		if (this == o) &lt;/p&gt;
{
    +			return true;
    +		}
&lt;p&gt;    +		if (o == null || getClass() != o.getClass()) &lt;/p&gt;
{
    +			return false;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		SerializableCacheableValue&amp;lt;?&amp;gt; that = (SerializableCacheableValue&amp;lt;?&amp;gt;) o;&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			// serialize for equality check
    +			serialize();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			throw new RuntimeException(&quot;Error while serializing for equality check.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		return serializedValue != null &amp;amp;&amp;amp; serializedValue.equals(that.serializedValue);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public int hashCode() {&lt;br/&gt;
    +		int result = value != null ? value.hashCode() : 0;&lt;br/&gt;
    +		result = 31 * result + serializedValue.hashCode();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This is a potential null pointer, serialization did not happen, yet.&lt;/p&gt;</comment>
                            <comment id="15278202" author="githubbot" created="Tue, 10 May 2016 14:42:38 +0000"  >&lt;p&gt;Github user StephanEwen commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/1913#discussion_r62684204&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/1913#discussion_r62684204&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-core/src/main/java/org/apache/flink/util/SerializableCacheableValue.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,127 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.util;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import java.io.IOException;&lt;br/&gt;
    +import java.io.ObjectOutputStream;&lt;br/&gt;
    +import java.io.Serializable;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * A data structure that enables to keep a value which may be serialized/deserialized using a custom&lt;br/&gt;
    + * Classloader. The encapsulated value is kept locally for further use after a copy of the class has&lt;br/&gt;
    + * been serialized and shipped somewhere else.&lt;br/&gt;
    + *&lt;br/&gt;
    + * This is useful if we want to keep working with a value which may require a custom classloader in&lt;br/&gt;
    + * one context but is fine with the system/context Classloader in other cases. The value is cached&lt;br/&gt;
    + * as long as possible to prevent unnecessary serialization/deserialization.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class SerializableCacheableValue&amp;lt;T&amp;gt; implements Serializable {&lt;br/&gt;
    +&lt;br/&gt;
    +	/** The current cached value. Lost when serialized. */&lt;br/&gt;
    +	private transient T value;&lt;br/&gt;
    +&lt;br/&gt;
    +	private SerializedValue&amp;lt;T&amp;gt; serializedValue;&lt;br/&gt;
    +&lt;br/&gt;
    +	public SerializableCacheableValue(T value) &lt;/p&gt;
{
    +		update(value);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Custom serialization methods which always writes the latest value.&lt;br/&gt;
    +     */&lt;br/&gt;
    +	private void writeObject(ObjectOutputStream out) throws IOException &lt;/p&gt;
{
    +		// trigger serialization once more to update to the least recent value
    +		serialize();
    +		out.defaultWriteObject();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Serialization, e.g. before shipping the class&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void serialize() throws IOException {&lt;br/&gt;
    +		if (value != null) &lt;/p&gt;
{
    +			serializedValue = new SerializedValue&amp;lt;&amp;gt;(value);
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Explicit deserialiation using a provided class loader.&lt;br/&gt;
    +	 * @param classLoader The class loader to use&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void deserialize(ClassLoader classLoader) {&lt;br/&gt;
    +		if (serializedValue != null) {&lt;br/&gt;
    +			try &lt;/p&gt;
{
    +				value = serializedValue.deserializeValue(classLoader);
    +			}
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
    +				throw new RuntimeException(&quot;Attempted to deserialize serialized data &quot; +
    +					&quot; with class loader &quot; + classLoader + &quot; failed. You probably forgot to&quot; +
    +					&quot; deserialize using a custom Classloader via deserialize(Classloader).&quot;, e);
    +			}
&lt;p&gt;    +		}&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Gets the current value or deserializes it uses the current Classloader.&lt;br/&gt;
    +	 * @return the value of type T&lt;br/&gt;
    +     */&lt;br/&gt;
    +	public T get() {&lt;br/&gt;
    +		if (value == null) &lt;/p&gt;
{
    +			deserialize(getClass().getClassLoader());
    +		}
&lt;p&gt;    +		return value;&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Updates the current stored value.&lt;br/&gt;
    +	 * @param value The new value of type T&lt;br/&gt;
    +     */&lt;br/&gt;
    +	public void update(T value) &lt;/p&gt;
{
    +		Preconditions.checkNotNull(value, &quot;Serializable value must not be null.&quot;);
    +		this.value = value;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public boolean equals(Object o) {&lt;br/&gt;
    +		if (this == o) &lt;/p&gt;
{
    +			return true;
    +		}
&lt;p&gt;    +		if (o == null || getClass() != o.getClass()) &lt;/p&gt;
{
    +			return false;
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		SerializableCacheableValue&amp;lt;?&amp;gt; that = (SerializableCacheableValue&amp;lt;?&amp;gt;) o;&lt;br/&gt;
    +&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			// serialize for equality check
    +			serialize();
    +		}
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
    +			throw new RuntimeException(&quot;Error while serializing for equality check.&quot;);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		return serializedValue != null &amp;amp;&amp;amp; serializedValue.equals(that.serializedValue);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Override&lt;br/&gt;
    +	public int hashCode() {&lt;br/&gt;
    +		int result = value != null ? value.hashCode() : 0;&lt;br/&gt;
    +		result = 31 * result + serializedValue.hashCode();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    To avoid these kind of errors, I think it helps a lot to add annotations like `@Nullable` to the fields that can be null. Then IntelliJ should give warnings about null pointers.&lt;/p&gt;</comment>
                            <comment id="15283555" author="mxm" created="Sat, 14 May 2016 13:27:39 +0000"  >&lt;p&gt;Fixed in 48b469ad4f0da466b347071cea82913965645de3.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12964768">FLINK-3865</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12957786">FLINK-3733</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12951204">FLINK-3633</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310040">
                    <name>Required</name>
                                                                <inwardlinks description="is required by">
                                        <issuelink>
            <issuekey id="12958306">MAHOUT-1831</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            9 years, 27 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2vnq7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>