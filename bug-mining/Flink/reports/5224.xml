<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:55:24 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-21133] FLIP-27 Source does not work with synchronous savepoint</title>
                <link>https://issues.apache.org/jira/browse/FLINK-21133</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;I have pushed branch &lt;a href=&quot;https://github.com/kezhuw/flink/commits/synchronous-savepoint-conflict-with-bounded-end-input-case&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;synchronous-savepoint-conflict-with-bounded-end-input-case&lt;/a&gt; in my repository.&#160;&lt;tt&gt;SavepointITCase.testStopSavepointWithFlip27Source&lt;/tt&gt; failed due to timeout.&lt;/p&gt;

&lt;p&gt;See also &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21132&quot; title=&quot;BoundedOneInput.endInput is called when taking synchronous savepoint&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21132&quot;&gt;&lt;del&gt;FLINK-21132&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/apache/iceberg/issues/2033&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;apache/iceberg#2033&lt;/a&gt;..&lt;/p&gt;</description>
                <environment></environment>
        <key id="13354470">FLINK-21133</key>
            <summary>FLIP-27 Source does not work with synchronous savepoint</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="becket_qin">Jiangjie Qin</assignee>
                                    <reporter username="kezhuw">Kezhu Wang</reporter>
                        <labels>
                            <label>pull-request-available</label>
                            <label>stale-assigned</label>
                    </labels>
                <created>Mon, 25 Jan 2021 15:25:46 +0000</created>
                <updated>Fri, 28 May 2021 08:58:50 +0000</updated>
                            <resolved>Mon, 19 Apr 2021 14:38:41 +0000</resolved>
                                    <version>1.11.3</version>
                    <version>1.12.1</version>
                                    <fixVersion>1.13.0</fixVersion>
                    <fixVersion>1.12.3</fixVersion>
                                    <component>API / Core</component>
                    <component>API / DataStream</component>
                    <component>Runtime / Checkpointing</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>13</watches>
                                                                                                                <comments>
                            <comment id="17281581" author="mapohl" created="Tue, 9 Feb 2021 07:19:27 +0000"  >&lt;p&gt;Findings mentioned in duplicate &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21323&quot; title=&quot;Stop-with-savepoint is not supported by SourceOperatorStreamTask&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21323&quot;&gt;&lt;del&gt;FLINK-21323&lt;/del&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When looking into &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21030&quot; title=&quot;Broken job restart for job with disjoint graph&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21030&quot;&gt;&lt;del&gt;FLINK-21030&lt;/del&gt;&lt;/a&gt; analyzing the stop-with-savepoint behavior we implemented different test jobs covering the old addSource and new fromSource methods for adding sources. The stop-with-savepoint consists of two phase:&lt;/p&gt;

&lt;p&gt;Create the savepoint&lt;br/&gt;
Stop the source to trigger finalizing the job&lt;br/&gt;
The test failing in the second phase using fromSource does not succeed. The reason for this might be that finishTask is not implemented by SourceOperatorStreamTask in contrast to SourceStreamTask which is used when calling addSource in the job definition. Hence, the job termination is never triggered.&lt;/p&gt;

&lt;p&gt;We might have missed this due to some naming error of JobMasterStopWithSavepointIT test that is not triggered by Maven due to the wrong suffix used in this case. The IT is failing right now. &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21031&quot; title=&quot;JobMasterStopWithSavepointIT test is not run due to wrong name&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21031&quot;&gt;&lt;del&gt;FLINK-21031&lt;/del&gt;&lt;/a&gt; is covering the fix of JobMasterStopWithSavepointIT already.&lt;/p&gt;&lt;/blockquote&gt;</comment>
                            <comment id="17281693" author="till.rohrmann" created="Tue, 9 Feb 2021 10:25:05 +0000"  >&lt;p&gt;fyi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jqin&quot; class=&quot;user-hover&quot; rel=&quot;jqin&quot;&gt;jqin&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=aljoscha&quot; class=&quot;user-hover&quot; rel=&quot;aljoscha&quot;&gt;aljoscha&lt;/a&gt; &lt;/p&gt;</comment>
                            <comment id="17281821" author="mapohl" created="Tue, 9 Feb 2021 14:58:25 +0000"  >&lt;p&gt;The error I described above was caused by not enabling Checkpoints. The test succeeded as expected when Checkpointing was enabled. I&apos;m gonna try to come up with a shorter testcase describing the behavior.&lt;/p&gt;</comment>
                            <comment id="17282226" author="becket_qin" created="Wed, 10 Feb 2021 05:25:16 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mapohl&quot; class=&quot;user-hover&quot; rel=&quot;mapohl&quot;&gt;mapohl&lt;/a&gt;&#160;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kezhuw&quot; class=&quot;user-hover&quot; rel=&quot;kezhuw&quot;&gt;kezhuw&lt;/a&gt;, thanks for digging into the issue. The root cause you found sounds correct to me. A quick fix would be implementing &lt;tt&gt;finishTask()&lt;/tt&gt; in the &lt;tt&gt;SourceOperatorStreamTask&lt;/tt&gt;.&#160;&lt;/p&gt;

&lt;p&gt;That said, the semantic of &lt;tt&gt;finishTask()&lt;/tt&gt; seems not well defined. It would be good if we can first agree on the behavior before we fix the issue. The current semantic of &lt;tt&gt;finishTask()&lt;/tt&gt;&#160;is following.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;For non-source tasks, this method is essentially optional and can be regarded as a &quot;hook&quot;. And in fact it is even not guaranteed to be invoked if I understand correctly - because the checkpoint callback may come after the task has received the &lt;tt&gt;EndOfInput&lt;/tt&gt;&#160;marker from upstream tasks. At that point, the task might have exited.&lt;/li&gt;
	&lt;li&gt;For source tasks, this method must be implemented in order to let the task stop when synchronous savepoint is taken. Supposedly a source task&#160;should return an &lt;tt&gt;EndOfInput&lt;/tt&gt; marker from the source to the downstream so all the tasks will exit. I am not sure if this &lt;tt&gt;EndOfInput&lt;/tt&gt;&#160;marker should be different from an actual &lt;tt&gt;EndOfInput&lt;/tt&gt;&#160;marker as an operator may want to behave differently if the stream has not actually ended. But this is a separate issue.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Assuming we keep the above semantic unchanged for now. For the quick fix, we may need to do the following:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Add a &lt;tt&gt;stop()&lt;/tt&gt; method to the SourceOperator. Once it is called, the SourceOperator#emitNext() method will just return &lt;tt&gt;END_OF_INPUT&lt;/tt&gt;.&#160;&lt;/li&gt;
	&lt;li&gt;Implement &lt;tt&gt;finishTask()&lt;/tt&gt; method in the &lt;tt&gt;SourceOperatorStreamTask&lt;/tt&gt; to stop the &lt;tt&gt;SourceOperator.&lt;/tt&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;CC&#160;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17282253" author="kezhuw" created="Wed, 10 Feb 2021 06:30:18 +0000"  >&lt;p&gt;Hi all, there are actually two cases for FLIP-27 sources not working with stop-with-savepoint:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;&lt;tt&gt;SourceOperatorStreamTask&lt;/tt&gt; does not finish itself on &lt;tt&gt;finishTask&lt;/tt&gt;.&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;MultipleInputStreamTask&lt;/tt&gt; does not finish itself if it is the heading task that triggering checkpoint.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Fix to first case is simple. Fix to second case may require extra works, such as moving &lt;tt&gt;finishTask&lt;/tt&gt; to path &lt;tt&gt;triggerCheckpointAsync&lt;/tt&gt;, I am unsure of this.&lt;/p&gt;

&lt;p&gt;I pushed another &lt;a href=&quot;https://github.com/kezhuw/flink/commit/3578b67d6d880d7981bc8b3c0d425eb9f57caaf7&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;branch with two test cases&lt;/a&gt;, &lt;tt&gt;testStopSavepointWithFlip27SourceChainedOut&lt;/tt&gt; still fail after &lt;tt&gt;SourceOperatorStreamTask.finishTask&lt;/tt&gt; introduced.&lt;/p&gt;

&lt;p&gt;I am wonder whether we could separate the two so the first could be fixed without blocking on the second. The second need extra attention from stop-with-savepoint path.&lt;/p&gt;

&lt;p&gt;I could provide a fix for first case if there is no one working on it yet.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trohrmann&quot; class=&quot;user-hover&quot; rel=&quot;trohrmann&quot;&gt;trohrmann&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pnowojski&quot; class=&quot;user-hover&quot; rel=&quot;pnowojski&quot;&gt;pnowojski&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jqin&quot; class=&quot;user-hover&quot; rel=&quot;jqin&quot;&gt;jqin&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=aljoscha&quot; class=&quot;user-hover&quot; rel=&quot;aljoscha&quot;&gt;aljoscha&lt;/a&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17282263" author="kezhuw" created="Wed, 10 Feb 2021 06:58:56 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=becket_qin&quot; class=&quot;user-hover&quot; rel=&quot;becket_qin&quot;&gt;becket_qin&lt;/a&gt; Sorry for not aware of your comment, I am writing test cases. In &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21132&quot; title=&quot;BoundedOneInput.endInput is called when taking synchronous savepoint&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21132&quot;&gt;&lt;del&gt;FLINK-21132&lt;/del&gt;&lt;/a&gt;, we agreed that &lt;tt&gt;endInput&lt;/tt&gt; should not be called upon stop-with-savepoint, so first step of your recommended changes is not needed now.&lt;/p&gt;</comment>
                            <comment id="17282449" author="stephanewen" created="Wed, 10 Feb 2021 13:01:00 +0000"  >&lt;p&gt;It looks to me like &quot;stop with savepoint&quot; it itself incompletely implemented. The current implementation works by simply &quot;breaking the legacy source thread out of its loop&quot;. That&apos;s why it only works for those specific sources.&lt;/p&gt;

&lt;p&gt;I think what stop-with-savepoint should really do is tell the mailbox to take a savepoint and then exit (as if input was empty).&lt;br/&gt;
That is the definition of stopping and should cover simultaneously chained and unchained sources, without any other changes.&lt;br/&gt;
&quot;Stop()&quot; is like a graceful &quot;cancel()&quot; where the main difference are:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;not interrupting threads, because don&apos;t need to be &quot;as fast as possible&quot;&lt;/li&gt;
	&lt;li&gt;calling close() on the operators for graceful shutdown and finalization.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If we add a &quot;stop()&quot; method to the sources, we are solving this in the wrong place, in my opinion. The sources are designed such that the calling thread (mailbox) can decide when to read and when to stop. The sources only give indications about availability to help the thread make that decision. A &quot;stop()&quot; command should go to the thread (mailbox) to tell it to stop its mailbox loop.&lt;/p&gt;

&lt;p&gt;That way, there is also a natural distinction between the case where the source reaches the end of the stream (and we needs to emit a MAX_WATERMARK, as implemented in the source operator) and the case where we just stop reading (&quot;stop()&quot;). Otherwise we need weird bookkeeping to understand whether, once the source tells us END_OF_INPUT we should advance the watermark or not.&lt;/p&gt;


</comment>
                            <comment id="17282454" author="stephanewen" created="Wed, 10 Feb 2021 13:30:05 +0000"  >&lt;p&gt;I think that the &quot;stop()&quot; method should be on &lt;tt&gt;StreamTask&lt;/tt&gt; and that way it should work for all setups equally.&lt;/p&gt;</comment>
                            <comment id="17282564" author="kezhuw" created="Wed, 10 Feb 2021 16:40:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think what stop-with-savepoint should really do is tell the mailbox to take a savepoint and then exit (as if input was empty).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt;, I agree and second this point.&lt;/p&gt;

&lt;p&gt;Currently, stop-with-savepoint is implemented through propagation of &lt;tt&gt;EndOfPartitionEvent&lt;/tt&gt;, it indeed need bookkeeping to avoid &lt;tt&gt;endInput&lt;/tt&gt; in downstream not only source.&lt;/p&gt;

&lt;p&gt;I actually pushed a &lt;a href=&quot;https://github.com/kezhuw/flink/commit/d6c6837cd724913716007265f03a50098bee985e&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;preview working&lt;/a&gt; in discussion of &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21132&quot; title=&quot;BoundedOneInput.endInput is called when taking synchronous savepoint&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21132&quot;&gt;&lt;del&gt;FLINK-21132&lt;/del&gt;&lt;/a&gt;. It works for all stream tasks but more like an rework but not bug fix. The key change is that it stops tasks independently. The consequence is that &lt;tt&gt;StreamOperator.close&lt;/tt&gt; will not be called as flushing/sending operation probably will fail.&lt;/p&gt;

&lt;p&gt;If &lt;tt&gt;StreamOperator.close&lt;/tt&gt; is required in api side as guarantee to stop-with-savepoint, I think we finally will resort to another shape of data flow event, say &lt;tt&gt;StopOfPartitionEvent&lt;/tt&gt;, to avoid bookkeeping.&lt;/p&gt;</comment>
                            <comment id="17283631" author="stephanewen" created="Fri, 12 Feb 2021 11:49:45 +0000"  >&lt;p&gt;I see, the remaining problem is that exiting the mailbox loop in case of the source ending should call &lt;tt&gt;finishInput()&lt;/tt&gt;, while exiting from &lt;tt&gt;stop()&lt;/tt&gt; should not.&lt;/p&gt;

&lt;p&gt;Digging through the code is that there seems to be a lot of confusion and mixup between cancelling, stopping, reaching end of the stream, reaching the end of the input. For example, the fact that we need to pass a flag &lt;tt&gt;&quot;isStoppingBySyncSavepoint&quot;&lt;/tt&gt; to the &lt;tt&gt;&quot;close()&quot;&lt;/tt&gt; method points to a bad abstraction there.&lt;/p&gt;

&lt;p&gt;I think it makes sense to revisit this and clean it up. Similar like &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kezhuw&quot; class=&quot;user-hover&quot; rel=&quot;kezhuw&quot;&gt;kezhuw&lt;/a&gt; suggested, having an explicit &lt;tt&gt;EndOfData&lt;/tt&gt; event that would trigger &lt;tt&gt;finishInput()&lt;/tt&gt; woudl make this cleaner.&lt;/p&gt;

&lt;p&gt;In that case&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;stop() would simply exit the mailbox loop, task closes/cleans up, and it send EndOfPartition downstream. The downstream task, once all input channels have seen the EndOfPartition, exits the mailbox in the same way&lt;/li&gt;
	&lt;li&gt;reaching the end of a source, or using &quot;stop()&quot; with the additional flag to drain the pipeline, would call &quot;finishInput()&quot; and enqueue an EndOfData event before exiting the loop. Downstream tasks call &quot;finishInput()&quot; when they saw EndOfData from all their input channels.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="17285118" author="stephanewen" created="Tue, 16 Feb 2021 09:51:47 +0000"  >&lt;p&gt;Alternatively, we could also have one EndOfPartition event, with a flag to indicate whether this signals &quot;end of data&quot;. But we still need to handle the cases where only a subsets of input signal &quot;end of data&quot; and some inputs only signal &quot;end of partition&quot;.&lt;/p&gt;</comment>
                            <comment id="17285207" author="kezhuw" created="Tue, 16 Feb 2021 14:00:15 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think what stop-with-savepoint should really do is tell the mailbox to take a savepoint and then exit (as if input was empty).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Based on this, I would say that some of our assumptions and/or current implementations are unnecessary or even harmful for future improvements:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;not interrupting threads, because don&apos;t need to be &quot;as fast as possible&quot;. I agree with this and I think this could be naming guarantee comparing to &quot;cancel --savepoint&quot;.&lt;/li&gt;
	&lt;li&gt;calling close() on the operators for graceful shutdown and finalization. I think this actually enforce &quot;semantics guarantee&quot; to &quot;stop-with-savepoint&quot; and refactor bar for future improvements. After successful savepoint, it is nosense to pretend &quot;all records have been added to the operators&quot; and &quot;flush all remaining buffered data&quot;. Just &quot;cleanup resources&quot; and exit is enough. Calling close() also hurt implementation as we have to guarantee &quot;flush all remaining buffered data&quot; to be success.&lt;/li&gt;
	&lt;li&gt;Another data flow event(or flag of EndOfPartition). Assumed that &quot;close&quot; is required, I think it is viable to replace &quot;isStoppingBySyncSavepoint&quot;, but also I think it is even more complicated than &quot;isStoppingBySyncSavepoint&quot; as it requires supports from more than one stack: network channels(eg. InputGates), stream tasks(eg. StreamTaskNetworkInput, StreamTask).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Given all above, I would say &quot;stop-with-savepoint&quot; as an utility method to &quot;take a savepoint and then exit&quot; does not deserve any extra semantics guarantees from streaming data flow comparing to &quot;cancel --savepoint&quot;.&lt;/p&gt;

&lt;p&gt;If we could reach above agreement, then I think the refactor is pretty simple, just &quot;take a savepoint, cleanup resources, then exit&quot; in single task. No data flow events will involving in. More importantly, we could clearly document that &quot;close&quot; will only be &quot;called after all records have been added to the operators&quot; to fix api semantics exception.&lt;/p&gt;</comment>
                            <comment id="17285209" author="pnowojski" created="Tue, 16 Feb 2021 14:03:34 +0000"  >&lt;p&gt;As I have mentioned in the &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21132&quot; title=&quot;BoundedOneInput.endInput is called when taking synchronous savepoint&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21132&quot;&gt;&lt;del&gt;FLINK-21132&lt;/del&gt;&lt;/a&gt;, in principle I also think replacing &lt;tt&gt;isStoppingBySyncSavepoint&lt;/tt&gt; with an event is a cleaner solution on the conceptual level.&lt;/p&gt;

&lt;p&gt;One extra complexity is a &lt;a href=&quot;https://github.com/apache/flink/pull/14831#issuecomment-774642652&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;closing handshake&lt;/a&gt; that we are probably going to introduce as a part of &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21086&quot; title=&quot;Support checkpoint alignment with finished input channels&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21086&quot;&gt;&lt;del&gt;FLINK-21086&lt;/del&gt;&lt;/a&gt;. Also it will mean we will need to support unaligned checkpoint overtaking current &lt;tt&gt;EndOfPartitionEvent&lt;/tt&gt;. Overtaking means also persisting as part of the checkpoint and later potentially restoring. &lt;/p&gt;

&lt;p&gt;From this perspective I would lean more towards adding a boolean flag to the &lt;tt&gt;EndOfPartitionEvent&lt;/tt&gt;, as opposed to adding new &lt;tt&gt;EndOfData&lt;/tt&gt; event. &lt;/p&gt;

&lt;p&gt;However the more I&apos;m thinking about, the less convinced I&apos;m if the added complexity of the &lt;tt&gt;EndOfData&lt;/tt&gt; (or enriching &lt;tt&gt;EndOfPartitionEvent&lt;/tt&gt; with a flag) is worth it. It looks to me like we would need to complicate quite a lot of the code in the network stack, to pass this &lt;tt&gt;EndOfData&lt;/tt&gt; to the &lt;tt&gt;StreamTask&lt;/tt&gt;.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;As &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; you mentioned, we would need to track how many inputs received &lt;tt&gt;EndOfPartitionEvent&lt;/tt&gt; and/or &lt;tt&gt;EndOfData&lt;/tt&gt;.&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;InputGate#isFinished&lt;/tt&gt; would have to be replaced with something more sophisticated (it&apos;s used in quite a bit of places).&lt;/li&gt;
	&lt;li&gt;The same applies to the return status of &lt;tt&gt;StreamTaskNetworkInput#emitNext&lt;/tt&gt; method. Currently it re-uses public facing enum &lt;tt&gt;InputStatus&lt;/tt&gt;. That would have to be changed, enriched as well and would probably affect other places as well (&lt;tt&gt;SortingDataInput&lt;/tt&gt;? &lt;tt&gt;MultiInputSortingDataInput&lt;/tt&gt;?).&lt;/li&gt;
	&lt;li&gt;Finally we would reach &lt;tt&gt;StreamOneInputProcessor#processInput&lt;/tt&gt; where we could ignore this end of input...&lt;/li&gt;
	&lt;li&gt;... but that would still not be enough. We would probably still need to set a flag in the &lt;tt&gt;OperatorChain&lt;/tt&gt; (basically a copy of the &lt;tt&gt;isStoppingBySyncSavepoint&lt;/tt&gt;), to pass the distinction between end of input and end of partition to the &lt;tt&gt;OperatorChain&lt;/tt&gt;... This is because end of the &lt;tt&gt;OperatorChain&lt;/tt&gt;/&lt;tt&gt;StreamTask&lt;/tt&gt; inputs and the defacto &lt;tt&gt;endOfInput&lt;/tt&gt; calls on the operators are quite far apart.&lt;/li&gt;
	&lt;li&gt;... &lt;tt&gt;OperatorChain&lt;/tt&gt; would need to handle the case, if one of its input has received &lt;tt&gt;EndOfPartition&lt;/tt&gt; and the other &lt;tt&gt;EndOfData&lt;/tt&gt;, so we would again need to duplicate the logic from 0.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;So we would add a lot of code (0., 1., 2., 3., 4., 6.) and we would end up with the same basic solution (5.)?&lt;/p&gt;

&lt;p&gt;Or am I missing something?&lt;/p&gt;

&lt;p&gt;CC &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=roman_khachatryan&quot; class=&quot;user-hover&quot; rel=&quot;roman_khachatryan&quot;&gt;roman_khachatryan&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17285219" author="pnowojski" created="Tue, 16 Feb 2021 14:11:14 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Given all above, I would say &quot;stop-with-savepoint&quot; as an utility method to &quot;take a savepoint and then exit&quot; does not deserve any extra semantics guarantees from streaming data flow comparing to &quot;cancel --savepoint&quot;.&lt;/p&gt;

&lt;p&gt;If we could reach above agreement, then I think the refactor is pretty simple, just &quot;take a savepoint, cleanup resources, then exit&quot; in single task. No data flow events will involving in. More importantly, we could clearly document that &quot;close&quot; will only be &quot;called after all records have been added to the operators&quot; to fix api semantics exception.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kezhuw&quot; class=&quot;user-hover&quot; rel=&quot;kezhuw&quot;&gt;kezhuw&lt;/a&gt; as I tried to mention a couple of time in the &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21132&quot; title=&quot;BoundedOneInput.endInput is called when taking synchronous savepoint&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21132&quot;&gt;&lt;del&gt;FLINK-21132&lt;/del&gt;&lt;/a&gt;. Simply &quot;take a savepoint, cleanup resources, then exit&quot; in a single task, disregarding what the upstream task is doing, can easily lead to a deadlock, if upstream task thread is blocked/fully backpressured. We could probably ignore this problem in network tasks and FLIP-27 sources, by just assuming that if downstream task received an aligned savepoint barrier, upstream task has completely paused production of records, so it&apos;s not backpressured. But this assumption doesn&apos;t hold with the legacy sources. Maybe it would also cause problems with iterations/cyclic graphs in the future.&lt;/p&gt;

&lt;p&gt;And I would be afraid that relaying on such kind of assumption might be fragile. Orderly shutdown from sources to the sinks is from this perspective safer.&lt;/p&gt;

&lt;p&gt;However I admit, that such approach has good advantages that you mentioned (not having to flush buffered records, faster closing etc).&lt;/p&gt;</comment>
                            <comment id="17285319" author="kezhuw" created="Tue, 16 Feb 2021 16:18:32 +0000"  >&lt;blockquote&gt;&lt;p&gt;But this assumption doesn&apos;t hold with the legacy sources. Maybe it would also cause problems with iterations/cyclic graphs in the future&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pnowojski&quot; class=&quot;user-hover&quot; rel=&quot;pnowojski&quot;&gt;pnowojski&lt;/a&gt;, I commented about &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21132?focusedCommentId=17276558&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-17276558&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;legacy source&lt;/a&gt; in &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21132?focusedCommentId=17276558&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-17276558&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;FLINK-21132&lt;/a&gt;. Legacy source always requires some special treatment in implementation. I have not evaluate iterations/cyclic graphs. I have assumption/expectation in implementation that when one task hit &quot;notifyCheckpointComplete&quot; in &quot;stop-with-savepoint&quot; path, all tasks will hit that point sooner or later, all we have to decide is how to exit(cooperative or independent). Before &quot;notifyCheckpointComplete&quot;, code-path for all approaches could be same.&lt;/p&gt;

&lt;p&gt;I am no trying to cling to one approach or even my approach, I wanted/want to finger out best approach by evaluating/comparing all emerging approaches.&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;&lt;tt&gt;EndOfPartition&lt;/tt&gt;: It works but not that elegant, and requires extra works from sources(chained or not).&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;EndOfData&lt;/tt&gt;: I have raised same concerns as you.&lt;/li&gt;
	&lt;li&gt;Stop task individually: downstream task could be terminated before upstream task. Could cause errors in network stack and potential deadlock.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I will also evaluate &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21086&quot; title=&quot;Support checkpoint alignment with finished input channels&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21086&quot;&gt;&lt;del&gt;FLINK-21086&lt;/del&gt;&lt;/a&gt; for further information.&lt;/p&gt;

&lt;p&gt;Besides my proposed approach for stop-with-savepoint, I also want to bring another separated question to attentions:&lt;/p&gt;

&lt;p&gt;Whether &lt;tt&gt;StreamOperator.close&lt;/tt&gt; should be called &lt;b&gt;only&lt;/b&gt; &quot;after all records have been added to the operators&quot; ?&lt;/p&gt;

&lt;p&gt;Currently, stop-with-savepoint is an exception for &lt;tt&gt;StreamOperator.close&lt;/tt&gt;. This may be also related to &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pnowojski&quot; class=&quot;user-hover&quot; rel=&quot;pnowojski&quot;&gt;pnowojski&lt;/a&gt;&apos;s recently 2pc concerns on FLIP-147 dicussion as &lt;tt&gt;StreamOperator.close&lt;/tt&gt; is just &lt;tt&gt;flush-after-all-input-consumed&lt;/tt&gt; from javadoc after &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-2647&quot; title=&quot;Stream operators need to differentiate between close() and dispose()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-2647&quot;&gt;&lt;del&gt;FLINK-2647&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="17285367" author="stephanewen" created="Tue, 16 Feb 2021 17:31:20 +0000"  >&lt;p&gt;The complexity of adding a new &lt;tt&gt;EndOfData&lt;/tt&gt; event, versus a flag to the the &lt;tt&gt;EndOfPartition&lt;/tt&gt; event seem to be pretty similar, because the complexity lies in the book-keeping and how to handle the information.&lt;/p&gt;

&lt;p&gt;What I really like is the idea to change the definitions slightly so that we do not have to distinguish these cases at all, and that &lt;tt&gt;EndOfPartition&lt;/tt&gt; and &lt;tt&gt;EndOfData&lt;/tt&gt; is always the same, and we need no extra flags.&lt;/p&gt;


&lt;h3&gt;&lt;a name=&quot;StopwithSavepoint%2Cnodraining&quot;&gt;&lt;/a&gt;Stop-with-Savepoint, no draining&lt;/h3&gt;

&lt;p&gt;This simple variant (the &lt;em&gt;&quot;suspend case&quot;&lt;/em&gt;) could just become a &quot;cancel with savepoint&quot;, as &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kezhuw&quot; class=&quot;user-hover&quot; rel=&quot;kezhuw&quot;&gt;kezhuw&lt;/a&gt; mentioned.&lt;br/&gt;
There is no need to cleanly shut down streams. After the &quot;&lt;tt&gt;notifyCheckpointComplete()&lt;/tt&gt;&quot; call, the action just throws a &lt;tt&gt;CancelTaskException&lt;/tt&gt; and the pipeline shuts down.&lt;/p&gt;

&lt;p&gt;That means no &lt;tt&gt;EndOfPartition&lt;/tt&gt; would be involved, and &quot;&lt;tt&gt;close()&lt;/tt&gt;&quot; and &quot;&lt;tt&gt;finishInput()&lt;/tt&gt;&quot; would not be called. So we could get rid of all the special cases.&lt;/p&gt;

&lt;p&gt;Maybe this needs some JM side work, meaning supporting that the scheduler goes into &quot;cancelling&quot; state without actually triggering the &quot;cancel()&quot; on the tasks, yet. And that it goes into global recovery if a task fails in that state.&lt;br/&gt;
That would also be a clean way to handle &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21030&quot; title=&quot;Broken job restart for job with disjoint graph&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21030&quot;&gt;&lt;del&gt;FLINK-21030&lt;/del&gt;&lt;/a&gt; (issue around &quot;stop with savepoint&quot; and regional recovery /cc &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trohrmann&quot; class=&quot;user-hover&quot; rel=&quot;trohrmann&quot;&gt;trohrmann&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;IIRC, the reason that the stop-with-savepoint implementation currently shuts down &quot;cleanly&quot; was so no changes on the JM would be necessary. But in hind-sight, it looks like JM changes are necessary anyways (&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21030&quot; title=&quot;Broken job restart for job with disjoint graph&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21030&quot;&gt;&lt;del&gt;FLINK-21030&lt;/del&gt;&lt;/a&gt;) and that with those changes we also get cleaner semantics. Plus, this operation would work with unaligned checkpoints and other future flavors of checkpoints as well.&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;StopwithSavepoint%2Cwithpipelinedraining&quot;&gt;&lt;/a&gt;Stop-with-Savepoint, with pipeline draining&lt;/h3&gt;

&lt;p&gt;This looks like the same thing as the feature that shuts down a bounded stream with a checkpoint.&lt;br/&gt;
The only difference is that mailbox on the sources exits its default action (reading from the sources) due to the &quot;stop()&quot; RPC call, rather than because of the &quot;EndOfInput&quot; status. Here everything shuts down with &lt;tt&gt;EndOfPartition&lt;/tt&gt; which is also simultaneously &lt;tt&gt;EndOfData&lt;/tt&gt;. The &lt;tt&gt;finishInput()&lt;/tt&gt; and &lt;tt&gt;close()&lt;/tt&gt; methods actually get called.&lt;/p&gt;

&lt;p&gt;To support specifying a savepoint for that shutdown, we would need to be able to shut down the dataflow pipeline with one checkpoint in total. That would be interesting input for the &lt;a href=&quot;https://cwiki.apache.org/confluence/display/FLINK/FLIP-147%3A+Support+Checkpoints+After+Tasks+Finished&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;FLIP-147&lt;/a&gt; discussion.&lt;/p&gt;</comment>
                            <comment id="17286380" author="becket_qin" created="Thu, 18 Feb 2021 09:25:52 +0000"  >&lt;p&gt;It looks that we are aiming to get a long term solution here. My two cents:&lt;/p&gt;

&lt;p&gt;At a high level, in Flink any control logic initiated from JM eventually goes to one of the following two types / mechanisms.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;independent point-to-point control (e.g. all JM to TM RPC)
	&lt;ul&gt;
		&lt;li&gt;This is an &quot;out-of-band&quot; control flow, pretty much requests / responses between JM and TMs.&lt;/li&gt;
		&lt;li&gt;In order to make sure the tasks will respond to the control command, the mailbox thread may have to be interrupted from a blocking call.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;job-graph wide coordinated / orderly control (e.g. checkpoint, EndOfPartition)
	&lt;ul&gt;
		&lt;li&gt;This is a control flow combining &quot;out-of-band&quot; and &quot;in-band&quot; mechanism&lt;/li&gt;
		&lt;li&gt;JM sends the command to Sources via RPC (i.e. out-of-band)&lt;/li&gt;
		&lt;li&gt;Sources execute the command, then propagate the command to downstream operators in data stream (in-band)&lt;/li&gt;
		&lt;li&gt;The downstream operators receives the command from its input data stream (in-band)&lt;/li&gt;
		&lt;li&gt;JM receives the ack from all the operators and complete the control logic. (out-of-band)&lt;/li&gt;
		&lt;li&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Optional&amp;#93;&lt;/span&gt; JM notifies all the TMs about the execution result (out-of-band)&#160;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;When it comes to &lt;tt&gt;StopWithSavePoint&lt;/tt&gt;, to me the most intuitive semantic is that the tasks naturally stop right after taking the savepoint without any side effects. That means:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;The operators / tasks stop processing records right after the savepoint is taken.&lt;/li&gt;
	&lt;li&gt;The operators / tasks do not receive &lt;tt&gt;EndOfPartition&lt;/tt&gt;&#160;/ &lt;tt&gt;EndOfInput&lt;/tt&gt;&#160;because these events have already been assigned other meanings.&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;StreamOperator.close()&lt;/tt&gt;&#160;should not be invoked to confuse the operators. Instead, &lt;tt&gt;Stream&lt;/tt&gt;&lt;tt&gt;Operator.dispose()&lt;/tt&gt;&#160;should be invoked directly.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;At this point, I think the second control flow would just work. As long as we adjust the behavior of &lt;tt&gt;StreamTask&lt;/tt&gt;&#160;a little bit.&lt;/p&gt;

&lt;p&gt;Implementation wise, would the following work?&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;The JM sends to Sources a &quot;StopWithSavepoint&quot; RPC&lt;/li&gt;
	&lt;li&gt;The Sources take a snapshot, sends a checkpoint barrier with a flag indicating stop after checkpointing, then it stops processing data but just blocks on mailbox. This could be done either via a state machine for the task or simply a flag.&lt;/li&gt;
	&lt;li&gt;The downstream tasks align the checkpoint barrier, take their own snapshots, send the barrier to downstream tasks, then also block on mailbox.&lt;/li&gt;
	&lt;li&gt;After the JM finalize the checkpoint, it notifies the tasks of the completion of the checkpoint and the tasks will then exit.&lt;/li&gt;
	&lt;li&gt;When the tasks exit, the operators are not closed, but disposed directly.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;For the legacy sources, I agree with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kezhuw&quot; class=&quot;user-hover&quot; rel=&quot;kezhuw&quot;&gt;kezhuw&lt;/a&gt;&#160;that special treatment might be inevitable.&lt;/p&gt;</comment>
                            <comment id="17287105" author="pnowojski" created="Fri, 19 Feb 2021 14:50:34 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=becket_qin&quot; class=&quot;user-hover&quot; rel=&quot;becket_qin&quot;&gt;becket_qin&lt;/a&gt; I think you are missing the &lt;b&gt;Stop-with-Savepoint, with pipeline draining&lt;/b&gt; case, which &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; mentioned. There, we are emitting &lt;tt&gt;MAX_WATERMARK&lt;/tt&gt; with &lt;tt&gt;advanceToEndOfEventTime&lt;/tt&gt; case. In that case we probably should follow the standard clean shutdown procedure. I don&apos;t know if we should invoke &lt;tt&gt;endOfInput&lt;/tt&gt; on the operators in that case or not... I would guess probably yes. If we are flushing window operators, we would also want to flush all buffered records. And if we are never intending to resume this job, &lt;tt&gt;endOfInput&lt;/tt&gt; makes kind of sense for the downstream operators?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt;, generally speaking I like the idea of changing stop with savepoint (without the drain), to cancel with savepoint. As me and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=roman_khachatryan&quot; class=&quot;user-hover&quot; rel=&quot;roman_khachatryan&quot;&gt;roman_khachatryan&lt;/a&gt; mentioned previously, we would like to avoid controlling the flow with exceptions. But that should be as easy to replace throwing `CancelTaskException` with just `StreamTask#cancel` call. &lt;/p&gt;

&lt;p&gt;However I still do not see how one would solve the problem of fully/completely backpressured legacy source task. In this case, source thread can be perpetually blocked while holding &lt;tt&gt;checkpointLock&lt;/tt&gt;, thus preventing &lt;tt&gt;notifyCheckpointComplete&lt;/tt&gt; from being ever executed. Maybe we would need to spin using &lt;tt&gt;StreamTask#runSynchronousSavepointMailboxLoop&lt;/tt&gt; while triggering the checkpoint, and thus also blocking source thread from making any progress after triggering the checkpoint?&lt;/p&gt;

&lt;p&gt;Secondly &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; as we discussed offline. We would have to make sure that downstream/upstream task would cancel correctly, without mis-leading error messages, if they receive network connection closed before processing &lt;tt&gt;notifyCheckpointComplete()&lt;/tt&gt;. I haven&apos;t looked how this would affect the code, maybe that&apos;s not an issue and it would work as it is, but it has to be verified.&lt;/p&gt;</comment>
                            <comment id="17287451" author="becket_qin" created="Sat, 20 Feb 2021 01:56:24 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pnowojski&quot; class=&quot;user-hover&quot; rel=&quot;pnowojski&quot;&gt;pnowojski&lt;/a&gt;&#160;I might get a little confused about what options we eventually want to provide to the users. It would probably help to clarify that first. I am thinking of the following cases:&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Cancel&lt;/b&gt;&#160;- Stop the job without any data integrity guarantee. The job will not be able to resume, the output from the job is not guaranteed to be consistent. It is similar to a force quit.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Stop&lt;/b&gt;&#160;- Stop the job elegantly without the intention to resume the job. This is an orderly shutdown without a savepoint. It lets all the records in the pipeline get processed. &lt;tt&gt;MAX_WATERMARK&lt;/tt&gt;&#160;will be emitted to ensure the final result gets written to the output. &lt;tt&gt;EndOfPartition&lt;/tt&gt;&#160;will also be emitted as if all the records have been processed.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Stop with Savepoint (Suspend / Pause)&lt;/b&gt; - Stop the job elegantly with the intention to resume the job. This is also an orderly shutdown but with a savepoint taken. It lets all the records in the pipeline get processed. No &lt;tt&gt;MAX_WATERMARK&lt;/tt&gt;&#160;or &lt;tt&gt;EndOfPartition&lt;/tt&gt;&#160;will be emitted because the job is supposed to be resumed later.&lt;/p&gt;</comment>
                            <comment id="17287735" author="kezhuw" created="Sat, 20 Feb 2021 16:52:31 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=becket_qin&quot; class=&quot;user-hover&quot; rel=&quot;becket_qin&quot;&gt;becket_qin&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pnowojski&quot; class=&quot;user-hover&quot; rel=&quot;pnowojski&quot;&gt;pnowojski&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; Thanks all for recently discussions. It helps me a lot in understanding&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/tongue.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; I like the idea of clear-distinction between suspend and pipeline-draining cases and &quot;shut down the dataflow pipeline with one checkpoint in total&quot;. The semantics of `StreamOperator.close` back to no exception again in condition of clean definition of pipeline-draining case.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=becket_qin&quot; class=&quot;user-hover&quot; rel=&quot;becket_qin&quot;&gt;becket_qin&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pnowojski&quot; class=&quot;user-hover&quot; rel=&quot;pnowojski&quot;&gt;pnowojski&lt;/a&gt; I am kind of unsure what is the difference between pipeline-draining case and existing &quot;terminate&quot; case ? Where checkpoint should happen in pipeline-draining case ? At trigger/barrier or after end-of-stream-flush ? In case of trigger/barrier(eg. just like existing &quot;terminate&quot; case), there is no big code-path difference comparing to suspend case but clean definition. In case of after end-of-stream-flush, it is nearly an real terminal operation, the savepoint may be hard to resume from. In &quot;after end-of-stream-flush&quot; case, I think it is tight related to FLIP-147. In either case, currently FLIP-143 sink does not work out with single checkpoint.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;Maybe we would need to spin using StreamTask#runSynchronousSavepointMailboxLoop while triggering the checkpoint, and thus also blocking source thread from making any progress after triggering the checkpoint?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pnowojski&quot; class=&quot;user-hover&quot; rel=&quot;pnowojski&quot;&gt;pnowojski&lt;/a&gt; I think it is a must, otherwise if downstream closed before source, &lt;tt&gt;SourceContext.collect&lt;/tt&gt; will fail before &lt;tt&gt;notifyCheckpointComplete&lt;/tt&gt;.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;We would have to make sure that downstream/upstream task would cancel correctly, without mis-leading error messages, if they receive network connection closed before processing &lt;tt&gt;notifyCheckpointComplete()&lt;/tt&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pnowojski&quot; class=&quot;user-hover&quot; rel=&quot;pnowojski&quot;&gt;pnowojski&lt;/a&gt;  Currently, &lt;tt&gt;RecordWriter&lt;/tt&gt; reports error by lazy checking. I think it make sense as network error may caused by caller module intentionally. But I also saw exception swallowed in &lt;tt&gt;PartitionRequestQueue.handleException&lt;/tt&gt;. Anyway, it deserves more attentions.&lt;/p&gt;

&lt;p&gt;Other issue about chained source in &lt;tt&gt;MultipleInputStreamTask.triggerCheckpointAsync&lt;/tt&gt;: &lt;tt&gt;advanceToEndOfEventTime&lt;/tt&gt; is ignored.&lt;/p&gt;</comment>
                            <comment id="17288240" author="gaoyunhaii" created="Mon, 22 Feb 2021 08:13:59 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt;&#160;very thanks for the deep insights!&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;To support specifying a savepoint for that shutdown, we would need to be able to shut down the dataflow pipeline with one checkpoint in total. That would be interesting input for the&#160;FLIP-147&#160;discussion&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I tried to think a bit on this issue: for stop with savepoint with pipeline draining, our main target is to get a consistent savepoint for all the tasks. Meanwhile, in considering of the case that the savepoint fails and then we need resume the job, it seems we would still need to first triggering a savepoint, and holding the tasks until the savepoint succeed, then the tasks get to the finish process (e.g., endOfInput &amp;amp; close). In this case we would need a savepoint &lt;em&gt;before&lt;/em&gt; the end of input for each operator.&lt;/p&gt;

&lt;p&gt;For&#160;shut down a bounded stream with a checkpoint, our main target would be for operators interact with external systems, we need to get the pending data committed &lt;em&gt;after&lt;/em&gt; processed all the records (e.g., endOfInput), which makes it a bit divergent from stopping with savepoint. On the other side, in this case it would not necessary for all the operators to commit their pending records in one checkpoint (but I totally agree with it would be good to reduce the number of checkpoints required).&lt;/p&gt;

&lt;p&gt;Due to this difference, it seems to me that it might be not easy to unify the two processes?&lt;/p&gt;

&lt;p&gt;If we only consider whether we could shuts down&#160;a bounded stream with a single checkpoint, since we could not broadcast barriers after emitting &lt;tt&gt;EndOfPartitionEvent&lt;/tt&gt;, we might have to introduce a new &lt;tt&gt;EndOfInputEvent&lt;/tt&gt; to notify the endOfInput separately, then take a unified checkpoint,&#160; and emit&#160;&lt;tt&gt;EndOfPartitionEvent&lt;/tt&gt; finally. There might be still two problem here, one is whether we want to&#160;&lt;a href=&quot;https://lists.apache.org/thread.html/rc15b3f7f4ee3b94132f1da8f0b7e988607bccdc2eec49cf156061744%40%3Cdev.flink.apache.org%3E&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;support emitting records in notifyCheckpointComplete&lt;/a&gt;, another is that since we could not guarantee when the sources would finish, we may have to holding the finished tasks for a long time, and the extreme case would be for mixed jobs with both bounded and unbounded sources, in this case we would have to hold the finished tasks forever ? Thus I think even after we introduce&#160;&lt;tt&gt;EndOfInputEvent&lt;/tt&gt; and not emit records in notifyCheckpointComplete, we might still not need to limit the tasks to wait for a single checkpoint.&#160;&lt;/p&gt;</comment>
                            <comment id="17288340" author="till.rohrmann" created="Mon, 22 Feb 2021 11:41:21 +0000"  >&lt;p&gt;Thanks for driving this discussion. I think a lot of things are coming together here because shutdown/closing semantics of operators are tightly coupled to how sources and sinks must work and it should ideally work for bounded/unbounded streams and batch/streaming execution mode similarly.&lt;/p&gt;

&lt;p&gt;I think it is a good idea to think about what functionality we want to offer to our users as &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=becket_qin&quot; class=&quot;user-hover&quot; rel=&quot;becket_qin&quot;&gt;becket_qin&lt;/a&gt; did it before diving into the concrete implementation details:&lt;/p&gt;

&lt;p&gt;1. &lt;b&gt;A user wants to cancel a bounded/unbounded job and does not care about the output correctness&lt;/b&gt;&lt;br/&gt;
This is what we currently support with &lt;tt&gt;Task.cancelExecution&lt;/tt&gt;. Cancel should forcefully terminate the operators and we don&apos;t care whether records are properly sent to downstream tasks or written to a sink.&lt;/p&gt;

&lt;p&gt;2. &lt;b&gt;A user wants to suspend a bounded/unbounded job and wants to be able to resume it later&lt;/b&gt;&lt;br/&gt;
This is what we currently call *&lt;b&gt;stop-with-savepoint&lt;/b&gt;*. Here the user wants to create a savepoint representing the current state of the computation which he can use to resume the job at a later point. The user does not care about whether the job shuts down orderly or not. Hence, we should be able to simply cancel all tasks after taking the savepoint.&lt;/p&gt;

&lt;p&gt;3. &lt;b&gt;A user wants to terminate a bounded/unbounded job and wants all of its buffered data to be flushed to external systems&lt;/b&gt;&lt;br/&gt;
This is what we currently call &lt;b&gt;stop-with-savepoint --drain&lt;/b&gt;. Here the user is not so much interested in the savepoint as in materializing the job&apos;s state/result to external systems. The only use case for the created savepoint here I could think of is to get access to Flink&apos;s state after the job has terminated. Resuming the job from such a savepoint does not make much sense because the results will be affected by the &lt;tt&gt;MAX_WATERMARK&lt;/tt&gt; we have sent. Maybe &lt;b&gt;stop-with-savepoint --drain&lt;/b&gt; is a misnomer.&lt;/p&gt;

&lt;p&gt;4. &lt;b&gt;A bounded job reaches its end and in order to guarantee correctness needs to flush als its buffered data&lt;/b&gt;&lt;br/&gt;
This effectively the same as terminating a bounded/unbounded job just that it is not induced by the user but by the sources reaching the end of data.&lt;/p&gt;

&lt;p&gt;5. &lt;b&gt;A user wants to gracefully stop its job w/o creating a savepoint&lt;/b&gt;&lt;br/&gt;
The only case I can think of is that a user wants to stop an at-least-once job in such a way that all records up to the point of issuing the command will get processed. Other than that cancel might already be good enough.&lt;/p&gt;

&lt;p&gt;Conceptually, 3. and 4. should use the same mechanism because semantically, there is no difference &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=gaoyunhaii&quot; class=&quot;user-hover&quot; rel=&quot;gaoyunhaii&quot;&gt;gaoyunhaii&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I agree with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kezhuw&quot; class=&quot;user-hover&quot; rel=&quot;kezhuw&quot;&gt;kezhuw&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; that 2. should not require the complexity of shutting the job gracefully down. E.g. by allowing the state transition &lt;tt&gt;RUNNING -&amp;gt; CANCELLED&lt;/tt&gt; on the &lt;tt&gt;JobMaster&lt;/tt&gt; could allow the &lt;tt&gt;Tasks&lt;/tt&gt; to simply cancel themselves after receiving &lt;tt&gt;notifyCheckpointComplete&lt;/tt&gt;. Alternatively, &lt;tt&gt;Tasks&lt;/tt&gt; could acknowledge the &lt;tt&gt;notifyCheckpointComplete&lt;/tt&gt; but this adds complexity to the already complex &lt;tt&gt;CheckpointCoordinator&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;Whether we need multiple checkpoints to shut down a job in case of 3. and 4. probably depends on whether we allow records to be sent after the final &lt;tt&gt;notifyCheckpointComplete&lt;/tt&gt; has been executed for a &lt;tt&gt;Task&lt;/tt&gt; or not. Intuitively, not having to shut down a job with multiple checkpoints seems more desirable for me.&lt;/p&gt;

&lt;p&gt;If this were the case and if we could still create a checkpoint after a &lt;tt&gt;StreamOperator.close&lt;/tt&gt; has been called, then we could simply send a &lt;tt&gt;EndOfPartitionEnvent&lt;/tt&gt; when an operator reaches the end of input or receives the &lt;b&gt;terminate&lt;/b&gt; call. Next, the &lt;tt&gt;StreamTask&lt;/tt&gt; would only have to wait for a checkpoint to succeed before terminating. &lt;/p&gt;</comment>
                            <comment id="17288467" author="pnowojski" created="Mon, 22 Feb 2021 16:34:36 +0000"  >&lt;p&gt;+1 for those use cases/semantics summarised by &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trohrmann&quot; class=&quot;user-hover&quot; rel=&quot;trohrmann&quot;&gt;trohrmann&lt;/a&gt;. I agree that 3. and 4. are also effectively the same. Maybe trying to conclude various loose threads that we had here. I see the following, mostly independent, issues:&lt;/p&gt;

&lt;p&gt;a) Two phase commit support for 3. and 4. This will be dealt by FLIP-147 (please check the discussion on the dev mailing list)&lt;br/&gt;
b) Unfortunately in &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21132&quot; title=&quot;BoundedOneInput.endInput is called when taking synchronous savepoint&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21132&quot;&gt;&lt;del&gt;FLINK-21132&lt;/del&gt;&lt;/a&gt; we broke 3. (&lt;b&gt;stop-with-savepoint --drain&lt;/b&gt;). In this case, `endOfInput()` should be called (CC &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=roman_khachatryan&quot; class=&quot;user-hover&quot; rel=&quot;roman_khachatryan&quot;&gt;roman_khachatryan&lt;/a&gt;). Otherwise, some operators are not flushing/draining the buffered state (like for example &lt;tt&gt;AsyncWaitOperator&lt;/tt&gt;, which is doing it only in the &lt;tt&gt;endOfInput()&lt;/tt&gt; call). Note that before &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21132&quot; title=&quot;BoundedOneInput.endInput is called when taking synchronous savepoint&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21132&quot;&gt;&lt;del&gt;FLINK-21132&lt;/del&gt;&lt;/a&gt;, 3. was working correctly only if we ignore the issue of committing side effects (two phase commit support). &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21453&quot; title=&quot;BoundedOneInput.endInput is NOT called when doing stop with savepoint WITH drain&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21453&quot;&gt;&lt;del&gt;FLINK-21453&lt;/del&gt;&lt;/a&gt; will fix this problem.&lt;br/&gt;
c) Changing 2., from &quot;stop with savepoint&quot; to &quot;cancel with savepoint&quot;. Previously I thought about it as a refactor/clean up AND optimisation (speed up of the shutdown). However, as we can not used this approach for 3., I think it&apos;s just an optimisation that would diverge the code base. For this reason I think it would be better to postpone such optimisation after FLIP-147 is done (if ever).&lt;br/&gt;
d) FLIP-27 not supporting stop with savepoint (both 3. and 4.)&lt;/p&gt;</comment>
                            <comment id="17288477" author="kezhuw" created="Mon, 22 Feb 2021 16:56:35 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trohrmann&quot; class=&quot;user-hover&quot; rel=&quot;trohrmann&quot;&gt;trohrmann&lt;/a&gt; Great summarization!&lt;/p&gt;

&lt;p&gt;About user-case#2, we may need to handle failed &lt;tt&gt;notifyCheckpointComplete&lt;/tt&gt;, otherwise some 2pc context could lost during downtime(eg. kafka transaction timeout). A successful &quot;stop-with-savepoint&quot; should commit all side effects to visible and keep user from worry about downtime. This also requires &quot;shut down the dataflow pipeline with one checkpoint in total&quot;. All these apply to user-case#3 too.&lt;/p&gt;

&lt;p&gt;About user-case#3, currently &quot;stop-with-savepoint --drain&quot; takes snapshot before end-of-input, so some end-of-input-flushing works are not taken into savepoint. For example, &lt;tt&gt;AsyncWaitOperator.endInput&lt;/tt&gt; is called after savepoint before &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21132&quot; title=&quot;BoundedOneInput.endInput is called when taking synchronous savepoint&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21132&quot;&gt;&lt;del&gt;FLINK-21132&lt;/del&gt;&lt;/a&gt;. I think what &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; described in &quot;pipeline draining&quot; may deserve a more destructive name, say &quot;terminate&quot;. To behave as an real terminal operation, the savepoint should be taken after end-of-input-flushing operation.&lt;/p&gt;

&lt;p&gt;About user-case#4, I agree it should be no much difference to user-case#3 as long as we don&apos;t force to hold finished sources before checkpoint. Before the last checkpoint, there could be only partial or even only one task in running and waiting/expecting a checkpoint to commit side effects. I think this should be part of FLIP-147&apos;s goal. If we are targeting one checkpoint/savepoint for all tasks in this cases, it is may not that worth as there could be multiple sources exhausted at different time. But I think it has value that all tasks&apos; states are preserved after last checkpoint/savepoint. If this is the case, I think the last checkpoint/savepoint should be same as user-case#3.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;If this were the case and if we could still create a checkpoint after a StreamOperator.close has been called, then we could simply send a EndOfPartitionEnvent when an operator reaches the end of input or receives the terminate call. Next, the StreamTask would only have to wait for a checkpoint to succeed before terminating.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I would say it is attractive!&lt;/p&gt;

&lt;p&gt;Currently, &lt;tt&gt;StreamOperator.close&lt;/tt&gt; was used to both &quot;flushing buffered data&quot; and &quot;cleanup resources&quot;, while &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-2647&quot; title=&quot;Stream operators need to differentiate between close() and dispose()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-2647&quot;&gt;&lt;del&gt;FLINK-2647&lt;/del&gt;&lt;/a&gt; tried to claim &lt;b&gt;&quot;Distinguish between &quot;close&quot; (flushing buffered data) and &quot;dispose&quot; (cleanup resources) in streaming operators&quot;&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;Here is what I have seen:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-16383&quot; title=&quot;KafkaProducerExactlyOnceITCase.testExactlyOnceRegularSink fails with &amp;quot;The producer has already been closed&amp;quot;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-16383&quot;&gt;&lt;del&gt;FLINK-16383&lt;/del&gt;&lt;/a&gt; ignores &lt;tt&gt;notifyCheckpointComplete&lt;/tt&gt; after operator closed.&lt;/li&gt;
	&lt;li&gt;I thought &lt;tt&gt;notifyCheckpointAborted&lt;/tt&gt; should not be invoked after &lt;tt&gt;StreamOperator.close&lt;/tt&gt; before(&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-20389&quot; title=&quot;UnalignedCheckpointITCase failure caused by NullPointerException&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-20389&quot;&gt;&lt;del&gt;FLINK-20389&lt;/del&gt;&lt;/a&gt;).&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-20781&quot; title=&quot;UnalignedCheckpointITCase failure caused by NullPointerException&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-20781&quot;&gt;&lt;del&gt;FLINK-20781&lt;/del&gt;&lt;/a&gt; &lt;tt&gt;SourceOperator&lt;/tt&gt; has to deal with &lt;tt&gt;notifyCheckpointAborted&lt;/tt&gt; after &lt;tt&gt;StreamOperator.close&lt;/tt&gt; due to resources cleaned.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;There should be more I am not aware of and involved in.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Not &quot;allow records to be sent after the final &lt;tt&gt;notifyCheckpointComplete&lt;/tt&gt; has been executed&quot;&lt;/li&gt;
	&lt;li&gt;&quot;we could still create a checkpoint after a StreamOperator.close has been called&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Sadly, both will break something.&lt;/p&gt;</comment>
                            <comment id="17289922" author="pnowojski" created="Wed, 24 Feb 2021 13:32:59 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kezhuw&quot; class=&quot;user-hover&quot; rel=&quot;kezhuw&quot;&gt;kezhuw&lt;/a&gt;:&lt;br/&gt;
#2, if stop-with-savepoint fails, job can just continue. The problem is in case 3. and 4., where the only viable solution is I think to restart the job from last checkpoint/savepoint. I don&apos;t think this is happening right now?&lt;/p&gt;

&lt;p&gt;#3, please check FLIP-147 dev mailing list discussion. There is my proposal how to address this problem.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If this were the case and if we could still create a checkpoint after a StreamOperator.close has been called, then we could simply send a EndOfPartitionEnvent when an operator reaches the end of input or receives the terminate call. Next, the StreamTask would only have to wait for a checkpoint to succeed before terminating.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That would brake the current &lt;tt&gt;@Public&lt;/tt&gt; API. For example our own &lt;tt&gt;FlinkKafkaProducer&lt;/tt&gt; would stop working &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; And as you mentioned &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trohrmann&quot; class=&quot;user-hover&quot; rel=&quot;trohrmann&quot;&gt;trohrmann&lt;/a&gt; it wouldn&apos;t solve the problem of shutting the operators one by one if they need to emit something in the &lt;tt&gt;notifyCheckpointComplete()&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="17290197" author="till.rohrmann" created="Wed, 24 Feb 2021 18:57:15 +0000"  >&lt;p&gt;For #2, we should fail the stop-with-savepoint operation if the &lt;tt&gt;notifyCheckpointComplete&lt;/tt&gt; fails and resume the job from the last checkpoint. In this case it would actually be the just created savepoint. Whether we need to restart tasks or not depends on where the failure occurs. #3 and #4 should actually be quite similar in this regard. &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-21030&quot; title=&quot;Broken job restart for job with disjoint graph&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-21030&quot;&gt;&lt;del&gt;FLINK-21030&lt;/del&gt;&lt;/a&gt; should fix that we restart in case of a failure after the savepoint has been successfully created.&lt;/p&gt;

&lt;p&gt;I think it is not important that we keep finished operators running for the final checkpoint. If some operators have finished before the overall job reaches the final checkpoint, then these operators can shut down with a previous checkpoint. We somehow just need to remember that these operators were already completed in case we need to restart the job if a failure happened in &lt;tt&gt;notifyCheckpointComplete&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;I am pretty certain that our current API is not sufficient for expressing what we want to express (e.g. not being able to take a checkpoint after we have flushed all records from an operator via &lt;tt&gt;StreamOperator.close&lt;/tt&gt;). Breaking an API is never good but it should also not hinder us to think about how things should ideally look like and then think about how we could get there. Ideally we don&apos;t have to break things but if the current APIs do not allow to express the behaviour we need our operators to have, then at some point we have to take this bullet. In doubt I would prefer this compared to working around the current limitations and never being able to properly define the required operator semantics.&lt;/p&gt;
</comment>
                            <comment id="17290206" author="pnowojski" created="Wed, 24 Feb 2021 19:08:39 +0000"  >&lt;p&gt;I agree about that we might need to change the API somehow, but maybe there are less invasive changes. Calling `notifyCheckpointComplete()` after closing will be very invasive/affecting silently a lot of built in and user functions/operators. I would hope there are other options. For example IMO renaming `close()` to `flush()` or `finish()` combined with a contract that `notifyCheckpointComplete()` (and other checkpointing calls) can be called between `finish()` and `dispose()` would be better. It would be just as invasive, but as at least user code would not brake silently. But keep in mind that at the moment on the user functions level we even don&apos;t have `dispose()` :/ Let&apos;s maybe move this particular discussion to FLIP-147 discussion thread?&lt;/p&gt;</comment>
                            <comment id="17290782" author="till.rohrmann" created="Thu, 25 Feb 2021 08:44:06 +0000"  >&lt;p&gt;Yes, let&apos;s move this discussion to the FLIP-147 discussion thread. Let&apos;s use this ticket to discuss how to fix the FLIP-27 sources for stop-with-savepoint even if it is just a quick fix for the time being.&lt;/p&gt;</comment>
                            <comment id="17307100" author="kezhuw" created="Tue, 23 Mar 2021 14:08:11 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=trohrmann&quot; class=&quot;user-hover&quot; rel=&quot;trohrmann&quot;&gt;trohrmann&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pnowojski&quot; class=&quot;user-hover&quot; rel=&quot;pnowojski&quot;&gt;pnowojski&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=becket_qin&quot; class=&quot;user-hover&quot; rel=&quot;becket_qin&quot;&gt;becket_qin&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; Hi all, should we try a fix before 1.13 for possible sole &lt;tt&gt;SourceOperatorStreamTask&lt;/tt&gt; ? I think it is worth to not block &lt;tt&gt;SourceOperatorStreamTask&lt;/tt&gt; on more complicated issues. I guess part of stop-with-savepoint is blocked on FLIP-147.&lt;/p&gt;

&lt;p&gt;Besides this, is it worth an umbrella issue to track/marshal stop-with-savepoint issues in total ? The discussion in this thread is far beyond FLIP-27 source.&lt;/p&gt;</comment>
                            <comment id="17307109" author="stephanewen" created="Tue, 23 Mar 2021 14:17:28 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=becket_qin&quot; class=&quot;user-hover&quot; rel=&quot;becket_qin&quot;&gt;becket_qin&lt;/a&gt; and me talked about this quickly: We agree, to just enable stop-with-savepoint for the FLIP-27 sources, it looks like we need just a simple addition in the &lt;tt&gt;SourceOperatorStreamTask&lt;/tt&gt;. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=becket_qin&quot; class=&quot;user-hover&quot; rel=&quot;becket_qin&quot;&gt;becket_qin&lt;/a&gt; mentioned he wants to look into that.&lt;/p&gt;

&lt;p&gt;The bigger FLIP-147 fix will be part of a later release once the design/approach has converged.&lt;/p&gt;</comment>
                            <comment id="17307116" author="kezhuw" created="Tue, 23 Mar 2021 14:23:35 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=becket_qin&quot; class=&quot;user-hover&quot; rel=&quot;becket_qin&quot;&gt;becket_qin&lt;/a&gt; Good news!&lt;/p&gt;</comment>
                            <comment id="17322856" author="flink-jira-bot" created="Fri, 16 Apr 2021 10:47:01 +0000"  >&lt;p&gt;This issue is assigned but has not received an update in 7 days so it has been labeled &quot;stale-assigned&quot;. If you are still working on the issue, please give an update and remove the label. If you are no longer working on the issue, please unassign so someone else may work on it. In 7 days the issue will be automatically unassigned.&lt;/p&gt;</comment>
                            <comment id="17324804" author="till.rohrmann" created="Mon, 19 Apr 2021 07:55:18 +0000"  >&lt;p&gt;Are we going to have a quick fix for this problem in 1.13.0 &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sewen&quot; class=&quot;user-hover&quot; rel=&quot;sewen&quot;&gt;sewen&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=becket_qin&quot; class=&quot;user-hover&quot; rel=&quot;becket_qin&quot;&gt;becket_qin&lt;/a&gt;?&lt;/p&gt;</comment>
                            <comment id="17325085" author="becket_qin" created="Mon, 19 Apr 2021 14:38:41 +0000"  >&lt;p&gt;Patch merged.&lt;/p&gt;

&lt;p&gt;master:&#160;&#160;a9cf18b4d25f130e0bd24d51b128bbcf71892b45&lt;br/&gt;
release-1.12:&#160;0913824dda91b04612f2f885052635e0ca78f5b3&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="13360390">FLINK-21469</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13353251">FLINK-21028</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13357621">FLINK-21323</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13360289">FLINK-21453</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13195414">FLINK-10740</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 30 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z0myt4:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>