<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:34:04 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-9676] Deadlock during canceling task and recycling exclusive buffer</title>
                <link>https://issues.apache.org/jira/browse/FLINK-9676</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;It may cause deadlock between task canceler thread and task thread.&lt;/p&gt;

&lt;p&gt;The detail is as follows:&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;Task canceler thread -&amp;gt; IC1#releaseAllResources -&amp;gt; recycle floating buffers -&amp;gt;&#160;&lt;font color=&quot;#d04437&quot;&gt;lock&lt;/font&gt;(LocalBufferPool#availableMemorySegments) -&amp;gt; IC2#notifyBufferAvailable&lt;/tt&gt;&#160;&amp;gt;&#160;&lt;font color=&quot;#d04437&quot;&gt;try to lock&lt;/font&gt;(IC2#bufferQueue)&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;Task thread -&amp;gt; IC2#recycle -&amp;gt; &lt;font color=&quot;#d04437&quot;&gt;lock&lt;/font&gt;(IC2#bufferQueue) -&amp;gt; bufferQueue#addExclusiveBuffer&lt;/tt&gt; -&amp;gt; &lt;tt&gt;floatingBuffer#recycleBuffer&lt;/tt&gt; -&amp;gt; &lt;font color=&quot;#d04437&quot;&gt;try to lock&lt;/font&gt;(LocalBufferPool#availableMemorySegments)&lt;/p&gt;

&lt;p&gt;One solution is&#160;that &lt;tt&gt;listener#notifyBufferAvailable&lt;/tt&gt;&#160;can be&#160;called&#160;outside the &lt;tt&gt;synchronized(availableMemorySegments) in&#160;&lt;/tt&gt;&lt;tt&gt;LocalBufferPool#recycle.&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;The existing RemoteInputChannelTest#testConcurrentOnSenderBacklogAndRecycle can cover this case but the deadlock probability is very low, so this UT is not stable.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13168573">FLINK-9676</key>
            <summary>Deadlock during canceling task and recycling exclusive buffer</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="nkruber">Nico Kruber</assignee>
                                    <reporter username="zjwang">Zhijiang</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Wed, 27 Jun 2018 09:42:38 +0000</created>
                <updated>Tue, 10 Jul 2018 10:32:56 +0000</updated>
                            <resolved>Thu, 5 Jul 2018 10:24:32 +0000</resolved>
                                    <version>1.5.0</version>
                                    <fixVersion>1.5.1</fixVersion>
                    <fixVersion>1.6.0</fixVersion>
                                    <component>Runtime / Network</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="16524873" author="zjwang" created="Wed, 27 Jun 2018 10:25:42 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=NicoK&quot; class=&quot;user-hover&quot; rel=&quot;NicoK&quot;&gt;NicoK&lt;/a&gt;, I think this is a bug in credit-based mode.&lt;/p&gt;</comment>
                            <comment id="16532840" author="githubbot" created="Wed, 4 Jul 2018 14:48:16 +0000"  >&lt;p&gt;GitHub user NicoK opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6254&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9676&quot; title=&quot;Deadlock during canceling task and recycling exclusive buffer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9676&quot;&gt;&lt;del&gt;FLINK-9676&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;network&amp;#93;&lt;/span&gt; clarify contracts of BufferListener#notifyBufferAvailable() and fix a deadlock&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    When recycling exclusive buffers of a `RemoteInputChannel` and recycling (other/floating) buffers to the buffer pool concurrently while the `RemoteInputChannel` is registered as a listener to the buffer pool and adding the exclusive buffer triggers a floating buffer to be recycled back to the same&lt;br/&gt;
    buffer pool, a deadlock would occur holding locks on `LocalBufferPool#availableMemorySegments` and `RemoteInputChannel#bufferQueue` but acquiring them in reverse order.&lt;/p&gt;

&lt;p&gt;    One such instance would be (thanks @zhijiangW for finding this):&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    Task canceler thread -&amp;gt; RemoteInputChannel1#releaseAllResources -&amp;gt; recycle floating buffers&lt;br/&gt;
     -&amp;gt; lock(LocalBufferPool#availableMemorySegments) -&amp;gt; RemoteInputChannel2#notifyBufferAvailable&lt;br/&gt;
     -&amp;gt; try to lock(RemoteInputChannel2#bufferQueue)&lt;br/&gt;
    ```&lt;br/&gt;
    ```&lt;br/&gt;
    Task thread -&amp;gt; RemoteInputChannel2#recycle&lt;br/&gt;
     -&amp;gt; lock(RemoteInputChannel2#bufferQueue) -&amp;gt; bufferQueue#addExclusiveBuffer -&amp;gt; floatingBuffer#recycleBuffer&lt;br/&gt;
     -&amp;gt; try to lock(LocalBufferPool#availableMemorySegments)&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    @pnowojski and @tillrohrmann can you also have a quick look so that this can get into 1.5.1?&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;clarify the contract of `BufferListener#notifyBufferAvailable()` (see in the code)&lt;/li&gt;
	&lt;li&gt;make sure that none of the places in `RemoteInputChannel` break this contract, i.e. wherever a lock on `bufferQueue` is taken, we may not recycle any buffer under this lock&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This change added tests and can be verified as follows:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;added `RemoteInputChannelTest#testConcurrentRecycleAndRelease2` which catches this deadlock quite quickly&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The serializers: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): *&lt;b&gt;no&lt;/b&gt;* (per buffer, but we&apos;re only moving recycling out of the synchronized block so if there&apos;s any effect, it should be positive)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? *&lt;b&gt;JavaDocs&lt;/b&gt;*&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/NicoK/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/NicoK/flink&lt;/a&gt; flink-9676&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6254.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6254.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #6254&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 14000788b71910f6026a448c9cb5b2f35e4b33dd&lt;br/&gt;
Author: Nico Kruber &amp;lt;nico@...&amp;gt;&lt;br/&gt;
Date:   2018-07-04T14:32:11Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9676&quot; title=&quot;Deadlock during canceling task and recycling exclusive buffer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9676&quot;&gt;&lt;del&gt;FLINK-9676&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;network&amp;#93;&lt;/span&gt; clarify contracts of BufferListener#notifyBufferAvailable() and fix a deadlock&lt;/p&gt;

&lt;p&gt;    When recycling exclusive buffers of a RemoteInputChannel and recycling&lt;br/&gt;
    (other/floating) buffers to the buffer pool concurrently while the&lt;br/&gt;
    RemoteInputChannel is registered as a listener to the buffer pool and adding the&lt;br/&gt;
    exclusive buffer triggers a floating buffer to be recycled back to the same&lt;br/&gt;
    buffer pool, a deadlock would occur holding locks on&lt;br/&gt;
    LocalBufferPool#availableMemorySegments and RemoteInputChannel#bufferQueue but&lt;br/&gt;
    acquiring them in reverse order.&lt;/p&gt;

&lt;p&gt;    One such instance would be:&lt;/p&gt;

&lt;p&gt;    Task canceler thread -&amp;gt; IC1#releaseAllResources -&amp;gt; recycle floating buffers&lt;br/&gt;
     -&amp;gt; lock(LocalBufferPool#availableMemorySegments) -&amp;gt; IC2#notifyBufferAvailable&lt;br/&gt;
     -&amp;gt; try to lock(IC2#bufferQueue)&lt;/p&gt;

&lt;p&gt;    Task thread -&amp;gt; IC2#recycle&lt;br/&gt;
     -&amp;gt; lock(IC2#bufferQueue) -&amp;gt; bufferQueue#addExclusiveBuffer -&amp;gt; floatingBuffer#recycleBuffer&lt;br/&gt;
     -&amp;gt; try to lock(LocalBufferPool#availableMemorySegments)&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16532896" author="githubbot" created="Wed, 4 Jul 2018 15:45:00 +0000"  >&lt;p&gt;Github user pnowojski commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6254&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Please document in java doc AND in the commit message the contract of lock hierarchy that you are implementing here.&lt;/p&gt;</comment>
                            <comment id="16533075" author="githubbot" created="Wed, 4 Jul 2018 21:48:03 +0000"  >&lt;p&gt;GitHub user NicoK opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6257&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6257&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9676&quot; title=&quot;Deadlock during canceling task and recycling exclusive buffer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9676&quot;&gt;&lt;del&gt;FLINK-9676&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;network&amp;#93;&lt;/span&gt; clarify contracts of BufferListener#notifyBufferAvailable() and fix a deadlock&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    When recycling exclusive buffers of a `RemoteInputChannel` and recycling (other/floating) buffers to the buffer pool concurrently while the `RemoteInputChannel` is registered as a listener to the buffer pool and adding the exclusive buffer triggers a floating buffer to be recycled back to the same&lt;br/&gt;
    buffer pool, a deadlock would occur holding locks on `LocalBufferPool#availableMemorySegments` and `RemoteInputChannel#bufferQueue` but acquiring them in reverse order.&lt;/p&gt;

&lt;p&gt;    One such instance would be (thanks @zhijiangW for finding this):&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    Task canceler thread -&amp;gt; RemoteInputChannel1#releaseAllResources -&amp;gt; recycle floating buffers&lt;br/&gt;
     -&amp;gt; lock(LocalBufferPool#availableMemorySegments) -&amp;gt; RemoteInputChannel2#notifyBufferAvailable&lt;br/&gt;
     -&amp;gt; try to lock(RemoteInputChannel2#bufferQueue)&lt;br/&gt;
    ```&lt;br/&gt;
    ```&lt;br/&gt;
    Task thread -&amp;gt; RemoteInputChannel2#recycle&lt;br/&gt;
     -&amp;gt; lock(RemoteInputChannel2#bufferQueue) -&amp;gt; bufferQueue#addExclusiveBuffer -&amp;gt; floatingBuffer#recycleBuffer&lt;br/&gt;
     -&amp;gt; try to lock(LocalBufferPool#availableMemorySegments)&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    This PR is a second approach to #6254 and solves the deadlock on the `LocalBufferPool` side as the other solution turned out to be even more complex than what&apos;s already in the PR (I&apos;ll update that PR in a second).&lt;br/&gt;
    @pnowojski and @tillrohrmann can you also have a quick look so that this can get into 1.5.1?&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;clarify the contract of `BufferListener#notifyBufferAvailable()` (see in the code)&lt;/li&gt;
	&lt;li&gt;make sure that `LocalBufferPool#recycle()` does not break this contract, i.e. call the listener&apos;s callback outside the lock around `LocalBufferPool#availableMemorySegments`&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This change added tests and can be verified as follows:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;added `RemoteInputChannelTest#testConcurrentRecycleAndRelease2` which catches this deadlock quite quickly&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The serializers: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): *&lt;b&gt;no&lt;/b&gt;* (per buffer, but we&apos;re only moving recycling out of the synchronized block so if there&apos;s any effect, it should be positive)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? *&lt;b&gt;no&lt;/b&gt;*&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? *&lt;b&gt;JavaDocs&lt;/b&gt;*&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/NicoK/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/NicoK/flink&lt;/a&gt; flink-9676-lbp&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6257.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6257.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #6257&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit d69ff968f8647efa13adcc6f338e411675b36d68&lt;br/&gt;
Author: Nico Kruber &amp;lt;nico@...&amp;gt;&lt;br/&gt;
Date:   2018-07-04T15:45:18Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9676&quot; title=&quot;Deadlock during canceling task and recycling exclusive buffer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9676&quot;&gt;&lt;del&gt;FLINK-9676&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;network&amp;#93;&lt;/span&gt; clarify contracts of BufferListener#notifyBufferAvailable() and fix a deadlock&lt;/p&gt;

&lt;p&gt;    When recycling exclusive buffers of a RemoteInputChannel and recycling&lt;br/&gt;
    (other/floating) buffers to the buffer pool concurrently while the&lt;br/&gt;
    RemoteInputChannel is registered as a listener to the buffer pool and adding the&lt;br/&gt;
    exclusive buffer triggers a floating buffer to be recycled back to the same&lt;br/&gt;
    buffer pool, a deadlock would occur holding locks on&lt;br/&gt;
    LocalBufferPool#availableMemorySegments and RemoteInputChannel#bufferQueue but&lt;br/&gt;
    acquiring them in reverse order.&lt;/p&gt;

&lt;p&gt;    One such instance would be:&lt;/p&gt;

&lt;p&gt;    Task canceler thread -&amp;gt; RemoteInputChannel1#releaseAllResources -&amp;gt; recycle floating buffers&lt;br/&gt;
    	-&amp;gt; lock(LocalBufferPool#availableMemorySegments) -&amp;gt; RemoteInputChannel2#notifyBufferAvailable&lt;br/&gt;
    	-&amp;gt; try to lock(RemoteInputChannel2#bufferQueue)&lt;/p&gt;

&lt;p&gt;    Task thread -&amp;gt; RemoteInputChannel2#recycle&lt;br/&gt;
    	-&amp;gt; lock(RemoteInputChannel2#bufferQueue) -&amp;gt; bufferQueue#addExclusiveBuffer -&amp;gt; floatingBuffer#recycleBuffer&lt;br/&gt;
    	-&amp;gt; try to lock(LocalBufferPool#availableMemorySegments)&lt;/p&gt;

&lt;p&gt;    Therefore, we decouple the listener callback from lock around&lt;br/&gt;
    LocalBufferPool#availableMemorySegments and implicitly enforce that&lt;br/&gt;
    RemoteInputChannel2#bufferQueue takes precedence over this lock, i.e. must&lt;br/&gt;
    be acquired first and should never be taken after having locked on&lt;br/&gt;
    LocalBufferPool#availableMemorySegments.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16533080" author="githubbot" created="Wed, 4 Jul 2018 21:59:42 +0000"  >&lt;p&gt;Github user NicoK commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6254&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I updated the commit with a fixed unit test and added a big TODO on what else would need to be adapted in order to go with this solution (no updated commit message yet).&lt;/p&gt;

&lt;p&gt;    Since this is even more intrusive and ugly than the changes before, I&apos;ll close this PR in favour of another solution developed in #6257.&lt;/p&gt;</comment>
                            <comment id="16533081" author="githubbot" created="Wed, 4 Jul 2018 21:59:42 +0000"  >&lt;p&gt;Github user NicoK closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6254&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16533316" author="githubbot" created="Thu, 5 Jul 2018 06:50:05 +0000"  >&lt;p&gt;Github user zhijiangW commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6254#discussion_r200245464&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6254#discussion_r200245464&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -594,22 +626,22 @@ public String getMessage() {&lt;br/&gt;
     		}&lt;/p&gt;

&lt;p&gt;     		/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the&lt;br/&gt;
    +		 * Adds an exclusive buffer (back) into the queue and removes one floating buffer if the&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;number of available buffers in queue is more than the required amount.&lt;br/&gt;
     		 *&lt;/li&gt;
	&lt;li&gt;@param buffer The exclusive buffer to add&lt;/li&gt;
	&lt;li&gt;@param numRequiredBuffers The number of required buffers&lt;br/&gt;
     		 *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @return How many buffers were added to the queue&lt;br/&gt;
    +		 * @return How many buffers were added to the queue (&amp;lt;tt&amp;gt;0&amp;lt;/tt&amp;gt; or &amp;lt;tt&amp;gt;1&amp;lt;/tt&amp;gt;) and the&lt;br/&gt;
    +		 *         floating buffer which was removed and should be released (outside!)&lt;br/&gt;
     		 */&lt;/li&gt;
	&lt;li&gt;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {&lt;br/&gt;
    +		Tuple2&amp;lt;Integer, Optional&amp;lt;Buffer&amp;gt;&amp;gt; addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {&lt;br/&gt;
     			exclusiveBuffers.add(buffer);&lt;br/&gt;
     			if (getAvailableBufferSize() &amp;gt; numRequiredBuffers) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    For more strict, `getAvailableBufferSize() &amp;gt; numRequiredBuffers` should be `getAvailableBufferSize() == numRequiredBuffers + 1`? &lt;br/&gt;
    Otherwise, it may be understood the number of available buffers may exceed more than required buffers, but we only return one floating buffer each time. Actually it can only more than one in our design. Maybe it is out of this jira, and you can ignore it.&lt;/p&gt;</comment>
                            <comment id="16533317" author="githubbot" created="Thu, 5 Jul 2018 06:50:05 +0000"  >&lt;p&gt;Github user zhijiangW commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6254#discussion_r200247127&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6254#discussion_r200247127&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -479,6 +508,9 @@ void onSenderBacklog(int backlog) throws IOException {&lt;/p&gt;

&lt;p&gt;     			numRequiredBuffers = backlog + initialCredit;&lt;br/&gt;
     			while (bufferQueue.getAvailableBufferSize() &amp;lt; numRequiredBuffers &amp;amp;&amp;amp; !isWaitingForFloatingBuffers) {&lt;br/&gt;
    +				// TODO: this will take a lock in the LocalBufferPool as well and needs to be done&lt;br/&gt;
    +				// outside the synchronized block (which is a bit difficult trying to acquire the&lt;br/&gt;
    +				// lock only once!&lt;br/&gt;
     				Buffer buffer = inputGate.getBufferPool().requestBuffer();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    In my previous implementation, I added a new method in `BufferProvider` interface to request batch of buffers at a time.  To do so, it only needs lock only once in `LocalBufferPool` and may be more efficient from lock side. The only concern is that the floating buffer distribution may be not fair in all the channels. So we want to implement two strategies, one fair strategy is requesting one buffer at a time, another greedy strategy is requesting all required buffers at a time, then comparing these strategies to check performance. Maybe it behaves different in different scenarios. I am planing to submit this JIRA soon. What do you think?&lt;/p&gt;</comment>
                            <comment id="16533335" author="githubbot" created="Thu, 5 Jul 2018 07:18:21 +0000"  >&lt;p&gt;Github user zhijiangW commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6257#discussion_r200251500&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6257#discussion_r200251500&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java &amp;#8212;&lt;br/&gt;
    @@ -251,27 +257,56 @@ private MemorySegment requestMemorySegment(boolean isBlocking) throws Interrupte&lt;/p&gt;

&lt;p&gt;     	@Override&lt;br/&gt;
     	public void recycle(MemorySegment segment) {&lt;br/&gt;
    +		BufferListener listener;&lt;br/&gt;
     		synchronized (availableMemorySegments) {&lt;br/&gt;
     			if (isDestroyed || numberOfRequestedMemorySegments &amp;gt; currentPoolSize) &lt;/p&gt;
{
     				returnMemorySegment(segment);
    +				return;
     			}
&lt;p&gt;     			else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BufferListener listener = registeredListeners.poll();&lt;br/&gt;
    +				listener = registeredListeners.poll();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     				if (listener == null) &lt;/p&gt;
{
     					availableMemorySegments.add(segment);
     					availableMemorySegments.notify();
    +					return;
     				}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;boolean needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));&lt;/li&gt;
	&lt;li&gt;if (needMoreBuffers) 
{
    -							registeredListeners.add(listener);
    -						}
&lt;p&gt;    +			}&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		// We do not know which locks have been acquired before the recycle() or are needed in the&lt;br/&gt;
    +		// notification and which other threads also access them.&lt;br/&gt;
    +		// -&amp;gt; call notifyBufferAvailable() outside of the synchronized block to avoid a deadlock (&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9676&quot; title=&quot;Deadlock during canceling task and recycling exclusive buffer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9676&quot;&gt;&lt;del&gt;FLINK-9676&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
    +		boolean success = false;&lt;br/&gt;
    +		boolean needMoreBuffers = false;&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));
    +			success = true;
    +		}
&lt;p&gt; catch (Throwable ignored) &lt;/p&gt;
{
    +			// handled below, under the lock
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (!success || needMoreBuffers) {&lt;br/&gt;
    +			synchronized (availableMemorySegments) {&lt;br/&gt;
    +				if (isDestroyed) {&lt;br/&gt;
    +					// cleanup tasks how they would have been done if we only had one synchronized block&lt;br/&gt;
    +					if (needMoreBuffers) {&lt;br/&gt;
    +						listener.notifyBufferDestroyed();&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Currently `notifyBufferDestroyed` will do nothing, and we should be careful if implement this method future similar with `notifyBufferAvailable`.&lt;/p&gt;</comment>
                            <comment id="16533336" author="githubbot" created="Thu, 5 Jul 2018 07:18:21 +0000"  >&lt;p&gt;Github user zhijiangW commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6257#discussion_r200252253&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6257#discussion_r200252253&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java &amp;#8212;&lt;br/&gt;
    @@ -251,27 +257,56 @@ private MemorySegment requestMemorySegment(boolean isBlocking) throws Interrupte&lt;/p&gt;

&lt;p&gt;     	@Override&lt;br/&gt;
     	public void recycle(MemorySegment segment) {&lt;br/&gt;
    +		BufferListener listener;&lt;br/&gt;
     		synchronized (availableMemorySegments) {&lt;br/&gt;
     			if (isDestroyed || numberOfRequestedMemorySegments &amp;gt; currentPoolSize) &lt;/p&gt;
{
     				returnMemorySegment(segment);
    +				return;
     			}
&lt;p&gt;     			else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BufferListener listener = registeredListeners.poll();&lt;br/&gt;
    +				listener = registeredListeners.poll();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     				if (listener == null) &lt;/p&gt;
{
     					availableMemorySegments.add(segment);
     					availableMemorySegments.notify();
    +					return;
     				}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;boolean needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));&lt;/li&gt;
	&lt;li&gt;if (needMoreBuffers) 
{
    -							registeredListeners.add(listener);
    -						}
&lt;p&gt;    +			}&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		// We do not know which locks have been acquired before the recycle() or are needed in the&lt;br/&gt;
    +		// notification and which other threads also access them.&lt;br/&gt;
    +		// -&amp;gt; call notifyBufferAvailable() outside of the synchronized block to avoid a deadlock (&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9676&quot; title=&quot;Deadlock during canceling task and recycling exclusive buffer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9676&quot;&gt;&lt;del&gt;FLINK-9676&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
    +		boolean success = false;&lt;br/&gt;
    +		boolean needMoreBuffers = false;&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));
    +			success = true;
    +		}
&lt;p&gt; catch (Throwable ignored) &lt;/p&gt;
{
    +			// handled below, under the lock
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (!success || needMoreBuffers) {&lt;br/&gt;
    +			synchronized (availableMemorySegments) {&lt;br/&gt;
    +				if (isDestroyed) {&lt;br/&gt;
    +					// cleanup tasks how they would have been done if we only had one synchronized block&lt;br/&gt;
    +					if (needMoreBuffers) &lt;/p&gt;
{
    +						listener.notifyBufferDestroyed();
     					}&lt;/li&gt;
	&lt;li&gt;catch (Throwable ignored) {&lt;/li&gt;
	&lt;li&gt;availableMemorySegments.add(segment);&lt;/li&gt;
	&lt;li&gt;availableMemorySegments.notify();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I am wondering whether we should rethrow this exception under below handling in the end.&lt;/p&gt;

&lt;p&gt;    For example: During `RemoteInputChannel#notifyBufferAvailable`, if the tag of  `isWaitingForFloatingBuffers` is not consistent, we should throw this exception to trigger failover, otherwise we can not find the potential bug.&lt;/p&gt;</comment>
                            <comment id="16533343" author="githubbot" created="Thu, 5 Jul 2018 07:28:25 +0000"  >&lt;p&gt;Github user zhijiangW commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6257&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6257&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for fixing this bug, and we also solve this problem in this way. &lt;/p&gt;

&lt;p&gt;    This solution seems more lightweight than the way in &lt;span class=&quot;error&quot;&gt;&amp;#91;6254&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://github.com/apache/flink/pull/6254&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6254&lt;/a&gt;), and I also think the lock adjusting in `6254` has reference values.&lt;/p&gt;</comment>
                            <comment id="16533408" author="githubbot" created="Thu, 5 Jul 2018 08:42:26 +0000"  >&lt;p&gt;Github user NicoK commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6257#discussion_r200274038&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6257#discussion_r200274038&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java &amp;#8212;&lt;br/&gt;
    @@ -251,27 +257,56 @@ private MemorySegment requestMemorySegment(boolean isBlocking) throws Interrupte&lt;/p&gt;

&lt;p&gt;     	@Override&lt;br/&gt;
     	public void recycle(MemorySegment segment) {&lt;br/&gt;
    +		BufferListener listener;&lt;br/&gt;
     		synchronized (availableMemorySegments) {&lt;br/&gt;
     			if (isDestroyed || numberOfRequestedMemorySegments &amp;gt; currentPoolSize) &lt;/p&gt;
{
     				returnMemorySegment(segment);
    +				return;
     			}
&lt;p&gt;     			else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BufferListener listener = registeredListeners.poll();&lt;br/&gt;
    +				listener = registeredListeners.poll();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     				if (listener == null) &lt;/p&gt;
{
     					availableMemorySegments.add(segment);
     					availableMemorySegments.notify();
    +					return;
     				}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;boolean needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));&lt;/li&gt;
	&lt;li&gt;if (needMoreBuffers) 
{
    -							registeredListeners.add(listener);
    -						}
&lt;p&gt;    +			}&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		// We do not know which locks have been acquired before the recycle() or are needed in the&lt;br/&gt;
    +		// notification and which other threads also access them.&lt;br/&gt;
    +		// -&amp;gt; call notifyBufferAvailable() outside of the synchronized block to avoid a deadlock (&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9676&quot; title=&quot;Deadlock during canceling task and recycling exclusive buffer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9676&quot;&gt;&lt;del&gt;FLINK-9676&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
    +		boolean success = false;&lt;br/&gt;
    +		boolean needMoreBuffers = false;&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));
    +			success = true;
    +		}
&lt;p&gt; catch (Throwable ignored) &lt;/p&gt;
{
    +			// handled below, under the lock
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (!success || needMoreBuffers) {&lt;br/&gt;
    +			synchronized (availableMemorySegments) {&lt;br/&gt;
    +				if (isDestroyed) {&lt;br/&gt;
    +					// cleanup tasks how they would have been done if we only had one synchronized block&lt;br/&gt;
    +					if (needMoreBuffers) &lt;/p&gt;
{
    +						listener.notifyBufferDestroyed();
     					}&lt;/li&gt;
	&lt;li&gt;catch (Throwable ignored) {&lt;/li&gt;
	&lt;li&gt;availableMemorySegments.add(segment);&lt;/li&gt;
	&lt;li&gt;availableMemorySegments.notify();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    true, that&apos;s why I created &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9755&quot; title=&quot;Exceptions in RemoteInputChannel#notifyBufferAvailable() are not propagated to the responsible thread&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9755&quot;&gt;&lt;del&gt;FLINK-9755&lt;/del&gt;&lt;/a&gt; for this issue and already have code (have to add tests though) - expect a PR soon&lt;/p&gt;</comment>
                            <comment id="16533409" author="githubbot" created="Thu, 5 Jul 2018 08:43:28 +0000"  >&lt;p&gt;Github user NicoK commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6257#discussion_r200274433&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6257#discussion_r200274433&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java &amp;#8212;&lt;br/&gt;
    @@ -251,27 +257,56 @@ private MemorySegment requestMemorySegment(boolean isBlocking) throws Interrupte&lt;/p&gt;

&lt;p&gt;     	@Override&lt;br/&gt;
     	public void recycle(MemorySegment segment) {&lt;br/&gt;
    +		BufferListener listener;&lt;br/&gt;
     		synchronized (availableMemorySegments) {&lt;br/&gt;
     			if (isDestroyed || numberOfRequestedMemorySegments &amp;gt; currentPoolSize) &lt;/p&gt;
{
     				returnMemorySegment(segment);
    +				return;
     			}
&lt;p&gt;     			else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BufferListener listener = registeredListeners.poll();&lt;br/&gt;
    +				listener = registeredListeners.poll();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     				if (listener == null) &lt;/p&gt;
{
     					availableMemorySegments.add(segment);
     					availableMemorySegments.notify();
    +					return;
     				}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;boolean needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));&lt;/li&gt;
	&lt;li&gt;if (needMoreBuffers) 
{
    -							registeredListeners.add(listener);
    -						}
&lt;p&gt;    +			}&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		// We do not know which locks have been acquired before the recycle() or are needed in the&lt;br/&gt;
    +		// notification and which other threads also access them.&lt;br/&gt;
    +		// -&amp;gt; call notifyBufferAvailable() outside of the synchronized block to avoid a deadlock (&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9676&quot; title=&quot;Deadlock during canceling task and recycling exclusive buffer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9676&quot;&gt;&lt;del&gt;FLINK-9676&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
    +		boolean success = false;&lt;br/&gt;
    +		boolean needMoreBuffers = false;&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));
    +			success = true;
    +		}
&lt;p&gt; catch (Throwable ignored) &lt;/p&gt;
{
    +			// handled below, under the lock
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (!success || needMoreBuffers) {&lt;br/&gt;
    +			synchronized (availableMemorySegments) {&lt;br/&gt;
    +				if (isDestroyed) {&lt;br/&gt;
    +					// cleanup tasks how they would have been done if we only had one synchronized block&lt;br/&gt;
    +					if (needMoreBuffers) {&lt;br/&gt;
    +						listener.notifyBufferDestroyed();&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    true, this &lt;sub&gt;could&lt;/sub&gt; should be done outside the lock as well&lt;/p&gt;</comment>
                            <comment id="16533425" author="githubbot" created="Thu, 5 Jul 2018 09:11:51 +0000"  >&lt;p&gt;Github user NicoK commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6257#discussion_r200283214&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6257#discussion_r200283214&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java &amp;#8212;&lt;br/&gt;
    @@ -251,27 +257,56 @@ private MemorySegment requestMemorySegment(boolean isBlocking) throws Interrupte&lt;/p&gt;

&lt;p&gt;     	@Override&lt;br/&gt;
     	public void recycle(MemorySegment segment) {&lt;br/&gt;
    +		BufferListener listener;&lt;br/&gt;
     		synchronized (availableMemorySegments) {&lt;br/&gt;
     			if (isDestroyed || numberOfRequestedMemorySegments &amp;gt; currentPoolSize) &lt;/p&gt;
{
     				returnMemorySegment(segment);
    +				return;
     			}
&lt;p&gt;     			else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BufferListener listener = registeredListeners.poll();&lt;br/&gt;
    +				listener = registeredListeners.poll();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     				if (listener == null) &lt;/p&gt;
{
     					availableMemorySegments.add(segment);
     					availableMemorySegments.notify();
    +					return;
     				}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;boolean needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));&lt;/li&gt;
	&lt;li&gt;if (needMoreBuffers) 
{
    -							registeredListeners.add(listener);
    -						}
&lt;p&gt;    +			}&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		// We do not know which locks have been acquired before the recycle() or are needed in the&lt;br/&gt;
    +		// notification and which other threads also access them.&lt;br/&gt;
    +		// -&amp;gt; call notifyBufferAvailable() outside of the synchronized block to avoid a deadlock (&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9676&quot; title=&quot;Deadlock during canceling task and recycling exclusive buffer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9676&quot;&gt;&lt;del&gt;FLINK-9676&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
    +		boolean success = false;&lt;br/&gt;
    +		boolean needMoreBuffers = false;&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));
    +			success = true;
    +		}
&lt;p&gt; catch (Throwable ignored) &lt;/p&gt;
{
    +			// handled below, under the lock
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (!success || needMoreBuffers) {&lt;br/&gt;
    +			synchronized (availableMemorySegments) {&lt;br/&gt;
    +				if (isDestroyed) {&lt;br/&gt;
    +					// cleanup tasks how they would have been done if we only had one synchronized block&lt;br/&gt;
    +					if (needMoreBuffers) {&lt;br/&gt;
    +						listener.notifyBufferDestroyed();&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    actually, let&apos;s do this in a follow-up PR&lt;/p&gt;</comment>
                            <comment id="16533438" author="githubbot" created="Thu, 5 Jul 2018 09:27:13 +0000"  >&lt;p&gt;Github user zhijiangW commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6257#discussion_r200287730&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6257#discussion_r200287730&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java &amp;#8212;&lt;br/&gt;
    @@ -251,27 +257,56 @@ private MemorySegment requestMemorySegment(boolean isBlocking) throws Interrupte&lt;/p&gt;

&lt;p&gt;     	@Override&lt;br/&gt;
     	public void recycle(MemorySegment segment) {&lt;br/&gt;
    +		BufferListener listener;&lt;br/&gt;
     		synchronized (availableMemorySegments) {&lt;br/&gt;
     			if (isDestroyed || numberOfRequestedMemorySegments &amp;gt; currentPoolSize) &lt;/p&gt;
{
     				returnMemorySegment(segment);
    +				return;
     			}
&lt;p&gt;     			else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BufferListener listener = registeredListeners.poll();&lt;br/&gt;
    +				listener = registeredListeners.poll();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     				if (listener == null) &lt;/p&gt;
{
     					availableMemorySegments.add(segment);
     					availableMemorySegments.notify();
    +					return;
     				}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;boolean needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));&lt;/li&gt;
	&lt;li&gt;if (needMoreBuffers) 
{
    -							registeredListeners.add(listener);
    -						}
&lt;p&gt;    +			}&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		// We do not know which locks have been acquired before the recycle() or are needed in the&lt;br/&gt;
    +		// notification and which other threads also access them.&lt;br/&gt;
    +		// -&amp;gt; call notifyBufferAvailable() outside of the synchronized block to avoid a deadlock (&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9676&quot; title=&quot;Deadlock during canceling task and recycling exclusive buffer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9676&quot;&gt;&lt;del&gt;FLINK-9676&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
    +		boolean success = false;&lt;br/&gt;
    +		boolean needMoreBuffers = false;&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));
    +			success = true;
    +		}
&lt;p&gt; catch (Throwable ignored) &lt;/p&gt;
{
    +			// handled below, under the lock
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (!success || needMoreBuffers) {&lt;br/&gt;
    +			synchronized (availableMemorySegments) {&lt;br/&gt;
    +				if (isDestroyed) {&lt;br/&gt;
    +					// cleanup tasks how they would have been done if we only had one synchronized block&lt;br/&gt;
    +					if (needMoreBuffers) &lt;/p&gt;
{
    +						listener.notifyBufferDestroyed();
     					}&lt;/li&gt;
	&lt;li&gt;catch (Throwable ignored) {&lt;/li&gt;
	&lt;li&gt;availableMemorySegments.add(segment);&lt;/li&gt;
	&lt;li&gt;availableMemorySegments.notify();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    &#128077;&lt;/p&gt;</comment>
                            <comment id="16533439" author="githubbot" created="Thu, 5 Jul 2018 09:27:26 +0000"  >&lt;p&gt;Github user zhijiangW commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6257#discussion_r200287796&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6257#discussion_r200287796&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java &amp;#8212;&lt;br/&gt;
    @@ -251,27 +257,56 @@ private MemorySegment requestMemorySegment(boolean isBlocking) throws Interrupte&lt;/p&gt;

&lt;p&gt;     	@Override&lt;br/&gt;
     	public void recycle(MemorySegment segment) {&lt;br/&gt;
    +		BufferListener listener;&lt;br/&gt;
     		synchronized (availableMemorySegments) {&lt;br/&gt;
     			if (isDestroyed || numberOfRequestedMemorySegments &amp;gt; currentPoolSize) &lt;/p&gt;
{
     				returnMemorySegment(segment);
    +				return;
     			}
&lt;p&gt;     			else {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BufferListener listener = registeredListeners.poll();&lt;br/&gt;
    +				listener = registeredListeners.poll();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     				if (listener == null) &lt;/p&gt;
{
     					availableMemorySegments.add(segment);
     					availableMemorySegments.notify();
    +					return;
     				}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;boolean needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));&lt;/li&gt;
	&lt;li&gt;if (needMoreBuffers) 
{
    -							registeredListeners.add(listener);
    -						}
&lt;p&gt;    +			}&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		// We do not know which locks have been acquired before the recycle() or are needed in the&lt;br/&gt;
    +		// notification and which other threads also access them.&lt;br/&gt;
    +		// -&amp;gt; call notifyBufferAvailable() outside of the synchronized block to avoid a deadlock (&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-9676&quot; title=&quot;Deadlock during canceling task and recycling exclusive buffer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-9676&quot;&gt;&lt;del&gt;FLINK-9676&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
    +		boolean success = false;&lt;br/&gt;
    +		boolean needMoreBuffers = false;&lt;br/&gt;
    +		try &lt;/p&gt;
{
    +			needMoreBuffers = listener.notifyBufferAvailable(new NetworkBuffer(segment, this));
    +			success = true;
    +		}
&lt;p&gt; catch (Throwable ignored) &lt;/p&gt;
{
    +			// handled below, under the lock
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		if (!success || needMoreBuffers) {&lt;br/&gt;
    +			synchronized (availableMemorySegments) {&lt;br/&gt;
    +				if (isDestroyed) {&lt;br/&gt;
    +					// cleanup tasks how they would have been done if we only had one synchronized block&lt;br/&gt;
    +					if (needMoreBuffers) {&lt;br/&gt;
    +						listener.notifyBufferDestroyed();&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    &#128077;&lt;/p&gt;</comment>
                            <comment id="16533479" author="githubbot" created="Thu, 5 Jul 2018 10:21:30 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6257&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6257&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16533483" author="nicok" created="Thu, 5 Jul 2018 10:24:32 +0000"  >&lt;p&gt;Fixed via&lt;br/&gt;
1.6.0: a9b5579b397b6c56e44e21ebb8b2a6a7e6d8b2d1&lt;br/&gt;
1.5.0: 6ce8211bab84308a17043dc4901d6a93b2777da8&lt;/p&gt;</comment>
                            <comment id="16538302" author="githubbot" created="Tue, 10 Jul 2018 09:19:07 +0000"  >&lt;p&gt;Github user NicoK commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6254#discussion_r201272052&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6254#discussion_r201272052&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -594,22 +626,22 @@ public String getMessage() {&lt;br/&gt;
     		}&lt;/p&gt;

&lt;p&gt;     		/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the&lt;br/&gt;
    +		 * Adds an exclusive buffer (back) into the queue and removes one floating buffer if the&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;number of available buffers in queue is more than the required amount.&lt;br/&gt;
     		 *&lt;/li&gt;
	&lt;li&gt;@param buffer The exclusive buffer to add&lt;/li&gt;
	&lt;li&gt;@param numRequiredBuffers The number of required buffers&lt;br/&gt;
     		 *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @return How many buffers were added to the queue&lt;br/&gt;
    +		 * @return How many buffers were added to the queue (&amp;lt;tt&amp;gt;0&amp;lt;/tt&amp;gt; or &amp;lt;tt&amp;gt;1&amp;lt;/tt&amp;gt;) and the&lt;br/&gt;
    +		 *         floating buffer which was removed and should be released (outside!)&lt;br/&gt;
     		 */&lt;/li&gt;
	&lt;li&gt;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {&lt;br/&gt;
    +		Tuple2&amp;lt;Integer, Optional&amp;lt;Buffer&amp;gt;&amp;gt; addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {&lt;br/&gt;
     			exclusiveBuffers.add(buffer);&lt;br/&gt;
     			if (getAvailableBufferSize() &amp;gt; numRequiredBuffers) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    true, we could change that but the `BufferQueue` logic in `addExclusiveBuffer` and `addFloatingBuffer` does not enforce this contract (only outside code does). If outside code decides to break this contract (I can&apos;t think of a reason why) than the current one-for-one logic with `getAvailableBufferSize() &amp;gt; numRequiredBuffers` ensures that we do not further deviate from the target.&lt;br/&gt;
    This is purely a theoretical concern and definitely out of the scope of this ticket - I would leave it unchanged for now since we don&apos;t gain anything with that change.&lt;/p&gt;</comment>
                            <comment id="16538305" author="githubbot" created="Tue, 10 Jul 2018 09:22:24 +0000"  >&lt;p&gt;Github user NicoK commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6254#discussion_r201273133&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6254#discussion_r201273133&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -479,6 +508,9 @@ void onSenderBacklog(int backlog) throws IOException {&lt;/p&gt;

&lt;p&gt;     			numRequiredBuffers = backlog + initialCredit;&lt;br/&gt;
     			while (bufferQueue.getAvailableBufferSize() &amp;lt; numRequiredBuffers &amp;amp;&amp;amp; !isWaitingForFloatingBuffers) {&lt;br/&gt;
    +				// TODO: this will take a lock in the LocalBufferPool as well and needs to be done&lt;br/&gt;
    +				// outside the synchronized block (which is a bit difficult trying to acquire the&lt;br/&gt;
    +				// lock only once!&lt;br/&gt;
     				Buffer buffer = inputGate.getBufferPool().requestBuffer();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I&apos;m not sure about this change since this may lead to lower-throughput channels being starved by high-throughput channels, but we can discuss further with a broader audience in the JIRA ticket once created (this is off-topic here)&lt;/p&gt;</comment>
                            <comment id="16538371" author="githubbot" created="Tue, 10 Jul 2018 10:29:48 +0000"  >&lt;p&gt;Github user zhijiangW commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6254#discussion_r201293052&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6254#discussion_r201293052&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -479,6 +508,9 @@ void onSenderBacklog(int backlog) throws IOException {&lt;/p&gt;

&lt;p&gt;     			numRequiredBuffers = backlog + initialCredit;&lt;br/&gt;
     			while (bufferQueue.getAvailableBufferSize() &amp;lt; numRequiredBuffers &amp;amp;&amp;amp; !isWaitingForFloatingBuffers) {&lt;br/&gt;
    +				// TODO: this will take a lock in the LocalBufferPool as well and needs to be done&lt;br/&gt;
    +				// outside the synchronized block (which is a bit difficult trying to acquire the&lt;br/&gt;
    +				// lock only once!&lt;br/&gt;
     				Buffer buffer = inputGate.getBufferPool().requestBuffer();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Agree with your suggestion.&lt;/p&gt;</comment>
                            <comment id="16538374" author="githubbot" created="Tue, 10 Jul 2018 10:32:56 +0000"  >&lt;p&gt;Github user zhijiangW commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/6254#discussion_r201293862&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6254#discussion_r201293862&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java &amp;#8212;&lt;br/&gt;
    @@ -594,22 +626,22 @@ public String getMessage() {&lt;br/&gt;
     		}&lt;/p&gt;

&lt;p&gt;     		/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the&lt;br/&gt;
    +		 * Adds an exclusive buffer (back) into the queue and removes one floating buffer if the&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;number of available buffers in queue is more than the required amount.&lt;br/&gt;
     		 *&lt;/li&gt;
	&lt;li&gt;@param buffer The exclusive buffer to add&lt;/li&gt;
	&lt;li&gt;@param numRequiredBuffers The number of required buffers&lt;br/&gt;
     		 *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @return How many buffers were added to the queue&lt;br/&gt;
    +		 * @return How many buffers were added to the queue (&amp;lt;tt&amp;gt;0&amp;lt;/tt&amp;gt; or &amp;lt;tt&amp;gt;1&amp;lt;/tt&amp;gt;) and the&lt;br/&gt;
    +		 *         floating buffer which was removed and should be released (outside!)&lt;br/&gt;
     		 */&lt;/li&gt;
	&lt;li&gt;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {&lt;br/&gt;
    +		Tuple2&amp;lt;Integer, Optional&amp;lt;Buffer&amp;gt;&amp;gt; addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {&lt;br/&gt;
     			exclusiveBuffers.add(buffer);&lt;br/&gt;
     			if (getAvailableBufferSize() &amp;gt; numRequiredBuffers) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    yes, this is not critical. Just thought of it to exchange with you! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 19 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3vaav:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>