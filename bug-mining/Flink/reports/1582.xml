<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:27:37 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-5972] Don&apos;t allow shrinking merging windows</title>
                <link>https://issues.apache.org/jira/browse/FLINK-5972</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;A misbehaving &lt;tt&gt;MergingWindowAssigner&lt;/tt&gt; can cause a merge that results in a window that is smaller than the span of all the merged windows. This, in itself is not problematic. It becomes problematic when the end timestamp of a window that was not late before merging is now earlier than the watermark (the timestamp is smaller than the watermark).&lt;/p&gt;

&lt;p&gt;There are two choices:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;immediately process the window&lt;/li&gt;
	&lt;li&gt;drop the window&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;processing the window will lead to late data downstream.&lt;/p&gt;

&lt;p&gt;The current behaviour is to silently drop the window but that logic has a bug: we only remove the dropped window from the &lt;tt&gt;MergingWindowSet&lt;/tt&gt; but we don&apos;t properly clean up state and timers that the window still (possibly) has. We should fix this bug in the process of resolving this issue.&lt;/p&gt;

&lt;p&gt;We should either just fix the bug and still silently drop windows or add a check and throw an exception when the end timestamp falls below the watermark.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13048567">FLINK-5972</key>
            <summary>Don&apos;t allow shrinking merging windows</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="aljoscha">Aljoscha Krettek</assignee>
                                    <reporter username="aljoscha">Aljoscha Krettek</reporter>
                        <labels>
                    </labels>
                <created>Mon, 6 Mar 2017 16:08:39 +0000</created>
                <updated>Fri, 24 Mar 2017 07:10:21 +0000</updated>
                            <resolved>Fri, 24 Mar 2017 07:10:21 +0000</resolved>
                                    <version>1.1.0</version>
                    <version>1.2.0</version>
                    <version>1.3.0</version>
                                    <fixVersion>1.2.1</fixVersion>
                    <fixVersion>1.3.0</fixVersion>
                                    <component>API / DataStream</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="15934701" author="githubbot" created="Tue, 21 Mar 2017 14:23:06 +0000"  >&lt;p&gt;GitHub user aljoscha opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5972&quot; title=&quot;Don&amp;#39;t allow shrinking merging windows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5972&quot;&gt;&lt;del&gt;FLINK-5972&lt;/del&gt;&lt;/a&gt; Don&apos;t allow shrinking merging windows&lt;/p&gt;

&lt;p&gt;    Thanks for contributing to Apache Flink. Before you open your pull request, please take the following check list into consideration.&lt;br/&gt;
    If your changes take all of the items into account, feel free to open your pull request. For more information and/or questions please refer to the &lt;span class=&quot;error&quot;&gt;&amp;#91;How To Contribute guide&amp;#93;&lt;/span&gt;(&lt;a href=&quot;http://flink.apache.org/how-to-contribute.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://flink.apache.org/how-to-contribute.html&lt;/a&gt;).&lt;br/&gt;
    In addition to going through the list, please provide a meaningful description of your changes.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] General&lt;/li&gt;
	&lt;li&gt;The pull request references the related JIRA issue (&quot;&lt;span class=&quot;error&quot;&gt;&amp;#91;FLINK-XXX&amp;#93;&lt;/span&gt; Jira title text&quot;)&lt;/li&gt;
	&lt;li&gt;The pull request addresses only one issue&lt;/li&gt;
	&lt;li&gt;Each commit in the PR has a meaningful commit message (including the JIRA id)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Documentation&lt;/li&gt;
	&lt;li&gt;Documentation has been added for new functionality&lt;/li&gt;
	&lt;li&gt;Old documentation affected by the pull request has been updated&lt;/li&gt;
	&lt;li&gt;JavaDoc for public methods has been added&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Tests &amp;amp; Build&lt;/li&gt;
	&lt;li&gt;Functionality added by the pull request is covered by tests&lt;/li&gt;
	&lt;li&gt;`mvn clean verify` has been executed successfully locally or a Travis build has passed&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/aljoscha/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/aljoscha/flink&lt;/a&gt; jira-5972-disallow-shrinking-windows&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #3587&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit d6de53c286db4386166c50c6a3f5871f2b6ed43f&lt;br/&gt;
Author: Aljoscha Krettek &amp;lt;aljoscha.krettek@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-03-21T13:58:45Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-5972&quot; title=&quot;Don&amp;#39;t allow shrinking merging windows&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-5972&quot;&gt;&lt;del&gt;FLINK-5972&lt;/del&gt;&lt;/a&gt; Don&apos;t allow shrinking merging windows&lt;/p&gt;

&lt;p&gt;commit 197f1f95e74fe7557eaead168c88c5b0d8ea2932&lt;br/&gt;
Author: Aljoscha Krettek &amp;lt;aljoscha.krettek@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-03-21T14:00:24Z&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;hotfix&amp;#93;&lt;/span&gt; Add EvictingWindowOperatorContractTest&lt;/p&gt;

&lt;p&gt;    This also patches in the missing side output support for&lt;br/&gt;
    EvictingWindowOperator.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15934705" author="githubbot" created="Tue, 21 Mar 2017 14:24:41 +0000"  >&lt;p&gt;Github user aljoscha commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @StephanEwen this is the better alternative to #3535 in that it doesn&apos;t silently drop windows and throws an exception when window shrinking occurs.&lt;/p&gt;</comment>
                            <comment id="15935926" author="githubbot" created="Wed, 22 Mar 2017 08:51:40 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107347809&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107347809&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -574,7 +588,7 @@ private void emitWindowContents(W window, ACC contents) throws Exception {&lt;br/&gt;
     	 *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param element skipped late arriving element to side output&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private void sideOutput(StreamRecord&amp;lt;IN&amp;gt; element){&lt;br/&gt;
    +	protected void sideOutput(StreamRecord&amp;lt;IN&amp;gt; element){
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Should we use the &quot;@VisibleForTesting&quot; annotation, or comment that it is exposed for testing?&lt;/p&gt;</comment>
                            <comment id="15935927" author="githubbot" created="Wed, 22 Mar 2017 08:51:40 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107347975&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107347975&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Let&apos;s start trying to avoid star imports in the tests also &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15935928" author="githubbot" created="Wed, 22 Mar 2017 08:51:40 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107350816&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107350816&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Isn&apos;t the ordering of side outputs supposed to be deterministic? Why do we need to use `containsInAnyOrder`?&lt;/p&gt;</comment>
                            <comment id="15935929" author="githubbot" created="Wed, 22 Mar 2017 08:51:40 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107353469&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107353469&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerIsInvokedOncePerElement() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(2)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerWithMultipleWindows() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		shouldFireOnElement(mockTrigger);
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testWindowsDontInterfere() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		// no output so far
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());
    +
    +		// state for two windows
    +		assertEquals(2, testHarness.numKeyedStateEntries());
    +		assertEquals(2, testHarness.numEventTimeTimers());
    +
    +		// now we fire
    +		shouldFireOnElement(mockTrigger);
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0, 0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(1), eq(new TimeWindow(0, 1)), intIterable(1, 1), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementCalledPerWindow() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(42, 1L));
    +
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(2, 4)), anyTriggerContext());
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(0, 2)), anyTriggerContext());
    +
    +		verify(mockTrigger, times(2)).onElement(anyInt(), anyLong(), anyTimeWindow(), anyTriggerContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunction() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);
    +				out.collect(&quot;Hallo&quot;);
    +				out.collect(&quot;Ciao&quot;);
    +				return null;
    +			}
&lt;p&gt;    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnEventTime() throws Exception &lt;/p&gt;
{
    +		testEmittingFromWindowFunction(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnProcessingTime() throws Exception &lt;/p&gt;
{
    +		testEmittingFromWindowFunction(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private  void testEmittingFromWindowFunction(TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    redundant space between `private` and `void`&lt;/p&gt;</comment>
                            <comment id="15935930" author="githubbot" created="Wed, 22 Mar 2017 08:51:40 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107355400&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107355400&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -1577,6 +1585,91 @@ public TriggerResult answer(InvocationOnMock invocation) throws Exception {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Test&lt;br/&gt;
    +	public void testRejectShrinkingMergingEventTimeWindows() throws Exception &lt;/p&gt;
{
    +		testRejectShrinkingMergingWindows(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRejectShrinkingMergingProcessingTimeWindows() throws Exception &lt;/p&gt;
{
    +		testRejectShrinkingMergingWindows(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * A misbehaving &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; can cause a window to become late by merging if&lt;br/&gt;
    +	 * it moves the end-of-window time before the watermark. This verifies that we don&apos;t allow that.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testRejectShrinkingMergingWindows(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This can be private.&lt;/p&gt;</comment>
                            <comment id="15935931" author="githubbot" created="Wed, 22 Mar 2017 08:51:40 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107348150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107348150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerIsInvokedOncePerElement() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(2)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerWithMultipleWindows() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		shouldFireOnElement(mockTrigger);
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testWindowsDontInterfere() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		// no output so far
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());
    +
    +		// state for two windows
    +		assertEquals(2, testHarness.numKeyedStateEntries());
    +		assertEquals(2, testHarness.numEventTimeTimers());
    +
    +		// now we fire
    +		shouldFireOnElement(mockTrigger);
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0, 0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(1), eq(new TimeWindow(0, 1)), intIterable(1, 1), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementCalledPerWindow() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(42, 1L));
    +
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(2, 4)), anyTriggerContext());
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(0, 2)), anyTriggerContext());
    +
    +		verify(mockTrigger, times(2)).onElement(anyInt(), anyLong(), anyTimeWindow(), anyTriggerContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunction() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);
    +				out.collect(&quot;Hallo&quot;);
    +				out.collect(&quot;Ciao&quot;);
    +				return null;
    +			}&lt;br/&gt;
    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnEventTime() throws Exception {
    +		testEmittingFromWindowFunction(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnProcessingTime() throws Exception {
    +		testEmittingFromWindowFunction(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private  void testEmittingFromWindowFunction(TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception {    +				@SuppressWarnings(&quot;unchecked&quot;)    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);    +				out.collect(&quot;Hallo&quot;);    +				out.collect(&quot;Ciao&quot;);    +				return null;    +			}
&lt;p&gt;    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never()).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementContinue() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// CONTINUE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFire() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFireAndPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE_AND_PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // trigger timer and GC timer&lt;br/&gt;
    +&lt;br/&gt;
    +		// no output&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeContinue(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should register two timers because we have two windows&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// we don&apos;t want to fire the cleanup timer
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents plus trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFire(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFireAndPurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireAndPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state stays until GC time&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimePurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(4, 6)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 1L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +&lt;br/&gt;
    +		// still no output&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for a non-existent window fires.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testNoTimerFiringForPurgedWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				return TriggerResult.PURGE;
    +			}&lt;br/&gt;
    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries()); // not contents or state&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for an empty merging window.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForPurgedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception {    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];    +				// don&apos;t interfere with cleanup timers    +				timeAdaptor.registerTimer(context, 0L);    +				return TriggerResult.PURGE;    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, testHarness.numKeyedStateEntries()); // just the merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * fires for a merging window that was already garbage collected.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForGarbageCollectedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// set a timer for after the GC time
    +				timeAdaptor.registerTimer(context, 10L);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // window contents and merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should trigger GC&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 4L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockTrigger, times(1)).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		// we still have a dangling timer because our trigger doesn&apos;t do cleanup&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness));&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// now we trigger the dangling timer&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 10L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// we don&apos;t fire again&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testTimerCreationAndDeletion(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 2)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private void testTimerFiring(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.advanceTime(testHarness, 1);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 1L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		// doesn&apos;t do anything
    +		timeAdaptor.advanceTime(testHarness, 15);
    +
    +		// so still the same
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		timeAdaptor.advanceTime(testHarness, 42);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 17L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 42L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(3), null, null);
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public void testDeletedTimerDoesNotFire(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 2);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.advanceTime(testHarness, 50L);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(0), 1L, null);
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), 2L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testMergeWindowsIsCalled() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4))), anyMergeCallback());&lt;br/&gt;
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4), new TimeWindow(0, 2))), anyMergeCallback());&lt;br/&gt;
    +		verify(mockAssigner, times(2)).mergeWindows(anyCollection(), anyMergeCallback());&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    too many unnecessary empty lines here&lt;/p&gt;</comment>
                            <comment id="15935932" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107346963&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107346963&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -122,6 +121,20 @@ public void processElement(StreamRecord&amp;lt;IN&amp;gt; element) throws Exception {&lt;br/&gt;
     							public void merge(W mergeResult,&lt;br/&gt;
     									Collection&amp;lt;W&amp;gt; mergedWindows, W stateWindowResult,&lt;br/&gt;
     									Collection&amp;lt;W&amp;gt; mergedStateWindows) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +								if ((windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentWatermark())) &lt;/p&gt;
{
    +									throw new UnsupportedOperationException(&quot;The end timestamp of an &quot; +
    +											&quot;event-time window cannot become earlier than the current watermark &quot; +
    +											&quot;by merging. Current watermark: &quot; + internalTimerService.currentWatermark() +
    +											&quot; window: &quot; + mergeResult);
    +								}
&lt;p&gt; else if (!windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentProcessingTime()) {&lt;br/&gt;
    +									throw new UnsupportedOperationException(&quot;The end timestamp of a &quot; +&lt;br/&gt;
    +											&quot;processing-time window cannot become earlier than the current procesing time&quot; +&lt;br/&gt;
    +											&quot;by merging. Current processing time: &quot; + internalTimerService.currentProcessingTime() +&lt;br/&gt;
    +											&quot; window: &quot; + mergeResult);&lt;br/&gt;
    +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    unnecessary empty line&lt;/p&gt;</comment>
                            <comment id="15935933" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107354200&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107354200&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerIsInvokedOncePerElement() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(2)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerWithMultipleWindows() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		shouldFireOnElement(mockTrigger);
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testWindowsDontInterfere() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		// no output so far
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());
    +
    +		// state for two windows
    +		assertEquals(2, testHarness.numKeyedStateEntries());
    +		assertEquals(2, testHarness.numEventTimeTimers());
    +
    +		// now we fire
    +		shouldFireOnElement(mockTrigger);
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0, 0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(1), eq(new TimeWindow(0, 1)), intIterable(1, 1), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementCalledPerWindow() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(42, 1L));
    +
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(2, 4)), anyTriggerContext());
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(0, 2)), anyTriggerContext());
    +
    +		verify(mockTrigger, times(2)).onElement(anyInt(), anyLong(), anyTimeWindow(), anyTriggerContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunction() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);
    +				out.collect(&quot;Hallo&quot;);
    +				out.collect(&quot;Ciao&quot;);
    +				return null;
    +			}&lt;br/&gt;
    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnEventTime() throws Exception {
    +		testEmittingFromWindowFunction(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnProcessingTime() throws Exception {
    +		testEmittingFromWindowFunction(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private  void testEmittingFromWindowFunction(TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception {    +				@SuppressWarnings(&quot;unchecked&quot;)    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);    +				out.collect(&quot;Hallo&quot;);    +				out.collect(&quot;Ciao&quot;);    +				return null;    +			}
&lt;p&gt;    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never()).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementContinue() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// CONTINUE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFire() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFireAndPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE_AND_PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // trigger timer and GC timer&lt;br/&gt;
    +&lt;br/&gt;
    +		// no output&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeContinue(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should register two timers because we have two windows&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// we don&apos;t want to fire the cleanup timer
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents plus trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFire(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFireAndPurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireAndPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state stays until GC time&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimePurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(4, 6)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 1L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +&lt;br/&gt;
    +		// still no output&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for a non-existent window fires.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testNoTimerFiringForPurgedWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				return TriggerResult.PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries()); // not contents or state&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedMergingWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedMergingWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for an empty merging window.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    seems like a missing word here: &quot;if a timer &lt;em&gt;fires&lt;/em&gt; for an empty merging window&quot;&lt;/p&gt;</comment>
                            <comment id="15935934" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107350215&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107350215&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I think there was some sort of agreement in avoiding Guava in Flink.&lt;/p&gt;</comment>
                            <comment id="15935935" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107346816&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107346816&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -122,6 +121,20 @@ public void processElement(StreamRecord&amp;lt;IN&amp;gt; element) throws Exception {&lt;br/&gt;
     							public void merge(W mergeResult,&lt;br/&gt;
     									Collection&amp;lt;W&amp;gt; mergedWindows, W stateWindowResult,&lt;br/&gt;
     									Collection&amp;lt;W&amp;gt; mergedStateWindows) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +								if ((windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentWatermark())) &lt;/p&gt;
{
    +									throw new UnsupportedOperationException(&quot;The end timestamp of an &quot; +
    +											&quot;event-time window cannot become earlier than the current watermark &quot; +
    +											&quot;by merging. Current watermark: &quot; + internalTimerService.currentWatermark() +
    +											&quot; window: &quot; + mergeResult);
    +								}
&lt;p&gt; else if (!windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentProcessingTime()) {&lt;br/&gt;
    +									throw new UnsupportedOperationException(&quot;The end timestamp of a &quot; +&lt;br/&gt;
    +											&quot;processing-time window cannot become earlier than the current procesing time&quot; +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Missing space between &quot;... processing time&quot; and &quot; by merging&quot;.&lt;/p&gt;</comment>
                            <comment id="15935936" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107352734&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107352734&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception {&lt;br/&gt;
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    can we resuse `anyTimeWindow()` to replace `Matchers.&amp;lt;TimeWindow&amp;gt;any()`, just because we&apos;ve defined the method in this class anyways &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;?&lt;/p&gt;</comment>
                            <comment id="15935937" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107353123&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107353123&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Also, should we consider moving the static mock / matcher util methods to a separate class, similar to the `StreamRecordMatchers` class?&lt;/p&gt;</comment>
                            <comment id="15935938" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107349684&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107349684&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    nitpick: The line spacing between the tests / methods in this class is also generally a bit off, occasionally there&apos;s 2-line spacings.&lt;/p&gt;</comment>
                            <comment id="15935939" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107349222&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107349222&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    type: I think it&apos;s &quot;late-data&quot;&lt;/p&gt;</comment>
                            <comment id="15935940" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107356162&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107356162&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -1577,6 +1585,91 @@ public TriggerResult answer(InvocationOnMock invocation) throws Exception {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Test&lt;br/&gt;
    +	public void testRejectShrinkingMergingEventTimeWindows() throws Exception &lt;/p&gt;
{
    +		testRejectShrinkingMergingWindows(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRejectShrinkingMergingProcessingTimeWindows() throws Exception &lt;/p&gt;
{
    +		testRejectShrinkingMergingWindows(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * A misbehaving &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; can cause a window to become late by merging if&lt;br/&gt;
    +	 * it moves the end-of-window time before the watermark. This verifies that we don&apos;t allow that.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testRejectShrinkingMergingWindows(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 5);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				timeAdaptor.registerTimer(context, window.maxTimestamp());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[0];
    +				Trigger.OnMergeContext context = (Trigger.OnMergeContext) invocation.getArguments()[1];
    +				timeAdaptor.registerTimer(context, window.maxTimestamp());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onMerge(anyTimeWindow(), anyOnMergeContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[0];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[1];
    +				timeAdaptor.deleteTimer(context, window.maxTimestamp());
    +				context.getPartitionedState(valueStateDescriptor).clear();
    +				return null;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(8, 11)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(3, testHarness.numKeyedStateEntries()); // window state plus trigger state plus merging window set&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // cleanup timer == end-of-window timer&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(10, 13)));&lt;br/&gt;
    +&lt;br/&gt;
    +		shouldMergeWindows(&lt;br/&gt;
    +				mockAssigner,&lt;br/&gt;
    +				Lists.newArrayList(new TimeWindow(8, 11), new TimeWindow(10, 13)),&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Avoid Guava.&lt;/p&gt;</comment>
                            <comment id="15935941" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107347411&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107347411&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -352,6 +352,20 @@ public void processElement(StreamRecord&amp;lt;IN&amp;gt; element) throws Exception {&lt;br/&gt;
     					public void merge(W mergeResult,&lt;br/&gt;
     							Collection&amp;lt;W&amp;gt; mergedWindows, W stateWindowResult,&lt;br/&gt;
     							Collection&amp;lt;W&amp;gt; mergedStateWindows) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +						if ((windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentWatermark())) &lt;/p&gt;
{
    +							throw new UnsupportedOperationException(&quot;The end timestamp of an &quot; +
    +									&quot;event-time window cannot become earlier than the current watermark &quot; +
    +									&quot;by merging. Current watermark: &quot; + internalTimerService.currentWatermark() +
    +									&quot; window: &quot; + mergeResult);
    +						}
&lt;p&gt; else if (!windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentProcessingTime()) {&lt;br/&gt;
    +							throw new UnsupportedOperationException(&quot;The end timestamp of a &quot; +&lt;br/&gt;
    +									&quot;processing-time window cannot become earlier than the current procesing time&quot; +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Missing space between &quot;... processing time&quot; and &quot; by merging&quot;.&lt;/p&gt;</comment>
                            <comment id="15935942" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107347802&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107347802&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -138,7 +138,7 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;{@code window.maxTimestamp + allowedLateness}
&lt;p&gt; is smaller than the current watermark will&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;be emitted to this.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final OutputTag&amp;lt;IN&amp;gt; lateDataOutputTag;&lt;br/&gt;
    +	protected final OutputTag&amp;lt;IN&amp;gt; lateDataOutputTag;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Should we use the &quot;@VisibleForTesting&quot; annotation, or comment that it is exposed for testing?&lt;/p&gt;</comment>
                            <comment id="15935943" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107355610&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107355610&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -1577,6 +1585,91 @@ public TriggerResult answer(InvocationOnMock invocation) throws Exception {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Test&lt;br/&gt;
    +	public void testRejectShrinkingMergingEventTimeWindows() throws Exception &lt;/p&gt;
{
    +		testRejectShrinkingMergingWindows(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRejectShrinkingMergingProcessingTimeWindows() throws Exception &lt;/p&gt;
{
    +		testRejectShrinkingMergingWindows(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * A misbehaving &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; can cause a window to become late by merging if&lt;br/&gt;
    +	 * it moves the end-of-window time before the watermark. This verifies that we don&apos;t allow that.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testRejectShrinkingMergingWindows(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 5);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				timeAdaptor.registerTimer(context, window.maxTimestamp());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I wonder if we want to have a common class to contain all these static mock util methods for these kind of bigger stubs too.&lt;br/&gt;
    Together with `EvictingWindowOperatorContractTest` that could save quite a bit of LoC and easier to read.&lt;/p&gt;</comment>
                            <comment id="15935944" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107352208&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107352208&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerIsInvokedOncePerElement() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(2)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerWithMultipleWindows() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		shouldFireOnElement(mockTrigger);
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testWindowsDontInterfere() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		// no output so far
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());
    +
    +		// state for two windows
    +		assertEquals(2, testHarness.numKeyedStateEntries());
    +		assertEquals(2, testHarness.numEventTimeTimers());
    +
    +		// now we fire
    +		shouldFireOnElement(mockTrigger);
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0, 0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(1), eq(new TimeWindow(0, 1)), intIterable(1, 1), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementCalledPerWindow() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(42, 1L));
    +
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(2, 4)), anyTriggerContext());
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(0, 2)), anyTriggerContext());
    +
    +		verify(mockTrigger, times(2)).onElement(anyInt(), anyLong(), anyTimeWindow(), anyTriggerContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunction() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Why not reuse `shouldFireOnElement` here?&lt;/p&gt;</comment>
                            <comment id="15935945" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107348912&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107348912&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    nitpick: For this class, can we place all the private static test and mock utilities before the actual @Tests?&lt;br/&gt;
    Just a habit of putting the actual working public stuff before privates and utilities, isn&apos;t necessary if you don&apos;t agree &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15935946" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107354721&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107354721&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerIsInvokedOncePerElement() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(2)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerWithMultipleWindows() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		shouldFireOnElement(mockTrigger);
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testWindowsDontInterfere() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		// no output so far
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());
    +
    +		// state for two windows
    +		assertEquals(2, testHarness.numKeyedStateEntries());
    +		assertEquals(2, testHarness.numEventTimeTimers());
    +
    +		// now we fire
    +		shouldFireOnElement(mockTrigger);
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0, 0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(1), eq(new TimeWindow(0, 1)), intIterable(1, 1), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementCalledPerWindow() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(42, 1L));
    +
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(2, 4)), anyTriggerContext());
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(0, 2)), anyTriggerContext());
    +
    +		verify(mockTrigger, times(2)).onElement(anyInt(), anyLong(), anyTimeWindow(), anyTriggerContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunction() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);
    +				out.collect(&quot;Hallo&quot;);
    +				out.collect(&quot;Ciao&quot;);
    +				return null;
    +			}&lt;br/&gt;
    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnEventTime() throws Exception {
    +		testEmittingFromWindowFunction(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnProcessingTime() throws Exception {
    +		testEmittingFromWindowFunction(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private  void testEmittingFromWindowFunction(TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception {    +				@SuppressWarnings(&quot;unchecked&quot;)    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);    +				out.collect(&quot;Hallo&quot;);    +				out.collect(&quot;Ciao&quot;);    +				return null;    +			}
&lt;p&gt;    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never()).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementContinue() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// CONTINUE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFire() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFireAndPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE_AND_PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // trigger timer and GC timer&lt;br/&gt;
    +&lt;br/&gt;
    +		// no output&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeContinue(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should register two timers because we have two windows&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// we don&apos;t want to fire the cleanup timer
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents plus trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFire(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFireAndPurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireAndPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state stays until GC time&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimePurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(4, 6)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 1L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +&lt;br/&gt;
    +		// still no output&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for a non-existent window fires.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testNoTimerFiringForPurgedWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				return TriggerResult.PURGE;
    +			}&lt;br/&gt;
    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries()); // not contents or state&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for an empty merging window.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForPurgedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception {    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];    +				// don&apos;t interfere with cleanup timers    +				timeAdaptor.registerTimer(context, 0L);    +				return TriggerResult.PURGE;    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, testHarness.numKeyedStateEntries()); // just the merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * fires for a merging window that was already garbage collected.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForGarbageCollectedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// set a timer for after the GC time
    +				timeAdaptor.registerTimer(context, 10L);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // window contents and merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should trigger GC&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 4L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockTrigger, times(1)).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		// we still have a dangling timer because our trigger doesn&apos;t do cleanup&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness));&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// now we trigger the dangling timer&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 10L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// we don&apos;t fire again&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testTimerCreationAndDeletion(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 2)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private void testTimerFiring(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.advanceTime(testHarness, 1);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 1L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		// doesn&apos;t do anything
    +		timeAdaptor.advanceTime(testHarness, 15);
    +
    +		// so still the same
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		timeAdaptor.advanceTime(testHarness, 42);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 17L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 42L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(3), null, null);
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public void testDeletedTimerDoesNotFire(TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This can be private.&lt;/p&gt;</comment>
                            <comment id="15935947" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107354758&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107354758&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerIsInvokedOncePerElement() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(2)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerWithMultipleWindows() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		shouldFireOnElement(mockTrigger);
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testWindowsDontInterfere() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		// no output so far
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());
    +
    +		// state for two windows
    +		assertEquals(2, testHarness.numKeyedStateEntries());
    +		assertEquals(2, testHarness.numEventTimeTimers());
    +
    +		// now we fire
    +		shouldFireOnElement(mockTrigger);
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0, 0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(1), eq(new TimeWindow(0, 1)), intIterable(1, 1), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementCalledPerWindow() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(42, 1L));
    +
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(2, 4)), anyTriggerContext());
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(0, 2)), anyTriggerContext());
    +
    +		verify(mockTrigger, times(2)).onElement(anyInt(), anyLong(), anyTimeWindow(), anyTriggerContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunction() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);
    +				out.collect(&quot;Hallo&quot;);
    +				out.collect(&quot;Ciao&quot;);
    +				return null;
    +			}&lt;br/&gt;
    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnEventTime() throws Exception {
    +		testEmittingFromWindowFunction(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnProcessingTime() throws Exception {
    +		testEmittingFromWindowFunction(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private  void testEmittingFromWindowFunction(TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception {    +				@SuppressWarnings(&quot;unchecked&quot;)    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);    +				out.collect(&quot;Hallo&quot;);    +				out.collect(&quot;Ciao&quot;);    +				return null;    +			}
&lt;p&gt;    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never()).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementContinue() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// CONTINUE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFire() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFireAndPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE_AND_PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // trigger timer and GC timer&lt;br/&gt;
    +&lt;br/&gt;
    +		// no output&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeContinue(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should register two timers because we have two windows&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// we don&apos;t want to fire the cleanup timer
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents plus trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFire(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFireAndPurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireAndPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state stays until GC time&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimePurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(4, 6)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 1L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +&lt;br/&gt;
    +		// still no output&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for a non-existent window fires.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testNoTimerFiringForPurgedWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				return TriggerResult.PURGE;
    +			}&lt;br/&gt;
    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries()); // not contents or state&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for an empty merging window.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForPurgedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception {    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];    +				// don&apos;t interfere with cleanup timers    +				timeAdaptor.registerTimer(context, 0L);    +				return TriggerResult.PURGE;    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, testHarness.numKeyedStateEntries()); // just the merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * fires for a merging window that was already garbage collected.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForGarbageCollectedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// set a timer for after the GC time
    +				timeAdaptor.registerTimer(context, 10L);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // window contents and merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should trigger GC&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 4L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockTrigger, times(1)).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		// we still have a dangling timer because our trigger doesn&apos;t do cleanup&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness));&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// now we trigger the dangling timer&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 10L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// we don&apos;t fire again&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testTimerCreationAndDeletion(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 2)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private void testTimerFiring(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.advanceTime(testHarness, 1);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 1L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		// doesn&apos;t do anything
    +		timeAdaptor.advanceTime(testHarness, 15);
    +
    +		// so still the same
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		timeAdaptor.advanceTime(testHarness, 42);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 17L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 42L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(3), null, null);
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public void testDeletedTimerDoesNotFire(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 2);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.advanceTime(testHarness, 50L);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(0), 1L, null);
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), 2L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testMergeWindowsIsCalled() throws Exception &lt;/p&gt;
{
    +
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		assertEquals(0, testHarness.getOutput().size());
    +		assertEquals(0, testHarness.numKeyedStateEntries());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4))), anyMergeCallback());
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4), new TimeWindow(0, 2))), anyMergeCallback());
    +		verify(mockAssigner, times(2)).mergeWindows(anyCollection(), anyMergeCallback());
    +
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeWindowsAreMergedEagerly() throws Exception &lt;/p&gt;
{
    +		testWindowsAreMergedEagerly(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeWindowsAreMergedEagerly() throws Exception &lt;/p&gt;
{
    +		testWindowsAreMergedEagerly(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that windows are merged eagerly, if possible.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testWindowsAreMergedEagerly(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Private &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15935948" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107351397&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107351397&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerIsInvokedOncePerElement() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(2)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerWithMultipleWindows() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		shouldFireOnElement(mockTrigger);
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testWindowsDontInterfere() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		// no output so far
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());
    +
    +		// state for two windows
    +		assertEquals(2, testHarness.numKeyedStateEntries());
    +		assertEquals(2, testHarness.numEventTimeTimers());
    +
    +		// now we fire
    +		shouldFireOnElement(mockTrigger);
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0, 0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(1), eq(new TimeWindow(0, 1)), intIterable(1, 1), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementCalledPerWindow() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(42, 1L));
    +
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(2, 4)), anyTriggerContext());
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(0, 2)), anyTriggerContext());
    +
    +		verify(mockTrigger, times(2)).onElement(anyInt(), anyLong(), anyTimeWindow(), anyTriggerContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunction() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);
    +				out.collect(&quot;Hallo&quot;);
    +				out.collect(&quot;Ciao&quot;);
    +				return null;
    +			}&lt;br/&gt;
    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnEventTime() throws Exception {
    +		testEmittingFromWindowFunction(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnProcessingTime() throws Exception {
    +		testEmittingFromWindowFunction(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private  void testEmittingFromWindowFunction(TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception {    +				@SuppressWarnings(&quot;unchecked&quot;)    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);    +				out.collect(&quot;Hallo&quot;);    +				out.collect(&quot;Ciao&quot;);    +				return null;    +			}
&lt;p&gt;    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never()).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementContinue() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// CONTINUE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFire() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFireAndPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE_AND_PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // trigger timer and GC timer&lt;br/&gt;
    +&lt;br/&gt;
    +		// no output&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeContinue(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should register two timers because we have two windows&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// we don&apos;t want to fire the cleanup timer
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents plus trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFire(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFireAndPurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireAndPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state stays until GC time&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimePurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(4, 6)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 1L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +&lt;br/&gt;
    +		// still no output&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for a non-existent window fires.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testNoTimerFiringForPurgedWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				return TriggerResult.PURGE;
    +			}&lt;br/&gt;
    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries()); // not contents or state&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for an empty merging window.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForPurgedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception {    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];    +				// don&apos;t interfere with cleanup timers    +				timeAdaptor.registerTimer(context, 0L);    +				return TriggerResult.PURGE;    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, testHarness.numKeyedStateEntries()); // just the merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * fires for a merging window that was already garbage collected.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForGarbageCollectedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// set a timer for after the GC time
    +				timeAdaptor.registerTimer(context, 10L);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // window contents and merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should trigger GC&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 4L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockTrigger, times(1)).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		// we still have a dangling timer because our trigger doesn&apos;t do cleanup&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness));&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// now we trigger the dangling timer&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 10L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// we don&apos;t fire again&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testTimerCreationAndDeletion(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 2)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private void testTimerFiring(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.advanceTime(testHarness, 1);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 1L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		// doesn&apos;t do anything
    +		timeAdaptor.advanceTime(testHarness, 15);
    +
    +		// so still the same
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		timeAdaptor.advanceTime(testHarness, 42);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 17L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 42L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(3), null, null);
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public void testDeletedTimerDoesNotFire(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 2);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.advanceTime(testHarness, 50L);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(0), 1L, null);
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), 2L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testMergeWindowsIsCalled() throws Exception &lt;/p&gt;
{
    +
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		assertEquals(0, testHarness.getOutput().size());
    +		assertEquals(0, testHarness.numKeyedStateEntries());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4))), anyMergeCallback());
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4), new TimeWindow(0, 2))), anyMergeCallback());
    +		verify(mockAssigner, times(2)).mergeWindows(anyCollection(), anyMergeCallback());
    +
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeWindowsAreMergedEagerly() throws Exception &lt;/p&gt;
{
    +		testWindowsAreMergedEagerly(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeWindowsAreMergedEagerly() throws Exception &lt;/p&gt;
{
    +		testWindowsAreMergedEagerly(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that windows are merged eagerly, if possible.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testWindowsAreMergedEagerly(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +		// in this test we only have one state window and windows are eagerly&lt;br/&gt;
    +		// merged into the first window&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t intefere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.OnMergeContext context = (Trigger.OnMergeContext) invocation.getArguments()[1];
    +				// don&apos;t intefere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onMerge(anyTimeWindow(), anyOnMergeContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[1];
    +				timeAdaptor.deleteTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).clear();
    +				return null;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(3, testHarness.numKeyedStateEntries()); // window state plus trigger state plus merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and GC timer&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		shouldMergeWindows(&lt;br/&gt;
    +				mockAssigner,&lt;br/&gt;
    +				Lists.newArrayList(new TimeWindow(0, 2), new TimeWindow(2, 4)),&lt;br/&gt;
    +				Lists.newArrayList(new TimeWindow(0, 2), new TimeWindow(2, 4)),&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Same here, avoid Guava &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15935949" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107354646&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107354646&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerIsInvokedOncePerElement() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(2)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerWithMultipleWindows() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		shouldFireOnElement(mockTrigger);
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testWindowsDontInterfere() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		// no output so far
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());
    +
    +		// state for two windows
    +		assertEquals(2, testHarness.numKeyedStateEntries());
    +		assertEquals(2, testHarness.numEventTimeTimers());
    +
    +		// now we fire
    +		shouldFireOnElement(mockTrigger);
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0, 0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(1), eq(new TimeWindow(0, 1)), intIterable(1, 1), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementCalledPerWindow() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(42, 1L));
    +
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(2, 4)), anyTriggerContext());
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(0, 2)), anyTriggerContext());
    +
    +		verify(mockTrigger, times(2)).onElement(anyInt(), anyLong(), anyTimeWindow(), anyTriggerContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunction() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);
    +				out.collect(&quot;Hallo&quot;);
    +				out.collect(&quot;Ciao&quot;);
    +				return null;
    +			}&lt;br/&gt;
    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnEventTime() throws Exception {
    +		testEmittingFromWindowFunction(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnProcessingTime() throws Exception {
    +		testEmittingFromWindowFunction(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private  void testEmittingFromWindowFunction(TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception {    +				@SuppressWarnings(&quot;unchecked&quot;)    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);    +				out.collect(&quot;Hallo&quot;);    +				out.collect(&quot;Ciao&quot;);    +				return null;    +			}
&lt;p&gt;    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never()).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementContinue() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// CONTINUE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFire() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFireAndPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE_AND_PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // trigger timer and GC timer&lt;br/&gt;
    +&lt;br/&gt;
    +		// no output&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeContinue(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should register two timers because we have two windows&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// we don&apos;t want to fire the cleanup timer
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents plus trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFire(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFireAndPurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireAndPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state stays until GC time&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimePurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(4, 6)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 1L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +&lt;br/&gt;
    +		// still no output&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for a non-existent window fires.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testNoTimerFiringForPurgedWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				return TriggerResult.PURGE;
    +			}&lt;br/&gt;
    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries()); // not contents or state&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for an empty merging window.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForPurgedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception {    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];    +				// don&apos;t interfere with cleanup timers    +				timeAdaptor.registerTimer(context, 0L);    +				return TriggerResult.PURGE;    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, testHarness.numKeyedStateEntries()); // just the merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * fires for a merging window that was already garbage collected.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForGarbageCollectedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// set a timer for after the GC time
    +				timeAdaptor.registerTimer(context, 10L);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // window contents and merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should trigger GC&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 4L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockTrigger, times(1)).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		// we still have a dangling timer because our trigger doesn&apos;t do cleanup&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness));&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// now we trigger the dangling timer&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 10L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// we don&apos;t fire again&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testTimerCreationAndDeletion(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 2)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private void testTimerFiring(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.advanceTime(testHarness, 1);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 1L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		// doesn&apos;t do anything
    +		timeAdaptor.advanceTime(testHarness, 15);
    +
    +		// so still the same
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		timeAdaptor.advanceTime(testHarness, 42);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 17L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 42L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(3), null, null);
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public void testDeletedTimerDoesNotFire(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 2);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.advanceTime(testHarness, 50L);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(0), 1L, null);
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), 2L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testMergeWindowsIsCalled() throws Exception &lt;/p&gt;
{
    +
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		assertEquals(0, testHarness.getOutput().size());
    +		assertEquals(0, testHarness.numKeyedStateEntries());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4))), anyMergeCallback());
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4), new TimeWindow(0, 2))), anyMergeCallback());
    +		verify(mockAssigner, times(2)).mergeWindows(anyCollection(), anyMergeCallback());
    +
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeWindowsAreMergedEagerly() throws Exception &lt;/p&gt;
{
    +		testWindowsAreMergedEagerly(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeWindowsAreMergedEagerly() throws Exception &lt;/p&gt;
{
    +		testWindowsAreMergedEagerly(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that windows are merged eagerly, if possible.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testWindowsAreMergedEagerly(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +		// in this test we only have one state window and windows are eagerly&lt;br/&gt;
    +		// merged into the first window&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t intefere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.OnMergeContext context = (Trigger.OnMergeContext) invocation.getArguments()[1];
    +				// don&apos;t intefere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onMerge(anyTimeWindow(), anyOnMergeContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[1];
    +				timeAdaptor.deleteTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).clear();
    +				return null;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(3, testHarness.numKeyedStateEntries()); // window state plus trigger state plus merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and GC timer&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		shouldMergeWindows(&lt;br/&gt;
    +				mockAssigner,&lt;br/&gt;
    +				Lists.newArrayList(new TimeWindow(0, 2), new TimeWindow(2, 4)),&lt;br/&gt;
    +				Lists.newArrayList(new TimeWindow(0, 2), new TimeWindow(2, 4)),&lt;br/&gt;
    +				new TimeWindow(0, 4));&lt;br/&gt;
    +&lt;br/&gt;
    +		// don&apos;t register a timer or update state in onElement, this checks&lt;br/&gt;
    +		// whether onMerge does correctly set those things&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockTrigger).onMerge(eq(new TimeWindow(0, 4)), anyOnMergeContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(3, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRejectShrinkingMergingEventTimeWindows() throws Exception {&lt;br/&gt;
    +		testRejectShrinkingMergingWindows(new EventTimeAdaptor());&lt;br/&gt;
    +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This can be private.&lt;/p&gt;</comment>
                            <comment id="15935950" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107351285&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107351285&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerIsInvokedOncePerElement() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(2)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerWithMultipleWindows() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		shouldFireOnElement(mockTrigger);
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testWindowsDontInterfere() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		// no output so far
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());
    +
    +		// state for two windows
    +		assertEquals(2, testHarness.numKeyedStateEntries());
    +		assertEquals(2, testHarness.numEventTimeTimers());
    +
    +		// now we fire
    +		shouldFireOnElement(mockTrigger);
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0, 0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(1), eq(new TimeWindow(0, 1)), intIterable(1, 1), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementCalledPerWindow() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(42, 1L));
    +
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(2, 4)), anyTriggerContext());
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(0, 2)), anyTriggerContext());
    +
    +		verify(mockTrigger, times(2)).onElement(anyInt(), anyLong(), anyTimeWindow(), anyTriggerContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunction() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);
    +				out.collect(&quot;Hallo&quot;);
    +				out.collect(&quot;Ciao&quot;);
    +				return null;
    +			}&lt;br/&gt;
    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnEventTime() throws Exception {
    +		testEmittingFromWindowFunction(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnProcessingTime() throws Exception {
    +		testEmittingFromWindowFunction(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private  void testEmittingFromWindowFunction(TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception {    +				@SuppressWarnings(&quot;unchecked&quot;)    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);    +				out.collect(&quot;Hallo&quot;);    +				out.collect(&quot;Ciao&quot;);    +				return null;    +			}
&lt;p&gt;    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never()).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementContinue() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// CONTINUE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFire() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFireAndPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE_AND_PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // trigger timer and GC timer&lt;br/&gt;
    +&lt;br/&gt;
    +		// no output&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeContinue(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should register two timers because we have two windows&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// we don&apos;t want to fire the cleanup timer
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents plus trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFire(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFireAndPurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireAndPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state stays until GC time&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimePurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(4, 6)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 1L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +&lt;br/&gt;
    +		// still no output&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for a non-existent window fires.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testNoTimerFiringForPurgedWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				return TriggerResult.PURGE;
    +			}&lt;br/&gt;
    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries()); // not contents or state&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for an empty merging window.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForPurgedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception {    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];    +				// don&apos;t interfere with cleanup timers    +				timeAdaptor.registerTimer(context, 0L);    +				return TriggerResult.PURGE;    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, testHarness.numKeyedStateEntries()); // just the merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * fires for a merging window that was already garbage collected.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForGarbageCollectedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// set a timer for after the GC time
    +				timeAdaptor.registerTimer(context, 10L);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // window contents and merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should trigger GC&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 4L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockTrigger, times(1)).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		// we still have a dangling timer because our trigger doesn&apos;t do cleanup&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness));&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// now we trigger the dangling timer&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 10L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// we don&apos;t fire again&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testTimerCreationAndDeletion(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 2)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private void testTimerFiring(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.advanceTime(testHarness, 1);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 1L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		// doesn&apos;t do anything
    +		timeAdaptor.advanceTime(testHarness, 15);
    +
    +		// so still the same
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		timeAdaptor.advanceTime(testHarness, 42);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 17L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 42L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(3), null, null);
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public void testDeletedTimerDoesNotFire(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 2);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.advanceTime(testHarness, 50L);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(0), 1L, null);
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), 2L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testMergeWindowsIsCalled() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4))), anyMergeCallback());&lt;br/&gt;
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4), new TimeWindow(0, 2))), anyMergeCallback());&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Avoid Guava in Flink. `Arrays.asList(...)` should do fine.&lt;/p&gt;</comment>
                            <comment id="15935951" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107354581&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107354581&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerIsInvokedOncePerElement() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(2)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerWithMultipleWindows() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		shouldFireOnElement(mockTrigger);
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testWindowsDontInterfere() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		// no output so far
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());
    +
    +		// state for two windows
    +		assertEquals(2, testHarness.numKeyedStateEntries());
    +		assertEquals(2, testHarness.numEventTimeTimers());
    +
    +		// now we fire
    +		shouldFireOnElement(mockTrigger);
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0, 0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(1), eq(new TimeWindow(0, 1)), intIterable(1, 1), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementCalledPerWindow() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(42, 1L));
    +
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(2, 4)), anyTriggerContext());
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(0, 2)), anyTriggerContext());
    +
    +		verify(mockTrigger, times(2)).onElement(anyInt(), anyLong(), anyTimeWindow(), anyTriggerContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunction() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);
    +				out.collect(&quot;Hallo&quot;);
    +				out.collect(&quot;Ciao&quot;);
    +				return null;
    +			}&lt;br/&gt;
    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnEventTime() throws Exception {
    +		testEmittingFromWindowFunction(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnProcessingTime() throws Exception {
    +		testEmittingFromWindowFunction(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private  void testEmittingFromWindowFunction(TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception {    +				@SuppressWarnings(&quot;unchecked&quot;)    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);    +				out.collect(&quot;Hallo&quot;);    +				out.collect(&quot;Ciao&quot;);    +				return null;    +			}
&lt;p&gt;    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never()).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementContinue() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// CONTINUE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFire() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFireAndPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE_AND_PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // trigger timer and GC timer&lt;br/&gt;
    +&lt;br/&gt;
    +		// no output&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeContinue(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should register two timers because we have two windows&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// we don&apos;t want to fire the cleanup timer
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents plus trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFire(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFireAndPurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireAndPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state stays until GC time&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimePurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(4, 6)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 1L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +&lt;br/&gt;
    +		// still no output&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for a non-existent window fires.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testNoTimerFiringForPurgedWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				return TriggerResult.PURGE;
    +			}&lt;br/&gt;
    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries()); // not contents or state&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for an empty merging window.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForPurgedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception {    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];    +				// don&apos;t interfere with cleanup timers    +				timeAdaptor.registerTimer(context, 0L);    +				return TriggerResult.PURGE;    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, testHarness.numKeyedStateEntries()); // just the merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * fires for a merging window that was already garbage collected.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForGarbageCollectedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// set a timer for after the GC time
    +				timeAdaptor.registerTimer(context, 10L);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // window contents and merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should trigger GC&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 4L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockTrigger, times(1)).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		// we still have a dangling timer because our trigger doesn&apos;t do cleanup&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness));&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// now we trigger the dangling timer&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 10L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// we don&apos;t fire again&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testTimerCreationAndDeletion(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 2)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private void testTimerFiring(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.advanceTime(testHarness, 1);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 1L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		// doesn&apos;t do anything
    +		timeAdaptor.advanceTime(testHarness, 15);
    +
    +		// so still the same
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		timeAdaptor.advanceTime(testHarness, 42);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 17L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 42L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(3), null, null);
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public void testDeletedTimerDoesNotFire(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 2);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.advanceTime(testHarness, 50L);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(0), 1L, null);
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), 2L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testMergeWindowsIsCalled() throws Exception &lt;/p&gt;
{
    +
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		assertEquals(0, testHarness.getOutput().size());
    +		assertEquals(0, testHarness.numKeyedStateEntries());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4))), anyMergeCallback());
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4), new TimeWindow(0, 2))), anyMergeCallback());
    +		verify(mockAssigner, times(2)).mergeWindows(anyCollection(), anyMergeCallback());
    +
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeWindowsAreMergedEagerly() throws Exception &lt;/p&gt;
{
    +		testWindowsAreMergedEagerly(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeWindowsAreMergedEagerly() throws Exception &lt;/p&gt;
{
    +		testWindowsAreMergedEagerly(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that windows are merged eagerly, if possible.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testWindowsAreMergedEagerly(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +		// in this test we only have one state window and windows are eagerly&lt;br/&gt;
    +		// merged into the first window&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t intefere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.OnMergeContext context = (Trigger.OnMergeContext) invocation.getArguments()[1];
    +				// don&apos;t intefere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onMerge(anyTimeWindow(), anyOnMergeContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[1];
    +				timeAdaptor.deleteTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).clear();
    +				return null;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(3, testHarness.numKeyedStateEntries()); // window state plus trigger state plus merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and GC timer&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		shouldMergeWindows(&lt;br/&gt;
    +				mockAssigner,&lt;br/&gt;
    +				Lists.newArrayList(new TimeWindow(0, 2), new TimeWindow(2, 4)),&lt;br/&gt;
    +				Lists.newArrayList(new TimeWindow(0, 2), new TimeWindow(2, 4)),&lt;br/&gt;
    +				new TimeWindow(0, 4));&lt;br/&gt;
    +&lt;br/&gt;
    +		// don&apos;t register a timer or update state in onElement, this checks&lt;br/&gt;
    +		// whether onMerge does correctly set those things&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockTrigger).onMerge(eq(new TimeWindow(0, 4)), anyOnMergeContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(3, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRejectShrinkingMergingEventTimeWindows() throws Exception {&lt;br/&gt;
    +		testRejectShrinkingMergingWindows(new EventTimeAdaptor());&lt;br/&gt;
    +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This can be private&lt;/p&gt;</comment>
                            <comment id="15935952" author="githubbot" created="Wed, 22 Mar 2017 08:51:41 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107354860&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107354860&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerIsInvokedOncePerElement() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(2)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerWithMultipleWindows() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		shouldFireOnElement(mockTrigger);
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testWindowsDontInterfere() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		// no output so far
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());
    +
    +		// state for two windows
    +		assertEquals(2, testHarness.numKeyedStateEntries());
    +		assertEquals(2, testHarness.numEventTimeTimers());
    +
    +		// now we fire
    +		shouldFireOnElement(mockTrigger);
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0, 0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(1), eq(new TimeWindow(0, 1)), intIterable(1, 1), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementCalledPerWindow() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(42, 1L));
    +
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(2, 4)), anyTriggerContext());
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(0, 2)), anyTriggerContext());
    +
    +		verify(mockTrigger, times(2)).onElement(anyInt(), anyLong(), anyTimeWindow(), anyTriggerContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunction() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);
    +				out.collect(&quot;Hallo&quot;);
    +				out.collect(&quot;Ciao&quot;);
    +				return null;
    +			}&lt;br/&gt;
    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnEventTime() throws Exception {
    +		testEmittingFromWindowFunction(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnProcessingTime() throws Exception {
    +		testEmittingFromWindowFunction(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private  void testEmittingFromWindowFunction(TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception {    +				@SuppressWarnings(&quot;unchecked&quot;)    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);    +				out.collect(&quot;Hallo&quot;);    +				out.collect(&quot;Ciao&quot;);    +				return null;    +			}
&lt;p&gt;    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never()).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementContinue() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// CONTINUE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFire() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window contents plus trigger state&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // window timers/gc timers&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementFireAndPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				TimeWindow window = (TimeWindow) invocation.getArguments()[2];
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(window.getEnd());
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.FIRE_AND_PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementPurge() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.PURGE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around until GC time&lt;br/&gt;
    +&lt;br/&gt;
    +		// timers will stick around&lt;br/&gt;
    +		assertEquals(4, testHarness.numEventTimeTimers()); // trigger timer and GC timer&lt;br/&gt;
    +&lt;br/&gt;
    +		// no output&lt;br/&gt;
    +		assertEquals(0, testHarness.getOutput().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeContinue() throws Exception &lt;/p&gt;
{
    +		testOnTimeContinue(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeContinue(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should register two timers because we have two windows&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// we don&apos;t want to fire the cleanup timer
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents plus trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +&lt;br/&gt;
    +		// there should be no firing&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFire() throws Exception &lt;/p&gt;
{
    +		testOnTimeFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFire(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE should not purge contents&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimeFireAndPurge() throws Exception &lt;/p&gt;
{
    +		testOnTimeFireAndPurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimeFireAndPurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldFireAndPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// FIRE_AND_PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state stays until GC time&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnEventTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnProcessingTimePurge() throws Exception &lt;/p&gt;
{
    +		testOnTimePurge(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testOnTimePurge(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(4, 6)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 1L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldPurgeOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(4, testHarness.numKeyedStateEntries()); // window-contents and trigger state for two windows&lt;br/&gt;
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // timers/gc timers for two windows&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 1L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// clear is only called at cleanup time/GC time&lt;br/&gt;
    +		verify(mockTrigger, never()).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		// PURGE should purge contents&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // trigger state will stick around&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // gc timers are still there&lt;br/&gt;
    +&lt;br/&gt;
    +		// still no output&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForPurgedWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for a non-existent window fires.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testNoTimerFiringForPurgedWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t interfere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				return TriggerResult.PURGE;
    +			}&lt;br/&gt;
    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries()); // not contents or state&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new EventTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForPurgedMergingWindow() throws Exception {
    +		testNoTimerFiringForPurgedMergingWindow(new ProcessingTimeAdaptor());
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * for an empty merging window.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForPurgedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception {    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];    +				// don&apos;t interfere with cleanup timers    +				timeAdaptor.registerTimer(context, 0L);    +				return TriggerResult.PURGE;    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, testHarness.numKeyedStateEntries()); // just the merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 0L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// trigger is not called if there is no more window (timer is silently ignored)&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, never(), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // only gc timers left&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoEventTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoProcessingTimeFiringForGarbageCollectedMergingWindow() throws Exception &lt;/p&gt;
{
    +		testNoTimerFiringForGarbageCollectedMergingWindow(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that we neither invoke the trigger nor the window function if a timer&lt;br/&gt;
    +	 * fires for a merging window that was already garbage collected.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testNoTimerFiringForGarbageCollectedMergingWindow(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +&lt;br/&gt;
    +		@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, List&amp;lt;Integer&amp;gt;, Integer, TimeWindow&amp;gt; mockWindowFunction =&lt;br/&gt;
    +				mock(InternalWindowFunction.class);&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, List&amp;lt;Integer&amp;gt;&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// set a timer for after the GC time
    +				timeAdaptor.registerTimer(context, 10L);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(2, testHarness.numKeyedStateEntries()); // window contents and merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and gc timer&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.shouldContinueOnTime(mockTrigger);&lt;br/&gt;
    +&lt;br/&gt;
    +		// this should trigger GC&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 4L);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockTrigger, times(1)).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		// we still have a dangling timer because our trigger doesn&apos;t do cleanup&lt;br/&gt;
    +		assertEquals(1, timeAdaptor.numTimers(testHarness));&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, never())&lt;br/&gt;
    +				.apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		// now we trigger the dangling timer&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, 10L);&lt;br/&gt;
    +&lt;br/&gt;
    +		// we don&apos;t fire again&lt;br/&gt;
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerCreationAndDeletion() throws Exception &lt;/p&gt;
{
    +		testTimerCreationAndDeletion(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private void testTimerCreationAndDeletion(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 2)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeTimerFiring() throws Exception &lt;/p&gt;
{
    +		testTimerFiring(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private void testTimerFiring(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 17);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 42);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(4, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		timeAdaptor.advanceTime(testHarness, 1);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 1L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +		assertEquals(3, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +
    +		// doesn&apos;t do anything
    +		timeAdaptor.advanceTime(testHarness, 15);
    +
    +		// so still the same
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		timeAdaptor.advanceTime(testHarness, 42);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 17L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, atLeastOnce(), 42L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(3), null, null);
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 because of the GC timer of the window
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeDeletedTimerDoesNotFire() throws Exception &lt;/p&gt;
{
    +		testDeletedTimerDoesNotFire(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public void testDeletedTimerDoesNotFire(TimeDomainAdaptor timeAdaptor) throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		timeAdaptor.setIsEventTime(mockAssigner);
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 100)));
    +
    +		assertEquals(0, timeAdaptor.numTimers(testHarness));
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldDeleteTimerOnElement(mockTrigger, 1);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.shouldRegisterTimerOnElement(mockTrigger, 2);
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +
    +		timeAdaptor.advanceTime(testHarness, 50L);
    +
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(0), 1L, null);
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), 2L, new TimeWindow(0, 100));
    +		timeAdaptor.verifyTriggerCallback(mockTrigger, times(1), null, null);
    +
    +		assertEquals(1, timeAdaptor.numTimers(testHarness)); // +1 for the GC timer
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testMergeWindowsIsCalled() throws Exception &lt;/p&gt;
{
    +
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		assertEquals(0, testHarness.getOutput().size());
    +		assertEquals(0, testHarness.numKeyedStateEntries());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4))), anyMergeCallback());
    +		verify(mockAssigner).mergeWindows(eq(Lists.newArrayList(new TimeWindow(2, 4), new TimeWindow(0, 2))), anyMergeCallback());
    +		verify(mockAssigner, times(2)).mergeWindows(anyCollection(), anyMergeCallback());
    +
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEventTimeWindowsAreMergedEagerly() throws Exception &lt;/p&gt;
{
    +		testWindowsAreMergedEagerly(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testProcessingTimeWindowsAreMergedEagerly() throws Exception &lt;/p&gt;
{
    +		testWindowsAreMergedEagerly(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that windows are merged eagerly, if possible.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public void testWindowsAreMergedEagerly(final TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    +		// in this test we only have one state window and windows are eagerly&lt;br/&gt;
    +		// merged into the first window&lt;br/&gt;
    +&lt;br/&gt;
    +		MergingWindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockMergingAssigner();&lt;br/&gt;
    +		timeAdaptor.setIsEventTime(mockAssigner);&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		timeAdaptor.advanceTime(testHarness, Long.MIN_VALUE);&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(0, testHarness.extractOutputStreamRecords().size());&lt;br/&gt;
    +		assertEquals(0, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[3];
    +				// don&apos;t intefere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.OnMergeContext context = (Trigger.OnMergeContext) invocation.getArguments()[1];
    +				// don&apos;t intefere with cleanup timers
    +				timeAdaptor.registerTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).update(&quot;hello&quot;);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onMerge(anyTimeWindow(), anyOnMergeContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Trigger.TriggerContext context = (Trigger.TriggerContext) invocation.getArguments()[1];
    +				timeAdaptor.deleteTimer(context, 0L);
    +				context.getPartitionedState(valueStateDescriptor).clear();
    +				return null;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).clear(anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(3, testHarness.numKeyedStateEntries()); // window state plus trigger state plus merging window set&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness)); // timer and GC timer&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4)));&lt;br/&gt;
    +&lt;br/&gt;
    +		shouldMergeWindows(&lt;br/&gt;
    +				mockAssigner,&lt;br/&gt;
    +				Lists.newArrayList(new TimeWindow(0, 2), new TimeWindow(2, 4)),&lt;br/&gt;
    +				Lists.newArrayList(new TimeWindow(0, 2), new TimeWindow(2, 4)),&lt;br/&gt;
    +				new TimeWindow(0, 4));&lt;br/&gt;
    +&lt;br/&gt;
    +		// don&apos;t register a timer or update state in onElement, this checks&lt;br/&gt;
    +		// whether onMerge does correctly set those things&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockTrigger).onMerge(eq(new TimeWindow(0, 4)), anyOnMergeContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertEquals(3, testHarness.numKeyedStateEntries());&lt;br/&gt;
    +		assertEquals(2, timeAdaptor.numTimers(testHarness));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testRejectShrinkingMergingEventTimeWindows() throws Exception {&lt;br/&gt;
    +		testRejectShrinkingMergingWindows(new EventTimeAdaptor());&lt;br/&gt;
    +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    private &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; All of the testXXXXXXX branch methods for testing below can be private, I think.&lt;/p&gt;</comment>
                            <comment id="15936527" author="githubbot" created="Wed, 22 Mar 2017 15:29:16 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107445929&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107445929&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -122,6 +121,20 @@ public void processElement(StreamRecord&amp;lt;IN&amp;gt; element) throws Exception {&lt;br/&gt;
     							public void merge(W mergeResult,&lt;br/&gt;
     									Collection&amp;lt;W&amp;gt; mergedWindows, W stateWindowResult,&lt;br/&gt;
     									Collection&amp;lt;W&amp;gt; mergedStateWindows) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +								if ((windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentWatermark())) &lt;/p&gt;
{
    +									throw new UnsupportedOperationException(&quot;The end timestamp of an &quot; +
    +											&quot;event-time window cannot become earlier than the current watermark &quot; +
    +											&quot;by merging. Current watermark: &quot; + internalTimerService.currentWatermark() +
    +											&quot; window: &quot; + mergeResult);
    +								}
&lt;p&gt; else if (!windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentProcessingTime()) {&lt;br/&gt;
    +									throw new UnsupportedOperationException(&quot;The end timestamp of a &quot; +&lt;br/&gt;
    +											&quot;processing-time window cannot become earlier than the current procesing time&quot; +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Fixing&lt;/p&gt;</comment>
                            <comment id="15936529" author="githubbot" created="Wed, 22 Mar 2017 15:29:30 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107445987&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107445987&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -122,6 +121,20 @@ public void processElement(StreamRecord&amp;lt;IN&amp;gt; element) throws Exception {&lt;br/&gt;
     							public void merge(W mergeResult,&lt;br/&gt;
     									Collection&amp;lt;W&amp;gt; mergedWindows, W stateWindowResult,&lt;br/&gt;
     									Collection&amp;lt;W&amp;gt; mergedStateWindows) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +								if ((windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentWatermark())) &lt;/p&gt;
{
    +									throw new UnsupportedOperationException(&quot;The end timestamp of an &quot; +
    +											&quot;event-time window cannot become earlier than the current watermark &quot; +
    +											&quot;by merging. Current watermark: &quot; + internalTimerService.currentWatermark() +
    +											&quot; window: &quot; + mergeResult);
    +								}
&lt;p&gt; else if (!windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentProcessingTime()) {&lt;br/&gt;
    +									throw new UnsupportedOperationException(&quot;The end timestamp of a &quot; +&lt;br/&gt;
    +											&quot;processing-time window cannot become earlier than the current procesing time&quot; +&lt;br/&gt;
    +											&quot;by merging. Current processing time: &quot; + internalTimerService.currentProcessingTime() +&lt;br/&gt;
    +											&quot; window: &quot; + mergeResult);&lt;br/&gt;
    +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Fixing&lt;/p&gt;</comment>
                            <comment id="15936533" author="githubbot" created="Wed, 22 Mar 2017 15:30:38 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107446308&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107446308&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -138,7 +138,7 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;{@code window.maxTimestamp + allowedLateness}
&lt;p&gt; is smaller than the current watermark will&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;be emitted to this.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final OutputTag&amp;lt;IN&amp;gt; lateDataOutputTag;&lt;br/&gt;
    +	protected final OutputTag&amp;lt;IN&amp;gt; lateDataOutputTag;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It is protected so that `EvictingWindowOperator` can access it. I could make it package private, though.&lt;/p&gt;</comment>
                            <comment id="15936535" author="githubbot" created="Wed, 22 Mar 2017 15:30:52 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107446384&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107446384&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -352,6 +352,20 @@ public void processElement(StreamRecord&amp;lt;IN&amp;gt; element) throws Exception {&lt;br/&gt;
     					public void merge(W mergeResult,&lt;br/&gt;
     							Collection&amp;lt;W&amp;gt; mergedWindows, W stateWindowResult,&lt;br/&gt;
     							Collection&amp;lt;W&amp;gt; mergedStateWindows) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +						if ((windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentWatermark())) &lt;/p&gt;
{
    +							throw new UnsupportedOperationException(&quot;The end timestamp of an &quot; +
    +									&quot;event-time window cannot become earlier than the current watermark &quot; +
    +									&quot;by merging. Current watermark: &quot; + internalTimerService.currentWatermark() +
    +									&quot; window: &quot; + mergeResult);
    +						}
&lt;p&gt; else if (!windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentProcessingTime()) {&lt;br/&gt;
    +							throw new UnsupportedOperationException(&quot;The end timestamp of a &quot; +&lt;br/&gt;
    +									&quot;processing-time window cannot become earlier than the current procesing time&quot; +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Fixing&lt;/p&gt;</comment>
                            <comment id="15936537" author="githubbot" created="Wed, 22 Mar 2017 15:31:44 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107446618&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107446618&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -574,7 +588,7 @@ private void emitWindowContents(W window, ACC contents) throws Exception {&lt;br/&gt;
     	 *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param element skipped late arriving element to side output&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private void sideOutput(StreamRecord&amp;lt;IN&amp;gt; element){&lt;br/&gt;
    +	protected void sideOutput(StreamRecord&amp;lt;IN&amp;gt; element){
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Same as for `lateDataOutputTag`. It&apos;s used by the `EvictingWindowOperator`. I can also make it package private.&lt;/p&gt;</comment>
                            <comment id="15936554" author="githubbot" created="Wed, 22 Mar 2017 15:43:11 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107450009&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107450009&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Done. I would like to have strict checkstyle for tests as well ... &#128517; &lt;/p&gt;</comment>
                            <comment id="15936555" author="githubbot" created="Wed, 22 Mar 2017 15:43:12 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107450020&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107450020&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -138,7 +138,7 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;{@code window.maxTimestamp + allowedLateness}
&lt;p&gt; is smaller than the current watermark will&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;be emitted to this.&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final OutputTag&amp;lt;IN&amp;gt; lateDataOutputTag;&lt;br/&gt;
    +	protected final OutputTag&amp;lt;IN&amp;gt; lateDataOutputTag;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Ah, sorry I mistakened that it was exposed for testing. `protected` would be fine then.&lt;/p&gt;</comment>
                            <comment id="15936684" author="githubbot" created="Wed, 22 Mar 2017 17:00:19 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107471533&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107471533&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I&apos;m replacing it by `new ArrayList&amp;lt;&amp;gt;(Arrays.asList(...))`&lt;/p&gt;</comment>
                            <comment id="15936699" author="githubbot" created="Wed, 22 Mar 2017 17:08:25 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107473789&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107473789&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Fixing&lt;/p&gt;</comment>
                            <comment id="15936701" author="githubbot" created="Wed, 22 Mar 2017 17:10:27 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107474350&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107474350&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Fixing&lt;/p&gt;</comment>
                            <comment id="15936706" author="githubbot" created="Wed, 22 Mar 2017 17:14:08 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107475345&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107475345&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperatorContractTest.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,2654 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +package org.apache.flink.streaming.runtime.operators.windowing;&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +import static org.apache.flink.streaming.runtime.operators.windowing.StreamRecordMatchers.isStreamRecord;&lt;br/&gt;
    +import static org.hamcrest.Matchers.containsInAnyOrder;&lt;br/&gt;
    +import static org.junit.Assert.*;&lt;br/&gt;
    +import static org.mockito.Matchers.anyLong;&lt;br/&gt;
    +import static org.mockito.Mockito.*;&lt;br/&gt;
    +&lt;br/&gt;
    +import com.google.common.collect.Lists;&lt;br/&gt;
    +import java.util.Arrays;&lt;br/&gt;
    +import java.util.Collection;&lt;br/&gt;
    +import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
    +import org.apache.flink.api.common.ExecutionConfig;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.FoldFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.functions.ReduceFunction;&lt;br/&gt;
    +import org.apache.flink.api.common.state.AppendingState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.FoldingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListState;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ListStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ReducingStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.StateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.state.ValueStateDescriptor;&lt;br/&gt;
    +import org.apache.flink.api.common.typeinfo.BasicTypeInfo;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
    +import org.apache.flink.api.java.functions.KeySelector;&lt;br/&gt;
    +import org.apache.flink.streaming.api.watermark.Watermark;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.evictors.CountEvictor;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.Trigger;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.triggers.TriggerResult;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.GlobalWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.TimeWindow;&lt;br/&gt;
    +import org.apache.flink.streaming.api.windowing.windows.Window;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.operators.windowing.functions.InternalWindowFunction;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;&lt;br/&gt;
    +import org.apache.flink.streaming.runtime.tasks.OperatorStateHandles;&lt;br/&gt;
    +import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;&lt;br/&gt;
    +import org.apache.flink.util.Collector;&lt;br/&gt;
    +import org.apache.flink.util.OutputTag;&lt;br/&gt;
    +import org.apache.flink.util.TestLogger;&lt;br/&gt;
    +import org.junit.Rule;&lt;br/&gt;
    +import org.junit.Test;&lt;br/&gt;
    +import org.junit.rules.ExpectedException;&lt;br/&gt;
    +import org.mockito.Matchers;&lt;br/&gt;
    +import org.mockito.Mockito;&lt;br/&gt;
    +import org.mockito.invocation.InvocationOnMock;&lt;br/&gt;
    +import org.mockito.stubbing.Answer;&lt;br/&gt;
    +import org.mockito.verification.VerificationMode;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * These tests verify that &lt;/p&gt;
{@link WindowOperator}
&lt;p&gt; correctly interacts with the other windowing&lt;br/&gt;
    + * components: &lt;/p&gt;
{@link WindowAssigner}
&lt;p&gt;,&lt;br/&gt;
    + * &lt;/p&gt;
{@link Trigger}
&lt;p&gt;.&lt;br/&gt;
    + * &lt;/p&gt;
{@link org.apache.flink.streaming.api.functions.windowing.WindowFunction}
&lt;p&gt; and window state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;These tests document the implicit contract that exists between the windowing components.&lt;br/&gt;
    + *&lt;br/&gt;
    + * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Important:&amp;lt;/b&amp;gt;This test must always be kept up-to-date with&lt;br/&gt;
    + * &lt;/p&gt;
{@link WindowOperatorContractTest}
&lt;p&gt;.&lt;br/&gt;
    + */&lt;br/&gt;
    +public class EvictingWindowOperatorContractTest extends TestLogger {&lt;br/&gt;
    +&lt;br/&gt;
    +	@Rule&lt;br/&gt;
    +	public ExpectedException expectedException = ExpectedException.none();&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ValueStateDescriptor&amp;lt;String&amp;gt; valueStateDescriptor =&lt;br/&gt;
    +			new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;string-state&quot;, StringSerializer.INSTANCE, null);&lt;br/&gt;
    +&lt;br/&gt;
    +	private static ListStateDescriptor&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt; intListDescriptor =&lt;br/&gt;
    +			new ListStateDescriptor&amp;lt;&amp;gt;(&quot;int-list&quot;, (TypeSerializer&amp;lt;StreamRecord&amp;lt;Integer&amp;gt;&amp;gt;) new StreamElementSerializer(IntSerializer.INSTANCE));&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;IN, OUT, KEY, W extends Window&amp;gt; InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		InternalWindowFunction&amp;lt;IN, OUT, KEY, W&amp;gt; mockWindowFunction = mock(InternalWindowFunction.class);
    +
    +		return mockWindowFunction;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T, W extends Window&amp;gt; Trigger&amp;lt;T, W&amp;gt; mockTrigger() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		Trigger&amp;lt;T, W&amp;gt; mockTrigger = mock(Trigger.class);
    +
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;any(), anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;W&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +
    +		return mockTrigger;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockTimeWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockGlobalWindowAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		WindowAssigner&amp;lt;T, GlobalWindow&amp;gt; mockAssigner = mock(WindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new GlobalWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +		when(mockAssigner.assignWindows(Mockito.&amp;lt;T&amp;gt;any(), anyLong(), anyAssignerContext())).thenReturn(Collections.singletonList(GlobalWindow.get()));
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockMergingAssigner() throws Exception &lt;/p&gt;
{
    +		@SuppressWarnings(&quot;unchecked&quot;)
    +		MergingWindowAssigner&amp;lt;T, TimeWindow&amp;gt; mockAssigner = mock(MergingWindowAssigner.class);
    +
    +		when(mockAssigner.getWindowSerializer(Mockito.&amp;lt;ExecutionConfig&amp;gt;any())).thenReturn(new TimeWindow.Serializer());
    +		when(mockAssigner.isEventTime()).thenReturn(true);
    +
    +		return mockAssigner;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static WindowAssigner.WindowAssignerContext anyAssignerContext() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.TriggerContext anyTriggerContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; Collector&amp;lt;T&amp;gt; anyCollector() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; anyIntIterable() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	static Iterable&amp;lt;Integer&amp;gt; intIterable(Integer... values) &lt;/p&gt;
{
    +		return (Iterable&amp;lt;Integer&amp;gt;) argThat(containsInAnyOrder(values));
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static TimeWindow anyTimeWindow() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	static Trigger.OnMergeContext anyOnMergeContext() {    +		return Mockito.any();    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	static MergingWindowAssigner.MergeCallback anyMergeCallback() &lt;/p&gt;
{
    +		return Mockito.any();
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	static &amp;lt;T&amp;gt; void shouldRegisterEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteEventTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteEventTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +		.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldRegisterProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.registerProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldDeleteProcessingTimeTimerOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger, final long timestamp) throws Exception {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Trigger.TriggerContext context =
    +						(Trigger.TriggerContext) invocation.getArguments()[3];
    +				context.deleteProcessingTimeTimer(timestamp);
    +				return TriggerResult.CONTINUE;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(mockTrigger).onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
    +	private static &amp;lt;T, W extends Window&amp;gt; void shouldMergeWindows(final MergingWindowAssigner&amp;lt;T, W&amp;gt; assigner, final Collection&amp;lt;? extends W&amp;gt; expectedWindows, final Collection&amp;lt;W&amp;gt; toMerge, final W mergeResult) {&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Object answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				Collection&amp;lt;W&amp;gt; windows = (Collection&amp;lt;W&amp;gt;) invocation.getArguments()[0];
    +
    +				MergingWindowAssigner.MergeCallback callback = (MergingWindowAssigner.MergeCallback) invocation.getArguments()[1];
    +
    +				// verify the expected windows
    +				assertThat(windows, containsInAnyOrder(expectedWindows.toArray()));
    +
    +				callback.merge(toMerge, mergeResult);
    +				return null;
    +			}
&lt;p&gt;    +		})&lt;br/&gt;
    +				.when(assigner).mergeWindows(anyCollection(), Matchers.&amp;lt;MergingWindowAssigner.MergeCallback&amp;gt;anyObject());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnElement(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onElement(Matchers.&amp;lt;T&amp;gt;anyObject(), anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnEventTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onEventTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldContinueOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.CONTINUE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	private static &amp;lt;T&amp;gt; void shouldFireAndPurgeOnProcessingTime(Trigger&amp;lt;T, TimeWindow&amp;gt; mockTrigger) throws Exception &lt;/p&gt;
{
    +		when(mockTrigger.onProcessingTime(anyLong(), Matchers.&amp;lt;TimeWindow&amp;gt;any(), anyTriggerContext())).thenReturn(TriggerResult.FIRE_AND_PURGE);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Verify that there is no late-date side output if the &lt;/p&gt;
{@code WindowAssigner}
&lt;p&gt; does&lt;br/&gt;
    +	 * not assign any windows.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testNoLateSideOutputForSkippedWindows() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(0);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertTrue(testHarness.getSideOutput(lateOutputTag) == null || testHarness.getSideOutput(lateOutputTag).isEmpty());&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testLateSideOutput() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		OutputTag&amp;lt;Integer&amp;gt; lateOutputTag = new OutputTag&amp;lt;Integer&amp;gt;(&quot;late&quot;){};&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction, lateOutputTag);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processWatermark(20);&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 5L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L)));&lt;br/&gt;
    +&lt;br/&gt;
    +		// we should also see side output if the WindowAssigner assigns no windows&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.&amp;lt;TimeWindow&amp;gt;emptyList());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 10L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(5L), anyAssignerContext());&lt;br/&gt;
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(10L), anyAssignerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.getSideOutput(lateOutputTag),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(0, 5L), isStreamRecord(0, 10L)));&lt;br/&gt;
    +&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerIsInvokedOncePerElement() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 0)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(1)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockAssigner, times(2)).assignWindows(eq(0), eq(0L), anyAssignerContext());
    +
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testAssignerWithMultipleWindows() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		shouldFireOnElement(mockTrigger);
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(eq(0), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(2, 4)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testWindowsDontInterfere() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		// no output so far
    +		assertTrue(testHarness.extractOutputStreamRecords().isEmpty());
    +
    +		// state for two windows
    +		assertEquals(2, testHarness.numKeyedStateEntries());
    +		assertEquals(2, testHarness.numEventTimeTimers());
    +
    +		// now we fire
    +		shouldFireOnElement(mockTrigger);
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 1)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(1, 0L));
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));
    +
    +		verify(mockWindowFunction, times(2)).apply(anyInt(), anyTimeWindow(), anyIntIterable(), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0, 0), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +		verify(mockWindowFunction, times(1)).apply(eq(1), eq(new TimeWindow(0, 1)), intIterable(1, 1), EvictingWindowOperatorContractTest.&amp;lt;Void&amp;gt;anyCollector());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testOnElementCalledPerWindow() throws Exception &lt;/p&gt;
{
    +
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, Void, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();
    +
    +		OneInputStreamOperatorTestHarness&amp;lt;Integer, Void&amp;gt; testHarness =
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);
    +
    +		testHarness.open();
    +
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))
    +				.thenReturn(Arrays.asList(new TimeWindow(2, 4), new TimeWindow(0, 2)));
    +
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(42, 1L));
    +
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(2, 4)), anyTriggerContext());
    +		verify(mockTrigger).onElement(eq(42), eq(1L), eq(new TimeWindow(0, 2)), anyTriggerContext());
    +
    +		verify(mockTrigger, times(2)).onElement(anyInt(), anyLong(), anyTimeWindow(), anyTriggerContext());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunction() throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		WindowAssigner&amp;lt;Integer, TimeWindow&amp;gt; mockAssigner = mockTimeWindowAssigner();&lt;br/&gt;
    +		Trigger&amp;lt;Integer, TimeWindow&amp;gt; mockTrigger = mockTrigger();&lt;br/&gt;
    +		InternalWindowFunction&amp;lt;Iterable&amp;lt;Integer&amp;gt;, String, Integer, TimeWindow&amp;gt; mockWindowFunction = mockWindowFunction();&lt;br/&gt;
    +&lt;br/&gt;
    +		KeyedOneInputStreamOperatorTestHarness&amp;lt;Integer, Integer, String&amp;gt; testHarness =&lt;br/&gt;
    +				createWindowOperator(mockAssigner, mockTrigger, 0L, intListDescriptor, mockWindowFunction);&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.open();&lt;br/&gt;
    +&lt;br/&gt;
    +		when(mockAssigner.assignWindows(anyInt(), anyLong(), anyAssignerContext()))&lt;br/&gt;
    +				.thenReturn(Collections.singletonList(new TimeWindow(0, 2)));&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;TriggerResult&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public TriggerResult answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				return TriggerResult.FIRE;
    +			}
&lt;p&gt;    +		}).when(mockTrigger).onElement(Matchers.&amp;lt;Integer&amp;gt;anyObject(), anyLong(), anyTimeWindow(), anyTriggerContext());&lt;br/&gt;
    +&lt;br/&gt;
    +		doAnswer(new Answer&amp;lt;Void&amp;gt;() {&lt;br/&gt;
    +			@Override&lt;br/&gt;
    +			public Void answer(InvocationOnMock invocation) throws Exception &lt;/p&gt;
{
    +				@SuppressWarnings(&quot;unchecked&quot;)
    +				Collector&amp;lt;String&amp;gt; out = invocation.getArgumentAt(3, Collector.class);
    +				out.collect(&quot;Hallo&quot;);
    +				out.collect(&quot;Ciao&quot;);
    +				return null;
    +			}
&lt;p&gt;    +		}).when(mockWindowFunction).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		testHarness.processElement(new StreamRecord&amp;lt;&amp;gt;(0, 0L));&lt;br/&gt;
    +&lt;br/&gt;
    +		verify(mockWindowFunction, times(1)).apply(eq(0), eq(new TimeWindow(0, 2)), intIterable(0), EvictingWindowOperatorContractTest.&amp;lt;String&amp;gt;anyCollector());&lt;br/&gt;
    +&lt;br/&gt;
    +		assertThat(testHarness.extractOutputStreamRecords(),&lt;br/&gt;
    +				containsInAnyOrder(isStreamRecord(&quot;Hallo&quot;, 1L), isStreamRecord(&quot;Ciao&quot;, 1L)));&lt;br/&gt;
    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnEventTime() throws Exception &lt;/p&gt;
{
    +		testEmittingFromWindowFunction(new EventTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testEmittingFromWindowFunctionOnProcessingTime() throws Exception &lt;/p&gt;
{
    +		testEmittingFromWindowFunction(new ProcessingTimeAdaptor());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +&lt;br/&gt;
    +	private  void testEmittingFromWindowFunction(TimeDomainAdaptor timeAdaptor) throws Exception {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    fixing&lt;/p&gt;
</comment>
                            <comment id="15936803" author="githubbot" created="Wed, 22 Mar 2017 17:58:32 +0000"  >&lt;p&gt;Github user aljoscha commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for the thorough review, @tzulitai!&lt;/p&gt;

&lt;p&gt;    And shame over my head for all the code duplication &#128561; &lt;/p&gt;

&lt;p&gt;    I now refactored the contract tests into a base class and addressed all the issues that you found (hopefully).&lt;/p&gt;

&lt;p&gt;    The failing `WindowOperatorTest` tests actually discovered a real problem, I wasn&apos;t taking the allowed lateness into account when calculating if a merged window would be late. I modified the new tests in in the contract test to verify that we now have the correct behaviour.&lt;/p&gt;

&lt;p&gt;    Could you maybe have another look?&lt;/p&gt;</comment>
                            <comment id="15936943" author="githubbot" created="Wed, 22 Mar 2017 19:09:41 +0000"  >&lt;p&gt;Github user tzulitai commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks a lot for addressing my comments @aljoscha!&lt;/p&gt;

&lt;p&gt;    That&apos;s so much cleaner now :-D Really like the refactoring in the fixes.&lt;br/&gt;
    I actually didn&apos;t realize the mock stubs and util methods were already in `WindowOperatorContractTest` just looking at the previous diffs &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/tongue.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    I did one final pass on the changes and didn&apos;t find anything. +1 to merge after Travis turns green.&lt;/p&gt;</comment>
                            <comment id="15936954" author="githubbot" created="Wed, 22 Mar 2017 19:14:55 +0000"  >&lt;p&gt;Github user tzulitai commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107506662&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107506662&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -122,6 +121,19 @@ public void processElement(StreamRecord&amp;lt;IN&amp;gt; element) throws Exception {&lt;br/&gt;
     							public void merge(W mergeResult,&lt;br/&gt;
     									Collection&amp;lt;W&amp;gt; mergedWindows, W stateWindowResult,&lt;br/&gt;
     									Collection&amp;lt;W&amp;gt; mergedStateWindows) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +								if ((windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() + allowedLateness &amp;lt;= internalTimerService.currentWatermark())) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Ah, I see. Good seeing the tests at work catching this :-D&lt;/p&gt;</comment>
                            <comment id="15938535" author="githubbot" created="Thu, 23 Mar 2017 15:08:58 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107674329&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107674329&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -352,6 +352,19 @@ public void processElement(StreamRecord&amp;lt;IN&amp;gt; element) throws Exception {&lt;br/&gt;
     					public void merge(W mergeResult,&lt;br/&gt;
     							Collection&amp;lt;W&amp;gt; mergedWindows, W stateWindowResult,&lt;br/&gt;
     							Collection&amp;lt;W&amp;gt; mergedStateWindows) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +						if ((windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() + allowedLateness &amp;lt;= internalTimerService.currentWatermark())) &lt;/p&gt;
{
    +							throw new UnsupportedOperationException(&quot;The end timestamp of an &quot; +
    +									&quot;event-time window cannot become earlier than the current watermark &quot; +
    +									&quot;by merging. Current watermark: &quot; + internalTimerService.currentWatermark() +
    +									&quot; window: &quot; + mergeResult);
    +						}
&lt;p&gt; else if (!windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentProcessingTime()) {&lt;br/&gt;
    +							throw new UnsupportedOperationException(&quot;The end timestamp of a &quot; +&lt;br/&gt;
    +									&quot;processing-time window cannot become earlier than the current procesing time &quot; +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Typo &quot;procesing&quot; -&amp;gt; &quot;processing&quot;&lt;/p&gt;</comment>
                            <comment id="15938536" author="githubbot" created="Thu, 23 Mar 2017 15:08:59 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587#discussion_r107674217&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587#discussion_r107674217&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java &amp;#8212;&lt;br/&gt;
    @@ -121,6 +121,19 @@ public void processElement(StreamRecord&amp;lt;IN&amp;gt; element) throws Exception {&lt;br/&gt;
     							public void merge(W mergeResult,&lt;br/&gt;
     									Collection&amp;lt;W&amp;gt; mergedWindows, W stateWindowResult,&lt;br/&gt;
     									Collection&amp;lt;W&amp;gt; mergedStateWindows) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +								if ((windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() + allowedLateness &amp;lt;= internalTimerService.currentWatermark())) &lt;/p&gt;
{
    +									throw new UnsupportedOperationException(&quot;The end timestamp of an &quot; +
    +											&quot;event-time window cannot become earlier than the current watermark &quot; +
    +											&quot;by merging. Current watermark: &quot; + internalTimerService.currentWatermark() +
    +											&quot; window: &quot; + mergeResult);
    +								}
&lt;p&gt; else if (!windowAssigner.isEventTime() &amp;amp;&amp;amp; mergeResult.maxTimestamp() &amp;lt;= internalTimerService.currentProcessingTime()) {&lt;br/&gt;
    +									throw new UnsupportedOperationException(&quot;The end timestamp of a &quot; +&lt;br/&gt;
    +											&quot;processing-time window cannot become earlier than the current procesing time &quot; +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Typo &quot;procesing&quot; -&amp;gt; processing&lt;/p&gt;</comment>
                            <comment id="15938554" author="githubbot" created="Thu, 23 Mar 2017 15:17:26 +0000"  >&lt;p&gt;Github user tzulitai commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks a lot for the extra pair of eyes on this @kl0u!&lt;br/&gt;
    I can fix the typo and proceed to merge this to `master` and `release-1-2`.&lt;/p&gt;</comment>
                            <comment id="15938558" author="githubbot" created="Thu, 23 Mar 2017 15:22:07 +0000"  >&lt;p&gt;Github user tzulitai commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Merging ..&lt;/p&gt;</comment>
                            <comment id="15938571" author="githubbot" created="Thu, 23 Mar 2017 15:30:14 +0000"  >&lt;p&gt;Github user aljoscha commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for merging, @tzulitai! &#128515; &lt;/p&gt;</comment>
                            <comment id="15938573" author="githubbot" created="Thu, 23 Mar 2017 15:31:17 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15938580" author="githubbot" created="Thu, 23 Mar 2017 15:33:41 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks @tzulitai &lt;/p&gt;</comment>
                            <comment id="15938714" author="githubbot" created="Thu, 23 Mar 2017 16:33:08 +0000"  >&lt;p&gt;Github user tzulitai commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/3587&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/3587&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    FYI: I managed to backport the changes (including the contract test refactorings) back to `release-1.2`.&lt;br/&gt;
    But since it involved quite a few conflict resolvings, I&apos;m waiting on a local Travis run just to be sure before merging the backport: &lt;a href=&quot;https://travis-ci.org/tzulitai/flink/builds/214315026&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://travis-ci.org/tzulitai/flink/builds/214315026&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15939933" author="aljoscha" created="Fri, 24 Mar 2017 07:10:21 +0000"  >&lt;p&gt;Fixed on release-1.2 in&lt;br/&gt;
b99883430decef11f6893d9db8f77bc98458979b&lt;/p&gt;

&lt;p&gt;Fixed on master in&lt;br/&gt;
68289b1a52db7157d23085850ec947e78e729f01&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 34 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3b05j:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>