<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:32:57 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-8802] Concurrent serialization without duplicating serializers in state server.</title>
                <link>https://issues.apache.org/jira/browse/FLINK-8802</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;The `getSerializedValue()` may be called by multiple threads but serializers are not duplicated, which may lead to exceptions thrown when a serializer is stateful.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13141484">FLINK-8802</key>
            <summary>Concurrent serialization without duplicating serializers in state server.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kkl0u">Kostas Kloudas</assignee>
                                    <reporter username="kkl0u">Kostas Kloudas</reporter>
                        <labels>
                    </labels>
                <created>Wed, 28 Feb 2018 10:00:32 +0000</created>
                <updated>Thu, 29 Mar 2018 16:10:45 +0000</updated>
                            <resolved>Thu, 29 Mar 2018 16:10:45 +0000</resolved>
                                    <version>1.5.0</version>
                                    <fixVersion>1.5.0</fixVersion>
                                    <component>Runtime / Queryable State</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="16396910" author="githubbot" created="Tue, 13 Mar 2018 13:03:19 +0000"  >&lt;p&gt;GitHub user kl0u opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8802&quot; title=&quot;Concurrent serialization without duplicating serializers in state server.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8802&quot;&gt;&lt;del&gt;FLINK-8802&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;QS&amp;#93;&lt;/span&gt; Fix concurrent access to non-duplicated serializers.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This fixes the problem of multiple threads using the same serializer instance to concurrently deserialize requests.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    Now the `KvStateRegistry` holds a `KvStateEntry` for each registered `InternalKvState` and in that entry we have a cache that holds a copy of the serializer per thread, if the serializer is stateful. If it is stateless, we do not need to copy the serializer.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    There is a test added in the `KvStateRegistryTest`, the `KvStateRegistryTest#testKvStateEntry()` and also I have tested it with an actual job (but I run it locally).&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): no&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: no&lt;/li&gt;
	&lt;li&gt;The serializers: no&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): no&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: no&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: no&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? no&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? not applicable&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/kl0u/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/kl0u/flink&lt;/a&gt; improved-qs-inv&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #5691&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 595a59c30dfc778945c43351edf8dbc2887b6a87&lt;br/&gt;
Author: kkloudas &amp;lt;kkloudas@...&amp;gt;&lt;br/&gt;
Date:   2018-03-09T11:05:38Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8908&quot; title=&quot;MapSerializer creates new serializer even if key and value serializers are stateless&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8908&quot;&gt;&lt;del&gt;FLINK-8908&lt;/del&gt;&lt;/a&gt; Do not create copy when MapSerializer stateless.&lt;/p&gt;

&lt;p&gt;commit 1a8c0415cec46ed6683768b793c295ab478b2eb8&lt;br/&gt;
Author: kkloudas &amp;lt;kkloudas@...&amp;gt;&lt;br/&gt;
Date:   2018-03-12T11:12:06Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8928&quot; title=&quot;Improve error message on server binding error.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8928&quot;&gt;&lt;del&gt;FLINK-8928&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;QS&amp;#93;&lt;/span&gt; Improve server binding error message.&lt;/p&gt;

&lt;p&gt;commit 67b6d7ad2d128a14e001afc34eb14cd6c62d90c4&lt;br/&gt;
Author: kkloudas &amp;lt;kkloudas@...&amp;gt;&lt;br/&gt;
Date:   2018-03-09T21:47:35Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8802&quot; title=&quot;Concurrent serialization without duplicating serializers in state server.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8802&quot;&gt;&lt;del&gt;FLINK-8802&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;QS&amp;#93;&lt;/span&gt; Fix concurrent access to non-duplicated serializers.&lt;/p&gt;

&lt;p&gt;commit b86657f630363e59971edd29464130c62bd4b3a7&lt;br/&gt;
Author: kkloudas &amp;lt;kkloudas@...&amp;gt;&lt;br/&gt;
Date:   2018-03-12T12:19:23Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8926&quot; title=&quot;Shutdown client proxy on test end.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8926&quot;&gt;&lt;del&gt;FLINK-8926&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;QS&amp;#93;&lt;/span&gt; Shutdown client proxy after test ends.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16396943" author="githubbot" created="Tue, 13 Mar 2018 13:41:14 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174128377&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174128377&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-queryable-state/flink-queryable-state-runtime/src/main/java/org/apache/flink/queryablestate/server/KvStateServerHandler.java &amp;#8212;&lt;br/&gt;
    @@ -78,13 +75,22 @@ public KvStateServerHandler(&lt;br/&gt;
     		final CompletableFuture&amp;lt;KvStateResponse&amp;gt; responseFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;p&gt;     		try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final InternalKvState&amp;lt;?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
    +			final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
     			if (kvState == null) 
{
     				responseFuture.completeExceptionally(new UnknownKvStateIdException(getServerName(), request.getKvStateId()));
     			}
&lt;p&gt; else {&lt;br/&gt;
     				byte[] serializedKeyAndNamespace = request.getSerializedKeyAndNamespace();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;byte[] serializedResult = kvState.getSerializedValue(serializedKeyAndNamespace);&lt;br/&gt;
    +				// here we remove any type check...&lt;br/&gt;
    +				// Ideally we want to keep that the info match the state.&lt;br/&gt;
    +				final InternalKvState state = kvState.getState();&lt;br/&gt;
    +				final KvStateInfo info = kvState.getInfoForCurrentThread();&lt;br/&gt;
    +&lt;br/&gt;
    +				byte[] serializedResult = state.getSerializedValue(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Couldn&apos;t we synchronize on `kvState` instead of modifying all `InternalKvState` implementations?&lt;/p&gt;

&lt;p&gt;    This seems like a much safer alternative than baking in the assumption that `getSerializedValue()` can be called concurrently.&lt;/p&gt;
</comment>
                            <comment id="16396949" author="githubbot" created="Tue, 13 Mar 2018 13:43:32 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174133415&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174133415&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-queryable-state/flink-queryable-state-runtime/src/main/java/org/apache/flink/queryablestate/server/KvStateServerHandler.java &amp;#8212;&lt;br/&gt;
    @@ -78,13 +75,22 @@ public KvStateServerHandler(&lt;br/&gt;
     		final CompletableFuture&amp;lt;KvStateResponse&amp;gt; responseFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;p&gt;     		try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final InternalKvState&amp;lt;?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
    +			final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
     			if (kvState == null) 
{
     				responseFuture.completeExceptionally(new UnknownKvStateIdException(getServerName(), request.getKvStateId()));
     			}
&lt;p&gt; else {&lt;br/&gt;
     				byte[] serializedKeyAndNamespace = request.getSerializedKeyAndNamespace();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;byte[] serializedResult = kvState.getSerializedValue(serializedKeyAndNamespace);&lt;br/&gt;
    +				// here we remove any type check...&lt;br/&gt;
    +				// Ideally we want to keep that the info match the state.&lt;br/&gt;
    +				final InternalKvState state = kvState.getState();&lt;br/&gt;
    +				final KvStateInfo info = kvState.getInfoForCurrentThread();&lt;br/&gt;
    +&lt;br/&gt;
    +				byte[] serializedResult = state.getSerializedValue(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It is not an assumption. It is accessed concurrently from the thread pool. Synchronizing on the `kvState` would serialize all accesses, which would slow down (by a lot) performance.&lt;/p&gt;</comment>
                            <comment id="16396988" author="githubbot" created="Tue, 13 Mar 2018 14:11:24 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174144247&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174144247&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-queryable-state/flink-queryable-state-runtime/src/main/java/org/apache/flink/queryablestate/server/KvStateServerHandler.java &amp;#8212;&lt;br/&gt;
    @@ -78,13 +75,22 @@ public KvStateServerHandler(&lt;br/&gt;
     		final CompletableFuture&amp;lt;KvStateResponse&amp;gt; responseFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;p&gt;     		try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final InternalKvState&amp;lt;?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
    +			final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
     			if (kvState == null) 
{
     				responseFuture.completeExceptionally(new UnknownKvStateIdException(getServerName(), request.getKvStateId()));
     			}
&lt;p&gt; else {&lt;br/&gt;
     				byte[] serializedKeyAndNamespace = request.getSerializedKeyAndNamespace();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;byte[] serializedResult = kvState.getSerializedValue(serializedKeyAndNamespace);&lt;br/&gt;
    +				// here we remove any type check...&lt;br/&gt;
    +				// Ideally we want to keep that the info match the state.&lt;br/&gt;
    +				final InternalKvState state = kvState.getState();&lt;br/&gt;
    +				final KvStateInfo info = kvState.getInfoForCurrentThread();&lt;br/&gt;
    +&lt;br/&gt;
    +				byte[] serializedResult = state.getSerializedValue(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Ah, i mistakenly thought that `getSerializedValue()` is also called out of QS.&lt;/p&gt;

&lt;p&gt;    What would be the overhead of always duplicating serializers within `getSerializedValue()`?&lt;/p&gt;</comment>
                            <comment id="16396994" author="githubbot" created="Tue, 13 Mar 2018 14:15:15 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174145613&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174145613&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-queryable-state/flink-queryable-state-runtime/src/main/java/org/apache/flink/queryablestate/server/KvStateServerHandler.java &amp;#8212;&lt;br/&gt;
    @@ -78,13 +75,22 @@ public KvStateServerHandler(&lt;br/&gt;
     		final CompletableFuture&amp;lt;KvStateResponse&amp;gt; responseFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;p&gt;     		try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final InternalKvState&amp;lt;?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
    +			final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
     			if (kvState == null) 
{
     				responseFuture.completeExceptionally(new UnknownKvStateIdException(getServerName(), request.getKvStateId()));
     			}
&lt;p&gt; else {&lt;br/&gt;
     				byte[] serializedKeyAndNamespace = request.getSerializedKeyAndNamespace();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;byte[] serializedResult = kvState.getSerializedValue(serializedKeyAndNamespace);&lt;br/&gt;
    +				// here we remove any type check...&lt;br/&gt;
    +				// Ideally we want to keep that the info match the state.&lt;br/&gt;
    +				final InternalKvState state = kvState.getState();&lt;br/&gt;
    +				final KvStateInfo info = kvState.getInfoForCurrentThread();&lt;br/&gt;
    +&lt;br/&gt;
    +				byte[] serializedResult = state.getSerializedValue(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    &quot;Word on the street&quot; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/tongue.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; is that `Kryo` duplication is pretty expensive. This is why I went for this solution.&lt;/p&gt;</comment>
                            <comment id="16397008" author="githubbot" created="Tue, 13 Mar 2018 14:22:20 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174148331&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174148331&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-queryable-state/flink-queryable-state-runtime/src/main/java/org/apache/flink/queryablestate/server/KvStateServerHandler.java &amp;#8212;&lt;br/&gt;
    @@ -78,13 +75,22 @@ public KvStateServerHandler(&lt;br/&gt;
     		final CompletableFuture&amp;lt;KvStateResponse&amp;gt; responseFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;p&gt;     		try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final InternalKvState&amp;lt;?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
    +			final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
     			if (kvState == null) 
{
     				responseFuture.completeExceptionally(new UnknownKvStateIdException(getServerName(), request.getKvStateId()));
     			}
&lt;p&gt; else {&lt;br/&gt;
     				byte[] serializedKeyAndNamespace = request.getSerializedKeyAndNamespace();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;byte[] serializedResult = kvState.getSerializedValue(serializedKeyAndNamespace);&lt;br/&gt;
    +				// here we remove any type check...&lt;br/&gt;
    +				// Ideally we want to keep that the info match the state.&lt;br/&gt;
    +				final InternalKvState state = kvState.getState();&lt;br/&gt;
    +				final KvStateInfo info = kvState.getInfoForCurrentThread();&lt;br/&gt;
    +&lt;br/&gt;
    +				byte[] serializedResult = state.getSerializedValue(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    well we could move the thread-caching into the `InternalKvStates`.&lt;/p&gt;</comment>
                            <comment id="16397015" author="githubbot" created="Tue, 13 Mar 2018 14:28:17 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174150658&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174150658&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-queryable-state/flink-queryable-state-runtime/src/main/java/org/apache/flink/queryablestate/server/KvStateServerHandler.java &amp;#8212;&lt;br/&gt;
    @@ -78,13 +75,22 @@ public KvStateServerHandler(&lt;br/&gt;
     		final CompletableFuture&amp;lt;KvStateResponse&amp;gt; responseFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;p&gt;     		try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final InternalKvState&amp;lt;?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
    +			final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
     			if (kvState == null) 
{
     				responseFuture.completeExceptionally(new UnknownKvStateIdException(getServerName(), request.getKvStateId()));
     			}
&lt;p&gt; else {&lt;br/&gt;
     				byte[] serializedKeyAndNamespace = request.getSerializedKeyAndNamespace();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;byte[] serializedResult = kvState.getSerializedValue(serializedKeyAndNamespace);&lt;br/&gt;
    +				// here we remove any type check...&lt;br/&gt;
    +				// Ideally we want to keep that the info match the state.&lt;br/&gt;
    +				final InternalKvState state = kvState.getState();&lt;br/&gt;
    +				final KvStateInfo info = kvState.getInfoForCurrentThread();&lt;br/&gt;
    +&lt;br/&gt;
    +				byte[] serializedResult = state.getSerializedValue(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    True, but after also discussion with Stephan and Aljoscha we concluded that probably it is not the right place, just from a &quot;separation-of-concerns&quot; point of view.&lt;/p&gt;

&lt;p&gt;    That said, the more I was working on it, the more I was thinking that the `InternalKvStates` could also be a place. But this we can leave for future discussion when we re-prioritize QS.&lt;/p&gt;</comment>
                            <comment id="16398255" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174379723&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174379723&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/internal/InternalMergingState.java &amp;#8212;&lt;br/&gt;
    @@ -26,12 +26,14 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The peer to the 
{@link MergingState}
&lt;p&gt; in the internal state type hierarchy.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;See 
{@link InternalKvState}
&lt;p&gt; for a description of the internal state hierarchy.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;N&amp;gt;   The type of the namespace&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;IN&amp;gt;  The type of elements added to the state&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;OUT&amp;gt; The type of elements&lt;br/&gt;
    + *&lt;br/&gt;
    + * @param &amp;lt;K&amp;gt;	The type of key the state is associated to&lt;br/&gt;
    + * @param &amp;lt;N&amp;gt;	The type of the namespace&lt;br/&gt;
    + * @param &amp;lt;IN&amp;gt;	The type of elements added to the state&lt;br/&gt;
    + * @param &amp;lt;SV&amp;gt;	The type of elements in the state&lt;br/&gt;
    + * @param &amp;lt;OUT&amp;gt;	The type of elements
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    indentation is off and the description deserves an extension&lt;/p&gt;</comment>
                            <comment id="16398256" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174380744&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174380744&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/AbstractHeapMergingState.java &amp;#8212;&lt;br/&gt;
    @@ -28,18 +28,19 @@&lt;br/&gt;
     import java.util.Collection;&lt;/p&gt;

&lt;p&gt;     /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Base class for 
{@link MergingState} ({@link org.apache.flink.runtime.state.internal.InternalMergingState})&lt;br/&gt;
    - * that is stored on the heap.&lt;br/&gt;
    + * Base class for {@link MergingState}
&lt;p&gt; (&lt;/p&gt;
{@link InternalMergingState}
&lt;p&gt;) that is stored on the heap.&lt;br/&gt;
      *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;K&amp;gt; The type of the key.&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;N&amp;gt; The type of the namespace.&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;SV&amp;gt; The type of the values in the state.&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;S&amp;gt; The type of State&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;SD&amp;gt; The type of StateDescriptor for the State S&lt;br/&gt;
    + * @param &amp;lt;K&amp;gt;	The type of the key.&lt;br/&gt;
    + * @param &amp;lt;N&amp;gt;	The type of the namespace.&lt;br/&gt;
    + * @param &amp;lt;IN&amp;gt;	The type of the input elements.&lt;br/&gt;
    + * @param &amp;lt;SV&amp;gt;	The type of the values in the state.&lt;br/&gt;
    + * @param &amp;lt;OUT&amp;gt;	The type of the output elements.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    indentation&lt;/p&gt;</comment>
                            <comment id="16398257" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174381716&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174381716&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/network/ClientTest.java &amp;#8212;&lt;br/&gt;
    @@ -686,7 +686,7 @@ public void testClientServerIntegration() throws Throwable {&lt;br/&gt;
     				state.update(201 + i);&lt;/p&gt;

&lt;p&gt;     				// we know it must be a KvStat but this is not exposed to the user via State&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    typo: KvStat&lt;/p&gt;</comment>
                            <comment id="16398258" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174381475&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174381475&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/query/KvStateRegistry.java &amp;#8212;&lt;br/&gt;
    @@ -136,13 +138,13 @@ public void unregisterKvState(&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Returns the KvState instance identified by the given KvStateID or&lt;/li&gt;
	&lt;li&gt;* &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt; if none is registered.&lt;br/&gt;
    +	 * Returns the KvState instance identified by the given KvStateID along with
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    would rephrase to `KvStateEntry` containing the `KvState`&lt;/p&gt;</comment>
                            <comment id="16398259" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174382685&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174382685&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-queryable-state/flink-queryable-state-runtime/src/main/java/org/apache/flink/queryablestate/server/KvStateServerHandler.java &amp;#8212;&lt;br/&gt;
    @@ -78,13 +75,22 @@ public KvStateServerHandler(&lt;br/&gt;
     		final CompletableFuture&amp;lt;KvStateResponse&amp;gt; responseFuture = new CompletableFuture&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;p&gt;     		try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final InternalKvState&amp;lt;?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
    +			final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = registry.getKvState(request.getKvStateId());&lt;br/&gt;
     			if (kvState == null) 
{
     				responseFuture.completeExceptionally(new UnknownKvStateIdException(getServerName(), request.getKvStateId()));
     			}
&lt;p&gt; else {&lt;br/&gt;
     				byte[] serializedKeyAndNamespace = request.getSerializedKeyAndNamespace();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;byte[] serializedResult = kvState.getSerializedValue(serializedKeyAndNamespace);&lt;br/&gt;
    +				// here we remove any type check...&lt;br/&gt;
    +				// Ideally we want to keep that the info match the state.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    you can retain type safety:&lt;/p&gt;

&lt;p&gt;    Call from the handler:&lt;br/&gt;
    ```&lt;br/&gt;
    byte[] serializedResult = getSerializedValue(kvState, serializedKeyAndNamespace);&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    Added method:&lt;br/&gt;
    ```&lt;br/&gt;
    private static &amp;lt;K, N, V&amp;gt; byte[] getSerializedValue(KvStateEntry&amp;lt;K, N, V&amp;gt; entry, byte[] serializedKeyAndNamespace) throws Exception &lt;/p&gt;
{
    		InternalKvState&amp;lt;K, N, V&amp;gt; state = entry.getState();
    		KvStateInfo&amp;lt;K, N, V&amp;gt; infoForCurrentThread = entry.getInfoForCurrentThread();
    		
    		return state.getSerializedValue(
    			serializedKeyAndNamespace,
    			infoForCurrentThread.getKeySerializer(),
    			infoForCurrentThread.getNamespaceSerializer(),
    			infoForCurrentThread.getStateValueSerializer()
    		);
    	}
&lt;p&gt;    ```&lt;/p&gt;</comment>
                            <comment id="16398260" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174385360&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174385360&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/query/KvStateRegistryTest.java &amp;#8212;&lt;br/&gt;
    @@ -40,6 +54,81 @@&lt;br/&gt;
      */&lt;br/&gt;
     public class KvStateRegistryTest extends TestLogger {&lt;/p&gt;

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testKvStateEntry() throws InterruptedException {&lt;br/&gt;
    +		final int threads = 10;&lt;br/&gt;
    +&lt;br/&gt;
    +		final CountDownLatch latch1 = new CountDownLatch(threads);&lt;br/&gt;
    +		final CountDownLatch latch2 = new CountDownLatch(1);&lt;br/&gt;
    +&lt;br/&gt;
    +		final List&amp;lt;KvStateInfo&amp;lt;?, ?, ?&amp;gt;&amp;gt; infos = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;());&lt;br/&gt;
    +&lt;br/&gt;
    +		final JobID jobID = new JobID();&lt;br/&gt;
    +&lt;br/&gt;
    +		final JobVertexID jobVertexId = new JobVertexID();&lt;br/&gt;
    +		final KeyGroupRange keyGroupRange = new KeyGroupRange(0, 1);&lt;br/&gt;
    +		final String registrationName = &quot;foobar&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +		final KvStateRegistry kvStateRegistry = new KvStateRegistry();&lt;br/&gt;
    +		final KvStateID stateID = kvStateRegistry.registerKvState(&lt;br/&gt;
    +				jobID,&lt;br/&gt;
    +				jobVertexId,&lt;br/&gt;
    +				keyGroupRange,&lt;br/&gt;
    +				registrationName,&lt;br/&gt;
    +				new DummyKvState()&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; threads; i++) {&lt;br/&gt;
    +			new Thread(() -&amp;gt; {&lt;br/&gt;
    +				final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = kvStateRegistry.getKvState(stateID);&lt;br/&gt;
    +				final KvStateInfo&amp;lt;?, ?, ?&amp;gt; stateInfo = kvState.getInfoForCurrentThread();&lt;br/&gt;
    +				infos.add(stateInfo);&lt;br/&gt;
    +&lt;br/&gt;
    +				latch1.countDown();&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					latch2.await();
    +				}
&lt;p&gt; catch (InterruptedException e) {&lt;br/&gt;
    +					Assert.fail(e.getMessage());&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    this would never directly fail the test and we may loose the exception&lt;/p&gt;</comment>
                            <comment id="16398261" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174383043&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174383043&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/query/KvStateEntry.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,79 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.runtime.query;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.annotation.Internal;&lt;br/&gt;
    +import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
    +import org.apache.flink.runtime.state.internal.InternalKvState;&lt;br/&gt;
    +import org.apache.flink.util.Preconditions;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentMap;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * An entry holding the &lt;/p&gt;
{@link InternalKvState}
&lt;p&gt; along with its &lt;/p&gt;
{@link KvStateInfo}
&lt;p&gt;.&lt;br/&gt;
    + *&lt;br/&gt;
    + * @param &amp;lt;K&amp;gt;	The type of key the state is associated to&lt;br/&gt;
    + * @param &amp;lt;N&amp;gt;	The type of the namespace the state is associated to&lt;br/&gt;
    + * @param &amp;lt;V&amp;gt;	The type of values kept internally in state&lt;br/&gt;
    + */&lt;br/&gt;
    +@Internal&lt;br/&gt;
    +public class KvStateEntry&amp;lt;K, N, V&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +	private final InternalKvState&amp;lt;K, N, V&amp;gt; state;&lt;br/&gt;
    +	private final KvStateInfo&amp;lt;K, N, V&amp;gt; stateInfo;&lt;br/&gt;
    +&lt;br/&gt;
    +	private final ConcurrentMap&amp;lt;Thread, KvStateInfo&amp;lt;K, N, V&amp;gt;&amp;gt; serializerCache;&lt;br/&gt;
    +&lt;br/&gt;
    +	public KvStateEntry(final InternalKvState&amp;lt;K, N, V&amp;gt; state) {&lt;br/&gt;
    +&lt;br/&gt;
    +		this.state = Preconditions.checkNotNull(state);&lt;br/&gt;
    +		this.stateInfo = new KvStateInfo&amp;lt;&amp;gt;(&lt;br/&gt;
    +				state.getKeySerializer(),&lt;br/&gt;
    +				state.getNamespaceSerializer(),&lt;br/&gt;
    +				state.getValueSerializer()&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		this.serializerCache =&lt;br/&gt;
    +				stateInfo.duplicate() == stateInfo&lt;br/&gt;
    +						? null							// if the serializers are stateless, we do not need a cache&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    An empty map would be acceptable here.&lt;/p&gt;</comment>
                            <comment id="16398262" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174383199&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174383199&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/query/KvStateInfo.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,114 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.runtime.query;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.state.internal.InternalKvState;&lt;br/&gt;
    +import org.apache.flink.util.Preconditions;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.Objects;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * Metadata about a &lt;/p&gt;
{@link InternalKvState}
&lt;p&gt;. This includes the serializers for&lt;br/&gt;
    + * the key, the namespace, and the values kept in the state.&lt;br/&gt;
    + *&lt;br/&gt;
    + * @param &amp;lt;K&amp;gt;	The type of key the state is associated to&lt;br/&gt;
    + * @param &amp;lt;N&amp;gt;	The type of the namespace the state is associated to&lt;br/&gt;
    + * @param &amp;lt;V&amp;gt;	The type of values kept internally in state&lt;br/&gt;
    + */&lt;br/&gt;
    +public class KvStateInfo&amp;lt;K, N, V&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +	private final TypeSerializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
    +	private final TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer;&lt;br/&gt;
    +	private final TypeSerializer&amp;lt;V&amp;gt; stateValueSerializer;&lt;br/&gt;
    +&lt;br/&gt;
    +	public KvStateInfo(&lt;br/&gt;
    +			final TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
    +			final TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer,&lt;br/&gt;
    +			final TypeSerializer&amp;lt;V&amp;gt; stateValueSerializer&lt;br/&gt;
    +	) &lt;/p&gt;
{
    +		this.keySerializer = Preconditions.checkNotNull(keySerializer);
    +		this.namespaceSerializer = Preconditions.checkNotNull(namespaceSerializer);
    +		this.stateValueSerializer = Preconditions.checkNotNull(stateValueSerializer);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * @return The serializer for the key the state is associated to.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public TypeSerializer&amp;lt;K&amp;gt; getKeySerializer() &lt;/p&gt;
{
    +		return keySerializer;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * @return The serializer for the namespace the state is associated to.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public TypeSerializer&amp;lt;N&amp;gt; getNamespaceSerializer() &lt;/p&gt;
{
    +		return namespaceSerializer;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * @return The serializer for the values kept in the state.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public TypeSerializer&amp;lt;V&amp;gt; getStateValueSerializer() &lt;/p&gt;
{
    +		return stateValueSerializer;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Creates a deep copy of the current &lt;/p&gt;
{@link KvStateInfo}
&lt;p&gt; by duplicating&lt;br/&gt;
    +	 * all the included serializers.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;This method assumes correct implementation of the &lt;/p&gt;
{@link TypeSerializer#duplicate()}
&lt;p&gt;    +	 * method of the included serializers.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public KvStateInfo&amp;lt;K, N, V&amp;gt; duplicate() {&lt;br/&gt;
    +		final TypeSerializer&amp;lt;K&amp;gt; dupKeySerializer = keySerializer.duplicate();&lt;br/&gt;
    +		final TypeSerializer&amp;lt;N&amp;gt; dupNamespaceSerializer = namespaceSerializer.duplicate();&lt;br/&gt;
    +		final TypeSerializer&amp;lt;V&amp;gt; dupSVSerializer = stateValueSerializer.duplicate();&lt;br/&gt;
    +&lt;br/&gt;
    +		if (&lt;br/&gt;
    +				dupKeySerializer == keySerializer &amp;amp;&amp;amp;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    odd formatting&lt;/p&gt;</comment>
                            <comment id="16398263" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174380400&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174380400&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/internal/InternalAppendingState.java &amp;#8212;&lt;br/&gt;
    @@ -24,9 +24,11 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The peer to the 
{@link AppendingState}
&lt;p&gt; in the internal state type hierarchy.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;See 
{@link InternalKvState}
&lt;p&gt; for a description of the internal state hierarchy.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;N&amp;gt;   The type of the namespace&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;IN&amp;gt;  The type of elements added to the state&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;OUT&amp;gt; The type of the&lt;br/&gt;
    + *&lt;br/&gt;
    + * @param &amp;lt;K&amp;gt;	The type of key the state is associated to&lt;br/&gt;
    + * @param &amp;lt;N&amp;gt;	The type of the namespace&lt;br/&gt;
    + * @param &amp;lt;IN&amp;gt;	The type of elements added to the state&lt;br/&gt;
    + * @param &amp;lt;SV&amp;gt;	The type of elements in the state&lt;br/&gt;
    + * @param &amp;lt;OUT&amp;gt;	The type of the resulting element in the state
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    indentation is weird&lt;/p&gt;</comment>
                            <comment id="16398264" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174385024&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174385024&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/query/KvStateRegistryTest.java &amp;#8212;&lt;br/&gt;
    @@ -40,6 +54,81 @@&lt;br/&gt;
      */&lt;br/&gt;
     public class KvStateRegistryTest extends TestLogger {&lt;/p&gt;

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testKvStateEntry() throws InterruptedException {&lt;br/&gt;
    +		final int threads = 10;&lt;br/&gt;
    +&lt;br/&gt;
    +		final CountDownLatch latch1 = new CountDownLatch(threads);&lt;br/&gt;
    +		final CountDownLatch latch2 = new CountDownLatch(1);&lt;br/&gt;
    +&lt;br/&gt;
    +		final List&amp;lt;KvStateInfo&amp;lt;?, ?, ?&amp;gt;&amp;gt; infos = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;());&lt;br/&gt;
    +&lt;br/&gt;
    +		final JobID jobID = new JobID();&lt;br/&gt;
    +&lt;br/&gt;
    +		final JobVertexID jobVertexId = new JobVertexID();&lt;br/&gt;
    +		final KeyGroupRange keyGroupRange = new KeyGroupRange(0, 1);&lt;br/&gt;
    +		final String registrationName = &quot;foobar&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +		final KvStateRegistry kvStateRegistry = new KvStateRegistry();&lt;br/&gt;
    +		final KvStateID stateID = kvStateRegistry.registerKvState(&lt;br/&gt;
    +				jobID,&lt;br/&gt;
    +				jobVertexId,&lt;br/&gt;
    +				keyGroupRange,&lt;br/&gt;
    +				registrationName,&lt;br/&gt;
    +				new DummyKvState()&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; threads; i++) {&lt;br/&gt;
    +			new Thread(() -&amp;gt; {&lt;br/&gt;
    +				final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = kvStateRegistry.getKvState(stateID);&lt;br/&gt;
    +				final KvStateInfo&amp;lt;?, ?, ?&amp;gt; stateInfo = kvState.getInfoForCurrentThread();&lt;br/&gt;
    +				infos.add(stateInfo);&lt;br/&gt;
    +&lt;br/&gt;
    +				latch1.countDown();&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					latch2.await();
    +				}
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
    +					Assert.fail(e.getMessage());
    +				}
&lt;p&gt;    +&lt;br/&gt;
    +			}).start();&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		latch1.await();&lt;br/&gt;
    +&lt;br/&gt;
    +		final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = kvStateRegistry.getKvState(stateID);&lt;br/&gt;
    +&lt;br/&gt;
    +		// verify that all the threads are done correctly.&lt;br/&gt;
    +		Assert.assertEquals(threads, infos.size());&lt;br/&gt;
    +		Assert.assertEquals(threads, kvState.getCacheSize());&lt;br/&gt;
    +&lt;br/&gt;
    +		latch2.countDown();&lt;br/&gt;
    +&lt;br/&gt;
    +		for (KvStateInfo&amp;lt;?, ?, ?&amp;gt; infoA: infos) {&lt;br/&gt;
    +			boolean found = false;&lt;br/&gt;
    +			for (KvStateInfo&amp;lt;?, ?, ?&amp;gt; infoB: infos) {&lt;br/&gt;
    +				if (infoA == infoB) {&lt;br/&gt;
    +					if (found) {&lt;br/&gt;
    +						Assert.fail(&quot;Already found&quot;);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    needs a better error message&lt;/p&gt;</comment>
                            <comment id="16398265" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174385129&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174385129&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/query/KvStateRegistryTest.java &amp;#8212;&lt;br/&gt;
    @@ -40,6 +54,81 @@&lt;br/&gt;
      */&lt;br/&gt;
     public class KvStateRegistryTest extends TestLogger {&lt;/p&gt;

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testKvStateEntry() throws InterruptedException {&lt;br/&gt;
    +		final int threads = 10;&lt;br/&gt;
    +&lt;br/&gt;
    +		final CountDownLatch latch1 = new CountDownLatch(threads);&lt;br/&gt;
    +		final CountDownLatch latch2 = new CountDownLatch(1);&lt;br/&gt;
    +&lt;br/&gt;
    +		final List&amp;lt;KvStateInfo&amp;lt;?, ?, ?&amp;gt;&amp;gt; infos = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;());&lt;br/&gt;
    +&lt;br/&gt;
    +		final JobID jobID = new JobID();&lt;br/&gt;
    +&lt;br/&gt;
    +		final JobVertexID jobVertexId = new JobVertexID();&lt;br/&gt;
    +		final KeyGroupRange keyGroupRange = new KeyGroupRange(0, 1);&lt;br/&gt;
    +		final String registrationName = &quot;foobar&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +		final KvStateRegistry kvStateRegistry = new KvStateRegistry();&lt;br/&gt;
    +		final KvStateID stateID = kvStateRegistry.registerKvState(&lt;br/&gt;
    +				jobID,&lt;br/&gt;
    +				jobVertexId,&lt;br/&gt;
    +				keyGroupRange,&lt;br/&gt;
    +				registrationName,&lt;br/&gt;
    +				new DummyKvState()&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; threads; i++) {&lt;br/&gt;
    +			new Thread(() -&amp;gt; {&lt;br/&gt;
    +				final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = kvStateRegistry.getKvState(stateID);&lt;br/&gt;
    +				final KvStateInfo&amp;lt;?, ?, ?&amp;gt; stateInfo = kvState.getInfoForCurrentThread();&lt;br/&gt;
    +				infos.add(stateInfo);&lt;br/&gt;
    +&lt;br/&gt;
    +				latch1.countDown();&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					latch2.await();
    +				}
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
    +					Assert.fail(e.getMessage());
    +				}
&lt;p&gt;    +&lt;br/&gt;
    +			}).start();&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		latch1.await();&lt;br/&gt;
    +&lt;br/&gt;
    +		final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = kvStateRegistry.getKvState(stateID);&lt;br/&gt;
    +&lt;br/&gt;
    +		// verify that all the threads are done correctly.&lt;br/&gt;
    +		Assert.assertEquals(threads, infos.size());&lt;br/&gt;
    +		Assert.assertEquals(threads, kvState.getCacheSize());&lt;br/&gt;
    +&lt;br/&gt;
    +		latch2.countDown();&lt;br/&gt;
    +&lt;br/&gt;
    +		for (KvStateInfo&amp;lt;?, ?, ?&amp;gt; infoA: infos) {&lt;br/&gt;
    +			boolean found = false;&lt;br/&gt;
    +			for (KvStateInfo&amp;lt;?, ?, ?&amp;gt; infoB: infos) {&lt;br/&gt;
    +				if (infoA == infoB) {&lt;br/&gt;
    +					if (found) &lt;/p&gt;
{
    +						Assert.fail(&quot;Already found&quot;);
    +					}
&lt;p&gt;    +					found = true;&lt;br/&gt;
    +				} else &lt;/p&gt;
{
    +					Assert.assertTrue(infoA != infoB &amp;amp;&amp;amp; infoA.equals(infoB));
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		kvStateRegistry.unregisterKvState(&lt;br/&gt;
    +				jobID,&lt;br/&gt;
    +				jobVertexId,&lt;br/&gt;
    +				keyGroupRange,&lt;br/&gt;
    +				registrationName,&lt;br/&gt;
    +				stateID);&lt;br/&gt;
    +&lt;br/&gt;
    +		// we have to call for garbage collection to be sure that everything is cleared up.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    ?&lt;/p&gt;</comment>
                            <comment id="16398266" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174383696&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174383696&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapMapState.java &amp;#8212;&lt;br/&gt;
    @@ -140,19 +159,28 @@ public boolean contains(UK userKey) {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public byte[] getSerializedValue(K key, N namespace) throws IOException {&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(namespace != null, &quot;No namespace given.&quot;);&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(key != null, &quot;No key given.&quot;);&lt;br/&gt;
    +	public byte[] getSerializedValue(&lt;br/&gt;
    +			byte[] serializedKeyAndNamespace,&lt;br/&gt;
    +			TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
    +			TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer,&lt;br/&gt;
    +			TypeSerializer&amp;lt;HashMap&amp;lt;UK, UV&amp;gt;&amp;gt; valueSerializer) throws Exception {&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;HashMap&amp;lt;UK, UV&amp;gt; result = stateTable.get(key, namespace);&lt;br/&gt;
    +		Preconditions.checkNotNull(serializedKeyAndNamespace, &quot;Serialized key and namespace&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (null == result) {&lt;br/&gt;
    +		Tuple2&amp;lt;K, N&amp;gt; keyAndNamespace = KvStateSerializer.deserializeKeyAndNamespace(&lt;br/&gt;
    +				serializedKeyAndNamespace, keySerializer, namespaceSerializer);&lt;br/&gt;
    +&lt;br/&gt;
    +		Map&amp;lt;UK, UV&amp;gt; result = stateTable.get(keyAndNamespace.f0, keyAndNamespace.f1);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (result == null) 
{
     			return null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TypeSerializer&amp;lt;UK&amp;gt; userKeySerializer = stateDesc.getKeySerializer();&lt;/li&gt;
	&lt;li&gt;TypeSerializer&amp;lt;UV&amp;gt; userValueSerializer = stateDesc.getValueSerializer();&lt;br/&gt;
    +		final HashMapSerializer&amp;lt;UK, UV&amp;gt; serializer = (HashMapSerializer&amp;lt;UK, UV&amp;gt;) valueSerializer;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    this shouldn&apos;t be necessary. why can&apos;t we just pass the map serialzer into `serializeMap`?&lt;/p&gt;</comment>
                            <comment id="16398267" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174385834&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174385834&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/query/KvStateRegistryTest.java &amp;#8212;&lt;br/&gt;
    @@ -40,6 +54,81 @@&lt;br/&gt;
      */&lt;br/&gt;
     public class KvStateRegistryTest extends TestLogger {&lt;/p&gt;

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testKvStateEntry() throws InterruptedException {&lt;br/&gt;
    +		final int threads = 10;&lt;br/&gt;
    +&lt;br/&gt;
    +		final CountDownLatch latch1 = new CountDownLatch(threads);&lt;br/&gt;
    +		final CountDownLatch latch2 = new CountDownLatch(1);&lt;br/&gt;
    +&lt;br/&gt;
    +		final List&amp;lt;KvStateInfo&amp;lt;?, ?, ?&amp;gt;&amp;gt; infos = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;());&lt;br/&gt;
    +&lt;br/&gt;
    +		final JobID jobID = new JobID();&lt;br/&gt;
    +&lt;br/&gt;
    +		final JobVertexID jobVertexId = new JobVertexID();&lt;br/&gt;
    +		final KeyGroupRange keyGroupRange = new KeyGroupRange(0, 1);&lt;br/&gt;
    +		final String registrationName = &quot;foobar&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +		final KvStateRegistry kvStateRegistry = new KvStateRegistry();&lt;br/&gt;
    +		final KvStateID stateID = kvStateRegistry.registerKvState(&lt;br/&gt;
    +				jobID,&lt;br/&gt;
    +				jobVertexId,&lt;br/&gt;
    +				keyGroupRange,&lt;br/&gt;
    +				registrationName,&lt;br/&gt;
    +				new DummyKvState()&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; threads; i++) {&lt;br/&gt;
    +			new Thread(() -&amp;gt; {&lt;br/&gt;
    +				final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = kvStateRegistry.getKvState(stateID);&lt;br/&gt;
    +				final KvStateInfo&amp;lt;?, ?, ?&amp;gt; stateInfo = kvState.getInfoForCurrentThread();&lt;br/&gt;
    +				infos.add(stateInfo);&lt;br/&gt;
    +&lt;br/&gt;
    +				latch1.countDown();&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					latch2.await();
    +				}
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
    +					Assert.fail(e.getMessage());
    +				}
&lt;p&gt;    +&lt;br/&gt;
    +			}).start();&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		latch1.await();&lt;br/&gt;
    +&lt;br/&gt;
    +		final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = kvStateRegistry.getKvState(stateID);&lt;br/&gt;
    +&lt;br/&gt;
    +		// verify that all the threads are done correctly.&lt;br/&gt;
    +		Assert.assertEquals(threads, infos.size());&lt;br/&gt;
    +		Assert.assertEquals(threads, kvState.getCacheSize());&lt;br/&gt;
    +&lt;br/&gt;
    +		latch2.countDown();&lt;br/&gt;
    +&lt;br/&gt;
    +		for (KvStateInfo&amp;lt;?, ?, ?&amp;gt; infoA: infos) {&lt;br/&gt;
    +			boolean found = false;&lt;br/&gt;
    +			for (KvStateInfo&amp;lt;?, ?, ?&amp;gt; infoB: infos) {&lt;br/&gt;
    +				if (infoA == infoB) {&lt;br/&gt;
    +					if (found) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    `found` needs a better name or a comment what it means&lt;/p&gt;</comment>
                            <comment id="16398268" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174380197&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174380197&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/internal/InternalMapState.java &amp;#8212;&lt;br/&gt;
    @@ -20,13 +20,16 @@&lt;/p&gt;

&lt;p&gt;     import org.apache.flink.api.common.state.MapState;&lt;/p&gt;

&lt;p&gt;    +import java.util.Map;&lt;br/&gt;
    +&lt;br/&gt;
     /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The peer to the 
{@link MapState}
&lt;p&gt; in the internal state type hierarchy.&lt;br/&gt;
      *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;See 
{@link InternalKvState}
&lt;p&gt; for a description of the internal state hierarchy.&lt;br/&gt;
      *&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @param &amp;lt;N&amp;gt; The type of the namespace&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;UK&amp;gt; Type of the values folded into the state&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;UV&amp;gt; Type of the value in the state&lt;br/&gt;
    + * @param &amp;lt;K&amp;gt;	The type of key the state is associated to&lt;br/&gt;
    + * @param &amp;lt;N&amp;gt;	The type of the namespace&lt;br/&gt;
    + * @param &amp;lt;UK&amp;gt;	Type of the values folded into the state
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    the description seems like a copy&amp;amp;paste from `FoldingState`&lt;/p&gt;</comment>
                            <comment id="16398269" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174384860&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174384860&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/query/KvStateRegistryTest.java &amp;#8212;&lt;br/&gt;
    @@ -40,6 +54,81 @@&lt;br/&gt;
      */&lt;br/&gt;
     public class KvStateRegistryTest extends TestLogger {&lt;/p&gt;

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testKvStateEntry() throws InterruptedException {&lt;br/&gt;
    +		final int threads = 10;&lt;br/&gt;
    +&lt;br/&gt;
    +		final CountDownLatch latch1 = new CountDownLatch(threads);&lt;br/&gt;
    +		final CountDownLatch latch2 = new CountDownLatch(1);&lt;br/&gt;
    +&lt;br/&gt;
    +		final List&amp;lt;KvStateInfo&amp;lt;?, ?, ?&amp;gt;&amp;gt; infos = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;());&lt;br/&gt;
    +&lt;br/&gt;
    +		final JobID jobID = new JobID();&lt;br/&gt;
    +&lt;br/&gt;
    +		final JobVertexID jobVertexId = new JobVertexID();&lt;br/&gt;
    +		final KeyGroupRange keyGroupRange = new KeyGroupRange(0, 1);&lt;br/&gt;
    +		final String registrationName = &quot;foobar&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +		final KvStateRegistry kvStateRegistry = new KvStateRegistry();&lt;br/&gt;
    +		final KvStateID stateID = kvStateRegistry.registerKvState(&lt;br/&gt;
    +				jobID,&lt;br/&gt;
    +				jobVertexId,&lt;br/&gt;
    +				keyGroupRange,&lt;br/&gt;
    +				registrationName,&lt;br/&gt;
    +				new DummyKvState()&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; threads; i++) {&lt;br/&gt;
    +			new Thread(() -&amp;gt; {&lt;br/&gt;
    +				final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = kvStateRegistry.getKvState(stateID);&lt;br/&gt;
    +				final KvStateInfo&amp;lt;?, ?, ?&amp;gt; stateInfo = kvState.getInfoForCurrentThread();&lt;br/&gt;
    +				infos.add(stateInfo);&lt;br/&gt;
    +&lt;br/&gt;
    +				latch1.countDown();&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					latch2.await();
    +				}
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
    +					Assert.fail(e.getMessage());
    +				}
&lt;p&gt;    +&lt;br/&gt;
    +			}).start();&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		latch1.await();&lt;br/&gt;
    +&lt;br/&gt;
    +		final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = kvStateRegistry.getKvState(stateID);&lt;br/&gt;
    +&lt;br/&gt;
    +		// verify that all the threads are done correctly.&lt;br/&gt;
    +		Assert.assertEquals(threads, infos.size());&lt;br/&gt;
    +		Assert.assertEquals(threads, kvState.getCacheSize());&lt;br/&gt;
    +&lt;br/&gt;
    +		latch2.countDown();&lt;br/&gt;
    +&lt;br/&gt;
    +		for (KvStateInfo&amp;lt;?, ?, ?&amp;gt; infoA: infos) {&lt;br/&gt;
    +			boolean found = false;&lt;br/&gt;
    +			for (KvStateInfo&amp;lt;?, ?, ?&amp;gt; infoB: infos) {&lt;br/&gt;
    +				if (infoA == infoB) {&lt;br/&gt;
    +					if (found) &lt;/p&gt;
{
    +						Assert.fail(&quot;Already found&quot;);
    +					}
&lt;p&gt;    +					found = true;&lt;br/&gt;
    +				} else {&lt;br/&gt;
    +					Assert.assertTrue(infoA != infoB &amp;amp;&amp;amp; infoA.equals(infoB));&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    `infoA != infoB` is redundant&lt;/p&gt;</comment>
                            <comment id="16398270" author="githubbot" created="Wed, 14 Mar 2018 08:46:13 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174380673&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174380673&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapAggregatingState.java &amp;#8212;&lt;br/&gt;
    @@ -30,18 +30,17 @@&lt;br/&gt;
     import java.io.IOException;&lt;/p&gt;

&lt;p&gt;     /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Heap-backed partitioned 
{@link ReducingState} that is&lt;br/&gt;
    - * snapshotted into files.&lt;br/&gt;
    + * Heap-backed partitioned {@link ReducingState}
&lt;p&gt; that is snapshotted into files.&lt;br/&gt;
      *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;K&amp;gt; The type of the key.&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;N&amp;gt; The type of the namespace.&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;IN&amp;gt; The type of the value added to the state.&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;ACC&amp;gt; The type of the value stored in the state (the accumulator type).&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;OUT&amp;gt; The type of the value returned from the state.&lt;br/&gt;
    + * @param &amp;lt;K&amp;gt;	The type of the key.&lt;br/&gt;
    + * @param &amp;lt;N&amp;gt;	The type of the namespace.&lt;br/&gt;
    + * @param &amp;lt;IN&amp;gt;	The type of the value added to the state.&lt;br/&gt;
    + * @param &amp;lt;ACC&amp;gt;	The type of the value stored in the state (the accumulator type).&lt;br/&gt;
    + * @param &amp;lt;OUT&amp;gt;	The type of the value returned from the state.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    indentation&lt;/p&gt;</comment>
                            <comment id="16398271" author="githubbot" created="Wed, 14 Mar 2018 08:46:14 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174380623&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174380623&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapFoldingState.java &amp;#8212;&lt;br/&gt;
    @@ -29,20 +29,19 @@&lt;br/&gt;
     import java.io.IOException;&lt;/p&gt;

&lt;p&gt;     /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Heap-backed partitioned 
{@link FoldingState} that is&lt;br/&gt;
    - * snapshotted into files.&lt;br/&gt;
    + * Heap-backed partitioned {@link FoldingState}
&lt;p&gt; that is snapshotted into files.&lt;br/&gt;
      *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;K&amp;gt; The type of the key.&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;N&amp;gt; The type of the namespace.&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;T&amp;gt; The type of the values that can be folded into the state.&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;ACC&amp;gt; The type of the value in the folding state.&lt;br/&gt;
    + * @param &amp;lt;K&amp;gt;	The type of the key.&lt;br/&gt;
    + * @param &amp;lt;N&amp;gt;	The type of the namespace.&lt;br/&gt;
    + * @param &amp;lt;T&amp;gt;	The type of the values that can be folded into the state.&lt;br/&gt;
    + * @param &amp;lt;ACC&amp;gt;	The type of the value in the folding state.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    indentation is funky&lt;/p&gt;</comment>
                            <comment id="16398341" author="githubbot" created="Wed, 14 Mar 2018 09:48:26 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174402053&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174402053&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/query/KvStateRegistryTest.java &amp;#8212;&lt;br/&gt;
    @@ -40,6 +54,81 @@&lt;br/&gt;
      */&lt;br/&gt;
     public class KvStateRegistryTest extends TestLogger {&lt;/p&gt;

&lt;p&gt;    +	@Test&lt;br/&gt;
    +	public void testKvStateEntry() throws InterruptedException {&lt;br/&gt;
    +		final int threads = 10;&lt;br/&gt;
    +&lt;br/&gt;
    +		final CountDownLatch latch1 = new CountDownLatch(threads);&lt;br/&gt;
    +		final CountDownLatch latch2 = new CountDownLatch(1);&lt;br/&gt;
    +&lt;br/&gt;
    +		final List&amp;lt;KvStateInfo&amp;lt;?, ?, ?&amp;gt;&amp;gt; infos = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;());&lt;br/&gt;
    +&lt;br/&gt;
    +		final JobID jobID = new JobID();&lt;br/&gt;
    +&lt;br/&gt;
    +		final JobVertexID jobVertexId = new JobVertexID();&lt;br/&gt;
    +		final KeyGroupRange keyGroupRange = new KeyGroupRange(0, 1);&lt;br/&gt;
    +		final String registrationName = &quot;foobar&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +		final KvStateRegistry kvStateRegistry = new KvStateRegistry();&lt;br/&gt;
    +		final KvStateID stateID = kvStateRegistry.registerKvState(&lt;br/&gt;
    +				jobID,&lt;br/&gt;
    +				jobVertexId,&lt;br/&gt;
    +				keyGroupRange,&lt;br/&gt;
    +				registrationName,&lt;br/&gt;
    +				new DummyKvState()&lt;br/&gt;
    +		);&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; threads; i++) {&lt;br/&gt;
    +			new Thread(() -&amp;gt; {&lt;br/&gt;
    +				final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = kvStateRegistry.getKvState(stateID);&lt;br/&gt;
    +				final KvStateInfo&amp;lt;?, ?, ?&amp;gt; stateInfo = kvState.getInfoForCurrentThread();&lt;br/&gt;
    +				infos.add(stateInfo);&lt;br/&gt;
    +&lt;br/&gt;
    +				latch1.countDown();&lt;br/&gt;
    +				try &lt;/p&gt;
{
    +					latch2.await();
    +				}
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
    +					Assert.fail(e.getMessage());
    +				}
&lt;p&gt;    +&lt;br/&gt;
    +			}).start();&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		latch1.await();&lt;br/&gt;
    +&lt;br/&gt;
    +		final KvStateEntry&amp;lt;?, ?, ?&amp;gt; kvState = kvStateRegistry.getKvState(stateID);&lt;br/&gt;
    +&lt;br/&gt;
    +		// verify that all the threads are done correctly.&lt;br/&gt;
    +		Assert.assertEquals(threads, infos.size());&lt;br/&gt;
    +		Assert.assertEquals(threads, kvState.getCacheSize());&lt;br/&gt;
    +&lt;br/&gt;
    +		latch2.countDown();&lt;br/&gt;
    +&lt;br/&gt;
    +		for (KvStateInfo&amp;lt;?, ?, ?&amp;gt; infoA: infos) {&lt;br/&gt;
    +			boolean found = false;&lt;br/&gt;
    +			for (KvStateInfo&amp;lt;?, ?, ?&amp;gt; infoB: infos) {&lt;br/&gt;
    +				if (infoA == infoB) {&lt;br/&gt;
    +					if (found) &lt;/p&gt;
{
    +						Assert.fail(&quot;Already found&quot;);
    +					}
&lt;p&gt;    +					found = true;&lt;br/&gt;
    +				} else &lt;/p&gt;
{
    +					Assert.assertTrue(infoA != infoB &amp;amp;&amp;amp; infoA.equals(infoB));
    +				}
&lt;p&gt;    +			}&lt;br/&gt;
    +		}&lt;br/&gt;
    +&lt;br/&gt;
    +		kvStateRegistry.unregisterKvState(&lt;br/&gt;
    +				jobID,&lt;br/&gt;
    +				jobVertexId,&lt;br/&gt;
    +				keyGroupRange,&lt;br/&gt;
    +				registrationName,&lt;br/&gt;
    +				stateID);&lt;br/&gt;
    +&lt;br/&gt;
    +		// we have to call for garbage collection to be sure that everything is cleared up.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Forgotten from previous experiments that were using a weak hash map. I will remove it.&lt;/p&gt;</comment>
                            <comment id="16398400" author="githubbot" created="Wed, 14 Mar 2018 11:09:15 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174423536&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174423536&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapMapState.java &amp;#8212;&lt;br/&gt;
    @@ -140,19 +159,28 @@ public boolean contains(UK userKey) {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public byte[] getSerializedValue(K key, N namespace) throws IOException {&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(namespace != null, &quot;No namespace given.&quot;);&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(key != null, &quot;No key given.&quot;);&lt;br/&gt;
    +	public byte[] getSerializedValue(&lt;br/&gt;
    +			byte[] serializedKeyAndNamespace,&lt;br/&gt;
    +			TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
    +			TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer,&lt;br/&gt;
    +			TypeSerializer&amp;lt;HashMap&amp;lt;UK, UV&amp;gt;&amp;gt; valueSerializer) throws Exception {&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;HashMap&amp;lt;UK, UV&amp;gt; result = stateTable.get(key, namespace);&lt;br/&gt;
    +		Preconditions.checkNotNull(serializedKeyAndNamespace, &quot;Serialized key and namespace&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (null == result) {&lt;br/&gt;
    +		Tuple2&amp;lt;K, N&amp;gt; keyAndNamespace = KvStateSerializer.deserializeKeyAndNamespace(&lt;br/&gt;
    +				serializedKeyAndNamespace, keySerializer, namespaceSerializer);&lt;br/&gt;
    +&lt;br/&gt;
    +		Map&amp;lt;UK, UV&amp;gt; result = stateTable.get(keyAndNamespace.f0, keyAndNamespace.f1);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (result == null) 
{
     			return null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TypeSerializer&amp;lt;UK&amp;gt; userKeySerializer = stateDesc.getKeySerializer();&lt;/li&gt;
	&lt;li&gt;TypeSerializer&amp;lt;UV&amp;gt; userValueSerializer = stateDesc.getValueSerializer();&lt;br/&gt;
    +		final HashMapSerializer&amp;lt;UK, UV&amp;gt; serializer = (HashMapSerializer&amp;lt;UK, UV&amp;gt;) valueSerializer;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The problem is that the Heap Backend uses the `HashMapSerializer` while RocksDB uses `MapSerializer`. So here it should be sth like `TypeSerializer&amp;lt;? extends Map&amp;lt;UK, UV&amp;gt;&amp;gt;` that then should somehow be casted to the appropriate serializer somehow in order to get the key and the value serializer. The solution that we have here is a bit cleaner, although the best would be to remove the `HashMapSerializer` and have a `MapSerializer` in here.&lt;/p&gt;</comment>
                            <comment id="16398401" author="githubbot" created="Wed, 14 Mar 2018 11:11:10 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for the review @zentol ! I updated the PR integrating your comments, or commenting on why I did not do it. Please have a look and let me know if you have more comments.&lt;/p&gt;</comment>
                            <comment id="16398530" author="githubbot" created="Wed, 14 Mar 2018 12:49:22 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174444070&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174444070&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/query/KvStateEntry.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,77 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.runtime.query;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.annotation.Internal;&lt;br/&gt;
    +import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
    +import org.apache.flink.runtime.state.internal.InternalKvState;&lt;br/&gt;
    +import org.apache.flink.util.Preconditions;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentMap;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * An entry holding the &lt;/p&gt;
{@link InternalKvState}
&lt;p&gt; along with its &lt;/p&gt;
{@link KvStateInfo}
&lt;p&gt;.&lt;br/&gt;
    + *&lt;br/&gt;
    + * @param &amp;lt;K&amp;gt;	The type of key the state is associated to&lt;br/&gt;
    + * @param &amp;lt;N&amp;gt;	The type of the namespace the state is associated to&lt;br/&gt;
    + * @param &amp;lt;V&amp;gt;	The type of values kept internally in state&lt;br/&gt;
    + */&lt;br/&gt;
    +@Internal&lt;br/&gt;
    +public class KvStateEntry&amp;lt;K, N, V&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +	private final InternalKvState&amp;lt;K, N, V&amp;gt; state;&lt;br/&gt;
    +	private final KvStateInfo&amp;lt;K, N, V&amp;gt; stateInfo;&lt;br/&gt;
    +&lt;br/&gt;
    +	private final boolean isSerializerStateless;&lt;br/&gt;
    +&lt;br/&gt;
    +	private final ConcurrentMap&amp;lt;Thread, KvStateInfo&amp;lt;K, N, V&amp;gt;&amp;gt; serializerCache;&lt;br/&gt;
    +&lt;br/&gt;
    +	public KvStateEntry(final InternalKvState&amp;lt;K, N, V&amp;gt; state) &lt;/p&gt;
{
    +		this.state = Preconditions.checkNotNull(state);
    +		this.stateInfo = new KvStateInfo&amp;lt;&amp;gt;(
    +				state.getKeySerializer(),
    +				state.getNamespaceSerializer(),
    +				state.getValueSerializer()
    +		);
    +		this.serializerCache = new ConcurrentHashMap&amp;lt;&amp;gt;();
    +		this.isSerializerStateless = stateInfo.duplicate() == stateInfo;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public InternalKvState&amp;lt;K, N, V&amp;gt; getState() &lt;/p&gt;
{
    +		return state;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public KvStateInfo&amp;lt;K, N, V&amp;gt; getInfoForCurrentThread() &lt;/p&gt;
{
    +		return isSerializerStateless
    +				? stateInfo
    +				: serializerCache.computeIfAbsent(Thread.currentThread(), t -&amp;gt; stateInfo.duplicate());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public void clear() {&lt;br/&gt;
    +		if (serializerCache != null) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    unnecessary null check&lt;/p&gt;</comment>
                            <comment id="16398531" author="githubbot" created="Wed, 14 Mar 2018 12:49:22 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174444245&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174444245&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/query/KvStateEntry.java &amp;#8212;&lt;br/&gt;
    @@ -39,29 +39,27 @@&lt;br/&gt;
     	private final InternalKvState&amp;lt;K, N, V&amp;gt; state;&lt;br/&gt;
     	private final KvStateInfo&amp;lt;K, N, V&amp;gt; stateInfo;&lt;/p&gt;

&lt;p&gt;    +	private final boolean isSerializerStateless;&lt;br/&gt;
    +&lt;br/&gt;
     	private final ConcurrentMap&amp;lt;Thread, KvStateInfo&amp;lt;K, N, V&amp;gt;&amp;gt; serializerCache;&lt;/p&gt;

&lt;p&gt;     	public KvStateEntry(final InternalKvState&amp;lt;K, N, V&amp;gt; state) {&lt;br/&gt;
    -&lt;br/&gt;
     		this.state = Preconditions.checkNotNull(state);&lt;br/&gt;
     		this.stateInfo = new KvStateInfo&amp;lt;&amp;gt;(&lt;br/&gt;
     				state.getKeySerializer(),&lt;br/&gt;
     				state.getNamespaceSerializer(),&lt;br/&gt;
     				state.getValueSerializer()&lt;br/&gt;
     		);&lt;br/&gt;
    -&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.serializerCache =&lt;/li&gt;
	&lt;li&gt;stateInfo.duplicate() == stateInfo&lt;/li&gt;
	&lt;li&gt;? null							// if the serializers are stateless, we do not need a cache&lt;/li&gt;
	&lt;li&gt;: new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
    +		this.serializerCache = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
    +		this.isSerializerStateless = stateInfo.duplicate() == stateInfo;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -&amp;gt; areSerializersStateless?&lt;/p&gt;</comment>
                            <comment id="16398532" author="githubbot" created="Wed, 14 Mar 2018 12:49:22 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174444107&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174444107&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/query/KvStateEntry.java &amp;#8212;&lt;br/&gt;
    @@ -0,0 +1,77 @@&lt;br/&gt;
    +/*&lt;br/&gt;
    + * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
    + * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
    + * distributed with this work for additional information&lt;br/&gt;
    + * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
    + * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
    + * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
    + * with the License.  You may obtain a copy of the License at&lt;br/&gt;
    + *&lt;br/&gt;
    + *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
    + *&lt;br/&gt;
    + * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
    + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
    + * See the License for the specific language governing permissions and&lt;br/&gt;
    + * limitations under the License.&lt;br/&gt;
    + */&lt;br/&gt;
    +&lt;br/&gt;
    +package org.apache.flink.runtime.query;&lt;br/&gt;
    +&lt;br/&gt;
    +import org.apache.flink.annotation.Internal;&lt;br/&gt;
    +import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
    +import org.apache.flink.runtime.state.internal.InternalKvState;&lt;br/&gt;
    +import org.apache.flink.util.Preconditions;&lt;br/&gt;
    +&lt;br/&gt;
    +import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
    +import java.util.concurrent.ConcurrentMap;&lt;br/&gt;
    +&lt;br/&gt;
    +/**&lt;br/&gt;
    + * An entry holding the &lt;/p&gt;
{@link InternalKvState}
&lt;p&gt; along with its &lt;/p&gt;
{@link KvStateInfo}
&lt;p&gt;.&lt;br/&gt;
    + *&lt;br/&gt;
    + * @param &amp;lt;K&amp;gt;	The type of key the state is associated to&lt;br/&gt;
    + * @param &amp;lt;N&amp;gt;	The type of the namespace the state is associated to&lt;br/&gt;
    + * @param &amp;lt;V&amp;gt;	The type of values kept internally in state&lt;br/&gt;
    + */&lt;br/&gt;
    +@Internal&lt;br/&gt;
    +public class KvStateEntry&amp;lt;K, N, V&amp;gt; {&lt;br/&gt;
    +&lt;br/&gt;
    +	private final InternalKvState&amp;lt;K, N, V&amp;gt; state;&lt;br/&gt;
    +	private final KvStateInfo&amp;lt;K, N, V&amp;gt; stateInfo;&lt;br/&gt;
    +&lt;br/&gt;
    +	private final boolean isSerializerStateless;&lt;br/&gt;
    +&lt;br/&gt;
    +	private final ConcurrentMap&amp;lt;Thread, KvStateInfo&amp;lt;K, N, V&amp;gt;&amp;gt; serializerCache;&lt;br/&gt;
    +&lt;br/&gt;
    +	public KvStateEntry(final InternalKvState&amp;lt;K, N, V&amp;gt; state) &lt;/p&gt;
{
    +		this.state = Preconditions.checkNotNull(state);
    +		this.stateInfo = new KvStateInfo&amp;lt;&amp;gt;(
    +				state.getKeySerializer(),
    +				state.getNamespaceSerializer(),
    +				state.getValueSerializer()
    +		);
    +		this.serializerCache = new ConcurrentHashMap&amp;lt;&amp;gt;();
    +		this.isSerializerStateless = stateInfo.duplicate() == stateInfo;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public InternalKvState&amp;lt;K, N, V&amp;gt; getState() &lt;/p&gt;
{
    +		return state;
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public KvStateInfo&amp;lt;K, N, V&amp;gt; getInfoForCurrentThread() &lt;/p&gt;
{
    +		return isSerializerStateless
    +				? stateInfo
    +				: serializerCache.computeIfAbsent(Thread.currentThread(), t -&amp;gt; stateInfo.duplicate());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	public void clear() {&lt;br/&gt;
    +		if (serializerCache != null) &lt;/p&gt;
{
    +			serializerCache.clear();
    +		}
&lt;p&gt;    +	}&lt;br/&gt;
    +&lt;br/&gt;
    +	@VisibleForTesting&lt;br/&gt;
    +	public int getCacheSize() {&lt;br/&gt;
    +		return serializerCache == null ? -1 : serializerCache.size();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    unnecessary null check&lt;/p&gt;</comment>
                            <comment id="16398545" author="githubbot" created="Wed, 14 Mar 2018 13:01:33 +0000"  >&lt;p&gt;Github user zentol commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174450032&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174450032&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapMapState.java &amp;#8212;&lt;br/&gt;
    @@ -140,19 +159,28 @@ public boolean contains(UK userKey) {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public byte[] getSerializedValue(K key, N namespace) throws IOException {&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(namespace != null, &quot;No namespace given.&quot;);&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(key != null, &quot;No key given.&quot;);&lt;br/&gt;
    +	public byte[] getSerializedValue(&lt;br/&gt;
    +			byte[] serializedKeyAndNamespace,&lt;br/&gt;
    +			TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
    +			TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer,&lt;br/&gt;
    +			TypeSerializer&amp;lt;HashMap&amp;lt;UK, UV&amp;gt;&amp;gt; valueSerializer) throws Exception {&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;HashMap&amp;lt;UK, UV&amp;gt; result = stateTable.get(key, namespace);&lt;br/&gt;
    +		Preconditions.checkNotNull(serializedKeyAndNamespace, &quot;Serialized key and namespace&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (null == result) {&lt;br/&gt;
    +		Tuple2&amp;lt;K, N&amp;gt; keyAndNamespace = KvStateSerializer.deserializeKeyAndNamespace(&lt;br/&gt;
    +				serializedKeyAndNamespace, keySerializer, namespaceSerializer);&lt;br/&gt;
    +&lt;br/&gt;
    +		Map&amp;lt;UK, UV&amp;gt; result = stateTable.get(keyAndNamespace.f0, keyAndNamespace.f1);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (result == null) 
{
     			return null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TypeSerializer&amp;lt;UK&amp;gt; userKeySerializer = stateDesc.getKeySerializer();&lt;/li&gt;
	&lt;li&gt;TypeSerializer&amp;lt;UV&amp;gt; userValueSerializer = stateDesc.getValueSerializer();&lt;br/&gt;
    +		final HashMapSerializer&amp;lt;UK, UV&amp;gt; serializer = (HashMapSerializer&amp;lt;UK, UV&amp;gt;) valueSerializer;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    i mean why isn&apos;t the signature of `KvStateSerializer.serializeMap`:&lt;br/&gt;
    ```&lt;br/&gt;
    KvStateSerializer.serializeMap(Map&amp;lt;UK, UV&amp;gt; map, TypeSerializer&amp;lt;Map&amp;lt;UK, UV&amp;gt;&amp;gt; serializer);&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    with the following implementation:&lt;br/&gt;
    ```&lt;br/&gt;
    ...&lt;br/&gt;
    serializeMap(Map&amp;lt;UK, UV&amp;gt; map, TypeSerializer&amp;lt;Map&amp;lt;UK, UV&amp;gt;&amp;gt; serializer) {&lt;br/&gt;
    		if (map != null) &lt;/p&gt;
{
    			DataOutputSerializer dos = new DataOutputSerializer(32);
    			serializer.serialize(map, dos);
    			return dos.getCopyOfBuffer();
    		}
&lt;p&gt; else &lt;/p&gt;
{
    			return null;
    		}
&lt;p&gt;    ```&lt;/p&gt;

&lt;p&gt;    Why deal with the map key/value entries at all outside the serializer?&lt;/p&gt;</comment>
                            <comment id="16398562" author="githubbot" created="Wed, 14 Mar 2018 13:16:26 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174454169&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174454169&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapMapState.java &amp;#8212;&lt;br/&gt;
    @@ -140,19 +159,28 @@ public boolean contains(UK userKey) {&lt;br/&gt;
     	}&lt;/p&gt;

&lt;p&gt;     	@Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public byte[] getSerializedValue(K key, N namespace) throws IOException {&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(namespace != null, &quot;No namespace given.&quot;);&lt;/li&gt;
	&lt;li&gt;Preconditions.checkState(key != null, &quot;No key given.&quot;);&lt;br/&gt;
    +	public byte[] getSerializedValue(&lt;br/&gt;
    +			byte[] serializedKeyAndNamespace,&lt;br/&gt;
    +			TypeSerializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
    +			TypeSerializer&amp;lt;N&amp;gt; namespaceSerializer,&lt;br/&gt;
    +			TypeSerializer&amp;lt;HashMap&amp;lt;UK, UV&amp;gt;&amp;gt; valueSerializer) throws Exception {&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;HashMap&amp;lt;UK, UV&amp;gt; result = stateTable.get(key, namespace);&lt;br/&gt;
    +		Preconditions.checkNotNull(serializedKeyAndNamespace, &quot;Serialized key and namespace&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (null == result) {&lt;br/&gt;
    +		Tuple2&amp;lt;K, N&amp;gt; keyAndNamespace = KvStateSerializer.deserializeKeyAndNamespace(&lt;br/&gt;
    +				serializedKeyAndNamespace, keySerializer, namespaceSerializer);&lt;br/&gt;
    +&lt;br/&gt;
    +		Map&amp;lt;UK, UV&amp;gt; result = stateTable.get(keyAndNamespace.f0, keyAndNamespace.f1);&lt;br/&gt;
    +&lt;br/&gt;
    +		if (result == null) 
{
     			return null;
     		}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TypeSerializer&amp;lt;UK&amp;gt; userKeySerializer = stateDesc.getKeySerializer();&lt;/li&gt;
	&lt;li&gt;TypeSerializer&amp;lt;UV&amp;gt; userValueSerializer = stateDesc.getValueSerializer();&lt;br/&gt;
    +		final HashMapSerializer&amp;lt;UK, UV&amp;gt; serializer = (HashMapSerializer&amp;lt;UK, UV&amp;gt;) valueSerializer;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The reason is that RocksDB returns an iterator that gets lazily populated as you call next() while the serialize() of the MapSerializer expects a Map. If it were to go with your option, we would have to iterate over the map twice, once to create the map, and then to serialize it.&lt;/p&gt;</comment>
                            <comment id="16398650" author="githubbot" created="Wed, 14 Mar 2018 14:16:42 +0000"  >&lt;p&gt;Github user StefanRRichter commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r174473498&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r174473498&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/internal/InternalKvState.java &amp;#8212;&lt;br/&gt;
    @@ -70,10 +88,18 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;If no value is associated with key and namespace, &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt;&lt;/li&gt;
	&lt;li&gt;is returned.&lt;br/&gt;
     	 *&lt;br/&gt;
    +	 * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;TO IMPLEMENTERS:&amp;lt;/b&amp;gt; This method is called by multiple threads. Anything&lt;br/&gt;
    +	 * stateful (e.g. serializers) should be either duplicated or protected from undesired&lt;br/&gt;
    +	 * consequences of concurrent invocations.&lt;br/&gt;
    +	 *&lt;/li&gt;
	&lt;li&gt;@param serializedKeyAndNamespace Serialized key and namespace&lt;/li&gt;
	&lt;li&gt;@return Serialized value or &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt; if no value is associated with the key and namespace.&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@throws Exception Exceptions during serialization are forwarded&lt;br/&gt;
     	 */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;byte[] getSerializedValue(byte[] serializedKeyAndNamespace) throws Exception;&lt;br/&gt;
    +	byte[] getSerializedValue(
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I would suggest to store the serializer in a thread local variable. The current solution is a bit confusing because this interface suddenly exposes serializers and caller have to provide serialzer in the `getSerializedValue` method. In my opinion this interface does not make much sense in this way. Furthermore, the serializers are copied externally into something that looks like a custom-build thread local. I suggest having the serializers thread local in the base class and bringing this interface back to the original form. There is also only one threadpool, dedicated for queryable state that would hold the serializers and even the current solution has a dedicated cleanup method. In that place, we can just clean the thread locals.&lt;/p&gt;</comment>
                            <comment id="16399064" author="githubbot" created="Wed, 14 Mar 2018 18:33:05 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @StefanRRichter and @zentol  I will ping you when I am done with the refactoring.&lt;/p&gt;</comment>
                            <comment id="16400115" author="githubbot" created="Thu, 15 Mar 2018 09:14:08 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    This is ready for another review @StefanRRichter and @zentol &lt;/p&gt;</comment>
                            <comment id="16405713" author="githubbot" created="Tue, 20 Mar 2018 02:33:56 +0000"  >&lt;p&gt;Github user sihuazhou commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r175640731&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r175640731&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/internal/InternalQueryableKvState.java &amp;#8212;&lt;br/&gt;
    @@ -16,46 +16,42 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -package org.apache.flink.runtime.query;&lt;br/&gt;
    +package org.apache.flink.runtime.state.internal;&lt;/p&gt;

&lt;p&gt;    -import org.apache.flink.annotation.Internal;&lt;br/&gt;
     import org.apache.flink.annotation.VisibleForTesting;&lt;br/&gt;
    -import org.apache.flink.runtime.state.internal.InternalKvState;&lt;br/&gt;
    +import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
    +import org.apache.flink.runtime.query.KvStateInfo;&lt;br/&gt;
     import org.apache.flink.util.Preconditions;&lt;/p&gt;

&lt;p&gt;     import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
     import java.util.concurrent.ConcurrentMap;&lt;/p&gt;

&lt;p&gt;     /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* An entry holding the 
{@link InternalKvState}
&lt;p&gt; along with its &lt;/p&gt;
{@link KvStateInfo}
&lt;p&gt;.&lt;br/&gt;
    + * An abstract base class to be subclassed by states that are expected to be queryable.&lt;br/&gt;
    + * Its main task is to keep a &quot;thread-local&quot; copy of the different serializers (if needed).&lt;br/&gt;
      *&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@param &amp;lt;K&amp;gt;	The type of key the state is associated to&lt;/li&gt;
	&lt;li&gt;@param &amp;lt;N&amp;gt;	The type of the namespace the state is associated to&lt;/li&gt;
	&lt;li&gt;@param &amp;lt;V&amp;gt;	The type of values kept internally in state&lt;br/&gt;
      */&lt;br/&gt;
    -@Internal&lt;br/&gt;
    -public class KvStateEntry&amp;lt;K, N, V&amp;gt; {&lt;br/&gt;
    +public abstract class InternalQueryableKvState&amp;lt;K, N, V&amp;gt; implements InternalKvState&amp;lt;N&amp;gt; {&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final InternalKvState&amp;lt;K, N, V&amp;gt; state;&lt;br/&gt;
     	private final KvStateInfo&amp;lt;K, N, V&amp;gt; stateInfo;&lt;br/&gt;
    -&lt;br/&gt;
     	private final boolean areSerializersStateless;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final ConcurrentMap&amp;lt;Thread, KvStateInfo&amp;lt;K, N, V&amp;gt;&amp;gt; serializerCache;&lt;br/&gt;
    +	private final ConcurrentMap&amp;lt;Thread, KvStateInfo&amp;lt;K, N, V&amp;gt;&amp;gt; serializerCache = new ConcurrentHashMap&amp;lt;&amp;gt;(4);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    nit:  just wonder why didn&apos;t use ThreadLocal&amp;lt;KvStateInfo&amp;lt;K, N, V&amp;gt;&amp;gt; provided by JDK...&lt;/p&gt;</comment>
                            <comment id="16405813" author="githubbot" created="Tue, 20 Mar 2018 05:02:45 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    That is because cleaning up the cache is happening from another thread, other than the one &lt;br/&gt;
    accessing the serializers, and ThreadLocal does not have a clear() method that you can call&lt;br/&gt;
    from another thread and clean all the state in it. Each thread can only clean its own state.&lt;/p&gt;

&lt;p&gt;    &amp;gt; On Mar 20, 2018, at 3:34 AM, sihua zhou &amp;lt;notifications@github.com&amp;gt; wrote:&lt;br/&gt;
    &amp;gt; &lt;br/&gt;
    &amp;gt; @sihuazhou commented on this pull request.&lt;br/&gt;
    &amp;gt; &lt;br/&gt;
    &amp;gt; In flink-runtime/src/main/java/org/apache/flink/runtime/state/internal/InternalQueryableKvState.java &amp;lt;&lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r175640731&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r175640731&lt;/a&gt;&amp;gt;:&lt;br/&gt;
    &amp;gt; &lt;br/&gt;
    &amp;gt; &amp;gt;  	private final boolean areSerializersStateless;&lt;br/&gt;
    &amp;gt;  &lt;br/&gt;
    &amp;gt; -	private final ConcurrentMap&amp;lt;Thread, KvStateInfo&amp;lt;K, N, V&amp;gt;&amp;gt; serializerCache;&lt;br/&gt;
    &amp;gt; +	private final ConcurrentMap&amp;lt;Thread, KvStateInfo&amp;lt;K, N, V&amp;gt;&amp;gt; serializerCache = new ConcurrentHashMap&amp;lt;&amp;gt;(4);&lt;br/&gt;
    &amp;gt;  &lt;br/&gt;
    &amp;gt; nit: just wonder why didn&apos;t use ThreadLocal&amp;lt;KvStateInfo&amp;lt;K, N, V&amp;gt;&amp;gt; provided by JDK...&lt;br/&gt;
    &amp;gt; &lt;br/&gt;
    &amp;gt; &#8212;&lt;br/&gt;
    &amp;gt; You are receiving this because you authored the thread.&lt;br/&gt;
    &amp;gt; Reply to this email directly, view it on GitHub &amp;lt;&lt;a href=&quot;https://github.com/apache/flink/pull/5691#pullrequestreview-105202229&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#pullrequestreview-105202229&lt;/a&gt;&amp;gt;, or mute the thread &amp;lt;&lt;a href=&quot;https://github.com/notifications/unsubscribe-auth/ACS1qD3X7x51gg8CHKKLCVJ6aFuOvnthks5tgGqmgaJpZM4SopKO&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/notifications/unsubscribe-auth/ACS1qD3X7x51gg8CHKKLCVJ6aFuOvnthks5tgGqmgaJpZM4SopKO&lt;/a&gt;&amp;gt;.&lt;br/&gt;
    &amp;gt; &lt;/p&gt;

</comment>
                            <comment id="16411247" author="githubbot" created="Fri, 23 Mar 2018 11:22:37 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Can someone have a look at this? &lt;/p&gt;</comment>
                            <comment id="16419114" author="githubbot" created="Thu, 29 Mar 2018 14:47:41 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r177690430&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r177690430&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/network/KVStateRequestSerializerRocksDBTest.java &amp;#8212;&lt;br/&gt;
    @@ -124,10 +134,56 @@ public void testListSerialization() throws Exception &lt;/p&gt;
{
     			.createListState(VoidNamespaceSerializer.INSTANCE,
     				new ListStateDescriptor&amp;lt;&amp;gt;(&quot;test&quot;, LongSerializer.INSTANCE));
     
    -		KvStateRequestSerializerTest.testListSerialization(key, listState);
    +		testListSerialization(key, (RocksDBListState&amp;lt;Long, VoidNamespace, Long&amp;gt;) listState);
     		longHeapKeyedStateBackend.dispose();
     	}

&lt;p&gt;    +	/**&lt;br/&gt;
    +	 * Verifies that the serialization of a list using the given list state&lt;br/&gt;
    +	 * matches the deserialization with &lt;/p&gt;
{@link KvStateSerializer#deserializeList}
&lt;p&gt;.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param key&lt;br/&gt;
    +	 * 		key of the list state&lt;br/&gt;
    +	 * @param listState&lt;br/&gt;
    +	 * 		list state using the &lt;/p&gt;
{@link VoidNamespace}
&lt;p&gt;, must also be a &lt;/p&gt;
{@link RocksDBListState}
&lt;p&gt; instance&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @throws Exception&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	private void testListSerialization(&lt;br/&gt;
    +			final long key,&lt;br/&gt;
    +			final RocksDBListState&amp;lt;Long, VoidNamespace, Long&amp;gt; listState) throws Exception {&lt;br/&gt;
    +&lt;br/&gt;
    +		TypeSerializer&amp;lt;Long&amp;gt; valueSerializer = LongSerializer.INSTANCE;&lt;br/&gt;
    +		listState.setCurrentNamespace(VoidNamespace.INSTANCE);&lt;br/&gt;
    +&lt;br/&gt;
    +		// List&lt;br/&gt;
    +		final int numElements = 10;&lt;br/&gt;
    +&lt;br/&gt;
    +		final List&amp;lt;Long&amp;gt; expectedValues = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
    +		for (int i = 0; i &amp;lt; numElements; i++) &lt;/p&gt;
{
    +			final long value = ThreadLocalRandom.current().nextLong();
    +			expectedValues.add(value);
    +			listState.add(value);
    +		}
&lt;p&gt;    +&lt;br/&gt;
    +		final byte[] serializedKey =&lt;br/&gt;
    +				KvStateSerializer.serializeKeyAndNamespace(&lt;br/&gt;
    +						key, LongSerializer.INSTANCE,&lt;br/&gt;
    +						VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE);&lt;br/&gt;
    +&lt;br/&gt;
    +		final byte[] serializedValues = listState.getSerializedValue(serializedKey);&lt;br/&gt;
    +&lt;br/&gt;
    +		List&amp;lt;Long&amp;gt; actualValues = KvStateSerializer.deserializeList(serializedValues, valueSerializer);&lt;br/&gt;
    +		assertEquals(expectedValues, actualValues);&lt;br/&gt;
    +&lt;br/&gt;
    +		// Single value&lt;br/&gt;
    +		long expectedValue = ThreadLocalRandom.current().nextLong();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    nit: why is this using `ThreadLocalRandom`?&lt;/p&gt;</comment>
                            <comment id="16419115" author="githubbot" created="Thu, 29 Mar 2018 14:47:41 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691#discussion_r178075205&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691#discussion_r178075205&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/AbstractHeapState.java &amp;#8212;&lt;br/&gt;
    @@ -31,14 +31,13 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Base class for partitioned 
{@link State}
&lt;p&gt; implementations that are backed by a regular&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;heap hash map. The concrete implementations define how the state is checkpointed.&lt;br/&gt;
      *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @param &amp;lt;K&amp;gt; The type of the key.&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;N&amp;gt; The type of the namespace.&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;SV&amp;gt; The type of the values in the state.&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;S&amp;gt; The type of State&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;SD&amp;gt; The type of StateDescriptor for the State S&lt;br/&gt;
    + * @param &amp;lt;K&amp;gt;	The type of the key.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    All of the generic parameters seem to have a tab in them. That&apos;s why they look wonky here. Maybe should fix those.&lt;/p&gt;</comment>
                            <comment id="16419248" author="githubbot" created="Thu, 29 Mar 2018 16:01:23 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/5691&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/5691&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16419267" author="kkl0u" created="Thu, 29 Mar 2018 16:10:45 +0000"  >&lt;p&gt;Fixed on master with&#160;db8e1f09bd7dcd9f392bf987e96cddcb34665b6c&lt;/p&gt;

&lt;p&gt;and on release-1.5 with&#160;c17c3b60381b454e101d10b5b285b489775bfa71&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 33 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3qovj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>