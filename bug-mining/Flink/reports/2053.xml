<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:30:52 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-8005] Snapshotting FlinkKafkaProducer011 fails due to ClassLoader issues</title>
                <link>https://issues.apache.org/jira/browse/FLINK-8005</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;&lt;b&gt;Problem Description&lt;/b&gt;&lt;br/&gt;
Classes in the user code jar cannot be loaded by the snapshot thread&#8217;s context class loader (&lt;tt&gt;AppClassLoader&lt;/tt&gt;).&lt;br/&gt;
For example, when creating instances of &lt;tt&gt;KafkaProducer&lt;/tt&gt;, Strings are resolved to class objects by Kafka.&lt;br/&gt;
Find below an extract from &lt;tt&gt;ConfigDef.java&lt;/tt&gt;:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; CLASS:
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (value &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt;)
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; value;
    &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (value &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;)
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt;.forName(trimmed, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;, Utils.getContextOrKafkaClassLoader());
    &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ConfigException(name, value, &lt;span class=&quot;code-quote&quot;&gt;&quot;Expected a &lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt; instance or &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;name.&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;b&gt;Exception/Stacktrace&lt;/b&gt;&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;Caused by: java.lang.Exception: Could not complete snapshot 1 for operator Source: Collection Source -&amp;gt; Sink: kafka-sink-1510048188383 (1/1).
	at org.apache.flink.streaming.api.operators.AbstractStreamOperator.snapshotState(AbstractStreamOperator.java:379)
	at org.apache.flink.streaming.runtime.tasks.StreamTask$CheckpointingOperation.checkpointStreamOperator(StreamTask.java:1077)
	at org.apache.flink.streaming.runtime.tasks.StreamTask$CheckpointingOperation.executeCheckpointing(StreamTask.java:1026)
	at org.apache.flink.streaming.runtime.tasks.StreamTask.checkpointState(StreamTask.java:659)
	at org.apache.flink.streaming.runtime.tasks.StreamTask.performCheckpoint(StreamTask.java:595)
	at org.apache.flink.streaming.runtime.tasks.StreamTask.triggerCheckpoint(StreamTask.java:526)
	... 7 more
Caused by: org.apache.kafka.common.config.ConfigException: Invalid value org.apache.kafka.common.serialization.ByteArraySerializer for configuration key.serializer: Class org.apache.kafka.common.serialization.ByteArraySerializer could not be found.
	at org.apache.kafka.common.config.ConfigDef.parseType(ConfigDef.java:715)
	at org.apache.kafka.common.config.ConfigDef.parseValue(ConfigDef.java:460)
	at org.apache.kafka.common.config.ConfigDef.parse(ConfigDef.java:453)
	at org.apache.kafka.common.config.AbstractConfig.&amp;lt;init&amp;gt;(AbstractConfig.java:62)
	at org.apache.kafka.common.config.AbstractConfig.&amp;lt;init&amp;gt;(AbstractConfig.java:75)
	at org.apache.kafka.clients.producer.ProducerConfig.&amp;lt;init&amp;gt;(ProducerConfig.java:360)
	at org.apache.kafka.clients.producer.KafkaProducer.&amp;lt;init&amp;gt;(KafkaProducer.java:288)
	at org.apache.flink.streaming.connectors.kafka.internal.FlinkKafkaProducer.&amp;lt;init&amp;gt;(FlinkKafkaProducer.java:114)
	at org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer011.initProducer(FlinkKafkaProducer011.java:913)
	at org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer011.initTransactionalProducer(FlinkKafkaProducer011.java:904)
	at org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer011.createOrGetProducerFromPool(FlinkKafkaProducer011.java:637)
	at org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer011.beginTransaction(FlinkKafkaProducer011.java:613)
	at org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer011.beginTransaction(FlinkKafkaProducer011.java:94)
	at org.apache.flink.streaming.api.functions.sink.TwoPhaseCommitSinkFunction.beginTransactionInternal(TwoPhaseCommitSinkFunction.java:359)
	at org.apache.flink.streaming.api.functions.sink.TwoPhaseCommitSinkFunction.snapshotState(TwoPhaseCommitSinkFunction.java:294)
	at org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer011.snapshotState(FlinkKafkaProducer011.java:756)
	at org.apache.flink.streaming.util.functions.StreamingFunctionUtils.trySnapshotFunctionState(StreamingFunctionUtils.java:118)
	at org.apache.flink.streaming.util.functions.StreamingFunctionUtils.snapshotFunctionState(StreamingFunctionUtils.java:99)
	at org.apache.flink.streaming.api.operators.AbstractUdfStreamOperator.snapshotState(AbstractUdfStreamOperator.java:90)
	at org.apache.flink.streaming.api.operators.AbstractStreamOperator.snapshotState(AbstractStreamOperator.java:357)
	... 12 more
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;b&gt;How to reproduce&lt;/b&gt;&lt;br/&gt;
Note that the problem only appears when a job is deployed on a cluster. &lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Build Flink 1.4&lt;/li&gt;
	&lt;li&gt;Build test job &lt;a href=&quot;https://github.com/GJL/flink-kafka011-producer-test&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/GJL/flink-kafka011-producer-test&lt;/a&gt; with &lt;tt&gt;mvn -o clean install -Pbuild-jar&lt;/tt&gt;&lt;/li&gt;
	&lt;li&gt;Start job:
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;bin/flink run -c com.garyyao.StreamingJob /pathto/flink-kafka011-producer/target/flink-kafka011-producer-1.0-SNAPSHOT.jar
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;


</description>
                <environment></environment>
        <key id="13116624">FLINK-8005</key>
            <summary>Snapshotting FlinkKafkaProducer011 fails due to ClassLoader issues</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="gjy">Gary Yao</assignee>
                                    <reporter username="gjy">Gary Yao</reporter>
                        <labels>
                    </labels>
                <created>Tue, 7 Nov 2017 10:28:59 +0000</created>
                <updated>Thu, 28 Feb 2019 13:21:30 +0000</updated>
                            <resolved>Fri, 10 Nov 2017 08:27:25 +0000</resolved>
                                    <version>1.4.0</version>
                                    <fixVersion>1.4.0</fixVersion>
                                    <component>Connectors / Kafka</component>
                    <component>Runtime / State Backends</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="16243723" author="githubbot" created="Wed, 8 Nov 2017 10:58:25 +0000"  >&lt;p&gt;GitHub user GJL opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8005&quot; title=&quot;Snapshotting FlinkKafkaProducer011 fails due to ClassLoader issues&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8005&quot;&gt;&lt;del&gt;FLINK-8005&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;runtime&amp;#93;&lt;/span&gt; Set user code class loader before snapshot&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    *During checkpointing, user code may dynamically load classes from the user code&lt;br/&gt;
    jar. This is a problem if the thread invoking the snapshot callbacks does not&lt;br/&gt;
    have the user code class loader set as its context class loader. This commit&lt;br/&gt;
    makes sure that the correct class loader is set.*&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    &lt;b&gt;(for example&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*Set user code class loader in ThreadFactory of `Task#asyncCallDispatcher` *&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Clean up TaskAsyncCallTest&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This change added tests and can be verified as follows:&lt;/p&gt;

&lt;p&gt;    &lt;b&gt;(example&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;b&gt;Added unit tests to verify that context class loader is set&lt;/b&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Started job with FlinkKafkaProducer011 and verified that snapshotting works&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;The serializers: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? (*&lt;b&gt;not applicable&lt;/b&gt;* / docs / JavaDocs / not documented)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/GJL/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/GJL/flink&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8005&quot; title=&quot;Snapshotting FlinkKafkaProducer011 fails due to ClassLoader issues&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8005&quot;&gt;&lt;del&gt;FLINK-8005&lt;/del&gt;&lt;/a&gt;-2&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4980&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 07e9e4206842319884e424b3636493e4d7f8c7a4&lt;br/&gt;
Author: gyao &amp;lt;gary@data-artisans.com&amp;gt;&lt;br/&gt;
Date:   2017-11-08T10:46:45Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8005&quot; title=&quot;Snapshotting FlinkKafkaProducer011 fails due to ClassLoader issues&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8005&quot;&gt;&lt;del&gt;FLINK-8005&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;runtime&amp;#93;&lt;/span&gt; Set user code class loader before snapshot&lt;/p&gt;

&lt;p&gt;    During checkpointing, user code may dynamically load classes from the user code&lt;br/&gt;
    jar. This is a problem if the thread invoking the snapshot callbacks does not&lt;br/&gt;
    have the user code class loader set as its context class loader. This commit&lt;br/&gt;
    makes sure that the correct class loader is set.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16243733" author="githubbot" created="Wed, 8 Nov 2017 11:04:05 +0000"  >&lt;p&gt;Github user GJL commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149637566&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149637566&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -58,99 +58,119 @@&lt;br/&gt;
     import org.junit.Before;&lt;br/&gt;
     import org.junit.Test;&lt;/p&gt;

&lt;p&gt;    +import java.util.ArrayList;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
     import java.util.concurrent.Executor;&lt;/p&gt;

&lt;p&gt;    +import static org.hamcrest.Matchers.everyItem;&lt;br/&gt;
    +import static org.hamcrest.Matchers.instanceOf;&lt;br/&gt;
    +import static org.hamcrest.Matchers.isOneOf;&lt;br/&gt;
     import static org.junit.Assert.assertFalse;&lt;br/&gt;
    -import static org.junit.Assert.fail;&lt;br/&gt;
    +import static org.junit.Assert.assertThat;&lt;br/&gt;
     import static org.mockito.Matchers.any;&lt;br/&gt;
     import static org.mockito.Mockito.mock;&lt;br/&gt;
     import static org.mockito.Mockito.when;&lt;/p&gt;

&lt;p&gt;     public class TaskAsyncCallTest {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final int NUM_CALLS = 1000;&lt;br/&gt;
    +	private static int numCalls;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     	private static OneShotLatch awaitLatch;&lt;br/&gt;
     	private static OneShotLatch triggerLatch;&lt;/p&gt;

&lt;p&gt;    +	private static List&amp;lt;ClassLoader&amp;gt; classLoaders;&lt;br/&gt;
    +&lt;br/&gt;
     	@Before&lt;br/&gt;
     	public void createQueuesAndActors() &lt;/p&gt;
{
    +		numCalls = 1000;
    +
     		awaitLatch = new OneShotLatch();
     		triggerLatch = new OneShotLatch();
    +
    +		classLoaders = new ArrayList&amp;lt;&amp;gt;();
     	}


&lt;p&gt;     	// ------------------------------------------------------------------------&lt;br/&gt;
     	//  Tests &lt;br/&gt;
     	// ------------------------------------------------------------------------&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     	@Test&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public void testCheckpointCallsInOrder() {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Task task = createTask();&lt;/li&gt;
	&lt;li&gt;task.startTaskThread();&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;awaitLatch.await();&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;for (int i = 1; i &amp;lt;= NUM_CALLS; i++) 
{
    -				task.triggerCheckpointBarrier(i, 156865867234L, CheckpointOptions.forCheckpoint());
    -			}&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;triggerLatch.await();&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;assertFalse(task.isCanceledOrFailed());&lt;br/&gt;
    +	public void testCheckpointCallsInOrder() throws Exception {&lt;br/&gt;
    +		Task task = createTask(CheckpointsInOrderInvokable.class);&lt;br/&gt;
    +		task.startTaskThread();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ExecutionState currentState = task.getExecutionState();&lt;/li&gt;
	&lt;li&gt;if (currentState != ExecutionState.RUNNING &amp;amp;&amp;amp; currentState != ExecutionState.FINISHED) 
{
    -				fail(&quot;Task should be RUNNING or FINISHED, but is &quot; + currentState);
    -			}&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;task.cancelExecution();&lt;/li&gt;
	&lt;li&gt;task.getExecutingThread().join();&lt;br/&gt;
    +		awaitLatch.await();&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 1; i &amp;lt;= numCalls; i++) 
{
    +			task.triggerCheckpointBarrier(i, 156865867234L, CheckpointOptions.forCheckpoint());
     		}&lt;/li&gt;
	&lt;li&gt;catch (Exception e) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Semantics of existing tests did not change: I removed the `try-catch` and simplified the assertion:&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    if (currentState != ExecutionState.RUNNING &amp;amp;&amp;amp; currentState != ExecutionState.FINISHED) &lt;/p&gt;
{
        fail(&quot;Task should be RUNNING or FINISHED, but is &quot; + currentState);
    }

&lt;p&gt;    ```&lt;br/&gt;
    to&lt;br/&gt;
    ```&lt;br/&gt;
    assertThat(currentState, isOneOf(ExecutionState.RUNNING, ExecutionState.FINISHED));&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="16243734" author="githubbot" created="Wed, 8 Nov 2017 11:04:10 +0000"  >&lt;p&gt;Github user aljoscha commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    These changes look good! &#128077; &lt;/p&gt;

&lt;p&gt;    I&apos;ll wait for travis and then merge.&lt;/p&gt;</comment>
                            <comment id="16243736" author="githubbot" created="Wed, 8 Nov 2017 11:04:44 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149637696&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149637696&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -58,99 +58,119 @@&lt;br/&gt;
     import org.junit.Before;&lt;br/&gt;
     import org.junit.Test;&lt;/p&gt;

&lt;p&gt;    +import java.util.ArrayList;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
     import java.util.concurrent.Executor;&lt;/p&gt;

&lt;p&gt;    +import static org.hamcrest.Matchers.everyItem;&lt;br/&gt;
    +import static org.hamcrest.Matchers.instanceOf;&lt;br/&gt;
    +import static org.hamcrest.Matchers.isOneOf;&lt;br/&gt;
     import static org.junit.Assert.assertFalse;&lt;br/&gt;
    -import static org.junit.Assert.fail;&lt;br/&gt;
    +import static org.junit.Assert.assertThat;&lt;br/&gt;
     import static org.mockito.Matchers.any;&lt;br/&gt;
     import static org.mockito.Mockito.mock;&lt;br/&gt;
     import static org.mockito.Mockito.when;&lt;/p&gt;

&lt;p&gt;     public class TaskAsyncCallTest {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final int NUM_CALLS = 1000;&lt;br/&gt;
    +	private static int numCalls;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     	private static OneShotLatch awaitLatch;&lt;br/&gt;
     	private static OneShotLatch triggerLatch;&lt;/p&gt;

&lt;p&gt;    +	private static List&amp;lt;ClassLoader&amp;gt; classLoaders;&lt;br/&gt;
    +&lt;br/&gt;
     	@Before&lt;br/&gt;
     	public void createQueuesAndActors() &lt;/p&gt;
{
    +		numCalls = 1000;
    +
     		awaitLatch = new OneShotLatch();
     		triggerLatch = new OneShotLatch();
    +
    +		classLoaders = new ArrayList&amp;lt;&amp;gt;();
     	}


&lt;p&gt;     	// ------------------------------------------------------------------------&lt;br/&gt;
     	//  Tests &lt;br/&gt;
     	// ------------------------------------------------------------------------&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     	@Test&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public void testCheckpointCallsInOrder() {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Task task = createTask();&lt;/li&gt;
	&lt;li&gt;task.startTaskThread();&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;awaitLatch.await();&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;for (int i = 1; i &amp;lt;= NUM_CALLS; i++) 
{
    -				task.triggerCheckpointBarrier(i, 156865867234L, CheckpointOptions.forCheckpoint());
    -			}&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;triggerLatch.await();&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;assertFalse(task.isCanceledOrFailed());&lt;br/&gt;
    +	public void testCheckpointCallsInOrder() throws Exception {&lt;br/&gt;
    +		Task task = createTask(CheckpointsInOrderInvokable.class);&lt;br/&gt;
    +		task.startTaskThread();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ExecutionState currentState = task.getExecutionState();&lt;/li&gt;
	&lt;li&gt;if (currentState != ExecutionState.RUNNING &amp;amp;&amp;amp; currentState != ExecutionState.FINISHED) 
{
    -				fail(&quot;Task should be RUNNING or FINISHED, but is &quot; + currentState);
    -			}&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;task.cancelExecution();&lt;/li&gt;
	&lt;li&gt;task.getExecutingThread().join();&lt;br/&gt;
    +		awaitLatch.await();&lt;br/&gt;
    +&lt;br/&gt;
    +		for (int i = 1; i &amp;lt;= numCalls; i++) 
{
    +			task.triggerCheckpointBarrier(i, 156865867234L, CheckpointOptions.forCheckpoint());
     		}&lt;/li&gt;
	&lt;li&gt;catch (Exception e) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Yep, the diff on GitHub is a bit hard to read but I figured it out. &#128517; &lt;/p&gt;</comment>
                            <comment id="16243756" author="githubbot" created="Wed, 8 Nov 2017 11:21:16 +0000"  >&lt;p&gt;Github user GJL closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16244148" author="githubbot" created="Wed, 8 Nov 2017 15:28:28 +0000"  >&lt;p&gt;GitHub user GJL reopened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8005&quot; title=&quot;Snapshotting FlinkKafkaProducer011 fails due to ClassLoader issues&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8005&quot;&gt;&lt;del&gt;FLINK-8005&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;runtime&amp;#93;&lt;/span&gt; Set user code class loader before snapshot&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    *During checkpointing, user code may dynamically load classes from the user code&lt;br/&gt;
    jar. This is a problem if the thread invoking the snapshot callbacks does not&lt;br/&gt;
    have the user code class loader set as its context class loader. This commit&lt;br/&gt;
    makes sure that the correct class loader is set.*&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;b&gt;Set user code class loader in ThreadFactory of `Task#asyncCallDispatcher`&lt;/b&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Clean up TaskAsyncCallTest&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;    This change added tests and can be verified as follows:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;b&gt;Added unit tests to verify that context class loader is set&lt;/b&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Started job with FlinkKafkaProducer011 and verified that snapshotting works&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;The serializers: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: (yes / *&lt;b&gt;no&lt;/b&gt;* / don&apos;t know)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (yes / *&lt;b&gt;no&lt;/b&gt;*)&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? (*&lt;b&gt;not applicable&lt;/b&gt;* / docs / JavaDocs / not documented)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/GJL/flink&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/GJL/flink&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8005&quot; title=&quot;Snapshotting FlinkKafkaProducer011 fails due to ClassLoader issues&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8005&quot;&gt;&lt;del&gt;FLINK-8005&lt;/del&gt;&lt;/a&gt;-2&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4980&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 07e9e4206842319884e424b3636493e4d7f8c7a4&lt;br/&gt;
Author: gyao &amp;lt;gary@data-artisans.com&amp;gt;&lt;br/&gt;
Date:   2017-11-08T10:46:45Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8005&quot; title=&quot;Snapshotting FlinkKafkaProducer011 fails due to ClassLoader issues&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8005&quot;&gt;&lt;del&gt;FLINK-8005&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;runtime&amp;#93;&lt;/span&gt; Set user code class loader before snapshot&lt;/p&gt;

&lt;p&gt;    During checkpointing, user code may dynamically load classes from the user code&lt;br/&gt;
    jar. This is a problem if the thread invoking the snapshot callbacks does not&lt;br/&gt;
    have the user code class loader set as its context class loader. This commit&lt;br/&gt;
    makes sure that the correct class loader is set.&lt;/p&gt;

&lt;p&gt;commit e5c5a42deb27949b26698cf07d9ae88459805b0d&lt;br/&gt;
Author: gyao &amp;lt;gary@data-artisans.com&amp;gt;&lt;br/&gt;
Date:   2017-11-08T15:27:54Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-8005&quot; title=&quot;Snapshotting FlinkKafkaProducer011 fails due to ClassLoader issues&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-8005&quot;&gt;&lt;del&gt;FLINK-8005&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;runtime&amp;#93;&lt;/span&gt; Move tests in TaskStopTest to TaskAsyncCallTest&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16244159" author="githubbot" created="Wed, 8 Nov 2017 15:32:44 +0000"  >&lt;p&gt;Github user GJL commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149703349&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149703349&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskStopTest.java &amp;#8212;&lt;br/&gt;
    @@ -1,157 +0,0 @@&lt;br/&gt;
    -/*&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Licensed to the Apache Software Foundation (ASF) under one&lt;/li&gt;
	&lt;li&gt;* or more contributor license agreements.  See the NOTICE file&lt;/li&gt;
	&lt;li&gt;* distributed with this work for additional information&lt;/li&gt;
	&lt;li&gt;* regarding copyright ownership.  The ASF licenses this file&lt;/li&gt;
	&lt;li&gt;* to you under the Apache License, Version 2.0 (the&lt;/li&gt;
	&lt;li&gt;* &quot;License&quot;); you may not use this file except in compliance&lt;/li&gt;
	&lt;li&gt;* with the License.  You may obtain a copy of the License at&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* Unless required by applicable law or agreed to in writing, software&lt;/li&gt;
	&lt;li&gt;* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;/li&gt;
	&lt;li&gt;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;* See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;* limitations under the License.&lt;/li&gt;
	&lt;li&gt;*/&lt;br/&gt;
    -package org.apache.flink.runtime.taskmanager;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.flink.api.common.JobID;&lt;br/&gt;
    -import org.apache.flink.api.common.TaskInfo;&lt;br/&gt;
    -import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    -import org.apache.flink.runtime.blob.BlobCacheService;&lt;br/&gt;
    -import org.apache.flink.runtime.blob.PermanentBlobCache;&lt;br/&gt;
    -import org.apache.flink.runtime.blob.TransientBlobCache;&lt;br/&gt;
    -import org.apache.flink.runtime.broadcast.BroadcastVariableManager;&lt;br/&gt;
    -import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    -import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
    -import org.apache.flink.runtime.deployment.InputGateDeploymentDescriptor;&lt;br/&gt;
    -import org.apache.flink.runtime.deployment.ResultPartitionDeploymentDescriptor;&lt;br/&gt;
    -import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;&lt;br/&gt;
    -import org.apache.flink.runtime.execution.ExecutionState;&lt;br/&gt;
    -import org.apache.flink.runtime.execution.librarycache.LibraryCacheManager;&lt;br/&gt;
    -import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;&lt;br/&gt;
    -import org.apache.flink.runtime.executiongraph.JobInformation;&lt;br/&gt;
    -import org.apache.flink.runtime.executiongraph.TaskInformation;&lt;br/&gt;
    -import org.apache.flink.runtime.filecache.FileCache;&lt;br/&gt;
    -import org.apache.flink.runtime.io.disk.iomanager.IOManager;&lt;br/&gt;
    -import org.apache.flink.runtime.io.network.NetworkEnvironment;&lt;br/&gt;
    -import org.apache.flink.runtime.io.network.netty.PartitionProducerStateChecker;&lt;br/&gt;
    -import org.apache.flink.runtime.io.network.partition.ResultPartitionConsumableNotifier;&lt;br/&gt;
    -import org.apache.flink.runtime.jobgraph.JobVertexID;&lt;br/&gt;
    -import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;&lt;br/&gt;
    -import org.apache.flink.runtime.jobgraph.tasks.InputSplitProvider;&lt;br/&gt;
    -import org.apache.flink.runtime.jobgraph.tasks.StoppableTask;&lt;br/&gt;
    -import org.apache.flink.runtime.memory.MemoryManager;&lt;br/&gt;
    -import org.apache.flink.runtime.metrics.groups.TaskIOMetricGroup;&lt;br/&gt;
    -import org.apache.flink.runtime.metrics.groups.TaskMetricGroup;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.junit.Test;&lt;br/&gt;
    -import org.junit.runner.RunWith;&lt;br/&gt;
    -import org.powermock.core.classloader.annotations.PrepareForTest;&lt;br/&gt;
    -import org.powermock.modules.junit4.PowerMockRunner;&lt;br/&gt;
    -&lt;br/&gt;
    -import java.lang.reflect.Field;&lt;br/&gt;
    -import java.util.Collections;&lt;br/&gt;
    -import java.util.concurrent.Executor;&lt;br/&gt;
    -&lt;br/&gt;
    -import scala.concurrent.duration.FiniteDuration;&lt;br/&gt;
    -&lt;br/&gt;
    -import static org.mockito.Mockito.mock;&lt;br/&gt;
    -import static org.mockito.Mockito.when;&lt;br/&gt;
    -&lt;br/&gt;
    -@RunWith(PowerMockRunner.class)&lt;br/&gt;
    -@PrepareForTest(
{ TaskDeploymentDescriptor.class, JobID.class, FiniteDuration.class }
&lt;p&gt;)&lt;br/&gt;
    -public class TaskStopTest {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;private Task task;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;public void doMocking(AbstractInvokable taskMock) throws Exception 
{
    -
    -		TaskInfo taskInfoMock = mock(TaskInfo.class);
    -		when(taskInfoMock.getTaskNameWithSubtasks()).thenReturn(&quot;dummyName&quot;);
    -
    -		TaskManagerRuntimeInfo tmRuntimeInfo = mock(TaskManagerRuntimeInfo.class);
    -		when(tmRuntimeInfo.getConfiguration()).thenReturn(new Configuration());
    -
    -		TaskMetricGroup taskMetricGroup = mock(TaskMetricGroup.class);
    -		when(taskMetricGroup.getIOMetricGroup()).thenReturn(mock(TaskIOMetricGroup.class));
    -
    -		BlobCacheService blobService =
    -			new BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));
    -
    -		task = new Task(
    -			mock(JobInformation.class),
    -			new TaskInformation(
    -				new JobVertexID(),
    -				&quot;test task name&quot;,
    -				1,
    -				1,
    -				&quot;foobar&quot;,
    -				new Configuration()),
    -			mock(ExecutionAttemptID.class),
    -			mock(AllocationID.class),
    -			0,
    -			0,
    -			Collections.&amp;lt;ResultPartitionDeploymentDescriptor&amp;gt;emptyList(),
    -			Collections.&amp;lt;InputGateDeploymentDescriptor&amp;gt;emptyList(),
    -			0,
    -			mock(TaskStateSnapshot.class),
    -			mock(MemoryManager.class),
    -			mock(IOManager.class),
    -			mock(NetworkEnvironment.class),
    -			mock(BroadcastVariableManager.class),
    -			mock(TaskManagerActions.class),
    -			mock(InputSplitProvider.class),
    -			mock(CheckpointResponder.class),
    -			blobService,
    -			mock(LibraryCacheManager.class),
    -			mock(FileCache.class),
    -			tmRuntimeInfo,
    -			taskMetricGroup,
    -			mock(ResultPartitionConsumableNotifier.class),
    -			mock(PartitionProducerStateChecker.class),
    -			mock(Executor.class));
    -		Field f = task.getClass().getDeclaredField(&quot;invokable&quot;);
    -		f.setAccessible(true);
    -		f.set(task, taskMock);
    -
    -		Field f2 = task.getClass().getDeclaredField(&quot;executionState&quot;);
    -		f2.setAccessible(true);
    -		f2.set(task, ExecutionState.RUNNING);
    -	}
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test(timeout = 20000)&lt;/li&gt;
	&lt;li&gt;public void testStopExecution() throws Exception {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This only tested that stop is invoked. Should be covered by `testSetsUserCodeClassLoader`.&lt;/p&gt;</comment>
                            <comment id="16244162" author="githubbot" created="Wed, 8 Nov 2017 15:33:09 +0000"  >&lt;p&gt;Github user GJL commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149703482&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149703482&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskStopTest.java &amp;#8212;&lt;br/&gt;
    @@ -1,157 +0,0 @@&lt;br/&gt;
    -/*&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Licensed to the Apache Software Foundation (ASF) under one&lt;/li&gt;
	&lt;li&gt;* or more contributor license agreements.  See the NOTICE file&lt;/li&gt;
	&lt;li&gt;* distributed with this work for additional information&lt;/li&gt;
	&lt;li&gt;* regarding copyright ownership.  The ASF licenses this file&lt;/li&gt;
	&lt;li&gt;* to you under the Apache License, Version 2.0 (the&lt;/li&gt;
	&lt;li&gt;* &quot;License&quot;); you may not use this file except in compliance&lt;/li&gt;
	&lt;li&gt;* with the License.  You may obtain a copy of the License at&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* Unless required by applicable law or agreed to in writing, software&lt;/li&gt;
	&lt;li&gt;* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;/li&gt;
	&lt;li&gt;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;* See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;* limitations under the License.&lt;/li&gt;
	&lt;li&gt;*/&lt;br/&gt;
    -package org.apache.flink.runtime.taskmanager;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.apache.flink.api.common.JobID;&lt;br/&gt;
    -import org.apache.flink.api.common.TaskInfo;&lt;br/&gt;
    -import org.apache.flink.configuration.Configuration;&lt;br/&gt;
    -import org.apache.flink.runtime.blob.BlobCacheService;&lt;br/&gt;
    -import org.apache.flink.runtime.blob.PermanentBlobCache;&lt;br/&gt;
    -import org.apache.flink.runtime.blob.TransientBlobCache;&lt;br/&gt;
    -import org.apache.flink.runtime.broadcast.BroadcastVariableManager;&lt;br/&gt;
    -import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;&lt;br/&gt;
    -import org.apache.flink.runtime.clusterframework.types.AllocationID;&lt;br/&gt;
    -import org.apache.flink.runtime.deployment.InputGateDeploymentDescriptor;&lt;br/&gt;
    -import org.apache.flink.runtime.deployment.ResultPartitionDeploymentDescriptor;&lt;br/&gt;
    -import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;&lt;br/&gt;
    -import org.apache.flink.runtime.execution.ExecutionState;&lt;br/&gt;
    -import org.apache.flink.runtime.execution.librarycache.LibraryCacheManager;&lt;br/&gt;
    -import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;&lt;br/&gt;
    -import org.apache.flink.runtime.executiongraph.JobInformation;&lt;br/&gt;
    -import org.apache.flink.runtime.executiongraph.TaskInformation;&lt;br/&gt;
    -import org.apache.flink.runtime.filecache.FileCache;&lt;br/&gt;
    -import org.apache.flink.runtime.io.disk.iomanager.IOManager;&lt;br/&gt;
    -import org.apache.flink.runtime.io.network.NetworkEnvironment;&lt;br/&gt;
    -import org.apache.flink.runtime.io.network.netty.PartitionProducerStateChecker;&lt;br/&gt;
    -import org.apache.flink.runtime.io.network.partition.ResultPartitionConsumableNotifier;&lt;br/&gt;
    -import org.apache.flink.runtime.jobgraph.JobVertexID;&lt;br/&gt;
    -import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;&lt;br/&gt;
    -import org.apache.flink.runtime.jobgraph.tasks.InputSplitProvider;&lt;br/&gt;
    -import org.apache.flink.runtime.jobgraph.tasks.StoppableTask;&lt;br/&gt;
    -import org.apache.flink.runtime.memory.MemoryManager;&lt;br/&gt;
    -import org.apache.flink.runtime.metrics.groups.TaskIOMetricGroup;&lt;br/&gt;
    -import org.apache.flink.runtime.metrics.groups.TaskMetricGroup;&lt;br/&gt;
    -&lt;br/&gt;
    -import org.junit.Test;&lt;br/&gt;
    -import org.junit.runner.RunWith;&lt;br/&gt;
    -import org.powermock.core.classloader.annotations.PrepareForTest;&lt;br/&gt;
    -import org.powermock.modules.junit4.PowerMockRunner;&lt;br/&gt;
    -&lt;br/&gt;
    -import java.lang.reflect.Field;&lt;br/&gt;
    -import java.util.Collections;&lt;br/&gt;
    -import java.util.concurrent.Executor;&lt;br/&gt;
    -&lt;br/&gt;
    -import scala.concurrent.duration.FiniteDuration;&lt;br/&gt;
    -&lt;br/&gt;
    -import static org.mockito.Mockito.mock;&lt;br/&gt;
    -import static org.mockito.Mockito.when;&lt;br/&gt;
    -&lt;br/&gt;
    -@RunWith(PowerMockRunner.class)&lt;br/&gt;
    -@PrepareForTest(
{ TaskDeploymentDescriptor.class, JobID.class, FiniteDuration.class }
&lt;p&gt;)&lt;br/&gt;
    -public class TaskStopTest {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;private Task task;&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;public void doMocking(AbstractInvokable taskMock) throws Exception 
{
    -
    -		TaskInfo taskInfoMock = mock(TaskInfo.class);
    -		when(taskInfoMock.getTaskNameWithSubtasks()).thenReturn(&quot;dummyName&quot;);
    -
    -		TaskManagerRuntimeInfo tmRuntimeInfo = mock(TaskManagerRuntimeInfo.class);
    -		when(tmRuntimeInfo.getConfiguration()).thenReturn(new Configuration());
    -
    -		TaskMetricGroup taskMetricGroup = mock(TaskMetricGroup.class);
    -		when(taskMetricGroup.getIOMetricGroup()).thenReturn(mock(TaskIOMetricGroup.class));
    -
    -		BlobCacheService blobService =
    -			new BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class));
    -
    -		task = new Task(
    -			mock(JobInformation.class),
    -			new TaskInformation(
    -				new JobVertexID(),
    -				&quot;test task name&quot;,
    -				1,
    -				1,
    -				&quot;foobar&quot;,
    -				new Configuration()),
    -			mock(ExecutionAttemptID.class),
    -			mock(AllocationID.class),
    -			0,
    -			0,
    -			Collections.&amp;lt;ResultPartitionDeploymentDescriptor&amp;gt;emptyList(),
    -			Collections.&amp;lt;InputGateDeploymentDescriptor&amp;gt;emptyList(),
    -			0,
    -			mock(TaskStateSnapshot.class),
    -			mock(MemoryManager.class),
    -			mock(IOManager.class),
    -			mock(NetworkEnvironment.class),
    -			mock(BroadcastVariableManager.class),
    -			mock(TaskManagerActions.class),
    -			mock(InputSplitProvider.class),
    -			mock(CheckpointResponder.class),
    -			blobService,
    -			mock(LibraryCacheManager.class),
    -			mock(FileCache.class),
    -			tmRuntimeInfo,
    -			taskMetricGroup,
    -			mock(ResultPartitionConsumableNotifier.class),
    -			mock(PartitionProducerStateChecker.class),
    -			mock(Executor.class));
    -		Field f = task.getClass().getDeclaredField(&quot;invokable&quot;);
    -		f.setAccessible(true);
    -		f.set(task, taskMock);
    -
    -		Field f2 = task.getClass().getDeclaredField(&quot;executionState&quot;);
    -		f2.setAccessible(true);
    -		f2.set(task, ExecutionState.RUNNING);
    -	}
&lt;p&gt;    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test(timeout = 20000)&lt;/li&gt;
	&lt;li&gt;public void testStopExecution() throws Exception {&lt;/li&gt;
	&lt;li&gt;StoppableTestTask taskMock = new StoppableTestTask();&lt;/li&gt;
	&lt;li&gt;doMocking(taskMock);&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;task.stopExecution();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;while (!taskMock.stopCalled) 
{
    -			Thread.sleep(100);
    -		}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;@Test(expected = RuntimeException.class)&lt;/li&gt;
	&lt;li&gt;public void testStopExecutionFail() throws Exception {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This is now covered by `testThrowExceptionIfStopInvokedWithNotStoppableTask`&lt;/p&gt;</comment>
                            <comment id="16244163" author="githubbot" created="Wed, 8 Nov 2017 15:34:31 +0000"  >&lt;p&gt;Github user GJL commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149703888&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149703888&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -58,99 +59,144 @@&lt;br/&gt;
     import org.junit.Before;&lt;br/&gt;
     import org.junit.Test;&lt;/p&gt;

&lt;p&gt;    +import java.util.ArrayList;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
     import java.util.concurrent.Executor;&lt;/p&gt;

&lt;p&gt;    +import static org.hamcrest.Matchers.containsString;&lt;br/&gt;
    +import static org.hamcrest.Matchers.everyItem;&lt;br/&gt;
    +import static org.hamcrest.Matchers.greaterThanOrEqualTo;&lt;br/&gt;
    +import static org.hamcrest.Matchers.hasSize;&lt;br/&gt;
    +import static org.hamcrest.Matchers.instanceOf;&lt;br/&gt;
    +import static org.hamcrest.Matchers.isOneOf;&lt;br/&gt;
     import static org.junit.Assert.assertFalse;&lt;br/&gt;
    +import static org.junit.Assert.assertThat;&lt;br/&gt;
     import static org.junit.Assert.fail;&lt;br/&gt;
     import static org.mockito.Matchers.any;&lt;br/&gt;
     import static org.mockito.Mockito.mock;&lt;br/&gt;
     import static org.mockito.Mockito.when;&lt;/p&gt;

&lt;p&gt;     public class TaskAsyncCallTest {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final int NUM_CALLS = 1000;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +	private static int numCalls;&lt;br/&gt;
    +&lt;br/&gt;
    +	/** Triggered at the beginning of &lt;/p&gt;
{@link CheckpointsInOrderInvokable#invoke()}
&lt;p&gt;. */&lt;br/&gt;
     	private static OneShotLatch awaitLatch;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Triggered when &lt;/p&gt;
{@link CheckpointsInOrderInvokable#triggerCheckpoint(CheckpointMetaData, CheckpointOptions)}
&lt;p&gt;    +	 * was called &lt;/p&gt;
{@link #numCalls}
&lt;p&gt; times.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static OneShotLatch triggerLatch;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +	private static final List&amp;lt;ClassLoader&amp;gt; classLoaders = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
    +&lt;br/&gt;
     	@Before&lt;br/&gt;
     	public void createQueuesAndActors() &lt;/p&gt;
{
    +		numCalls = 1000;
    +
     		awaitLatch = new OneShotLatch();
     		triggerLatch = new OneShotLatch();
    +
    +		classLoaders.clear();
     	}


&lt;p&gt;     	// ------------------------------------------------------------------------&lt;br/&gt;
     	//  Tests &lt;br/&gt;
     	// ------------------------------------------------------------------------&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     	@Test&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public void testCheckpointCallsInOrder() {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Task task = createTask();&lt;br/&gt;
    +	public void testCheckpointCallsInOrder() throws Exception {&lt;br/&gt;
    +		Task task = createTask(CheckpointsInOrderInvokable.class);&lt;br/&gt;
    +		try (TaskCleaner ignored = new TaskCleaner(task)) {&lt;br/&gt;
     			task.startTaskThread();&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     			awaitLatch.await();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;for (int i = 1; i &amp;lt;= NUM_CALLS; i++) {&lt;br/&gt;
    +&lt;br/&gt;
    +			for (int i = 1; i &amp;lt;= numCalls; i++) 
{
     				task.triggerCheckpointBarrier(i, 156865867234L, CheckpointOptions.forCheckpoint());
     			}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     			triggerLatch.await();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     			assertFalse(task.isCanceledOrFailed());&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     			ExecutionState currentState = task.getExecutionState();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (currentState != ExecutionState.RUNNING &amp;amp;&amp;amp; currentState != ExecutionState.FINISHED) 
{
    -				fail(&quot;Task should be RUNNING or FINISHED, but is &quot; + currentState);
    -			}&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;task.cancelExecution();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I moved this to the `AutoCloseable` `TaskCleaner`.&lt;/p&gt;</comment>
                            <comment id="16245484" author="githubbot" created="Thu, 9 Nov 2017 10:47:11 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149926517&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149926517&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -58,99 +59,144 @@&lt;br/&gt;
     import org.junit.Before;&lt;br/&gt;
     import org.junit.Test;&lt;/p&gt;

&lt;p&gt;    +import java.util.ArrayList;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
     import java.util.concurrent.Executor;&lt;/p&gt;

&lt;p&gt;    +import static org.hamcrest.Matchers.containsString;&lt;br/&gt;
    +import static org.hamcrest.Matchers.everyItem;&lt;br/&gt;
    +import static org.hamcrest.Matchers.greaterThanOrEqualTo;&lt;br/&gt;
    +import static org.hamcrest.Matchers.hasSize;&lt;br/&gt;
    +import static org.hamcrest.Matchers.instanceOf;&lt;br/&gt;
    +import static org.hamcrest.Matchers.isOneOf;&lt;br/&gt;
     import static org.junit.Assert.assertFalse;&lt;br/&gt;
    +import static org.junit.Assert.assertThat;&lt;br/&gt;
     import static org.junit.Assert.fail;&lt;br/&gt;
     import static org.mockito.Matchers.any;&lt;br/&gt;
     import static org.mockito.Mockito.mock;&lt;br/&gt;
     import static org.mockito.Mockito.when;&lt;/p&gt;

&lt;p&gt;     public class TaskAsyncCallTest {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final int NUM_CALLS = 1000;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +	private static int numCalls;&lt;br/&gt;
    +&lt;br/&gt;
    +	/** Triggered at the beginning of &lt;/p&gt;
{@link CheckpointsInOrderInvokable#invoke()}
&lt;p&gt;. */&lt;br/&gt;
     	private static OneShotLatch awaitLatch;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Triggered when &lt;/p&gt;
{@link CheckpointsInOrderInvokable#triggerCheckpoint(CheckpointMetaData, CheckpointOptions)}
&lt;p&gt;    +	 * was called &lt;/p&gt;
{@link #numCalls}
&lt;p&gt; times.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static OneShotLatch triggerLatch;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +	private static final List&amp;lt;ClassLoader&amp;gt; classLoaders = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
    +&lt;br/&gt;
     	@Before&lt;br/&gt;
     	public void createQueuesAndActors() &lt;/p&gt;
{
    +		numCalls = 1000;
    +
     		awaitLatch = new OneShotLatch();
     		triggerLatch = new OneShotLatch();
    +
    +		classLoaders.clear();
     	}


&lt;p&gt;     	// ------------------------------------------------------------------------&lt;br/&gt;
     	//  Tests &lt;br/&gt;
     	// ------------------------------------------------------------------------&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     	@Test&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public void testCheckpointCallsInOrder() {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Task task = createTask();&lt;br/&gt;
    +	public void testCheckpointCallsInOrder() throws Exception {&lt;br/&gt;
    +		Task task = createTask(CheckpointsInOrderInvokable.class);&lt;br/&gt;
    +		try (TaskCleaner ignored = new TaskCleaner(task)) {&lt;br/&gt;
     			task.startTaskThread();&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     			awaitLatch.await();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;for (int i = 1; i &amp;lt;= NUM_CALLS; i++) {&lt;br/&gt;
    +&lt;br/&gt;
    +			for (int i = 1; i &amp;lt;= numCalls; i++) 
{
     				task.triggerCheckpointBarrier(i, 156865867234L, CheckpointOptions.forCheckpoint());
     			}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     			triggerLatch.await();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     			assertFalse(task.isCanceledOrFailed());&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     			ExecutionState currentState = task.getExecutionState();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (currentState != ExecutionState.RUNNING &amp;amp;&amp;amp; currentState != ExecutionState.FINISHED) 
{
    -				fail(&quot;Task should be RUNNING or FINISHED, but is &quot; + currentState);
    -			}&lt;br/&gt;
    -			&lt;br/&gt;
    -			task.cancelExecution();&lt;br/&gt;
    -			task.getExecutingThread().join();&lt;br/&gt;
    -		}&lt;br/&gt;
    -		catch (Exception e) {
    -			e.printStackTrace();
    -			fail(e.getMessage());
    +			assertThat(currentState, isOneOf(ExecutionState.RUNNING, ExecutionState.FINISHED));
     		}&lt;br/&gt;
     	}&lt;br/&gt;
     &lt;br/&gt;
     	@Test&lt;br/&gt;
    -	public void testMixedAsyncCallsInOrder() {&lt;br/&gt;
    -		try {&lt;br/&gt;
    -			Task task = createTask();&lt;br/&gt;
    +	public void testMixedAsyncCallsInOrder() throws Exception {&lt;br/&gt;
    +		Task task = createTask(CheckpointsInOrderInvokable.class);&lt;br/&gt;
    +		try (TaskCleaner ignored = new TaskCleaner(task)) {&lt;br/&gt;
     			task.startTaskThread();&lt;br/&gt;
     &lt;br/&gt;
     			awaitLatch.await();&lt;br/&gt;
     &lt;br/&gt;
    -			for (int i = 1; i &amp;lt;= NUM_CALLS; i++) {&lt;br/&gt;
    +			for (int i = 1; i &amp;lt;= numCalls; i++) {
     				task.triggerCheckpointBarrier(i, 156865867234L, CheckpointOptions.forCheckpoint());
     				task.notifyCheckpointComplete(i);
     			}&lt;br/&gt;
     &lt;br/&gt;
     			triggerLatch.await();&lt;br/&gt;
     &lt;br/&gt;
     			assertFalse(task.isCanceledOrFailed());&lt;br/&gt;
    +&lt;br/&gt;
     			ExecutionState currentState = task.getExecutionState();&lt;br/&gt;
    -			if (currentState != ExecutionState.RUNNING &amp;amp;&amp;amp; currentState != ExecutionState.FINISHED) {    -				fail(&quot;Task should be RUNNING or FINISHED, but is &quot; + currentState);    -			}
&lt;p&gt;    +			assertThat(currentState, isOneOf(ExecutionState.RUNNING, ExecutionState.FINISHED));&lt;br/&gt;
    +		}&lt;br/&gt;
    +	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;task.cancelExecution();&lt;/li&gt;
	&lt;li&gt;task.getExecutingThread().join();&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testThrowExceptionIfStopInvokedWithNotStoppableTask() throws Exception {&lt;br/&gt;
    +		Task task = createTask(CheckpointsInOrderInvokable.class);&lt;br/&gt;
    +		try (TaskCleaner ignored = new TaskCleaner(task)) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			task.startTaskThread();    +			awaitLatch.await();    +    +			try {
    +				task.stopExecution();
    +				fail(&quot;Expected exception not thrown&quot;);
    +			} catch (UnsupportedOperationException e) {
    +				assertThat(e.getMessage(), containsString(&quot;Stopping not supported by task&quot;));
    +			}     		}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;catch (Exception e) 
{
    -			e.printStackTrace();
    -			fail(e.getMessage());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Asserts that &lt;/p&gt;
{@link StatefulTask#triggerCheckpoint(CheckpointMetaData, CheckpointOptions)}
&lt;p&gt;,&lt;br/&gt;
    +	 * &lt;/p&gt;
{@link StatefulTask#notifyCheckpointComplete(long)}
&lt;p&gt;, and &lt;/p&gt;
{@link StoppableTask#stop()}
&lt;p&gt; are&lt;br/&gt;
    +	 * invoked by a thread whose context class loader is set to the user code class loader.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSetsUserCodeClassLoader() throws Exception {&lt;br/&gt;
    +		numCalls = 1;&lt;br/&gt;
    +&lt;br/&gt;
    +		Task task = createTask(ContextClassLoaderInterceptingInvokable.class);&lt;br/&gt;
    +		try (TaskCleaner ignored = new TaskCleaner(task)) &lt;/p&gt;
{
    +			task.startTaskThread();
    +
    +			awaitLatch.await();
    +
    +			task.triggerCheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint());
    +			task.notifyCheckpointComplete(1);
    +			task.stopExecution();
     		}
&lt;p&gt;    +&lt;br/&gt;
    +		// assert after task is canceled and executing thread is stopped to avoid race conditions&lt;br/&gt;
    +		assertThat(classLoaders, hasSize(greaterThanOrEqualTo(3)));&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Are we guaranteed that all three calls have been made at this point or could this be flaky due to race conditions?&lt;/p&gt;</comment>
                            <comment id="16245569" author="githubbot" created="Thu, 9 Nov 2017 12:36:17 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149947094&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149947094&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -254,12 +300,10 @@ else if (this.error == null) {&lt;/p&gt;

&lt;p&gt;     		@Override&lt;br/&gt;
     		public void triggerCheckpointOnBarrier(CheckpointMetaData checkpointMetaData, CheckpointOptions checkpointOptions, CheckpointMetrics checkpointMetrics) throws Exception {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;throw new UnsupportedOperationException(&quot;Should not be called&quot;);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Why was this removed?&lt;/p&gt;</comment>
                            <comment id="16245570" author="githubbot" created="Thu, 9 Nov 2017 12:36:17 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149946930&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149946930&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/DispatcherThreadFactory.java &amp;#8212;&lt;br/&gt;
    @@ -29,21 +31,41 @@&lt;br/&gt;
     	private final ThreadGroup group;&lt;/p&gt;

&lt;p&gt;     	private final String threadName;&lt;br/&gt;
    +&lt;br/&gt;
    +	private final ClassLoader classLoader;&lt;/p&gt;

&lt;p&gt;     	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Creates a new thread factory.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
    +	 *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@param group The group that the threads will be associated with.&lt;/li&gt;
	&lt;li&gt;@param threadName The name for the threads.&lt;br/&gt;
     	 */&lt;br/&gt;
     	public DispatcherThreadFactory(ThreadGroup group, String threadName) 
{
    +		this(group, threadName, null);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Creates a new thread factory.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param group The group that the threads will be associated with.&lt;br/&gt;
    +	 * @param threadName The name for the threads.&lt;br/&gt;
    +	 * @param classLoader The &lt;/p&gt;
{@link ClassLoader}
&lt;p&gt; to be set as context class loader.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public DispatcherThreadFactory(&lt;br/&gt;
    +		ThreadGroup group,&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This is a code style preference rather than an issue, but I would suggest to indent the arguments by a tab to separate them from the body of the method.&lt;/p&gt;</comment>
                            <comment id="16245571" author="githubbot" created="Thu, 9 Nov 2017 12:36:17 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149949202&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149949202&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -58,99 +59,144 @@&lt;br/&gt;
     import org.junit.Before;&lt;br/&gt;
     import org.junit.Test;&lt;/p&gt;

&lt;p&gt;    +import java.util.ArrayList;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
     import java.util.concurrent.Executor;&lt;/p&gt;

&lt;p&gt;    +import static org.hamcrest.Matchers.containsString;&lt;br/&gt;
    +import static org.hamcrest.Matchers.everyItem;&lt;br/&gt;
    +import static org.hamcrest.Matchers.greaterThanOrEqualTo;&lt;br/&gt;
    +import static org.hamcrest.Matchers.hasSize;&lt;br/&gt;
    +import static org.hamcrest.Matchers.instanceOf;&lt;br/&gt;
    +import static org.hamcrest.Matchers.isOneOf;&lt;br/&gt;
     import static org.junit.Assert.assertFalse;&lt;br/&gt;
    +import static org.junit.Assert.assertThat;&lt;br/&gt;
     import static org.junit.Assert.fail;&lt;br/&gt;
     import static org.mockito.Matchers.any;&lt;br/&gt;
     import static org.mockito.Mockito.mock;&lt;br/&gt;
     import static org.mockito.Mockito.when;&lt;/p&gt;

&lt;p&gt;     public class TaskAsyncCallTest {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final int NUM_CALLS = 1000;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +	private static int numCalls;&lt;br/&gt;
    +&lt;br/&gt;
    +	/** Triggered at the beginning of &lt;/p&gt;
{@link CheckpointsInOrderInvokable#invoke()}
&lt;p&gt;. */&lt;br/&gt;
     	private static OneShotLatch awaitLatch;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Triggered when &lt;/p&gt;
{@link CheckpointsInOrderInvokable#triggerCheckpoint(CheckpointMetaData, CheckpointOptions)}
&lt;p&gt;    +	 * was called &lt;/p&gt;
{@link #numCalls}
&lt;p&gt; times.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static OneShotLatch triggerLatch;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +	private static final List&amp;lt;ClassLoader&amp;gt; classLoaders = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
    +&lt;br/&gt;
     	@Before&lt;br/&gt;
     	public void createQueuesAndActors() &lt;/p&gt;
{
    +		numCalls = 1000;
    +
     		awaitLatch = new OneShotLatch();
     		triggerLatch = new OneShotLatch();
    +
    +		classLoaders.clear();
     	}


&lt;p&gt;     	// ------------------------------------------------------------------------&lt;br/&gt;
     	//  Tests &lt;br/&gt;
     	// ------------------------------------------------------------------------&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     	@Test&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public void testCheckpointCallsInOrder() {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Task task = createTask();&lt;br/&gt;
    +	public void testCheckpointCallsInOrder() throws Exception {&lt;br/&gt;
    +		Task task = createTask(CheckpointsInOrderInvokable.class);&lt;br/&gt;
    +		try (TaskCleaner ignored = new TaskCleaner(task)) {&lt;br/&gt;
     			task.startTaskThread();&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     			awaitLatch.await();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;for (int i = 1; i &amp;lt;= NUM_CALLS; i++) {&lt;br/&gt;
    +&lt;br/&gt;
    +			for (int i = 1; i &amp;lt;= numCalls; i++) 
{
     				task.triggerCheckpointBarrier(i, 156865867234L, CheckpointOptions.forCheckpoint());
     			}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     			triggerLatch.await();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     			assertFalse(task.isCanceledOrFailed());&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     			ExecutionState currentState = task.getExecutionState();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (currentState != ExecutionState.RUNNING &amp;amp;&amp;amp; currentState != ExecutionState.FINISHED) 
{
    -				fail(&quot;Task should be RUNNING or FINISHED, but is &quot; + currentState);
    -			}&lt;br/&gt;
    -			&lt;br/&gt;
    -			task.cancelExecution();&lt;br/&gt;
    -			task.getExecutingThread().join();&lt;br/&gt;
    -		}&lt;br/&gt;
    -		catch (Exception e) {
    -			e.printStackTrace();
    -			fail(e.getMessage());
    +			assertThat(currentState, isOneOf(ExecutionState.RUNNING, ExecutionState.FINISHED));
     		}&lt;br/&gt;
     	}&lt;br/&gt;
     &lt;br/&gt;
     	@Test&lt;br/&gt;
    -	public void testMixedAsyncCallsInOrder() {&lt;br/&gt;
    -		try {&lt;br/&gt;
    -			Task task = createTask();&lt;br/&gt;
    +	public void testMixedAsyncCallsInOrder() throws Exception {&lt;br/&gt;
    +		Task task = createTask(CheckpointsInOrderInvokable.class);&lt;br/&gt;
    +		try (TaskCleaner ignored = new TaskCleaner(task)) {&lt;br/&gt;
     			task.startTaskThread();&lt;br/&gt;
     &lt;br/&gt;
     			awaitLatch.await();&lt;br/&gt;
     &lt;br/&gt;
    -			for (int i = 1; i &amp;lt;= NUM_CALLS; i++) {&lt;br/&gt;
    +			for (int i = 1; i &amp;lt;= numCalls; i++) {
     				task.triggerCheckpointBarrier(i, 156865867234L, CheckpointOptions.forCheckpoint());
     				task.notifyCheckpointComplete(i);
     			}&lt;br/&gt;
     &lt;br/&gt;
     			triggerLatch.await();&lt;br/&gt;
     &lt;br/&gt;
     			assertFalse(task.isCanceledOrFailed());&lt;br/&gt;
    +&lt;br/&gt;
     			ExecutionState currentState = task.getExecutionState();&lt;br/&gt;
    -			if (currentState != ExecutionState.RUNNING &amp;amp;&amp;amp; currentState != ExecutionState.FINISHED) {    -				fail(&quot;Task should be RUNNING or FINISHED, but is &quot; + currentState);    -			}
&lt;p&gt;    +			assertThat(currentState, isOneOf(ExecutionState.RUNNING, ExecutionState.FINISHED));&lt;br/&gt;
    +		}&lt;br/&gt;
    +	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;task.cancelExecution();&lt;/li&gt;
	&lt;li&gt;task.getExecutingThread().join();&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testThrowExceptionIfStopInvokedWithNotStoppableTask() throws Exception {&lt;br/&gt;
    +		Task task = createTask(CheckpointsInOrderInvokable.class);&lt;br/&gt;
    +		try (TaskCleaner ignored = new TaskCleaner(task)) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			task.startTaskThread();    +			awaitLatch.await();    +    +			try {
    +				task.stopExecution();
    +				fail(&quot;Expected exception not thrown&quot;);
    +			} catch (UnsupportedOperationException e) {
    +				assertThat(e.getMessage(), containsString(&quot;Stopping not supported by task&quot;));
    +			}     		}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;catch (Exception e) 
{
    -			e.printStackTrace();
    -			fail(e.getMessage());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Asserts that &lt;/p&gt;
{@link StatefulTask#triggerCheckpoint(CheckpointMetaData, CheckpointOptions)}
&lt;p&gt;,&lt;br/&gt;
    +	 * &lt;/p&gt;
{@link StatefulTask#notifyCheckpointComplete(long)}
&lt;p&gt;, and &lt;/p&gt;
{@link StoppableTask#stop()}
&lt;p&gt; are&lt;br/&gt;
    +	 * invoked by a thread whose context class loader is set to the user code class loader.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSetsUserCodeClassLoader() throws Exception {&lt;br/&gt;
    +		numCalls = 1;&lt;br/&gt;
    +&lt;br/&gt;
    +		Task task = createTask(ContextClassLoaderInterceptingInvokable.class);&lt;br/&gt;
    +		try (TaskCleaner ignored = new TaskCleaner(task)) &lt;/p&gt;
{
    +			task.startTaskThread();
    +
    +			awaitLatch.await();
    +
    +			task.triggerCheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint());
    +			task.notifyCheckpointComplete(1);
    +			task.stopExecution();
     		}
&lt;p&gt;    +&lt;br/&gt;
    +		// assert after task is canceled and executing thread is stopped to avoid race conditions&lt;br/&gt;
    +		assertThat(classLoaders, hasSize(greaterThanOrEqualTo(3)));&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    As @aljoscha suggested, I think that there is no guarantee that the 3 calls have finished by the time we check, right?&lt;/p&gt;</comment>
                            <comment id="16245572" author="githubbot" created="Thu, 9 Nov 2017 12:36:17 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149947069&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149947069&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -254,12 +300,10 @@ else if (this.error == null) {&lt;/p&gt;

&lt;p&gt;     		@Override&lt;br/&gt;
     		public void triggerCheckpointOnBarrier(CheckpointMetaData checkpointMetaData, CheckpointOptions checkpointOptions, CheckpointMetrics checkpointMetrics) throws Exception &lt;/p&gt;
{
    -			throw new UnsupportedOperationException(&quot;Should not be called&quot;);
     		}

&lt;p&gt;     		@Override&lt;br/&gt;
     		public void abortCheckpointOnBarrier(long checkpointId, Throwable cause) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;throw new UnsupportedOperationException(&quot;Should not be called&quot;);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Why was this removed?&lt;/p&gt;</comment>
                            <comment id="16245592" author="githubbot" created="Thu, 9 Nov 2017 13:02:06 +0000"  >&lt;p&gt;Github user GJL commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149954576&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149954576&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -58,99 +59,144 @@&lt;br/&gt;
     import org.junit.Before;&lt;br/&gt;
     import org.junit.Test;&lt;/p&gt;

&lt;p&gt;    +import java.util.ArrayList;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
    +import java.util.List;&lt;br/&gt;
     import java.util.concurrent.Executor;&lt;/p&gt;

&lt;p&gt;    +import static org.hamcrest.Matchers.containsString;&lt;br/&gt;
    +import static org.hamcrest.Matchers.everyItem;&lt;br/&gt;
    +import static org.hamcrest.Matchers.greaterThanOrEqualTo;&lt;br/&gt;
    +import static org.hamcrest.Matchers.hasSize;&lt;br/&gt;
    +import static org.hamcrest.Matchers.instanceOf;&lt;br/&gt;
    +import static org.hamcrest.Matchers.isOneOf;&lt;br/&gt;
     import static org.junit.Assert.assertFalse;&lt;br/&gt;
    +import static org.junit.Assert.assertThat;&lt;br/&gt;
     import static org.junit.Assert.fail;&lt;br/&gt;
     import static org.mockito.Matchers.any;&lt;br/&gt;
     import static org.mockito.Mockito.mock;&lt;br/&gt;
     import static org.mockito.Mockito.when;&lt;/p&gt;

&lt;p&gt;     public class TaskAsyncCallTest {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final int NUM_CALLS = 1000;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +	private static int numCalls;&lt;br/&gt;
    +&lt;br/&gt;
    +	/** Triggered at the beginning of &lt;/p&gt;
{@link CheckpointsInOrderInvokable#invoke()}
&lt;p&gt;. */&lt;br/&gt;
     	private static OneShotLatch awaitLatch;&lt;br/&gt;
    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Triggered when &lt;/p&gt;
{@link CheckpointsInOrderInvokable#triggerCheckpoint(CheckpointMetaData, CheckpointOptions)}
&lt;p&gt;    +	 * was called &lt;/p&gt;
{@link #numCalls}
&lt;p&gt; times.&lt;br/&gt;
    +	 */&lt;br/&gt;
     	private static OneShotLatch triggerLatch;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +	private static final List&amp;lt;ClassLoader&amp;gt; classLoaders = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
    +&lt;br/&gt;
     	@Before&lt;br/&gt;
     	public void createQueuesAndActors() &lt;/p&gt;
{
    +		numCalls = 1000;
    +
     		awaitLatch = new OneShotLatch();
     		triggerLatch = new OneShotLatch();
    +
    +		classLoaders.clear();
     	}


&lt;p&gt;     	// ------------------------------------------------------------------------&lt;br/&gt;
     	//  Tests &lt;br/&gt;
     	// ------------------------------------------------------------------------&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     	@Test&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public void testCheckpointCallsInOrder() {&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Task task = createTask();&lt;br/&gt;
    +	public void testCheckpointCallsInOrder() throws Exception {&lt;br/&gt;
    +		Task task = createTask(CheckpointsInOrderInvokable.class);&lt;br/&gt;
    +		try (TaskCleaner ignored = new TaskCleaner(task)) {&lt;br/&gt;
     			task.startTaskThread();&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     			awaitLatch.await();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;for (int i = 1; i &amp;lt;= NUM_CALLS; i++) {&lt;br/&gt;
    +&lt;br/&gt;
    +			for (int i = 1; i &amp;lt;= numCalls; i++) 
{
     				task.triggerCheckpointBarrier(i, 156865867234L, CheckpointOptions.forCheckpoint());
     			}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     			triggerLatch.await();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
     			assertFalse(task.isCanceledOrFailed());&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     			ExecutionState currentState = task.getExecutionState();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (currentState != ExecutionState.RUNNING &amp;amp;&amp;amp; currentState != ExecutionState.FINISHED) 
{
    -				fail(&quot;Task should be RUNNING or FINISHED, but is &quot; + currentState);
    -			}&lt;br/&gt;
    -			&lt;br/&gt;
    -			task.cancelExecution();&lt;br/&gt;
    -			task.getExecutingThread().join();&lt;br/&gt;
    -		}&lt;br/&gt;
    -		catch (Exception e) {
    -			e.printStackTrace();
    -			fail(e.getMessage());
    +			assertThat(currentState, isOneOf(ExecutionState.RUNNING, ExecutionState.FINISHED));
     		}&lt;br/&gt;
     	}&lt;br/&gt;
     &lt;br/&gt;
     	@Test&lt;br/&gt;
    -	public void testMixedAsyncCallsInOrder() {&lt;br/&gt;
    -		try {&lt;br/&gt;
    -			Task task = createTask();&lt;br/&gt;
    +	public void testMixedAsyncCallsInOrder() throws Exception {&lt;br/&gt;
    +		Task task = createTask(CheckpointsInOrderInvokable.class);&lt;br/&gt;
    +		try (TaskCleaner ignored = new TaskCleaner(task)) {&lt;br/&gt;
     			task.startTaskThread();&lt;br/&gt;
     &lt;br/&gt;
     			awaitLatch.await();&lt;br/&gt;
     &lt;br/&gt;
    -			for (int i = 1; i &amp;lt;= NUM_CALLS; i++) {&lt;br/&gt;
    +			for (int i = 1; i &amp;lt;= numCalls; i++) {
     				task.triggerCheckpointBarrier(i, 156865867234L, CheckpointOptions.forCheckpoint());
     				task.notifyCheckpointComplete(i);
     			}&lt;br/&gt;
     &lt;br/&gt;
     			triggerLatch.await();&lt;br/&gt;
     &lt;br/&gt;
     			assertFalse(task.isCanceledOrFailed());&lt;br/&gt;
    +&lt;br/&gt;
     			ExecutionState currentState = task.getExecutionState();&lt;br/&gt;
    -			if (currentState != ExecutionState.RUNNING &amp;amp;&amp;amp; currentState != ExecutionState.FINISHED) {    -				fail(&quot;Task should be RUNNING or FINISHED, but is &quot; + currentState);    -			}
&lt;p&gt;    +			assertThat(currentState, isOneOf(ExecutionState.RUNNING, ExecutionState.FINISHED));&lt;br/&gt;
    +		}&lt;br/&gt;
    +	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;task.cancelExecution();&lt;/li&gt;
	&lt;li&gt;task.getExecutingThread().join();&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testThrowExceptionIfStopInvokedWithNotStoppableTask() throws Exception {&lt;br/&gt;
    +		Task task = createTask(CheckpointsInOrderInvokable.class);&lt;br/&gt;
    +		try (TaskCleaner ignored = new TaskCleaner(task)) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +			task.startTaskThread();    +			awaitLatch.await();    +    +			try {
    +				task.stopExecution();
    +				fail(&quot;Expected exception not thrown&quot;);
    +			} catch (UnsupportedOperationException e) {
    +				assertThat(e.getMessage(), containsString(&quot;Stopping not supported by task&quot;));
    +			}     		}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;catch (Exception e) 
{
    -			e.printStackTrace();
    -			fail(e.getMessage());
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Asserts that &lt;/p&gt;
{@link StatefulTask#triggerCheckpoint(CheckpointMetaData, CheckpointOptions)}
&lt;p&gt;,&lt;br/&gt;
    +	 * &lt;/p&gt;
{@link StatefulTask#notifyCheckpointComplete(long)}
&lt;p&gt;, and &lt;/p&gt;
{@link StoppableTask#stop()}
&lt;p&gt; are&lt;br/&gt;
    +	 * invoked by a thread whose context class loader is set to the user code class loader.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	@Test&lt;br/&gt;
    +	public void testSetsUserCodeClassLoader() throws Exception {&lt;br/&gt;
    +		numCalls = 1;&lt;br/&gt;
    +&lt;br/&gt;
    +		Task task = createTask(ContextClassLoaderInterceptingInvokable.class);&lt;br/&gt;
    +		try (TaskCleaner ignored = new TaskCleaner(task)) &lt;/p&gt;
{
    +			task.startTaskThread();
    +
    +			awaitLatch.await();
    +
    +			task.triggerCheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint());
    +			task.notifyCheckpointComplete(1);
    +			task.stopExecution();
     		}
&lt;p&gt;    +&lt;br/&gt;
    +		// assert after task is canceled and executing thread is stopped to avoid race conditions&lt;br/&gt;
    +		assertThat(classLoaders, hasSize(greaterThanOrEqualTo(3)));&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I believe you are right. I introduced another latch to counter this.&lt;/p&gt;</comment>
                            <comment id="16245593" author="githubbot" created="Thu, 9 Nov 2017 13:02:15 +0000"  >&lt;p&gt;Github user GJL commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149954606&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149954606&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/DispatcherThreadFactory.java &amp;#8212;&lt;br/&gt;
    @@ -29,21 +31,41 @@&lt;br/&gt;
     	private final ThreadGroup group;&lt;/p&gt;

&lt;p&gt;     	private final String threadName;&lt;br/&gt;
    +&lt;br/&gt;
    +	private final ClassLoader classLoader;&lt;/p&gt;

&lt;p&gt;     	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Creates a new thread factory.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
    +	 *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@param group The group that the threads will be associated with.&lt;/li&gt;
	&lt;li&gt;@param threadName The name for the threads.&lt;br/&gt;
     	 */&lt;br/&gt;
     	public DispatcherThreadFactory(ThreadGroup group, String threadName) 
{
    +		this(group, threadName, null);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +	/**&lt;br/&gt;
    +	 * Creates a new thread factory.&lt;br/&gt;
    +	 *&lt;br/&gt;
    +	 * @param group The group that the threads will be associated with.&lt;br/&gt;
    +	 * @param threadName The name for the threads.&lt;br/&gt;
    +	 * @param classLoader The &lt;/p&gt;
{@link ClassLoader}
&lt;p&gt; to be set as context class loader.&lt;br/&gt;
    +	 */&lt;br/&gt;
    +	public DispatcherThreadFactory(&lt;br/&gt;
    +		ThreadGroup group,&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Indented.&lt;/p&gt;</comment>
                            <comment id="16245596" author="githubbot" created="Thu, 9 Nov 2017 13:03:07 +0000"  >&lt;p&gt;Github user GJL commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149954849&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149954849&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -254,12 +300,10 @@ else if (this.error == null) {&lt;/p&gt;

&lt;p&gt;     		@Override&lt;br/&gt;
     		public void triggerCheckpointOnBarrier(CheckpointMetaData checkpointMetaData, CheckpointOptions checkpointOptions, CheckpointMetrics checkpointMetrics) throws Exception {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;throw new UnsupportedOperationException(&quot;Should not be called&quot;);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Not sure but I decided to add it again.&lt;/p&gt;</comment>
                            <comment id="16245597" author="githubbot" created="Thu, 9 Nov 2017 13:04:08 +0000"  >&lt;p&gt;Github user GJL commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149955008&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149955008&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -254,12 +300,10 @@ else if (this.error == null) {&lt;/p&gt;

&lt;p&gt;     		@Override&lt;br/&gt;
     		public void triggerCheckpointOnBarrier(CheckpointMetaData checkpointMetaData, CheckpointOptions checkpointOptions, CheckpointMetrics checkpointMetrics) throws Exception &lt;/p&gt;
{
    -			throw new UnsupportedOperationException(&quot;Should not be called&quot;);
     		}

&lt;p&gt;     		@Override&lt;br/&gt;
     		public void abortCheckpointOnBarrier(long checkpointId, Throwable cause) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;throw new UnsupportedOperationException(&quot;Should not be called&quot;);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Not sure anymore but I decided to add it again.&lt;/p&gt;</comment>
                            <comment id="16245600" author="githubbot" created="Thu, 9 Nov 2017 13:08:40 +0000"  >&lt;p&gt;Github user GJL commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I addressed the comments. Let&apos;s wait for Travis and let me know if something else needs to be changed. &lt;/p&gt;

&lt;p&gt;    @aljoscha  @kl0u &lt;/p&gt;</comment>
                            <comment id="16245623" author="githubbot" created="Thu, 9 Nov 2017 13:21:01 +0000"  >&lt;p&gt;Github user aljoscha commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I think waiting on the stop latch might not be enough (in 100 % of cases) because the other two calls are also asynchronous.&lt;/p&gt;</comment>
                            <comment id="16245630" author="githubbot" created="Thu, 9 Nov 2017 13:25:22 +0000"  >&lt;p&gt;Github user GJL commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    There is only one thread dispatching the calls:&lt;br/&gt;
    ```&lt;br/&gt;
    executor = Executors.newSingleThreadExecutor(&lt;br/&gt;
    						new DispatcherThreadFactory(TASK_THREADS_GROUP, &quot;Async calls on &quot; + taskNameWithSubtask));&lt;br/&gt;
    				this.asyncCallDispatcher = executor;&lt;br/&gt;
    ```&lt;/p&gt;

&lt;p&gt;    The tasks cannot overtake each other. I could make the test more strict and wait additionally on `triggerLatch` in case somebody decides to have multiple threads.&lt;/p&gt;</comment>
                            <comment id="16245681" author="githubbot" created="Thu, 9 Nov 2017 13:56:39 +0000"  >&lt;p&gt;Github user aljoscha commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Yes, but I think this is making an assumption about the internal implementation. If someone changes that the test could break/not test the right thing anymore.&lt;/p&gt;</comment>
                            <comment id="16245765" author="githubbot" created="Thu, 9 Nov 2017 14:53:00 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149982812&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149982812&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -277,8 +287,12 @@ public void invoke() throws Exception {&lt;br/&gt;
     				}&lt;br/&gt;
     			}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;triggerLatch.trigger();&lt;br/&gt;
     			if (error != null) {&lt;br/&gt;
    +				// exit method prematurely due to error but make sure that the tests can finish&lt;br/&gt;
    +				triggerLatch.trigger();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    for all latches, it should also have:`if (!latch.isTriggered()) &lt;/p&gt;
{ latch.await() }
&lt;p&gt;`&lt;/p&gt;</comment>
                            <comment id="16245773" author="githubbot" created="Thu, 9 Nov 2017 14:56:43 +0000"  >&lt;p&gt;Github user GJL commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149983878&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149983878&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -277,8 +287,12 @@ public void invoke() throws Exception {&lt;br/&gt;
     				}&lt;br/&gt;
     			}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;triggerLatch.trigger();&lt;br/&gt;
     			if (error != null) {&lt;br/&gt;
    +				// exit method prematurely due to error but make sure that the tests can finish&lt;br/&gt;
    +				triggerLatch.trigger();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Why is that? I think at this point the latch might not get triggered at all.&lt;/p&gt;</comment>
                            <comment id="16245776" author="githubbot" created="Thu, 9 Nov 2017 14:58:41 +0000"  >&lt;p&gt;Github user kl0u commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149984491&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149984491&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -277,8 +287,12 @@ public void invoke() throws Exception {&lt;br/&gt;
     				}&lt;br/&gt;
     			}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;triggerLatch.trigger();&lt;br/&gt;
     			if (error != null) {&lt;br/&gt;
    +				// exit method prematurely due to error but make sure that the tests can finish&lt;br/&gt;
    +				triggerLatch.trigger();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Sorry, I was just looking on the IDE and missed the lines. This line should be before every time you call `await` on the `latch`.&lt;/p&gt;</comment>
                            <comment id="16245781" author="githubbot" created="Thu, 9 Nov 2017 15:00:27 +0000"  >&lt;p&gt;Github user GJL commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149985097&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149985097&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -277,8 +287,12 @@ public void invoke() throws Exception {&lt;br/&gt;
     				}&lt;br/&gt;
     			}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;triggerLatch.trigger();&lt;br/&gt;
     			if (error != null) {&lt;br/&gt;
    +				// exit method prematurely due to error but make sure that the tests can finish&lt;br/&gt;
    +				triggerLatch.trigger();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I think it doesn&apos;t matter because the latch already checks for the flag.&lt;br/&gt;
    ```&lt;br/&gt;
    	public void await() throws InterruptedException {&lt;br/&gt;
    		synchronized (lock) {&lt;br/&gt;
    			while (!triggered) &lt;/p&gt;
{
    				lock.wait();
    			}
&lt;p&gt;    		}&lt;br/&gt;
    	}&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="16245825" author="githubbot" created="Thu, 9 Nov 2017 15:27:51 +0000"  >&lt;p&gt;Github user aljoscha commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980#discussion_r149993559&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980#discussion_r149993559&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskAsyncCallTest.java &amp;#8212;&lt;br/&gt;
    @@ -277,8 +287,12 @@ public void invoke() throws Exception {&lt;br/&gt;
     				}&lt;br/&gt;
     			}&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;triggerLatch.trigger();&lt;br/&gt;
     			if (error != null) {&lt;br/&gt;
    +				// exit method prematurely due to error but make sure that the tests can finish&lt;br/&gt;
    +				triggerLatch.trigger();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    yes, a latch that was already triggered will simply return immediately, no need for an additional check&lt;/p&gt;
</comment>
                            <comment id="16245867" author="githubbot" created="Thu, 9 Nov 2017 15:44:56 +0000"  >&lt;p&gt;Github user aljoscha commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    thanks, I think this is excellent now. &#128076; &lt;/p&gt;

&lt;p&gt;    I&apos;ll merge as soon as travis is green.&lt;/p&gt;</comment>
                            <comment id="16245879" author="githubbot" created="Thu, 9 Nov 2017 15:53:18 +0000"  >&lt;p&gt;Github user kl0u commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I agree! +1 to merge as soon as Travis gives us the green light.&lt;/p&gt;</comment>
                            <comment id="16247190" author="aljoscha" created="Fri, 10 Nov 2017 08:27:25 +0000"  >&lt;p&gt;Fixed on release-1.4 in&lt;br/&gt;
2117eb77bb9d34da4288b5dd4455ef06c583ce7c&lt;/p&gt;

&lt;p&gt;Fixed on master in&lt;br/&gt;
de58523b5cfb5e2e4210c4d4ee7cbdf459398afd&lt;/p&gt;</comment>
                            <comment id="16247191" author="githubbot" created="Fri, 10 Nov 2017 08:27:53 +0000"  >&lt;p&gt;Github user aljoscha commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks again for this fix! &#128077; &lt;/p&gt;

&lt;p&gt;    Could you please close if GitHub doesn&apos;t auto-close?&lt;/p&gt;</comment>
                            <comment id="16247253" author="githubbot" created="Fri, 10 Nov 2017 09:15:48 +0000"  >&lt;p&gt;Github user GJL closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/flink/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/4980&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 1 week, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3mhdz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>