<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 20:35:04 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[FLINK-10157] Allow `null` user values in map state with TTL</title>
                <link>https://issues.apache.org/jira/browse/FLINK-10157</link>
                <project id="12315522" key="FLINK">Flink</project>
                    <description>&lt;p&gt;Thanks for the StateTtl feature,this is exactly what I need now! But I found an issue.&lt;/p&gt;

&lt;p&gt;In the previous version or when StateTtl is not enabled,MapState allows `null` value,that means after&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
mapState.put(&lt;span class=&quot;code-quote&quot;&gt;&quot;key&quot;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;, then&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
mapState.contains(&lt;span class=&quot;code-quote&quot;&gt;&quot;key&quot;&lt;/span&gt;)&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;will return &lt;font color=&quot;#ff0000&quot;&gt;&lt;b&gt;true&lt;/b&gt;&lt;/font&gt;, but when StateTtl is enabled,&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
mapState.contains(&lt;span class=&quot;code-quote&quot;&gt;&quot;key&quot;&lt;/span&gt;)&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;will return &lt;font color=&quot;#ff0000&quot;&gt;&lt;b&gt;false&lt;/b&gt;&lt;/font&gt;(&lt;b&gt;the&#160;key has not expired&lt;/b&gt;).&lt;br/&gt;
 So I think the field `userValue` in `org.apache.flink.runtime.state.ttl.TtlValue` should allow `null` value. User state is null may not means the TtlValue should&#160;be&#160;null.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
/**
 * This &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;wraps user value of state with TTL.
 *
 * @param &amp;lt;T&amp;gt; Type of the user value of state with TTL
 */
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;TtlValue&amp;lt;T&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Serializable {
 &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; T userValue;
 &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; lastAccessTimestamp;
TtlValue(T userValue, &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; lastAccessTimestamp) {
 Preconditions.checkNotNull(userValue);
 &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.userValue = userValue;
 &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.lastAccessTimestamp = lastAccessTimestamp;
 }
T getUserValue() {
 &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; userValue;
 }
&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; getLastAccessTimestamp() {
 &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; lastAccessTimestamp;
 }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Am I understanding right?&lt;/p&gt;

&lt;p&gt;This is my test class.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12935823/12935823_StateWithTtlTest.scala&quot; title=&quot;StateWithTtlTest.scala attached to FLINK-10157&quot;&gt;StateWithTtlTest.scala&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;&#160;&lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12935822/12935822_StateWithOutTtlTest.scala&quot; title=&quot;StateWithOutTtlTest.scala attached to FLINK-10157&quot;&gt;StateWithOutTtlTest.scala&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;Thanks!&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/p&gt;</description>
                <environment>&lt;p&gt;Flink:1.6.0&lt;/p&gt;

&lt;p&gt;Scala:2.11&lt;/p&gt;

&lt;p&gt;JDK:1.8&lt;/p&gt;</environment>
        <key id="13179289">FLINK-10157</key>
            <summary>Allow `null` user values in map state with TTL</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="azagrebin">Andrey Zagrebin</assignee>
                                    <reporter username="wucj">chengjie.wu</reporter>
                        <labels>
                            <label>pull-request-available</label>
                    </labels>
                <created>Thu, 16 Aug 2018 08:00:16 +0000</created>
                <updated>Fri, 21 Sep 2018 13:35:18 +0000</updated>
                            <resolved>Fri, 21 Sep 2018 13:35:18 +0000</resolved>
                                    <version>1.6.0</version>
                                    <fixVersion>1.6.2</fixVersion>
                    <fixVersion>1.7.0</fixVersion>
                                    <component>Runtime / State Backends</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="16582152" author="wucj" created="Thu, 16 Aug 2018 08:14:22 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=azagrebin&quot; class=&quot;user-hover&quot; rel=&quot;azagrebin&quot;&gt;azagrebin&lt;/a&gt; thanks for your answer!&lt;/p&gt;</comment>
                            <comment id="16582175" author="azagrebin" created="Thu, 16 Aug 2018 08:26:22 +0000"  >&lt;p&gt;Thanks for reporting this issue &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=wucj&quot; class=&quot;user-hover&quot; rel=&quot;wucj&quot;&gt;wucj&lt;/a&gt;! I will have a look&#160;at this.&lt;/p&gt;</comment>
                            <comment id="16618162" author="githubbot" created="Mon, 17 Sep 2018 21:19:42 +0000"  >&lt;p&gt;azagrebin opened a new pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What is the purpose of the change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   This change allows to store null values with TTL and aligns the semantics of map state TTL get/contains methods with the map state w/o TTL.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Brief change log&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;allow null user value in TtlValue&lt;/li&gt;
	&lt;li&gt;add tests for null user values in Map state&lt;/li&gt;
	&lt;li&gt;add NullableSerializer to wrap serializers w/o null support but where null values are needed in map state&lt;/li&gt;
	&lt;li&gt;doc notes&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Verifying this change&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   &lt;b&gt;(Please pick either of the following options)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;   This change is a trivial rework / code cleanup without any test coverage.&lt;/p&gt;

&lt;p&gt;   &lt;b&gt;(or)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;   This change is already covered by existing tests, such as &lt;b&gt;(please describe tests)&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;   &lt;b&gt;(or)&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;   This change added tests and can be verified as follows:&lt;/p&gt;

&lt;p&gt;   &lt;b&gt;(example&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;b&gt;Added integration tests for end-to-end deployment with large payloads (100MB)&lt;/b&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Extended integration test for recovery after master (JobManager) failure&lt;/b&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Added test that validates that TaskInfo is transferred only once across recoveries&lt;/b&gt;&lt;/li&gt;
	&lt;li&gt;&lt;b&gt;Manually verified the change by running a 4 node cluser with 2 JobManagers and 4 TaskManagers, a stateful streaming program, and killing one JobManager and two TaskManagers during the execution, verifying that recovery happens correctly.&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Does this pull request potentially affect one of the following parts:&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Dependencies (does it add or upgrade a dependency): (yes / no)&lt;/li&gt;
	&lt;li&gt;The public API, i.e., is any changed class annotated with `@Public(Evolving)`: (yes / no)&lt;/li&gt;
	&lt;li&gt;The serializers: (yes / no / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;The runtime per-record code paths (performance sensitive): (yes / no / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;Anything that affects deployment or recovery: JobManager (and its components), Checkpointing, Yarn/Mesos, ZooKeeper: (yes / no / don&apos;t know)&lt;/li&gt;
	&lt;li&gt;The S3 file system connector: (yes / no / don&apos;t know)&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;Documentation&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Does this pull request introduce a new feature? (yes / no)&lt;/li&gt;
	&lt;li&gt;If yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16618165" author="githubbot" created="Mon, 17 Sep 2018 21:23:23 +0000"  >&lt;p&gt;azagrebin commented on issue #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#issuecomment-422176532&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#issuecomment-422176532&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   cc @StefanRRichter &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16620278" author="githubbot" created="Wed, 19 Sep 2018 08:15:57 +0000"  >&lt;p&gt;Clarkkkkk commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r218707661&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r218707661&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlMapState.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -54,7 +54,13 @@&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	public UV get(UK key) throws Exception &lt;/p&gt;
{
-		return getWithTtlCheckAndUpdate(() -&amp;gt; original.get(key), v -&amp;gt; original.put(key, v), () -&amp;gt; original.remove(key));
+		TtlValue&amp;lt;UV&amp;gt; ttlValue = getWrapped(key);
+		return ttlValue == null ? null : ttlValue.getUserValue();
+	}
&lt;p&gt;+&lt;br/&gt;
+	private TtlValue&amp;lt;UV&amp;gt; getWrapped(UK key) throws Exception {&lt;br/&gt;
+		return getWrappedWithTtlCheckAndUpdate(&lt;br/&gt;
+			() -&amp;gt; original.get(key), v -&amp;gt; original.put(key, v), () -&amp;gt; original.remove(key));&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Is it necessary to add a private method here? &lt;br/&gt;
   TtlValue&amp;lt;UV&amp;gt; ttlValue = getWrappedWithTtlCheckAndUpdate(&lt;br/&gt;
   			() -&amp;gt; original.get(key), v -&amp;gt; original.put(key, v), () -&amp;gt; original.remove(key));&lt;br/&gt;
   return ttlValue == null ? null : ttlValue.getUserValue();&lt;br/&gt;
   looks better to me.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16620307" author="githubbot" created="Wed, 19 Sep 2018 08:50:08 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r218708975&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r218708975&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,221 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Serializer wrapper to add support of null value serialization.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If the target serializer does not support null values of its type,&lt;br/&gt;
+ * you can use this class to wrap this serializer.&lt;br/&gt;
+ * This is a generic treatment of null value serialization&lt;br/&gt;
+ * which comes with the cost of additional byte in the final serialized value.&lt;br/&gt;
+ * The &lt;/p&gt;
{@code NullableSerializer}
&lt;p&gt; will intercept null value serialization case&lt;br/&gt;
+ * and prepend the target serialized value with a boolean flag marking whether it is null or not.&lt;br/&gt;
+ * &amp;lt;pre&amp;gt; {@code&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; originalSerializer = ...;&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrap(originalSerializer);&lt;br/&gt;
+ * // or&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer);&lt;br/&gt;
+ * }}&amp;lt;/pre&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; type to serialize&lt;br/&gt;
+ */&lt;br/&gt;
+public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+	private static final long serialVersionUID = 3335569358214720033L;&lt;br/&gt;
+&lt;br/&gt;
+	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;br/&gt;
+&lt;br/&gt;
+	private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) &lt;/p&gt;
{
+		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);
+		this.originalSerializer = originalSerializer;
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method tries to serialize null value with the &lt;/p&gt;
{@code originalSerializer}&lt;br/&gt;
+	 * and wraps it in case of {@link NullPointerException}, otherwise it returns the {@code originalSerializer}
&lt;p&gt;.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) &lt;/p&gt;
{
+		return checkIfNullSupported(originalSerializer) ? originalSerializer : wrap(originalSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	private static &amp;lt;T&amp;gt; boolean checkIfNullSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+		try {&lt;br/&gt;
+			originalSerializer.serialize(null, new DataOutputSerializer(1));&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Would it make sense to check that a full cycle of `serialize(null) -&amp;gt;  deserialize(bytes)` returns as `null`? &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16620308" author="githubbot" created="Wed, 19 Sep 2018 08:50:08 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r218714030&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r218714030&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializerTest.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,80 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputDeserializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertEquals;&lt;br/&gt;
+import static org.junit.Assert.assertNull;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+&lt;br/&gt;
+/** Unit tests for &lt;/p&gt;
{@link NullableSerializer}
&lt;p&gt;. */&lt;br/&gt;
+public class NullableSerializerTest {&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I think you might also extend `TestLogger` and probably `TypeSerializerTestBase` as well. The second could also be a separate test class.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16620309" author="githubbot" created="Wed, 19 Sep 2018 08:50:08 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r218708034&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r218708034&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/common/state/StateTtlConfig.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -32,6 +32,12 @@&lt;/p&gt;

&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Configuration of state TTL logic.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;Note: The map state with TTL currently supports null user values&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Do you think this is the best position for this comment or rather on `MapStateDescriptor` (where the serializer is supplied) or maybe even both?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16620310" author="githubbot" created="Wed, 19 Sep 2018 08:50:08 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r218486113&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r218486113&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,221 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Serializer wrapper to add support of null value serialization.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If the target serializer does not support null values of its type,&lt;br/&gt;
+ * you can use this class to wrap this serializer.&lt;br/&gt;
+ * This is a generic treatment of null value serialization&lt;br/&gt;
+ * which comes with the cost of additional byte in the final serialized value.&lt;br/&gt;
+ * The &lt;/p&gt;
{@code NullableSerializer} will intercept null value serialization case&lt;br/&gt;
+ * and prepend the target serialized value with a boolean flag marking whether it is null or not.&lt;br/&gt;
+ * &amp;lt;pre&amp;gt; {@code&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; originalSerializer = ...;&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrap(originalSerializer);&lt;br/&gt;
+ * // or&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer);&lt;br/&gt;
+ * }}&amp;lt;/pre&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; type to serialize&lt;br/&gt;
+ */&lt;br/&gt;
+public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+	private static final long serialVersionUID = 3335569358214720033L;&lt;br/&gt;
+&lt;br/&gt;
+	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;br/&gt;
+&lt;br/&gt;
+	private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {
+		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);
+		this.originalSerializer = originalSerializer;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method tries to serialize null value with the {@code originalSerializer}&lt;br/&gt;
+	 * and wraps it in case of {@link NullPointerException}, otherwise it returns the {@code originalSerializer}.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {
+		return checkIfNullSupported(originalSerializer) ? originalSerializer : wrap(originalSerializer);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private static &amp;lt;T&amp;gt; boolean checkIfNullSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+		try {
+			originalSerializer.serialize(null, new DataOutputSerializer(1));
+			Preconditions.checkArgument(originalSerializer.copy(null) == null);
+		} catch (NullPointerException | IOException e) {
+			return false;
+		}&lt;br/&gt;
+		return true;&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/** This method wraps the {@code originalSerializer} with the {@code NullableSerializer}
&lt;p&gt; if not already wrapped. */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrap(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) &lt;/p&gt;
{
+		return originalSerializer instanceof NullableSerializer ?
+			originalSerializer : new NullableSerializer&amp;lt;&amp;gt;(originalSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public boolean isImmutableType() &lt;/p&gt;
{
+		return originalSerializer.isImmutableType();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public TypeSerializer&amp;lt;T&amp;gt; duplicate() &lt;/p&gt;
{
+		return new NullableSerializer&amp;lt;&amp;gt;(originalSerializer.duplicate());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T createInstance() &lt;/p&gt;
{
+		return originalSerializer.createInstance();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T copy(T from) &lt;/p&gt;
{
+		return from == null ? null : originalSerializer.copy(from);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T copy(T from, T reuse) &lt;/p&gt;
{
+		return from == null ? null :
+			(reuse == null ? originalSerializer.copy(from) : originalSerializer.copy(from, reuse));
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public int getLength() &lt;/p&gt;
{
+		int len = originalSerializer.getLength();
+		return len &amp;lt; 0 ? len : len + 1;
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void serialize(T record, DataOutputView target) throws IOException {&lt;br/&gt;
+		if (record == null) &lt;/p&gt;
{
+			target.writeBoolean(true);
+		}
&lt;p&gt; else &lt;/p&gt;
{
+			target.writeBoolean(false);
+			originalSerializer.serialize(record, target);
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T deserialize(DataInputView source) throws IOException &lt;/p&gt;
{
+		boolean isNull = source.readBoolean();
+		return isNull ? null : originalSerializer.deserialize(source);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T deserialize(T reuse, DataInputView source) throws IOException &lt;/p&gt;
{
+		boolean isNull = source.readBoolean();
+		return isNull ? null : (reuse == null ?
+			originalSerializer.deserialize(source) : originalSerializer.deserialize(reuse, source));
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void copy(DataInputView source, DataOutputView target) throws IOException {&lt;br/&gt;
+		boolean isNull = source.readBoolean();&lt;br/&gt;
+		target.writeBoolean(isNull);&lt;br/&gt;
+		if (!isNull) &lt;/p&gt;
{
+			originalSerializer.copy(source, target);
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public boolean equals(Object obj) &lt;/p&gt;
{
+		return obj == this ||
+			(obj != null &amp;amp;&amp;amp; obj.getClass() == getClass() &amp;amp;&amp;amp;
+				originalSerializer.equals(((NullableSerializer) originalSerializer).originalSerializer));
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public boolean canEqual(Object obj) {&lt;br/&gt;
+		return (obj != null &amp;amp;&amp;amp; obj.getClass() == getClass());&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   ...and also check if the originalSerializer canEqual?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16620311" author="githubbot" created="Wed, 19 Sep 2018 08:50:08 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r218485176&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r218485176&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,221 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Serializer wrapper to add support of null value serialization.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If the target serializer does not support null values of its type,&lt;br/&gt;
+ * you can use this class to wrap this serializer.&lt;br/&gt;
+ * This is a generic treatment of null value serialization&lt;br/&gt;
+ * which comes with the cost of additional byte in the final serialized value.&lt;br/&gt;
+ * The &lt;/p&gt;
{@code NullableSerializer}
&lt;p&gt; will intercept null value serialization case&lt;br/&gt;
+ * and prepend the target serialized value with a boolean flag marking whether it is null or not.&lt;br/&gt;
+ * &amp;lt;pre&amp;gt; {@code&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; originalSerializer = ...;&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrap(originalSerializer);&lt;br/&gt;
+ * // or&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer);&lt;br/&gt;
+ * }}&amp;lt;/pre&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; type to serialize&lt;br/&gt;
+ */&lt;br/&gt;
+public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+	private static final long serialVersionUID = 3335569358214720033L;&lt;br/&gt;
+&lt;br/&gt;
+	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;br/&gt;
+&lt;br/&gt;
+	private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   For my personal taste, I would prefer `@Nonnull` on the field.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16620312" author="githubbot" created="Wed, 19 Sep 2018 08:50:08 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r218713187&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r218713187&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,221 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Serializer wrapper to add support of null value serialization.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If the target serializer does not support null values of its type,&lt;br/&gt;
+ * you can use this class to wrap this serializer.&lt;br/&gt;
+ * This is a generic treatment of null value serialization&lt;br/&gt;
+ * which comes with the cost of additional byte in the final serialized value.&lt;br/&gt;
+ * The &lt;/p&gt;
{@code NullableSerializer}
&lt;p&gt; will intercept null value serialization case&lt;br/&gt;
+ * and prepend the target serialized value with a boolean flag marking whether it is null or not.&lt;br/&gt;
+ * &amp;lt;pre&amp;gt; {@code&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; originalSerializer = ...;&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrap(originalSerializer);&lt;br/&gt;
+ * // or&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer);&lt;br/&gt;
+ * }}&amp;lt;/pre&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; type to serialize&lt;br/&gt;
+ */&lt;br/&gt;
+public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+	private static final long serialVersionUID = 3335569358214720033L;&lt;br/&gt;
+&lt;br/&gt;
+	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;br/&gt;
+&lt;br/&gt;
+	private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) &lt;/p&gt;
{
+		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);
+		this.originalSerializer = originalSerializer;
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method tries to serialize null value with the &lt;/p&gt;
{@code originalSerializer}&lt;br/&gt;
+	 * and wraps it in case of {@link NullPointerException}, otherwise it returns the {@code originalSerializer}
&lt;p&gt;.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) &lt;/p&gt;
{
+		return checkIfNullSupported(originalSerializer) ? originalSerializer : wrap(originalSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	private static &amp;lt;T&amp;gt; boolean checkIfNullSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+		try &lt;/p&gt;
{
+			originalSerializer.serialize(null, new DataOutputSerializer(1));
+			Preconditions.checkArgument(originalSerializer.copy(null) == null);
+		}
&lt;p&gt; catch (NullPointerException | IOException e) {&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   This triggered another idea, maybe we should also test for this in the `SerializerTestBase`, for example that `null` either works or throws an &quot;acceptable&quot; exception. In case that it works, we could also check other properties, e.g. that if the serializer declares a fixed size also the serialized bytes for `null` have the same size.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16620313" author="githubbot" created="Wed, 19 Sep 2018 08:50:08 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r218482795&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r218482795&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,221 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Serializer wrapper to add support of null value serialization.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If the target serializer does not support null values of its type,&lt;br/&gt;
+ * you can use this class to wrap this serializer.&lt;br/&gt;
+ * This is a generic treatment of null value serialization&lt;br/&gt;
+ * which comes with the cost of additional byte in the final serialized value.&lt;br/&gt;
+ * The &lt;/p&gt;
{@code NullableSerializer} will intercept null value serialization case&lt;br/&gt;
+ * and prepend the target serialized value with a boolean flag marking whether it is null or not.&lt;br/&gt;
+ * &amp;lt;pre&amp;gt; {@code&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; originalSerializer = ...;&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrap(originalSerializer);&lt;br/&gt;
+ * // or&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer);&lt;br/&gt;
+ * }}&amp;lt;/pre&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; type to serialize&lt;br/&gt;
+ */&lt;br/&gt;
+public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+	private static final long serialVersionUID = 3335569358214720033L;&lt;br/&gt;
+&lt;br/&gt;
+	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;br/&gt;
+&lt;br/&gt;
+	private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {
+		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);
+		this.originalSerializer = originalSerializer;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method tries to serialize null value with the {@code originalSerializer}&lt;br/&gt;
+	 * and wraps it in case of {@link NullPointerException}, otherwise it returns the {@code originalSerializer}.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {
+		return checkIfNullSupported(originalSerializer) ? originalSerializer : wrap(originalSerializer);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private static &amp;lt;T&amp;gt; boolean checkIfNullSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+		try {
+			originalSerializer.serialize(null, new DataOutputSerializer(1));
+			Preconditions.checkArgument(originalSerializer.copy(null) == null);
+		} catch (NullPointerException | IOException e) {
+			return false;
+		}&lt;br/&gt;
+		return true;&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/** This method wraps the {@code originalSerializer} with the {@code NullableSerializer}
&lt;p&gt; if not already wrapped. */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrap(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) &lt;/p&gt;
{
+		return originalSerializer instanceof NullableSerializer ?
+			originalSerializer : new NullableSerializer&amp;lt;&amp;gt;(originalSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public boolean isImmutableType() &lt;/p&gt;
{
+		return originalSerializer.isImmutableType();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public TypeSerializer&amp;lt;T&amp;gt; duplicate() {&lt;br/&gt;
+		return new NullableSerializer&amp;lt;&amp;gt;(originalSerializer.duplicate());&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I would only return a new serializer if `originalSerializer.duplicate() != originalSerializer`, otherwise `this`.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16620314" author="githubbot" created="Wed, 19 Sep 2018 08:50:08 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r218484596&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r218484596&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,221 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Serializer wrapper to add support of null value serialization.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If the target serializer does not support null values of its type,&lt;br/&gt;
+ * you can use this class to wrap this serializer.&lt;br/&gt;
+ * This is a generic treatment of null value serialization&lt;br/&gt;
+ * which comes with the cost of additional byte in the final serialized value.&lt;br/&gt;
+ * The &lt;/p&gt;
{@code NullableSerializer}
&lt;p&gt; will intercept null value serialization case&lt;br/&gt;
+ * and prepend the target serialized value with a boolean flag marking whether it is null or not.&lt;br/&gt;
+ * &amp;lt;pre&amp;gt; {@code&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; originalSerializer = ...;&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrap(originalSerializer);&lt;br/&gt;
+ * // or&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer);&lt;br/&gt;
+ * }}&amp;lt;/pre&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; type to serialize&lt;br/&gt;
+ */&lt;br/&gt;
+public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+	private static final long serialVersionUID = 3335569358214720033L;&lt;br/&gt;
+&lt;br/&gt;
+	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;br/&gt;
+&lt;br/&gt;
+	private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) &lt;/p&gt;
{
+		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);
+		this.originalSerializer = originalSerializer;
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method tries to serialize null value with the &lt;/p&gt;
{@code originalSerializer}&lt;br/&gt;
+	 * and wraps it in case of {@link NullPointerException}, otherwise it returns the {@code originalSerializer}
&lt;p&gt;.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) &lt;/p&gt;
{
+		return checkIfNullSupported(originalSerializer) ? originalSerializer : wrap(originalSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	private static &amp;lt;T&amp;gt; boolean checkIfNullSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+		try &lt;/p&gt;
{
+			originalSerializer.serialize(null, new DataOutputSerializer(1));
+			Preconditions.checkArgument(originalSerializer.copy(null) == null);
+		}
&lt;p&gt; catch (NullPointerException | IOException e) {&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I wonder if we should be broader and catch `IOException` and `RuntimeException`, e.g. some people might wrongly throw `IllegalArgumentException` in their serializer.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16620315" author="githubbot" created="Wed, 19 Sep 2018 08:50:08 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r218707603&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r218707603&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: docs/dev/stream/state/state.md&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -350,6 +350,9 @@ will lead to compatibility failure and `StateMigrationException`.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The TTL configuration is not part of check- or savepoints but rather a way of how Flink treats it in the currently running job.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+- The map state with TTL currently supports null user values only if the user value serializer can handle null values. &lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Could highlight plaintext null as `null` (multiple instances).&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16620316" author="githubbot" created="Wed, 19 Sep 2018 08:50:08 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r218713497&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r218713497&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,221 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Serializer wrapper to add support of null value serialization.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If the target serializer does not support null values of its type,&lt;br/&gt;
+ * you can use this class to wrap this serializer.&lt;br/&gt;
+ * This is a generic treatment of null value serialization&lt;br/&gt;
+ * which comes with the cost of additional byte in the final serialized value.&lt;br/&gt;
+ * The &lt;/p&gt;
{@code NullableSerializer}
&lt;p&gt; will intercept null value serialization case&lt;br/&gt;
+ * and prepend the target serialized value with a boolean flag marking whether it is null or not.&lt;br/&gt;
+ * &amp;lt;pre&amp;gt; {@code&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; originalSerializer = ...;&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrap(originalSerializer);&lt;br/&gt;
+ * // or&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer);&lt;br/&gt;
+ * }}&amp;lt;/pre&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; type to serialize&lt;br/&gt;
+ */&lt;br/&gt;
+public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+	private static final long serialVersionUID = 3335569358214720033L;&lt;br/&gt;
+&lt;br/&gt;
+	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;br/&gt;
+&lt;br/&gt;
+	private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) &lt;/p&gt;
{
+		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);
+		this.originalSerializer = originalSerializer;
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method tries to serialize null value with the &lt;/p&gt;
{@code originalSerializer}&lt;br/&gt;
+	 * and wraps it in case of {@link NullPointerException}, otherwise it returns the {@code originalSerializer}
&lt;p&gt;.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) &lt;/p&gt;
{
+		return checkIfNullSupported(originalSerializer) ? originalSerializer : wrap(originalSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	private static &amp;lt;T&amp;gt; boolean checkIfNullSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+		try {&lt;br/&gt;
+			originalSerializer.serialize(null, new DataOutputSerializer(1));&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   Could initialize `new DataOutputSerializer(serializer.getLength())` for positive length.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16620319" author="githubbot" created="Wed, 19 Sep 2018 08:50:50 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r218486113&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r218486113&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,221 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Serializer wrapper to add support of null value serialization.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If the target serializer does not support null values of its type,&lt;br/&gt;
+ * you can use this class to wrap this serializer.&lt;br/&gt;
+ * This is a generic treatment of null value serialization&lt;br/&gt;
+ * which comes with the cost of additional byte in the final serialized value.&lt;br/&gt;
+ * The &lt;/p&gt;
{@code NullableSerializer} will intercept null value serialization case&lt;br/&gt;
+ * and prepend the target serialized value with a boolean flag marking whether it is null or not.&lt;br/&gt;
+ * &amp;lt;pre&amp;gt; {@code&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; originalSerializer = ...;&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrap(originalSerializer);&lt;br/&gt;
+ * // or&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer);&lt;br/&gt;
+ * }}&amp;lt;/pre&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; type to serialize&lt;br/&gt;
+ */&lt;br/&gt;
+public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+	private static final long serialVersionUID = 3335569358214720033L;&lt;br/&gt;
+&lt;br/&gt;
+	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;br/&gt;
+&lt;br/&gt;
+	private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {
+		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);
+		this.originalSerializer = originalSerializer;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method tries to serialize null value with the {@code originalSerializer}&lt;br/&gt;
+	 * and wraps it in case of {@link NullPointerException}, otherwise it returns the {@code originalSerializer}.&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {
+		return checkIfNullSupported(originalSerializer) ? originalSerializer : wrap(originalSerializer);
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private static &amp;lt;T&amp;gt; boolean checkIfNullSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+		try {
+			originalSerializer.serialize(null, new DataOutputSerializer(1));
+			Preconditions.checkArgument(originalSerializer.copy(null) == null);
+		} catch (NullPointerException | IOException e) {
+			return false;
+		}&lt;br/&gt;
+		return true;&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/** This method wraps the {@code originalSerializer} with the {@code NullableSerializer}
&lt;p&gt; if not already wrapped. */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrap(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) &lt;/p&gt;
{
+		return originalSerializer instanceof NullableSerializer ?
+			originalSerializer : new NullableSerializer&amp;lt;&amp;gt;(originalSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public boolean isImmutableType() &lt;/p&gt;
{
+		return originalSerializer.isImmutableType();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public TypeSerializer&amp;lt;T&amp;gt; duplicate() &lt;/p&gt;
{
+		return new NullableSerializer&amp;lt;&amp;gt;(originalSerializer.duplicate());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T createInstance() &lt;/p&gt;
{
+		return originalSerializer.createInstance();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T copy(T from) &lt;/p&gt;
{
+		return from == null ? null : originalSerializer.copy(from);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T copy(T from, T reuse) &lt;/p&gt;
{
+		return from == null ? null :
+			(reuse == null ? originalSerializer.copy(from) : originalSerializer.copy(from, reuse));
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public int getLength() &lt;/p&gt;
{
+		int len = originalSerializer.getLength();
+		return len &amp;lt; 0 ? len : len + 1;
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void serialize(T record, DataOutputView target) throws IOException {&lt;br/&gt;
+		if (record == null) &lt;/p&gt;
{
+			target.writeBoolean(true);
+		}
&lt;p&gt; else &lt;/p&gt;
{
+			target.writeBoolean(false);
+			originalSerializer.serialize(record, target);
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T deserialize(DataInputView source) throws IOException &lt;/p&gt;
{
+		boolean isNull = source.readBoolean();
+		return isNull ? null : originalSerializer.deserialize(source);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T deserialize(T reuse, DataInputView source) throws IOException &lt;/p&gt;
{
+		boolean isNull = source.readBoolean();
+		return isNull ? null : (reuse == null ?
+			originalSerializer.deserialize(source) : originalSerializer.deserialize(reuse, source));
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void copy(DataInputView source, DataOutputView target) throws IOException {&lt;br/&gt;
+		boolean isNull = source.readBoolean();&lt;br/&gt;
+		target.writeBoolean(isNull);&lt;br/&gt;
+		if (!isNull) &lt;/p&gt;
{
+			originalSerializer.copy(source, target);
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public boolean equals(Object obj) &lt;/p&gt;
{
+		return obj == this ||
+			(obj != null &amp;amp;&amp;amp; obj.getClass() == getClass() &amp;amp;&amp;amp;
+				originalSerializer.equals(((NullableSerializer) originalSerializer).originalSerializer));
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public boolean canEqual(Object obj) {&lt;br/&gt;
+		return (obj != null &amp;amp;&amp;amp; obj.getClass() == getClass());&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   ...and also check if the originalSerializer `canEqual`?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16620756" author="githubbot" created="Wed, 19 Sep 2018 15:33:34 +0000"  >&lt;p&gt;azagrebin commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r218853515&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r218853515&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlMapState.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -54,7 +54,13 @@&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	public UV get(UK key) throws Exception &lt;/p&gt;
{
-		return getWithTtlCheckAndUpdate(() -&amp;gt; original.get(key), v -&amp;gt; original.put(key, v), () -&amp;gt; original.remove(key));
+		TtlValue&amp;lt;UV&amp;gt; ttlValue = getWrapped(key);
+		return ttlValue == null ? null : ttlValue.getUserValue();
+	}
&lt;p&gt;+&lt;br/&gt;
+	private TtlValue&amp;lt;UV&amp;gt; getWrapped(UK key) throws Exception {&lt;br/&gt;
+		return getWrappedWithTtlCheckAndUpdate(&lt;br/&gt;
+			() -&amp;gt; original.get(key), v -&amp;gt; original.put(key, v), () -&amp;gt; original.remove(key));&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   I added it for code reuse because `get` and `contains` needed the same code.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16621672" author="githubbot" created="Thu, 20 Sep 2018 08:41:01 +0000"  >&lt;p&gt;azagrebin commented on issue #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#issuecomment-423095611&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#issuecomment-423095611&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Thanks for the review @StefanRRichter, I updated the PR&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16621759" author="githubbot" created="Thu, 20 Sep 2018 09:50:01 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219100170&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219100170&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -56,33 +59,51 @@&lt;br/&gt;
 public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
 	private static final long serialVersionUID = 3335569358214720033L;&lt;/p&gt;

&lt;p&gt;+	@Nonnull&lt;br/&gt;
 	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	private NullableSerializer(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
 		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   You could also remove the `Preconditions` check now that the annotation is in place.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16621763" author="githubbot" created="Thu, 20 Sep 2018 09:52:42 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219101008&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219101008&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -56,33 +59,51 @@&lt;br/&gt;
 public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
 	private static final long serialVersionUID = 3335569358214720033L;&lt;/p&gt;

&lt;p&gt;+	@Nonnull&lt;br/&gt;
 	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	private NullableSerializer(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer) 
{
 		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);
 		this.originalSerializer = originalSerializer;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* This method tries to serialize null value with the 
{@code originalSerializer}&lt;br/&gt;
+	 * This method tries to serialize {@code null} value with the {@code originalSerializer}&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;and wraps it in case of 
{@link NullPointerException}
&lt;p&gt;, otherwise it returns the &lt;/p&gt;
{@code originalSerializer}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param originalSerializer serializer to wrap and add &lt;/p&gt;
{@code null} support&lt;br/&gt;
+	 * @return serializer which supports {@code null}
&lt;p&gt; values&lt;br/&gt;
 	 */&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer) 
{
 		return checkIfNullSupported(originalSerializer) ? originalSerializer : wrap(originalSerializer);
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static &amp;lt;T&amp;gt; boolean checkIfNullSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method checks if 
{@code serializer}
&lt;p&gt; supports &lt;/p&gt;
{@code null}
&lt;p&gt; value.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param serializer serializer to check&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; boolean checkIfNullSupported(@Nonnull TypeSerializer&amp;lt;T&amp;gt; serializer) {&lt;br/&gt;
 		try &lt;/p&gt;
{
-			originalSerializer.serialize(null, new DataOutputSerializer(1));
-			Preconditions.checkArgument(originalSerializer.copy(null) == null);
-		}
&lt;p&gt; catch (NullPointerException | IOException e) {&lt;br/&gt;
+			int length = serializer.getLength() &amp;gt; 0 ? serializer.getLength() : 1;&lt;br/&gt;
+			DataOutputSerializer dos = new DataOutputSerializer(length);&lt;br/&gt;
+			serializer.serialize(null, dos);&lt;br/&gt;
+			DataInputDeserializer dis = new DataInputDeserializer(dos.getSharedBuffer());&lt;br/&gt;
+			Preconditions.checkArgument(serializer.deserialize(dis) == null);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Both precondition checks will just be caught by the following `catch` block. Depending on what you intend to do, the check should go outside the block, or rather result in `false` value directly (I assume the second case is what you want).&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16621765" author="githubbot" created="Thu, 20 Sep 2018 09:56:17 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219102134&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219102134&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -116,7 +139,7 @@ public T copy(T from, T reuse) {&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public int getLength() {&lt;br/&gt;
 		int len = originalSerializer.getLength();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return len &amp;lt; 0 ? len : len + 1;&lt;br/&gt;
+		return len == 0 ? 1 : -1;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   This change seems to be a bug.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16621768" author="githubbot" created="Thu, 20 Sep 2018 09:59:25 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219103133&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219103133&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -116,7 +139,7 @@ public T copy(T from, T reuse) {&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public int getLength() {&lt;br/&gt;
 		int len = originalSerializer.getLength();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return len &amp;lt; 0 ? len : len + 1;&lt;br/&gt;
+		return len == 0 ? 1 : -1;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Followup question: how did it pass the tests?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16621866" author="githubbot" created="Thu, 20 Sep 2018 11:40:47 +0000"  >&lt;p&gt;azagrebin commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219130240&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219130240&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -56,33 +59,51 @@&lt;br/&gt;
 public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
 	private static final long serialVersionUID = 3335569358214720033L;&lt;/p&gt;

&lt;p&gt;+	@Nonnull&lt;br/&gt;
 	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	private NullableSerializer(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer) 
{
 		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);
 		this.originalSerializer = originalSerializer;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* This method tries to serialize null value with the 
{@code originalSerializer}&lt;br/&gt;
+	 * This method tries to serialize {@code null} value with the {@code originalSerializer}&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;and wraps it in case of 
{@link NullPointerException}
&lt;p&gt;, otherwise it returns the &lt;/p&gt;
{@code originalSerializer}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param originalSerializer serializer to wrap and add &lt;/p&gt;
{@code null} support&lt;br/&gt;
+	 * @return serializer which supports {@code null}
&lt;p&gt; values&lt;br/&gt;
 	 */&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer) 
{
 		return checkIfNullSupported(originalSerializer) ? originalSerializer : wrap(originalSerializer);
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static &amp;lt;T&amp;gt; boolean checkIfNullSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method checks if 
{@code serializer}
&lt;p&gt; supports &lt;/p&gt;
{@code null}
&lt;p&gt; value.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param serializer serializer to check&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; boolean checkIfNullSupported(@Nonnull TypeSerializer&amp;lt;T&amp;gt; serializer) {&lt;br/&gt;
 		try &lt;/p&gt;
{
-			originalSerializer.serialize(null, new DataOutputSerializer(1));
-			Preconditions.checkArgument(originalSerializer.copy(null) == null);
-		}
&lt;p&gt; catch (NullPointerException | IOException e) {&lt;br/&gt;
+			int length = serializer.getLength() &amp;gt; 0 ? serializer.getLength() : 1;&lt;br/&gt;
+			DataOutputSerializer dos = new DataOutputSerializer(length);&lt;br/&gt;
+			serializer.serialize(null, dos);&lt;br/&gt;
+			DataInputDeserializer dis = new DataInputDeserializer(dos.getSharedBuffer());&lt;br/&gt;
+			Preconditions.checkArgument(serializer.deserialize(dis) == null);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   Catching exceptions will also produce false which will also result in returning false. But I think they should be rather moved out because if serializer can serialize null then it must also properly deserialize and copy it. This can be a sanity check after try and before returning true. What do you think?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16621871" author="githubbot" created="Thu, 20 Sep 2018 11:43:50 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219131023&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219131023&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -56,33 +59,51 @@&lt;br/&gt;
 public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
 	private static final long serialVersionUID = 3335569358214720033L;&lt;/p&gt;

&lt;p&gt;+	@Nonnull&lt;br/&gt;
 	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	private NullableSerializer(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer) 
{
 		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);
 		this.originalSerializer = originalSerializer;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* This method tries to serialize null value with the 
{@code originalSerializer}&lt;br/&gt;
+	 * This method tries to serialize {@code null} value with the {@code originalSerializer}&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;and wraps it in case of 
{@link NullPointerException}
&lt;p&gt;, otherwise it returns the &lt;/p&gt;
{@code originalSerializer}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param originalSerializer serializer to wrap and add &lt;/p&gt;
{@code null} support&lt;br/&gt;
+	 * @return serializer which supports {@code null}
&lt;p&gt; values&lt;br/&gt;
 	 */&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer) 
{
 		return checkIfNullSupported(originalSerializer) ? originalSerializer : wrap(originalSerializer);
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static &amp;lt;T&amp;gt; boolean checkIfNullSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method checks if 
{@code serializer}
&lt;p&gt; supports &lt;/p&gt;
{@code null}
&lt;p&gt; value.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param serializer serializer to check&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; boolean checkIfNullSupported(@Nonnull TypeSerializer&amp;lt;T&amp;gt; serializer) {&lt;br/&gt;
 		try &lt;/p&gt;
{
-			originalSerializer.serialize(null, new DataOutputSerializer(1));
-			Preconditions.checkArgument(originalSerializer.copy(null) == null);
-		}
&lt;p&gt; catch (NullPointerException | IOException e) {&lt;br/&gt;
+			int length = serializer.getLength() &amp;gt; 0 ? serializer.getLength() : 1;&lt;br/&gt;
+			DataOutputSerializer dos = new DataOutputSerializer(length);&lt;br/&gt;
+			serializer.serialize(null, dos);&lt;br/&gt;
+			DataInputDeserializer dis = new DataInputDeserializer(dos.getSharedBuffer());&lt;br/&gt;
+			Preconditions.checkArgument(serializer.deserialize(dis) == null);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   My main point is, you use precondition that could produce an exception and then immediately catch the exception and translate it to `false`. So my question is, why use precondition and not just an `if` that affects the result.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16621875" author="githubbot" created="Thu, 20 Sep 2018 11:44:49 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219131023&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219131023&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -56,33 +59,51 @@&lt;br/&gt;
 public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
 	private static final long serialVersionUID = 3335569358214720033L;&lt;/p&gt;

&lt;p&gt;+	@Nonnull&lt;br/&gt;
 	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	private NullableSerializer(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer) 
{
 		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);
 		this.originalSerializer = originalSerializer;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* This method tries to serialize null value with the 
{@code originalSerializer}&lt;br/&gt;
+	 * This method tries to serialize {@code null} value with the {@code originalSerializer}&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;and wraps it in case of 
{@link NullPointerException}
&lt;p&gt;, otherwise it returns the &lt;/p&gt;
{@code originalSerializer}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param originalSerializer serializer to wrap and add &lt;/p&gt;
{@code null} support&lt;br/&gt;
+	 * @return serializer which supports {@code null}
&lt;p&gt; values&lt;br/&gt;
 	 */&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer) 
{
 		return checkIfNullSupported(originalSerializer) ? originalSerializer : wrap(originalSerializer);
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static &amp;lt;T&amp;gt; boolean checkIfNullSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method checks if 
{@code serializer}
&lt;p&gt; supports &lt;/p&gt;
{@code null}
&lt;p&gt; value.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param serializer serializer to check&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; boolean checkIfNullSupported(@Nonnull TypeSerializer&amp;lt;T&amp;gt; serializer) {&lt;br/&gt;
 		try &lt;/p&gt;
{
-			originalSerializer.serialize(null, new DataOutputSerializer(1));
-			Preconditions.checkArgument(originalSerializer.copy(null) == null);
-		}
&lt;p&gt; catch (NullPointerException | IOException e) {&lt;br/&gt;
+			int length = serializer.getLength() &amp;gt; 0 ? serializer.getLength() : 1;&lt;br/&gt;
+			DataOutputSerializer dos = new DataOutputSerializer(length);&lt;br/&gt;
+			serializer.serialize(null, dos);&lt;br/&gt;
+			DataInputDeserializer dis = new DataInputDeserializer(dos.getSharedBuffer());&lt;br/&gt;
+			Preconditions.checkArgument(serializer.deserialize(dis) == null);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   My main point is, you use precondition that could produce an exception and then immediately catch the exception and translate it to `false`. So my question is, why use precondition and not just an `if` that affects the result. Or in other words, why do we need to go through exceptions for this (nobody takes note that the `false` came from an exceptional case as well)?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16621939" author="githubbot" created="Thu, 20 Sep 2018 12:38:05 +0000"  >&lt;p&gt;azagrebin commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219146019&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219146019&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -56,33 +59,51 @@&lt;br/&gt;
 public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
 	private static final long serialVersionUID = 3335569358214720033L;&lt;/p&gt;

&lt;p&gt;+	@Nonnull&lt;br/&gt;
 	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	private NullableSerializer(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer) 
{
 		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);
 		this.originalSerializer = originalSerializer;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* This method tries to serialize null value with the 
{@code originalSerializer}&lt;br/&gt;
+	 * This method tries to serialize {@code null} value with the {@code originalSerializer}&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;and wraps it in case of 
{@link NullPointerException}
&lt;p&gt;, otherwise it returns the &lt;/p&gt;
{@code originalSerializer}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param originalSerializer serializer to wrap and add &lt;/p&gt;
{@code null} support&lt;br/&gt;
+	 * @return serializer which supports {@code null}
&lt;p&gt; values&lt;br/&gt;
 	 */&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer) 
{
 		return checkIfNullSupported(originalSerializer) ? originalSerializer : wrap(originalSerializer);
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static &amp;lt;T&amp;gt; boolean checkIfNullSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method checks if 
{@code serializer}
&lt;p&gt; supports &lt;/p&gt;
{@code null}
&lt;p&gt; value.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param serializer serializer to check&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; boolean checkIfNullSupported(@Nonnull TypeSerializer&amp;lt;T&amp;gt; serializer) {&lt;br/&gt;
 		try &lt;/p&gt;
{
-			originalSerializer.serialize(null, new DataOutputSerializer(1));
-			Preconditions.checkArgument(originalSerializer.copy(null) == null);
-		}
&lt;p&gt; catch (NullPointerException | IOException e) {&lt;br/&gt;
+			int length = serializer.getLength() &amp;gt; 0 ? serializer.getLength() : 1;&lt;br/&gt;
+			DataOutputSerializer dos = new DataOutputSerializer(length);&lt;br/&gt;
+			serializer.serialize(null, dos);&lt;br/&gt;
+			DataInputDeserializer dis = new DataInputDeserializer(dos.getSharedBuffer());&lt;br/&gt;
+			Preconditions.checkArgument(serializer.deserialize(dis) == null);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   ok, let&apos;s move preconditions out and leave them as a sanity checks&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16621940" author="githubbot" created="Thu, 20 Sep 2018 12:38:11 +0000"  >&lt;p&gt;azagrebin commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219146019&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219146019&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -56,33 +59,51 @@&lt;br/&gt;
 public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
 	private static final long serialVersionUID = 3335569358214720033L;&lt;/p&gt;

&lt;p&gt;+	@Nonnull&lt;br/&gt;
 	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private NullableSerializer(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	private NullableSerializer(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer) 
{
 		Preconditions.checkNotNull(originalSerializer, &quot;The original serializer cannot be null&quot;);
 		this.originalSerializer = originalSerializer;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* This method tries to serialize null value with the 
{@code originalSerializer}&lt;br/&gt;
+	 * This method tries to serialize {@code null} value with the {@code originalSerializer}&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;and wraps it in case of 
{@link NullPointerException}
&lt;p&gt;, otherwise it returns the &lt;/p&gt;
{@code originalSerializer}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param originalSerializer serializer to wrap and add &lt;/p&gt;
{@code null} support&lt;br/&gt;
+	 * @return serializer which supports {@code null}
&lt;p&gt; values&lt;br/&gt;
 	 */&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer) 
{
 		return checkIfNullSupported(originalSerializer) ? originalSerializer : wrap(originalSerializer);
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static &amp;lt;T&amp;gt; boolean checkIfNullSupported(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) {&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method checks if 
{@code serializer}
&lt;p&gt; supports &lt;/p&gt;
{@code null}
&lt;p&gt; value.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param serializer serializer to check&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; boolean checkIfNullSupported(@Nonnull TypeSerializer&amp;lt;T&amp;gt; serializer) {&lt;br/&gt;
 		try &lt;/p&gt;
{
-			originalSerializer.serialize(null, new DataOutputSerializer(1));
-			Preconditions.checkArgument(originalSerializer.copy(null) == null);
-		}
&lt;p&gt; catch (NullPointerException | IOException e) {&lt;br/&gt;
+			int length = serializer.getLength() &amp;gt; 0 ? serializer.getLength() : 1;&lt;br/&gt;
+			DataOutputSerializer dos = new DataOutputSerializer(length);&lt;br/&gt;
+			serializer.serialize(null, dos);&lt;br/&gt;
+			DataInputDeserializer dis = new DataInputDeserializer(dos.getSharedBuffer());&lt;br/&gt;
+			Preconditions.checkArgument(serializer.deserialize(dis) == null);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   ok, let&apos;s move preconditions out and leave them as a sanity check&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16621945" author="githubbot" created="Thu, 20 Sep 2018 12:41:08 +0000"  >&lt;p&gt;azagrebin commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219146864&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219146864&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -116,7 +139,7 @@ public T copy(T from, T reuse) {&lt;br/&gt;
 	@Override&lt;br/&gt;
 	public int getLength() {&lt;br/&gt;
 		int len = originalSerializer.getLength();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return len &amp;lt; 0 ? len : len + 1;&lt;br/&gt;
+		return len == 0 ? 1 : -1;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; Review comment:&lt;br/&gt;
   The serializer does not have fixed length in common case now (1 or 1 + original length). It is fixed to 1 only of original length is zero. Let&apos;s add an option to pad the null value and preserve the fixed length if original serializer has the fixed length.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16622225" author="githubbot" created="Thu, 20 Sep 2018 15:37:32 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219214268&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219214268&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,279 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputDeserializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Serializer wrapper to add support of &lt;/p&gt;
{@code null} value serialization.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If the target serializer does not support {@code null}
&lt;p&gt; values of its type,&lt;br/&gt;
+ * you can use this class to wrap this serializer.&lt;br/&gt;
+ * This is a generic treatment of &lt;/p&gt;
{@code null} value serialization&lt;br/&gt;
+ * which comes with the cost of additional byte in the final serialized value.&lt;br/&gt;
+ * The {@code NullableSerializer} will intercept {@code null}
&lt;p&gt; value serialization case&lt;br/&gt;
+ * and prepend the target serialized value with a boolean flag marking whether it is &lt;/p&gt;
{@code null}
&lt;p&gt; or not.&lt;br/&gt;
+ * &amp;lt;pre&amp;gt; {@code&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; originalSerializer = ...;&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrap(originalSerializer);&lt;br/&gt;
+ * // or&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer);&lt;br/&gt;
+ * }}&amp;lt;/pre&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; type to serialize&lt;br/&gt;
+ */&lt;br/&gt;
+public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+	private static final long serialVersionUID = 3335569358214720033L;&lt;br/&gt;
+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;br/&gt;
+	private final boolean padNullValue;&lt;br/&gt;
+	private final byte[] padding;&lt;br/&gt;
+&lt;br/&gt;
+	private NullableSerializer(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer, boolean padNullValueIfFixedLen) {&lt;br/&gt;
+		this.originalSerializer = originalSerializer;&lt;br/&gt;
+		this.padNullValue = originalSerializer.getLength() &amp;gt; 0 &amp;amp;&amp;amp; padNullValueIfFixedLen;&lt;br/&gt;
+		padding = padNullValue ? new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;originalSerializer.getLength()&amp;#93;&lt;/span&gt; : null;&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   You could use `byte&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;` for no padding and get rid of `null` checks as well as the `padNullValue` flag via a method `isPadding &lt;/p&gt;
{ return padding.length &amp;gt; 0;}
&lt;p&gt;`&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16622226" author="githubbot" created="Thu, 20 Sep 2018 15:38:02 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219214268&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219214268&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,279 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputDeserializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Serializer wrapper to add support of &lt;/p&gt;
{@code null} value serialization.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If the target serializer does not support {@code null}
&lt;p&gt; values of its type,&lt;br/&gt;
+ * you can use this class to wrap this serializer.&lt;br/&gt;
+ * This is a generic treatment of &lt;/p&gt;
{@code null} value serialization&lt;br/&gt;
+ * which comes with the cost of additional byte in the final serialized value.&lt;br/&gt;
+ * The {@code NullableSerializer} will intercept {@code null}
&lt;p&gt; value serialization case&lt;br/&gt;
+ * and prepend the target serialized value with a boolean flag marking whether it is &lt;/p&gt;
{@code null}
&lt;p&gt; or not.&lt;br/&gt;
+ * &amp;lt;pre&amp;gt; {@code&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; originalSerializer = ...;&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrap(originalSerializer);&lt;br/&gt;
+ * // or&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer);&lt;br/&gt;
+ * }}&amp;lt;/pre&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; type to serialize&lt;br/&gt;
+ */&lt;br/&gt;
+public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+	private static final long serialVersionUID = 3335569358214720033L;&lt;br/&gt;
+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;br/&gt;
+	private final boolean padNullValue;&lt;br/&gt;
+	private final byte[] padding;&lt;br/&gt;
+&lt;br/&gt;
+	private NullableSerializer(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer, boolean padNullValueIfFixedLen) {&lt;br/&gt;
+		this.originalSerializer = originalSerializer;&lt;br/&gt;
+		this.padNullValue = originalSerializer.getLength() &amp;gt; 0 &amp;amp;&amp;amp; padNullValueIfFixedLen;&lt;br/&gt;
+		padding = padNullValue ? new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;originalSerializer.getLength()&amp;#93;&lt;/span&gt; : null;&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   You could use `byte&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;` for no padding and get rid of `null` checks as well as the `padNullValue` flag via a method `isPadding &lt;/p&gt;
{ return padding.length &amp;gt; 0;}
&lt;p&gt;`. Then also annotating the field as `@Nonnull`.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16622229" author="githubbot" created="Thu, 20 Sep 2018 15:40:28 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219214268&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219214268&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,279 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputDeserializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Serializer wrapper to add support of &lt;/p&gt;
{@code null} value serialization.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If the target serializer does not support {@code null}
&lt;p&gt; values of its type,&lt;br/&gt;
+ * you can use this class to wrap this serializer.&lt;br/&gt;
+ * This is a generic treatment of &lt;/p&gt;
{@code null} value serialization&lt;br/&gt;
+ * which comes with the cost of additional byte in the final serialized value.&lt;br/&gt;
+ * The {@code NullableSerializer} will intercept {@code null}
&lt;p&gt; value serialization case&lt;br/&gt;
+ * and prepend the target serialized value with a boolean flag marking whether it is &lt;/p&gt;
{@code null}
&lt;p&gt; or not.&lt;br/&gt;
+ * &amp;lt;pre&amp;gt; {@code&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; originalSerializer = ...;&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrap(originalSerializer);&lt;br/&gt;
+ * // or&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer);&lt;br/&gt;
+ * }}&amp;lt;/pre&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; type to serialize&lt;br/&gt;
+ */&lt;br/&gt;
+public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+	private static final long serialVersionUID = 3335569358214720033L;&lt;br/&gt;
+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;br/&gt;
+	private final boolean padNullValue;&lt;br/&gt;
+	private final byte[] padding;&lt;br/&gt;
+&lt;br/&gt;
+	private NullableSerializer(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer, boolean padNullValueIfFixedLen) {&lt;br/&gt;
+		this.originalSerializer = originalSerializer;&lt;br/&gt;
+		this.padNullValue = originalSerializer.getLength() &amp;gt; 0 &amp;amp;&amp;amp; padNullValueIfFixedLen;&lt;br/&gt;
+		padding = padNullValue ? new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;originalSerializer.getLength()&amp;#93;&lt;/span&gt; : null;&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   You could use `byte&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;` for no padding and get rid of `null` checks as well as the `padNullValue` flag via a method `isPadding &lt;/p&gt;
{ return padding.length &amp;gt; 0;}
&lt;p&gt;`. Then also annotating the field as `@Nonnull` and just always call the method that writes padding.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16622237" author="githubbot" created="Thu, 20 Sep 2018 15:46:39 +0000"  >&lt;p&gt;StefanRRichter commented on a change in pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#discussion_r219214268&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#discussion_r219214268&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; ##########&lt;br/&gt;
 File path: flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
 ##########&lt;br/&gt;
 @@ -0,0 +1,279 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputDeserializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Serializer wrapper to add support of &lt;/p&gt;
{@code null} value serialization.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If the target serializer does not support {@code null}
&lt;p&gt; values of its type,&lt;br/&gt;
+ * you can use this class to wrap this serializer.&lt;br/&gt;
+ * This is a generic treatment of &lt;/p&gt;
{@code null} value serialization&lt;br/&gt;
+ * which comes with the cost of additional byte in the final serialized value.&lt;br/&gt;
+ * The {@code NullableSerializer} will intercept {@code null}
&lt;p&gt; value serialization case&lt;br/&gt;
+ * and prepend the target serialized value with a boolean flag marking whether it is &lt;/p&gt;
{@code null}
&lt;p&gt; or not.&lt;br/&gt;
+ * &amp;lt;pre&amp;gt; {@code&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; originalSerializer = ...;&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrap(originalSerializer);&lt;br/&gt;
+ * // or&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer);&lt;br/&gt;
+ * }}&amp;lt;/pre&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; type to serialize&lt;br/&gt;
+ */&lt;br/&gt;
+public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+	private static final long serialVersionUID = 3335569358214720033L;&lt;br/&gt;
+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;br/&gt;
+	private final boolean padNullValue;&lt;br/&gt;
+	private final byte[] padding;&lt;br/&gt;
+&lt;br/&gt;
+	private NullableSerializer(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer, boolean padNullValueIfFixedLen) {&lt;br/&gt;
+		this.originalSerializer = originalSerializer;&lt;br/&gt;
+		this.padNullValue = originalSerializer.getLength() &amp;gt; 0 &amp;amp;&amp;amp; padNullValueIfFixedLen;&lt;br/&gt;
+		padding = padNullValue ? new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;originalSerializer.getLength()&amp;#93;&lt;/span&gt; : null;&lt;/p&gt;

&lt;p&gt; Review comment:&lt;br/&gt;
   You could use `byte&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;` for no padding and get rid of `null`/flag checks as well as the `padNullValue` flag via a method `isPadding &lt;/p&gt;
{ return padding.length &amp;gt; 0;}
&lt;p&gt;`. Then also annotating the field as `@Nonnull` and just always call the method that writes padding to remove a couple branches.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16623467" author="githubbot" created="Fri, 21 Sep 2018 12:01:15 +0000"  >&lt;p&gt;StefanRRichter commented on issue #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707#issuecomment-423507977&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707#issuecomment-423507977&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Thanks @azagrebin ! Changes look good to me, merging. &#128077; &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16623621" author="githubbot" created="Fri, 21 Sep 2018 13:33:14 +0000"  >&lt;p&gt;asfgit closed pull request #6707: &lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-10157&quot; title=&quot;Allow `null` user values in map state with TTL&quot; class=&quot;issue-link&quot; data-issue-key=&quot;FLINK-10157&quot;&gt;&lt;del&gt;FLINK-10157&lt;/del&gt;&lt;/a&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;State TTL&amp;#93;&lt;/span&gt; Allow `null` user values in map state with TTL&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/flink/pull/6707&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/flink/pull/6707&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/docs/dev/stream/state/state.md b/docs/dev/stream/state/state.md&lt;br/&gt;
index fb787763536..decf1dbe9de 100644&lt;br/&gt;
&amp;#8212; a/docs/dev/stream/state/state.md&lt;br/&gt;
+++ b/docs/dev/stream/state/state.md&lt;br/&gt;
@@ -350,6 +350,9 @@ will lead to compatibility failure and `StateMigrationException`.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The TTL configuration is not part of check- or savepoints but rather a way of how Flink treats it in the currently running job.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+- The map state with TTL currently supports null user values only if the user value serializer can handle null values. &lt;br/&gt;
+If the serializer does not support null values, it can be wrapped with `NullableSerializer` at the cost of an extra byte in the serialized form.&lt;br/&gt;
+&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;
			&lt;ol&gt;
				&lt;li&gt;Cleanup of Expired State&lt;/li&gt;
			&lt;/ol&gt;
			&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt; Currently, expired values are only removed when they are read out explicitly, &lt;br/&gt;
diff --git a/flink-core/src/main/java/org/apache/flink/api/common/state/MapStateDescriptor.java b/flink-core/src/main/java/org/apache/flink/api/common/state/MapStateDescriptor.java&lt;br/&gt;
index 6eb8ddcd649..9b0094d50cd 100644&lt;br/&gt;
&amp;#8212; a/flink-core/src/main/java/org/apache/flink/api/common/state/MapStateDescriptor.java&lt;br/&gt;
+++ b/flink-core/src/main/java/org/apache/flink/api/common/state/MapStateDescriptor.java&lt;br/&gt;
@@ -37,6 +37,12 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;To create keyed map state (on a KeyedStream), use&lt;/li&gt;
	&lt;li&gt;{@link org.apache.flink.api.common.functions.RuntimeContext#getMapState(MapStateDescriptor)}
&lt;p&gt;.&lt;br/&gt;
  *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;Note: The map state with TTL currently supports &lt;/p&gt;
{@code null} user values&lt;br/&gt;
+ * only if the user value serializer can handle {@code null}
&lt;p&gt; values.&lt;br/&gt;
+ * If the serializer does not support &lt;/p&gt;
{@code null} values,&lt;br/&gt;
+ * it can be wrapped with {@link org.apache.flink.api.java.typeutils.runtime.NullableSerializer}&lt;br/&gt;
+ * at the cost of an extra byte in the serialized form.&lt;br/&gt;
+ *&lt;br/&gt;
  * @param &amp;lt;UK&amp;gt; The type of the keys that can be added to the map state.&lt;br/&gt;
  */&lt;br/&gt;
 @PublicEvolving&lt;br/&gt;
diff --git a/flink-core/src/main/java/org/apache/flink/api/common/state/StateTtlConfig.java b/flink-core/src/main/java/org/apache/flink/api/common/state/StateTtlConfig.java&lt;br/&gt;
index f4ed929bca9..42eaea4c482 100644&lt;br/&gt;
&amp;#8212; a/flink-core/src/main/java/org/apache/flink/api/common/state/StateTtlConfig.java&lt;br/&gt;
+++ b/flink-core/src/main/java/org/apache/flink/api/common/state/StateTtlConfig.java&lt;br/&gt;
@@ -32,6 +32,12 @@&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * Configuration of state TTL logic.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;Note: The map state with TTL currently supports {@code null}
&lt;p&gt; user values&lt;br/&gt;
+ * only if the user value serializer can handle &lt;/p&gt;
{@code null} values.&lt;br/&gt;
+ * If the serializer does not support {@code null}
&lt;p&gt; values,&lt;br/&gt;
+ * it can be wrapped with &lt;/p&gt;
{@link org.apache.flink.api.java.typeutils.runtime.NullableSerializer}
&lt;p&gt;+ * at the cost of an extra byte in the serialized form.&lt;br/&gt;
  */&lt;br/&gt;
 public class StateTtlConfig implements Serializable {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java b/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..fe392e4b1cb&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializer.java&lt;br/&gt;
@@ -0,0 +1,285 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.annotation.Internal;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.java.tuple.Tuple2;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputDeserializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataInputView;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputSerializer;&lt;br/&gt;
+import org.apache.flink.core.memory.DataOutputView;&lt;br/&gt;
+import org.apache.flink.util.Preconditions;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nonnull;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Serializer wrapper to add support of &lt;/p&gt;
{@code null} value serialization.&lt;br/&gt;
+ *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;If the target serializer does not support {@code null}
&lt;p&gt; values of its type,&lt;br/&gt;
+ * you can use this class to wrap this serializer.&lt;br/&gt;
+ * This is a generic treatment of &lt;/p&gt;
{@code null} value serialization&lt;br/&gt;
+ * which comes with the cost of additional byte in the final serialized value.&lt;br/&gt;
+ * The {@code NullableSerializer} will intercept {@code null}
&lt;p&gt; value serialization case&lt;br/&gt;
+ * and prepend the target serialized value with a boolean flag marking whether it is &lt;/p&gt;
{@code null} or not.&lt;br/&gt;
+ * &amp;lt;pre&amp;gt; {@code&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; originalSerializer = ...;&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrap(originalSerializer);&lt;br/&gt;
+ * // or&lt;br/&gt;
+ * TypeSerializer&amp;lt;T&amp;gt; serializerWithNullValueSupport = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer);&lt;br/&gt;
+ * }}&amp;lt;/pre&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; type to serialize&lt;br/&gt;
+ */&lt;br/&gt;
+public class NullableSerializer&amp;lt;T&amp;gt; extends TypeSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+	private static final long serialVersionUID = 3335569358214720033L;&lt;br/&gt;
+	private static final byte[] EMPTY_BYTE_ARRAY = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+&lt;br/&gt;
+	@Nonnull&lt;br/&gt;
+	private final TypeSerializer&amp;lt;T&amp;gt; originalSerializer;&lt;br/&gt;
+	private final byte[] padding;&lt;br/&gt;
+&lt;br/&gt;
+	private NullableSerializer(@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer, boolean padNullValueIfFixedLen) {
+		this.originalSerializer = originalSerializer;
+		this.padding = createPadding(originalSerializer.getLength(), padNullValueIfFixedLen);
+
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private static &amp;lt;T&amp;gt; byte[] createPadding(int originalSerializerLength, boolean padNullValueIfFixedLen) {
+		boolean padNullValue = originalSerializerLength &amp;gt; 0 &amp;amp;&amp;amp; padNullValueIfFixedLen;
+		return padNullValue ? new byte[originalSerializerLength] : EMPTY_BYTE_ARRAY;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method tries to serialize {@code null}
&lt;p&gt; value with the &lt;/p&gt;
{@code originalSerializer}&lt;br/&gt;
+	 * and wraps it in case of {@link NullPointerException}, otherwise it returns the {@code originalSerializer}
&lt;p&gt;.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param originalSerializer serializer to wrap and add &lt;/p&gt;
{@code null} support&lt;br/&gt;
+	 * @param padNullValueIfFixedLen pad null value to preserve the fixed length of original serializer&lt;br/&gt;
+	 * @return serializer which supports {@code null}
&lt;p&gt; values&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrapIfNullIsNotSupported(&lt;br/&gt;
+		@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer, boolean padNullValueIfFixedLen) &lt;/p&gt;
{
+		return checkIfNullSupported(originalSerializer) ?
+			originalSerializer : wrap(originalSerializer, padNullValueIfFixedLen);
+	}
&lt;p&gt;+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method checks if &lt;/p&gt;
{@code serializer}
&lt;p&gt; supports &lt;/p&gt;
{@code null} value.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param serializer serializer to check&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; boolean checkIfNullSupported(@Nonnull TypeSerializer&amp;lt;T&amp;gt; serializer) {&lt;br/&gt;
+		int length = serializer.getLength() &amp;gt; 0 ? serializer.getLength() : 1;&lt;br/&gt;
+		DataOutputSerializer dos = new DataOutputSerializer(length);&lt;br/&gt;
+		try {
+			serializer.serialize(null, dos);
+		} catch (IOException | RuntimeException e) {
+			return false;
+		}&lt;br/&gt;
+		Preconditions.checkArgument(&lt;br/&gt;
+			serializer.getLength() &amp;lt; 0 || serializer.getLength() == dos.getCopyOfBuffer().length,&lt;br/&gt;
+			&quot;The serialized form of the null value should have the same length &quot; +&lt;br/&gt;
+				&quot;as any other if the length is fixed in the serializer&quot;);&lt;br/&gt;
+		DataInputDeserializer dis = new DataInputDeserializer(dos.getSharedBuffer());&lt;br/&gt;
+		try {
+			Preconditions.checkArgument(serializer.deserialize(dis) == null);
+		} catch (IOException e) {
+			throw new RuntimeException(
+				String.format(&quot;Unexpected failure to deserialize just serialized null value with %s&quot;,
+					serializer.getClass().getName()), e);
+		}&lt;br/&gt;
+		Preconditions.checkArgument(&lt;br/&gt;
+			serializer.copy(null) == null,&lt;br/&gt;
+			&quot;Serializer %s has to be able properly copy null value if it can serialize it&quot;,&lt;br/&gt;
+			serializer.getClass().getName());&lt;br/&gt;
+		return true;&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	private boolean padNullValue() {
+		return padding.length &amp;gt; 0;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * This method wraps the {@code originalSerializer} with the {@code NullableSerializer} if not already wrapped.&lt;br/&gt;
+	 *&lt;br/&gt;
+	 * @param originalSerializer serializer to wrap and add {@code null}
&lt;p&gt; support&lt;br/&gt;
+	 * @param padNullValueIfFixedLen pad null value to preserve the fixed length of original serializer&lt;br/&gt;
+	 * @return wrapped serializer which supports &lt;/p&gt;
{@code null}
&lt;p&gt; values&lt;br/&gt;
+	 */&lt;br/&gt;
+	public static &amp;lt;T&amp;gt; TypeSerializer&amp;lt;T&amp;gt; wrap(&lt;br/&gt;
+		@Nonnull TypeSerializer&amp;lt;T&amp;gt; originalSerializer, boolean padNullValueIfFixedLen) &lt;/p&gt;
{
+		return originalSerializer instanceof NullableSerializer ?
+			originalSerializer : new NullableSerializer&amp;lt;&amp;gt;(originalSerializer, padNullValueIfFixedLen);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public boolean isImmutableType() &lt;/p&gt;
{
+		return originalSerializer.isImmutableType();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public TypeSerializer&amp;lt;T&amp;gt; duplicate() &lt;/p&gt;
{
+		TypeSerializer&amp;lt;T&amp;gt; duplicateOriginalSerializer = originalSerializer.duplicate();
+		return duplicateOriginalSerializer == originalSerializer ?
+			this : new NullableSerializer&amp;lt;&amp;gt;(originalSerializer.duplicate(), padNullValue());
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T createInstance() &lt;/p&gt;
{
+		return originalSerializer.createInstance();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T copy(T from) &lt;/p&gt;
{
+		return from == null ? null : originalSerializer.copy(from);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T copy(T from, T reuse) &lt;/p&gt;
{
+		return from == null ? null :
+			(reuse == null ? originalSerializer.copy(from) : originalSerializer.copy(from, reuse));
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public int getLength() &lt;/p&gt;
{
+		return padNullValue() ? 1 + padding.length : -1;
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void serialize(T record, DataOutputView target) throws IOException {&lt;br/&gt;
+		if (record == null) &lt;/p&gt;
{
+			target.writeBoolean(true);
+			target.write(padding);
+		}
&lt;p&gt; else &lt;/p&gt;
{
+			target.writeBoolean(false);
+			originalSerializer.serialize(record, target);
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T deserialize(DataInputView source) throws IOException &lt;/p&gt;
{
+		boolean isNull = deserializeNull(source);
+		return isNull ? null : originalSerializer.deserialize(source);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public T deserialize(T reuse, DataInputView source) throws IOException &lt;/p&gt;
{
+		boolean isNull = deserializeNull(source);
+		return isNull ? null : (reuse == null ?
+			originalSerializer.deserialize(source) : originalSerializer.deserialize(reuse, source));
+	}
&lt;p&gt;+&lt;br/&gt;
+	private boolean deserializeNull(DataInputView source) throws IOException {&lt;br/&gt;
+		boolean isNull = source.readBoolean();&lt;br/&gt;
+		if (isNull) &lt;/p&gt;
{
+			source.skipBytesToRead(padding.length);
+		}
&lt;p&gt;+		return isNull;&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public void copy(DataInputView source, DataOutputView target) throws IOException {&lt;br/&gt;
+		boolean isNull = source.readBoolean();&lt;br/&gt;
+		target.writeBoolean(isNull);&lt;br/&gt;
+		if (isNull) &lt;/p&gt;
{
+			target.write(padding);
+		}
&lt;p&gt; else &lt;/p&gt;
{
+			originalSerializer.copy(source, target);
+		}
&lt;p&gt;+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public boolean equals(Object obj) &lt;/p&gt;
{
+		return obj == this ||
+			(obj != null &amp;amp;&amp;amp; obj.getClass() == getClass() &amp;amp;&amp;amp;
+				originalSerializer.equals(((NullableSerializer) obj).originalSerializer));
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public boolean canEqual(Object obj) &lt;/p&gt;
{
+		return (obj != null &amp;amp;&amp;amp; obj.getClass() == getClass() &amp;amp;&amp;amp;
+			originalSerializer.canEqual(((NullableSerializer) obj).originalSerializer));
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public int hashCode() &lt;/p&gt;
{
+		return originalSerializer.hashCode();
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public NullableSerializerConfigSnapshot&amp;lt;T&amp;gt; snapshotConfiguration() &lt;/p&gt;
{
+		return new NullableSerializerConfigSnapshot&amp;lt;&amp;gt;(originalSerializer);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	public CompatibilityResult&amp;lt;T&amp;gt; ensureCompatibility(TypeSerializerConfigSnapshot configSnapshot) {&lt;br/&gt;
+		if (configSnapshot instanceof NullableSerializerConfigSnapshot) {&lt;br/&gt;
+			List&amp;lt;Tuple2&amp;lt;TypeSerializer&amp;lt;?&amp;gt;, TypeSerializerConfigSnapshot&amp;gt;&amp;gt; previousKvSerializersAndConfigs =&lt;br/&gt;
+				((NullableSerializerConfigSnapshot) configSnapshot).getNestedSerializersAndConfigs();&lt;br/&gt;
+&lt;br/&gt;
+			CompatibilityResult&amp;lt;T&amp;gt; compatResult = CompatibilityUtil.resolveCompatibilityResult(&lt;br/&gt;
+				previousKvSerializersAndConfigs.get(0).f0,&lt;br/&gt;
+				UnloadableDummyTypeSerializer.class,&lt;br/&gt;
+				previousKvSerializersAndConfigs.get(0).f1,&lt;br/&gt;
+				originalSerializer);&lt;br/&gt;
+&lt;br/&gt;
+			if (!compatResult.isRequiresMigration()) &lt;/p&gt;
{
+				return CompatibilityResult.compatible();
+			}
&lt;p&gt; else if (compatResult.getConvertDeserializer() != null) &lt;/p&gt;
{
+				return CompatibilityResult.requiresMigration(
+					new NullableSerializer&amp;lt;&amp;gt;(
+						new TypeDeserializerAdapter&amp;lt;&amp;gt;(compatResult.getConvertDeserializer()), padNullValue()));
+			}
&lt;p&gt;+		}&lt;br/&gt;
+&lt;br/&gt;
+		return CompatibilityResult.requiresMigration();&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	/**&lt;br/&gt;
+	 * Configuration snapshot for serializers of nullable types, containing the&lt;br/&gt;
+	 * configuration snapshot of its original serializer.&lt;br/&gt;
+	 */&lt;br/&gt;
+	@Internal&lt;br/&gt;
+	public static class NullableSerializerConfigSnapshot&amp;lt;T&amp;gt; extends CompositeTypeSerializerConfigSnapshot {&lt;br/&gt;
+		private static final int VERSION = 1;&lt;br/&gt;
+&lt;br/&gt;
+		/** This empty nullary constructor is required for deserializing the configuration. */&lt;br/&gt;
+		@SuppressWarnings(&quot;unused&quot;)&lt;br/&gt;
+		public NullableSerializerConfigSnapshot() {}&lt;br/&gt;
+&lt;br/&gt;
+		NullableSerializerConfigSnapshot(TypeSerializer&amp;lt;T&amp;gt; originalSerializer) &lt;/p&gt;
{
+			super(originalSerializer);
+		}
&lt;p&gt;+&lt;br/&gt;
+		@Override&lt;br/&gt;
+		public int getVersion() &lt;/p&gt;
{
+			return VERSION;
+		}
&lt;p&gt;+	}&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/flink-core/src/test/java/org/apache/flink/api/common/typeutils/SerializerTestBase.java b/flink-core/src/test/java/org/apache/flink/api/common/typeutils/SerializerTestBase.java&lt;br/&gt;
index 57015c78be0..1997866fb3c 100644&lt;br/&gt;
&amp;#8212; a/flink-core/src/test/java/org/apache/flink/api/common/typeutils/SerializerTestBase.java&lt;br/&gt;
+++ b/flink-core/src/test/java/org/apache/flink/api/common/typeutils/SerializerTestBase.java&lt;br/&gt;
@@ -32,6 +32,7 @@&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.util.Arrays;&lt;/p&gt;

&lt;p&gt;+import org.apache.flink.api.java.typeutils.runtime.NullableSerializer;&lt;br/&gt;
 import org.apache.flink.core.memory.DataInputViewStreamWrapper;&lt;br/&gt;
 import org.apache.flink.core.memory.DataOutputViewStreamWrapper;&lt;br/&gt;
 import org.apache.flink.util.InstantiationUtil;&lt;br/&gt;
@@ -53,23 +54,23 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;internal state would be corrupt, which becomes evident when toString is called.&lt;br/&gt;
  */&lt;br/&gt;
 public abstract class SerializerTestBase&amp;lt;T&amp;gt; extends TestLogger {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	protected abstract TypeSerializer&amp;lt;T&amp;gt; createSerializer();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Gets the expected length for the serializer&apos;s 
{@link TypeSerializer#getLength()}
&lt;p&gt; method.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
+	 *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;The expected length should be positive, for fix-length data types, or 
{@code -1}
&lt;p&gt; for&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;variable-length types.&lt;br/&gt;
 	 */&lt;br/&gt;
 	protected abstract int getLength();&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	protected abstract Class&amp;lt;T&amp;gt; getTypeClass();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	protected abstract T[] getTestData();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	// --------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testInstantiate() {&lt;br/&gt;
 		try {&lt;br/&gt;
@@ -80,13 +81,13 @@ public void testInstantiate() {&lt;br/&gt;
 			}&lt;br/&gt;
 			T instance = serializer.createInstance();&lt;br/&gt;
 			assertNotNull(&quot;The created instance must not be null.&quot;, instance);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			Class&amp;lt;T&amp;gt; type = getTypeClass();&lt;br/&gt;
 			assertNotNull(&quot;The test is corrupt: type class is null.&quot;, type);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 			if (!type.isAssignableFrom(instance.getClass())) &lt;/p&gt;
{
 				fail(&quot;Type of the instantiated object is wrong. &quot; +
-						&quot;Expected Type: &quot; + type + &quot; present type &quot; + instance.getClass());
+					&quot;Expected Type: &quot; + type + &quot; present type &quot; + instance.getClass());
 			}
&lt;p&gt; 		}&lt;br/&gt;
 		catch (Exception e) {&lt;br/&gt;
@@ -127,7 +128,7 @@ public void testSnapshotConfigurationAndReconfigure() throws Exception &lt;/p&gt;
{
 		strategy = getSerializer().ensureCompatibility(new TestIncompatibleSerializerConfigSnapshot());
 		assertTrue(strategy.isRequiresMigration());
 	}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testGetLength() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: { 		final int len = getLength();@@ -146,16 +147,16 @@ public void testGetLength() {
 			fail(&quot;Exception in test: &quot; + e.getMessage());
 		} 	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testCopy() {&lt;br/&gt;
 		try {&lt;br/&gt;
 			TypeSerializer&amp;lt;T&amp;gt; serializer = getSerializer();&lt;br/&gt;
 			T[] testData = getData();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			for (T datum : testData) &lt;/p&gt;
{
 				T copy = serializer.copy(datum);
-				copy.toString();
+				checkToString(copy);
 				deepEquals(&quot;Copied element is not equal to the original element.&quot;, datum, copy);
 			}
&lt;p&gt; 		}&lt;br/&gt;
@@ -165,16 +166,16 @@ public void testCopy() &lt;/p&gt;
{
 			fail(&quot;Exception in test: &quot; + e.getMessage());
 		}
&lt;p&gt; 	}&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testCopyIntoNewElements() {&lt;br/&gt;
 		try {&lt;br/&gt;
 			TypeSerializer&amp;lt;T&amp;gt; serializer = getSerializer();&lt;br/&gt;
 			T[] testData = getData();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			for (T datum : testData) &lt;/p&gt;
{
 				T copy = serializer.copy(datum, serializer.createInstance());
-				copy.toString();
+				checkToString(copy);
 				deepEquals(&quot;Copied element is not equal to the original element.&quot;, datum, copy);
 			}
&lt;p&gt; 		}&lt;br/&gt;
@@ -184,18 +185,18 @@ public void testCopyIntoNewElements() &lt;/p&gt;
{
 			fail(&quot;Exception in test: &quot; + e.getMessage());
 		}
&lt;p&gt; 	}&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testCopyIntoReusedElements() {&lt;br/&gt;
 		try {&lt;br/&gt;
 			TypeSerializer&amp;lt;T&amp;gt; serializer = getSerializer();&lt;br/&gt;
 			T[] testData = getData();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			T target = serializer.createInstance();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			for (T datum : testData) &lt;/p&gt;
{
 				T copy = serializer.copy(datum, target);
-				copy.toString();
+				checkToString(copy);
 				deepEquals(&quot;Copied element is not equal to the original element.&quot;, datum, copy);
 				target = copy;
 			}
&lt;p&gt;@@ -206,25 +207,25 @@ public void testCopyIntoReusedElements() &lt;/p&gt;
{
 			fail(&quot;Exception in test: &quot; + e.getMessage());
 		}
&lt;p&gt; 	}&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testSerializeIndividually() {&lt;br/&gt;
 		try {&lt;br/&gt;
 			TypeSerializer&amp;lt;T&amp;gt; serializer = getSerializer();&lt;br/&gt;
 			T[] testData = getData();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			for (T value : testData) &lt;/p&gt;
{
 				TestOutputView out = new TestOutputView();
 				serializer.serialize(value, out);
 				TestInputView in = out.getInputView();
-				
+
 				assertTrue(&quot;No data available during deserialization.&quot;, in.available() &amp;gt; 0);
-				
+
 				T deserialized = serializer.deserialize(serializer.createInstance(), in);
- 				deserialized.toString();
+				checkToString(deserialized);
 
 				deepEquals(&quot;Deserialized value if wrong.&quot;, value, deserialized);
-				
+
 				assertTrue(&quot;Trailing data available after deserialization.&quot;, in.available() == 0);
 			}
&lt;p&gt; 		}&lt;br/&gt;
@@ -241,23 +242,23 @@ public void testSerializeIndividuallyReusingValues() {&lt;br/&gt;
 		try {&lt;br/&gt;
 			TypeSerializer&amp;lt;T&amp;gt; serializer = getSerializer();&lt;br/&gt;
 			T[] testData = getData();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			T reuseValue = serializer.createInstance();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			for (T value : testData) &lt;/p&gt;
{
 				TestOutputView out = new TestOutputView();
 				serializer.serialize(value, out);
 				TestInputView in = out.getInputView();
-				
+
 				assertTrue(&quot;No data available during deserialization.&quot;, in.available() &amp;gt; 0);
-				
+
 				T deserialized = serializer.deserialize(reuseValue, in);
-				deserialized.toString();
+				checkToString(deserialized);
 
 				deepEquals(&quot;Deserialized value if wrong.&quot;, value, deserialized);
-				
+
 				assertTrue(&quot;Trailing data available after deserialization.&quot;, in.available() == 0);
-				
+
 				reuseValue = deserialized;
 			}
&lt;p&gt; 		}&lt;br/&gt;
@@ -267,29 +268,29 @@ public void testSerializeIndividuallyReusingValues() &lt;/p&gt;
{
 			fail(&quot;Exception in test: &quot; + e.getMessage());
 		}
&lt;p&gt; 	}&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testSerializeAsSequenceNoReuse() {&lt;br/&gt;
 		try {&lt;br/&gt;
 			TypeSerializer&amp;lt;T&amp;gt; serializer = getSerializer();&lt;br/&gt;
 			T[] testData = getData();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			TestOutputView out = new TestOutputView();&lt;br/&gt;
 			for (T value : testData) &lt;/p&gt;
{
 				serializer.serialize(value, out);
 			}&lt;br/&gt;
-			&lt;br/&gt;
+&lt;br/&gt;
 			TestInputView in = out.getInputView();&lt;br/&gt;
-			&lt;br/&gt;
+&lt;br/&gt;
 			int num = 0;&lt;br/&gt;
 			while (in.available() &amp;gt; 0) {
 				T deserialized = serializer.deserialize(in);
-				deserialized.toString();
+				checkToString(deserialized);
 
 				deepEquals(&quot;Deserialized value if wrong.&quot;, testData[num], deserialized);
 				num++;
 			}&lt;br/&gt;
-			&lt;br/&gt;
+&lt;br/&gt;
 			assertEquals(&quot;Wrong number of elements deserialized.&quot;, testData.length, num);&lt;br/&gt;
 		}&lt;br/&gt;
 		catch (Exception e) {&lt;br/&gt;
@@ -298,31 +299,31 @@ public void testSerializeAsSequenceNoReuse() {
 			fail(&quot;Exception in test: &quot; + e.getMessage());
 		}&lt;br/&gt;
 	}&lt;br/&gt;
-	&lt;br/&gt;
+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testSerializeAsSequenceReusingValues() {&lt;br/&gt;
 		try {&lt;br/&gt;
 			TypeSerializer&amp;lt;T&amp;gt; serializer = getSerializer();&lt;br/&gt;
 			T[] testData = getData();&lt;br/&gt;
-			&lt;br/&gt;
+&lt;br/&gt;
 			TestOutputView out = new TestOutputView();&lt;br/&gt;
 			for (T value : testData) { 				serializer.serialize(value, out); 			}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			TestInputView in = out.getInputView();&lt;br/&gt;
 			T reuseValue = serializer.createInstance();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			int num = 0;&lt;br/&gt;
 			while (in.available() &amp;gt; 0) &lt;/p&gt;
{
 				T deserialized = serializer.deserialize(reuseValue, in);
-				deserialized.toString();
+				checkToString(deserialized);
 
 				deepEquals(&quot;Deserialized value if wrong.&quot;, testData[num], deserialized);
 				reuseValue = deserialized;
 				num++;
 			}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			assertEquals(&quot;Wrong number of elements deserialized.&quot;, testData.length, num);&lt;br/&gt;
 		}&lt;br/&gt;
 		catch (Exception e) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {@@ -331,30 +332,30 @@ public void testSerializeAsSequenceReusingValues() {
 			fail(&quot;Exception in test: &quot; + e.getMessage());
 		} 	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testSerializedCopyIndividually() {&lt;br/&gt;
 		try {&lt;br/&gt;
 			TypeSerializer&amp;lt;T&amp;gt; serializer = getSerializer();&lt;br/&gt;
 			T[] testData = getData();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			for (T value : testData) &lt;/p&gt;
{
 				TestOutputView out = new TestOutputView();
 				serializer.serialize(value, out);
-				
+
 				TestInputView source = out.getInputView();
 				TestOutputView target = new TestOutputView();
 				serializer.copy(source, target);
-				
+
 				TestInputView toVerify = target.getInputView();
-				
+
 				assertTrue(&quot;No data available copying.&quot;, toVerify.available() &amp;gt; 0);
-				
+
 				T deserialized = serializer.deserialize(serializer.createInstance(), toVerify);
-				deserialized.toString();
+				checkToString(deserialized);
 
 				deepEquals(&quot;Deserialized value if wrong.&quot;, value, deserialized);
-				
+
 				assertTrue(&quot;Trailing data available after deserialization.&quot;, toVerify.available() == 0);
 			}
&lt;p&gt; 		}&lt;br/&gt;
@@ -364,36 +365,36 @@ public void testSerializedCopyIndividually() &lt;/p&gt;
{
 			fail(&quot;Exception in test: &quot; + e.getMessage());
 		}
&lt;p&gt; 	}&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testSerializedCopyAsSequence() {&lt;br/&gt;
 		try {&lt;br/&gt;
 			TypeSerializer&amp;lt;T&amp;gt; serializer = getSerializer();&lt;br/&gt;
 			T[] testData = getData();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			TestOutputView out = new TestOutputView();&lt;br/&gt;
 			for (T value : testData) &lt;/p&gt;
{
 				serializer.serialize(value, out);
 			}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			TestInputView source = out.getInputView();&lt;br/&gt;
 			TestOutputView target = new TestOutputView();&lt;br/&gt;
 			for (int i = 0; i &amp;lt; testData.length; i++) &lt;/p&gt;
{
 				serializer.copy(source, target);
 			}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			TestInputView toVerify = target.getInputView();&lt;br/&gt;
 			int num = 0;&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			while (toVerify.available() &amp;gt; 0) &lt;/p&gt;
{
 				T deserialized = serializer.deserialize(serializer.createInstance(), toVerify);
-				deserialized.toString();
+				checkToString(deserialized);
 
 				deepEquals(&quot;Deserialized value if wrong.&quot;, testData[num], deserialized);
 				num++;
 			}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			assertEquals(&quot;Wrong number of elements copied.&quot;, testData.length, num);&lt;br/&gt;
 		}&lt;br/&gt;
 		catch (Exception e) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {@@ -402,7 +403,7 @@ public void testSerializedCopyAsSequence() {
 			fail(&quot;Exception in test: &quot; + e.getMessage());
 		} 	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	@Test&lt;br/&gt;
 	public void testSerializabilityAndEquals() {&lt;br/&gt;
 		try {&lt;br/&gt;
@@ -414,7 +415,7 @@ public void testSerializabilityAndEquals() &lt;/p&gt;
{
 				fail(&quot;The serializer is not serializable: &quot; + e);
 				return;
 			}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 			assertEquals(&quot;The copy of the serializer is not equal to the original one.&quot;, ser1, ser2);&lt;br/&gt;
 		}&lt;br/&gt;
 		catch (Exception e) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {@@ -423,10 +424,26 @@ public void testSerializabilityAndEquals() {
 			fail(&quot;Exception in test: &quot; + e.getMessage());
 		} 	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testNullability() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+		TypeSerializer&amp;lt;T&amp;gt; serializer = getSerializer();+		try {
+			NullableSerializer.checkIfNullSupported(serializer);
+		} catch (Throwable t) {
+			System.err.println(t.getMessage());
+			t.printStackTrace();
+			fail(&quot;Unexpected failure of null value handling: &quot; + t.getMessage());
+		}+	}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
 	// --------------------------------------------------------------------------------------------&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	protected void deepEquals(String message, T should, T is) {&lt;br/&gt;
+		Assert.assertTrue((should == null &amp;amp;&amp;amp; is == null) || (should != null &amp;amp;&amp;amp; is != null));&lt;br/&gt;
+		if (should == null) &lt;/p&gt;
{
+			return;
+		}
&lt;p&gt; 		if (should.getClass().isArray()) {&lt;br/&gt;
 			if (should instanceof boolean[]) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: { 				Assert.assertTrue(message, Arrays.equals((boolean[]) should, (boolean[]) is));@@ -463,9 +480,9 @@ else if (should instanceof Throwable) {
 			assertEquals(message,  should, is);
 		} 	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	// --------------------------------------------------------------------------------------------&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	protected TypeSerializer&amp;lt;T&amp;gt; getSerializer() {&lt;br/&gt;
 		TypeSerializer&amp;lt;T&amp;gt; serializer = createSerializer();&lt;br/&gt;
 		if (serializer == null) {&lt;br/&gt;
@@ -473,7 +490,7 @@ else if (should instanceof Throwable) {&lt;br/&gt;
 		}&lt;br/&gt;
 		return serializer;&lt;br/&gt;
 	}&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	private T[] getData() {&lt;br/&gt;
 		T[] data = getTestData();&lt;br/&gt;
 		if (data == null) {&lt;br/&gt;
@@ -481,15 +498,15 @@ else if (should instanceof Throwable) {&lt;br/&gt;
 		}&lt;br/&gt;
 		return data;&lt;br/&gt;
 	}&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	// --------------------------------------------------------------------------------------------&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 	private static final class TestOutputView extends DataOutputStream implements DataOutputView {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 		public TestOutputView() &lt;/p&gt;
{
 			super(new ByteArrayOutputStream(4096));
 		}&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
 		public TestInputView getInputView() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: { 			ByteArrayOutputStream baos = (ByteArrayOutputStream) out; 			return new TestInputView(baos.toByteArray());@@ -509,8 +526,8 @@ public void write(DataInputView source, int numBytes) throws IOException {
 			write(buffer);
 		} 	}&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
+&lt;br/&gt;
 	private static final class TestInputView extends DataInputStream implements DataInputView {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		public TestInputView(byte[] data) {&lt;br/&gt;
@@ -542,4 +559,10 @@ public int hashCode() &lt;/p&gt;
{
 			return getClass().hashCode();
 		}
&lt;p&gt; 	}&lt;br/&gt;
+&lt;br/&gt;
+	private static &amp;lt;T&amp;gt; void checkToString(T value) {&lt;br/&gt;
+		if (value != null) &lt;/p&gt;
{
+			value.toString();
+		}
&lt;p&gt;+	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializerTest.java b/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializerTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..3bd176a8fbc&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-core/src/test/java/org/apache/flink/api/java/typeutils/runtime/NullableSerializerTest.java&lt;br/&gt;
@@ -0,0 +1,87 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.api.java.typeutils.runtime;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.SerializerTestBase;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.TypeSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.base.IntSerializer;&lt;br/&gt;
+import org.apache.flink.api.common.typeutils.base.StringSerializer;&lt;br/&gt;
+&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+import org.junit.runner.RunWith;&lt;br/&gt;
+import org.junit.runners.Parameterized;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Arrays;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertEquals;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+&lt;br/&gt;
+/** Unit tests for &lt;/p&gt;
{@link NullableSerializer}
&lt;p&gt;. */&lt;br/&gt;
+@RunWith(Parameterized.class)&lt;br/&gt;
+public class NullableSerializerTest extends SerializerTestBase&amp;lt;Integer&amp;gt; {&lt;br/&gt;
+	private static final TypeSerializer&amp;lt;Integer&amp;gt; originalSerializer = IntSerializer.INSTANCE;&lt;br/&gt;
+&lt;br/&gt;
+	@Parameterized.Parameters(name = &quot;&lt;/p&gt;
{0}
&lt;p&gt;&quot;)&lt;br/&gt;
+	public static List&amp;lt;Boolean&amp;gt; whetherToPadNullValue() &lt;/p&gt;
{
+		return Arrays.asList(true, false);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Parameterized.Parameter&lt;br/&gt;
+	public boolean padNullValue;&lt;br/&gt;
+&lt;br/&gt;
+	private TypeSerializer&amp;lt;Integer&amp;gt; nullableSerializer;&lt;br/&gt;
+&lt;br/&gt;
+	@Before&lt;br/&gt;
+	public void init() &lt;/p&gt;
{
+		nullableSerializer = NullableSerializer.wrapIfNullIsNotSupported(originalSerializer, padNullValue);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	protected TypeSerializer&amp;lt;Integer&amp;gt; createSerializer() &lt;/p&gt;
{
+		return NullableSerializer.wrapIfNullIsNotSupported(originalSerializer, padNullValue);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	protected int getLength() &lt;/p&gt;
{
+		return padNullValue ? 5 : -1;
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	protected Class&amp;lt;Integer&amp;gt; getTypeClass() &lt;/p&gt;
{
+		return Integer.class;
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Override&lt;br/&gt;
+	protected Integer[] getTestData() {&lt;br/&gt;
+		return new Integer[] &lt;/p&gt;
{ 5, -1, 0, null }
&lt;p&gt;;&lt;br/&gt;
+	}&lt;br/&gt;
+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testWrappingNotNeeded() &lt;/p&gt;
{
+		assertEquals(NullableSerializer.wrapIfNullIsNotSupported(StringSerializer.INSTANCE, padNullValue), StringSerializer.INSTANCE);
+	}
&lt;p&gt;+&lt;br/&gt;
+	@Test&lt;br/&gt;
+	public void testWrappingNeeded() &lt;/p&gt;
{
+		assertTrue(nullableSerializer instanceof NullableSerializer);
+		assertEquals(NullableSerializer.wrapIfNullIsNotSupported(nullableSerializer, padNullValue), nullableSerializer);
+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/AbstractTtlDecorator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/AbstractTtlDecorator.java&lt;br/&gt;
index 268f84aaa9b..3b0a99f782c 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/AbstractTtlDecorator.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/AbstractTtlDecorator.java&lt;br/&gt;
@@ -78,6 +78,14 @@&lt;br/&gt;
 	}&lt;/p&gt;

&lt;p&gt; 	&amp;lt;SE extends Throwable, CE extends Throwable, CLE extends Throwable, V&amp;gt; V getWithTtlCheckAndUpdate(&lt;br/&gt;
+		SupplierWithException&amp;lt;TtlValue&amp;lt;V&amp;gt;, SE&amp;gt; getter,&lt;br/&gt;
+		ThrowingConsumer&amp;lt;TtlValue&amp;lt;V&amp;gt;, CE&amp;gt; updater,&lt;br/&gt;
+		ThrowingRunnable&amp;lt;CLE&amp;gt; stateClear) throws SE, CE, CLE &lt;/p&gt;
{
+		TtlValue&amp;lt;V&amp;gt; ttlValue = getWrappedWithTtlCheckAndUpdate(getter, updater, stateClear);
+		return ttlValue == null ? null : ttlValue.getUserValue();
+	}
&lt;p&gt;+&lt;br/&gt;
+	&amp;lt;SE extends Throwable, CE extends Throwable, CLE extends Throwable, V&amp;gt; TtlValue&amp;lt;V&amp;gt; getWrappedWithTtlCheckAndUpdate(&lt;br/&gt;
 		SupplierWithException&amp;lt;TtlValue&amp;lt;V&amp;gt;, SE&amp;gt; getter,&lt;br/&gt;
 		ThrowingConsumer&amp;lt;TtlValue&amp;lt;V&amp;gt;, CE&amp;gt; updater,&lt;br/&gt;
 		ThrowingRunnable&amp;lt;CLE&amp;gt; stateClear) throws SE, CE, CLE &lt;/p&gt;
{
@@ -92,6 +100,6 @@
 		}
&lt;p&gt; else if (updateTsOnRead) &lt;/p&gt;
{
 			updater.accept(rewrapWithNewTs(ttlValue));
 		}
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return ttlValue.getUserValue();&lt;br/&gt;
+		return ttlValue;&lt;br/&gt;
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlMapState.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlMapState.java&lt;br/&gt;
index 160dbeb71e9..f84a2ee4820 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlMapState.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlMapState.java&lt;br/&gt;
@@ -54,7 +54,13 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	@Override&lt;br/&gt;
 	public UV get(UK key) throws Exception &lt;/p&gt;
{
-		return getWithTtlCheckAndUpdate(() -&amp;gt; original.get(key), v -&amp;gt; original.put(key, v), () -&amp;gt; original.remove(key));
+		TtlValue&amp;lt;UV&amp;gt; ttlValue = getWrapped(key);
+		return ttlValue == null ? null : ttlValue.getUserValue();
+	}
&lt;p&gt;+&lt;br/&gt;
+	private TtlValue&amp;lt;UV&amp;gt; getWrapped(UK key) throws Exception &lt;/p&gt;
{
+		return getWrappedWithTtlCheckAndUpdate(
+			() -&amp;gt; original.get(key), v -&amp;gt; original.put(key, v), () -&amp;gt; original.remove(key));
 	}

&lt;p&gt; 	@Override&lt;br/&gt;
@@ -83,7 +89,8 @@ public void remove(UK key) throws Exception {&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	public boolean contains(UK key) throws Exception &lt;/p&gt;
{
-		return get(key) != null;
+		TtlValue&amp;lt;UV&amp;gt; ttlValue = getWrapped(key);
+		return ttlValue != null;
 	}

&lt;p&gt; 	@Override&lt;br/&gt;
@@ -161,16 +168,16 @@ public void remove() {&lt;br/&gt;
 		}&lt;/p&gt;

&lt;p&gt; 		private Map.Entry&amp;lt;UK, UV&amp;gt; getUnexpiredAndUpdateOrCleanup(Map.Entry&amp;lt;UK, TtlValue&amp;lt;UV&amp;gt;&amp;gt; e) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;UV unexpiredValue;&lt;br/&gt;
+			TtlValue&amp;lt;UV&amp;gt; unexpiredValue;&lt;br/&gt;
 			try 
{
-				unexpiredValue = getWithTtlCheckAndUpdate(
+				unexpiredValue = getWrappedWithTtlCheckAndUpdate(
 					e::getValue,
 					v -&amp;gt; original.put(e.getKey(), v),
 					originalIterator::remove);
 			}
&lt;p&gt; catch (Exception ex) &lt;/p&gt;
{
 				throw new FlinkRuntimeException(ex);
 			}&lt;/li&gt;
	&lt;li&gt;return unexpiredValue == null ? null : new AbstractMap.SimpleEntry&amp;lt;&amp;gt;(e.getKey(), unexpiredValue);&lt;br/&gt;
+			return unexpiredValue == null ? null : new AbstractMap.SimpleEntry&amp;lt;&amp;gt;(e.getKey(), unexpiredValue.getUserValue());&lt;br/&gt;
 		}&lt;br/&gt;
 	}&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlUtils.java&lt;br/&gt;
index 773fe7c4474..be231c63428 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlUtils.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlUtils.java&lt;br/&gt;
@@ -44,6 +44,6 @@ private static long getExpirationTimestamp(long ts, long ttl) {&lt;br/&gt;
 	}&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 	static &amp;lt;V&amp;gt; TtlValue&amp;lt;V&amp;gt; wrapWithTs(V value, long ts) &lt;/p&gt;
{
-		return value == null ? null : new TtlValue&amp;lt;&amp;gt;(value, ts);
+		return new TtlValue&amp;lt;&amp;gt;(value, ts);
 	}
&lt;p&gt; }&lt;br/&gt;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlValue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlValue.java&lt;br/&gt;
index a8bcadf9d19..48435d567e8 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlValue.java&lt;br/&gt;
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/ttl/TtlValue.java&lt;br/&gt;
@@ -18,7 +18,7 @@&lt;/p&gt;

&lt;p&gt; package org.apache.flink.runtime.state.ttl;&lt;/p&gt;

&lt;p&gt;-import org.apache.flink.util.Preconditions;&lt;br/&gt;
+import javax.annotation.Nullable;&lt;/p&gt;

&lt;p&gt; import java.io.Serializable;&lt;/p&gt;

&lt;p&gt;@@ -30,15 +30,16 @@&lt;br/&gt;
 class TtlValue&amp;lt;T&amp;gt; implements Serializable {&lt;br/&gt;
 	private static final long serialVersionUID = 5221129704201125020L;&lt;/p&gt;

&lt;p&gt;+	@Nullable&lt;br/&gt;
 	private final T userValue;&lt;br/&gt;
 	private final long lastAccessTimestamp;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TtlValue(T userValue, long lastAccessTimestamp) {&lt;/li&gt;
	&lt;li&gt;Preconditions.checkNotNull(userValue);&lt;br/&gt;
+	TtlValue(@Nullable T userValue, long lastAccessTimestamp) 
{
 		this.userValue = userValue;
 		this.lastAccessTimestamp = lastAccessTimestamp;
 	}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+	@Nullable&lt;br/&gt;
 	T getUserValue() &lt;/p&gt;
{
 		return userValue;
 	}
&lt;p&gt;diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlMapStateAllEntriesTestContext.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlMapStateAllEntriesTestContext.java&lt;br/&gt;
index 7fd61aaeb29..7294b4aa747 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlMapStateAllEntriesTestContext.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlMapStateAllEntriesTestContext.java&lt;br/&gt;
@@ -22,6 +22,7 @@&lt;/p&gt;

&lt;p&gt; import java.util.Arrays;&lt;br/&gt;
 import java.util.Collections;&lt;br/&gt;
+import java.util.HashMap;&lt;br/&gt;
 import java.util.Map;&lt;br/&gt;
 import java.util.Set;&lt;br/&gt;
 import java.util.stream.Collectors;&lt;br/&gt;
@@ -35,9 +36,9 @@&lt;br/&gt;
 	void initTestValues() {&lt;br/&gt;
 		emptyValue = Collections.emptySet();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;updateEmpty = mapOf(Tuple2.of(3, &quot;3&quot;), Tuple2.of(5, &quot;5&quot;), Tuple2.of(10, &quot;10&quot;));&lt;/li&gt;
	&lt;li&gt;updateUnexpired = mapOf(Tuple2.of(12, &quot;12&quot;), Tuple2.of(7, &quot;7&quot;));&lt;/li&gt;
	&lt;li&gt;updateExpired = mapOf(Tuple2.of(15, &quot;15&quot;), Tuple2.of(4, &quot;4&quot;));&lt;br/&gt;
+		updateEmpty = mapOf(Tuple2.of(3, &quot;3&quot;), Tuple2.of(5, &quot;5&quot;), Tuple2.of(23, null), Tuple2.of(10, &quot;10&quot;));&lt;br/&gt;
+		updateUnexpired = mapOf(Tuple2.of(12, &quot;12&quot;), Tuple2.of(24, null), Tuple2.of(7, &quot;7&quot;));&lt;br/&gt;
+		updateExpired = mapOf(Tuple2.of(15, &quot;15&quot;), Tuple2.of(25, null), Tuple2.of(4, &quot;4&quot;));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 		getUpdateEmpty = updateEmpty.entrySet();&lt;br/&gt;
 		getUnexpired = updateUnexpired.entrySet();&lt;br/&gt;
@@ -46,7 +47,9 @@ void initTestValues() {&lt;/p&gt;

&lt;p&gt; 	@SafeVarargs&lt;br/&gt;
 	private static &amp;lt;UK, UV&amp;gt; Map&amp;lt;UK, UV&amp;gt; mapOf(Tuple2&amp;lt;UK, UV&amp;gt; ... entries) &lt;/p&gt;
{
-		return Arrays.stream(entries).collect(Collectors.toMap(t -&amp;gt; t.f0, t -&amp;gt; t.f1));
+		Map&amp;lt;UK, UV&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
+		Arrays.stream(entries).forEach(t -&amp;gt; map.put(t.f0, t.f1));
+		return map;
 	}

&lt;p&gt; 	@Override&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlMapStatePerElementTestContext.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlMapStatePerElementTestContext.java&lt;br/&gt;
index fb025afd9ad..a77c8ed958c 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlMapStatePerElementTestContext.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlMapStatePerElementTestContext.java&lt;br/&gt;
@@ -43,7 +43,10 @@ void update(String value) throws Exception {&lt;/p&gt;

&lt;p&gt; 	@Override&lt;br/&gt;
 	String get() throws Exception &lt;/p&gt;
{
-		return ttlState.get(TEST_KEY);
+		String value = ttlState.get(TEST_KEY);
+		assert (getOriginal() == null &amp;amp;&amp;amp; !ttlState.contains(TEST_KEY)) ||
+			(getOriginal() != null &amp;amp;&amp;amp; ttlState.contains(TEST_KEY));
+		return value;
 	}

&lt;p&gt; 	@Override&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlMapStatePerNullElementTestContext.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlMapStatePerNullElementTestContext.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..6f8c70bcb63&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlMapStatePerNullElementTestContext.java&lt;br/&gt;
@@ -0,0 +1,32 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.flink.runtime.state.ttl;&lt;br/&gt;
+&lt;br/&gt;
+class TtlMapStatePerNullElementTestContext extends TtlMapStatePerElementTestContext {&lt;br/&gt;
+	@Override&lt;br/&gt;
+	void initTestValues() &lt;/p&gt;
{
+		updateEmpty = null;
+		updateUnexpired = null;
+		updateExpired = null;
+
+		getUpdateEmpty = null;
+		getUnexpired = null;
+		getUpdateExpired = null;
+	}
&lt;p&gt;+}&lt;br/&gt;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlStateTestBase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlStateTestBase.java&lt;br/&gt;
index 6b3a15fdd30..f9f108a3a12 100644&lt;br/&gt;
&amp;#8212; a/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlStateTestBase.java&lt;br/&gt;
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/ttl/TtlStateTestBase.java&lt;br/&gt;
@@ -69,6 +69,7 @@ public void setup() {&lt;br/&gt;
 			new TtlListStateTestContext(),&lt;br/&gt;
 			new TtlMapStateAllEntriesTestContext(),&lt;br/&gt;
 			new TtlMapStatePerElementTestContext(),&lt;br/&gt;
+			new TtlMapStatePerNullElementTestContext(),&lt;br/&gt;
 			new TtlAggregatingStateTestContext(),&lt;br/&gt;
 			new TtlReducingStateTestContext(),&lt;br/&gt;
 			new TtlFoldingStateTestContext());&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16623625" author="srichter" created="Fri, 21 Sep 2018 13:35:18 +0000"  >&lt;p&gt;Merged in:&lt;br/&gt;
master: f3432042fe&lt;br/&gt;
release-1.6: 3558d1586c&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13186271">FLINK-10374</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12935822" name="StateWithOutTtlTest.scala" size="1355" author="wucj" created="Thu, 16 Aug 2018 07:50:27 +0000"/>
                            <attachment id="12935823" name="StateWithTtlTest.scala" size="1701" author="wucj" created="Thu, 16 Aug 2018 07:50:16 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 8 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3x3sn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>