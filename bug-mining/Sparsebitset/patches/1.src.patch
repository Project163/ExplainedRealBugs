diff --git a/pom.xml b/pom.xml
index 84c6e2f..b764c9a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -50,7 +50,7 @@
       <dependency>
          <groupId>junit</groupId>
          <artifactId>junit</artifactId>
-         <version>3.8.1</version>
+         <version>4.12</version>
          <scope>test</scope>
       </dependency>
    </dependencies>
diff --git a/src/main/java/com/zaxxer/sparsebits/SparseBitSet.java b/src/main/java/com/zaxxer/sparsebits/SparseBitSet.java
index 9c266cd..b0ae450 100644
--- a/src/main/java/com/zaxxer/sparsebits/SparseBitSet.java
+++ b/src/main/java/com/zaxxer/sparsebits/SparseBitSet.java
@@ -12,7 +12,7 @@ import java.io.Serializable;
 /**
  *  This class implements a set of bits that grows as needed. Each bit of the
  *  bit set represents a <code>boolean</code> value. The values of a
- *  <code>SparseBitSet</code> are indexed by nonnegative integers.
+ *  <code>SparseBitSet</code> are indexed by non-negative integers.
  *  Individual indexed values may be examined, set, cleared, or modified by
  *  logical operations. One <code>SparseBitSet</code> or logical value may be
  *  used to modify the contents of (another) <code>SparseBitSet</code> through
@@ -31,9 +31,9 @@ import java.io.Serializable;
  *  <code>SparseBitSet</code> are labelled <code>
  *  0</code>&nbsp;..&nbsp;<code>Integer.MAX_VALUE&nbsp;&minus;&nbsp;1</code>.
  *  After the last set bit of a <code>SparseBitSet</code>, any attempt to find
- *  a subsequent bit (<i>getNextSetBit</i>()), will return an value of &minus;1.
- *  If an attempt is made to use <i>getNextClearBit</i>(), and all the bits are
- *  set from the starting postion of the search to the bit labelled
+ *  a subsequent bit (<i>nextSetBit</i>()), will return an value of &minus;1.
+ *  If an attempt is made to use <i>nextClearBit</i>(), and all the bits are
+ *  set from the starting position of the search to the bit labelled
  *  <code>Integer.MAX_VALUE&nbsp;&minus;&nbsp;1</code>, then similarly &minus;1
  *  will be returned.
  *  <p>
@@ -41,7 +41,7 @@ import java.io.Serializable;
  *  a <code>SparseBitSet</code> will result in a
  *  <code>NullPointerException</code>.
  *  <p>
- *  A <code>SparseBitSet</code> is not safe for multithreaded use without
+ *  A <code>SparseBitSet</code> is not safe for multi-threaded use without
  *  external synchronization.
  *
  * @author      Bruce K. Haddon
@@ -592,7 +592,7 @@ public class SparseBitSet implements Cloneable, Serializable
         setScanner(i, j, null, clearStrategy);
     }
 
-    /** 
+    /**
      *  Sets all of the bits in this <code>SparseBitSet</code> to
      *  <code>false</code>.
      *
@@ -651,8 +651,8 @@ public class SparseBitSet implements Cloneable, Serializable
 
     /**
      *  Compares this object against the specified object. The result is
-     *  <code>true</code> if and only if the argument is not <code>null</code> 
-     *  and is a <code>SparseBitSet</code> object that has exactly the same bits 
+     *  <code>true</code> if and only if the argument is not <code>null</code>
+     *  and is a <code>SparseBitSet</code> object that has exactly the same bits
      *  set to <code>true</code> as this bit set. That is, for every nonnegative
      *  <code>i</code> indexing a bit in the set,
      *  <pre>((SparseBitSet)obj).get(i) == this.get(i)</pre>
@@ -1011,6 +1011,138 @@ public class SparseBitSet implements Cloneable, Serializable
                         + Long.numberOfTrailingZeros(word));
     }
 
+    /**
+     * Returns the index of the nearest bit that is set to {@code false}
+     * that occurs on or before the specified starting index.
+     * If no such bit exists, or if {@code -1} is given as the
+     * starting index, then {@code -1} is returned.
+     *
+     * @param  i the index to start checking from (inclusive)
+     * @return the index of the previous clear bit, or {@code -1} if there
+     *         is no such bit
+     * @throws IndexOutOfBoundsException if the specified index is less
+     *         than {@code -1}
+     * @since  1.2
+     * @see java.util.BitSet#previousClearBit
+     */
+    public int previousClearBit(int i)
+    {
+        if (i < 0)
+        {
+            if (i == -1)
+                return -1;
+            throw new IndexOutOfBoundsException("i=" + i);
+        }
+
+        final long[][][] bits = this.bits;
+        final int aLength = bits.length;
+
+        int w = i >> SHIFT3;
+        int w3 = w & MASK3;
+        int w2 = (w >> SHIFT2) & MASK2;
+        int w1 = w >> SHIFT1;
+        if (w1 > aLength - 1)
+            return i;
+        w1 = Math.min(w1, aLength - 1);
+        /* The bit to search backwards from in the stored word */
+        final int maxBitIdx = Math.min(i % LENGTH4, LENGTH4);
+
+        long word;
+        long[][] a2;
+        long[] a3;
+
+        /* A fake GOTO so we can break if we find an empty block rather than copy pasting the return code everywhere */
+        search:
+        {
+            for (; w1 >= 0; --w1)
+            {
+                if ((a2 = bits[w1]) == null)
+                    break search;
+                for (; w2 >= 0; --w2)
+                {
+                    if ((a3 = a2[w2]) == null)
+                        break search;
+                    for (; w3 >= 0; --w3)
+                    {
+                        if ((word = a3[w3]) == 0)
+                            break search;
+                        for (int bitIdx = maxBitIdx; bitIdx >= 0; --bitIdx)
+                        {
+                            if ((word & (1L << bitIdx)) == 0)
+                                return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + bitIdx;
+                        }
+                    }
+                    w3 = LENGTH3 - 1;
+                }
+                w2 = LENGTH2 - 1;
+                w3 = LENGTH3 - 1;
+            }
+            return -1;
+        }
+        return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3) + maxBitIdx;
+    }
+
+    /**
+     * Returns the index of the nearest bit that is set to {@code true}
+     * that occurs on or before the specified starting index.
+     * If no such bit exists, or if {@code -1} is given as the
+     * starting index, then {@code -1} is returned.
+     *
+     * @param  i the index to start checking from (inclusive)
+     * @return the index of the previous set bit, or {@code -1} if there
+     *         is no such bit
+     * @throws IndexOutOfBoundsException if the specified index is less
+     *         than {@code -1}
+     * @since  1.2
+     * @see java.util.BitSet#previousSetBit
+     */
+    public int previousSetBit(int i)
+    {
+        if (i < 0)
+        {
+            if (i == -1)
+                return -1;
+            throw new IndexOutOfBoundsException("i=" + i);
+        }
+
+        final long[][][] bits = this.bits;
+        final int aLength = bits.length;
+
+        /*  This is the word from which the search begins. */
+        final int w = i >> SHIFT3;
+        int w3 = w & MASK3;
+        int w2 = (w >> SHIFT2) & MASK2;
+        int w1 = Math.min(w >> SHIFT1, aLength - 1);
+        /* The bit to search backwards from in the stored word. */
+        final int maxBitIdx = Math.min(i, LENGTH4);
+
+        long word;
+        long[][] a2;
+        long[] a3;
+        for (; w1 >= 0; --w1)
+        {
+            if ((a2 = bits[w1]) != null)
+                for (; w2 >= 0; --w2)
+                {
+                    if ((a3 = a2[w2]) != null)
+                        for (; w3 >= 0; --w3)
+                        {
+                            if ((word = a3[w3]) != 0)
+                                for (int bitIdx = maxBitIdx; bitIdx >= 0; --bitIdx)
+                                {
+                                    if ((word & (1L << bitIdx)) != 0)
+                                        return (((w1 << SHIFT1) + (w2 << SHIFT2) + w3) << SHIFT3)
+                                                + Long.numberOfTrailingZeros(word);
+                                }
+                        }
+                    w3 = LENGTH3 - 1;
+                }
+            w2 = LENGTH2 - 1;
+            w3 = LENGTH3 - 1;
+        }
+        return -1;
+    }
+
     /**
      *  Performs a logical <b>OR</b> of the addressed target bit with the
      *  argument value. This bit set is modified so that the addressed bit has the
@@ -1352,7 +1484,7 @@ public class SparseBitSet implements Cloneable, Serializable
     /** Sequences of set bits longer than this value are shown by
      *  {@link #toString()} as a "sub-sequence," in the form <code>a..b</code>.
      *  Setting this value to zero causes each set bit to be listed individually.
-     *  The default default value is 2 (which means sequences of three or more 
+     *  The default default value is 2 (which means sequences of three or more
      *  bits set are shown as a subsequence, and all other set bits are listed
      *  individually).
      *  <p>
@@ -1839,7 +1971,7 @@ public class SparseBitSet implements Cloneable, Serializable
     //==============================================================================
 
     /**
-     *  Save the state of the <code>SparseBitSet</code> instance to a stream 
+     *  Save the state of the <code>SparseBitSet</code> instance to a stream
      *  (<i>i.e.</i>, serialize it).
      *
      * @param       s the ObjectOutputStream to which to write the serialized object
@@ -1848,7 +1980,7 @@ public class SparseBitSet implements Cloneable, Serializable
      *              inconsistent
      *
      * @serialData  The default data is emitted, followed by the current
-     *              <i>compactionCount</i> for the bit set, and then the 
+     *              <i>compactionCount</i> for the bit set, and then the
      *              <i>length</i> of the set (the position of the last bit),
      *              followed by the <i>cache.count</i> value (an <code>int</code>,
      *              the number of <code>int-&gt;long</code> pairs needed to describe
@@ -1902,7 +2034,7 @@ public class SparseBitSet implements Cloneable, Serializable
     private static final long serialVersionUID = -6663013367427929992L;
 
     /**
-     *  Reconstitute the <code>SparseBitSet</code> instance from a stream 
+     *  Reconstitute the <code>SparseBitSet</code> instance from a stream
      *  (<i>i.e.</i>, deserialize it).
      *
      * @param       s the ObjectInputStream to use
diff --git a/src/test/java/com/zaxxer/sparsebits/PreviousClearBitTest.java b/src/test/java/com/zaxxer/sparsebits/PreviousClearBitTest.java
new file mode 100644
index 0000000..dbba8a7
--- /dev/null
+++ b/src/test/java/com/zaxxer/sparsebits/PreviousClearBitTest.java
@@ -0,0 +1,124 @@
+package com.zaxxer.sparsebits;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.HashSet;
+import java.util.Random;
+import java.util.Set;
+
+/**
+ * @author <a href="mailto:brent.n.douglas@gmail.com">Brent Douglas</a>
+ */
+public class PreviousClearBitTest extends Assert {
+
+    SparseBitSet set;
+
+    @Before
+    public void setUp() {
+        set = new SparseBitSet();
+    }
+
+    @Test
+    public void munisOne() throws Exception {
+        final int ret = set.previousClearBit(-1);
+
+        assertEquals(-1, ret);
+    }
+
+    @Test
+    public void emptySet() throws Exception {
+        final int ret = set.previousClearBit(0);
+
+        assertEquals(0, ret);
+    }
+
+    @Test
+    public void bottomBit() throws Exception {
+        final int ret = set.previousClearBit(1);
+
+        assertEquals(1, ret);
+    }
+
+    @Test
+    public void sameBit() throws Exception {
+        set.flip(12345);
+        final int ret = set.previousClearBit(12345);
+
+        assertEquals(12344, ret);
+    }
+
+    @Test
+    public void noneBelow() throws Exception {
+        set.flip(1);
+        final int ret = set.previousClearBit(1);
+
+        assertEquals(0, ret);
+    }
+
+    @Test
+    public void oneBelow() throws Exception {
+        set.flip(1);
+        final int ret = set.previousClearBit(2);
+
+        assertEquals(2, ret);
+    }
+
+    @Test
+    public void threeNoSet() throws Exception {
+        set.flip(1);
+        final int ret = set.previousClearBit(3);
+
+        assertEquals(3, ret);
+    }
+
+    @Test
+    public void threeSet() throws Exception {
+        set.flip(3);
+        final int ret = set.previousClearBit(3);
+
+        assertEquals(2, ret);
+    }
+
+    @Test
+    public void topBit() throws Exception {
+        final int i = Integer.MAX_VALUE - 1;
+        final int ret = set.previousClearBit(i);
+
+        assertEquals(i, ret);
+    }
+
+    @Test
+    public void randomSingleEntry() throws Exception {
+        final Random random = new Random(0);
+        for (int i = 0; i < 10000; ++i) {
+            set = new SparseBitSet();
+            final int x = Math.abs(random.nextInt() + 1);
+            final int ret = set.previousClearBit(x);
+            assertEquals("Failed on i = " + i, x, ret);
+        }
+    }
+
+    @Test
+    public void randomMultiEntry() throws Exception {
+        final Random random = new Random(0);
+        final Set<Integer> values = new HashSet<Integer>();
+        for (int i = 0; i < 10000; ++i) {
+            set = new SparseBitSet();
+            for (int j = 0; j < 1000; ++j) {
+                final int x = Math.abs(random.nextInt() + 1);
+                set.flip(x);
+                values.add(x);
+            }
+            final int x = Math.abs(random.nextInt() + 1);
+            int expected = x;
+            while (values.contains(expected)) {
+                --expected;
+            }
+            final int ret = set.previousClearBit(x);
+            assertEquals("Failed on i = " + i + " x = " + x, expected, ret);
+            values.clear();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/com/zaxxer/sparsebits/PreviousSetBitTest.java b/src/test/java/com/zaxxer/sparsebits/PreviousSetBitTest.java
new file mode 100644
index 0000000..9649063
--- /dev/null
+++ b/src/test/java/com/zaxxer/sparsebits/PreviousSetBitTest.java
@@ -0,0 +1,127 @@
+package com.zaxxer.sparsebits;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+
+/**
+ * @author <a href="mailto:brent.n.douglas@gmail.com">Brent Douglas</a>
+ */
+public class PreviousSetBitTest extends Assert {
+
+    SparseBitSet set;
+
+    @Before
+    public void setUp() {
+        set = new SparseBitSet();
+    }
+
+    @Test
+    public void emptySet() throws Exception {
+        final int ret = set.previousSetBit(0);
+
+        assertEquals(-1, ret);
+    }
+
+    @Test
+    public void bottomBit() throws Exception {
+        set.flip(0);
+        final int ret = set.previousSetBit(0);
+
+        assertEquals(0, ret);
+    }
+
+    @Test
+    public void betweenTwo() throws Exception {
+        set.flip(4);
+        set.flip(8);
+        final int ret = set.previousSetBit(5);
+
+        assertEquals(4, ret);
+    }
+
+    @Test
+    public void sameBit() throws Exception {
+        set.flip(12345);
+        final int ret = set.previousSetBit(12345);
+
+        assertEquals(12345, ret);
+    }
+
+    @Test
+    public void noneBelow() throws Exception {
+        set.flip(1);
+        final int ret = set.previousSetBit(0);
+
+        assertEquals(-1, ret);
+    }
+
+    @Test
+    public void oneBelow() throws Exception {
+        set.flip(1);
+        final int ret = set.previousSetBit(2);
+
+        assertEquals(1, ret);
+    }
+
+    @Test
+    public void twoBelow() throws Exception {
+        set.flip(1);
+        final int ret = set.previousSetBit(3);
+
+        assertEquals(1, ret);
+    }
+
+    @Test
+    public void topBit() throws Exception {
+        final int i = Integer.MAX_VALUE - 1;
+        set.flip(i);
+        final int ret = set.previousSetBit(i);
+
+        assertEquals(i, ret);
+    }
+
+    @Test
+    public void randomSingleEntry() throws Exception {
+        final int max = Integer.MAX_VALUE - 1;
+        final Random random = new Random(0);
+        for (int i = 0; i < 10000; ++i) {
+            set = new SparseBitSet();
+            final int x = Math.abs(random.nextInt() + 1);
+            set.flip(x);
+            final int ret = set.previousSetBit(max);
+            assertEquals("Failed on i = " + i, x, ret);
+        }
+    }
+
+    @Test
+    public void randomMultiEntry() throws Exception {
+        final Random random = new Random(0);
+        final List<Integer> values = new ArrayList<Integer>();
+        for (int i = 0; i < 10000; ++i) {
+            set = new SparseBitSet();
+            for (int j = 0; j < 1000; ++j) {
+                final int x = Math.abs(random.nextInt() + 1);
+                set.flip(x);
+                values.add(x);
+            }
+            final int x = Math.abs(random.nextInt() + 1);
+            Collections.sort(values);
+            int expected = -1;
+            for (final Integer val : values) {
+                if (val > x) {
+                    break;
+                }
+                expected = val;
+            }
+            final int ret = set.previousSetBit(x);
+            assertEquals("Failed on i = " + i, expected, ret);
+            values.clear();
+        }
+    }
+}
\ No newline at end of file
