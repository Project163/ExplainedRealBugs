diff --git a/api/go.sum b/api/go.sum
index 52d9b2c3e..60834fdb3 100644
--- a/api/go.sum
+++ b/api/go.sum
@@ -127,6 +127,7 @@ google.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlba
 google.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=
 google.golang.org/protobuf v1.26.0 h1:bxAC2xTBsZGibn2RTntX0oH50xLsqy1OxA9tTL3p/lk=
 google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
+gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
 gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
 gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
 gopkg.in/yaml.v2 v2.2.3 h1:fvjTMHxHEw/mxHbtzPi3JCcKXQRAnQTBRo6YCJSVHKI=
diff --git a/client/pkg/go.sum b/client/pkg/go.sum
index 14c70b333..88f7cf130 100644
--- a/client/pkg/go.sum
+++ b/client/pkg/go.sum
@@ -89,6 +89,7 @@ google.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2
 google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
 google.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
 google.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=
+gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
 gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
 gopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=
 gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
diff --git a/client/v2/go.sum b/client/v2/go.sum
index ef8988b07..5cc459ee1 100644
--- a/client/v2/go.sum
+++ b/client/v2/go.sum
@@ -137,6 +137,7 @@ google.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpAD
 google.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=
 google.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=
 google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
+gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
 gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
 gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
 gopkg.in/yaml.v2 v2.2.3 h1:fvjTMHxHEw/mxHbtzPi3JCcKXQRAnQTBRo6YCJSVHKI=
diff --git a/etcdctl/go.sum b/etcdctl/go.sum
index 90c566820..f1abfabe0 100644
--- a/etcdctl/go.sum
+++ b/etcdctl/go.sum
@@ -181,9 +181,11 @@ github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI
 github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
 github.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
 github.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=
+github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=
 github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
 github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
 github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
+github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
 github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
 github.com/magiconair/properties v1.8.1/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
 github.com/mattn/go-colorable v0.0.9 h1:UVL0vNpWh04HeJXV0KLcaT7r06gOH2l4OW6ddYRUIY4=
@@ -351,6 +353,7 @@ golang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCc
 golang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=
 golang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=
 golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
+golang.org/x/mod v0.3.0 h1:RM4zey1++hCTbCVQfnWeKs9/IEsaBLA8vTkd0WVtmH4=
 golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
 golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
@@ -493,6 +496,7 @@ google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQ
 gopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=
 gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
 gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=
 gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
 gopkg.in/cheggaaa/pb.v1 v1.0.28 h1:n1tBJnnK2r7g9OW2btFH91V92STTUevLXYFb8gy9EMk=
 gopkg.in/cheggaaa/pb.v1 v1.0.28/go.mod h1:V/YB90LKu/1FcN3WVnfiiE5oMCibMjukxqG/qStrOgw=
diff --git a/etcdutl/go.sum b/etcdutl/go.sum
index d44b8a0a8..26cb55aa5 100644
--- a/etcdutl/go.sum
+++ b/etcdutl/go.sum
@@ -177,9 +177,11 @@ github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI
 github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
 github.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
 github.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=
+github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=
 github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
 github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
 github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
+github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
 github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
 github.com/magiconair/properties v1.8.1/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
 github.com/mattn/go-colorable v0.0.9/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=
@@ -341,6 +343,7 @@ golang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCc
 golang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=
 golang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=
 golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
+golang.org/x/mod v0.3.0 h1:RM4zey1++hCTbCVQfnWeKs9/IEsaBLA8vTkd0WVtmH4=
 golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
 golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
@@ -483,6 +486,7 @@ google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQ
 gopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=
 gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
 gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=
 gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
 gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
 gopkg.in/ini.v1 v1.51.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
diff --git a/go.sum b/go.sum
index 717358969..1b8ab7831 100644
--- a/go.sum
+++ b/go.sum
@@ -366,6 +366,7 @@ golang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKG
 golang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=
 golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
 golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
+golang.org/x/mod v0.4.2 h1:Gz96sIWK3OalVv/I/qNygP42zyoKp3xptRVCWRFEBvo=
 golang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
 golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
diff --git a/server/embed/config_test.go b/server/embed/config_test.go
index 8fa52e38d..8e36006bc 100644
--- a/server/embed/config_test.go
+++ b/server/embed/config_test.go
@@ -24,8 +24,8 @@ import (
 	"testing"
 	"time"
 
+	"github.com/stretchr/testify/assert"
 	"go.etcd.io/etcd/client/pkg/v3/srv"
-	"go.etcd.io/etcd/client/pkg/v3/testutil"
 	"go.etcd.io/etcd/client/pkg/v3/transport"
 	"go.etcd.io/etcd/client/pkg/v3/types"
 
@@ -80,11 +80,11 @@ func TestConfigFileOtherFields(t *testing.T) {
 		t.Errorf("PeerTLS = %v, want %v", cfg.PeerTLSInfo, ptls)
 	}
 
-	testutil.AssertEqual(t, true, cfg.ForceNewCluster, "ForceNewCluster does not match")
+	assert.Equal(t, true, cfg.ForceNewCluster, "ForceNewCluster does not match")
 
-	testutil.AssertEqual(t, true, cfg.SocketOpts.ReusePort, "ReusePort does not match")
+	assert.Equal(t, true, cfg.SocketOpts.ReusePort, "ReusePort does not match")
 
-	testutil.AssertEqual(t, false, cfg.SocketOpts.ReuseAddress, "ReuseAddress does not match")
+	assert.Equal(t, false, cfg.SocketOpts.ReuseAddress, "ReuseAddress does not match")
 }
 
 // TestUpdateDefaultClusterFromName ensures that etcd can start with 'etcd --name=abc'.
diff --git a/server/etcdserver/api/v2store/node_extern_test.go b/server/etcdserver/api/v2store/node_extern_test.go
index 790cfb106..2a73496d6 100644
--- a/server/etcdserver/api/v2store/node_extern_test.go
+++ b/server/etcdserver/api/v2store/node_extern_test.go
@@ -19,7 +19,7 @@ import (
 	"testing"
 	"time"
 
-	"go.etcd.io/etcd/client/pkg/v3/testutil"
+	"github.com/stretchr/testify/assert"
 )
 
 func TestNodeExternClone(t *testing.T) {
@@ -56,15 +56,15 @@ func TestNodeExternClone(t *testing.T) {
 
 	gNode := eNode.Clone()
 	// Check the clone is as expected
-	testutil.AssertEqual(t, gNode.Key, key)
-	testutil.AssertEqual(t, gNode.TTL, ttl)
-	testutil.AssertEqual(t, gNode.CreatedIndex, ci)
-	testutil.AssertEqual(t, gNode.ModifiedIndex, mi)
+	assert.Equal(t, gNode.Key, key)
+	assert.Equal(t, gNode.TTL, ttl)
+	assert.Equal(t, gNode.CreatedIndex, ci)
+	assert.Equal(t, gNode.ModifiedIndex, mi)
 	// values should be the same
-	testutil.AssertEqual(t, *gNode.Value, val)
-	testutil.AssertEqual(t, *gNode.Expiration, exp)
-	testutil.AssertEqual(t, len(gNode.Nodes), len(childs))
-	testutil.AssertEqual(t, *gNode.Nodes[0], child)
+	assert.Equal(t, *gNode.Value, val)
+	assert.Equal(t, *gNode.Expiration, exp)
+	assert.Equal(t, len(gNode.Nodes), len(childs))
+	assert.Equal(t, *gNode.Nodes[0], child)
 	// but pointers should differ
 	if gNode.Value == eNode.Value {
 		t.Fatalf("expected value pointers to differ, but got same!")
@@ -76,12 +76,12 @@ func TestNodeExternClone(t *testing.T) {
 		t.Fatalf("expected nodes pointers to differ, but got same!")
 	}
 	// Original should be the same
-	testutil.AssertEqual(t, eNode.Key, key)
-	testutil.AssertEqual(t, eNode.TTL, ttl)
-	testutil.AssertEqual(t, eNode.CreatedIndex, ci)
-	testutil.AssertEqual(t, eNode.ModifiedIndex, mi)
-	testutil.AssertEqual(t, eNode.Value, valp)
-	testutil.AssertEqual(t, eNode.Expiration, expp)
+	assert.Equal(t, eNode.Key, key)
+	assert.Equal(t, eNode.TTL, ttl)
+	assert.Equal(t, eNode.CreatedIndex, ci)
+	assert.Equal(t, eNode.ModifiedIndex, mi)
+	assert.Equal(t, eNode.Value, valp)
+	assert.Equal(t, eNode.Expiration, expp)
 	if !sameSlice(eNode.Nodes, childs) {
 		t.Fatalf("expected nodes pointer to same, but got different!")
 	}
@@ -89,15 +89,15 @@ func TestNodeExternClone(t *testing.T) {
 	gNode.Key = "/baz"
 	gNode.TTL = 0
 	gNode.Nodes[0].Key = "uno"
-	testutil.AssertEqual(t, eNode.Key, key)
-	testutil.AssertEqual(t, eNode.TTL, ttl)
-	testutil.AssertEqual(t, eNode.CreatedIndex, ci)
-	testutil.AssertEqual(t, eNode.ModifiedIndex, mi)
-	testutil.AssertEqual(t, *eNode.Nodes[0], child)
+	assert.Equal(t, eNode.Key, key)
+	assert.Equal(t, eNode.TTL, ttl)
+	assert.Equal(t, eNode.CreatedIndex, ci)
+	assert.Equal(t, eNode.ModifiedIndex, mi)
+	assert.Equal(t, *eNode.Nodes[0], child)
 	// Change the original and ensure the clone is not affected
 	eNode.Key = "/wuf"
-	testutil.AssertEqual(t, eNode.Key, "/wuf")
-	testutil.AssertEqual(t, gNode.Key, "/baz")
+	assert.Equal(t, eNode.Key, "/wuf")
+	assert.Equal(t, gNode.Key, "/baz")
 }
 
 func sameSlice(a, b []*NodeExtern) bool {
diff --git a/server/etcdserver/api/v2store/stats_test.go b/server/etcdserver/api/v2store/stats_test.go
index 1780a8aff..66ffe636e 100644
--- a/server/etcdserver/api/v2store/stats_test.go
+++ b/server/etcdserver/api/v2store/stats_test.go
@@ -18,7 +18,7 @@ import (
 	"testing"
 	"time"
 
-	"go.etcd.io/etcd/client/pkg/v3/testutil"
+	"github.com/stretchr/testify/assert"
 )
 
 // Ensure that a successful Get is recorded in the stats.
@@ -26,7 +26,7 @@ func TestStoreStatsGetSuccess(t *testing.T) {
 	s := newStore()
 	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
 	s.Get("/foo", false, false)
-	testutil.AssertEqual(t, uint64(1), s.Stats.GetSuccess, "")
+	assert.Equal(t, uint64(1), s.Stats.GetSuccess, "")
 }
 
 // Ensure that a failed Get is recorded in the stats.
@@ -34,14 +34,14 @@ func TestStoreStatsGetFail(t *testing.T) {
 	s := newStore()
 	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
 	s.Get("/no_such_key", false, false)
-	testutil.AssertEqual(t, uint64(1), s.Stats.GetFail, "")
+	assert.Equal(t, uint64(1), s.Stats.GetFail, "")
 }
 
 // Ensure that a successful Create is recorded in the stats.
 func TestStoreStatsCreateSuccess(t *testing.T) {
 	s := newStore()
 	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
-	testutil.AssertEqual(t, uint64(1), s.Stats.CreateSuccess, "")
+	assert.Equal(t, uint64(1), s.Stats.CreateSuccess, "")
 }
 
 // Ensure that a failed Create is recorded in the stats.
@@ -49,7 +49,7 @@ func TestStoreStatsCreateFail(t *testing.T) {
 	s := newStore()
 	s.Create("/foo", true, "", false, TTLOptionSet{ExpireTime: Permanent})
 	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
-	testutil.AssertEqual(t, uint64(1), s.Stats.CreateFail, "")
+	assert.Equal(t, uint64(1), s.Stats.CreateFail, "")
 }
 
 // Ensure that a successful Update is recorded in the stats.
@@ -57,14 +57,14 @@ func TestStoreStatsUpdateSuccess(t *testing.T) {
 	s := newStore()
 	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
 	s.Update("/foo", "baz", TTLOptionSet{ExpireTime: Permanent})
-	testutil.AssertEqual(t, uint64(1), s.Stats.UpdateSuccess, "")
+	assert.Equal(t, uint64(1), s.Stats.UpdateSuccess, "")
 }
 
 // Ensure that a failed Update is recorded in the stats.
 func TestStoreStatsUpdateFail(t *testing.T) {
 	s := newStore()
 	s.Update("/foo", "bar", TTLOptionSet{ExpireTime: Permanent})
-	testutil.AssertEqual(t, uint64(1), s.Stats.UpdateFail, "")
+	assert.Equal(t, uint64(1), s.Stats.UpdateFail, "")
 }
 
 // Ensure that a successful CAS is recorded in the stats.
@@ -72,7 +72,7 @@ func TestStoreStatsCompareAndSwapSuccess(t *testing.T) {
 	s := newStore()
 	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
 	s.CompareAndSwap("/foo", "bar", 0, "baz", TTLOptionSet{ExpireTime: Permanent})
-	testutil.AssertEqual(t, uint64(1), s.Stats.CompareAndSwapSuccess, "")
+	assert.Equal(t, uint64(1), s.Stats.CompareAndSwapSuccess, "")
 }
 
 // Ensure that a failed CAS is recorded in the stats.
@@ -80,7 +80,7 @@ func TestStoreStatsCompareAndSwapFail(t *testing.T) {
 	s := newStore()
 	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
 	s.CompareAndSwap("/foo", "wrong_value", 0, "baz", TTLOptionSet{ExpireTime: Permanent})
-	testutil.AssertEqual(t, uint64(1), s.Stats.CompareAndSwapFail, "")
+	assert.Equal(t, uint64(1), s.Stats.CompareAndSwapFail, "")
 }
 
 // Ensure that a successful Delete is recorded in the stats.
@@ -88,14 +88,14 @@ func TestStoreStatsDeleteSuccess(t *testing.T) {
 	s := newStore()
 	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: Permanent})
 	s.Delete("/foo", false, false)
-	testutil.AssertEqual(t, uint64(1), s.Stats.DeleteSuccess, "")
+	assert.Equal(t, uint64(1), s.Stats.DeleteSuccess, "")
 }
 
 // Ensure that a failed Delete is recorded in the stats.
 func TestStoreStatsDeleteFail(t *testing.T) {
 	s := newStore()
 	s.Delete("/foo", false, false)
-	testutil.AssertEqual(t, uint64(1), s.Stats.DeleteFail, "")
+	assert.Equal(t, uint64(1), s.Stats.DeleteFail, "")
 }
 
 //Ensure that the number of expirations is recorded in the stats.
@@ -105,8 +105,8 @@ func TestStoreStatsExpireCount(t *testing.T) {
 	s.clock = fc
 
 	s.Create("/foo", false, "bar", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
-	testutil.AssertEqual(t, uint64(0), s.Stats.ExpireCount, "")
+	assert.Equal(t, uint64(0), s.Stats.ExpireCount, "")
 	fc.Advance(600 * time.Millisecond)
 	s.DeleteExpiredKeys(fc.Now())
-	testutil.AssertEqual(t, uint64(1), s.Stats.ExpireCount, "")
+	assert.Equal(t, uint64(1), s.Stats.ExpireCount, "")
 }
diff --git a/server/etcdserver/api/v2store/store_ttl_test.go b/server/etcdserver/api/v2store/store_ttl_test.go
index 22a9f79da..5ce5ca478 100644
--- a/server/etcdserver/api/v2store/store_ttl_test.go
+++ b/server/etcdserver/api/v2store/store_ttl_test.go
@@ -18,6 +18,7 @@ import (
 	"testing"
 	"time"
 
+	"github.com/stretchr/testify/assert"
 	"go.etcd.io/etcd/client/pkg/v3/testutil"
 	"go.etcd.io/etcd/server/v3/etcdserver/api/v2error"
 
@@ -38,10 +39,10 @@ func TestMinExpireTime(t *testing.T) {
 	var eidx uint64 = 1
 	e, err := s.Get("/foo", true, false)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "get")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "get")
+	assert.Equal(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.Node.TTL, int64(0))
 }
 
 // Ensure that the store can recursively retrieve a directory listing.
@@ -60,19 +61,19 @@ func TestStoreGetDirectory(t *testing.T) {
 	var eidx uint64 = 7
 	e, err := s.Get("/foo", true, false)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "get")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, len(e.Node.Nodes), 2)
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "get")
+	assert.Equal(t, e.Node.Key, "/foo")
+	assert.Equal(t, len(e.Node.Nodes), 2)
 	var bazNodes NodeExterns
 	for _, node := range e.Node.Nodes {
 		switch node.Key {
 		case "/foo/bar":
-			testutil.AssertEqual(t, *node.Value, "X")
-			testutil.AssertEqual(t, node.Dir, false)
+			assert.Equal(t, *node.Value, "X")
+			assert.Equal(t, node.Dir, false)
 		case "/foo/baz":
-			testutil.AssertEqual(t, node.Dir, true)
-			testutil.AssertEqual(t, len(node.Nodes), 2)
+			assert.Equal(t, node.Dir, true)
+			assert.Equal(t, len(node.Nodes), 2)
 			bazNodes = node.Nodes
 		default:
 			t.Errorf("key = %s, not matched", node.Key)
@@ -81,12 +82,12 @@ func TestStoreGetDirectory(t *testing.T) {
 	for _, node := range bazNodes {
 		switch node.Key {
 		case "/foo/baz/bat":
-			testutil.AssertEqual(t, *node.Value, "Y")
-			testutil.AssertEqual(t, node.Dir, false)
+			assert.Equal(t, *node.Value, "Y")
+			assert.Equal(t, node.Dir, false)
 		case "/foo/baz/ttl":
-			testutil.AssertEqual(t, *node.Value, "Y")
-			testutil.AssertEqual(t, node.Dir, false)
-			testutil.AssertEqual(t, node.TTL, int64(3))
+			assert.Equal(t, *node.Value, "Y")
+			assert.Equal(t, node.Dir, false)
+			assert.Equal(t, node.TTL, int64(3))
 		default:
 			t.Errorf("key = %s, not matched", node.Key)
 		}
@@ -104,13 +105,13 @@ func TestStoreUpdateValueTTL(t *testing.T) {
 	_, err := s.Update("/foo", "baz", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
 	testutil.AssertNil(t, err)
 	e, _ := s.Get("/foo", false, false)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	assert.Equal(t, *e.Node.Value, "baz")
+	assert.Equal(t, e.EtcdIndex, eidx)
 	fc.Advance(600 * time.Millisecond)
 	s.DeleteExpiredKeys(fc.Now())
 	e, err = s.Get("/foo", false, false)
 	testutil.AssertNil(t, e)
-	testutil.AssertEqual(t, err.(*v2error.Error).ErrorCode, v2error.EcodeKeyNotFound)
+	assert.Equal(t, err.(*v2error.Error).ErrorCode, v2error.EcodeKeyNotFound)
 }
 
 // Ensure that the store can update the TTL on a directory.
@@ -126,17 +127,17 @@ func TestStoreUpdateDirTTL(t *testing.T) {
 	testutil.AssertNil(t, err)
 	e, err := s.Update("/foo/bar", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.Node.Dir, false)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Node.Dir, false)
+	assert.Equal(t, e.EtcdIndex, eidx)
 	e, _ = s.Get("/foo/bar", false, false)
-	testutil.AssertEqual(t, *e.Node.Value, "")
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	assert.Equal(t, *e.Node.Value, "")
+	assert.Equal(t, e.EtcdIndex, eidx)
 
 	fc.Advance(600 * time.Millisecond)
 	s.DeleteExpiredKeys(fc.Now())
 	e, err = s.Get("/foo/bar", false, false)
 	testutil.AssertNil(t, e)
-	testutil.AssertEqual(t, err.(*v2error.Error).ErrorCode, v2error.EcodeKeyNotFound)
+	assert.Equal(t, err.(*v2error.Error).ErrorCode, v2error.EcodeKeyNotFound)
 }
 
 // Ensure that the store can watch for key expiration.
@@ -151,7 +152,7 @@ func TestStoreWatchExpire(t *testing.T) {
 	s.Create("/foodir", true, "", false, TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond)})
 
 	w, _ := s.Watch("/", true, false, 0)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	assert.Equal(t, w.StartIndex(), eidx)
 	c := w.EventChan()
 	e := nbselect(c)
 	testutil.AssertNil(t, e)
@@ -159,22 +160,22 @@ func TestStoreWatchExpire(t *testing.T) {
 	s.DeleteExpiredKeys(fc.Now())
 	eidx = 4
 	e = nbselect(c)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "expire")
+	assert.Equal(t, e.Node.Key, "/foo")
 	w, _ = s.Watch("/", true, false, 5)
 	eidx = 6
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	assert.Equal(t, w.StartIndex(), eidx)
 	e = nbselect(w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foofoo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "expire")
+	assert.Equal(t, e.Node.Key, "/foofoo")
 	w, _ = s.Watch("/", true, false, 6)
 	e = nbselect(w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foodir")
-	testutil.AssertEqual(t, e.Node.Dir, true)
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "expire")
+	assert.Equal(t, e.Node.Key, "/foodir")
+	assert.Equal(t, e.Node.Dir, true)
 }
 
 // Ensure that the store can watch for key expiration when refreshing.
@@ -189,7 +190,7 @@ func TestStoreWatchExpireRefresh(t *testing.T) {
 
 	// Make sure we set watch updates when Refresh is true for newly created keys
 	w, _ := s.Watch("/", true, false, 0)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	assert.Equal(t, w.StartIndex(), eidx)
 	c := w.EventChan()
 	e := nbselect(c)
 	testutil.AssertNil(t, e)
@@ -197,20 +198,20 @@ func TestStoreWatchExpireRefresh(t *testing.T) {
 	s.DeleteExpiredKeys(fc.Now())
 	eidx = 3
 	e = nbselect(c)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "expire")
+	assert.Equal(t, e.Node.Key, "/foo")
 
 	s.Update("/foofoo", "", TTLOptionSet{ExpireTime: fc.Now().Add(500 * time.Millisecond), Refresh: true})
 	w, _ = s.Watch("/", true, false, 4)
 	fc.Advance(700 * time.Millisecond)
 	s.DeleteExpiredKeys(fc.Now())
 	eidx = 5 // We should skip 4 because a TTL update should occur with no watch notification if set `TTLOptionSet.Refresh` to true
-	testutil.AssertEqual(t, w.StartIndex(), eidx-1)
+	assert.Equal(t, w.StartIndex(), eidx-1)
 	e = nbselect(w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foofoo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "expire")
+	assert.Equal(t, e.Node.Key, "/foofoo")
 }
 
 // Ensure that the store can watch for key expiration when refreshing with an empty value.
@@ -230,12 +231,12 @@ func TestStoreWatchExpireEmptyRefresh(t *testing.T) {
 	fc.Advance(700 * time.Millisecond)
 	s.DeleteExpiredKeys(fc.Now())
 	eidx = 3 // We should skip 2 because a TTL update should occur with no watch notification if set `TTLOptionSet.Refresh` to true
-	testutil.AssertEqual(t, w.StartIndex(), eidx-1)
+	assert.Equal(t, w.StartIndex(), eidx-1)
 	e := nbselect(w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "expire")
+	assert.Equal(t, e.Node.Key, "/foo")
+	assert.Equal(t, *e.PrevNode.Value, "bar")
 }
 
 // Update TTL of a key (set TTLOptionSet.Refresh to false) and send notification
@@ -256,12 +257,12 @@ func TestStoreWatchNoRefresh(t *testing.T) {
 	fc.Advance(700 * time.Millisecond)
 	s.DeleteExpiredKeys(fc.Now())
 	eidx = 2
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	assert.Equal(t, w.StartIndex(), eidx)
 	e := nbselect(w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "update")
+	assert.Equal(t, e.Node.Key, "/foo")
+	assert.Equal(t, *e.PrevNode.Value, "bar")
 }
 
 // Ensure that the store can update the TTL on a value with refresh.
@@ -312,8 +313,8 @@ func TestStoreRecoverWithExpiration(t *testing.T) {
 
 	e, err := s.Get("/foo/x", false, false)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, *e.Node.Value, "bar")
 
 	e, err = s.Get("/foo/y", false, false)
 	testutil.AssertNotNil(t, err)
@@ -340,8 +341,8 @@ func TestStoreWatchExpireWithHiddenKey(t *testing.T) {
 	fc.Advance(600 * time.Millisecond)
 	s.DeleteExpiredKeys(fc.Now())
 	e = nbselect(c)
-	testutil.AssertEqual(t, e.Action, "expire")
-	testutil.AssertEqual(t, e.Node.Key, "/foofoo")
+	assert.Equal(t, e.Action, "expire")
+	assert.Equal(t, e.Node.Key, "/foofoo")
 }
 
 // newFakeClock creates a new FakeClock that has been advanced to at least minExpireTime
diff --git a/server/go.sum b/server/go.sum
index 3ccf56bb4..ef608517f 100644
--- a/server/go.sum
+++ b/server/go.sum
@@ -353,6 +353,7 @@ golang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCc
 golang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=
 golang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=
 golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
+golang.org/x/mod v0.3.0 h1:RM4zey1++hCTbCVQfnWeKs9/IEsaBLA8vTkd0WVtmH4=
 golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
 golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
diff --git a/tests/integration/clientv3/lease/leasing_test.go b/tests/integration/clientv3/lease/leasing_test.go
index 02814aa46..54236be97 100644
--- a/tests/integration/clientv3/lease/leasing_test.go
+++ b/tests/integration/clientv3/lease/leasing_test.go
@@ -23,8 +23,9 @@ import (
 	"testing"
 	"time"
 
+	"github.com/stretchr/testify/assert"
 	"go.etcd.io/etcd/client/pkg/v3/testutil"
-	"go.etcd.io/etcd/client/v3"
+	clientv3 "go.etcd.io/etcd/client/v3"
 	"go.etcd.io/etcd/client/v3/concurrency"
 	"go.etcd.io/etcd/client/v3/leasing"
 	"go.etcd.io/etcd/tests/v3/integration"
@@ -209,14 +210,14 @@ func TestLeasingGetNoLeaseTTL(t *testing.T) {
 
 	gresp, err := lkv.Get(context.TODO(), "k")
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, len(gresp.Kvs), 1)
+	assert.Equal(t, len(gresp.Kvs), 1)
 
 	clus.Members[0].Stop(t)
 
 	ctx, cancel := context.WithTimeout(context.TODO(), time.Second)
 	_, err = lkv.Get(ctx, "k")
 	cancel()
-	testutil.AssertEqual(t, err, ctx.Err())
+	assert.Equal(t, err, ctx.Err())
 }
 
 // TestLeasingGetSerializable checks the leasing KV can make serialized requests
diff --git a/tests/integration/v2store/store_tag_not_v2v3_test.go b/tests/integration/v2store/store_tag_not_v2v3_test.go
index fbc63b94a..af5e21c81 100644
--- a/tests/integration/v2store/store_tag_not_v2v3_test.go
+++ b/tests/integration/v2store/store_tag_not_v2v3_test.go
@@ -20,6 +20,7 @@ package v2store_test
 import (
 	"testing"
 
+	"github.com/stretchr/testify/assert"
 	"go.etcd.io/etcd/client/pkg/v3/testutil"
 	"go.etcd.io/etcd/server/v3/etcdserver/api/v2store"
 	"go.etcd.io/etcd/tests/v3/integration"
@@ -55,14 +56,14 @@ func TestStoreRecover(t *testing.T) {
 	s2.Recovery(b)
 
 	e, err := s.Get("/foo/x", false, false)
-	testutil.AssertEqual(t, e.Node.CreatedIndex, uint64(2))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(3))
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Node.CreatedIndex, uint64(2))
+	assert.Equal(t, e.Node.ModifiedIndex, uint64(3))
+	assert.Equal(t, e.EtcdIndex, eidx)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, *e.Node.Value, "barbar")
+	assert.Equal(t, *e.Node.Value, "barbar")
 
 	e, err = s.Get("/foo/y", false, false)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.EtcdIndex, eidx)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	assert.Equal(t, *e.Node.Value, "baz")
 }
diff --git a/tests/integration/v2store/store_test.go b/tests/integration/v2store/store_test.go
index 562ff5397..59ee050d4 100644
--- a/tests/integration/v2store/store_test.go
+++ b/tests/integration/v2store/store_test.go
@@ -19,6 +19,7 @@ import (
 	"testing"
 	"time"
 
+	"github.com/stretchr/testify/assert"
 	"go.etcd.io/etcd/client/pkg/v3/testutil"
 	"go.etcd.io/etcd/server/v3/etcdserver/api/v2error"
 	"go.etcd.io/etcd/server/v3/etcdserver/api/v2store"
@@ -48,10 +49,10 @@ func TestStoreGetValue(t *testing.T) {
 	var eidx uint64 = 1
 	e, err := s.Get("/foo", false, false)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "get")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "get")
+	assert.Equal(t, e.Node.Key, "/foo")
+	assert.Equal(t, *e.Node.Value, "bar")
 }
 
 // Ensure that the store can retrieve a directory in sorted order.
@@ -68,7 +69,7 @@ func TestStoreGetSorted(t *testing.T) {
 	var eidx uint64 = 6
 	e, err := s.Get("/foo", true, true)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.EtcdIndex, eidx)
 
 	var yNodes v2store.NodeExterns
 	sortedStrings := []string{"/foo/x", "/foo/y", "/foo/z"}
@@ -99,79 +100,79 @@ func TestSet(t *testing.T) {
 	var eidx uint64 = 1
 	e, err := s.Set("/foo", false, "", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "set")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "set")
+	assert.Equal(t, e.Node.Key, "/foo")
 	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "")
+	assert.Equal(t, *e.Node.Value, "")
 	testutil.AssertNil(t, e.Node.Nodes)
 	testutil.AssertNil(t, e.Node.Expiration)
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(1))
+	assert.Equal(t, e.Node.TTL, int64(0))
+	assert.Equal(t, e.Node.ModifiedIndex, uint64(1))
 
 	// Set /foo="bar"
 	eidx = 2
 	e, err = s.Set("/foo", false, "bar", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "set")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "set")
+	assert.Equal(t, e.Node.Key, "/foo")
 	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
+	assert.Equal(t, *e.Node.Value, "bar")
 	testutil.AssertNil(t, e.Node.Nodes)
 	testutil.AssertNil(t, e.Node.Expiration)
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(2))
+	assert.Equal(t, e.Node.TTL, int64(0))
+	assert.Equal(t, e.Node.ModifiedIndex, uint64(2))
 	// check prevNode
 	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "")
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
+	assert.Equal(t, e.PrevNode.Key, "/foo")
+	assert.Equal(t, *e.PrevNode.Value, "")
+	assert.Equal(t, e.PrevNode.ModifiedIndex, uint64(1))
 	// Set /foo="baz" (for testing prevNode)
 	eidx = 3
 	e, err = s.Set("/foo", false, "baz", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "set")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "set")
+	assert.Equal(t, e.Node.Key, "/foo")
 	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	assert.Equal(t, *e.Node.Value, "baz")
 	testutil.AssertNil(t, e.Node.Nodes)
 	testutil.AssertNil(t, e.Node.Expiration)
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(3))
+	assert.Equal(t, e.Node.TTL, int64(0))
+	assert.Equal(t, e.Node.ModifiedIndex, uint64(3))
 	// check prevNode
 	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(2))
+	assert.Equal(t, e.PrevNode.Key, "/foo")
+	assert.Equal(t, *e.PrevNode.Value, "bar")
+	assert.Equal(t, e.PrevNode.ModifiedIndex, uint64(2))
 
 	// Set /a/b/c/d="efg"
 	eidx = 4
 	e, err = s.Set("/a/b/c/d", false, "efg", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Node.Key, "/a/b/c/d")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Node.Key, "/a/b/c/d")
 	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "efg")
+	assert.Equal(t, *e.Node.Value, "efg")
 	testutil.AssertNil(t, e.Node.Nodes)
 	testutil.AssertNil(t, e.Node.Expiration)
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(4))
+	assert.Equal(t, e.Node.TTL, int64(0))
+	assert.Equal(t, e.Node.ModifiedIndex, uint64(4))
 
 	// Set /dir as a directory
 	eidx = 5
 	e, err = s.Set("/dir", true, "", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "set")
-	testutil.AssertEqual(t, e.Node.Key, "/dir")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "set")
+	assert.Equal(t, e.Node.Key, "/dir")
 	testutil.AssertTrue(t, e.Node.Dir)
 	testutil.AssertNil(t, e.Node.Value)
 	testutil.AssertNil(t, e.Node.Nodes)
 	testutil.AssertNil(t, e.Node.Expiration)
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(5))
+	assert.Equal(t, e.Node.TTL, int64(0))
+	assert.Equal(t, e.Node.ModifiedIndex, uint64(5))
 }
 
 // Ensure that the store can create a new key if it doesn't already exist.
@@ -183,29 +184,29 @@ func TestStoreCreateValue(t *testing.T) {
 	var eidx uint64 = 1
 	e, err := s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "create")
+	assert.Equal(t, e.Node.Key, "/foo")
 	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
+	assert.Equal(t, *e.Node.Value, "bar")
 	testutil.AssertNil(t, e.Node.Nodes)
 	testutil.AssertNil(t, e.Node.Expiration)
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(1))
+	assert.Equal(t, e.Node.TTL, int64(0))
+	assert.Equal(t, e.Node.ModifiedIndex, uint64(1))
 
 	// Create /empty=""
 	eidx = 2
 	e, err = s.Create("/empty", false, "", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/empty")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "create")
+	assert.Equal(t, e.Node.Key, "/empty")
 	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "")
+	assert.Equal(t, *e.Node.Value, "")
 	testutil.AssertNil(t, e.Node.Nodes)
 	testutil.AssertNil(t, e.Node.Expiration)
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(2))
+	assert.Equal(t, e.Node.TTL, int64(0))
+	assert.Equal(t, e.Node.ModifiedIndex, uint64(2))
 
 }
 
@@ -217,9 +218,9 @@ func TestStoreCreateDirectory(t *testing.T) {
 	var eidx uint64 = 1
 	e, err := s.Create("/foo", true, "", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "create")
+	assert.Equal(t, e.Node.Key, "/foo")
 	testutil.AssertTrue(t, e.Node.Dir)
 }
 
@@ -234,10 +235,10 @@ func TestStoreCreateFailsIfExists(t *testing.T) {
 	// create /foo as dir again
 	e, _err := s.Create("/foo", true, "", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	err := _err.(*v2error.Error)
-	testutil.AssertEqual(t, err.ErrorCode, v2error.EcodeNodeExist)
-	testutil.AssertEqual(t, err.Message, "Key already exists")
-	testutil.AssertEqual(t, err.Cause, "/foo")
-	testutil.AssertEqual(t, err.Index, uint64(1))
+	assert.Equal(t, err.ErrorCode, v2error.EcodeNodeExist)
+	assert.Equal(t, err.Message, "Key already exists")
+	assert.Equal(t, err.Cause, "/foo")
+	assert.Equal(t, err.Index, uint64(1))
 	testutil.AssertNil(t, e)
 }
 
@@ -252,43 +253,43 @@ func TestStoreUpdateValue(t *testing.T) {
 	var eidx uint64 = 2
 	e, err := s.Update("/foo", "baz", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "update")
+	assert.Equal(t, e.Node.Key, "/foo")
 	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(2))
+	assert.Equal(t, *e.Node.Value, "baz")
+	assert.Equal(t, e.Node.TTL, int64(0))
+	assert.Equal(t, e.Node.ModifiedIndex, uint64(2))
 	// check prevNode
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-	testutil.AssertEqual(t, e.PrevNode.TTL, int64(0))
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
+	assert.Equal(t, e.PrevNode.Key, "/foo")
+	assert.Equal(t, *e.PrevNode.Value, "bar")
+	assert.Equal(t, e.PrevNode.TTL, int64(0))
+	assert.Equal(t, e.PrevNode.ModifiedIndex, uint64(1))
 
 	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	assert.Equal(t, *e.Node.Value, "baz")
+	assert.Equal(t, e.EtcdIndex, eidx)
 
 	// update /foo=""
 	eidx = 3
 	e, err = s.Update("/foo", "", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "update")
+	assert.Equal(t, e.Node.Key, "/foo")
 	testutil.AssertFalse(t, e.Node.Dir)
-	testutil.AssertEqual(t, *e.Node.Value, "")
-	testutil.AssertEqual(t, e.Node.TTL, int64(0))
-	testutil.AssertEqual(t, e.Node.ModifiedIndex, uint64(3))
+	assert.Equal(t, *e.Node.Value, "")
+	assert.Equal(t, e.Node.TTL, int64(0))
+	assert.Equal(t, e.Node.ModifiedIndex, uint64(3))
 	// check prevNode
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "baz")
-	testutil.AssertEqual(t, e.PrevNode.TTL, int64(0))
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(2))
+	assert.Equal(t, e.PrevNode.Key, "/foo")
+	assert.Equal(t, *e.PrevNode.Value, "baz")
+	assert.Equal(t, e.PrevNode.TTL, int64(0))
+	assert.Equal(t, e.PrevNode.ModifiedIndex, uint64(2))
 
 	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, *e.Node.Value, "")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, *e.Node.Value, "")
 }
 
 // Ensure that the store cannot update a directory.
@@ -299,9 +300,9 @@ func TestStoreUpdateFailsIfDirectory(t *testing.T) {
 	s.Create("/foo", true, "", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e, _err := s.Update("/foo", "baz", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	err := _err.(*v2error.Error)
-	testutil.AssertEqual(t, err.ErrorCode, v2error.EcodeNotFile)
-	testutil.AssertEqual(t, err.Message, "Not a file")
-	testutil.AssertEqual(t, err.Cause, "/foo")
+	assert.Equal(t, err.ErrorCode, v2error.EcodeNotFile)
+	assert.Equal(t, err.Message, "Not a file")
+	assert.Equal(t, err.Cause, "/foo")
 	testutil.AssertNil(t, e)
 }
 
@@ -314,12 +315,12 @@ func TestStoreDeleteValue(t *testing.T) {
 	s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e, err := s.Delete("/foo", false, false)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "delete")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "delete")
 	// check prevNode
 	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
+	assert.Equal(t, e.PrevNode.Key, "/foo")
+	assert.Equal(t, *e.PrevNode.Value, "bar")
 }
 
 // Ensure that the store can delete a directory if recursive is specified.
@@ -334,12 +335,12 @@ func TestStoreDeleteDirectory(t *testing.T) {
 	// this should succeed, since the directory is empty
 	e, err := s.Delete("/foo", true, false)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "delete")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "delete")
 	// check prevNode
 	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, e.PrevNode.Dir, true)
+	assert.Equal(t, e.PrevNode.Key, "/foo")
+	assert.Equal(t, e.PrevNode.Dir, true)
 
 	// create directory /foo and directory /foo/bar
 	_, err = s.Create("/foo/bar", true, "", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
@@ -355,7 +356,7 @@ func TestStoreDeleteDirectory(t *testing.T) {
 	// items under the given directory
 	e, err = s.Delete("/foo", false, true)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.Action, "delete")
+	assert.Equal(t, e.Action, "delete")
 
 }
 
@@ -368,8 +369,8 @@ func TestStoreDeleteDirectoryFailsIfNonRecursiveAndDir(t *testing.T) {
 	s.Create("/foo", true, "", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e, _err := s.Delete("/foo", false, false)
 	err := _err.(*v2error.Error)
-	testutil.AssertEqual(t, err.ErrorCode, v2error.EcodeNotFile)
-	testutil.AssertEqual(t, err.Message, "Not a file")
+	assert.Equal(t, err.ErrorCode, v2error.EcodeNotFile)
+	assert.Equal(t, err.Message, "Not a file")
 	testutil.AssertNil(t, e)
 }
 
@@ -403,16 +404,16 @@ func TestStoreCompareAndDeletePrevValue(t *testing.T) {
 	s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e, err := s.CompareAndDelete("/foo", "bar", 0)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "compareAndDelete")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "compareAndDelete")
+	assert.Equal(t, e.Node.Key, "/foo")
 
 	// check prevNode
 	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
-	testutil.AssertEqual(t, e.PrevNode.CreatedIndex, uint64(1))
+	assert.Equal(t, e.PrevNode.Key, "/foo")
+	assert.Equal(t, *e.PrevNode.Value, "bar")
+	assert.Equal(t, e.PrevNode.ModifiedIndex, uint64(1))
+	assert.Equal(t, e.PrevNode.CreatedIndex, uint64(1))
 }
 
 func TestStoreCompareAndDeletePrevValueFailsIfNotMatch(t *testing.T) {
@@ -423,12 +424,12 @@ func TestStoreCompareAndDeletePrevValueFailsIfNotMatch(t *testing.T) {
 	s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e, _err := s.CompareAndDelete("/foo", "baz", 0)
 	err := _err.(*v2error.Error)
-	testutil.AssertEqual(t, err.ErrorCode, v2error.EcodeTestFailed)
-	testutil.AssertEqual(t, err.Message, "Compare failed")
+	assert.Equal(t, err.ErrorCode, v2error.EcodeTestFailed)
+	assert.Equal(t, err.Message, "Compare failed")
 	testutil.AssertNil(t, e)
 	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, *e.Node.Value, "bar")
 }
 
 func TestStoreCompareAndDeletePrevIndex(t *testing.T) {
@@ -439,14 +440,14 @@ func TestStoreCompareAndDeletePrevIndex(t *testing.T) {
 	s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e, err := s.CompareAndDelete("/foo", "", 1)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "compareAndDelete")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "compareAndDelete")
 	// check prevNode
 	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
-	testutil.AssertEqual(t, e.PrevNode.CreatedIndex, uint64(1))
+	assert.Equal(t, e.PrevNode.Key, "/foo")
+	assert.Equal(t, *e.PrevNode.Value, "bar")
+	assert.Equal(t, e.PrevNode.ModifiedIndex, uint64(1))
+	assert.Equal(t, e.PrevNode.CreatedIndex, uint64(1))
 }
 
 func TestStoreCompareAndDeletePrevIndexFailsIfNotMatch(t *testing.T) {
@@ -458,12 +459,12 @@ func TestStoreCompareAndDeletePrevIndexFailsIfNotMatch(t *testing.T) {
 	e, _err := s.CompareAndDelete("/foo", "", 100)
 	testutil.AssertNotNil(t, _err)
 	err := _err.(*v2error.Error)
-	testutil.AssertEqual(t, err.ErrorCode, v2error.EcodeTestFailed)
-	testutil.AssertEqual(t, err.Message, "Compare failed")
+	assert.Equal(t, err.ErrorCode, v2error.EcodeTestFailed)
+	assert.Equal(t, err.Message, "Compare failed")
 	testutil.AssertNil(t, e)
 	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, *e.Node.Value, "bar")
 }
 
 // Ensure that the store cannot delete a directory.
@@ -475,7 +476,7 @@ func TestStoreCompareAndDeleteDirectoryFail(t *testing.T) {
 	_, _err := s.CompareAndDelete("/foo", "", 0)
 	testutil.AssertNotNil(t, _err)
 	err := _err.(*v2error.Error)
-	testutil.AssertEqual(t, err.ErrorCode, v2error.EcodeNotFile)
+	assert.Equal(t, err.ErrorCode, v2error.EcodeNotFile)
 }
 
 // Ensure that the store can conditionally update a key if it has a previous value.
@@ -487,18 +488,18 @@ func TestStoreCompareAndSwapPrevValue(t *testing.T) {
 	s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e, err := s.CompareAndSwap("/foo", "bar", 0, "baz", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "compareAndSwap")
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "compareAndSwap")
+	assert.Equal(t, *e.Node.Value, "baz")
 	// check prevNode
 	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
-	testutil.AssertEqual(t, e.PrevNode.CreatedIndex, uint64(1))
+	assert.Equal(t, e.PrevNode.Key, "/foo")
+	assert.Equal(t, *e.PrevNode.Value, "bar")
+	assert.Equal(t, e.PrevNode.ModifiedIndex, uint64(1))
+	assert.Equal(t, e.PrevNode.CreatedIndex, uint64(1))
 
 	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	assert.Equal(t, *e.Node.Value, "baz")
 }
 
 // Ensure that the store cannot conditionally update a key if it has the wrong previous value.
@@ -509,12 +510,12 @@ func TestStoreCompareAndSwapPrevValueFailsIfNotMatch(t *testing.T) {
 	s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e, _err := s.CompareAndSwap("/foo", "wrong_value", 0, "baz", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	err := _err.(*v2error.Error)
-	testutil.AssertEqual(t, err.ErrorCode, v2error.EcodeTestFailed)
-	testutil.AssertEqual(t, err.Message, "Compare failed")
+	assert.Equal(t, err.ErrorCode, v2error.EcodeTestFailed)
+	assert.Equal(t, err.Message, "Compare failed")
 	testutil.AssertNil(t, e)
 	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	assert.Equal(t, *e.Node.Value, "bar")
+	assert.Equal(t, e.EtcdIndex, eidx)
 }
 
 // Ensure that the store can conditionally update a key if it has a previous index.
@@ -525,19 +526,19 @@ func TestStoreCompareAndSwapPrevIndex(t *testing.T) {
 	s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e, err := s.CompareAndSwap("/foo", "", 1, "baz", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "compareAndSwap")
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "compareAndSwap")
+	assert.Equal(t, *e.Node.Value, "baz")
 	// check prevNode
 	testutil.AssertNotNil(t, e.PrevNode)
-	testutil.AssertEqual(t, e.PrevNode.Key, "/foo")
-	testutil.AssertEqual(t, *e.PrevNode.Value, "bar")
-	testutil.AssertEqual(t, e.PrevNode.ModifiedIndex, uint64(1))
-	testutil.AssertEqual(t, e.PrevNode.CreatedIndex, uint64(1))
+	assert.Equal(t, e.PrevNode.Key, "/foo")
+	assert.Equal(t, *e.PrevNode.Value, "bar")
+	assert.Equal(t, e.PrevNode.ModifiedIndex, uint64(1))
+	assert.Equal(t, e.PrevNode.CreatedIndex, uint64(1))
 
 	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
+	assert.Equal(t, *e.Node.Value, "baz")
+	assert.Equal(t, e.EtcdIndex, eidx)
 }
 
 // Ensure that the store cannot conditionally update a key if it has the wrong previous index.
@@ -548,12 +549,12 @@ func TestStoreCompareAndSwapPrevIndexFailsIfNotMatch(t *testing.T) {
 	s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e, _err := s.CompareAndSwap("/foo", "", 100, "baz", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	err := _err.(*v2error.Error)
-	testutil.AssertEqual(t, err.ErrorCode, v2error.EcodeTestFailed)
-	testutil.AssertEqual(t, err.Message, "Compare failed")
+	assert.Equal(t, err.ErrorCode, v2error.EcodeTestFailed)
+	assert.Equal(t, err.Message, "Compare failed")
 	testutil.AssertNil(t, e)
 	e, _ = s.Get("/foo", false, false)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, *e.Node.Value, "bar")
 }
 
 // Ensure that the store can watch for key creation.
@@ -563,13 +564,13 @@ func TestStoreWatchCreate(t *testing.T) {
 	var eidx uint64 = 0
 	w, _ := s.Watch("/foo", false, false, 0)
 	c := w.EventChan()
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	assert.Equal(t, w.StartIndex(), eidx)
 	s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	eidx = 1
 	e := timeoutSelect(t, c)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "create")
+	assert.Equal(t, e.Node.Key, "/foo")
 	select {
 	case e = <-w.EventChan():
 		testutil.AssertNil(t, e)
@@ -584,13 +585,13 @@ func TestStoreWatchRecursiveCreate(t *testing.T) {
 	var eidx uint64 = 0
 	w, err := s.Watch("/foo", true, false, 0)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	assert.Equal(t, w.StartIndex(), eidx)
 	eidx = 1
 	s.Create("/foo/bar", false, "baz", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/foo/bar")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "create")
+	assert.Equal(t, e.Node.Key, "/foo/bar")
 }
 
 // Ensure that the store can watch for key updates.
@@ -600,13 +601,13 @@ func TestStoreWatchUpdate(t *testing.T) {
 	var eidx uint64 = 1
 	s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	w, _ := s.Watch("/foo", false, false, 0)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	assert.Equal(t, w.StartIndex(), eidx)
 	eidx = 2
 	s.Update("/foo", "baz", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "update")
+	assert.Equal(t, e.Node.Key, "/foo")
 }
 
 // Ensure that the store can watch for recursive key updates.
@@ -617,13 +618,13 @@ func TestStoreWatchRecursiveUpdate(t *testing.T) {
 	s.Create("/foo/bar", false, "baz", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	w, err := s.Watch("/foo", true, false, 0)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	assert.Equal(t, w.StartIndex(), eidx)
 	eidx = 2
 	s.Update("/foo/bar", "baz", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/foo/bar")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "update")
+	assert.Equal(t, e.Node.Key, "/foo/bar")
 }
 
 // Ensure that the store can watch for key deletions.
@@ -633,13 +634,13 @@ func TestStoreWatchDelete(t *testing.T) {
 	var eidx uint64 = 1
 	s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	w, _ := s.Watch("/foo", false, false, 0)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	assert.Equal(t, w.StartIndex(), eidx)
 	eidx = 2
 	s.Delete("/foo", false, false)
 	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "delete")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "delete")
+	assert.Equal(t, e.Node.Key, "/foo")
 }
 
 // Ensure that the store can watch for recursive key deletions.
@@ -650,13 +651,13 @@ func TestStoreWatchRecursiveDelete(t *testing.T) {
 	s.Create("/foo/bar", false, "baz", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	w, err := s.Watch("/foo", true, false, 0)
 	testutil.AssertNil(t, err)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	assert.Equal(t, w.StartIndex(), eidx)
 	eidx = 2
 	s.Delete("/foo/bar", false, false)
 	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "delete")
-	testutil.AssertEqual(t, e.Node.Key, "/foo/bar")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "delete")
+	assert.Equal(t, e.Node.Key, "/foo/bar")
 }
 
 // Ensure that the store can watch for CAS updates.
@@ -666,13 +667,13 @@ func TestStoreWatchCompareAndSwap(t *testing.T) {
 	var eidx uint64 = 1
 	s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	w, _ := s.Watch("/foo", false, false, 0)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	assert.Equal(t, w.StartIndex(), eidx)
 	eidx = 2
 	s.CompareAndSwap("/foo", "bar", 0, "baz", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "compareAndSwap")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "compareAndSwap")
+	assert.Equal(t, e.Node.Key, "/foo")
 }
 
 // Ensure that the store can watch for recursive CAS updates.
@@ -682,13 +683,13 @@ func TestStoreWatchRecursiveCompareAndSwap(t *testing.T) {
 	var eidx uint64 = 1
 	s.Create("/foo/bar", false, "baz", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	w, _ := s.Watch("/foo", true, false, 0)
-	testutil.AssertEqual(t, w.StartIndex(), eidx)
+	assert.Equal(t, w.StartIndex(), eidx)
 	eidx = 2
 	s.CompareAndSwap("/foo/bar", "baz", 0, "bat", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "compareAndSwap")
-	testutil.AssertEqual(t, e.Node.Key, "/foo/bar")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "compareAndSwap")
+	assert.Equal(t, e.Node.Key, "/foo/bar")
 }
 
 // Ensure that the store can watch in streaming mode.
@@ -700,10 +701,10 @@ func TestStoreWatchStream(t *testing.T) {
 	// first modification
 	s.Create("/foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, *e.Node.Value, "bar")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "create")
+	assert.Equal(t, e.Node.Key, "/foo")
+	assert.Equal(t, *e.Node.Value, "bar")
 	select {
 	case e = <-w.EventChan():
 		testutil.AssertNil(t, e)
@@ -713,10 +714,10 @@ func TestStoreWatchStream(t *testing.T) {
 	eidx = 2
 	s.Update("/foo", "baz", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e = timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/foo")
-	testutil.AssertEqual(t, *e.Node.Value, "baz")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "update")
+	assert.Equal(t, e.Node.Key, "/foo")
+	assert.Equal(t, *e.Node.Value, "baz")
 	select {
 	case e = <-w.EventChan():
 		testutil.AssertNil(t, e)
@@ -732,9 +733,9 @@ func TestStoreWatchCreateWithHiddenKey(t *testing.T) {
 	w, _ := s.Watch("/_foo", false, false, 0)
 	s.Create("/_foo", false, "bar", false, v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/_foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "create")
+	assert.Equal(t, e.Node.Key, "/_foo")
 	select {
 	case e = <-w.EventChan():
 		testutil.AssertNil(t, e)
@@ -773,8 +774,8 @@ func TestStoreWatchUpdateWithHiddenKey(t *testing.T) {
 	w, _ := s.Watch("/_foo", false, false, 0)
 	s.Update("/_foo", "baz", v2store.TTLOptionSet{ExpireTime: v2store.Permanent})
 	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.Action, "update")
-	testutil.AssertEqual(t, e.Node.Key, "/_foo")
+	assert.Equal(t, e.Action, "update")
+	assert.Equal(t, e.Node.Key, "/_foo")
 	e = nbselect(w.EventChan())
 	testutil.AssertNil(t, e)
 }
@@ -799,9 +800,9 @@ func TestStoreWatchDeleteWithHiddenKey(t *testing.T) {
 	w, _ := s.Watch("/_foo", false, false, 0)
 	s.Delete("/_foo", false, false)
 	e := timeoutSelect(t, w.EventChan())
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "delete")
-	testutil.AssertEqual(t, e.Node.Key, "/_foo")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "delete")
+	assert.Equal(t, e.Node.Key, "/_foo")
 	e = nbselect(w.EventChan())
 	testutil.AssertNil(t, e)
 }
@@ -827,9 +828,9 @@ func TestStoreWatchRecursiveCreateDeeperThanHiddenKey(t *testing.T) {
 
 	e := timeoutSelect(t, w.EventChan())
 	testutil.AssertNotNil(t, e)
-	testutil.AssertEqual(t, e.EtcdIndex, eidx)
-	testutil.AssertEqual(t, e.Action, "create")
-	testutil.AssertEqual(t, e.Node.Key, "/_foo/bar/baz")
+	assert.Equal(t, e.EtcdIndex, eidx)
+	assert.Equal(t, e.Action, "create")
+	assert.Equal(t, e.Node.Key, "/_foo/bar/baz")
 }
 
 // Ensure that slow consumers are handled properly.
@@ -847,10 +848,10 @@ func TestStoreWatchSlowConsumer(t *testing.T) {
 	for i := 1; i <= 100; i++ {
 		s.Set("/foo", false, fmt.Sprint(i), v2store.TTLOptionSet{ExpireTime: v2store.Permanent}) // ok
 	}
-	// testutil.AssertEqual(t, s.WatcherHub.count, int64(1))
+	// assert.Equal(t, s.WatcherHub.count, int64(1))
 	s.Set("/foo", false, "101", v2store.TTLOptionSet{ExpireTime: v2store.Permanent}) // ok
 	// remove watcher
-	// testutil.AssertEqual(t, s.WatcherHub.count, int64(0))
+	// assert.Equal(t, s.WatcherHub.count, int64(0))
 	s.Set("/foo", false, "102", v2store.TTLOptionSet{ExpireTime: v2store.Permanent}) // must not panic
 }
 
