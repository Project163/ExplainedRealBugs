diff --git a/src/nvim/textformat.c b/src/nvim/textformat.c
index c427206764..1722bcc968 100644
--- a/src/nvim/textformat.c
+++ b/src/nvim/textformat.c
@@ -105,14 +105,9 @@ void internal_format(int textwidth, int second_indent, int flags, bool format_on
     colnr_T col;
     bool did_do_comment = false;
 
-    // Cursor is currently at the end of line. No need to format
-    // if line length is less than textwidth (8 * textwidth for
-    // utf safety)
-    if (curwin->w_cursor.col < 8 * textwidth) {
-      colnr_T virtcol = get_nolist_virtcol() + char2cells(c != NUL ? c : gchar_cursor());
-      if (virtcol <= (colnr_T)textwidth) {
-        break;
-      }
+    colnr_T virtcol = get_nolist_virtcol() + char2cells(c != NUL ? c : gchar_cursor());
+    if (virtcol <= (colnr_T)textwidth) {
+      break;
     }
 
     if (no_leader) {
@@ -160,16 +155,9 @@ void internal_format(int textwidth, int second_indent, int flags, bool format_on
     coladvance(curwin, (colnr_T)textwidth);
     wantcol = curwin->w_cursor.col;
 
-    // If startcol is large (a long line), formatting takes too much
-    // time. The algorithm is O(n^2), it walks from the end of the
-    // line to textwidth border every time for each line break.
-    //
-    // Ceil to 8 * textwidth to optimize.
-    curwin->w_cursor.col = startcol < 8 * textwidth ? startcol : 8 * textwidth;
-
+    curwin->w_cursor.col = startcol;
     foundcol = 0;
     int skip_pos = 0;
-    bool first_pass = true;
 
     // Find position to break at.
     // Stop at first entered white when 'formatoptions' has 'v'
@@ -177,9 +165,8 @@ void internal_format(int textwidth, int second_indent, int flags, bool format_on
            || (flags & INSCHAR_FORMAT)
            || curwin->w_cursor.lnum != Insstart.lnum
            || curwin->w_cursor.col >= Insstart.col) {
-      if (first_pass && c != NUL) {
+      if (curwin->w_cursor.col == startcol && c != NUL) {
         cc = c;
-        first_pass = false;
       } else {
         cc = gchar_cursor();
       }
