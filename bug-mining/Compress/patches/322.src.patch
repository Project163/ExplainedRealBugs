diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldParsingBehavior.java b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldParsingBehavior.java
index 2e2945068..943a41aa3 100644
--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldParsingBehavior.java
+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldParsingBehavior.java
@@ -32,7 +32,7 @@ public interface ExtraFieldParsingBehavior extends UnparseableExtraFieldBehavior
      * ExtraFieldUtils#createExtraField}.</p>
      *
      * @param headerId the id for the extra field
-     * @return an instance of ZipExtraField, must not be null
+     * @return an instance of ZipExtraField, must not be {@code null}
      * @throws ZipException if an error occurs
      * @throws InstantiationException if unable to instantiate the class
      * @throws IllegalAccessException if not allowed to instantiate the class
@@ -54,7 +54,8 @@ ZipExtraField createExtraField(final ZipShort headerId)
      * file header. If this is false then the data is part if the
      * central directory header extra data.
      * @return the filled field. Usually this is the same as {@code
-     * field} but it oculd be a replacement extra field as well
+     * field} but it oculd be a replacement extra field as well. Must
+     * not be {@code null}.
      * @throws ZipException if an error occurs
      */
     ZipExtraField fill(ZipExtraField field, byte[] data, int off, int len, boolean local)
diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java
index 3fb60c39d..78f16ba4a 100644
--- a/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java
+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ExtraFieldUtils.java
@@ -20,6 +20,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.zip.ZipException;
 
@@ -213,8 +214,10 @@ public static ZipExtraField[] parse(final byte[] data, final boolean local,
                 break LOOP;
             }
             try {
-                ZipExtraField ze = parsingbehavior.createExtraField(headerId);
-                v.add(parsingbehavior.fill(ze, data, start + WORD, length, local));
+                ZipExtraField ze = Objects.requireNonNull(parsingbehavior.createExtraField(headerId),
+                    "createExtraField must not return null");
+                v.add(Objects.requireNonNull(parsingbehavior.fill(ze, data, start + WORD, length, local),
+                    "fill must not return null"));
                 start += length + WORD;
             } catch (final InstantiationException | IllegalAccessException ie) {
                 throw (ZipException) new ZipException(ie.getMessage()).initCause(ie);
