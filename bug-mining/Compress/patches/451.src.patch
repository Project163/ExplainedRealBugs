diff --git a/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorOutputStream.java b/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorOutputStream.java
index 62bb4460b..e36ee17f7 100644
--- a/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorOutputStream.java
+++ b/src/main/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorOutputStream.java
@@ -104,12 +104,13 @@ public void close() throws IOException {
      * @throws IOException if an error occurs
      */
     public void finish() throws IOException {
-        if (currentIndex > 0) {
-            flushBuffer();
-        }
+        flushBuffer();
     }
 
     private void flushBuffer() throws IOException {
+        if (currentIndex == 0) {
+            return;
+        }
         out.write(FramedSnappyCompressorInputStream.COMPRESSED_CHUNK_TYPE);
         final ByteArrayOutputStream baos = new ByteArrayOutputStream();
         try (OutputStream o = new SnappyCompressorOutputStream(baos, currentIndex, params)) {
@@ -124,18 +125,19 @@ private void flushBuffer() throws IOException {
 
     @Override
     public void write(final byte[] data, int off, int len) throws IOException {
-        if (currentIndex + len > MAX_COMPRESSED_BUFFER_SIZE) {
-            flushBuffer();
-            while (len > MAX_COMPRESSED_BUFFER_SIZE) {
-                System.arraycopy(data, off, buffer, 0, MAX_COMPRESSED_BUFFER_SIZE);
-                off += MAX_COMPRESSED_BUFFER_SIZE;
-                len -= MAX_COMPRESSED_BUFFER_SIZE;
-                currentIndex = MAX_COMPRESSED_BUFFER_SIZE;
+        int blockDataRemaining = buffer.length - currentIndex;
+        while (len > 0) {
+            final int copyLen = Math.min(len, blockDataRemaining);
+            System.arraycopy(data, off, buffer, currentIndex, copyLen);
+            off += copyLen;
+            blockDataRemaining -= copyLen;
+            len -= copyLen;
+            currentIndex += copyLen;
+            if (blockDataRemaining == 0) {
                 flushBuffer();
+                blockDataRemaining = buffer.length;
             }
         }
-        System.arraycopy(data, off, buffer, currentIndex, len);
-        currentIndex += len;
     }
 
     @Override
diff --git a/src/test/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStreamTest.java b/src/test/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStreamTest.java
index 36ec7f9d4..226219af5 100644
--- a/src/test/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStreamTest.java
+++ b/src/test/java/org/apache/commons/compress/compressors/snappy/FramedSnappyCompressorInputStreamTest.java
@@ -172,4 +172,65 @@ public void testUnskippableChunk() {
         }
     }
 
+    @Test
+    public void testWriteDataLargerThanBufferOneCall() throws IOException {
+        int inputSize = 500_000;
+        byte[] data = generateTestData(inputSize);
+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        try (FramedSnappyCompressorOutputStream compressor = new FramedSnappyCompressorOutputStream(outputStream)) {
+            compressor.write(data, 0, data.length);
+            compressor.finish();
+        }
+        byte[] compressed = outputStream.toByteArray();
+
+        byte[] decompressed = new byte[0];
+        try (ByteArrayInputStream bytesIn = new ByteArrayInputStream(compressed, 0, compressed.length);
+                 FramedSnappyCompressorInputStream decompressor = new FramedSnappyCompressorInputStream(bytesIn)) {
+            int i;
+            ByteArrayOutputStream decompressedOutputStream = new ByteArrayOutputStream();
+            while (-1 != (i = decompressor.read())) {
+                decompressedOutputStream.write(i);
+            }
+            decompressed = decompressedOutputStream.toByteArray();
+        }
+        assertArrayEquals(data, decompressed);
+    }
+
+    private static byte[] generateTestData(int inputSize) {
+        byte[] arr = new byte[inputSize];
+        for (int i = 0; i < arr.length; i++) {
+          arr[i] = (byte) (65 + i % 10);
+        }
+
+        return arr;
+    }
+
+    @Test
+    public void testFinishWithNoWrite() throws IOException {
+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        try (FramedSnappyCompressorOutputStream compressor = new FramedSnappyCompressorOutputStream(buffer)) {
+            // do nothing here. this will test that flush on close doesn't throw any exceptions if no data is written.
+        }
+        assertTrue(buffer.size() == 10, "Only the signature gets written.");
+    }
+
+    @Test
+    public void testWriteByteArrayVsWriteByte() throws IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        final byte[] bytes = "abcdefghijklmnop".getBytes();
+        try (FramedSnappyCompressorOutputStream compressor = new FramedSnappyCompressorOutputStream(buffer)) {
+            compressor.write(bytes);
+            compressor.finish();
+        }
+        final byte[] bulkOutput = buffer.toByteArray();
+        buffer = new ByteArrayOutputStream();
+        try (FramedSnappyCompressorOutputStream compressor = new FramedSnappyCompressorOutputStream(buffer)) {
+            for (final byte element : bytes) {
+                compressor.write(element);
+            }
+            compressor.finish();
+        }
+        assertArrayEquals(bulkOutput, buffer.toByteArray());
+    }
+
 }
