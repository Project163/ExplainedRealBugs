diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java
index 12da7bb5c..fdeb0de53 100644
--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java
+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java
@@ -1577,16 +1577,8 @@ private void parseTarHeader(final byte[] header, final ZipEncoding encoding,
             offset += OFFSETLEN_GNU;
             offset += LONGNAMESLEN_GNU;
             offset += PAD2LEN_GNU;
-            sparseHeaders = new ArrayList<>();
-            for (int i = 0; i < SPARSE_HEADERS_IN_OLDGNU_HEADER; i++) {
-                final TarArchiveStructSparse sparseHeader = TarUtils.parseSparse(header,
-                        offset + i * (SPARSE_OFFSET_LEN + SPARSE_NUMBYTES_LEN));
-
-                // some sparse headers are empty, we need to skip these sparse headers
-                if(sparseHeader.getOffset() > 0 || sparseHeader.getNumbytes() > 0) {
-                    sparseHeaders.add(sparseHeader);
-                }
-            }
+            sparseHeaders =
+                new ArrayList<>(TarUtils.readSparseStructs(header, offset, SPARSE_HEADERS_IN_OLDGNU_HEADER));
             offset += SPARSELEN_GNU;
             isExtended = TarUtils.parseBoolean(header, offset);
             offset += ISEXTENDEDLEN_GNU;
diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveSparseEntry.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveSparseEntry.java
index b738de191..697319498 100644
--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveSparseEntry.java
+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveSparseEntry.java
@@ -57,17 +57,7 @@ public class TarArchiveSparseEntry implements TarConstants {
      */
     public TarArchiveSparseEntry(final byte[] headerBuf) throws IOException {
         int offset = 0;
-        sparseHeaders = new ArrayList<>();
-        for(int i = 0; i < SPARSE_HEADERS_IN_EXTENSION_HEADER;i++) {
-            final TarArchiveStructSparse sparseHeader = TarUtils.parseSparse(headerBuf,
-                    offset + i * (SPARSE_OFFSET_LEN + SPARSE_NUMBYTES_LEN));
-
-            // some sparse headers are empty, we need to skip these sparse headers
-            if(sparseHeader.getOffset() > 0 || sparseHeader.getNumbytes() > 0) {
-                sparseHeaders.add(sparseHeader);
-            }
-        }
-
+        sparseHeaders = new ArrayList<>(TarUtils.readSparseStructs(headerBuf, 0, SPARSE_HEADERS_IN_EXTENSION_HEADER));
         offset += SPARSELEN_GNU_SPARSE;
         isExtended = TarUtils.parseBoolean(headerBuf, offset);
     }
diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
index ea4741ab7..fe6fe4da9 100644
--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
@@ -25,6 +25,7 @@
 import java.nio.ByteBuffer;
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -326,6 +327,35 @@ public static TarArchiveStructSparse parseSparse(final byte[] buffer, final int
         return new TarArchiveStructSparse(sparseOffset, sparseNumbytes);
     }
 
+    /**
+     * @since 1.21
+     */
+    static List<TarArchiveStructSparse> readSparseStructs(final byte[] buffer, final int offset, final int entries)
+        throws IOException {
+        final List<TarArchiveStructSparse> sparseHeaders = new ArrayList<>();
+        for (int i = 0; i < entries; i++) {
+            try {
+                final TarArchiveStructSparse sparseHeader =
+                    parseSparse(buffer, offset + i * (SPARSE_OFFSET_LEN + SPARSE_NUMBYTES_LEN));
+
+                if (sparseHeader.getOffset() < 0) {
+                    throw new IOException("Corrupted TAR archive, sparse entry with negative offset");
+                }
+                if (sparseHeader.getNumbytes() < 0) {
+                    throw new IOException("Corrupted TAR archive, sparse entry with negative numbytes");
+                }
+                // some sparse headers are empty, we need to skip these sparse headers
+                if (sparseHeader.getOffset() > 0 || sparseHeader.getNumbytes() > 0) {
+                    sparseHeaders.add(sparseHeader);
+                }
+            } catch (IllegalArgumentException ex) {
+                // thrown internally by parseOctalOrBinary
+                throw new IOException("Corrupted TAR archive, sparse entry is invalid", ex);
+            }
+        }
+        return Collections.unmodifiableList(sparseHeaders);
+    }
+
     /**
      * Copy a name into a buffer.
      * Copies characters from the name into the buffer
