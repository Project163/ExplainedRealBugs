diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java
index 58b006e92..3d33fa4a2 100644
--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java
+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java
@@ -27,7 +27,6 @@
 import java.math.BigInteger;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
-import java.util.Objects;
 import java.util.zip.CRC32;
 import java.util.zip.DataFormatException;
 import java.util.zip.Inflater;
@@ -81,11 +80,15 @@
  */
 public class ZipArchiveInputStream extends ArchiveInputStream implements InputStreamStatistics {
 
-    private final ZipReadingOptions options;
+    /** The zip encoding to use for file names and the file comment. */
+    private final ZipEncoding zipEncoding;
 
     // the provided encoding (for unit tests)
     final String encoding;
 
+    /** Whether to look for and use Unicode extra fields. */
+    private final boolean useUnicodeExtraFields;
+
     /** Wrapped stream, will always be a PushbackInputStream. */
     private final InputStream in;
 
@@ -165,11 +168,11 @@ public class ZipArchiveInputStream extends ArchiveInputStream implements InputSt
     private int entriesRead = 0;
 
     /**
-     * Create an instance using the {@link ZipReadingOptions#DEFAULT default reading options}.
+     * Create an instance using UTF-8 encoding
      * @param inputStream the stream to wrap
      */
     public ZipArchiveInputStream(final InputStream inputStream) {
-        this(inputStream, ZipReadingOptions.DEFAULT);
+        this(inputStream, ZipEncodingHelper.UTF8);
     }
 
     /**
@@ -180,7 +183,7 @@ public ZipArchiveInputStream(final InputStream inputStream) {
      * @since 1.5
      */
     public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {
-        this(inputStream, ZipReadingOptions.builder().withEncoding(encoding).build());
+        this(inputStream, encoding, true);
     }
 
     /**
@@ -192,9 +195,7 @@ public ZipArchiveInputStream(final InputStream inputStream, final String encodin
      * Extra Fields (if present) to set the file names.
      */
     public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {
-        this(inputStream, ZipReadingOptions.builder()
-             .withEncoding(encoding).withUseUnicodeExtraFields(useUnicodeExtraFields)
-             .build(), false);
+        this(inputStream, encoding, useUnicodeExtraFields, false);
     }
 
     /**
@@ -212,37 +213,9 @@ public ZipArchiveInputStream(final InputStream inputStream,
                                  final String encoding,
                                  final boolean useUnicodeExtraFields,
                                  final boolean allowStoredEntriesWithDataDescriptor) {
-        this(inputStream, ZipReadingOptions.builder()
-             .withEncoding(encoding).withUseUnicodeExtraFields(useUnicodeExtraFields)
-             .build(), allowStoredEntriesWithDataDescriptor);
-    }
-
-    /**
-     * Create an instance using the specified reading options.
-     * @param inputStream the stream to wrap
-     * @param options the reading options
-     * @throws NullPointerException if {@code options} is null
-     * @since 1.19
-     */
-    public ZipArchiveInputStream(final InputStream inputStream, final ZipReadingOptions options) {
-        this(inputStream, options, false);
-    }
-
-    /**
-     * Create an instance using the specified reading options.
-     * @param inputStream the stream to wrap
-     * @param options the reading options
-     * @param allowStoredEntriesWithDataDescriptor whether the stream
-     * will try to read STORED entries that use a data descriptor
-     * @throws NullPointerException if {@code options} is null
-     * @since 1.19
-     */
-    public ZipArchiveInputStream(final InputStream inputStream, final ZipReadingOptions options,
-                                 final boolean allowStoredEntriesWithDataDescriptor) {
-        this.options = Objects.requireNonNull(options, "options must not be null");
-        this.encoding = options.getZipEncoding() instanceof NioZipEncoding
-            ? ((NioZipEncoding) options.getZipEncoding()).getCharset().name()
-            : null;
+        this.encoding = encoding;
+        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
+        this.useUnicodeExtraFields = useUnicodeExtraFields;
         in = new PushbackInputStream(inputStream, buf.capacity());
         this.allowStoredEntriesWithDataDescriptor =
             allowStoredEntriesWithDataDescriptor;
@@ -296,8 +269,7 @@ public ZipArchiveEntry getNextZipEntry() throws IOException {
 
         final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfhBuf, off);
         final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
-        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING
-            : options.getZipEncoding();
+        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
         current.hasDataDescriptor = gpFlag.usesDataDescriptor();
         current.entry.setGeneralPurposeBit(gpFlag);
 
@@ -342,7 +314,7 @@ public ZipArchiveEntry getNextZipEntry() throws IOException {
         readFully(extraData);
         current.entry.setExtra(extraData);
 
-        if (!hasUTF8Flag && options.getUseUnicodeExtraFields()) {
+        if (!hasUTF8Flag && useUnicodeExtraFields) {
             ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
         }
 
diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java
index d47d31b74..0dd605e3d 100644
--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java
+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipEncodingHelper.java
@@ -32,7 +32,7 @@ public abstract class ZipEncodingHelper {
     /**
      * name of the encoding UTF-8
      */
-    static final String UTF8 = "UTF-8";
+    static final String UTF8 = "UTF8";
 
     /**
      * the encoding UTF-8
diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java
index 5f5662d1a..152272b5c 100644
--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java
+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java
@@ -39,7 +39,6 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.zip.Inflater;
 import java.util.zip.ZipException;
 
@@ -110,7 +109,19 @@ public class ZipFile implements Closeable {
     private final Map<String, LinkedList<ZipArchiveEntry>> nameMap =
         new HashMap<>(HASH_SIZE);
 
-    private final ZipReadingOptions options;
+    /**
+     * The encoding to use for file names and the file comment.
+     *
+     * <p>For a list of possible values see <a
+     * href="http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.
+     * Defaults to UTF-8.</p>
+     */
+    private final String encoding;
+
+    /**
+     * The zip encoding to use for file names and the file comment.
+     */
+    private final ZipEncoding zipEncoding;
 
     /**
      * File name of actual source.
@@ -122,6 +133,11 @@ public class ZipFile implements Closeable {
      */
     private final SeekableByteChannel archive;
 
+    /**
+     * Whether to look for and use Unicode extra fields.
+     */
+    private final boolean useUnicodeExtraFields;
+
     /**
      * Whether the file is closed.
      */
@@ -137,27 +153,25 @@ public class ZipFile implements Closeable {
     private final ByteBuffer cfhBbuf = ByteBuffer.wrap(cfhBuf);
 
     /**
-     * Opens the given file for reading using {@link
-     * ZipReadingOptions#DEFAULT default reading options}.
+     * Opens the given file for reading, assuming "UTF8" for file names.
      *
      * @param f the archive.
      *
      * @throws IOException if an error occurs while reading the file.
      */
     public ZipFile(final File f) throws IOException {
-        this(f, ZipReadingOptions.DEFAULT);
+        this(f, ZipEncodingHelper.UTF8);
     }
 
     /**
-     * Opens the given file for reading using {@link
-     * ZipReadingOptions#DEFAULT default reading options}.
+     * Opens the given file for reading, assuming "UTF8".
      *
      * @param name name of the archive.
      *
      * @throws IOException if an error occurs while reading the file.
      */
     public ZipFile(final String name) throws IOException {
-        this(new File(name));
+        this(new File(name), ZipEncodingHelper.UTF8);
     }
 
     /**
@@ -171,7 +185,7 @@ public ZipFile(final String name) throws IOException {
      * @throws IOException if an error occurs while reading the file.
      */
     public ZipFile(final String name, final String encoding) throws IOException {
-        this(new File(name), ZipReadingOptions.builder().withEncoding(encoding).build());
+        this(new File(name), encoding, true);
     }
 
     /**
@@ -185,7 +199,7 @@ public ZipFile(final String name, final String encoding) throws IOException {
      * @throws IOException if an error occurs while reading the file.
      */
     public ZipFile(final File f, final String encoding) throws IOException {
-        this(f, ZipReadingOptions.builder().withEncoding(encoding).build());
+        this(f, encoding, true);
     }
 
     /**
@@ -202,25 +216,7 @@ public ZipFile(final File f, final String encoding) throws IOException {
      */
     public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields)
         throws IOException {
-        this(f, ZipReadingOptions.builder()
-             .withEncoding(encoding).withUseUnicodeExtraFields(useUnicodeExtraFields)
-             .build());
-    }
-
-    /**
-     * Opens the given file for reading, assuming the specified
-     * options.
-     *
-     * @param f the archive.
-     * @param options the reading options
-     *
-     * @throws IOException if an error occurs while reading the file.
-     * @throws NullPointerException if {@code options} is null
-     * @since 1.19
-     */
-    public ZipFile(final File f, final ZipReadingOptions options)
-        throws IOException {
-        this(f, options, false);
+        this(f, encoding, useUnicodeExtraFields, false);
     }
 
     /**
@@ -238,24 +234,25 @@ public ZipFile(final File f, final ZipReadingOptions options)
      * true}.</p>
      *
      * @param f the archive.
-     * @param options the reading options
+     * @param encoding the encoding to use for file names, use null
+     * for the platform's default encoding
+     * @param useUnicodeExtraFields whether to use InfoZIP Unicode
+     * Extra Fields (if present) to set the file names.
      * @param ignoreLocalFileHeader whether to ignore information
      * stored inside the local file header (see the notes in this method's javadoc)
      *
      * @throws IOException if an error occurs while reading the file.
-     * @throws NullPointerException if {@code options} is null
      * @since 1.19
      */
-    public ZipFile(final File f, final ZipReadingOptions options,
+    public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields,
                    final boolean ignoreLocalFileHeader)
         throws IOException {
         this(Files.newByteChannel(f.toPath(), EnumSet.of(StandardOpenOption.READ)),
-             f.getAbsolutePath(), options, true, ignoreLocalFileHeader);
+             f.getAbsolutePath(), encoding, useUnicodeExtraFields, true, ignoreLocalFileHeader);
     }
 
     /**
-     * Opens the given channel for reading using {@link
-     * ZipReadingOptions#DEFAULT default reading options}.
+     * Opens the given channel for reading, assuming "UTF8" for file names.
      *
      * <p>{@link
      * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}
@@ -268,7 +265,7 @@ public ZipFile(final File f, final ZipReadingOptions options,
      */
     public ZipFile(final SeekableByteChannel channel)
             throws IOException {
-        this(channel, "unknown archive", ZipReadingOptions.DEFAULT);
+        this(channel, "unknown archive", ZipEncodingHelper.UTF8, true);
     }
 
     /**
@@ -288,7 +285,7 @@ public ZipFile(final SeekableByteChannel channel)
      */
     public ZipFile(final SeekableByteChannel channel, final String encoding)
         throws IOException {
-        this(channel, "unknown archive", ZipReadingOptions.builder().withEncoding(encoding).build());
+        this(channel, "unknown archive", encoding, true);
     }
 
     /**
@@ -312,30 +309,7 @@ public ZipFile(final SeekableByteChannel channel, final String encoding)
     public ZipFile(final SeekableByteChannel channel, final String archiveName,
                    final String encoding, final boolean useUnicodeExtraFields)
         throws IOException {
-        this(channel, archiveName, ZipReadingOptions.builder()
-             .withEncoding(encoding).withUseUnicodeExtraFields(useUnicodeExtraFields)
-             .build());
-    }
-
-    /**
-     * Opens the given channel for reading, assuming the specified
-     * reading options.
-     *
-     * <p>{@link
-     * org.apache.commons.compress.utils.SeekableInMemoryByteChannel}
-     * allows you to read from an in-memory archive.</p>
-     *
-     * @param channel the archive.
-     * @param archiveName name of the archive, used for error messages only.
-     * @param options the reading options
-     *
-     * @throws IOException if an error occurs while reading the file.
-     * @throws NullPointerException if {@code options} is null
-     * @since 1.19
-     */
-    public ZipFile(final SeekableByteChannel channel, final String archiveName,
-                   final ZipReadingOptions options) throws IOException {
-        this(channel, archiveName, options, false);
+        this(channel, archiveName, encoding, useUnicodeExtraFields, false, false);
     }
 
     /**
@@ -357,27 +331,31 @@ public ZipFile(final SeekableByteChannel channel, final String archiveName,
      *
      * @param channel the archive.
      * @param archiveName name of the archive, used for error messages only.
-     * @param options the reading options
+     * @param encoding the encoding to use for file names, use null
+     * for the platform's default encoding
+     * @param useUnicodeExtraFields whether to use InfoZIP Unicode
+     * Extra Fields (if present) to set the file names.
      * @param ignoreLocalFileHeader whether to ignore information
      * stored inside the local file header (see the notes in this method's javadoc)
      *
      * @throws IOException if an error occurs while reading the file.
-     * @throws NullPointerException if {@code options} is null
      * @since 1.19
      */
     public ZipFile(final SeekableByteChannel channel, final String archiveName,
-                   final ZipReadingOptions options,
+                   final String encoding, final boolean useUnicodeExtraFields,
                    final boolean ignoreLocalFileHeader)
         throws IOException {
-        this(channel, archiveName, options, false, ignoreLocalFileHeader);
+        this(channel, archiveName, encoding, useUnicodeExtraFields, false, ignoreLocalFileHeader);
     }
 
     private ZipFile(final SeekableByteChannel channel, final String archiveName,
-                    final ZipReadingOptions options,
+                    final String encoding, final boolean useUnicodeExtraFields,
                     final boolean closeOnError, final boolean ignoreLocalFileHeader)
         throws IOException {
         this.archiveName = archiveName;
-        this.options = Objects.requireNonNull(options, "options must not be null");
+        this.encoding = encoding;
+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
+        this.useUnicodeExtraFields = useUnicodeExtraFields;
         archive = channel;
         boolean success = false;
         try {
@@ -402,9 +380,7 @@ private ZipFile(final SeekableByteChannel channel, final String archiveName,
      * @return null if using the platform's default character encoding.
      */
     public String getEncoding() {
-        return options.getZipEncoding() instanceof NioZipEncoding
-            ? ((NioZipEncoding) options.getZipEncoding()).getCharset().name()
-            : null;
+        return encoding;
     }
 
     /**
@@ -650,7 +626,7 @@ public void close() throws IOException {
     public String getUnixSymlink(final ZipArchiveEntry entry) throws IOException {
         if (entry != null && entry.isUnixSymlink()) {
             try (InputStream in = getInputStream(entry)) {
-                return options.getZipEncoding().decode(IOUtils.toByteArray(in));
+                return zipEncoding.decode(IOUtils.toByteArray(in));
             }
         }
         return null;
@@ -763,7 +739,7 @@ private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()
         final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfhBuf, off);
         final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
         final ZipEncoding entryEncoding =
-            hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : options.getZipEncoding();
+            hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
         if (hasUTF8Flag) {
             ze.setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);
         }
@@ -826,7 +802,7 @@ private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()
         IOUtils.readFully(archive, ByteBuffer.wrap(comment));
         ze.setComment(entryEncoding.decode(comment));
 
-        if (!hasUTF8Flag && options.getUseUnicodeExtraFields()) {
+        if (!hasUTF8Flag && useUnicodeExtraFields) {
             noUTF8Flag.put(ze, new NameAndComment(fileName, comment));
         }
 
diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipReadingOptions.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipReadingOptions.java
deleted file mode 100644
index 386490e20..000000000
--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipReadingOptions.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- */
-
-package org.apache.commons.compress.archivers.zip;
-
-import java.util.Objects;
-
-/**
- * Collects options that control parsing of ZIP archives.
- *
- * @since 1.19
- */
-public final class ZipReadingOptions {
-    private static final ZipEncoding DEFAULT_ZIPENCODING = ZipEncodingHelper.UTF8_ZIP_ENCODING;
-    private static final boolean DEFAULT_USEUNICODEEXTRAFIELDS = true;
-    private static final ExtraFieldUtils.ParseErrorBehavior DEFAULT_EXTRAFIELDPARSEERRORBEHAVIOR =
-        ExtraFieldUtils.ParseErrorBehavior.MAKE_UNRECOGNIZED;
-
-    private final ZipEncoding zipEncoding;
-    private final boolean useUnicodeExtraFields;
-    private final ExtraFieldUtils.ParseErrorBehavior extraFieldParseErrorBehavior;
-
-    /**
-     * The default reading options.
-     *
-     * <ul>
-     * <li>UTF-8 encoding</li>
-     * <li>use unicode extra fields when available</li>
-     * <li>convert invalid extra fields into {@link UnparseableExtraFieldData}</li>
-     * </ul>
-     */
-    public static final ZipReadingOptions DEFAULT = new ZipReadingOptions(DEFAULT_ZIPENCODING,
-        DEFAULT_USEUNICODEEXTRAFIELDS, DEFAULT_EXTRAFIELDPARSEERRORBEHAVIOR);
-
-    private ZipReadingOptions(ZipEncoding zipEncoding, boolean useUnicodeExtraFields,
-        ExtraFieldUtils.ParseErrorBehavior extraFieldParseErrorBehavior) {
-        this.zipEncoding = zipEncoding;
-        this.useUnicodeExtraFields = useUnicodeExtraFields;
-        this.extraFieldParseErrorBehavior = extraFieldParseErrorBehavior;
-    }
-
-    /**
-     * The zip encoding to use for file names and the file comment.
-     */
-    public ZipEncoding getZipEncoding() {
-        return zipEncoding;
-    }
-
-    /**
-     * Whether to look for and use Unicode extra fields.
-     */
-    public boolean getUseUnicodeExtraFields() {
-        return useUnicodeExtraFields;
-    }
-
-    /**
-     * How to handle extra fields that are generally supported by
-     * Commons Compress but cannot be parsed in an archive.
-     *
-     * <p>The archive may contain corrupt extra fields or use a
-     * version not supported by Commons Compress.</p>
-     */
-    public ExtraFieldUtils.ParseErrorBehavior getExtraFieldParseErrorBehavior() {
-        return extraFieldParseErrorBehavior;
-    }
-
-    /**
-     * Obtains a builder for {@link ZipReadingOptions}.
-     */
-    public static Builder builder() {
-        return new Builder();
-    }
-
-    /**
-     * Builder for {@link ZipReadingOptions}.
-     */
-    public static class Builder {
-        private ZipEncoding zipEncoding = DEFAULT_ZIPENCODING;
-        private boolean useUnicodeExtraFields = DEFAULT_USEUNICODEEXTRAFIELDS;
-        private ExtraFieldUtils.ParseErrorBehavior extraFieldParseErrorBehavior =
-            DEFAULT_EXTRAFIELDPARSEERRORBEHAVIOR;
-
-        /**
-         * Configures the ZIP encoding.
-         *
-         * @throws NullPointException if {@code zipEncoding} is null
-         */
-        public Builder withZipEncoding(ZipEncoding zipEncoding) {
-            this.zipEncoding = Objects.requireNonNull(zipEncoding, "zipEncoding must not be null");
-            return this;
-        }
-
-        /**
-         * Configures the encoding.
-         *
-         * @param encoding name of the encoding to use, {@code null}
-         * means to use the platform's default encoding
-         */
-        public Builder withEncoding(String encoding) {
-            return withZipEncoding(ZipEncodingHelper.getZipEncoding(encoding));
-        }
-
-        /**
-         * Configures whether to use unicode extra fields to configure names and comments.
-         */
-        public Builder withUseUnicodeExtraFields(boolean useUnicodeExtraFields) {
-            this.useUnicodeExtraFields = useUnicodeExtraFields;
-            return this;
-        }
-
-        /**
-         * Configures how to handle extra fields that are generally
-         * supported by Commons Compress but cannot be parsed in an
-         * archive.
-         *
-         * @throws NullPointException if {@code extraFieldParseErrorBehavior} is null
-         */
-        public Builder withextraFieldParseErrorBehavior(ExtraFieldUtils.ParseErrorBehavior extraFieldParseErrorBehavior) {
-            this.extraFieldParseErrorBehavior = Objects.requireNonNull(extraFieldParseErrorBehavior,
-                "extraFieldParseErrorBehavior must not be null");
-            return this;
-        }
-
-        /**
-         * Create the configured {@link ZipReadingOptions}.
-         */
-        public ZipReadingOptions build() {
-            return new ZipReadingOptions(zipEncoding, useUnicodeExtraFields, extraFieldParseErrorBehavior);
-        }
-    }
-}
diff --git a/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java b/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java
index 3f3e3f760..f7113ac04 100644
--- a/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java
+++ b/src/test/java/org/apache/commons/compress/archivers/ArchiveStreamFactoryTest.java
@@ -195,9 +195,9 @@ static ArchiveStreamFactory getFactory(final String entryEncoding) {
     // The different factory types
     private static final ArchiveStreamFactory FACTORY = new ArchiveStreamFactory();
     private static final ArchiveStreamFactory FACTORY_UTF8 = new ArchiveStreamFactory("UTF-8");
-    private static final ArchiveStreamFactory FACTORY_ASCII = new ArchiveStreamFactory("US-ASCII");
+    private static final ArchiveStreamFactory FACTORY_ASCII = new ArchiveStreamFactory("ASCII");
     private static final ArchiveStreamFactory FACTORY_SET_UTF8 = getFactory("UTF-8");
-    private static final ArchiveStreamFactory FACTORY_SET_ASCII = getFactory("US-ASCII");
+    private static final ArchiveStreamFactory FACTORY_SET_ASCII = getFactory("ASCII");
 
     // Default encoding if none is provided (not even null)
     // The test currently assumes that the output default is the same as the input default
@@ -275,39 +275,39 @@ private String detect(String resource) throws IOException, ArchiveException {
     static final TestData[] TESTS = {
         new TestData("bla.arj", ArchiveStreamFactory.ARJ, false, ARJ_DEFAULT, FACTORY, "charsetName"),
         new TestData("bla.arj", ArchiveStreamFactory.ARJ, false, "UTF-8", FACTORY_UTF8, "charsetName"),
-        new TestData("bla.arj", ArchiveStreamFactory.ARJ, false, "US-ASCII", FACTORY_ASCII, "charsetName"),
+        new TestData("bla.arj", ArchiveStreamFactory.ARJ, false, "ASCII", FACTORY_ASCII, "charsetName"),
         new TestData("bla.arj", ArchiveStreamFactory.ARJ, false, "UTF-8", FACTORY_SET_UTF8, "charsetName"),
-        new TestData("bla.arj", ArchiveStreamFactory.ARJ, false, "US-ASCII", FACTORY_SET_ASCII, "charsetName"),
+        new TestData("bla.arj", ArchiveStreamFactory.ARJ, false, "ASCII", FACTORY_SET_ASCII, "charsetName"),
 
         new TestData("bla.cpio", ArchiveStreamFactory.CPIO, true, CPIO_DEFAULT, FACTORY, "encoding"),
         new TestData("bla.cpio", ArchiveStreamFactory.CPIO, true, "UTF-8", FACTORY_UTF8, "encoding"),
-        new TestData("bla.cpio", ArchiveStreamFactory.CPIO, true, "US-ASCII", FACTORY_ASCII, "encoding"),
+        new TestData("bla.cpio", ArchiveStreamFactory.CPIO, true, "ASCII", FACTORY_ASCII, "encoding"),
         new TestData("bla.cpio", ArchiveStreamFactory.CPIO, true, "UTF-8", FACTORY_SET_UTF8, "encoding"),
-        new TestData("bla.cpio", ArchiveStreamFactory.CPIO, true, "US-ASCII", FACTORY_SET_ASCII, "encoding"),
+        new TestData("bla.cpio", ArchiveStreamFactory.CPIO, true, "ASCII", FACTORY_SET_ASCII, "encoding"),
 
         new TestData("bla.dump", ArchiveStreamFactory.DUMP, false, DUMP_DEFAULT, FACTORY, "encoding"),
         new TestData("bla.dump", ArchiveStreamFactory.DUMP, false, "UTF-8", FACTORY_UTF8, "encoding"),
-        new TestData("bla.dump", ArchiveStreamFactory.DUMP, false, "US-ASCII", FACTORY_ASCII, "encoding"),
+        new TestData("bla.dump", ArchiveStreamFactory.DUMP, false, "ASCII", FACTORY_ASCII, "encoding"),
         new TestData("bla.dump", ArchiveStreamFactory.DUMP, false, "UTF-8", FACTORY_SET_UTF8, "encoding"),
-        new TestData("bla.dump", ArchiveStreamFactory.DUMP, false, "US-ASCII", FACTORY_SET_ASCII, "encoding"),
+        new TestData("bla.dump", ArchiveStreamFactory.DUMP, false, "ASCII", FACTORY_SET_ASCII, "encoding"),
 
         new TestData("bla.tar", ArchiveStreamFactory.TAR, true, TAR_DEFAULT, FACTORY, "encoding"),
         new TestData("bla.tar", ArchiveStreamFactory.TAR, true, "UTF-8", FACTORY_UTF8, "encoding"),
-        new TestData("bla.tar", ArchiveStreamFactory.TAR, true, "US-ASCII", FACTORY_ASCII, "encoding"),
+        new TestData("bla.tar", ArchiveStreamFactory.TAR, true, "ASCII", FACTORY_ASCII, "encoding"),
         new TestData("bla.tar", ArchiveStreamFactory.TAR, true, "UTF-8", FACTORY_SET_UTF8, "encoding"),
-        new TestData("bla.tar", ArchiveStreamFactory.TAR, true, "US-ASCII", FACTORY_SET_ASCII, "encoding"),
+        new TestData("bla.tar", ArchiveStreamFactory.TAR, true, "ASCII", FACTORY_SET_ASCII, "encoding"),
 
         new TestData("bla.jar", ArchiveStreamFactory.JAR, true, JAR_DEFAULT, FACTORY, "encoding"),
         new TestData("bla.jar", ArchiveStreamFactory.JAR, true, "UTF-8", FACTORY_UTF8, "encoding"),
-        new TestData("bla.jar", ArchiveStreamFactory.JAR, true, "US-ASCII", FACTORY_ASCII, "encoding"),
+        new TestData("bla.jar", ArchiveStreamFactory.JAR, true, "ASCII", FACTORY_ASCII, "encoding"),
         new TestData("bla.jar", ArchiveStreamFactory.JAR, true, "UTF-8", FACTORY_SET_UTF8, "encoding"),
-        new TestData("bla.jar", ArchiveStreamFactory.JAR, true, "US-ASCII", FACTORY_SET_ASCII, "encoding"),
+        new TestData("bla.jar", ArchiveStreamFactory.JAR, true, "ASCII", FACTORY_SET_ASCII, "encoding"),
 
         new TestData("bla.zip", ArchiveStreamFactory.ZIP, true, ZIP_DEFAULT, FACTORY, "encoding"),
         new TestData("bla.zip", ArchiveStreamFactory.ZIP, true, "UTF-8", FACTORY_UTF8, "encoding"),
-        new TestData("bla.zip", ArchiveStreamFactory.ZIP, true, "US-ASCII", FACTORY_ASCII, "encoding"),
+        new TestData("bla.zip", ArchiveStreamFactory.ZIP, true, "ASCII", FACTORY_ASCII, "encoding"),
         new TestData("bla.zip", ArchiveStreamFactory.ZIP, true, "UTF-8", FACTORY_SET_UTF8, "encoding"),
-        new TestData("bla.zip", ArchiveStreamFactory.ZIP, true, "US-ASCII", FACTORY_SET_ASCII, "encoding"),
+        new TestData("bla.zip", ArchiveStreamFactory.ZIP, true, "ASCII", FACTORY_SET_ASCII, "encoding"),
     };
 
     @Test
@@ -354,8 +354,8 @@ public void testEncodingOutputStream() throws Exception {
         for(int i = 1; i <= TESTS.length; i++) {
             final TestData test = TESTS[i-1];
             if (test.hasOutputStream) {
-                try (final ArchiveOutputStream aos = getOutputStreamFor(test.type, test.fac)) {
-                    final String field = getField(aos, test.fieldName);
+                try (final ArchiveOutputStream ais = getOutputStreamFor(test.type, test.fac)) {
+                    final String field = getField(ais, test.fieldName);
                     if (!eq(test.expectedEncoding, field)) {
                         System.out.println("Failed test " + i + ". expected: " + test.expectedEncoding + " actual: "
                                 + field + " type: " + test.type);
diff --git a/src/test/java/org/apache/commons/compress/archivers/zip/Maven221MultiVolumeTest.java b/src/test/java/org/apache/commons/compress/archivers/zip/Maven221MultiVolumeTest.java
index 4ce4f5669..0a905e3ab 100644
--- a/src/test/java/org/apache/commons/compress/archivers/zip/Maven221MultiVolumeTest.java
+++ b/src/test/java/org/apache/commons/compress/archivers/zip/Maven221MultiVolumeTest.java
@@ -72,7 +72,7 @@ public void testRead7ZipMultiVolumeArchiveForStream() throws IOException {
             new FileInputStream(getFile("apache-maven-2.2.1.zip.001"));
         ZipArchiveInputStream zi = null;
         try {
-            zi = new ZipArchiveInputStream(archive, (String) null, false);
+            zi = new ZipArchiveInputStream(archive,null,false);
 
             // these are the entries that are supposed to be processed
             // correctly without any problems
diff --git a/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java b/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
index c7ff05bf0..7c745a15a 100644
--- a/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
+++ b/src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java
@@ -134,7 +134,7 @@ public void testReadWinZipArchive() throws IOException {
         final File archive = getFile("utf8-winzip-test.zip");
         ZipFile zf = null;
         try {
-            zf = new ZipFile(archive, (String) null, true);
+            zf = new ZipFile(archive, null, true);
             assertCanRead(zf, ASCII_TXT);
             assertCanRead(zf, EURO_FOR_DOLLAR_TXT);
             assertCanRead(zf, OIL_BARREL_TXT);
@@ -161,7 +161,7 @@ public void testReadWinZipArchiveForStream() throws IOException {
             new FileInputStream(getFile("utf8-winzip-test.zip"));
         ZipArchiveInputStream zi = null;
         try {
-            zi = new ZipArchiveInputStream(archive, (String) null, true);
+            zi = new ZipArchiveInputStream(archive, null, true);
             assertEquals(EURO_FOR_DOLLAR_TXT, zi.getNextEntry().getName());
             assertEquals(OIL_BARREL_TXT, zi.getNextEntry().getName());
             assertEquals(ASCII_TXT, zi.getNextEntry().getName());
diff --git a/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileIgnoringLocalFileHeaderTest.java b/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileIgnoringLocalFileHeaderTest.java
index 457192dd9..3d40c0313 100644
--- a/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileIgnoringLocalFileHeaderTest.java
+++ b/src/test/java/org/apache/commons/compress/archivers/zip/ZipFileIgnoringLocalFileHeaderTest.java
@@ -103,6 +103,6 @@ public void testPhysicalOrder() throws IOException {
     }
 
     private static ZipFile openZipWithoutLFH(String fileName) throws IOException {
-        return new ZipFile(AbstractTestCase.getFile(fileName), ZipReadingOptions.DEFAULT, true);
+        return new ZipFile(AbstractTestCase.getFile(fileName), ZipEncodingHelper.UTF8, true, true);
     }
 }
