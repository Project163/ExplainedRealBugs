diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 8d3866313..5f3f9fca9 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -48,6 +48,9 @@ The <action> type attribute can be add,update,fix,remove.
         Removed the objenesis dependency from the pom as it is not
         needed at all.
       </action>
+      <action issue="COMPRESS-446" type="fix" date="2018-03-29">
+        Fixed resource leak in ParallelScatterZipCreator#writeTo.
+      </action>
     </release>
     <release version="1.16.1" date="2018-02-10"
              description="Release 1.16.1">
diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java
index 369a64938..b8d4e2c14 100644
--- a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java
+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java
@@ -227,6 +227,10 @@ public Object call() throws Exception {
      * before calling this method.
      * </p>
      *
+     * <p>Calling this method will shut down the {@link ExecutorService} used by this class. If any of the {@link
+     * Callable}s {@link #submit}ted to this instance throws an exception, the archive can not be created properly and
+     * this method will throw an exception.</p>
+     *
      * @param targetStream The {@link ZipArchiveOutputStream} to receive the contents of the scatter streams
      * @throws IOException          If writing fails
      * @throws InterruptedException If we get interrupted
@@ -236,11 +240,14 @@ public void writeTo(final ZipArchiveOutputStream targetStream)
             throws IOException, InterruptedException, ExecutionException {
 
         // Make sure we catch any exceptions from parallel phase
+        try {
         for (final Future<?> future : futures) {
             future.get();
         }
-
+        } finally {
         es.shutdown();
+        }
+
         es.awaitTermination(1000 * 60L, TimeUnit.SECONDS);  // == Infinity. We really *must* wait for this to complete
 
         // It is important that all threads terminate before we go on, ensure happens-before relationship
