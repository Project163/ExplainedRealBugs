diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 5b9619aba..e16e763de 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -58,6 +58,10 @@ The <action> type attribute can be add,update,fix,remove.
         TarArchiveInputStream has a new constructor-arg lenient that
         can be used to accept certain broken archives.
       </action>
+      <action issue="COMPRESS-470" type="fix" date="2018-11-18">
+        Fixed another potential resource leak in
+        ParallelScatterZipCreator#writeTo.
+      </action>
     </release>
     <release version="1.18" date="2018-08-16"
              description="Release 1.18">
diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java
index a381d0a28..f2a167945 100644
--- a/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java
+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ParallelScatterZipCreator.java
@@ -239,6 +239,7 @@ public Object call() throws Exception {
     public void writeTo(final ZipArchiveOutputStream targetStream)
             throws IOException, InterruptedException, ExecutionException {
 
+        try {
         // Make sure we catch any exceptions from parallel phase
         try {
             for (final Future<?> future : futures) {
@@ -261,6 +262,9 @@ public void writeTo(final ZipArchiveOutputStream targetStream)
         }
 
         scatterDoneAt = System.currentTimeMillis();
+        } finally {
+            ensureStreamsAreClosed();
+        }
     }
 
     /**
@@ -271,5 +275,17 @@ public void writeTo(final ZipArchiveOutputStream targetStream)
     public ScatterStatistics getStatisticsMessage() {
         return new ScatterStatistics(compressionDoneAt - startedAt, scatterDoneAt - compressionDoneAt);
     }
+
+    private void ensureStreamsAreClosed() {
+        synchronized (streams) {
+            for (final ScatterZipOutputStream scatterStream : streams) {
+                try {
+                    scatterStream.close();
+                } catch (IOException ex) {
+                    // no way to properly log this
+                }
+            }
+        }
+    }
 }
 
diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java
index 7001c84a1..006c53133 100644
--- a/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java
+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ScatterZipOutputStream.java
@@ -29,6 +29,7 @@
 import java.io.InputStream;
 import java.util.Queue;
 import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.zip.Deflater;
 
 /**
@@ -49,6 +50,7 @@ public class ScatterZipOutputStream implements Closeable {
     private final Queue<CompressedEntry> items = new ConcurrentLinkedQueue<>();
     private final ScatterGatherBackingStore backingStore;
     private final StreamCompressor streamCompressor;
+    private AtomicBoolean isClosed = new AtomicBoolean();
 
     private static class CompressedEntry {
         final ZipArchiveEntryRequest zipArchiveEntryRequest;
@@ -124,6 +126,9 @@ public void writeTo(final ZipArchiveOutputStream target) throws IOException {
      */
     @Override
     public void close() throws IOException {
+        if (!isClosed.compareAndSet(false, true)) {
+            return;
+        }
         try {
             backingStore.close();
         } finally {
