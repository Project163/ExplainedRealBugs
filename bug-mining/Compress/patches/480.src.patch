diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 010cbd81c..5f67e0aba 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -55,6 +55,7 @@ The <action> type attribute can be add,update,fix,remove.
       <action type="fix" dev="ggregory" due-to="takaaki nakama, Gary Gregory">ArArchiveOutputStream doesn't pad correctly when a file name length is odd and greater than 16 (padding missing).</action>
       <action type="fix" issue="COMPRESS-678" dev="ggregory" due-to="Gary Gregory">ArArchiveOutputStream should check that a file name length greater than 16 fits in a header.</action>
       <action type="fix" dev="ggregory" due-to="Gary Gregory">ArArchiveOutputStream implicit narrowing conversion in compound assignment.</action>
+      <action type="fix" issue="COMPRESS-679" dev="ggregory" due-to="MikaÃ«l MECHOULAM, Gary Gregory">Regression on parallel processing of 7zip files.</action>
       <!-- UPDATE -->
       <action type="update" dev="ggregory" due-to="Dependabot, Gary Gregory">Bump org.apache.commons:commons-parent from 66 to 69 #495, #508.</action>
       <action type="update" dev="ggregory" due-to="Dependabot, Gary Gregory">Bump org.ow2.asm:asm from 9.6 to 9.7 #504.</action>
diff --git a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java
index 0fad4fb2e..9ccbe38e4 100644
--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java
+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java
@@ -903,17 +903,15 @@ private InputStream getCurrentStream() throws IOException {
         if (deferredBlockStreams.isEmpty()) {
             throw new IllegalStateException("No current 7z entry (call getNextEntry() first).");
         }
-
         while (deferredBlockStreams.size() > 1) {
             // In solid compression mode we need to decompress all leading folder'
             // streams to get access to an entry. We defer this until really needed
             // so that entire blocks can be skipped without wasting time for decompression.
             try (InputStream stream = deferredBlockStreams.remove(0)) {
-                org.apache.commons.io.IOUtils.skip(stream, Long.MAX_VALUE);
+                org.apache.commons.io.IOUtils.skip(stream, Long.MAX_VALUE, org.apache.commons.io.IOUtils::byteArray);
             }
             compressedBytesReadFromCurrentEntry = 0;
         }
-
         return deferredBlockStreams.get(0);
     }
 
diff --git a/src/test/java/org/apache/commons/compress/archivers/sevenz/Compress679Test.java b/src/test/java/org/apache/commons/compress/archivers/sevenz/Compress679Test.java
index e8bd9607c..b6f9020d7 100644
--- a/src/test/java/org/apache/commons/compress/archivers/sevenz/Compress679Test.java
+++ b/src/test/java/org/apache/commons/compress/archivers/sevenz/Compress679Test.java
@@ -18,45 +18,47 @@
 package org.apache.commons.compress.archivers.sevenz;
 
 import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
 
 import java.io.InputStream;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
-import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 
 public class Compress679Test {
 
     @Test
-    @Disabled("Temp")
     public void testCompress679() {
         final Path origin = Paths.get("src/test/resources/org/apache/commons/compress/COMPRESS-679/file.7z");
         assertTrue(Files.exists(origin));
-        final List<Exception> list = new CopyOnWriteArrayList<>();
-        final Runnable runnable = () -> {
-            try {
-                try (SevenZFile sevenZFile = SevenZFile.builder().setPath(origin).get()) {
-                    SevenZArchiveEntry sevenZArchiveEntry;
-                    while ((sevenZArchiveEntry = sevenZFile.getNextEntry()) != null) {
-                        if ("file4.txt".equals(sevenZArchiveEntry.getName())) { // The entry must not be the first of the ZIP archive to reproduce
-                            final InputStream inputStream = sevenZFile.getInputStream(sevenZArchiveEntry);
-                            // treatments...
-                            break;
-                        }
+        final Callable<Boolean> runnable = () -> {
+            try (SevenZFile sevenZFile = SevenZFile.builder().setPath(origin).get()) {
+                SevenZArchiveEntry sevenZArchiveEntry;
+                while ((sevenZArchiveEntry = sevenZFile.getNextEntry()) != null) {
+                    if ("file4.txt".equals(sevenZArchiveEntry.getName())) { // The entry must not be the first of the ZIP archive to reproduce
+                        final InputStream inputStream = sevenZFile.getInputStream(sevenZArchiveEntry);
+                        // treatments...
+                        break;
                     }
                 }
-            } catch (final Exception e) {
-                // java.io.IOException: Checksum verification failed
-                e.printStackTrace();
-                list.add(e);
             }
+            return Boolean.TRUE;
         };
-        IntStream.range(0, 30).forEach(i -> new Thread(runnable).start());
-        assertTrue(list.isEmpty(), list::toString);
+        final ExecutorService threadPool = Executors.newFixedThreadPool(10);
+        try {
+            final List<Future<Boolean>> futures = IntStream.range(0, 30).mapToObj(i -> threadPool.submit(runnable)).collect(Collectors.toList());
+            futures.forEach(f -> assertDoesNotThrow(() -> f.get()));
+        } finally {
+            threadPool.shutdownNow();
+        }
     }
 }
