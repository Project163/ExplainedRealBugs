diff --git a/src/geom/polygon.js b/src/geom/polygon.js
index 530ee586..22a1b719 100644
--- a/src/geom/polygon.js
+++ b/src/geom/polygon.js
@@ -1,6 +1,8 @@
 import "geom";
 
+// Note: removes the closing coordinate if the polygon is not already open.
 d3.geom.polygon = function(coordinates) {
+  d3_geom_polygonOpen(coordinates);
 
   coordinates.area = function() {
     var i = -1,
@@ -36,7 +38,7 @@ d3.geom.polygon = function(coordinates) {
   };
 
   // The Sutherland-Hodgman clipping algorithm.
-  // Note: requires the clip polygon to be counterclockwise and convex.
+  // Note: requires the clip polygon to be open, counterclockwise and convex.
   coordinates.clip = function(subject) {
     var input,
         i = -1,
@@ -84,3 +86,10 @@ function d3_geom_polygonIntersect(c, d, a, b) {
       ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
   return [x1 + ua * x21, y1 + ua * y21];
 }
+
+// If coordinates is not open, removes the closing point.
+function d3_geom_polygonOpen(coordinates) {
+  var a = coordinates[0],
+      b = coordinates[coordinates.length - 1];
+  if (!(a[0] - b[0] || a[1] - b[1])) coordinates.pop();
+}
diff --git a/test/geom/polygon-test.js b/test/geom/polygon-test.js
index 39f70d81..b1d06560 100644
--- a/test/geom/polygon-test.js
+++ b/test/geom/polygon-test.js
@@ -12,70 +12,99 @@ suite.addBatch({
       topic: function(polygon) {
         return polygon([[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]);
       },
+      "is converted to an open polygon": function(p) {
+        assertPolygonInDelta(p, [[0, 0], [0, 1], [1, 1], [1, 0]]);
+      },
       "has area 1": function(p) {
         assert.equal(p.area(), 1);
       },
       "has centroid ⟨.5,.5⟩": function(p) {
-        assert.deepEqual(p.centroid(), [.5, .5]);
+        assertPointInDelta(p.centroid(), [.5, .5]);
+      },
+      "can clip an open counterclockwise triangle": function(p) {
+        assertPolygonInDelta(p.clip([[0.9, 0.5], [2, -1], [0.5, 0.1]]), [[0.9, 0.5], [1, 0.363636], [1, 0], [0.636363, 0], [0.5, 0.1]], 1e-4);
       }
     },
     "closed clockwise unit square": {
       topic: function(polygon) {
         return polygon([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]]);
       },
+      "is converted to an open polygon": function(p) {
+        assertPolygonInDelta(p, [[0, 0], [1, 0], [1, 1], [0, 1]]);
+      },
       "has area 1": function(p) {
         assert.equal(p.area(), -1);
       },
       "has centroid ⟨.5,.5⟩": function(p) {
-        assert.deepEqual(p.centroid(), [.5, .5]);
+        assertPointInDelta(p.centroid(), [.5, .5]);
+      },
+      "is not currently supported for clipping": function(p) {
+        // because clipping requires a counterclockwise source polygon
       }
     },
     "closed clockwise triangle": {
       topic: function(polygon) {
         return polygon([[1, 1], [3, 2], [2, 3], [1, 1]]);
       },
+      "is converted to an open polygon": function(p) {
+        assertPolygonInDelta(p, [[1, 1], [3, 2], [2, 3]]);
+      },
       "has area 1.5": function(p) {
         assert.equal(p.area(), -1.5);
       },
       "has centroid ⟨2,2⟩": function(p) {
-        var centroid = p.centroid();
-        assert.inDelta(centroid[0], 2, 1e-6);
-        assert.inDelta(centroid[1], 2, 1e-6);
+        assertPointInDelta(p.centroid(), [2, 2]);
+      },
+      "is not currently supported for clipping": function(p) {
+        // because clipping requires a counterclockwise source polygon
       }
     },
     "open counterclockwise unit square": {
       topic: function(polygon) {
         return polygon([[0, 0], [0, 1], [1, 1], [1, 0]]);
       },
+      "remains an open polygon": function(p) {
+        assertPolygonInDelta(p, [[0, 0], [0, 1], [1, 1], [1, 0]]);
+      },
       "has area 1": function(p) {
         assert.equal(p.area(), 1);
       },
       "has centroid ⟨.5,.5⟩": function(p) {
-        assert.deepEqual(p.centroid(), [.5, .5]);
+        assertPointInDelta(p.centroid(), [.5, .5]);
+      },
+      "can clip an open counterclockwise triangle": function(p) {
+        assertPolygonInDelta(p.clip([[0.9, 0.5], [2, -1], [0.5, 0.1]]), [[0.9, 0.5], [1, 0.363636], [1, 0], [0.636363, 0], [0.5, 0.1]], 1e-4);
       }
     },
     "open clockwise unit square": {
       topic: function(polygon) {
         return polygon([[0, 0], [1, 0], [1, 1], [0, 1]]);
       },
+      "remains an open polygon": function(p) {
+        assertPolygonInDelta(p, [[0, 0], [1, 0], [1, 1], [0, 1]]);
+      },
       "has area 1": function(p) {
         assert.equal(p.area(), -1);
       },
       "has centroid ⟨.5,.5⟩": function(p) {
-        assert.deepEqual(p.centroid(), [.5, .5]);
+        assertPointInDelta(p.centroid(), [.5, .5]);
+      },
+      "is not currently supported for clipping": function(p) {
+        // because clipping requires a counterclockwise source polygon
       }
     },
     "open clockwise triangle": {
       topic: function(polygon) {
         return polygon([[1, 1], [3, 2], [2, 3]]);
       },
+      "remains an open polygon": function(p) {
+        assertPolygonInDelta(p, [[1, 1], [3, 2], [2, 3]]);
+      },
       "has area 1.5": function(p) {
         assert.equal(p.area(), -1.5);
       },
       "has centroid ⟨2,2⟩": function(p) {
-        var centroid = p.centroid();
-        assert.inDelta(centroid[0], 2, 1e-6);
-        assert.inDelta(centroid[1], 2, 1e-6);
+        assertPointInDelta(p.centroid(), [2, 2]);
       }
     },
     "large square": {
@@ -95,4 +124,22 @@ suite.addBatch({
   }
 });
 
+function assertPointInDelta(expected, actual, δ, message) {
+  if (!δ) δ = 0;
+  if (!pointInDelta(expected, actual, δ)) {
+    assert.fail(JSON.stringify(actual), JSON.stringify(expected), message || "expected {expected}, got {actual}", "===", assertPointInDelta);
+  }
+}
+
+function assertPolygonInDelta(expected, actual, δ, message) {
+  if (!δ) δ = 0;
+  if (expected.length !== actual.length || expected.some(function(e, i) { return !pointInDelta(e, actual[i], δ); })) {
+    assert.fail(JSON.stringify(actual), JSON.stringify(expected), message || "expected {expected}, got {actual}", "===", assertPolygonInDelta);
+  }
+}
+
+function pointInDelta(a, b, δ) {
+  return !(Math.abs(a[0] - b[0]) > δ || Math.abs(a[1] - b[1]) > δ);
+}
+
 suite.export(module);
