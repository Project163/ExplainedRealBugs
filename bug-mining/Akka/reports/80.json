{"url":"https://api.github.com/repos/akka/akka-core/issues/28769","repository_url":"https://api.github.com/repos/akka/akka-core","labels_url":"https://api.github.com/repos/akka/akka-core/issues/28769/labels{/name}","comments_url":"https://api.github.com/repos/akka/akka-core/issues/28769/comments","events_url":"https://api.github.com/repos/akka/akka-core/issues/28769/events","html_url":"https://github.com/akka/akka-core/issues/28769","id":584937651,"node_id":"MDU6SXNzdWU1ODQ5Mzc2NTE=","number":28769,"title":"MergeSequence","user":{"login":"jroper","id":105833,"node_id":"MDQ6VXNlcjEwNTgzMw==","avatar_url":"https://avatars.githubusercontent.com/u/105833?v=4","gravatar_id":"","url":"https://api.github.com/users/jroper","html_url":"https://github.com/jroper","followers_url":"https://api.github.com/users/jroper/followers","following_url":"https://api.github.com/users/jroper/following{/other_user}","gists_url":"https://api.github.com/users/jroper/gists{/gist_id}","starred_url":"https://api.github.com/users/jroper/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jroper/subscriptions","organizations_url":"https://api.github.com/users/jroper/orgs","repos_url":"https://api.github.com/users/jroper/repos","events_url":"https://api.github.com/users/jroper/events{/privacy}","received_events_url":"https://api.github.com/users/jroper/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":93144690,"node_id":"MDU6TGFiZWw5MzE0NDY5MA==","url":"https://api.github.com/repos/akka/akka-core/labels/t:stream","name":"t:stream","color":"cccccc","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":{"url":"https://api.github.com/repos/akka/akka-core/milestones/167","html_url":"https://github.com/akka/akka-core/milestone/167","labels_url":"https://api.github.com/repos/akka/akka-core/milestones/167/labels","id":5519094,"node_id":"MDk6TWlsZXN0b25lNTUxOTA5NA==","number":167,"title":"2.6.7","description":"","creator":{"login":"johanandren","id":666915,"node_id":"MDQ6VXNlcjY2NjkxNQ==","avatar_url":"https://avatars.githubusercontent.com/u/666915?v=4","gravatar_id":"","url":"https://api.github.com/users/johanandren","html_url":"https://github.com/johanandren","followers_url":"https://api.github.com/users/johanandren/followers","following_url":"https://api.github.com/users/johanandren/following{/other_user}","gists_url":"https://api.github.com/users/johanandren/gists{/gist_id}","starred_url":"https://api.github.com/users/johanandren/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/johanandren/subscriptions","organizations_url":"https://api.github.com/users/johanandren/orgs","repos_url":"https://api.github.com/users/johanandren/repos","events_url":"https://api.github.com/users/johanandren/events{/privacy}","received_events_url":"https://api.github.com/users/johanandren/received_events","type":"User","user_view_type":"public","site_admin":false},"open_issues":0,"closed_issues":43,"state":"closed","created_at":"2020-06-08T13:20:20Z","updated_at":"2020-09-14T14:16:47Z","due_on":null,"closed_at":"2020-07-10T07:56:58Z"},"comments":0,"created_at":"2020-03-20T09:20:16Z","updated_at":"2020-07-09T15:54:23Z","closed_at":"2020-07-09T15:52:47Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"Let's say you have a stream that you want two partition into two substreams. You then have some 1:1 processing to do on those substreams, and then you want to merge them back together, in order. A merge sequence stage will let you do that. Here's something I've coded up to do it:\r\n\r\n```scala\r\n  object MergeSequence {\r\n    private case class Pushed[T](in: Int, sequence: Long, elem: T)\r\n    implicit val ordering: Ordering[Pushed[_]] = Ordering.by[Pushed[_], Long](_.sequence).reverse\r\n  }\r\n\r\n  class MergeSequence[T](inputPorts: Int)(extractSequence: T => Long) extends GraphStage[UniformFanInShape[T, T]] {\r\n    private val in: Seq[Inlet[T]] = Vector.tabulate(inputPorts)(i => Inlet[T](\"MergeSequence.in\" + i))\r\n    private val out: Outlet[T] = Outlet(\"MergeSequence.out\")\r\n    override val shape: UniformFanInShape[T, T] = UniformFanInShape(out, in: _*)\r\n\r\n    import MergeSequence._\r\n\r\n    override def createLogic(inheritedAttributes: Attributes): GraphStageLogic = new GraphStageLogic(shape) with OutHandler {\r\n      private var nextSequence = 0L\r\n      private val available = mutable.PriorityQueue.empty[Pushed[T]]\r\n      private var complete = 0\r\n\r\n      setHandler(out, this)\r\n\r\n      in.zipWithIndex.foreach {\r\n        case (inPort, idx) =>\r\n          setHandler(inPort, new InHandler {\r\n            override def onPush(): Unit = {\r\n              val elem = grab(inPort)\r\n              val sequence = extractSequence(elem)\r\n              if (sequence < nextSequence) {\r\n                failStage(new IllegalStateException(s\"Sequence regression from $nextSequence to $sequence on port $idx\"))\r\n              } else if (sequence == nextSequence && isAvailable(out)) {\r\n                push(out, elem)\r\n                tryPull(inPort)\r\n                nextSequence += 1\r\n              } else {\r\n                available.enqueue(Pushed(idx, sequence, elem))\r\n              }\r\n            }\r\n\r\n            override def onUpstreamFinish(): Unit = {\r\n              complete += 1\r\n              if (complete == inputPorts && available.isEmpty) {\r\n                completeStage()\r\n              }\r\n            }\r\n          })\r\n      }\r\n\r\n      def onPull(): Unit = {\r\n        if (available.nonEmpty && available.head.sequence == nextSequence) {\r\n          val pushed = available.dequeue()\r\n          val inPort = in(pushed.in)\r\n          push(out, pushed.elem)\r\n          if (complete == inputPorts && available.isEmpty) {\r\n            completeStage()\r\n          } else {\r\n            if (available.nonEmpty && available.head.sequence == nextSequence) {\r\n              failStage(new IllegalStateException(s\"Duplicate sequence $nextSequence on ports ${pushed.in} and ${available.head.in}\"))\r\n            }\r\n            tryPull(inPort)\r\n            nextSequence += 1\r\n          }\r\n        }\r\n      }\r\n\r\n      override def preStart(): Unit = {\r\n        in.foreach(pull)\r\n      }\r\n    }\r\n\r\n    override def toString: String = s\"MergeSequence($inputPorts)\"\r\n  }\r\n```\r\n\r\nGiven a sequence extractor `T => Long` that will extract a sequence number from each element that starts at zero and strictly increments by 1 for each message that should be output. If a message with a sequence greater than the next expected sequence number is received, it's buffered in a priority queue (ie, minimum heap). Each substream must produce elements in order (substreams themselves are not allowed to let elements overtake each other), since the priority queue will buffer at most once element from each substream. This is designed to be used in combination with `zipWithIndex`, eg:\r\n\r\n```scala\r\n  Flow[String]\r\n    .zipWithIndex\r\n    .via(Flow.fromGraph(GraphDSL.create() { implicit b =>\r\n      import GraphDSL.Implicits._\r\n\r\n      val broadcast = b.add(Partition[(String, Long)](2, elem => if (elem._1.headOption.exists(_.isUpper)) 0 else 1))\r\n      val merge = b.add(new MergeSequence[(String, Long)](2)(_._2))\r\n\r\n      broadcast.out(0).map { case (s, idx) => s.toUpperCase() -> idx } ~> merge.in(0)\r\n      broadcast.out(1).map { case (s, idx) => s.toLowerCase() -> idx } ~> merge.in(1)\r\n\r\n      FlowShape(broadcast.in, merge.out)\r\n    }))\r\n```","closed_by":{"login":"seglo","id":1148412,"node_id":"MDQ6VXNlcjExNDg0MTI=","avatar_url":"https://avatars.githubusercontent.com/u/1148412?v=4","gravatar_id":"","url":"https://api.github.com/users/seglo","html_url":"https://github.com/seglo","followers_url":"https://api.github.com/users/seglo/followers","following_url":"https://api.github.com/users/seglo/following{/other_user}","gists_url":"https://api.github.com/users/seglo/gists{/gist_id}","starred_url":"https://api.github.com/users/seglo/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/seglo/subscriptions","organizations_url":"https://api.github.com/users/seglo/orgs","repos_url":"https://api.github.com/users/seglo/repos","events_url":"https://api.github.com/users/seglo/events{/privacy}","received_events_url":"https://api.github.com/users/seglo/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/akka/akka-core/issues/28769/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/akka/akka-core/issues/28769/timeline","performed_via_github_app":null,"state_reason":"completed"}