diff --git a/akka-stream-tests/src/test/scala/akka/stream/io/TlsSpec.scala b/akka-stream-tests/src/test/scala/akka/stream/io/TlsSpec.scala
index 7870c24b90..5ffc7e170c 100644
--- a/akka-stream-tests/src/test/scala/akka/stream/io/TlsSpec.scala
+++ b/akka-stream-tests/src/test/scala/akka/stream/io/TlsSpec.scala
@@ -247,6 +247,14 @@ class TlsSpec extends StreamSpec(TlsSpec.configOverrides) with WithLogCapturing
       def output = ByteString("hello")
     }
 
+    object CompletedImmediately extends PayloadScenario {
+      override def inputs: immutable.Seq[SslTlsOutbound] = Nil
+      override def output = ByteString.empty
+
+      override def leftClosing: TLSClosing = EagerClose
+      override def rightClosing: TLSClosing = EagerClose
+    }
+
     // this demonstrates that cancellation is ignored so that the five results make it back
     object CancellingRHS extends PayloadScenario {
       override def flow =
@@ -345,6 +353,7 @@ class TlsSpec extends StreamSpec(TlsSpec.configOverrides) with WithLogCapturing
         EmptyBytesFirst,
         EmptyBytesInTheMiddle,
         EmptyBytesLast,
+        CompletedImmediately,
         CancellingRHS,
         SessionRenegotiationBySender,
         SessionRenegotiationByReceiver,
@@ -357,7 +366,7 @@ class TlsSpec extends StreamSpec(TlsSpec.configOverrides) with WithLogCapturing
     } {
       s"work in mode ${commPattern.name} while sending ${scenario.name}" in assertAllStagesStopped {
         val onRHS = debug.via(scenario.flow)
-        val f =
+        val output =
           Source(scenario.inputs)
             .via(commPattern.decorateFlow(scenario.leftClosing, scenario.rightClosing, onRHS))
             .via(new SimpleLinearGraphStage[SslTlsInbound] {
@@ -377,11 +386,12 @@ class TlsSpec extends StreamSpec(TlsSpec.configOverrides) with WithLogCapturing
             .via(debug)
             .collect { case SessionBytes(_, b) => b }
             .scan(ByteString.empty)(_ ++ _)
+            .filter(_.nonEmpty)
             .via(new Timeout(6.seconds))
             .dropWhile(_.size < scenario.output.size)
-            .runWith(Sink.head)
+            .runWith(Sink.headOption)
 
-        Await.result(f, 8.seconds).utf8String should be(scenario.output.utf8String)
+        Await.result(output, 8.seconds).getOrElse(ByteString.empty).utf8String should be(scenario.output.utf8String)
 
         commPattern.cleanup()
       }
diff --git a/akka-stream/src/main/scala/akka/stream/impl/io/TLSActor.scala b/akka-stream/src/main/scala/akka/stream/impl/io/TLSActor.scala
index 18042dfd03..b2f926018f 100644
--- a/akka-stream/src/main/scala/akka/stream/impl/io/TLSActor.scala
+++ b/akka-stream/src/main/scala/akka/stream/impl/io/TLSActor.scala
@@ -305,7 +305,7 @@ import scala.util.{ Failure, Success, Try }
     } else true
 
   private def doOutbound(isInboundClosed: Boolean): Unit =
-    if (inputBunch.isDepleted(UserIn) && userInChoppingBlock.isEmpty) {
+    if (inputBunch.isDepleted(UserIn) && userInChoppingBlock.isEmpty && mayCloseOutbound) {
       if (!isInboundClosed && closing.ignoreComplete) {
         if (tracing) log.debug("ignoring closeOutbound")
       } else {
@@ -328,6 +328,16 @@ import scala.util.{ Failure, Success, Try }
       }
     }
 
+  /**
+   * In JDK 8 it is not allowed to call `closeOutbound` before the handshake is done or otherwise
+   * an IllegalStateException might be thrown when the next handshake packet arrives.
+   */
+  private def mayCloseOutbound: Boolean =
+    lastHandshakeStatus match {
+      case HandshakeStatus.NOT_HANDSHAKING | HandshakeStatus.FINISHED ⇒ true
+      case _ ⇒ false
+    }
+
   def flushToTransport(): Unit = {
     if (tracing) log.debug("flushToTransport")
     transportOutBuffer.flip()
