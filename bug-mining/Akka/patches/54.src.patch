diff --git a/akka-cluster-sharding-typed/src/main/scala/akka/cluster/sharding/typed/javadsl/ClusterSharding.scala b/akka-cluster-sharding-typed/src/main/scala/akka/cluster/sharding/typed/javadsl/ClusterSharding.scala
index 69591d9972..ef0d15f17c 100644
--- a/akka-cluster-sharding-typed/src/main/scala/akka/cluster/sharding/typed/javadsl/ClusterSharding.scala
+++ b/akka-cluster-sharding-typed/src/main/scala/akka/cluster/sharding/typed/javadsl/ClusterSharding.scala
@@ -211,7 +211,6 @@ object Entity {
    *
    * @param typeKey A key that uniquely identifies the type of entity in this cluster
    * @param createBehavior Create the behavior for an entity given a [[EntityContext]] (includes entityId)
-   * @param stopMessage Message sent to an entity to tell it to stop, e.g. when rebalanced or passivated.
    * @tparam M The type of message the entity accepts
    */
   def of[M](
@@ -229,7 +228,6 @@ object Entity {
    *
    * @param typeKey A key that uniquely identifies the type of entity in this cluster
    * @param createPersistentEntity Create the `PersistentEntity` for an entity given a [[EntityContext]] (includes entityId)
-   * @param stopMessage Message sent to an entity to tell it to stop, e.g. when rebalanced or passivated.
    * @tparam Command The type of message the entity accepts
    */
   def ofPersistentEntity[Command, Event, State >: Null](
@@ -252,7 +250,7 @@ object Entity {
 /**
  * Defines how the entity should be created. Used in [[ClusterSharding#init]].
  */
-final class Entity[M, E] private[akka] (
+final class Entity[M, E] private (
   val createBehavior:     JFunction[EntityContext[M], Behavior[M]],
   val typeKey:            EntityTypeKey[M],
   val stopMessage:        Optional[M],
diff --git a/akka-cluster-typed/src/main/scala/akka/cluster/typed/ClusterSingleton.scala b/akka-cluster-typed/src/main/scala/akka/cluster/typed/ClusterSingleton.scala
index 5e6dce3c64..219832238c 100644
--- a/akka-cluster-typed/src/main/scala/akka/cluster/typed/ClusterSingleton.scala
+++ b/akka-cluster-typed/src/main/scala/akka/cluster/typed/ClusterSingleton.scala
@@ -124,6 +124,56 @@ private[akka] object ClusterSingletonImpl {
   def managerNameFor(singletonName: String) = s"singletonManager$singletonName"
 }
 
+object SingletonActor {
+  /**
+   * @param name Unique name for the singleton
+   * @param behavior Behavior for the singleton
+   */
+  def apply[M](behavior: Behavior[M], name: String): SingletonActor[M] = new SingletonActor[M](behavior, name, Props.empty, None, None)
+
+  /**
+   * Java API
+   *
+   * @param name Unique name for the singleton
+   * @param behavior Behavior for the singleton
+   */
+  def of[M](behavior: Behavior[M], name: String): SingletonActor[M] = apply(behavior, name)
+}
+
+final class SingletonActor[M] private (
+  val behavior:    Behavior[M],
+  val name:        String,
+  val props:       Props,
+  val stopMessage: Option[M],
+  val settings:    Option[ClusterSingletonSettings]
+) {
+
+  /**
+   * [[akka.actor.typed.Props]] of the singleton actor, such as dispatcher settings.
+   */
+  def withProps(props: Props): SingletonActor[M] = copy(props = props)
+
+  /**
+   * Message sent to the singleton to tell it to stop, e.g. when being migrated.
+   * If this is not defined it will be stopped automatically.
+   * It can be useful to define a custom stop message if the singleton needs to perform
+   * some asynchronous cleanup or interactions before stopping.
+   */
+  def withStopMessage(msg: M): SingletonActor[M] = copy(stopMessage = Option(msg))
+
+  /**
+   * Additional settings, typically loaded from configuration.
+   */
+  def withSettings(settings: ClusterSingletonSettings): SingletonActor[M] = copy(settings = Option(settings))
+
+  private def copy(
+    behavior:    Behavior[M]                      = behavior,
+    props:       Props                            = props,
+    stopMessage: Option[M]                        = stopMessage,
+    settings:    Option[ClusterSingletonSettings] = settings
+  ): SingletonActor[M] = new SingletonActor[M](behavior, name, props, stopMessage, settings)
+}
+
 /**
  * This class is not intended for user extension other than for test purposes (e.g.
  * stub implementation). More methods may be added in the future and that may break
@@ -132,24 +182,15 @@ private[akka] object ClusterSingletonImpl {
 @DoNotInherit
 abstract class ClusterSingleton extends Extension {
 
-  // FIXME align with ClusterSharding API, issue #25480
-
   /**
    * Start if needed and provide a proxy to a named singleton
    *
    * If there already is a manager running for the given `singletonName` on this node, no additional manager is started.
    * If there already is a proxy running for the given `singletonName` on this node, an [[ActorRef]] to that is returned.
    *
-   * @param singletonName A cluster global unique name for this singleton
    * @return A proxy actor that can be used to communicate with the singleton in the cluster
    */
-  def spawn[A](
-    behavior:           Behavior[A],
-    singletonName:      String,
-    props:              Props,
-    settings:           ClusterSingletonSettings,
-    terminationMessage: A
-  ): ActorRef[A]
+  def init[M](singleton: SingletonActor[M]): ActorRef[M]
 }
 
 object ClusterSingletonManagerSettings {
diff --git a/akka-cluster-typed/src/main/scala/akka/cluster/typed/internal/AdaptedClusterSingletonImpl.scala b/akka-cluster-typed/src/main/scala/akka/cluster/typed/internal/AdaptedClusterSingletonImpl.scala
index e358e3d7ac..41f2531e28 100644
--- a/akka-cluster-typed/src/main/scala/akka/cluster/typed/internal/AdaptedClusterSingletonImpl.scala
+++ b/akka-cluster-typed/src/main/scala/akka/cluster/typed/internal/AdaptedClusterSingletonImpl.scala
@@ -7,13 +7,16 @@ package akka.cluster.typed.internal
 import java.util.concurrent.ConcurrentHashMap
 import java.util.function.{ Function ⇒ JFunction }
 
+import akka.actor.typed.internal.{ PoisonPill, PoisonPillInterceptor }
 import akka.actor.{ ExtendedActorSystem, InvalidActorNameException }
 import akka.annotation.InternalApi
 import akka.cluster.singleton.{ ClusterSingletonProxy, ClusterSingletonManager ⇒ OldSingletonManager }
 import akka.cluster.typed.{ Cluster, ClusterSingleton, ClusterSingletonImpl, ClusterSingletonSettings }
 import akka.actor.typed.internal.adapter.ActorSystemAdapter
-import akka.actor.typed.{ ActorRef, ActorSystem, Behavior, Props }
+import akka.actor.typed.scaladsl.Behaviors
+import akka.actor.typed.{ ActorRef, ActorSystem, Behavior }
 import akka.cluster.ClusterSettings.DataCenter
+import akka.cluster.typed
 
 /**
  * INTERNAL API:
@@ -30,20 +33,25 @@ private[akka] final class AdaptedClusterSingletonImpl(system: ActorSystem[_]) ex
 
   private val proxies = new ConcurrentHashMap[(String, Option[DataCenter]), ActorRef[_]]()
 
-  override def spawn[A](
-    behavior:           Behavior[A],
-    singletonName:      String,
-    props:              Props,
-    settings:           ClusterSingletonSettings,
-    terminationMessage: A): ActorRef[A] = {
+  override def init[M](singleton: typed.SingletonActor[M]): ActorRef[M] = {
+    val settings = singleton.settings match {
+      case None    ⇒ ClusterSingletonSettings(system)
+      case Some(s) ⇒ s
+    }
+    def poisonPillInterceptor(behv: Behavior[M]): Behavior[M] = {
+      singleton.stopMessage match {
+        case Some(_) ⇒ behv
+        case None    ⇒ Behaviors.intercept(new PoisonPillInterceptor[M])(behv)
+      }
+    }
 
     if (settings.shouldRunManager(cluster)) {
-      val managerName = managerNameFor(singletonName)
+      val managerName = managerNameFor(singleton.name)
       // start singleton on this node
-      val untypedProps = PropsAdapter(behavior, props)
+      val untypedProps = PropsAdapter(poisonPillInterceptor(singleton.behavior), singleton.props)
       try {
         untypedSystem.systemActorOf(
-          OldSingletonManager.props(untypedProps, terminationMessage, settings.toManagerSettings(singletonName)),
+          OldSingletonManager.props(untypedProps, singleton.stopMessage.getOrElse(PoisonPill), settings.toManagerSettings(singleton.name)),
           managerName)
       } catch {
         case ex: InvalidActorNameException if ex.getMessage.endsWith("is not unique!") ⇒
@@ -51,12 +59,13 @@ private[akka] final class AdaptedClusterSingletonImpl(system: ActorSystem[_]) ex
       }
     }
 
-    getProxy(singletonName, settings)
+    getProxy(singleton.name, settings)
   }
 
   private def getProxy[T](name: String, settings: ClusterSingletonSettings): ActorRef[T] = {
     val proxyCreator = new JFunction[(String, Option[DataCenter]), ActorRef[_]] {
       def apply(singletonNameAndDc: (String, Option[DataCenter])): ActorRef[_] = {
+        println("Creating for " + singletonNameAndDc)
         val (singletonName, _) = singletonNameAndDc
         val proxyName = s"singletonProxy$singletonName-${settings.dataCenter.getOrElse("no-dc")}"
         untypedSystem.systemActorOf(
diff --git a/akka-cluster-typed/src/multi-jvm/scala/akka/cluster/typed/MultiDcClusterSingletonSpec.scala b/akka-cluster-typed/src/multi-jvm/scala/akka/cluster/typed/MultiDcClusterSingletonSpec.scala
index e80727f7ef..67a8c7864c 100644
--- a/akka-cluster-typed/src/multi-jvm/scala/akka/cluster/typed/MultiDcClusterSingletonSpec.scala
+++ b/akka-cluster-typed/src/multi-jvm/scala/akka/cluster/typed/MultiDcClusterSingletonSpec.scala
@@ -69,12 +69,8 @@ abstract class MultiDcClusterSingletonSpec extends MultiNodeSpec(MultiDcClusterS
     "be able to create and ping singleton in same DC" in {
       runOn(first) {
         val singleton = ClusterSingleton(typedSystem)
-        val pinger = singleton.spawn(
-          multiDcPinger,
-          "ping",
-          Props.empty,
-          ClusterSingletonSettings(typedSystem),
-          NoMore
+        val pinger = singleton.init(
+          SingletonActor(multiDcPinger, "ping").withStopMessage(NoMore)
         )
         val probe = TestProbe[Pong]
         pinger ! Ping(probe.ref)
@@ -89,12 +85,10 @@ abstract class MultiDcClusterSingletonSpec extends MultiNodeSpec(MultiDcClusterS
     "be able to ping singleton via proxy in another dc" in {
       runOn(second) {
         val singleton = ClusterSingleton(system.toTyped)
-        val pinger = singleton.spawn(
-          multiDcPinger,
-          "ping",
-          Props.empty,
-          ClusterSingletonSettings(typedSystem).withDataCenter("dc1"),
-          NoMore
+        val pinger = singleton.init(
+          SingletonActor(multiDcPinger, "ping").withStopMessage(NoMore).withSettings(
+            ClusterSingletonSettings(typedSystem).withDataCenter("dc1")
+          )
         )
         val probe = TestProbe[Pong]
         pinger ! Ping(probe.ref)
@@ -107,12 +101,8 @@ abstract class MultiDcClusterSingletonSpec extends MultiNodeSpec(MultiDcClusterS
     "be able to target singleton with the same name in own dc " in {
       runOn(second, third) {
         val singleton = ClusterSingleton(typedSystem)
-        val pinger = singleton.spawn(
-          multiDcPinger,
-          "ping",
-          Props.empty,
-          ClusterSingletonSettings(typedSystem),
-          NoMore
+        val pinger = singleton.init(
+          SingletonActor(multiDcPinger, "ping").withStopMessage(NoMore)
         )
         val probe = TestProbe[Pong]
         pinger ! Ping(probe.ref)
diff --git a/akka-cluster-typed/src/test/java/jdocs/akka/cluster/typed/SingletonCompileOnlyTest.java b/akka-cluster-typed/src/test/java/jdocs/akka/cluster/typed/SingletonCompileOnlyTest.java
index 109fe59b4b..1b96dc08ca 100644
--- a/akka-cluster-typed/src/test/java/jdocs/akka/cluster/typed/SingletonCompileOnlyTest.java
+++ b/akka-cluster-typed/src/test/java/jdocs/akka/cluster/typed/SingletonCompileOnlyTest.java
@@ -14,72 +14,76 @@ import java.time.Duration;
 
 public class SingletonCompileOnlyTest {
 
-  //#counter
-  interface CounterCommand {}
-  public static class Increment implements CounterCommand { }
-  public static class GoodByeCounter implements CounterCommand { }
-
-  public static class GetValue implements CounterCommand {
-    private final ActorRef<Integer> replyTo;
-    public GetValue(ActorRef<Integer> replyTo) {
-      this.replyTo = replyTo;
+    //#counter
+    interface CounterCommand {
     }
-  }
-
-  public static Behavior<CounterCommand> counter(String entityId, Integer value) {
-    return Behaviors.receive(CounterCommand.class)
-      .onMessage(Increment.class, (ctx, msg) -> {
-        return counter(entityId,value + 1);
-      })
-      .onMessage(GetValue.class, (ctx, msg) -> {
-        msg.replyTo.tell(value);
-        return Behaviors.same();
-      })
-      .onMessage(GoodByeCounter.class, (ctx, msg) -> {
-        return Behaviors.stopped();
-      })
-      .build();
-  }
-  //#counter
-
-  public static void example() {
+
+    public static class Increment implements CounterCommand {
+    }
+
+    public static class GoodByeCounter implements CounterCommand {
+    }
+
+    public static class GetValue implements CounterCommand {
+        private final ActorRef<Integer> replyTo;
+
+        public GetValue(ActorRef<Integer> replyTo) {
+            this.replyTo = replyTo;
+        }
+    }
+
+    public static Behavior<CounterCommand> counter(String entityId, Integer value) {
+        return Behaviors.receive(CounterCommand.class)
+                .onMessage(Increment.class, (ctx, msg) -> counter(entityId, value + 1))
+                .onMessage(GetValue.class, (ctx, msg) -> {
+                    msg.replyTo.tell(value);
+                    return Behaviors.same();
+                })
+                .onMessage(GoodByeCounter.class, (ctx, msg) -> Behaviors.stopped())
+                .build();
+    }
+    //#counter
 
     ActorSystem system = ActorSystem.create(
             Behaviors.empty(), "SingletonExample"
     );
 
-    //#singleton
-    ClusterSingleton singleton = ClusterSingleton.get(system);
-    // Start if needed and provide a proxy to a named singleton
-    ActorRef<CounterCommand> proxy = singleton.spawn(
-            counter("TheCounter", 0),
-            "GlobalCounter",
-            Props.empty(),
-            ClusterSingletonSettings.create(system),
-            new GoodByeCounter()
-    );
+    public void example() {
 
-    proxy.tell(new Increment());
-    //#singleton
 
-  }
+        //#singleton
+        ClusterSingleton singleton = ClusterSingleton.get(system);
+        // Start if needed and provide a proxy to a named singleton
+        ActorRef<CounterCommand> proxy = singleton.init(
+                SingletonActor.of(counter("TheCounter", 0), "GlobalCounter")
+        );
 
-  public static void backoff() {
+        proxy.tell(new Increment());
+        //#singleton
 
-    ActorSystem system = ActorSystem.create(
-      Behaviors.empty(), "SingletonExample"
-    );
+    }
 
-    //#backoff
-    ClusterSingleton singleton = ClusterSingleton.get(system);
-    ActorRef<CounterCommand> proxy = singleton.spawn(
-      Behaviors.supervise(counter("TheCounter", 0))
-              .onFailure(SupervisorStrategy.restartWithBackoff(Duration.ofSeconds(1), Duration.ofSeconds(10), 0.2)),
-      "GlobalCounter",
-      Props.empty(),
-      ClusterSingletonSettings.create(system),
-      new GoodByeCounter()
-    );
-    //#backoff
-  }
+    public void customStopMessage() {
+        ClusterSingleton singleton = ClusterSingleton.get(system);
+        //#stop-message
+        SingletonActor<CounterCommand> counterSingleton = SingletonActor.of(counter("TheCounter", 0), "GlobalCounter")
+            .withStopMessage(new GoodByeCounter());
+        ActorRef<CounterCommand> proxy = singleton.init(
+                counterSingleton
+        );
+        //#stop-message
+        proxy.tell(new Increment()); // avoid unused warning
+    }
+
+    public void backoff() {
+        //#backoff
+        ClusterSingleton singleton = ClusterSingleton.get(system);
+        ActorRef<CounterCommand> proxy = singleton.init(
+                SingletonActor.of(Behaviors.supervise(counter("TheCounter", 0))
+                        .onFailure(SupervisorStrategy.restartWithBackoff(Duration.ofSeconds(1), Duration.ofSeconds(10), 0.2)), "GlobalCounter"
+                )
+        );
+        //#backoff
+        proxy.tell(new Increment()); // avoid unused warning
+    }
 }
diff --git a/akka-cluster-typed/src/test/scala/akka/cluster/typed/ClusterSingletonApiSpec.scala b/akka-cluster-typed/src/test/scala/akka/cluster/typed/ClusterSingletonApiSpec.scala
index 74509956da..c01c43efc8 100644
--- a/akka-cluster-typed/src/test/scala/akka/cluster/typed/ClusterSingletonApiSpec.scala
+++ b/akka-cluster-typed/src/test/scala/akka/cluster/typed/ClusterSingletonApiSpec.scala
@@ -11,7 +11,7 @@ import akka.actor.typed.scaladsl.Behaviors
 import akka.actor.typed.scaladsl.adapter._
 import akka.actor.testkit.typed.TestKitSettings
 import akka.actor.testkit.typed.scaladsl.TestProbe
-import akka.actor.typed.{ ActorRef, ActorRefResolver, Props }
+import akka.actor.typed.{ ActorRef, ActorRefResolver }
 import akka.serialization.SerializerWithStringManifest
 import com.typesafe.config.ConfigFactory
 
@@ -123,12 +123,12 @@ class ClusterSingletonApiSpec extends ScalaTestWithActorTestKit(ClusterSingleton
       val cs2 = ClusterSingleton(adaptedSystem2)
 
       val settings = ClusterSingletonSettings(system).withRole("singleton")
-      val node1ref = cs1.spawn(pingPong, "ping-pong", Props.empty, settings, Perish)
-      val node2ref = cs2.spawn(pingPong, "ping-pong", Props.empty, settings, Perish)
+      val node1ref = cs1.init(SingletonActor(pingPong, "ping-pong").withStopMessage(Perish).withSettings(settings))
+      val node2ref = cs2.init(SingletonActor(pingPong, "ping-pong").withStopMessage(Perish).withSettings(settings))
 
       // subsequent spawning returns the same refs
-      cs1.spawn(pingPong, "ping-pong", Props.empty, settings, Perish) should ===(node1ref)
-      cs2.spawn(pingPong, "ping-pong", Props.empty, settings, Perish) should ===(node2ref)
+      cs1.init(SingletonActor(pingPong, "ping-pong").withStopMessage(Perish).withSettings(settings)) should ===(node1ref)
+      cs2.init(SingletonActor(pingPong, "ping-pong").withStopMessage(Perish).withSettings(settings)) should ===(node2ref)
 
       val node1PongProbe = TestProbe[Pong.type]()(system)
       val node2PongProbe = TestProbe[Pong.type]()(adaptedSystem2)
diff --git a/akka-cluster-typed/src/test/scala/akka/cluster/typed/ClusterSingletonPersistenceSpec.scala b/akka-cluster-typed/src/test/scala/akka/cluster/typed/ClusterSingletonPersistenceSpec.scala
index 31b9f6d5cf..f5496d10f5 100644
--- a/akka-cluster-typed/src/test/scala/akka/cluster/typed/ClusterSingletonPersistenceSpec.scala
+++ b/akka-cluster-typed/src/test/scala/akka/cluster/typed/ClusterSingletonPersistenceSpec.scala
@@ -64,12 +64,7 @@ class ClusterSingletonPersistenceSpec extends ScalaTestWithActorTestKit(ClusterS
     untypedCluster.join(untypedCluster.selfAddress)
 
     "start persistent actor" in {
-      val ref = ClusterSingleton(system).spawn(
-        behavior = persistentActor,
-        singletonName = "singleton",
-        props = Props.empty,
-        settings = ClusterSingletonSettings(system),
-        terminationMessage = StopPlz)
+      val ref = ClusterSingleton(system).init(SingletonActor(persistentActor, "singleton").withStopMessage(StopPlz))
 
       val p = TestProbe[String]()
 
diff --git a/akka-cluster-typed/src/test/scala/akka/cluster/typed/ClusterSingletonPoisonPillSpec.scala b/akka-cluster-typed/src/test/scala/akka/cluster/typed/ClusterSingletonPoisonPillSpec.scala
new file mode 100644
index 0000000000..9be3be7294
--- /dev/null
+++ b/akka-cluster-typed/src/test/scala/akka/cluster/typed/ClusterSingletonPoisonPillSpec.scala
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2009-2018 Lightbend Inc. <https://www.lightbend.com>
+ */
+
+package akka.cluster.typed
+
+import akka.actor.testkit.typed.TestKitSettings
+import akka.actor.testkit.typed.scaladsl.{ ScalaTestWithActorTestKit, TestProbe }
+import akka.actor.typed.internal.PoisonPill
+import akka.actor.typed.{ ActorRef, Behavior }
+import akka.actor.typed.scaladsl.Behaviors
+import akka.actor.typed.scaladsl.adapter._
+import akka.cluster.typed.ClusterSingletonPoisonPillSpec.GetSelf
+import org.scalatest.WordSpecLike
+
+import scala.concurrent.duration._
+
+object ClusterSingletonPoisonPillSpec {
+
+  final case class GetSelf(replyTo: ActorRef[ActorRef[Any]])
+  val sneakyBehavior: Behavior[GetSelf] = Behaviors.receive {
+    case (ctx, GetSelf(replyTo)) ⇒
+      replyTo ! ctx.self.unsafeUpcast[Any]
+      Behaviors.same
+  }
+}
+
+class ClusterSingletonPoisonPillSpec extends ScalaTestWithActorTestKit(ClusterSingletonApiSpec.config) with WordSpecLike {
+
+  implicit val testSettings = TestKitSettings(system)
+  val clusterNode1 = Cluster(system)
+  clusterNode1.manager ! Join(clusterNode1.selfMember.address)
+  val untypedSystem1 = system.toUntyped
+  "A typed cluster singleton" must {
+
+    "support using PoisonPill to stop" in {
+      val probe = TestProbe[ActorRef[Any]]
+      val singleton = ClusterSingleton(system).init(SingletonActor(ClusterSingletonPoisonPillSpec.sneakyBehavior, "sneaky"))
+      singleton ! GetSelf(probe.ref)
+      val singletonRef = probe.expectMessageType[ActorRef[Any]]
+      singletonRef ! PoisonPill
+      probe.expectTerminated(singletonRef, 1.second)
+    }
+
+  }
+
+}
diff --git a/akka-cluster-typed/src/test/scala/docs/akka/cluster/typed/SingletonCompileOnlySpec.scala b/akka-cluster-typed/src/test/scala/docs/akka/cluster/typed/SingletonCompileOnlySpec.scala
index 6a3b2b2628..579bae732a 100644
--- a/akka-cluster-typed/src/test/scala/docs/akka/cluster/typed/SingletonCompileOnlySpec.scala
+++ b/akka-cluster-typed/src/test/scala/docs/akka/cluster/typed/SingletonCompileOnlySpec.scala
@@ -6,6 +6,8 @@ package docs.akka.cluster.typed
 
 import akka.actor.typed.{ ActorRef, ActorSystem, Behavior, Props, SupervisorStrategy }
 import akka.actor.typed.scaladsl.Behaviors
+import akka.cluster.typed.SingletonActor
+
 import scala.concurrent.duration._
 
 object SingletonCompileOnlySpec {
@@ -18,44 +20,41 @@ object SingletonCompileOnlySpec {
   final case class GetValue(replyTo: ActorRef[Int]) extends CounterCommand
   case object GoodByeCounter extends CounterCommand
 
-  def counter(entityId: String, value: Int): Behavior[CounterCommand] =
+  def counter(value: Int): Behavior[CounterCommand] =
     Behaviors.receiveMessage[CounterCommand] {
       case Increment ⇒
-        counter(entityId, value + 1)
+        counter(value + 1)
       case GetValue(replyTo) ⇒
         replyTo ! value
         Behaviors.same
       case GoodByeCounter ⇒
+        // Do async action then stop
         Behaviors.stopped
     }
   //#counter
 
   //#singleton
   import akka.cluster.typed.ClusterSingleton
-  import akka.cluster.typed.ClusterSingletonSettings
 
   val singletonManager = ClusterSingleton(system)
   // Start if needed and provide a proxy to a named singleton
-  val proxy: ActorRef[CounterCommand] = singletonManager.spawn(
-    behavior = Behaviors.supervise(counter("TheCounter", 0))
-      .onFailure[Exception](SupervisorStrategy.restart),
-    "GlobalCounter",
-    Props.empty,
-    ClusterSingletonSettings(system),
-    terminationMessage = GoodByeCounter
+  val proxy: ActorRef[CounterCommand] = singletonManager.init(
+    SingletonActor(Behaviors.supervise(counter(0))
+      .onFailure[Exception](SupervisorStrategy.restart), "GlobalCounter")
   )
 
   proxy ! Increment
   //#singleton
 
+  //#stop-message
+  val singletonActor = SingletonActor(counter(0), "GlobalCounter").withStopMessage(GoodByeCounter)
+  singletonManager.init(singletonActor)
+  //#stop-message
+
   //#backoff
-  val proxyBackOff: ActorRef[CounterCommand] = singletonManager.spawn(
-    behavior = Behaviors.supervise(counter("TheCounter", 0))
-      .onFailure[Exception](SupervisorStrategy.restartWithBackoff(1.second, 10.seconds, 0.2)),
-    "GlobalCounter",
-    Props.empty,
-    ClusterSingletonSettings(system),
-    terminationMessage = GoodByeCounter
+  val proxyBackOff: ActorRef[CounterCommand] = singletonManager.init(
+    SingletonActor(Behaviors.supervise(counter(0))
+      .onFailure[Exception](SupervisorStrategy.restartWithBackoff(1.second, 10.seconds, 0.2)), "GlobalCounter")
   )
   //#backoff
 }
diff --git a/akka-docs/src/main/paradox/typed/cluster-singleton.md b/akka-docs/src/main/paradox/typed/cluster-singleton.md
index 568114ec07..8984f96bf2 100644
--- a/akka-docs/src/main/paradox/typed/cluster-singleton.md
+++ b/akka-docs/src/main/paradox/typed/cluster-singleton.md
@@ -74,6 +74,20 @@ Be aware that this means there will be times when the singleton won't be running
 See @ref[Fault Tolerance](./fault-tolerance.md) for a full list of supervision options.
 
 
+## Application specific stop message
+
+An application specific `stopMessage` can be used to close the resources before actually stopping the singleton actor. 
+This `stopMessage` is sent to the singleton actor to tell it to finish its work, close resources, and stop. The hand-over to the new oldest node is completed when the
+singleton actor is terminated.
+If the shutdown logic does not include any asynchronous actions it can be executed in the `PostStop` signal handler.
+
+Scala
+:  @@snip [SingletonCompileOnlySpec.scala](/akka-cluster-typed/src/test/scala/docs/akka/cluster/typed/SingletonCompileOnlySpec.scala) { #stop-message }
+
+Java
+:  @@snip [SingletonCompileOnlyTest.java](/akka-cluster-typed/src/test/java/jdocs/akka/cluster/typed/SingletonCompileOnlyTest.java) { #stop-message }
+
+
 ## Accessing singleton of another data centre
 
 TODO
