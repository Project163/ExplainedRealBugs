diff --git a/akka-typed-tests/src/test/scala/akka/typed/scaladsl/OnSignalSpec.scala b/akka-typed-tests/src/test/scala/akka/typed/scaladsl/OnSignalSpec.scala
new file mode 100644
index 0000000000..58f8347e05
--- /dev/null
+++ b/akka-typed-tests/src/test/scala/akka/typed/scaladsl/OnSignalSpec.scala
@@ -0,0 +1,42 @@
+/**
+ * Copyright (C) 2017 Lightbend Inc. <http://www.lightbend.com>
+ */
+package akka.typed
+package scaladsl
+
+import akka.Done
+import akka.typed.testkit.TestKitSettings
+import akka.typed.testkit.scaladsl.TestProbe
+import org.junit.runner.RunWith
+import org.scalatest.junit.JUnitRunner
+
+@RunWith(classOf[JUnitRunner])
+final class OnSignalSpec extends TypedSpec {
+
+  final object `An Actor.onSignal behavior (native)` extends Tests with NativeSystem
+
+  final object `An Actor.onSignal behavior (adapted)` extends Tests with AdaptedSystem
+
+  trait Tests extends StartSupport {
+
+    private implicit val testSettings = TestKitSettings(system)
+
+    override implicit def system: ActorSystem[TypedSpec.Command]
+
+    def `must correctly install the signal handler`(): Unit = {
+      val probe = TestProbe[Done]("probe")
+      val behavior =
+        Actor.deferred[Nothing] { context ⇒
+          val stoppedChild = context.spawn(Actor.stopped, "stopped-child")
+          context.watch(stoppedChild)
+          Actor.onSignal[Nothing] {
+            case (_, Terminated(`stoppedChild`)) ⇒
+              probe.ref ! Done
+              Actor.stopped
+          }
+        }
+      start[Nothing](behavior)
+      probe.expectMsg(Done)
+    }
+  }
+}
diff --git a/akka-typed/src/main/scala/akka/typed/javadsl/Actor.scala b/akka-typed/src/main/scala/akka/typed/javadsl/Actor.scala
index 99a5a52705..5f181ad891 100644
--- a/akka-typed/src/main/scala/akka/typed/javadsl/Actor.scala
+++ b/akka-typed/src/main/scala/akka/typed/javadsl/Actor.scala
@@ -9,7 +9,7 @@ import scala.reflect.ClassTag
 
 import akka.util.OptionVal
 import akka.japi.function.{ Function2 ⇒ JapiFunction2 }
-import akka.japi.function.Procedure2
+import akka.japi.function.{ Procedure, Procedure2 }
 import akka.japi.pf.PFBuilder
 
 import akka.typed.Behavior
@@ -191,6 +191,16 @@ object Actor {
    */
   def immutable[T](`type`: Class[T]): BehaviorBuilder[T] = BehaviorBuilder.create[T]
 
+  /**
+   * Construct an actor behavior that can react to lifecycle signals only.
+   */
+  def onSignal[T](handler: JapiFunction2[ActorContext[T], Signal, Behavior[T]]): Behavior[T] = {
+    val jSame = new JapiFunction2[ActorContext[T], T, Behavior[T]] {
+      override def apply(ctx: ActorContext[T], msg: T) = same
+    }
+    immutable(jSame, handler)
+  }
+
   /**
    * This type of Behavior wraps another Behavior while allowing you to perform
    * some action upon each received message or signal. It is most commonly used
diff --git a/akka-typed/src/main/scala/akka/typed/scaladsl/Actor.scala b/akka-typed/src/main/scala/akka/typed/scaladsl/Actor.scala
index 4e4426c12f..c29c84d2d4 100644
--- a/akka-typed/src/main/scala/akka/typed/scaladsl/Actor.scala
+++ b/akka-typed/src/main/scala/akka/typed/scaladsl/Actor.scala
@@ -187,6 +187,12 @@ object Actor {
       new BehaviorImpl.ImmutableBehavior(onMessage, onSignal)
   }
 
+  /**
+   * Construct an actor behavior that can react to lifecycle signals only.
+   */
+  def onSignal[T](handler: PartialFunction[(ActorContext[T], Signal), Behavior[T]]): Behavior[T] =
+    immutable[T]((_, _) ⇒ same).onSignal(handler)
+
   /**
    * This type of Behavior wraps another Behavior while allowing you to perform
    * some action upon each received message or signal. It is most commonly used
