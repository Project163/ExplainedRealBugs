diff --git a/akka-stream-tests/src/test/scala/akka/stream/scaladsl/HubSpec.scala b/akka-stream-tests/src/test/scala/akka/stream/scaladsl/HubSpec.scala
index 844f7e8769..38fe4882df 100644
--- a/akka-stream-tests/src/test/scala/akka/stream/scaladsl/HubSpec.scala
+++ b/akka-stream-tests/src/test/scala/akka/stream/scaladsl/HubSpec.scala
@@ -4,10 +4,11 @@
 
 package akka.stream.scaladsl
 
+import akka.Done
+
 import scala.collection.immutable
-import scala.concurrent.Await
+import scala.concurrent.{ Await, ExecutionContext, Future, Promise }
 import scala.concurrent.duration._
-
 import akka.stream.KillSwitches
 import akka.stream.ThrottleMode
 import akka.stream.testkit.StreamSpec
@@ -17,9 +18,10 @@ import akka.stream.testkit.Utils.TE
 import akka.stream.testkit.scaladsl.StreamTestKit._
 import akka.stream.testkit.scaladsl.TestSink
 import akka.stream.testkit.scaladsl.TestSource
-import akka.testkit.{ EventFilter, GHExcludeTest }
+import akka.testkit.EventFilter
 
 class HubSpec extends StreamSpec {
+  implicit val ec: ExecutionContext = system.dispatcher
 
   "MergeHub" must {
 
@@ -199,28 +201,36 @@ class HubSpec extends StreamSpec {
       downstream.expectComplete()
     }
 
-    // Excluded in GH Actions: https://github.com/akka/akka/issues/30464
-    "immediately cancel new producers while draining" taggedAs GHExcludeTest in assertAllStagesStopped {
+    "immediately cancel new producers while draining" in assertAllStagesStopped {
       val downstream = TestSubscriber.probe[Int]()
       val (sink, draining) =
         MergeHub.sourceWithDraining[Int](16).take(20).toMat(Sink.fromSubscriber(downstream))(Keep.left).run()
       Source(1 to 10).runWith(sink)
       Source(11 to 20).runWith(sink)
-      draining.drainAndComplete()
 
-      downstream.request(10)
-      val firstBatch = downstream.expectNextN(10)
+      // Give the sources time to fill up the producer buffers before completing (and cancelling the sources)
+      val testResult = Promise[Done]()
+      system.scheduler.scheduleOnce(200.millis) {
+        testResult.completeWith(Future {
+          draining.drainAndComplete()
 
-      val upstream = TestPublisher.probe[Int]()
-      Source.fromPublisher(upstream).runWith(sink)
-      upstream.expectCancellation()
+          downstream.request(10)
+          val firstBatch = downstream.expectNextN(10)
 
-      downstream.request(10)
-      val secondBatch = downstream.expectNextN(10)
+          val upstream = TestPublisher.probe[Int]()
+          Source.fromPublisher(upstream).runWith(sink)
+          upstream.expectCancellation()
 
-      (firstBatch ++ secondBatch).sorted should ===(1 to 20)
+          downstream.request(10)
+          val secondBatch = downstream.expectNextN(10)
 
-      downstream.expectComplete()
+          (firstBatch ++ secondBatch).sorted should ===(1 to 20)
+
+          downstream.expectComplete()
+          Done
+        })
+      }
+      testResult.future.futureValue
     }
   }
 
