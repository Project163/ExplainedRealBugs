diff --git a/akka-stream/src/main/boilerplate/akka/stream/FanInShape.scala.template b/akka-stream/src/main/boilerplate/akka/stream/FanInShape.scala.template
deleted file mode 100644
index a7c6985977..0000000000
--- a/akka-stream/src/main/boilerplate/akka/stream/FanInShape.scala.template
+++ /dev/null
@@ -1,111 +0,0 @@
-/**
- * Copyright (C) 2014-2017 Lightbend Inc. <http://www.lightbend.com>
- */
-package akka.stream
-
-import scala.collection.immutable
-import scala.annotation.unchecked.uncheckedVariance
-
-object FanInShape {
-  sealed trait Init[O] {
-    def outlet: Outlet[O]
-    def inlets: immutable.Seq[Inlet[_]]
-    def name: String
-  }
-  final case class Name[O](override val name: String) extends Init[O] {
-    override def outlet: Outlet[O] = Outlet(s"$name.out")
-    override def inlets: immutable.Seq[Inlet[_]] = Nil
-  }
-  final case class Ports[O](override val outlet: Outlet[O], override val inlets: immutable.Seq[Inlet[_]]) extends Init[O] {
-    override def name: String = "FanIn"
-  }
-}
-
-abstract class FanInShape[+O] private (_out: Outlet[O @uncheckedVariance], _registered: Iterator[Inlet[_]], _name: String) extends Shape {
-  import FanInShape._
-
-  def this(init: FanInShape.Init[O]) = this(init.outlet, init.inlets.iterator, init.name)
-
-  final def out: Outlet[O @uncheckedVariance] = _out
-  final override def outlets: immutable.Seq[Outlet[O @uncheckedVariance]] = _out :: Nil
-  /**
-    * Not meant for overriding outside of Akka.
-    */
-  override def inlets: immutable.Seq[Inlet[_]] = _inlets
-
-  /**
-    * Performance of subclass `UniformFanInShape` relies on `_inlets` being a `Vector`, not a `List`.
-    */
-  private var _inlets: Vector[Inlet[_]] = Vector.empty
-  protected def newInlet[T](name: String): Inlet[T] = {
-    val p = if (_registered.hasNext) _registered.next().asInstanceOf[Inlet[T]] else Inlet[T](s"${_name}.$name")
-    _inlets :+= p
-    p
-  }
-
-  protected def construct(init: Init[O @uncheckedVariance]): FanInShape[O]
-
-  def deepCopy(): FanInShape[O] = construct(Ports[O](_out.carbonCopy(), inlets.map(_.carbonCopy())))
-  final def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): FanInShape[O] = {
-    require(outlets.size == 1, s"proposed outlets [${outlets.mkString(", ")}] do not fit FanInShape")
-    require(inlets.size == _inlets.size, s"proposed inlets [${inlets.mkString(", ")}] do not fit FanInShape")
-    construct(Ports[O](outlets.head.asInstanceOf[Outlet[O]], inlets))
-  }
-}
-
-object UniformFanInShape {
-  def apply[I, O](outlet: Outlet[O], inlets: Inlet[I]*): UniformFanInShape[I, O] =
-    new UniformFanInShape(inlets.size, FanInShape.Ports(outlet, inlets.toList))
-}
-
-class UniformFanInShape[-T, +O](val n: Int, _init: FanInShape.Init[O]) extends FanInShape[O](_init) {
-
-  //ports get added to `FanInShape.inlets` as a side-effect of calling `newInlet`
-  for (i <- 0 until n) newInlet[T](s"in$i")
-
-  def this(n: Int) = this(n, FanInShape.Name[O]("UniformFanIn"))
-  def this(n: Int, name: String) = this(n, FanInShape.Name[O](name))
-  def this(outlet: Outlet[O], inlets: Array[Inlet[T]]) = this(inlets.length, FanInShape.Ports(outlet, inlets.toList))
-  override protected def construct(init: FanInShape.Init[O @uncheckedVariance]): FanInShape[O] = new UniformFanInShape(n, init)
-  override def deepCopy(): UniformFanInShape[T, O] = super.deepCopy().asInstanceOf[UniformFanInShape[T, O]]
-
-  final override def inlets: immutable.Seq[Inlet[T @uncheckedVariance]] = super.inlets.asInstanceOf[immutable.Seq[Inlet[T]]]
-
-  @deprecated("Use `inlets` or `in(id)` instead.", "2.5.5")
-  lazy val inSeq: immutable.IndexedSeq[Inlet[T @uncheckedVariance]] = inlets.toIndexedSeq
-  def in(n: Int): Inlet[T @uncheckedVariance] = inlets(n)
-}
-
-class FanInShape1N[-T0, -T1, +O](val n: Int, _init: FanInShape.Init[O]) extends FanInShape[O](_init) {
-
-  //ports get added to `FanInShape.inlets` as a side-effect of calling `newInlet`
-  val in0: Inlet[T0 @uncheckedVariance] = newInlet[T0]("in0")
-  for (i <- 1 until n) newInlet[T1](s"in$i")
-
-  def this(n: Int) = this(n, FanInShape.Name[O]("FanInShape1N"))
-  def this(n: Int, name: String) = this(n, FanInShape.Name[O](name))
-  def this(outlet: Outlet[O @uncheckedVariance], in0: Inlet[T0 @uncheckedVariance], inlets1: Array[Inlet[T1 @uncheckedVariance]]) = this(inlets1.length, FanInShape.Ports(outlet, in0 :: inlets1.toList))
-  override protected def construct(init: FanInShape.Init[O @uncheckedVariance]): FanInShape[O] = new FanInShape1N(n, init)
-  override def deepCopy(): FanInShape1N[T0, T1, O] = super.deepCopy().asInstanceOf[FanInShape1N[T0, T1, O]]
-
-  @deprecated("Use `inlets` or `in(id)` instead.", "2.5.5")
-  lazy val in1Seq: immutable.IndexedSeq[Inlet[T1 @uncheckedVariance]] = inlets
-    .tail //head is in0
-    .toIndexedSeq.asInstanceOf[immutable.IndexedSeq[Inlet[T1]]]
-  def in(n: Int): Inlet[T1 @uncheckedVariance] = {
-    require(n > 0, "n must be > 0")
-    inlets(n).asInstanceOf[Inlet[T1]]
-  }
-}
-
-[2..#class FanInShape1[[#-T0#], +O](_init: FanInShape.Init[O]) extends FanInShape[O](_init) {
-  def this(name: String) = this(FanInShape.Name[O](name))
-  def this([#in0: Inlet[T0]#], out: Outlet[O]) = this(FanInShape.Ports(out, [#in0# :: ] :: Nil))
-  override protected def construct(init: FanInShape.Init[O @uncheckedVariance]): FanInShape[O] = new FanInShape1(init)
-  override def deepCopy(): FanInShape1[[#T0#], O] = super.deepCopy().asInstanceOf[FanInShape1[[#T0#], O]]
-
-  [#val in0: Inlet[T0 @uncheckedVariance] = newInlet[T0]("in0")#
-  ]
-}#
-
-]
diff --git a/akka-stream/src/main/boilerplate/akka/stream/FanInShapeN.scala.template b/akka-stream/src/main/boilerplate/akka/stream/FanInShapeN.scala.template
new file mode 100644
index 0000000000..96b3671d54
--- /dev/null
+++ b/akka-stream/src/main/boilerplate/akka/stream/FanInShapeN.scala.template
@@ -0,0 +1,18 @@
+/**
+ * Copyright (C) 2014-2017 Lightbend Inc. <http://www.lightbend.com>
+ */
+package akka.stream
+
+import scala.annotation.unchecked.uncheckedVariance
+
+[2..#class FanInShape1[[#-T0#], +O](_init: FanInShape.Init[O]) extends FanInShape[O](_init) {
+  def this(name: String) = this(FanInShape.Name[O](name))
+  def this([#in0: Inlet[T0]#], out: Outlet[O]) = this(FanInShape.Ports(out, [#in0# :: ] :: Nil))
+  override protected def construct(init: FanInShape.Init[O @uncheckedVariance]): FanInShape[O] = new FanInShape1(init)
+  override def deepCopy(): FanInShape1[[#T0#], O] = super.deepCopy().asInstanceOf[FanInShape1[[#T0#], O]]
+
+  [#val in0: Inlet[T0 @uncheckedVariance] = newInlet[T0]("in0")#
+  ]
+}#
+
+]
diff --git a/akka-stream/src/main/boilerplate/akka/stream/FanOutShape.scala.template b/akka-stream/src/main/boilerplate/akka/stream/FanOutShape.scala.template
deleted file mode 100644
index 5e63d20ac8..0000000000
--- a/akka-stream/src/main/boilerplate/akka/stream/FanOutShape.scala.template
+++ /dev/null
@@ -1,91 +0,0 @@
-/**
- * Copyright (C) 2014-2017 Lightbend Inc. <http://www.lightbend.com>
- */
-package akka.stream
-
-import scala.collection.immutable
-import scala.annotation.unchecked.uncheckedVariance
-
-object FanOutShape {
-  sealed trait Init[I] {
-    def inlet: Inlet[I]
-    def outlets: immutable.Seq[Outlet[_]]
-    def name: String
-  }
-  final case class Name[I](override val name: String) extends Init[I] {
-    override def inlet: Inlet[I] = Inlet(s"$name.in")
-    override def outlets: immutable.Seq[Outlet[_]] = Nil
-  }
-  final case class Ports[I](override val inlet: Inlet[I], override val outlets: immutable.Seq[Outlet[_]]) extends Init[I] {
-    override def name: String = "FanOut"
-  }
-}
-
-abstract class FanOutShape[-I] private (_in: Inlet[I @uncheckedVariance], _registered: Iterator[Outlet[_]], _name: String) extends Shape {
-  import FanOutShape._
-
-  def this(init: FanOutShape.Init[I]) = this(init.inlet, init.outlets.iterator, init.name)
-  
-  final def in: Inlet[I @uncheckedVariance] = _in
-
-  /**
-    * Not meant for overriding outside of Akka.
-    */
-  override def outlets: immutable.Seq[Outlet[_]] = _outlets
-  final override def inlets: immutable.Seq[Inlet[I @uncheckedVariance]] = in :: Nil
-
-  /**
-    * Performance of subclass `UniformFanOutShape` relies on `_outlets` being a `Vector`, not a `List`.
-    */
-  private var _outlets: Vector[Outlet[_]] = Vector.empty
-  protected def newOutlet[T](name: String): Outlet[T] = {
-    val p = if (_registered.hasNext) _registered.next().asInstanceOf[Outlet[T]] else Outlet[T](s"${_name}.$name")
-    _outlets :+= p
-    p
-  }
-  
-  protected def construct(init: Init[I @uncheckedVariance]): FanOutShape[I]
-  
-  def deepCopy(): FanOutShape[I] = construct(Ports[I](_in.carbonCopy(), outlets.map(_.carbonCopy())))
-  final def copyFromPorts(inlets: immutable.Seq[Inlet[_]], outlets: immutable.Seq[Outlet[_]]): FanOutShape[I] = {
-    require(outlets.size == _outlets.size, s"proposed outlets [${outlets.mkString(", ")}] do not fit FanOutShape")
-    require(inlets.size == 1, s"proposed inlets [${inlets.mkString(", ")}] do not fit FanOutShape")
-    construct(Ports[I](inlets.head.asInstanceOf[Inlet[I]], outlets))
-  }
-}
-
-object UniformFanOutShape {
-  def apply[I, O](inlet: Inlet[I], outlets: Outlet[O]*): UniformFanOutShape[I, O] =
-    new UniformFanOutShape(outlets.size, FanOutShape.Ports(inlet, outlets.toList))
-}
-
-class UniformFanOutShape[-I, +O](n: Int, _init: FanOutShape.Init[I @uncheckedVariance]) extends FanOutShape[I](_init) {
-
-  //initialize by side-effect
-  for (i <- 0 until n) newOutlet[O](s"out$i")
-
-  def this(n: Int) = this(n, FanOutShape.Name[I]("UniformFanOut"))
-  def this(n: Int, name: String) = this(n, FanOutShape.Name[I](name))
-  def this(inlet: Inlet[I], outlets: Array[Outlet[O]]) = this(outlets.length, FanOutShape.Ports(inlet, outlets.toList))
-  override protected def construct(init: FanOutShape.Init[I @uncheckedVariance]): FanOutShape[I] = new UniformFanOutShape(n, init)
-  override def deepCopy(): UniformFanOutShape[I, O] = super.deepCopy().asInstanceOf[UniformFanOutShape[I, O]]
-
-  final override def outlets: immutable.Seq[Outlet[O @uncheckedVariance]] = super.outlets.asInstanceOf[immutable.Seq[Outlet[O]]]
-
-  @Deprecated
-  @deprecated("use `outlets` or `out(id)` instead", "2.5.5")
-  lazy val outArray: Array[Outlet[O @uncheckedVariance]] = outlets.toArray
-  def out(n: Int): Outlet[O @uncheckedVariance] = outlets(n)
-}
-
-[2..#class FanOutShape1[-I, [#+O0#]](_init: FanOutShape.Init[I @uncheckedVariance]) extends FanOutShape[I](_init) {
-  def this(name: String) = this(FanOutShape.Name[I](name))
-  def this(in: Inlet[I], [#out0: Outlet[O0]#]) = this(FanOutShape.Ports(in, [#out0# :: ] :: Nil))
-  override protected def construct(init: FanOutShape.Init[I @uncheckedVariance]): FanOutShape[I] = new FanOutShape1(init)
-  override def deepCopy(): FanOutShape1[I, [#O0#]] = super.deepCopy().asInstanceOf[FanOutShape1[I, [#O0#]]]
-  
-  [#val out0: Outlet[O0 @uncheckedVariance] = newOutlet[O0]("out0")#
-  ]
-}#
-
-]
diff --git a/akka-stream/src/main/boilerplate/akka/stream/FanOutShapeN.scala.template b/akka-stream/src/main/boilerplate/akka/stream/FanOutShapeN.scala.template
new file mode 100644
index 0000000000..d67008e013
--- /dev/null
+++ b/akka-stream/src/main/boilerplate/akka/stream/FanOutShapeN.scala.template
@@ -0,0 +1,18 @@
+/**
+ * Copyright (C) 2014-2017 Lightbend Inc. <http://www.lightbend.com>
+ */
+package akka.stream
+
+import scala.annotation.unchecked.uncheckedVariance
+
+[2..#class FanOutShape1[-I, [#+O0#]](_init: FanOutShape.Init[I @uncheckedVariance]) extends FanOutShape[I](_init) {
+  def this(name: String) = this(FanOutShape.Name[I](name))
+  def this(in: Inlet[I], [#out0: Outlet[O0]#]) = this(FanOutShape.Ports(in, [#out0# :: ] :: Nil))
+  override protected def construct(init: FanOutShape.Init[I @uncheckedVariance]): FanOutShape[I] = new FanOutShape1(init)
+  override def deepCopy(): FanOutShape1[I, [#O0#]] = super.deepCopy().asInstanceOf[FanOutShape1[I, [#O0#]]]
+  
+  [#val out0: Outlet[O0 @uncheckedVariance] = newOutlet[O0]("out0")#
+  ]
+}#
+
+]
diff --git a/akka-stream/src/main/mima-filters/2.5.4.backwards.excludes b/akka-stream/src/main/mima-filters/2.5.4.backwards.excludes
index 65a3c056cb..e539d9f1d6 100644
--- a/akka-stream/src/main/mima-filters/2.5.4.backwards.excludes
+++ b/akka-stream/src/main/mima-filters/2.5.4.backwards.excludes
@@ -8,4 +8,11 @@ ProblemFilters.exclude[DirectMissingMethodProblem]("akka.stream.impl.io.FileSour
 ProblemFilters.exclude[DirectMissingMethodProblem]("akka.stream.impl.io.FileSource.this")
 ProblemFilters.exclude[MissingClassProblem]("akka.stream.impl.io.FilePublisher$")
 ProblemFilters.exclude[MissingClassProblem]("akka.stream.impl.io.FilePublisher$Continue$")
-ProblemFilters.exclude[MissingClassProblem]("akka.stream.impl.io.FilePublisher")
\ No newline at end of file
+ProblemFilters.exclude[MissingClassProblem]("akka.stream.impl.io.FilePublisher")
+
+# Cleanup from left-overs from old materializer.
+# Methods are not used from inside akka. It's technically a binary incompatible because methods were public before.
+# It would break user code which called `copyFromPorts` explicitly. This seems highly unlikely as these methods were
+# thought to be used only from inside the old materializer.
+ProblemFilters.exclude[DirectMissingMethodProblem]("akka.stream.FanInShape.copyFromPorts")
+ProblemFilters.exclude[DirectMissingMethodProblem]("akka.stream.FanOutShape.copyFromPorts")
diff --git a/akka-stream/src/main/scala/akka/stream/FanInShape.scala b/akka-stream/src/main/scala/akka/stream/FanInShape.scala
new file mode 100644
index 0000000000..b1a87c7736
--- /dev/null
+++ b/akka-stream/src/main/scala/akka/stream/FanInShape.scala
@@ -0,0 +1,49 @@
+/**
+ * Copyright (C) 2014-2017 Lightbend Inc. <http://www.lightbend.com>
+ */
+package akka.stream
+
+import scala.collection.immutable
+import scala.annotation.unchecked.uncheckedVariance
+
+object FanInShape {
+  sealed trait Init[O] {
+    def outlet: Outlet[O]
+    def inlets: immutable.Seq[Inlet[_]]
+    def name: String
+  }
+  final case class Name[O](override val name: String) extends Init[O] {
+    override def outlet: Outlet[O] = Outlet(s"$name.out")
+    override def inlets: immutable.Seq[Inlet[_]] = Nil
+  }
+  final case class Ports[O](override val outlet: Outlet[O], override val inlets: immutable.Seq[Inlet[_]]) extends Init[O] {
+    override def name: String = "FanIn"
+  }
+}
+
+abstract class FanInShape[+O] private (_out: Outlet[O @uncheckedVariance], _registered: Iterator[Inlet[_]], _name: String) extends Shape {
+  import FanInShape._
+
+  def this(init: FanInShape.Init[O]) = this(init.outlet, init.inlets.iterator, init.name)
+
+  final def out: Outlet[O @uncheckedVariance] = _out
+  final override def outlets: immutable.Seq[Outlet[O @uncheckedVariance]] = _out :: Nil
+  /**
+   * Not meant for overriding outside of Akka.
+   */
+  override def inlets: immutable.Seq[Inlet[_]] = _inlets
+
+  /**
+   * Performance of subclass `UniformFanInShape` relies on `_inlets` being a `Vector`, not a `List`.
+   */
+  private var _inlets: Vector[Inlet[_]] = Vector.empty
+  protected def newInlet[T](name: String): Inlet[T] = {
+    val p = if (_registered.hasNext) _registered.next().asInstanceOf[Inlet[T]] else Inlet[T](s"${_name}.$name")
+    _inlets :+= p
+    p
+  }
+
+  protected def construct(init: Init[O @uncheckedVariance]): FanInShape[O]
+
+  def deepCopy(): FanInShape[O] = construct(Ports[O](_out.carbonCopy(), inlets.map(_.carbonCopy())))
+}
diff --git a/akka-stream/src/main/scala/akka/stream/FanInShape1N.scala b/akka-stream/src/main/scala/akka/stream/FanInShape1N.scala
new file mode 100644
index 0000000000..2aeb85bb23
--- /dev/null
+++ b/akka-stream/src/main/scala/akka/stream/FanInShape1N.scala
@@ -0,0 +1,28 @@
+package akka.stream
+
+import scala.annotation.unchecked.uncheckedVariance
+import scala.collection.immutable
+
+@Deprecated
+@deprecated("FanInShape1N was removed because it was not used anywhere. Use a custom shape extending from FanInShape directly.", "2.5.5")
+class FanInShape1N[-T0, -T1, +O](val n: Int, _init: FanInShape.Init[O]) extends FanInShape[O](_init) {
+
+  //ports get added to `FanInShape.inlets` as a side-effect of calling `newInlet`
+  val in0: Inlet[T0 @uncheckedVariance] = newInlet[T0]("in0")
+  for (i ← 1 until n) newInlet[T1](s"in$i")
+
+  def this(n: Int) = this(n, FanInShape.Name[O]("FanInShape1N"))
+  def this(n: Int, name: String) = this(n, FanInShape.Name[O](name))
+  def this(outlet: Outlet[O @uncheckedVariance], in0: Inlet[T0 @uncheckedVariance], inlets1: Array[Inlet[T1 @uncheckedVariance]]) = this(inlets1.length, FanInShape.Ports(outlet, in0 :: inlets1.toList))
+  override protected def construct(init: FanInShape.Init[O @uncheckedVariance]): FanInShape[O] = new FanInShape1N(n, init)
+  override def deepCopy(): FanInShape1N[T0, T1, O] = super.deepCopy().asInstanceOf[FanInShape1N[T0, T1, O]]
+
+  @deprecated("Use 'inlets' or 'in(id)' instead.", "2.5.5")
+  lazy val in1Seq: immutable.IndexedSeq[Inlet[T1 @uncheckedVariance]] = inlets
+    .tail //head is in0
+    .toIndexedSeq.asInstanceOf[immutable.IndexedSeq[Inlet[T1]]]
+  def in(n: Int): Inlet[T1 @uncheckedVariance] = {
+    require(n > 0, "n must be > 0")
+    inlets(n).asInstanceOf[Inlet[T1]]
+  }
+}
diff --git a/akka-stream/src/main/scala/akka/stream/FanOutShape.scala b/akka-stream/src/main/scala/akka/stream/FanOutShape.scala
new file mode 100644
index 0000000000..e7734f062b
--- /dev/null
+++ b/akka-stream/src/main/scala/akka/stream/FanOutShape.scala
@@ -0,0 +1,50 @@
+/**
+ * Copyright (C) 2014-2017 Lightbend Inc. <http://www.lightbend.com>
+ */
+package akka.stream
+
+import scala.collection.immutable
+import scala.annotation.unchecked.uncheckedVariance
+
+object FanOutShape {
+  sealed trait Init[I] {
+    def inlet: Inlet[I]
+    def outlets: immutable.Seq[Outlet[_]]
+    def name: String
+  }
+  final case class Name[I](override val name: String) extends Init[I] {
+    override def inlet: Inlet[I] = Inlet(s"$name.in")
+    override def outlets: immutable.Seq[Outlet[_]] = Nil
+  }
+  final case class Ports[I](override val inlet: Inlet[I], override val outlets: immutable.Seq[Outlet[_]]) extends Init[I] {
+    override def name: String = "FanOut"
+  }
+}
+
+abstract class FanOutShape[-I] private (_in: Inlet[I @uncheckedVariance], _registered: Iterator[Outlet[_]], _name: String) extends Shape {
+  import FanOutShape._
+
+  def this(init: FanOutShape.Init[I]) = this(init.inlet, init.outlets.iterator, init.name)
+
+  final def in: Inlet[I @uncheckedVariance] = _in
+
+  /**
+   * Not meant for overriding outside of Akka.
+   */
+  override def outlets: immutable.Seq[Outlet[_]] = _outlets
+  final override def inlets: immutable.Seq[Inlet[I @uncheckedVariance]] = in :: Nil
+
+  /**
+   * Performance of subclass `UniformFanOutShape` relies on `_outlets` being a `Vector`, not a `List`.
+   */
+  private var _outlets: Vector[Outlet[_]] = Vector.empty
+  protected def newOutlet[T](name: String): Outlet[T] = {
+    val p = if (_registered.hasNext) _registered.next().asInstanceOf[Outlet[T]] else Outlet[T](s"${_name}.$name")
+    _outlets :+= p
+    p
+  }
+
+  protected def construct(init: Init[I @uncheckedVariance]): FanOutShape[I]
+
+  def deepCopy(): FanOutShape[I] = construct(Ports[I](_in.carbonCopy(), outlets.map(_.carbonCopy())))
+}
diff --git a/akka-stream/src/main/scala/akka/stream/UniformFanInShape.scala b/akka-stream/src/main/scala/akka/stream/UniformFanInShape.scala
new file mode 100644
index 0000000000..2b9c514dcb
--- /dev/null
+++ b/akka-stream/src/main/scala/akka/stream/UniformFanInShape.scala
@@ -0,0 +1,30 @@
+/**
+ * Copyright (C) 2014-2017 Lightbend Inc. <http://www.lightbend.com>
+ */
+package akka.stream
+
+import scala.collection.immutable
+import scala.annotation.unchecked.uncheckedVariance
+
+object UniformFanInShape {
+  def apply[I, O](outlet: Outlet[O], inlets: Inlet[I]*): UniformFanInShape[I, O] =
+    new UniformFanInShape(inlets.size, FanInShape.Ports(outlet, inlets.toList))
+}
+
+class UniformFanInShape[-T, +O](val n: Int, _init: FanInShape.Init[O]) extends FanInShape[O](_init) {
+
+  //ports get added to `FanInShape.inlets` as a side-effect of calling `newInlet`
+  for (i ← 0 until n) newInlet[T](s"in$i")
+
+  def this(n: Int) = this(n, FanInShape.Name[O]("UniformFanIn"))
+  def this(n: Int, name: String) = this(n, FanInShape.Name[O](name))
+  def this(outlet: Outlet[O], inlets: Array[Inlet[T]]) = this(inlets.length, FanInShape.Ports(outlet, inlets.toList))
+  override protected def construct(init: FanInShape.Init[O @uncheckedVariance]): FanInShape[O] = new UniformFanInShape(n, init)
+  override def deepCopy(): UniformFanInShape[T, O] = super.deepCopy().asInstanceOf[UniformFanInShape[T, O]]
+
+  final override def inlets: immutable.Seq[Inlet[T @uncheckedVariance]] = super.inlets.asInstanceOf[immutable.Seq[Inlet[T]]]
+
+  @deprecated("Use 'inlets' or 'in(id)' instead.", "2.5.5")
+  lazy val inSeq: immutable.IndexedSeq[Inlet[T @uncheckedVariance]] = inlets.toIndexedSeq
+  def in(n: Int): Inlet[T @uncheckedVariance] = inlets(n)
+}
diff --git a/akka-stream/src/main/scala/akka/stream/UniformFanOutShape.scala b/akka-stream/src/main/scala/akka/stream/UniformFanOutShape.scala
new file mode 100644
index 0000000000..902e63eaba
--- /dev/null
+++ b/akka-stream/src/main/scala/akka/stream/UniformFanOutShape.scala
@@ -0,0 +1,31 @@
+/**
+ * Copyright (C) 2014-2017 Lightbend Inc. <http://www.lightbend.com>
+ */
+package akka.stream
+
+import scala.collection.immutable
+import scala.annotation.unchecked.uncheckedVariance
+
+object UniformFanOutShape {
+  def apply[I, O](inlet: Inlet[I], outlets: Outlet[O]*): UniformFanOutShape[I, O] =
+    new UniformFanOutShape(outlets.size, FanOutShape.Ports(inlet, outlets.toList))
+}
+
+class UniformFanOutShape[-I, +O](n: Int, _init: FanOutShape.Init[I @uncheckedVariance]) extends FanOutShape[I](_init) {
+
+  //initialize by side-effect
+  for (i ← 0 until n) newOutlet[O](s"out$i")
+
+  def this(n: Int) = this(n, FanOutShape.Name[I]("UniformFanOut"))
+  def this(n: Int, name: String) = this(n, FanOutShape.Name[I](name))
+  def this(inlet: Inlet[I], outlets: Array[Outlet[O]]) = this(outlets.length, FanOutShape.Ports(inlet, outlets.toList))
+  override protected def construct(init: FanOutShape.Init[I @uncheckedVariance]): FanOutShape[I] = new UniformFanOutShape(n, init)
+  override def deepCopy(): UniformFanOutShape[I, O] = super.deepCopy().asInstanceOf[UniformFanOutShape[I, O]]
+
+  final override def outlets: immutable.Seq[Outlet[O @uncheckedVariance]] = super.outlets.asInstanceOf[immutable.Seq[Outlet[O]]]
+
+  @Deprecated
+  @deprecated("use 'outlets' or 'out(id)' instead", "2.5.5")
+  lazy val outArray: Array[Outlet[O @uncheckedVariance]] = outlets.toArray
+  def out(n: Int): Outlet[O @uncheckedVariance] = outlets(n)
+}
\ No newline at end of file
