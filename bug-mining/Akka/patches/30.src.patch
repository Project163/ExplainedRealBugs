diff --git a/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java b/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java
index 04f6c5495d..9fce5865ac 100644
--- a/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java
+++ b/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java
@@ -6,25 +6,28 @@ package jdocs.akka.typed;
 import akka.actor.typed.ActorRef;
 import akka.actor.typed.ActorSystem;
 import akka.actor.typed.Behavior;
+import akka.actor.typed.Props;
 import akka.actor.typed.javadsl.ActorContext;
 import akka.actor.typed.javadsl.BehaviorBuilder;
 import akka.actor.typed.javadsl.Behaviors;
+import akka.actor.typed.javadsl.TimerScheduler;
+import akka.testkit.typed.scaladsl.TestProbe;
 import org.junit.Test;
 import org.scalatest.junit.JUnitSuite;
 import scala.concurrent.Await;
 import scala.concurrent.duration.Duration;
+import scala.concurrent.duration.FiniteDuration;
 
 import java.net.URI;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.*;
 import java.util.concurrent.TimeUnit;
 
 public class InteractionPatternsTest extends JUnitSuite {
 
   // #fire-and-forget
-  interface PrinterProtocol {}
-  class DisableOutput implements PrinterProtocol {}
-  class EnableOutput implements PrinterProtocol {}
+  interface PrinterProtocol { }
+  class DisableOutput implements PrinterProtocol { }
+  class EnableOutput implements PrinterProtocol { }
   class PrintMe implements PrinterProtocol {
     public final String message;
     public PrintMe(String message) {
@@ -197,7 +200,7 @@ public class InteractionPatternsTest extends JUnitSuite {
   public void fireAndForgetSample() throws Exception {
     // #fire-and-forget
     final ActorSystem<PrinterProtocol> system =
-        ActorSystem.create(enabledPrinterBehavior(), "printer-sample-system");
+      ActorSystem.create(enabledPrinterBehavior(), "printer-sample-system");
 
     // note that system is also the ActorRef to the guardian actor
     final ActorRef<PrinterProtocol> ref = system;
@@ -213,5 +216,105 @@ public class InteractionPatternsTest extends JUnitSuite {
     Await.ready(system.terminate(), Duration.create(3, TimeUnit.SECONDS));
   }
 
+  //#timer
+  interface Msg {
+  }
+
+  public static final class Batch {
+    private final List<Msg> messages;
+
+    public Batch(List<Msg> messages) {
+      this.messages = Collections.unmodifiableList(messages);
+    }
+
+    public List<Msg> getMessages() {
+      return messages;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
+      Batch batch = (Batch) o;
+      return Objects.equals(messages, batch.messages);
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(messages);
+    }
+  }
+
+  public static final class ExcitingMessage implements Msg {
+    private final String msg;
+
+    public ExcitingMessage(String msg) {
+      this.msg = msg;
+    }
+  }
+
+  private static final Object TIMER_KEY = new Object();
+
+  private static class Timeout implements Msg {
+  }
+
+  public static Behavior<Msg> behavior(ActorRef<Batch> target, FiniteDuration after, int maxSize) {
+    return Behaviors.withTimers(timers -> idle(timers, target, after, maxSize));
+  }
+
+  private static Behavior<Msg> idle(TimerScheduler<Msg> timers, ActorRef<Batch> target,
+                                    FiniteDuration after, int maxSize) {
+    return Behaviors.immutable(Msg.class)
+      .onMessage(Msg.class, (ctx, msg) -> {
+        timers.startSingleTimer(TIMER_KEY, new Timeout(), after);
+        List<Msg> buffer = new ArrayList<>();
+        buffer.add(msg);
+        return active(buffer, timers, target, after, maxSize);
+      })
+      .build();
+  }
+
+  private static Behavior<Msg> active(List<Msg> buffer, TimerScheduler<Msg> timers,
+                                      ActorRef<Batch> target, FiniteDuration after, int maxSize) {
+    return Behaviors.immutable(Msg.class)
+      .onMessage(Timeout.class, (ctx, msg) -> {
+        target.tell(new Batch(buffer));
+        return idle(timers, target, after, maxSize);
+      })
+      .onMessage(Msg.class, (ctx, msg) -> {
+        buffer.add(msg);
+        if (buffer.size() == maxSize) {
+          timers.cancel(TIMER_KEY);
+          target.tell(new Batch(buffer));
+          return idle(timers, target, after, maxSize);
+        } else {
+          return active(buffer, timers, target, after, maxSize);
+        }
+      })
+      .build();
+  }
+  //#timer
+
+  @Test
+  public void timers() throws Exception {
+    final ActorSystem<Object> system = ActorSystem.create(Behaviors.empty(), "timers-sample");
+    TestProbe<Batch> probe = new TestProbe<>("batcher", system);
+    ActorRef<Msg> bufferer = Await.result(system.systemActorOf(
+      behavior(probe.ref(), new FiniteDuration(1, TimeUnit.SECONDS), 10),
+      "batcher", Props.empty(), akka.util.Timeout.apply(1, TimeUnit.SECONDS)), new FiniteDuration(1, TimeUnit.SECONDS));
+
+    ExcitingMessage msgOne = new ExcitingMessage("one");
+    ExcitingMessage msgTwo = new ExcitingMessage("two");
+    bufferer.tell(msgOne);
+    bufferer.tell(msgTwo);
+    probe.expectNoMessage(new FiniteDuration(1, TimeUnit.MILLISECONDS));
+    probe.expectMsg(new FiniteDuration(2, TimeUnit.SECONDS),
+      new Batch(Arrays.asList(msgOne, msgTwo)));
+
+    Await.ready(system.terminate(), Duration.create(3, TimeUnit.SECONDS));
+  }
 
 }
+
+
+
diff --git a/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala b/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala
index 7622bfd49d..9da9086f64 100644
--- a/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala
+++ b/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala
@@ -6,10 +6,12 @@ package docs.akka.typed
 import java.net.URI
 
 import akka.actor.typed.{ ActorRef, ActorSystem, Behavior, TypedAkkaSpecWithShutdown }
-import akka.actor.typed.scaladsl.Behaviors
+import akka.actor.typed.scaladsl.{ Behaviors, TimerScheduler }
 import akka.testkit.typed.TestKit
 import akka.testkit.typed.scaladsl.TestProbe
 
+import scala.concurrent.duration._
+
 class InteractionPatternsSpec extends TestKit with TypedAkkaSpecWithShutdown {
 
   "The interaction patterns docs" must {
@@ -138,4 +140,53 @@ class InteractionPatternsSpec extends TestKit with TypedAkkaSpecWithShutdown {
 
   }
 
+  "contain a sample for scheduling messages to self" in {
+
+    //#timer
+    case object TimerKey
+
+    trait Msg
+    case class ExcitingMessage(msg: String) extends Msg
+    final case class Batch(messages: Vector[Msg])
+    case object Timeout extends Msg
+
+    def behavior(target: ActorRef[Batch], after: FiniteDuration, maxSize: Int): Behavior[Msg] = {
+      Behaviors.withTimers(timers ⇒ idle(timers, target, after, maxSize))
+    }
+
+    def idle(timers: TimerScheduler[Msg], target: ActorRef[Batch],
+             after: FiniteDuration, maxSize: Int): Behavior[Msg] = {
+      Behaviors.immutable[Msg] { (ctx, msg) ⇒
+        timers.startSingleTimer(TimerKey, Timeout, after)
+        active(Vector(msg), timers, target, after, maxSize)
+      }
+    }
+
+    def active(buffer: Vector[Msg], timers: TimerScheduler[Msg],
+               target: ActorRef[Batch], after: FiniteDuration, maxSize: Int): Behavior[Msg] = {
+      Behaviors.immutable[Msg] { (_, msg) ⇒
+        msg match {
+          case Timeout ⇒
+            target ! Batch(buffer)
+            idle(timers, target, after, maxSize)
+          case m ⇒
+            val newBuffer = buffer :+ m
+            if (newBuffer.size == maxSize) {
+              timers.cancel(TimerKey)
+              target ! Batch(newBuffer)
+              idle(timers, target, after, maxSize)
+            } else
+              active(newBuffer, timers, target, after, maxSize)
+        }
+      }
+    }
+    //#timer
+
+    val probe: TestProbe[Batch] = TestProbe[Batch]()
+    val bufferer: ActorRef[Msg] = spawn(behavior(probe.ref, 1.second, 10))
+    bufferer ! ExcitingMessage("one")
+    bufferer ! ExcitingMessage("two")
+    probe.expectNoMessage(1.millisecond)
+    probe.expectMsg(2.seconds, Batch(Vector[Msg](ExcitingMessage("one"), ExcitingMessage("two"))))
+  }
 }
diff --git a/akka-docs/src/main/paradox/common/may-change.md b/akka-docs/src/main/paradox/common/may-change.md
index a9cf9e15b0..1e58f2a6c5 100644
--- a/akka-docs/src/main/paradox/common/may-change.md
+++ b/akka-docs/src/main/paradox/common/may-change.md
@@ -29,6 +29,6 @@ that the module or API wasn't useful.
 These are the current complete modules marked as **may change**:
 
 * @ref:[Multi Node Testing](../multi-node-testing.md)
-* @ref:[Akka Typed](../actors-typed.md)
+* @ref:[Akka Typed](../typed/actors.md)
 
 
diff --git a/akka-docs/src/main/paradox/index-typed.md b/akka-docs/src/main/paradox/index-typed.md
index 022d90986a..f120823a58 100644
--- a/akka-docs/src/main/paradox/index-typed.md
+++ b/akka-docs/src/main/paradox/index-typed.md
@@ -4,16 +4,16 @@
 
 @@@ index
 
-* [actors](actors-typed.md)
-* [coexisting](coexisting.md)
-* [actor-lifecycle](actor-lifecycle-typed.md)
-* [interaction patterns](interaction-patterns-typed.md)
-* [fault-tolerance](fault-tolerance-typed.md)
-* [actor-discovery](actor-discovery-typed.md)
-* [cluster](cluster-typed.md)
-* [cluster-singleton](cluster-singleton-typed.md)
-* [cluster-sharding](cluster-sharding-typed.md)
-* [persistence](persistence-typed.md)
-* [testing](testing-typed.md)
+* [actors](typed/actors.md)
+* [coexisting](typed/coexisting.md)
+* [actor-lifecycle](typed/actor-lifecycle.md)
+* [interaction patterns](typed/interaction-patterns.md)
+* [fault-tolerance](typed/fault-tolerance.md)
+* [actor-discovery](typed/actor-discovery.md)
+* [cluster](typed/cluster.md)
+* [cluster-singleton](cluster-singleton.md)
+* [cluster-sharding](typed/cluster-sharding.md)
+* [persistence](typed/persistence.md)
+* [testing](typed/testing.md)
 
 @@@
diff --git a/akka-docs/src/main/paradox/typed-actors.md b/akka-docs/src/main/paradox/typed-actors.md
index 9cae31bbf5..17df2f14a6 100644
--- a/akka-docs/src/main/paradox/typed-actors.md
+++ b/akka-docs/src/main/paradox/typed-actors.md
@@ -2,7 +2,7 @@
 
 @@@ note
 
-This module will be deprecated as it will be superseded by the @ref:[Akka Typed](actors-typed.md)
+This module will be deprecated as it will be superseded by the @ref:[Akka Typed](typed/actors.md)
 project which is currently being developed in open preview mode.
 
 @@@
diff --git a/akka-docs/src/main/paradox/actor-discovery-typed.md b/akka-docs/src/main/paradox/typed/actor-discovery.md
similarity index 92%
rename from akka-docs/src/main/paradox/actor-discovery-typed.md
rename to akka-docs/src/main/paradox/typed/actor-discovery.md
index bfa2856b87..58bff05561 100644
--- a/akka-docs/src/main/paradox/actor-discovery-typed.md
+++ b/akka-docs/src/main/paradox/typed/actor-discovery.md
@@ -1,6 +1,6 @@
 # Actor discovery
 
-With @ref:[untyped actors](general/addressing.md) you would use `ActorSelection` to "lookup" actors. Given an actor path with 
+With @ref:[untyped actors](../general/addressing.md) you would use `ActorSelection` to "lookup" actors. Given an actor path with 
 address information you can get hold of an `ActorRef` to any actor. `ActorSelection` does not exist in Akka Typed, 
 so how do you get the actor references? You can send refs in messages but you need something to bootstrap the interaction.
 
@@ -54,6 +54,6 @@ guardian actor spawns a pinger to ping it.
 
 The `Receptionist` also works in a cluster, an actor registered to the receptionist will appear in the receptionist of the other nodes of the cluster.
 
-The state for the receptionist is propagated via @ref:[distributed data](distributed-data.md) which means that each node will eventually reach the same set of actors per `ServiceKey`.
+The state for the receptionist is propagated via @ref:[distributed data](../distributed-data.md) which means that each node will eventually reach the same set of actors per `ServiceKey`.
 
-One important difference from a local only receptions is the serialisation concerns, all messages sent to and back from an actor on another node must be serializable, see @ref:[clustering](cluster-typed.md#serialization).
+One important difference from a local only receptions is the serialisation concerns, all messages sent to and back from an actor on another node must be serializable, see @ref:[clustering](cluster.md#serialization).
diff --git a/akka-docs/src/main/paradox/actor-lifecycle-typed.md b/akka-docs/src/main/paradox/typed/actor-lifecycle.md
similarity index 100%
rename from akka-docs/src/main/paradox/actor-lifecycle-typed.md
rename to akka-docs/src/main/paradox/typed/actor-lifecycle.md
diff --git a/akka-docs/src/main/paradox/actors-typed.md b/akka-docs/src/main/paradox/typed/actors.md
similarity index 98%
rename from akka-docs/src/main/paradox/actors-typed.md
rename to akka-docs/src/main/paradox/typed/actors.md
index 0ab221efcd..4a9636315f 100644
--- a/akka-docs/src/main/paradox/actors-typed.md
+++ b/akka-docs/src/main/paradox/typed/actors.md
@@ -2,7 +2,7 @@
 
 @@@ warning
 
-This module is currently marked as @ref:[may change](common/may-change.md) in the sense
+This module is currently marked as @ref:[may change](../common/may-change.md) in the sense
   of being the subject of active research. This means that API or semantics can
   change without warning or deprecation period and it is not recommended to use
   this module in production just yet—you have been warned.
@@ -25,7 +25,7 @@ To use Akka Typed add the following dependency:
 
 ## Introduction
 
-As discussed in @ref:[Actor Systems](general/actor-systems.md) Actors are about
+As discussed in @ref:[Actor Systems](../general/actor-systems.md) Actors are about
 sending messages between independent units of computation, but how does that
 look like? 
 
@@ -275,7 +275,7 @@ Akka Typed is the result of many years of research and previous attempts
 (including Typed Channels in the 2.2.x series) and it is on its way to
 stabilization, but maturing such a profound change to the core concept of Akka
 will take a long time. We expect that this module will stay marked
-@ref:[may change](common/may-change.md) for multiple major releases of Akka and the
+@ref:[may change](../common/may-change.md) for multiple major releases of Akka and the
 plain `akka.actor.Actor` will not be deprecated or go away anytime soon.
 
 Being a research project also entails that the reference documentation is not
diff --git a/akka-docs/src/main/paradox/cluster-sharding-typed.md b/akka-docs/src/main/paradox/typed/cluster-sharding.md
similarity index 92%
rename from akka-docs/src/main/paradox/cluster-sharding-typed.md
rename to akka-docs/src/main/paradox/typed/cluster-sharding.md
index 15797932af..2126649894 100644
--- a/akka-docs/src/main/paradox/cluster-sharding-typed.md
+++ b/akka-docs/src/main/paradox/typed/cluster-sharding.md
@@ -2,7 +2,7 @@
 
 @@@ warning
 
-This module is currently marked as @ref:[may change](common/may-change.md) in the sense
+This module is currently marked as @ref:[may change](../common/may-change.md) in the sense
   of being the subject of active research. This means that API or semantics can
   change without warning or deprecation period and it is not recommended to use
   this module in production just yet—you have been warned.
@@ -17,7 +17,7 @@ To use cluster sharding add the following dependency:
   version=$akka.version$
 }
 
-For an introduction to Sharding concepts see @ref:[Cluster Sharding](cluster-sharding.md). This documentation shows how to use the typed
+For an introduction to Sharding concepts see @ref:[Cluster Sharding](../cluster-sharding.md). This documentation shows how to use the typed
 Cluster Sharding API.
 
 ## Basic example
@@ -61,7 +61,7 @@ When using sharding entities can be moved to different nodes in the cluster. Per
 an actor after it has moved. Currently Akka typed only has a Scala API for persistence, you can track the progress of the
 Java API [here](https://github.com/akka/akka/issues/24193).
 
-Taking the larger example from the @ref:[persistence documentation](persistence-typed.md#larger-example) and making it into
+Taking the larger example from the @ref:[persistence documentation](persistence.md#larger-example) and making it into
 a sharded entity is the same as for a non persistent behavior. The behavior:
 
 Scala
@@ -73,4 +73,4 @@ Scala
 :  @@snip [ShardingCompileOnlySpec.scala]($akka$/akka-cluster-sharding-typed/src/test/scala/doc/akka/cluster/sharding/typed/ShardingCompileOnlySpec.scala) { #persistence }
 
 Sending messages to entities is the same as the example above. The only difference is ow when an entity is moved the state will be restored. 
-See @ref:[persistence](persistence-typed.md) for more details.
+See @ref:[persistence](persistence.md) for more details.
diff --git a/akka-docs/src/main/paradox/cluster-singleton-typed.md b/akka-docs/src/main/paradox/typed/cluster-singleton.md
similarity index 95%
rename from akka-docs/src/main/paradox/cluster-singleton-typed.md
rename to akka-docs/src/main/paradox/typed/cluster-singleton.md
index be3a248ef0..446f6be8f0 100644
--- a/akka-docs/src/main/paradox/cluster-singleton-typed.md
+++ b/akka-docs/src/main/paradox/typed/cluster-singleton.md
@@ -2,7 +2,7 @@
 
 @@@ warning
 
-This module is currently marked as @ref:[may change](common/may-change.md) in the sense
+This module is currently marked as @ref:[may change](../common/may-change.md) in the sense
   of being the subject of active research. This means that API or semantics can
   change without warning or deprecation period and it is not recommended to use
   this module in production just yet—you have been warned.
diff --git a/akka-docs/src/main/paradox/cluster-typed.md b/akka-docs/src/main/paradox/typed/cluster.md
similarity index 95%
rename from akka-docs/src/main/paradox/cluster-typed.md
rename to akka-docs/src/main/paradox/typed/cluster.md
index 5736dc234f..606b89b481 100644
--- a/akka-docs/src/main/paradox/cluster-typed.md
+++ b/akka-docs/src/main/paradox/typed/cluster.md
@@ -2,7 +2,7 @@
 
 @@@ warning
 
-This module is currently marked as @ref:[may change](common/may-change.md) in the sense
+This module is currently marked as @ref:[may change](../common/may-change.md) in the sense
   of being the subject of active research. This means that API or semantics can
   change without warning or deprecation period and it is not recommended to use
   this module in production just yet—you have been warned.
@@ -17,7 +17,7 @@ To use the testkit add the following dependency:
   version=$akka.version$
 }
 
-For an introduction to Akka Cluster concepts see @ref:[Cluster Specification](common/cluster.md). This documentation shows how to use the typed
+For an introduction to Akka Cluster concepts see @ref:[Cluster Specification](../common/cluster.md). This documentation shows how to use the typed
 Cluster API. All of the examples below assume the following imports:
 
 Scala
@@ -77,7 +77,7 @@ Java
 
 Cluster `subscriptions` can be used to receive messages when cluster state changes. For example, registering
 for all `MemberEvent`s, then using the `manager` to have a node leave the cluster will result in events
-for the node going through the lifecycle described in @ref:[Cluster Specification](common/cluster.md).
+for the node going through the lifecycle described in @ref:[Cluster Specification](../common/cluster.md).
 
 This example subscribes with a `TestProbe` but in a real application it would be an Actor:
 
diff --git a/akka-docs/src/main/paradox/coexisting.md b/akka-docs/src/main/paradox/typed/coexisting.md
similarity index 100%
rename from akka-docs/src/main/paradox/coexisting.md
rename to akka-docs/src/main/paradox/typed/coexisting.md
diff --git a/akka-docs/src/main/paradox/fault-tolerance-typed.md b/akka-docs/src/main/paradox/typed/fault-tolerance.md
similarity index 100%
rename from akka-docs/src/main/paradox/fault-tolerance-typed.md
rename to akka-docs/src/main/paradox/typed/fault-tolerance.md
diff --git a/akka-docs/src/main/paradox/interaction-patterns-typed.md b/akka-docs/src/main/paradox/typed/interaction-patterns.md
similarity index 83%
rename from akka-docs/src/main/paradox/interaction-patterns-typed.md
rename to akka-docs/src/main/paradox/typed/interaction-patterns.md
index 7490935ea1..0fd5c2aa01 100644
--- a/akka-docs/src/main/paradox/interaction-patterns-typed.md
+++ b/akka-docs/src/main/paradox/typed/interaction-patterns.md
@@ -148,3 +148,27 @@ TODO
 
  * Children have lifecycles that must be managed to not create a resource leak
  * ???
+ 
+## Scheduling messages to self
+
+The following example demonstrates how to use timers to schedule messages to an actor. 
+
+The `Buncher` actor buffers a burst of incoming messages and delivers them as a batch after a timeout or when the number of batched messages exceeds a maximum size.
+
+Scala
+:  @@snip [InteractionPatternsSpec.scala]($akka$/akka-actor-typed-tests/src/test/scala/docs/akka/typed/InteractionPatternsSpec.scala) { #timer }
+
+Java
+:  @@snip [InteractionPatternsTest.java]($akka$/akka-actor-typed-tests/src/test/java/jdocs/akka/typed/InteractionPatternsTest.java) { #timer }
+
+There are a few things worth noting here:
+
+* To get access to the timers you start with `Behaviors.withTimers` that will pass a `TimerScheduler` instance to the function. This can be used with any type of `Behavior`, such as `immutable` or `mutable`.
+* Each timer has a key and if a new timer with same key is started the previous is cancelled and it's guaranteed that a message from the previous timer is not received, even though it might already be enqueued in the mailbox when the new timer is started.
+* Both periodic and single message timers are supported. 
+* The `TimerScheduler` is mutable in itself, because it performs and manages the side effects of registering the scheduled tasks.
+* The `TimerScheduler` is bound to the lifecycle of the actor that owns it and it's cancelled automatically when the actor is stopped.
+* `Behaviors.withTimers` can also be used inside `Behaviors.supervise` and it will automatically cancel the started timers correctly when the actor is restarted, so that the new incarnation will not receive scheduled messages from previous incarnation.
+
+
+
diff --git a/akka-docs/src/main/paradox/persistence-typed.md b/akka-docs/src/main/paradox/typed/persistence.md
similarity index 95%
rename from akka-docs/src/main/paradox/persistence-typed.md
rename to akka-docs/src/main/paradox/typed/persistence.md
index 44bbd089f8..700ac4ea7b 100644
--- a/akka-docs/src/main/paradox/persistence-typed.md
+++ b/akka-docs/src/main/paradox/typed/persistence.md
@@ -2,7 +2,7 @@
 
 @@@ warning
 
-This module is currently marked as @ref:[may change](common/may-change.md) in the sense
+This module is currently marked as @ref:[may change](../common/may-change.md) in the sense
   of being the subject of active research. This means that API or semantics can
   change without warning or deprecation period and it is not recommended to use
   this module in production just yet—you have been warned.
@@ -27,7 +27,7 @@ To use typed persistence add the following dependency:
 
 
 Akka Persistence is a library for building event sourced actors. For background about how it works
-see the @ref:[untyped Akka Persistence section](persistence.md). This documentation shows how the typed API for persistence
+see the @ref:[untyped Akka Persistence section](../persistence.md). This documentation shows how the typed API for persistence
 works and assumes you know what is meant by `Command`, `Event` and `State`.
 
 Let's start with a simple example. The minimum required for a `PersistentBehavior` is:
@@ -163,10 +163,10 @@ Scala
 
 ## Serialization
 
-The same @ref:[serialization](serialization.md) mechanism as for untyped 
+The same @ref:[serialization](../serialization.md) mechanism as for untyped 
 actors is also used in Akka Typed, also for persistent actors. When picking serialization solution for the events 
 you should also consider that it must be possible read old events when the application has evolved. 
-Strategies for that can be found in the @ref:[schema evolution](persistence-schema-evolution.md).
+Strategies for that can be found in the @ref:[schema evolution](../persistence-schema-evolution.md).
 
 ## Recovery
 
@@ -181,7 +181,7 @@ The `onRecoveryCompleted` takes on an `ActorContext` and the current `State`.
 ## Tagging
 
 Persistence typed allows you to use event tags with the following `withTagging` method,
-without using @ref[`EventAdapter`](persistence.md#event-adapters).
+without using @ref[`EventAdapter`](../persistence.md#event-adapters).
 
 Scala
 :  @@snip [BasicPersistentActorSpec.scala]($akka$/akka-persistence-typed/src/test/scala/docs/akka/persistence/typed/BasicPersistentBehaviorsSpec.scala) { #tagging }
diff --git a/akka-docs/src/main/paradox/testing-typed.md b/akka-docs/src/main/paradox/typed/testing.md
similarity index 98%
rename from akka-docs/src/main/paradox/testing-typed.md
rename to akka-docs/src/main/paradox/typed/testing.md
index a5be16d660..7fe53ae6e6 100644
--- a/akka-docs/src/main/paradox/testing-typed.md
+++ b/akka-docs/src/main/paradox/typed/testing.md
@@ -2,7 +2,7 @@
 
 @@@ warning
 
-This module is currently marked as @ref:[may change](common/may-change.md) in the sense
+This module is currently marked as @ref:[may change](../common/may-change.md) in the sense
   of being the subject of active research. This means that API or semantics can
   change without warning or deprecation period and it is not recommended to use
   this module in production just yet—you have been warned.
