diff --git a/akka-discovery/src/main/scala/akka/discovery/ServiceDiscovery.scala b/akka-discovery/src/main/scala/akka/discovery/ServiceDiscovery.scala
index ef5ab2ed7e..dcd1b745a7 100644
--- a/akka-discovery/src/main/scala/akka/discovery/ServiceDiscovery.scala
+++ b/akka-discovery/src/main/scala/akka/discovery/ServiceDiscovery.scala
@@ -18,6 +18,14 @@ import akka.util.HashCode
 
 object ServiceDiscovery {
 
+  /**
+   * Future returned by resolve(name, timeout) should be failed with this exception
+   * if the underlying mechanism was unable to resolve the name within the given timeout.
+   *
+   * It is up to each implementation to implement timeouts.
+   */
+  final class DiscoveryTimeoutException(reason: String) extends RuntimeException(reason)
+
   object Resolved {
     def apply(serviceName: String, addresses: immutable.Seq[ResolvedTarget]): Resolved =
       new Resolved(serviceName, addresses)
@@ -281,6 +289,7 @@ abstract class ServiceDiscovery {
    *
    * @param lookup       A service discovery lookup.
    * @param resolveTimeout Timeout. Up to the discovery-method to adhere to his
+   * @return Resolved future should be failed with a [DiscoveryTimeoutException] if the `resolveTimeout` is exceeded.
    */
   def lookup(lookup: Lookup, resolveTimeout: FiniteDuration): Future[Resolved]
 
@@ -299,7 +308,7 @@ abstract class ServiceDiscovery {
    * the passed `resolveTimeout` should never be exceeded, as it signals the application's
    * eagerness to wait for a result for this specific lookup.
    *
-   * The returned future SHOULD be failed once resolveTimeout has passed.
+   * The returned future should be failed once resolveTimeout has passed with a [[DiscoveryTimeoutException]].
    *
    */
   def lookup(query: Lookup, resolveTimeout: java.time.Duration): CompletionStage[Resolved] = {
@@ -311,7 +320,8 @@ abstract class ServiceDiscovery {
    * Java API
    *
    * @param serviceName           A name, see discovery-method's docs for how this is interpreted
-   * @param resolveTimeout Timeout. Up to the discovery-methodto adhere to his
+   * @param resolveTimeout Timeout. Up to the discovery-method to adhere to this and complete the CompletionStage with a
+   *                                [DiscoveryTimeoutException]
    */
   def lookup(serviceName: String, resolveTimeout: java.time.Duration): CompletionStage[Resolved] =
     lookup(Lookup(serviceName), resolveTimeout)
diff --git a/akka-discovery/src/main/scala/akka/discovery/dns/DnsServiceDiscovery.scala b/akka-discovery/src/main/scala/akka/discovery/dns/DnsServiceDiscovery.scala
index aee8eaea3b..7af40aff27 100644
--- a/akka-discovery/src/main/scala/akka/discovery/dns/DnsServiceDiscovery.scala
+++ b/akka-discovery/src/main/scala/akka/discovery/dns/DnsServiceDiscovery.scala
@@ -6,6 +6,8 @@ package akka.discovery.dns
 
 import java.net.InetAddress
 
+import akka.actor.ActorRef
+
 import scala.concurrent.duration._
 import akka.actor.ExtendedActorSystem
 import akka.annotation.InternalApi
@@ -25,6 +27,7 @@ import scala.collection.{ immutable => im }
 import scala.util.Failure
 import scala.util.Success
 import akka.io.dns.internal.AsyncDnsManager
+import akka.pattern.AskTimeoutException
 import akka.util.OptionVal
 import akka.util.Timeout
 
@@ -71,12 +74,17 @@ private[akka] class DnsServiceDiscovery(system: ExtendedActorSystem) extends Ser
   import ServiceDiscovery._
 
   private val log = Logging(system, getClass)
-  private val dns = if (system.settings.config.getString("akka.io.dns.resolver") == "async-dns") {
-    log.debug("using system resolver as it is set to async-dns")
-    IO(Dns)(system)
-  } else {
-    log.debug("system resolver is not async-dns. Loading isolated resolver")
-    Dns(system).loadAsyncDns("SD-DNS")
+  private val dns = initializeDns()
+
+  // exposed for testing
+  private[dns] def initializeDns(): ActorRef = {
+    if (system.settings.config.getString("akka.io.dns.resolver") == "async-dns") {
+      log.debug("using system resolver as it is set to async-dns")
+      IO(Dns)(system)
+    } else {
+      log.debug("system resolver is not async-dns. Loading isolated resolver")
+      Dns(system).loadAsyncDns("SD-DNS")
+    }
   }
 
   // updated from ask AsyncDnsManager.GetCache, but doesn't have to volatile since will still work when unset
@@ -110,14 +118,17 @@ private[akka] class DnsServiceDiscovery(system: ExtendedActorSystem) extends Ser
     val mode = Srv
 
     def askResolve(): Future[Resolved] = {
-      dns.ask(DnsProtocol.Resolve(srvRequest, mode))(resolveTimeout).map {
-        case resolved: DnsProtocol.Resolved =>
-          log.debug("{} lookup result: {}", mode, resolved)
-          srvRecordsToResolved(srvRequest, resolved)
-        case resolved =>
-          log.warning("Resolved UNEXPECTED (resolving to Nil): {}", resolved.getClass)
-          Resolved(srvRequest, Nil)
-      }
+      dns
+        .ask(DnsProtocol.Resolve(srvRequest, mode))(resolveTimeout)
+        .map {
+          case resolved: DnsProtocol.Resolved =>
+            log.debug("{} lookup result: {}", mode, resolved)
+            srvRecordsToResolved(srvRequest, resolved)
+          case resolved =>
+            log.warning("Resolved UNEXPECTED (resolving to Nil): {}", resolved.getClass)
+            Resolved(srvRequest, Nil)
+        }
+        .recoverWith(convertToTimeout(resolveTimeout))
     }
 
     asyncDnsCache match {
@@ -135,6 +146,12 @@ private[akka] class DnsServiceDiscovery(system: ExtendedActorSystem) extends Ser
     }
   }
 
+  private def convertToTimeout(timeout: FiniteDuration): PartialFunction[Throwable, Future[Resolved]] = {
+    case _: AskTimeoutException =>
+      import akka.util.PrettyDuration._
+      Future.failed(new DiscoveryTimeoutException(s"Dns resolve did not respond within ${timeout.pretty}"))
+  }
+
   private def lookupIp(lookup: Lookup, resolveTimeout: FiniteDuration) = {
     log.debug("Lookup[{}] translated to A/AAAA lookup as does not have portName and protocol", lookup)
     val mode = Ip()
@@ -148,15 +165,17 @@ private[akka] class DnsServiceDiscovery(system: ExtendedActorSystem) extends Ser
     }
 
     def askResolve(): Future[Resolved] = {
-      dns.ask(DnsProtocol.Resolve(lookup.serviceName, mode))(resolveTimeout).map {
-        case resolved: DnsProtocol.Resolved =>
-          log.debug("{} lookup result: {}", mode, resolved)
-          ipRecordsToResolved(resolved)
-        case resolved =>
-          log.warning("Resolved UNEXPECTED (resolving to Nil): {}", resolved.getClass)
-          Resolved(lookup.serviceName, Nil)
-
-      }
+      dns
+        .ask(DnsProtocol.Resolve(lookup.serviceName, mode))(resolveTimeout)
+        .map {
+          case resolved: DnsProtocol.Resolved =>
+            log.debug("{} lookup result: {}", mode, resolved)
+            ipRecordsToResolved(resolved)
+          case resolved =>
+            log.warning("Resolved UNEXPECTED (resolving to Nil): {}", resolved.getClass)
+            Resolved(lookup.serviceName, Nil)
+        }
+        .recoverWith(convertToTimeout(resolveTimeout))
     }
 
     asyncDnsCache match {
diff --git a/akka-discovery/src/test/scala/akka/discovery/dns/DnsServiceDiscoverySpec.scala b/akka-discovery/src/test/scala/akka/discovery/dns/DnsServiceDiscoverySpec.scala
index 6a77a76576..f3c559607b 100644
--- a/akka-discovery/src/test/scala/akka/discovery/dns/DnsServiceDiscoverySpec.scala
+++ b/akka-discovery/src/test/scala/akka/discovery/dns/DnsServiceDiscoverySpec.scala
@@ -6,16 +6,45 @@ package akka.discovery.dns
 
 import java.net.{ Inet6Address, InetAddress }
 
+import akka.actor.ActorRef
+import akka.actor.ExtendedActorSystem
+import akka.discovery
 import akka.discovery.ServiceDiscovery
+import akka.discovery.ServiceDiscovery.DiscoveryTimeoutException
 import akka.discovery.ServiceDiscovery.{ Resolved, ResolvedTarget }
 import akka.io.dns.CachePolicy.Ttl
 import akka.io.dns.{ AAAARecord, ARecord, DnsProtocol, SRVRecord }
-import org.scalatest.{ Matchers, WordSpec }
+import akka.testkit.AkkaSpec
+import akka.testkit.TestProbe
+import org.scalatest.WordSpecLike
+import org.scalatest.concurrent.ScalaFutures
+import org.scalatest.Matchers
 
 import scala.collection.{ immutable => im }
 import scala.concurrent.duration._
 
-class DnsServiceDiscoverySpec extends WordSpec with Matchers {
+class DnsServiceDiscoverySpec extends AkkaSpec with WordSpecLike with Matchers with ScalaFutures {
+
+  "DnsServiceDiscovery" must {
+    "fail future with DiscoveryTimeoutException if IP dns resolve does not respond" in {
+      val dnsProbe = TestProbe()
+      val underTest = new DnsServiceDiscovery(system.asInstanceOf[ExtendedActorSystem]) {
+        override def initializeDns(): ActorRef = dnsProbe.ref
+      }
+      val result = underTest.lookup("cats.com", 1.second)
+      result.failed.futureValue shouldBe a[DiscoveryTimeoutException]
+    }
+
+    "fail future with DiscoveryTimeoutException if SRV dns resolve does not respond" in {
+      val dnsProbe = TestProbe()
+      val underTest = new DnsServiceDiscovery(system.asInstanceOf[ExtendedActorSystem]) {
+        override def initializeDns(): ActorRef = dnsProbe.ref
+      }
+      val result = underTest.lookup(discovery.Lookup("cats.com").withPortName("dog").withProtocol("snake"), 1.second)
+      result.failed.futureValue shouldBe a[DiscoveryTimeoutException]
+    }
+  }
+
   "srvRecordsToResolved" must {
     "fill in ips from A records" in {
       val resolved = DnsProtocol.Resolved(
@@ -74,5 +103,6 @@ class DnsServiceDiscoverySpec extends WordSpec with Matchers {
         ResolvedTarget("kittens.com", Some(4), Some(InetAddress.getByName("::1"))),
         ResolvedTarget("kittens.com", Some(4), Some(InetAddress.getByName("::2"))))
     }
+
   }
 }
