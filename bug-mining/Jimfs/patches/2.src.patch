diff --git a/jimfs/src/main/java/com/google/common/jimfs/Handler.java b/jimfs/src/main/java/com/google/common/jimfs/Handler.java
new file mode 100644
index 00000000..8772ddae
--- /dev/null
+++ b/jimfs/src/main/java/com/google/common/jimfs/Handler.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.jimfs;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import java.io.IOException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.URLStreamHandler;
+
+/**
+ * {@link URLStreamHandler} implementation for jimfs. Named {@code Handler} so that the class can
+ * be found by Java as described in the documentation for
+ * {@link URL#URL(String, String, int, String) URL}.
+ *
+ * <p>This class is only public because it is necessary for Java to find it. It is not intended
+ * to be used directly.
+ *
+ * @author Colin Decker
+ */
+public final class Handler extends URLStreamHandler {
+
+  private static final String JAVA_PROTOCOL_HANDLER_PACKAGES = "java.protocol.handler.pkgs";
+
+  /**
+   * Registers this handler by adding the package {@code com.google.common} to the system property
+   * {@code "java.protocol.handler.pkgs"}. Java will then look for this class in the {@code jimfs}
+   * (the name of the protocol) package of {@code com.google.common}.
+   *
+   * @throws SecurityException if the system property that needs to be set to register this handler
+   *     can't be read or written.
+   */
+  static void register() {
+    register(Handler.class);
+  }
+
+  /**
+   * Generic method that would allow registration of any properly placed {@code Handler} class.
+   */
+  static void register(Class<? extends URLStreamHandler> handlerClass) {
+    checkArgument("Handler".equals(handlerClass.getSimpleName()));
+
+    String pkg = handlerClass.getPackage().getName();
+    int lastDot = pkg.lastIndexOf('.');
+    checkArgument(lastDot > 0, "package for Handler (%s) must have a parent package", pkg);
+
+    String parentPackage = pkg.substring(0, lastDot);
+
+    String packages = System.getProperty(JAVA_PROTOCOL_HANDLER_PACKAGES);
+    if (packages == null) {
+      packages = parentPackage;
+    } else {
+      packages += "|" + parentPackage;
+    }
+    System.setProperty(JAVA_PROTOCOL_HANDLER_PACKAGES, packages);
+  }
+
+  @Override
+  protected URLConnection openConnection(URL url) throws IOException {
+    return new PathURLConnection(url);
+  }
+}
diff --git a/jimfs/src/main/java/com/google/common/jimfs/JimfsFileSystemProvider.java b/jimfs/src/main/java/com/google/common/jimfs/JimfsFileSystemProvider.java
index 237a9e04..caeb9f6b 100644
--- a/jimfs/src/main/java/com/google/common/jimfs/JimfsFileSystemProvider.java
+++ b/jimfs/src/main/java/com/google/common/jimfs/JimfsFileSystemProvider.java
@@ -71,6 +71,15 @@ import javax.annotation.Nullable;
 @AutoService(FileSystemProvider.class)
 public final class JimfsFileSystemProvider extends FileSystemProvider {
 
+  static {
+    // Register the URL stream handler implementation.
+    try {
+      Handler.register();
+    } catch (SecurityException e) {
+      // Couldn't set the system property needed to register the handler. Nothing we can do really.
+    }
+  }
+
   @Override
   public String getScheme() {
     return URI_SCHEME;
diff --git a/jimfs/src/main/java/com/google/common/jimfs/PathURLConnection.java b/jimfs/src/main/java/com/google/common/jimfs/PathURLConnection.java
new file mode 100644
index 00000000..e0a27d49
--- /dev/null
+++ b/jimfs/src/main/java/com/google/common/jimfs/PathURLConnection.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.jimfs;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+import com.google.common.base.Ascii;
+import com.google.common.base.Joiner;
+import com.google.common.base.MoreObjects;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Multimaps;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.file.DirectoryStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.FileTime;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TimeZone;
+
+/**
+ * {@code URLConnection} implementation.
+ *
+ * @author Colin Decker
+ */
+final class PathURLConnection extends URLConnection {
+
+  /*
+   * This implementation should be able to work for any proper file system implementation... it
+   * might be useful to release it and make it usable by other file systems.
+   */
+
+  private static final String HTTP_DATE_FORMAT = "EEE, dd MMM yyyy HH:mm:ss \'GMT\'";
+  private static final String DEFAULT_CONTENT_TYPE = "application/octet-stream";
+
+  private InputStream stream;
+  private ImmutableListMultimap<String, String> headers = ImmutableListMultimap.of();
+
+  PathURLConnection(URL url) {
+    super(checkNotNull(url));
+  }
+
+  @Override
+  public void connect() throws IOException {
+    if (stream != null) {
+      return;
+    }
+
+    Path path = Paths.get(toUri(url));
+
+    long length;
+    if (Files.isDirectory(path)) {
+      // Match File URL behavior for directories by having the stream contain the filenames in
+      // the directory separated by newlines.
+      StringBuilder builder = new StringBuilder();
+      try (DirectoryStream<Path> files = Files.newDirectoryStream(path)) {
+        for (Path file : files) {
+          builder.append(file.getFileName()).append('\n');
+        }
+      }
+      byte[] bytes = builder.toString().getBytes(UTF_8);
+      stream = new ByteArrayInputStream(bytes);
+      length = bytes.length;
+    } else {
+      stream = Files.newInputStream(path);
+      length = Files.size(path);
+    }
+
+    FileTime lastModified = Files.getLastModifiedTime(path);
+    String contentType = MoreObjects.firstNonNull(
+        Files.probeContentType(path), DEFAULT_CONTENT_TYPE);
+
+    ImmutableListMultimap.Builder<String, String> builder = ImmutableListMultimap.builder();
+    builder.put("content-length", "" + length);
+    builder.put("content-type", contentType);
+    if (lastModified != null) {
+      DateFormat format = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
+      format.setTimeZone(TimeZone.getTimeZone("GMT"));
+      builder.put("last-modified", format.format(new Date(lastModified.toMillis())));
+    }
+
+    headers = builder.build();
+  }
+
+  private static URI toUri(URL url) throws IOException {
+    try {
+      return url.toURI();
+    } catch (URISyntaxException e) {
+      throw new IOException("URL " + url + " cannot be converted to a URI", e);
+    }
+  }
+
+  @Override
+  public InputStream getInputStream() throws IOException {
+    connect();
+    return stream;
+  }
+
+  @SuppressWarnings("unchecked") // safe by specification of ListMultimap.asMap()
+  @Override
+  public Map<String, List<String>> getHeaderFields() {
+    try {
+      connect();
+    } catch (IOException e) {
+      return ImmutableMap.of();
+    }
+    return (ImmutableMap<String, List<String>>) (ImmutableMap<String, ?>) headers.asMap();
+  }
+
+  @Override
+  public String getHeaderField(String name) {
+    try {
+      connect();
+    } catch (IOException e) {
+      return null;
+    }
+
+    // no header should have more than one value
+    return Iterables.getFirst(headers.get(Ascii.toLowerCase(name)), null);
+  }
+}
diff --git a/jimfs/src/test/java/com/google/common/jimfs/UrlTest.java b/jimfs/src/test/java/com/google/common/jimfs/UrlTest.java
new file mode 100644
index 00000000..9b7ce429
--- /dev/null
+++ b/jimfs/src/test/java/com/google/common/jimfs/UrlTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.jimfs;
+
+import static com.google.common.base.StandardSystemProperty.LINE_SEPARATOR;
+import static com.google.common.truth.Truth.assertThat;
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Range;
+import com.google.common.io.Resources;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.file.FileSystem;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.attribute.FileTime;
+
+/**
+ * Tests that {@link URL} instances can be created and used from jimfs URIs.
+ *
+ * @author Colin Decker
+ */
+@RunWith(JUnit4.class)
+public class UrlTest {
+
+  private final FileSystem fs = Jimfs.newFileSystem(Configuration.unix());
+  private Path path = fs.getPath("foo");
+
+  @Test
+  public void creatUrl() throws MalformedURLException {
+    URL url = path.toUri().toURL();
+    assertThat(url).isNotNull();
+  }
+
+  @Test
+  public void readFromUrl() throws IOException {
+    Files.write(path, ImmutableList.of("Hello World"), UTF_8);
+
+    URL url = path.toUri().toURL();
+    assertThat(Resources.asCharSource(url, UTF_8).read())
+        .isEqualTo("Hello World" + LINE_SEPARATOR.value());
+  }
+
+  @Test
+  public void readDirectoryContents() throws IOException {
+    Files.createDirectory(path);
+    Files.createFile(path.resolve("a.txt"));
+    Files.createFile(path.resolve("b.txt"));
+    Files.createDirectory(path.resolve("c"));
+
+    URL url = path.toUri().toURL();
+    assertThat(Resources.asCharSource(url, UTF_8).read())
+        .isEqualTo(""
+            + "a.txt\n"
+            + "b.txt\n"
+            + "c\n");
+  }
+
+  @Test
+  public void headers() throws IOException {
+    byte[] bytes = {1, 2, 3};
+    Files.write(path, bytes);
+    FileTime lastModified = Files.getLastModifiedTime(path);
+
+    URL url = path.toUri().toURL();
+    URLConnection conn = url.openConnection();
+
+    // read header fields directly
+    assertThat(conn.getHeaderFields()).containsEntry("content-length",
+        ImmutableList.of("3"));
+    assertThat(conn.getHeaderFields()).containsEntry("content-type",
+        ImmutableList.of("application/octet-stream"));
+
+    if (lastModified != null) {
+      assertThat(conn.getHeaderFields()).containsKey("last-modified");
+      assertThat(conn.getHeaderFields()).hasSize(3);
+    } else {
+      assertThat(conn.getHeaderFields()).hasSize(2);
+    }
+
+    // use the specific methods for reading the expected headers
+    assertThat(conn.getContentLengthLong()).isEqualTo(Files.size(path));
+    assertThat(conn.getContentType()).isEqualTo("application/octet-stream");
+
+    if (lastModified != null) {
+      // The HTTP date format does not include milliseconds, which means that the last modified time
+      // returned from the connection may not be exactly the same as that of the file system itself.
+      // The difference should less than 1000ms though, and should never be greater.
+      long difference = lastModified.toMillis() - conn.getLastModified();
+      assertThat(difference).isIn(Range.closedOpen(0L, 1000L));
+    } else {
+      assertThat(conn.getLastModified()).isEqualTo(0L);
+    }
+  }
+
+  @Test
+  public void contentType() throws IOException {
+    path = fs.getPath("foo.txt");
+    Files.write(path, ImmutableList.of("Hello World"), UTF_8);
+
+    URL url = path.toUri().toURL();
+    URLConnection conn = url.openConnection();
+
+    // Should be text/plain, but this is entirely dependent on the installed FileTypeDetectors
+    String detectedContentType = Files.probeContentType(path);
+    if (detectedContentType == null) {
+      assertThat(conn.getContentType()).isEqualTo("application/octet-stream");
+    } else {
+      assertThat(conn.getContentType()).isEqualTo(detectedContentType);
+    }
+  }
+}
