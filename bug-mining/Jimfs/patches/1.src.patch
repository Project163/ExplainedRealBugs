diff --git a/jimfs/src/main/java/com/google/jimfs/FileSystemState.java b/jimfs/src/main/java/com/google/jimfs/FileSystemState.java
new file mode 100644
index 00000000..0e42935a
--- /dev/null
+++ b/jimfs/src/main/java/com/google/jimfs/FileSystemState.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright 2013 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.jimfs;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Sets;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.nio.file.ClosedFileSystemException;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Object that manages the open/closed state of a file system, ensuring that all open resources
+ * are closed when the file system is closed and that file system methods throw an exception when
+ * the file system has been closed.
+ *
+ * @author Colin Decker
+ */
+final class FileSystemState implements Closeable {
+
+  private final Set<Closeable> resources = Sets.newConcurrentHashSet();
+  private final Runnable onClose;
+
+  private final AtomicBoolean open = new AtomicBoolean(true);
+
+  /** Count of resources currently in the process of being registered. */
+  private final AtomicInteger registering = new AtomicInteger();
+
+  FileSystemState(Runnable onClose) {
+    this.onClose = checkNotNull(onClose);
+  }
+
+  /**
+   * Returns whether or not the file system is open.
+   */
+  public boolean isOpen() {
+    return open.get();
+  }
+
+  /**
+   * Checks that the file system is open, throwing {@link ClosedFileSystemException} if it is not.
+   */
+  public void checkOpen() {
+    if (!open.get()) {
+      throw new ClosedFileSystemException();
+    }
+  }
+
+  /**
+   * Registers the given resource to be closed when the file system is closed. Should be called
+   * when the resource is opened.
+   */
+  public <C extends Closeable> C register(C resource) {
+    // Initial open check to avoid incrementing registering if we already know it's closed.
+    // This is to prevent any possibility of a weird pathalogical situation where the do/while
+    // loop in close() keeps looping as register() is called repeatedly from multiple threads.
+    checkOpen();
+
+    registering.incrementAndGet();
+    try {
+      // Need to check again after marking registration in progress to avoid a potential race.
+      // (close() could have run completely between the first checkOpen() and
+      // registering.incrementAndGet().)
+      checkOpen();
+      resources.add(resource);
+      return resource;
+    } finally {
+      registering.decrementAndGet();
+    }
+  }
+
+  /**
+   * Unregisters the given resource. Should be called when the resource is closed.
+   */
+  public void unregister(Closeable resource) {
+    resources.remove(resource);
+  }
+
+  /**
+   * Closes the file system, runs the {@code onClose} callback and closes all registered resources.
+   */
+  @Override
+  public void close() throws IOException {
+    if (open.compareAndSet(true, false)) {
+      onClose.run();
+
+      Throwable thrown = null;
+      do {
+        for (Closeable resource : resources) {
+          try {
+            resource.close();
+          } catch (Throwable e) {
+            if (thrown == null) {
+              thrown = e;
+            } else {
+              thrown.addSuppressed(e);
+            }
+          } finally {
+            // ensure the resource is removed even if it doesn't remove itself when closed
+            resources.remove(resource);
+          }
+        }
+
+        // It's possible for a thread registering a resource to register that resource after open
+        // has been set to false and even after we've looped through and closed all the resources.
+        // Since registering must be incremented *before* checking the state of open, however,
+        // when we reach this point in that situation either the register call is still in progress
+        // (registering > 0) or the new resource has been successfully added (resources not empty).
+        // In either case, we just need to repeat the loop until there are no more register calls
+        // in progress (no new calls can start and no resources left to close.
+      } while (registering.get() > 0 || !resources.isEmpty());
+      Throwables.propagateIfPossible(thrown, IOException.class);
+    }
+  }
+}
diff --git a/jimfs/src/main/java/com/google/jimfs/FileSystemView.java b/jimfs/src/main/java/com/google/jimfs/FileSystemView.java
index 42cf8b23..e0a4a6de 100644
--- a/jimfs/src/main/java/com/google/jimfs/FileSystemView.java
+++ b/jimfs/src/main/java/com/google/jimfs/FileSystemView.java
@@ -87,6 +87,13 @@ final class FileSystemView {
     return store == other.store;
   }
 
+  /**
+   * Returns the file system state.
+   */
+  public FileSystemState state() {
+    return store.state();
+  }
+
   /**
    * Returns the path of the working directory at the time this view was created. Does not reflect
    * changes to the path caused by the directory being moved.
@@ -130,7 +137,7 @@ final class FileSystemView {
         .requireDirectory(dir)
         .file();
     FileSystemView view = new FileSystemView(store, file, basePathForStream);
-    JimfsSecureDirectoryStream stream = new JimfsSecureDirectoryStream(view, filter);
+    JimfsSecureDirectoryStream stream = new JimfsSecureDirectoryStream(view, filter, state());
     return store.supportsFeature(Feature.SECURE_DIRECTORY_STREAM)
         ? stream
         : new DowngradedDirectoryStream(stream);
diff --git a/jimfs/src/main/java/com/google/jimfs/JimfsFileChannel.java b/jimfs/src/main/java/com/google/jimfs/JimfsFileChannel.java
index dda44a9e..ae513aab 100644
--- a/jimfs/src/main/java/com/google/jimfs/JimfsFileChannel.java
+++ b/jimfs/src/main/java/com/google/jimfs/JimfsFileChannel.java
@@ -64,6 +64,7 @@ final class JimfsFileChannel extends FileChannel {
   private volatile Thread blockingThread;
 
   private final RegularFile file;
+  private final FileSystemState fileSystemState;
 
   private final boolean read;
   private final boolean write;
@@ -71,11 +72,15 @@ final class JimfsFileChannel extends FileChannel {
 
   private long position;
 
-  public JimfsFileChannel(RegularFile file, Set<OpenOption> options) {
+  public JimfsFileChannel(
+      RegularFile file, Set<OpenOption> options, FileSystemState fileSystemState) {
     this.file = file;
+    this.fileSystemState = fileSystemState;
     this.read = options.contains(READ);
     this.write = options.contains(WRITE);
     this.append = options.contains(APPEND);
+
+    fileSystemState.register(this);
   }
 
   /**
@@ -546,6 +551,7 @@ final class JimfsFileChannel extends FileChannel {
         thread.interrupt();
       }
     } finally {
+      fileSystemState.unregister(this);
       file.closed();
     }
   }
diff --git a/jimfs/src/main/java/com/google/jimfs/JimfsFileStore.java b/jimfs/src/main/java/com/google/jimfs/JimfsFileStore.java
index 53adca85..28bf2ec2 100644
--- a/jimfs/src/main/java/com/google/jimfs/JimfsFileStore.java
+++ b/jimfs/src/main/java/com/google/jimfs/JimfsFileStore.java
@@ -56,17 +56,20 @@ final class JimfsFileStore extends FileStore {
   private final AttributeService attributes;
   private final FileFactory factory;
   private final ImmutableSet<Feature> supportedFeatures;
+  private final FileSystemState state;
 
   private final Lock readLock;
   private final Lock writeLock;
 
   public JimfsFileStore(FileTree tree, FileFactory factory, HeapDisk disk,
-      AttributeService attributes, ImmutableSet<Feature> supportedFeatures) {
+      AttributeService attributes, ImmutableSet<Feature> supportedFeatures,
+      FileSystemState state) {
     this.tree = checkNotNull(tree);
     this.factory = checkNotNull(factory);
     this.disk = checkNotNull(disk);
     this.attributes = checkNotNull(attributes);
     this.supportedFeatures = checkNotNull(supportedFeatures);
+    this.state = checkNotNull(state);
 
     ReadWriteLock lock = new ReentrantReadWriteLock();
     this.readLock = lock.readLock();
@@ -75,6 +78,13 @@ final class JimfsFileStore extends FileStore {
 
   // internal use methods
 
+  /**
+   * Returns the file system state object.
+   */
+  FileSystemState state() {
+    return state;
+  }
+
   /**
    * Returns the read lock for this store.
    */
@@ -93,6 +103,7 @@ final class JimfsFileStore extends FileStore {
    * Returns the names of the root directories in this store.
    */
   ImmutableSortedSet<Name> getRootDirectoryNames() {
+    state.checkOpen();
     return tree.getRootDirectoryNames();
   }
 
@@ -123,6 +134,7 @@ final class JimfsFileStore extends FileStore {
    */
   DirectoryEntry lookUp(File workingDirectory,
       JimfsPath path, Set<? super LinkOption> options) throws IOException {
+    state.checkOpen();
     return tree.lookUp(workingDirectory, path, options);
   }
 
@@ -130,6 +142,7 @@ final class JimfsFileStore extends FileStore {
    * Returns a supplier that creates a new regular file.
    */
   Supplier<RegularFile> regularFileCreator() {
+    state.checkOpen();
     return factory.regularFileCreator();
   }
 
@@ -137,6 +150,7 @@ final class JimfsFileStore extends FileStore {
    * Returns a supplier that creates a new directory.
    */
   Supplier<Directory> directoryCreator() {
+    state.checkOpen();
     return factory.directoryCreator();
   }
 
@@ -144,6 +158,7 @@ final class JimfsFileStore extends FileStore {
    * Returns a supplier that creates a new symbolic link with the given target.
    */
   Supplier<SymbolicLink> symbolicLinkCreator(JimfsPath target) {
+    state.checkOpen();
     return factory.symbolicLinkCreator(target);
   }
 
@@ -163,6 +178,7 @@ final class JimfsFileStore extends FileStore {
    * the given user-provided attributes.
    */
   void setInitialAttributes(File file, FileAttribute<?>... attrs) {
+    state.checkOpen();
     attributes.setInitialAttributes(file, attrs);
   }
 
@@ -172,6 +188,7 @@ final class JimfsFileStore extends FileStore {
    */
   @Nullable
   <V extends FileAttributeView> V getFileAttributeView(FileLookup lookup, Class<V> type) {
+    state.checkOpen();
     return attributes.getFileAttributeView(lookup, type);
   }
 
@@ -179,6 +196,7 @@ final class JimfsFileStore extends FileStore {
    * Returns a map containing the attributes described by the given string mapped to their values.
    */
   ImmutableMap<String, Object> readAttributes(File file, String attributes) {
+    state.checkOpen();
     return this.attributes.readAttributes(file, attributes);
   }
 
@@ -188,6 +206,7 @@ final class JimfsFileStore extends FileStore {
    * @throws UnsupportedOperationException if the given attributes type is not supported
    */
   <A extends BasicFileAttributes> A readAttributes(File file, Class<A> type) {
+    state.checkOpen();
     return attributes.readAttributes(file, type);
   }
 
@@ -195,6 +214,7 @@ final class JimfsFileStore extends FileStore {
    * Sets the given attribute to the given value for the given file.
    */
   void setAttribute(File file, String attribute, Object value) {
+    state.checkOpen();
     // TODO(cgdecker): Change attribute stuff to avoid the sad boolean parameter
     attributes.setAttribute(file, attribute, value, false);
   }
@@ -203,6 +223,7 @@ final class JimfsFileStore extends FileStore {
    * Returns the file attribute views supported by this store.
    */
   ImmutableSet<String> supportedFileAttributeViews() {
+    state.checkOpen();
     return attributes.supportedFileAttributeViews();
   }
 
@@ -225,31 +246,37 @@ final class JimfsFileStore extends FileStore {
 
   @Override
   public long getTotalSpace() throws IOException {
+    state.checkOpen();
     return disk.getTotalSpace();
   }
 
   @Override
   public long getUsableSpace() throws IOException {
+    state.checkOpen();
     return getUnallocatedSpace();
   }
 
   @Override
   public long getUnallocatedSpace() throws IOException {
+    state.checkOpen();
     return disk.getUnallocatedSpace();
   }
 
   @Override
   public boolean supportsFileAttributeView(Class<? extends FileAttributeView> type) {
+    state.checkOpen();
     return attributes.supportsFileAttributeView(type);
   }
 
   @Override
   public boolean supportsFileAttributeView(String name) {
+    state.checkOpen();
     return attributes.supportedFileAttributeViews().contains(name);
   }
 
   @Override
   public <V extends FileStoreAttributeView> V getFileStoreAttributeView(Class<V> type) {
+    state.checkOpen();
     return null; // no supported views
   }
 
diff --git a/jimfs/src/main/java/com/google/jimfs/JimfsFileSystem.java b/jimfs/src/main/java/com/google/jimfs/JimfsFileSystem.java
index 7add92f8..bea8830c 100644
--- a/jimfs/src/main/java/com/google/jimfs/JimfsFileSystem.java
+++ b/jimfs/src/main/java/com/google/jimfs/JimfsFileSystem.java
@@ -176,7 +176,6 @@ final class JimfsFileSystem extends FileSystem {
   private final JimfsFileStore fileStore;
   private final PathService pathService;
 
-  private final ResourceManager resourceManager = new ResourceManager();
   private final UserPrincipalLookupService userLookupService = new UserLookupService(true);
 
   private final FileSystemView defaultView;
@@ -248,6 +247,7 @@ final class JimfsFileSystem extends FileSystem {
 
   @Override
   public ImmutableSet<FileStore> getFileStores() {
+    fileStore.state().checkOpen();
     return ImmutableSet.<FileStore>of(fileStore);
   }
 
@@ -258,6 +258,7 @@ final class JimfsFileSystem extends FileSystem {
 
   @Override
   public JimfsPath getPath(String first, String... more) {
+    fileStore.state().checkOpen();
     return pathService.parsePath(first, more);
   }
 
@@ -265,6 +266,7 @@ final class JimfsFileSystem extends FileSystem {
    * Gets the URI of the given path in this file system.
    */
   public URI toUri(JimfsPath path) {
+    fileStore.state().checkOpen();
     return pathService.toUri(uri, path.toAbsolutePath());
   }
 
@@ -272,24 +274,25 @@ final class JimfsFileSystem extends FileSystem {
    * Converts the given URI into a path in this file system.
    */
   public JimfsPath toPath(URI uri) {
+    fileStore.state().checkOpen();
     return pathService.fromUri(uri);
   }
 
   @Override
   public PathMatcher getPathMatcher(String syntaxAndPattern) {
+    fileStore.state().checkOpen();
     return pathService.createPathMatcher(syntaxAndPattern);
   }
 
   @Override
   public UserPrincipalLookupService getUserPrincipalLookupService() {
+    fileStore.state().checkOpen();
     return userLookupService;
   }
 
   @Override
-  public synchronized WatchService newWatchService() throws IOException {
-    // synchronized for resourceManager to register the watch service so there are no races between
-    // creating a watch service and closing the file system
-    return new PollingWatchService(defaultView, pathService, resourceManager);
+  public WatchService newWatchService() throws IOException {
+    return new PollingWatchService(defaultView, pathService, fileStore.state());
   }
 
   @Nullable
@@ -308,7 +311,7 @@ final class JimfsFileSystem extends FileSystem {
           .build());
 
       // ensure thread pool is closed when file system is closed
-      resourceManager.register(new Closeable() {
+      fileStore.state().register(new Closeable() {
         @Override
         public void close() {
           defaultThreadPool.shutdown();
@@ -328,22 +331,13 @@ final class JimfsFileSystem extends FileSystem {
     return false;
   }
 
-  private boolean open = true;
-
   @Override
-  public synchronized boolean isOpen() {
-    return open;
+  public boolean isOpen() {
+    return fileStore.state().isOpen();
   }
 
   @Override
-  public synchronized void close() throws IOException {
-    if (open) {
-      open = false;
-      try {
-        resourceManager.close();
-      } finally {
-        provider.remove(this);
-      }
-    }
+  public void close() throws IOException {
+    fileStore.state().close();
   }
 }
diff --git a/jimfs/src/main/java/com/google/jimfs/JimfsFileSystemProvider.java b/jimfs/src/main/java/com/google/jimfs/JimfsFileSystemProvider.java
index 9bb23d90..622df099 100644
--- a/jimfs/src/main/java/com/google/jimfs/JimfsFileSystemProvider.java
+++ b/jimfs/src/main/java/com/google/jimfs/JimfsFileSystemProvider.java
@@ -148,10 +148,16 @@ public final class JimfsFileSystemProvider extends FileSystemProvider {
   }
 
   /**
-   * Called when the given file system is closed to remove it from this provider.
+   * Returns a runnable that, when run, removes the file system with the given URI from this
+   * provider.
    */
-  void remove(JimfsFileSystem fileSystem) {
-    fileSystems.remove(fileSystem.getUri());
+  static Runnable removeFileSystemRunnable(final URI uri) {
+    return new Runnable() {
+      @Override
+      public void run() {
+        fileSystems.remove(uri);
+      }
+    };
   }
 
   @Override
@@ -222,8 +228,9 @@ public final class JimfsFileSystemProvider extends FileSystemProvider {
   private JimfsFileChannel newJimfsFileChannel(
       JimfsPath path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {
     ImmutableSet<OpenOption> opts = Options.getOptionsForChannel(options);
-    RegularFile file = getDefaultView(path).getOrCreateRegularFile(path, opts, attrs);
-    return new JimfsFileChannel(file, opts);
+    FileSystemView view = getDefaultView(path);
+    RegularFile file = view.getOrCreateRegularFile(path, opts, attrs);
+    return new JimfsFileChannel(file, opts, view.state());
   }
 
   @Override
@@ -253,9 +260,9 @@ public final class JimfsFileSystemProvider extends FileSystemProvider {
   public InputStream newInputStream(Path path, OpenOption... options) throws IOException {
     JimfsPath checkedPath = checkPath(path);
     ImmutableSet<OpenOption> opts = Options.getOptionsForInputStream(options);
-    RegularFile file = getDefaultView(checkedPath)
-        .getOrCreateRegularFile(checkedPath, opts, NO_ATTRS);
-    return new JimfsInputStream(file);
+    FileSystemView view = getDefaultView(checkedPath);
+    RegularFile file = view.getOrCreateRegularFile(checkedPath, opts, NO_ATTRS);
+    return new JimfsInputStream(file, view.state());
   }
 
   private static final FileAttribute<?>[] NO_ATTRS = {};
@@ -264,9 +271,9 @@ public final class JimfsFileSystemProvider extends FileSystemProvider {
   public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {
     JimfsPath checkedPath = checkPath(path);
     ImmutableSet<OpenOption> opts = Options.getOptionsForOutputStream(options);
-    RegularFile file = getDefaultView(checkedPath)
-        .getOrCreateRegularFile(checkedPath, opts, NO_ATTRS);
-    return new JimfsOutputStream(file, opts.contains(APPEND));
+    FileSystemView view = getDefaultView(checkedPath);
+    RegularFile file = view.getOrCreateRegularFile(checkedPath, opts, NO_ATTRS);
+    return new JimfsOutputStream(file, opts.contains(APPEND), view.state());
   }
 
   @Override
diff --git a/jimfs/src/main/java/com/google/jimfs/JimfsFileSystems.java b/jimfs/src/main/java/com/google/jimfs/JimfsFileSystems.java
index 00ea4936..ce7f1c18 100644
--- a/jimfs/src/main/java/com/google/jimfs/JimfsFileSystems.java
+++ b/jimfs/src/main/java/com/google/jimfs/JimfsFileSystems.java
@@ -37,8 +37,10 @@ final class JimfsFileSystems {
   public static JimfsFileSystem newFileSystem(
       JimfsFileSystemProvider provider, URI uri, Configuration config) throws IOException {
     PathService pathService = new PathService(config);
+    FileSystemState state = new FileSystemState(
+        JimfsFileSystemProvider.removeFileSystemRunnable(uri));
 
-    JimfsFileStore fileStore = createFileStore(config, pathService);
+    JimfsFileStore fileStore = createFileStore(config, pathService, state);
     FileSystemView defaultView = createDefaultView(config, fileStore, pathService);
 
     JimfsFileSystem fileSystem = new JimfsFileSystem(
@@ -52,7 +54,7 @@ final class JimfsFileSystems {
    * Creates the file store for the file system.
    */
   private static JimfsFileStore createFileStore(
-      Configuration config, PathService pathService) {
+      Configuration config, PathService pathService, FileSystemState state) {
     AttributeService attributeService = new AttributeService(config);
 
     // TODO(cgdecker): Make disk values configurable
@@ -76,7 +78,7 @@ final class JimfsFileSystems {
     }
 
     return new JimfsFileStore(
-        new FileTree(roots), fileFactory, disk, attributeService, config.supportedFeatures);
+        new FileTree(roots), fileFactory, disk, attributeService, config.supportedFeatures, state);
   }
 
   /**
@@ -101,4 +103,4 @@ final class JimfsFileSystems {
 
     return new FileSystemView(fileStore, dir, workingDirPath);
   }
-}
\ No newline at end of file
+}
diff --git a/jimfs/src/main/java/com/google/jimfs/JimfsInputStream.java b/jimfs/src/main/java/com/google/jimfs/JimfsInputStream.java
index f132375f..d75dae4a 100644
--- a/jimfs/src/main/java/com/google/jimfs/JimfsInputStream.java
+++ b/jimfs/src/main/java/com/google/jimfs/JimfsInputStream.java
@@ -37,8 +37,12 @@ final class JimfsInputStream extends InputStream {
   private long pos;
   private boolean finished;
 
-  public JimfsInputStream(RegularFile file) {
+  private final FileSystemState fileSystemState;
+
+  public JimfsInputStream(RegularFile file, FileSystemState fileSystemState) {
     this.file = checkNotNull(file);
+    this.fileSystemState = fileSystemState;
+    fileSystemState.register(this);
   }
 
   @Override
@@ -134,6 +138,7 @@ final class JimfsInputStream extends InputStream {
   @Override
   public synchronized void close() throws IOException {
     if (isOpen()) {
+      fileSystemState.unregister(this);
       file.closed();
 
       // file is set to null here and only here
diff --git a/jimfs/src/main/java/com/google/jimfs/JimfsOutputStream.java b/jimfs/src/main/java/com/google/jimfs/JimfsOutputStream.java
index a36906ba..392e3475 100644
--- a/jimfs/src/main/java/com/google/jimfs/JimfsOutputStream.java
+++ b/jimfs/src/main/java/com/google/jimfs/JimfsOutputStream.java
@@ -36,10 +36,13 @@ final class JimfsOutputStream extends OutputStream {
   private long pos;
 
   private final boolean append;
+  private final FileSystemState fileSystemState;
 
-  JimfsOutputStream(RegularFile file, boolean append) {
+  JimfsOutputStream(RegularFile file, boolean append, FileSystemState fileSystemState) {
     this.file = checkNotNull(file);
     this.append = append;
+    this.fileSystemState = fileSystemState;
+    fileSystemState.register(this);
   }
 
   @Override
@@ -101,6 +104,7 @@ final class JimfsOutputStream extends OutputStream {
   @Override
   public synchronized void close() throws IOException {
     if (isOpen()) {
+      fileSystemState.unregister(this);
       file.closed();
 
       // file is set to null here and only here
diff --git a/jimfs/src/main/java/com/google/jimfs/JimfsSecureDirectoryStream.java b/jimfs/src/main/java/com/google/jimfs/JimfsSecureDirectoryStream.java
index 3b9db965..b687f0e8 100644
--- a/jimfs/src/main/java/com/google/jimfs/JimfsSecureDirectoryStream.java
+++ b/jimfs/src/main/java/com/google/jimfs/JimfsSecureDirectoryStream.java
@@ -49,12 +49,17 @@ final class JimfsSecureDirectoryStream implements SecureDirectoryStream<Path> {
 
   private final FileSystemView view;
   private final Filter<? super Path> filter;
+  private final FileSystemState fileSystemState;
+
   private boolean open = true;
   private Iterator<Path> iterator = new DirectoryIterator();
 
-  public JimfsSecureDirectoryStream(FileSystemView view, Filter<? super Path> filter) {
+  public JimfsSecureDirectoryStream(
+      FileSystemView view, Filter<? super Path> filter, FileSystemState fileSystemState) {
     this.view = checkNotNull(view);
     this.filter = checkNotNull(filter);
+    this.fileSystemState = fileSystemState;
+    fileSystemState.register(this);
   }
 
   private JimfsPath path() {
@@ -73,6 +78,7 @@ final class JimfsSecureDirectoryStream implements SecureDirectoryStream<Path> {
   @Override
   public synchronized void close() {
     open = false;
+    fileSystemState.unregister(this);
   }
 
   protected synchronized void checkOpen() {
@@ -140,7 +146,8 @@ final class JimfsSecureDirectoryStream implements SecureDirectoryStream<Path> {
     checkOpen();
     JimfsPath checkedPath = checkPath(path);
     ImmutableSet<OpenOption> opts = Options.getOptionsForChannel(options);
-    return new JimfsFileChannel(view.getOrCreateRegularFile(checkedPath, opts), opts);
+    return new JimfsFileChannel(
+        view.getOrCreateRegularFile(checkedPath, opts), opts, fileSystemState);
   }
 
   @Override
diff --git a/jimfs/src/main/java/com/google/jimfs/PollingWatchService.java b/jimfs/src/main/java/com/google/jimfs/PollingWatchService.java
index 2f990bb5..f1514c2d 100644
--- a/jimfs/src/main/java/com/google/jimfs/PollingWatchService.java
+++ b/jimfs/src/main/java/com/google/jimfs/PollingWatchService.java
@@ -44,8 +44,6 @@ import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 
-import javax.annotation.Nullable;
-
 /**
  * Implementation of {@link WatchService} that polls for changes to directories at registered paths.
  *
@@ -72,7 +70,7 @@ final class PollingWatchService extends AbstractWatchService {
 
   private final FileSystemView view;
   private final PathService pathService;
-  private final ResourceManager resourceManager;
+  private final FileSystemState fileSystemState;
 
   private final long pollingTime;
   private final TimeUnit timeUnit;
@@ -80,24 +78,24 @@ final class PollingWatchService extends AbstractWatchService {
   private ScheduledFuture<?> pollingFuture;
 
   public PollingWatchService(
-      FileSystemView view, PathService pathService, ResourceManager resourceManager) {
-    this(view, pathService, resourceManager, 5, SECONDS);
+      FileSystemView view, PathService pathService, FileSystemState fileSystemState) {
+    this(view, pathService, fileSystemState, 5, SECONDS);
   }
 
   // TODO(cgdecker): make user configurable somehow? meh
   @VisibleForTesting
   PollingWatchService(
-      FileSystemView view, PathService pathService, ResourceManager resourceManager,
+      FileSystemView view, PathService pathService, FileSystemState fileSystemState,
       long pollingTime, TimeUnit timeUnit) {
     this.view = checkNotNull(view);
     this.pathService = checkNotNull(pathService);
-    this.resourceManager = checkNotNull(resourceManager);
+    this.fileSystemState = checkNotNull(fileSystemState);
 
     checkArgument(pollingTime >= 0, "polling time (%s) may not be negative", pollingTime);
     this.pollingTime = pollingTime;
     this.timeUnit = checkNotNull(timeUnit);
 
-    resourceManager.register(this);
+    fileSystemState.register(this);
   }
 
   @Override
@@ -161,7 +159,7 @@ final class PollingWatchService extends AbstractWatchService {
       }
 
       pollingService.shutdown();
-      resourceManager.unregister(this);
+      fileSystemState.unregister(this);
     }
   }
 
@@ -201,7 +199,6 @@ final class PollingWatchService extends AbstractWatchService {
     }
   };
 
-  @Nullable
   private Snapshot takeSnapshot(JimfsPath path) throws IOException {
     return new Snapshot(view.snapshotModifiedTimes(path));
   }
diff --git a/jimfs/src/main/java/com/google/jimfs/RegularFile.java b/jimfs/src/main/java/com/google/jimfs/RegularFile.java
index 7770f6d0..9ba6f707 100644
--- a/jimfs/src/main/java/com/google/jimfs/RegularFile.java
+++ b/jimfs/src/main/java/com/google/jimfs/RegularFile.java
@@ -34,8 +34,6 @@ import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
-import javax.annotation.Nullable;
-
 /**
  * A mutable, resizable store for bytes. Bytes are stored in fixed-sized byte arrays (blocks)
  * allocated by a {@link HeapDisk}.
diff --git a/jimfs/src/main/java/com/google/jimfs/ResourceManager.java b/jimfs/src/main/java/com/google/jimfs/ResourceManager.java
deleted file mode 100644
index 1dbe77bb..00000000
--- a/jimfs/src/main/java/com/google/jimfs/ResourceManager.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright 2013 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.jimfs;
-
-import com.google.common.base.Throwables;
-import com.google.common.collect.Sets;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.Set;
-
-/**
- * Manages a set of open resources, ensuring they're closed when this is closed.
- *
- * @author Colin Decker
- */
-final class ResourceManager implements Closeable {
-
-  // TODO(cgdecker): Give this full responsibility for closing a FileSystem and a different name.
-
-  private final Set<Closeable> resources = Sets.newConcurrentHashSet();
-
-  /**
-   * Registers the given resource to be closed when this manager is closed. Should be called when
-   * the resource is opened.
-   */
-  public <C extends Closeable> C register(C resource) {
-    resources.add(resource);
-    return resource;
-  }
-
-  /**
-   * Unregisters this resource. Should be called when the resource is closed.
-   */
-  public void unregister(Closeable resource) {
-    resources.remove(resource);
-  }
-
-  @Override
-  public void close() throws IOException {
-    Throwable thrown = null;
-    for (Closeable resource : resources) {
-      try {
-        resource.close();
-      } catch (Throwable e) {
-        if (thrown == null) {
-          thrown = e;
-        } else {
-          thrown.addSuppressed(e);
-        }
-      }
-    }
-
-    Throwables.propagateIfPossible(thrown, IOException.class);
-  }
-}
diff --git a/jimfs/src/main/java/com/google/jimfs/SymbolicLink.java b/jimfs/src/main/java/com/google/jimfs/SymbolicLink.java
index cc8ed068..7bf057b6 100644
--- a/jimfs/src/main/java/com/google/jimfs/SymbolicLink.java
+++ b/jimfs/src/main/java/com/google/jimfs/SymbolicLink.java
@@ -18,8 +18,6 @@ package com.google.jimfs;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import java.io.IOException;
-
 /**
  * A symbolic link file, containing a {@linkplain JimfsPath path}.
  *
diff --git a/jimfs/src/test/java/com/google/jimfs/FileSystemStateTest.java b/jimfs/src/test/java/com/google/jimfs/FileSystemStateTest.java
new file mode 100644
index 00000000..312c16a7
--- /dev/null
+++ b/jimfs/src/test/java/com/google/jimfs/FileSystemStateTest.java
@@ -0,0 +1,180 @@
+/*
+ * Copyright 2013 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.jimfs;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.nio.file.ClosedFileSystemException;
+import java.util.List;
+
+/**
+ * Tests for {@link FileSystemState}.
+ *
+ * @author Colin Decker
+ */
+@RunWith(JUnit4.class)
+public class FileSystemStateTest {
+
+  private final TestRunnable onClose = new TestRunnable();
+  private final FileSystemState state = new FileSystemState(onClose);
+
+  @Test
+  public void testIsOpen() throws IOException {
+    assertTrue(state.isOpen());
+    state.close();
+    assertFalse(state.isOpen());
+  }
+
+  @Test
+  public void testCheckOpen() throws IOException {
+    state.checkOpen(); // does not throw
+    state.close();
+    try {
+      state.checkOpen();
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+  }
+
+  @Test
+  public void testClose_callsOnCloseRunnable() throws IOException {
+    assertEquals(0, onClose.runCount);
+    state.close();
+    assertEquals(1, onClose.runCount);
+  }
+
+  @Test
+  public void testClose_multipleTimesDoNothing() throws IOException {
+    state.close();
+    assertEquals(1, onClose.runCount);
+    state.close();
+    state.close();
+    assertEquals(1, onClose.runCount);
+  }
+
+  @Test
+  public void testClose_registeredResourceIsClosed() throws IOException {
+    TestCloseable resource = new TestCloseable();
+    state.register(resource);
+    assertFalse(resource.closed);
+    state.close();
+    assertTrue(resource.closed);
+  }
+
+  @Test
+  public void testClose_unregisteredResourceIsNotClosed() throws IOException {
+    TestCloseable resource = new TestCloseable();
+    state.register(resource);
+    assertFalse(resource.closed);
+    state.unregister(resource);
+    state.close();
+    assertFalse(resource.closed);
+  }
+
+  @Test
+  public void testClose_multipleRegisteredResourcesAreClosed() throws IOException {
+    List<TestCloseable> resources = ImmutableList.of(
+        new TestCloseable(), new TestCloseable(), new TestCloseable());
+    for (TestCloseable resource : resources) {
+      state.register(resource);
+      assertFalse(resource.closed);
+    }
+    state.close();
+    for (TestCloseable resource : resources) {
+      assertTrue(resource.closed);
+    }
+  }
+
+  @Test
+  public void testClose_resourcesThatThrowOnClose() {
+    List<TestCloseable> resources = ImmutableList.of(
+        new TestCloseable(),
+        new ThrowsOnClose("a"),
+        new TestCloseable(),
+        new ThrowsOnClose("b"),
+        new ThrowsOnClose("c"),
+        new TestCloseable(),
+        new TestCloseable());
+    for (TestCloseable resource : resources) {
+      state.register(resource);
+      assertFalse(resource.closed);
+    }
+
+    try {
+      state.close();
+      fail();
+    } catch (IOException expected) {
+      Throwable[] suppressed = expected.getSuppressed();
+      assertEquals(2, suppressed.length);
+      ImmutableSet<String> messages = ImmutableSet.of(
+          expected.getMessage(),
+          suppressed[0].getMessage(),
+          suppressed[1].getMessage());
+      assertEquals(ImmutableSet.of("a", "b", "c"), messages);
+    }
+
+    for (TestCloseable resource : resources) {
+      assertTrue(resource.closed);
+    }
+  }
+
+  private static class TestCloseable implements Closeable {
+
+    boolean closed = false;
+
+    @Override
+    public void close() throws IOException {
+      closed = true;
+    }
+  }
+
+  private static final class TestRunnable implements Runnable {
+    int runCount = 0;
+
+    @Override
+    public void run() {
+      runCount++;
+    }
+  }
+
+  private static class ThrowsOnClose extends TestCloseable {
+
+    private final String string;
+
+    private ThrowsOnClose(String string) {
+      this.string = string;
+    }
+
+    @Override
+    public void close() throws IOException {
+      super.close();
+      throw new IOException(string);
+    }
+  }
+}
diff --git a/jimfs/src/test/java/com/google/jimfs/JimfsAsynchronousFileChannelTest.java b/jimfs/src/test/java/com/google/jimfs/JimfsAsynchronousFileChannelTest.java
index cabe662a..6ee174aa 100644
--- a/jimfs/src/test/java/com/google/jimfs/JimfsAsynchronousFileChannelTest.java
+++ b/jimfs/src/test/java/com/google/jimfs/JimfsAsynchronousFileChannelTest.java
@@ -29,6 +29,7 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Runnables;
 import com.google.common.util.concurrent.Uninterruptibles;
 
 import org.junit.Test;
@@ -62,9 +63,10 @@ public class JimfsAsynchronousFileChannelTest {
 
   private static JimfsAsynchronousFileChannel channel(
       RegularFile file, ExecutorService executor, OpenOption... options) throws IOException {
-    return new JimfsAsynchronousFileChannel(
-        new JimfsFileChannel(file,
-            Options.getOptionsForChannel(ImmutableSet.copyOf(options))), executor);
+    JimfsFileChannel channel = new JimfsFileChannel(file,
+        Options.getOptionsForChannel(ImmutableSet.copyOf(options)),
+        new FileSystemState(Runnables.doNothing()));
+    return new JimfsAsynchronousFileChannel(channel, executor);
   }
 
   /**
diff --git a/jimfs/src/test/java/com/google/jimfs/JimfsFileChannelTest.java b/jimfs/src/test/java/com/google/jimfs/JimfsFileChannelTest.java
index 49a96839..aa4443f7 100644
--- a/jimfs/src/test/java/com/google/jimfs/JimfsFileChannelTest.java
+++ b/jimfs/src/test/java/com/google/jimfs/JimfsFileChannelTest.java
@@ -33,6 +33,7 @@ import static org.junit.Assert.fail;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.testing.NullPointerTester;
+import com.google.common.util.concurrent.Runnables;
 import com.google.common.util.concurrent.Uninterruptibles;
 
 import org.junit.Test;
@@ -73,7 +74,8 @@ public class JimfsFileChannelTest {
   private static FileChannel channel(RegularFile file, OpenOption... options)
       throws IOException {
     return new JimfsFileChannel(file,
-        Options.getOptionsForChannel(ImmutableSet.copyOf(options)));
+        Options.getOptionsForChannel(ImmutableSet.copyOf(options)),
+        new FileSystemState(Runnables.doNothing()));
   }
 
   @Test
@@ -226,7 +228,8 @@ public class JimfsFileChannelTest {
   @Test
   public void testFileTimeUpdates() throws IOException {
     RegularFile file = regularFile(10);
-    FileChannel channel = new JimfsFileChannel(file, ImmutableSet.<OpenOption>of(READ, WRITE));
+    FileChannel channel = new JimfsFileChannel(file, ImmutableSet.<OpenOption>of(READ, WRITE),
+        new FileSystemState(Runnables.doNothing()));
 
     // accessed
     long accessTime = file.getLastAccessTime();
diff --git a/jimfs/src/test/java/com/google/jimfs/JimfsFileSystemCloseTest.java b/jimfs/src/test/java/com/google/jimfs/JimfsFileSystemCloseTest.java
new file mode 100644
index 00000000..88ed9dc0
--- /dev/null
+++ b/jimfs/src/test/java/com/google/jimfs/JimfsFileSystemCloseTest.java
@@ -0,0 +1,440 @@
+/*
+ * Copyright 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.jimfs;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.nio.file.StandardOpenOption.CREATE;
+import static java.nio.file.StandardOpenOption.READ;
+import static java.nio.file.StandardOpenOption.WRITE;
+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import com.google.common.collect.ImmutableList;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URI;
+import java.nio.channels.AsynchronousFileChannel;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.FileChannel;
+import java.nio.channels.SeekableByteChannel;
+import java.nio.file.ClosedDirectoryStreamException;
+import java.nio.file.ClosedFileSystemException;
+import java.nio.file.ClosedWatchServiceException;
+import java.nio.file.DirectoryStream;
+import java.nio.file.FileSystemNotFoundException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.WatchService;
+import java.nio.file.attribute.BasicFileAttributeView;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.nio.file.attribute.FileTime;
+import java.nio.file.spi.FileSystemProvider;
+
+/**
+ * Tests for what happens when a file system is closed.
+ *
+ * @author Colin Decker
+ */
+@RunWith(JUnit4.class)
+public class JimfsFileSystemCloseTest {
+
+  private JimfsFileSystem fs = (JimfsFileSystem) Jimfs.newFileSystem(Configuration.unix());
+
+  @Test
+  public void testIsNotOpen() throws IOException {
+    assertTrue(fs.isOpen());
+    fs.close();
+    assertFalse(fs.isOpen());
+  }
+
+  @Test
+  public void testIsNotAvailableFromProvider() throws IOException {
+    FileSystemProvider provider = fs.provider();
+    URI uri = fs.getUri();
+    assertEquals(fs, provider.getFileSystem(uri));
+
+    fs.close();
+
+    try {
+      provider.getFileSystem(uri);
+      fail();
+    } catch (FileSystemNotFoundException expected) {
+    }
+  }
+
+  @Test
+  public void testOpenStreamsClosed() throws IOException {
+    Path p = fs.getPath("/foo");
+    OutputStream out = Files.newOutputStream(p);
+    InputStream in = Files.newInputStream(p);
+
+    out.write(1);
+    assertEquals(1, in.read());
+
+    fs.close();
+
+    try {
+      out.write(1);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream is closed", expected.getMessage());
+    }
+
+    try {
+      in.read();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream is closed", expected.getMessage());
+    }
+  }
+
+  @Test
+  public void testOpenChannelsClosed() throws IOException {
+    Path p = fs.getPath("/foo");
+    FileChannel fc = FileChannel.open(p, READ, WRITE, CREATE);
+    SeekableByteChannel sbc = Files.newByteChannel(p, READ);
+    AsynchronousFileChannel afc = AsynchronousFileChannel.open(p, READ, WRITE);
+
+    assertTrue(fc.isOpen());
+    assertTrue(sbc.isOpen());
+    assertTrue(afc.isOpen());
+
+    fs.close();
+
+    assertFalse(fc.isOpen());
+    assertFalse(sbc.isOpen());
+    assertFalse(afc.isOpen());
+
+    try {
+      fc.size();
+      fail();
+    } catch (ClosedChannelException expected) {
+    }
+
+    try {
+      sbc.size();
+      fail();
+    } catch (ClosedChannelException expected) {
+    }
+
+    try {
+      afc.size();
+      fail();
+    } catch (ClosedChannelException expected) {
+    }
+  }
+
+  @Test
+  public void testOpenDirectoryStreamsClosed() throws IOException {
+    Path p = fs.getPath("/foo");
+    Files.createDirectory(p);
+
+    DirectoryStream<Path> stream = Files.newDirectoryStream(p);
+
+    fs.close();
+
+    try {
+      stream.iterator();
+      fail();
+    } catch (ClosedDirectoryStreamException expected) {
+    }
+  }
+
+  @Test
+  public void testOpenWatchServicesClosed() throws IOException {
+    WatchService ws1 = fs.newWatchService();
+    WatchService ws2 = fs.newWatchService();
+
+    assertNull(ws1.poll());
+    assertNull(ws2.poll());
+
+    fs.close();
+
+    try {
+      ws1.poll();
+      fail();
+    } catch (ClosedWatchServiceException expected) {
+    }
+
+    try {
+      ws2.poll();
+      fail();
+    } catch (ClosedWatchServiceException expected) {
+    }
+  }
+
+  @Test
+  public void testPathMethodsThrow() throws IOException {
+    Path p = fs.getPath("/foo");
+    Files.createDirectory(p);
+
+    WatchService ws = fs.newWatchService();
+
+    fs.close();
+
+    try {
+      p.register(ws, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);
+      fail();
+    } catch (ClosedWatchServiceException expected) {
+    }
+
+    try {
+      p.toRealPath();
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    // While technically (according to the FileSystem.close() spec) all methods on Path should
+    // probably throw, we only throw for methods that access the file system itself in some way...
+    // path manipulation methods seem totally harmless to keep working, and I don't see any need to
+    // add the overhead of checking that the file system is open for each of those method calls.
+  }
+
+  @Test
+  public void testOpenFileAttributeViewsThrow() throws IOException {
+    Path p = fs.getPath("/foo");
+    Files.createFile(p);
+
+    BasicFileAttributeView view = Files.getFileAttributeView(p, BasicFileAttributeView.class);
+
+    fs.close();
+
+    try {
+      view.readAttributes();
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      view.setTimes(null, null, null);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+  }
+
+  @Test
+  public void testFileSystemMethodsThrow() throws IOException {
+    fs.close();
+
+    try {
+      fs.getPath("/foo");
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      fs.getRootDirectories();
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      fs.getFileStores();
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      fs.getPathMatcher("glob:*.java");
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      fs.getUserPrincipalLookupService();
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      fs.newWatchService();
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      fs.supportedFileAttributeViews();
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+  }
+
+  @Test
+  public void testFilesMethodsThrow() throws IOException {
+    Path file = fs.getPath("/file");
+    Path dir = fs.getPath("/dir");
+    Path nothing = fs.getPath("/nothing");
+
+    Files.createDirectory(dir);
+    Files.createFile(file);
+
+    fs.close();
+
+    // not exhaustive, but should cover every major type of functionality accessible through Files
+    // TODO(cgdecker): reflectively invoke all methods with default arguments?
+
+    try {
+      Files.delete(file);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.createDirectory(nothing);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.createFile(nothing);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.write(nothing, ImmutableList.of("hello world"), UTF_8);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.newInputStream(file);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.newOutputStream(file);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.newByteChannel(file);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.newDirectoryStream(dir);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.copy(file, nothing);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.move(file, nothing);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.copy(dir, nothing);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.move(dir, nothing);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.createSymbolicLink(nothing, file);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.createLink(nothing, file);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.exists(file);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.getAttribute(file, "size");
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.setAttribute(file, "lastModifiedTime", FileTime.fromMillis(0));
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.getFileAttributeView(file, BasicFileAttributeView.class);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.readAttributes(file, "basic:size,lastModifiedTime");
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.readAttributes(file, BasicFileAttributes.class);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.isDirectory(dir);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.readAllBytes(file);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+
+    try {
+      Files.isReadable(file);
+      fail();
+    } catch (ClosedFileSystemException expected) {
+    }
+  }
+}
diff --git a/jimfs/src/test/java/com/google/jimfs/JimfsInputStreamTest.java b/jimfs/src/test/java/com/google/jimfs/JimfsInputStreamTest.java
index efb78d21..15d958c9 100644
--- a/jimfs/src/test/java/com/google/jimfs/JimfsInputStreamTest.java
+++ b/jimfs/src/test/java/com/google/jimfs/JimfsInputStreamTest.java
@@ -22,6 +22,8 @@ import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.fail;
 import static org.truth0.Truth.ASSERT;
 
+import com.google.common.util.concurrent.Runnables;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -227,7 +229,7 @@ public class JimfsInputStreamTest {
 
     RegularFile file = regularFile(0);
     file.write(0, b, 0, b.length);
-    return new JimfsInputStream(file);
+    return new JimfsInputStream(file, new FileSystemState(Runnables.doNothing()));
   }
 
   private static void assertEmpty(JimfsInputStream in) throws IOException {
diff --git a/jimfs/src/test/java/com/google/jimfs/JimfsOutputStreamTest.java b/jimfs/src/test/java/com/google/jimfs/JimfsOutputStreamTest.java
index dfd7648f..26c6e9fc 100644
--- a/jimfs/src/test/java/com/google/jimfs/JimfsOutputStreamTest.java
+++ b/jimfs/src/test/java/com/google/jimfs/JimfsOutputStreamTest.java
@@ -21,6 +21,8 @@ import static com.google.jimfs.TestUtils.regularFile;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.fail;
 
+import com.google.common.util.concurrent.Runnables;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -167,7 +169,7 @@ public class JimfsOutputStreamTest {
 
   private static JimfsOutputStream newOutputStream(boolean append) {
     RegularFile file = regularFile(0);
-    return new JimfsOutputStream(file, append);
+    return new JimfsOutputStream(file, append, new FileSystemState(Runnables.doNothing()));
   }
 
   private static void addBytesToStore(JimfsOutputStream out, int... bytes) throws IOException {
diff --git a/jimfs/src/test/java/com/google/jimfs/PathSubject.java b/jimfs/src/test/java/com/google/jimfs/PathSubject.java
index 35b6c2d7..8d85542a 100644
--- a/jimfs/src/test/java/com/google/jimfs/PathSubject.java
+++ b/jimfs/src/test/java/com/google/jimfs/PathSubject.java
@@ -156,7 +156,7 @@ public final class PathSubject extends Subject<PathSubject, Path> {
     }
 
     if (!builder.build().equals(ImmutableList.copyOf(names))) {
-      fail("has name components", names);
+      fail("has name components", (Object[]) names);
     }
     return this;
   }
@@ -328,7 +328,7 @@ public final class PathSubject extends Subject<PathSubject, Path> {
       }
 
       if (!actualNames.equals(expectedNames)) {
-        fail("has children", children);
+        fail("has children", (Object[]) children);
       }
     }
     return this;
diff --git a/jimfs/src/test/java/com/google/jimfs/PathTypeTest.java b/jimfs/src/test/java/com/google/jimfs/PathTypeTest.java
index 2dffeabf..e4728b93 100644
--- a/jimfs/src/test/java/com/google/jimfs/PathTypeTest.java
+++ b/jimfs/src/test/java/com/google/jimfs/PathTypeTest.java
@@ -96,7 +96,7 @@ public class PathTypeTest {
   static void assertParseResult(
       ParseResult result, @Nullable String root, String... names) {
     ASSERT.that(result.root()).is(root);
-    ASSERT.that(result.names()).iteratesAs(names);
+    ASSERT.that(result.names()).iteratesAs((Object[]) names);
   }
 
   static void assertUriRoundTripsCorrectly(PathType type, String path) {
diff --git a/jimfs/src/test/java/com/google/jimfs/PollingWatchServiceTest.java b/jimfs/src/test/java/com/google/jimfs/PollingWatchServiceTest.java
index a771d50c..836dbeca 100644
--- a/jimfs/src/test/java/com/google/jimfs/PollingWatchServiceTest.java
+++ b/jimfs/src/test/java/com/google/jimfs/PollingWatchServiceTest.java
@@ -24,6 +24,7 @@ import static org.junit.Assert.fail;
 import static org.truth0.Truth.ASSERT;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.Runnables;
 import com.google.common.util.concurrent.Uninterruptibles;
 import com.google.jimfs.AbstractWatchService.Event;
 import com.google.jimfs.AbstractWatchService.Key;
@@ -60,7 +61,7 @@ public class PollingWatchServiceTest {
   public void setUp() {
     fs = (JimfsFileSystem) Jimfs.newFileSystem(Configuration.unix());
     watcher = new PollingWatchService(fs.getDefaultView(),
-        fs.getPathService(), new ResourceManager(), 4, MILLISECONDS);
+        fs.getPathService(), new FileSystemState(Runnables.doNothing()), 4, MILLISECONDS);
   }
 
   @After
diff --git a/jimfs/src/test/java/com/google/jimfs/ResourceManagerTest.java b/jimfs/src/test/java/com/google/jimfs/ResourceManagerTest.java
deleted file mode 100644
index 827127c6..00000000
--- a/jimfs/src/test/java/com/google/jimfs/ResourceManagerTest.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright 2013 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.jimfs;
-
-import static org.junit.Assert.fail;
-import static org.truth0.Truth.ASSERT;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-/**
- * Tests for {@link ResourceManager}.
- *
- * @author Colin Decker
- */
-@RunWith(JUnit4.class)
-public class ResourceManagerTest {
-
-  @Test
-  public void testResourceManager() {
-    ResourceManager resourceManager = new ResourceManager();
-    List<TestCloseable> resources = new ArrayList<>();
-    resources.add(resourceManager.register(new TestCloseable()));
-    resources.add(resourceManager.register(new TestCloseable()));
-    resources.add(resourceManager.register(new ThrowsOnClose("a")));
-    TestCloseable toUnregister = resourceManager.register(new TestCloseable());
-    resources.add(resourceManager.register(new ThrowsOnClose("b")));
-    resources.add(resourceManager.register(new TestCloseable()));
-    resources.add(resourceManager.register(new ThrowsOnClose("c")));
-
-    for (TestCloseable resource : resources) {
-      ASSERT.that(resource.closed).isFalse();
-    }
-    ASSERT.that(toUnregister.closed).isFalse();
-
-    resourceManager.unregister(toUnregister);
-
-    try {
-      resourceManager.close();
-      fail();
-    } catch (IOException expected) {
-      ASSERT.that(expected.getSuppressed().length).is(2);
-
-      Set<String> exceptionMessages = new HashSet<>();
-      exceptionMessages.add(expected.getMessage());
-      for (Throwable suppressed : expected.getSuppressed()) {
-        exceptionMessages.add(suppressed.getMessage());
-      }
-      ASSERT.that(exceptionMessages).has().exactly("a", "b", "c");
-    }
-
-    for (TestCloseable resource : resources) {
-      ASSERT.that(resource.closed).isTrue();
-    }
-    ASSERT.that(toUnregister.closed).isFalse();
-  }
-
-  private static class TestCloseable implements Closeable {
-
-    boolean closed = false;
-
-    @Override
-    public void close() throws IOException {
-      closed = true;
-    }
-  }
-
-  private static class ThrowsOnClose extends TestCloseable {
-
-    private final String string;
-
-    private ThrowsOnClose(String string) {
-      this.string = string;
-    }
-
-    @Override
-    public void close() throws IOException {
-      super.close();
-      throw new IOException(string);
-    }
-  }
-}
