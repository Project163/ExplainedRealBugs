diff --git a/src/main/java/org/semux/api/util/TransactionBuilder.java b/src/main/java/org/semux/api/util/TransactionBuilder.java
index 5bcfa888..99e210a4 100644
--- a/src/main/java/org/semux/api/util/TransactionBuilder.java
+++ b/src/main/java/org/semux/api/util/TransactionBuilder.java
@@ -156,29 +156,14 @@ public class TransactionBuilder {
         return this;
     }
 
+    // value is optional
     public TransactionBuilder withValue(String value) {
-        if (type == TransactionType.DELEGATE) {
-            if (value != null && !value.isEmpty()) {
-                throw new IllegalArgumentException("Parameter `value` is not needed for DELEGATE transaction");
-            }
-            return this; // ignore the provided parameter
-        }
-
-        if (type == TransactionType.CREATE) {
-            if (value != null && !value.isEmpty()) {
-                throw new IllegalArgumentException("Parameter `value` is not needed for CREATE transaction");
-            }
-            return this; // ignore the provided parameter
-        }
-
         if (value == null) {
-            throw new IllegalArgumentException("Parameter `value` is required");
-        }
-
-        try {
-            this.value = NANO_SEM.of(Long.parseLong(value));
-        } catch (NumberFormatException e) {
-            throw new IllegalArgumentException("Parameter `value` is not a valid number");
+            try {
+                this.value = NANO_SEM.of(Long.parseLong(value));
+            } catch (NumberFormatException e) {
+                throw new IllegalArgumentException("Parameter `value` is not a valid number");
+            }
         }
 
         return this;
@@ -270,7 +255,7 @@ public class TransactionBuilder {
                 network != null ? network : kernel.getConfig().network(),
                 type,
                 to,
-                value,
+                value != null ? value : Amount.ZERO,
                 fee,
                 nonce != null ? nonce : kernel.getPendingManager().getNonce(account.toAddress()),
                 timestamp != null ? timestamp : TimeUtil.currentTimeMillis(),
diff --git a/src/main/java/org/semux/core/PendingManager.java b/src/main/java/org/semux/core/PendingManager.java
index f1652b78..821e5092 100644
--- a/src/main/java/org/semux/core/PendingManager.java
+++ b/src/main/java/org/semux/core/PendingManager.java
@@ -28,6 +28,7 @@ import org.semux.net.msg.p2p.TransactionMessage;
 import org.semux.util.ArrayUtil;
 import org.semux.util.ByteArray;
 import org.semux.util.Bytes;
+import org.semux.util.SystemUtil;
 import org.semux.util.TimeUtil;
 import org.semux.vm.client.SemuxBlock;
 import org.semux.vm.client.SemuxBlockStore;
@@ -317,7 +318,8 @@ public class PendingManager implements Runnable, BlockchainListener {
         boolean isVMTransaction = tx.getType() == TransactionType.CALL || tx.getType() == TransactionType.CREATE;
 
         // reject VM transactions that come in before fork
-        if (isVMTransaction && !kernel.getBlockchain().isForkActivated(Fork.VIRTUAL_MACHINE)) {
+        if (isVMTransaction && !SystemUtil.isVMTest()
+                && !kernel.getBlockchain().isForkActivated(Fork.VIRTUAL_MACHINE)) {
             return new ProcessingResult(0, TransactionResult.Code.INVALID_TYPE);
         }
         // reject VM transaction with low gas price
diff --git a/src/main/java/org/semux/core/TransactionExecutor.java b/src/main/java/org/semux/core/TransactionExecutor.java
index 84199b88..f796a670 100644
--- a/src/main/java/org/semux/core/TransactionExecutor.java
+++ b/src/main/java/org/semux/core/TransactionExecutor.java
@@ -28,6 +28,7 @@ import org.semux.core.state.Account;
 import org.semux.core.state.AccountState;
 import org.semux.core.state.DelegateState;
 import org.semux.util.Bytes;
+import org.semux.util.SystemUtil;
 import org.semux.vm.client.SemuxBlock;
 import org.semux.vm.client.SemuxInternalTransaction;
 import org.semux.vm.client.SemuxRepository;
@@ -215,7 +216,7 @@ public class TransactionExecutor {
             case CREATE:
                 // Note: the second parameter should be height = block number + 1; here we're
                 // checking if the fork is enabled at the end of last block.
-                if (!chain.isForkActivated(Fork.VIRTUAL_MACHINE, block.getNumber())) {
+                if (!SystemUtil.isVMTest() && !chain.isForkActivated(Fork.VIRTUAL_MACHINE, block.getNumber())) {
                     result.setCode(Code.INVALID_TYPE);
                     break;
                 }
diff --git a/src/main/java/org/semux/util/SystemUtil.java b/src/main/java/org/semux/util/SystemUtil.java
index ea8ddb5f..29f4e082 100644
--- a/src/main/java/org/semux/util/SystemUtil.java
+++ b/src/main/java/org/semux/util/SystemUtil.java
@@ -41,6 +41,8 @@ public class SystemUtil {
 
     private static final Logger logger = LoggerFactory.getLogger(SystemUtil.class);
 
+    public static boolean VM_TEST = false;
+
     public static class Code {
         // success
         public static final int OK = 0;
@@ -376,6 +378,10 @@ public class SystemUtil {
         }
     }
 
+    public static boolean isVMTest() {
+        return VM_TEST;
+    }
+
     private SystemUtil() {
     }
 }
diff --git a/src/test/java/org/semux/integration/TransactTest.java b/src/test/java/org/semux/integration/TransactTest.java
index 1b81d016..919459fa 100644
--- a/src/test/java/org/semux/integration/TransactTest.java
+++ b/src/test/java/org/semux/integration/TransactTest.java
@@ -12,6 +12,9 @@ import static org.awaitility.Awaitility.await;
 import static org.hamcrest.Matchers.equalTo;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.doReturn;
 import static org.semux.core.Amount.Unit.NANO_SEM;
 import static org.semux.core.Amount.Unit.SEM;
 import static org.semux.core.Amount.ZERO;
@@ -25,6 +28,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.concurrent.Callable;
 
+import org.ethereum.vm.util.HashUtil;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -40,6 +44,7 @@ import org.semux.api.v2.model.GetAccountTransactionsResponse;
 import org.semux.api.v2.model.GetDelegateResponse;
 import org.semux.core.Amount;
 import org.semux.core.Genesis;
+import org.semux.core.Transaction;
 import org.semux.core.TransactionType;
 import org.semux.core.state.Delegate;
 import org.semux.crypto.Hex;
@@ -48,6 +53,7 @@ import org.semux.net.SemuxChannelInitializer;
 import org.semux.rules.KernelRule;
 import org.semux.util.Bytes;
 import org.semux.util.SimpleApiClient;
+import org.semux.util.SystemUtil;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -88,6 +94,8 @@ public class TransactTest {
 
     @Before
     public void setUp() throws Exception {
+        SystemUtil.VM_TEST = true;
+
         // prepare kernels
         kernelRuleValidator1.speedUpConsensus();
         kernelRuleValidator2.speedUpConsensus();
@@ -136,6 +144,8 @@ public class TransactTest {
 
     @After
     public void tearDown() {
+        SystemUtil.VM_TEST = false;
+
         // stop kernels
         kernelValidator1.stop();
         kernelValidator2.stop();
@@ -295,6 +305,114 @@ public class TransactTest {
         // wait for transaction to be processed
         logger.info("Waiting for the transaction to be processed...");
         await().atMost(20, SECONDS).until(() -> kernelReceiver.getBlockchain().getTransaction(hash) != null);
+
+        Transaction tx = kernelReceiver.getBlockchain().getTransaction(hash);
+        assertEquals(TransactionType.CREATE, tx.getType());
+        assertEquals(gas, tx.getGas());
+        assertEquals(gasPrice, tx.getGasPrice());
+    }
+
+    @Test
+    public void testCREATEWithValue() throws IOException {
+        final long gas = 100_000;
+        final Amount gasPrice = NANO_SEM.of(100);
+        final Amount value = NANO_SEM.of(50);
+
+        // prepare transaction
+        HashMap<String, Object> params = new HashMap<>();
+        params.put("from", coinbaseOf(kernelPremine));
+        params.put("gas", String.valueOf(gas));
+        params.put("gasPrice", String.valueOf(gasPrice.getNano()));
+        params.put("data", "0x60006000");
+        params.put("value", String.valueOf(value.getNano()));
+
+        // send transaction
+        logger.info("Making create request", params);
+        DoTransactionResponse response = new ObjectMapper().readValue(
+                kernelPremine.getApiClient().post("/transaction/create", params),
+                DoTransactionResponse.class);
+        assertTrue(response.isSuccess());
+        byte[] hash = Hex.decode0x(response.getResult());
+
+        // wait for transaction to be processed
+        logger.info("Waiting for the transaction to be processed...");
+        await().atMost(20, SECONDS).until(() -> kernelReceiver.getBlockchain().getTransaction(hash) != null);
+
+        Transaction tx = kernelReceiver.getBlockchain().getTransaction(hash);
+        assertEquals(TransactionType.CREATE, tx.getType());
+        assertEquals(gas, tx.getGas());
+        assertEquals(gasPrice, tx.getGasPrice());
+        byte[] contractAddress = HashUtil.calcNewAddress(tx.getFrom(), tx.getNonce());
+        assertEquals(value,
+                kernelReceiver.getBlockchain().getAccountState().getAccount(contractAddress).getAvailable());
+    }
+
+    @Test
+    public void testCALL() throws IOException {
+        final long gas = 100_000;
+        final Amount gasPrice = NANO_SEM.of(100);
+        final byte[] contractAddress = Bytes.random(20);
+
+        // prepare transaction
+        HashMap<String, Object> params = new HashMap<>();
+        params.put("from", coinbaseOf(kernelPremine));
+        params.put("to", Hex.encode(contractAddress));
+        params.put("gas", String.valueOf(gas));
+        params.put("gasPrice", String.valueOf(gasPrice.getNano()));
+        params.put("data", "0x60006000");
+
+        // send transaction
+        logger.info("Making CALL request", params);
+        DoTransactionResponse response = new ObjectMapper().readValue(
+                kernelPremine.getApiClient().post("/transaction/call", params),
+                DoTransactionResponse.class);
+        assertTrue(response.isSuccess());
+        byte[] hash = Hex.decode0x(response.getResult());
+
+        // wait for transaction to be processed
+        logger.info("Waiting for the transaction to be processed...");
+        await().atMost(20, SECONDS).until(() -> kernelReceiver.getBlockchain().getTransaction(hash) != null);
+
+        Transaction tx = kernelReceiver.getBlockchain().getTransaction(hash);
+        assertEquals(TransactionType.CREATE, tx.getType());
+        assertEquals(gas, tx.getGas());
+        assertEquals(gasPrice, tx.getGasPrice());
+    }
+
+    @Test
+    public void testCALLWithValue() throws IOException {
+        final long gas = 100_000;
+        final Amount gasPrice = NANO_SEM.of(100);
+        final Amount value = NANO_SEM.of(50);
+        final byte[] contractAddress = Bytes.random(20);
+
+        // prepare transaction
+        HashMap<String, Object> params = new HashMap<>();
+        params.put("from", coinbaseOf(kernelPremine));
+        params.put("to", Hex.encode(contractAddress));
+        params.put("gas", String.valueOf(gas));
+        params.put("gasPrice", String.valueOf(gasPrice.getNano()));
+        params.put("data", "0x60006000");
+        params.put("value", String.valueOf(value.getNano()));
+
+        // send transaction
+        logger.info("Making CALL request", params);
+        DoTransactionResponse response = new ObjectMapper().readValue(
+                kernelPremine.getApiClient().post("/transaction/call", params),
+                DoTransactionResponse.class);
+        assertTrue(response.isSuccess());
+        byte[] hash = Hex.decode0x(response.getResult());
+
+        // wait for transaction to be processed
+        logger.info("Waiting for the transaction to be processed...");
+        await().atMost(20, SECONDS).until(() -> kernelReceiver.getBlockchain().getTransaction(hash) != null);
+
+        Transaction tx = kernelReceiver.getBlockchain().getTransaction(hash);
+        assertEquals(TransactionType.CREATE, tx.getType());
+        assertEquals(gas, tx.getGas());
+        assertEquals(gasPrice, tx.getGasPrice());
+        assertEquals(value,
+                kernelReceiver.getBlockchain().getAccountState().getAccount(contractAddress).getAvailable());
     }
 
     /**
