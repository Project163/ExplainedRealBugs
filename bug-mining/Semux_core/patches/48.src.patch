diff --git a/src/main/java/org/semux/crypto/EdDSA.java b/src/main/java/org/semux/crypto/EdDSA.java
index 166edf69..0b00c322 100644
--- a/src/main/java/org/semux/crypto/EdDSA.java
+++ b/src/main/java/org/semux/crypto/EdDSA.java
@@ -13,10 +13,10 @@ import java.security.SecureRandom;
 import java.security.SignatureException;
 import java.security.spec.InvalidKeySpecException;
 import java.security.spec.PKCS8EncodedKeySpec;
-import java.security.spec.X509EncodedKeySpec;
 import java.util.Arrays;
 
 import org.semux.crypto.cache.EdDSAPublicKeyCache;
+import org.semux.util.Bytes;
 import org.semux.util.SystemUtil;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -30,12 +30,17 @@ import net.i2p.crypto.eddsa.spec.EdDSANamedCurveTable;
 import net.i2p.crypto.eddsa.spec.EdDSAPublicKeySpec;
 
 /**
- * Edwards-curve Digital Signature Algorithm (EdDSA), specifically ED25519.
+ * Represents a key pair of the Edwards-curve Digital Signature Algorithm
+ * (EdDSA), specifically ED25519.
+ * <p>
  * Public key is encoded in "X.509"; private key is encoded in "PKCS#8".
- *
  */
 public class EdDSA {
 
+    public static final int PUBLIC_KEY_LEN = 44;
+    public static final int PRIVATE_KEY_LEN = 48;
+    public static final int SIGNATURE_LEN = 96;
+
     private static final Logger logger = LoggerFactory.getLogger(EdDSA.class);
 
     private static final KeyPairGenerator gen = new KeyPairGenerator();
@@ -83,8 +88,11 @@ public class EdDSA {
      * @throws InvalidKeySpecException
      */
     public EdDSA(byte[] privateKey, byte[] publicKey) throws InvalidKeySpecException {
-        this.sk = new EdDSAPrivateKey(new PKCS8EncodedKeySpec(privateKey));
-        this.pk = new EdDSAPublicKey(new X509EncodedKeySpec(publicKey));
+        this(privateKey);
+
+        if (!Arrays.equals(getPublicKey(), publicKey)) {
+            throw new InvalidKeySpecException("Public key private does not match!");
+        }
     }
 
     /**
@@ -141,7 +149,7 @@ public class EdDSA {
             engine.initSign(sk);
             byte[] sig = engine.signOneShot(msgHash);
 
-            return new Signature(sig, pk.getEncoded());
+            return new Signature(sig, pk.getAbyte());
         } catch (InvalidKeyException | SignatureException e) {
             throw new CryptoException(e);
         }
@@ -162,7 +170,7 @@ public class EdDSA {
                 EdDSAEngine engine = new EdDSAEngine();
                 engine.initVerify(EdDSAPublicKeyCache.computeIfAbsent(signature.getPublicKey()));
 
-                return engine.verifyOneShot(msgHash, signature.getSignature());
+                return engine.verifyOneShot(msgHash, signature.getS());
             } catch (Exception e) {
                 // do nothing
             }
@@ -201,39 +209,52 @@ public class EdDSA {
      * 
      */
     public static class Signature {
-        private static final int SIG_LENGTH = 64;
-        private static final int PUB_LENGTH = 44;
+        private static final byte[] X509 = Hex.decode("302a300506032b6570032100");
+        private static final int S_LEN = 64;
+        private static final int A_LEN = 32;
 
-        private byte[] sig;
-        private byte[] pub;
+        private byte[] s;
+        private byte[] a;
 
         /**
          * Creates a Signature instance.
          * 
-         * @param sig
-         * @param pub
+         * @param s
+         * @param a
+         */
+        public Signature(byte[] s, byte[] a) {
+            if (s == null || s.length != S_LEN || a == null || a.length != A_LEN) {
+                throw new IllegalArgumentException("Invalid S or A");
+            }
+            this.s = s;
+            this.a = a;
+        }
+
+        /**
+         * Returns the S byte array.
+         * 
+         * @return
          */
-        public Signature(byte[] sig, byte[] pub) {
-            this.sig = sig;
-            this.pub = pub;
+        public byte[] getS() {
+            return s;
         }
 
         /**
-         * Returns the raw signature byte array.
+         * Returns the A byte array.
          * 
          * @return
          */
-        public byte[] getSignature() {
-            return sig;
+        public byte[] getA() {
+            return a;
         }
 
         /**
-         * Returns the public key.
+         * Returns the public key of the signer.
          * 
          * @return
          */
         public byte[] getPublicKey() {
-            return pub;
+            return Bytes.merge(X509, a);
         }
 
         /**
@@ -242,7 +263,7 @@ public class EdDSA {
          * @return
          */
         public byte[] getAddress() {
-            return Hash.h160(pub);
+            return Hash.h160(getPublicKey());
         }
 
         /**
@@ -251,9 +272,9 @@ public class EdDSA {
          * @return
          */
         public byte[] toBytes() {
-            byte[] result = new byte[sig.length + pub.length];
-            System.arraycopy(sig, 0, result, 0, sig.length);
-            System.arraycopy(pub, 0, result, sig.length, pub.length);
+            byte[] result = new byte[s.length + a.length];
+            System.arraycopy(s, 0, result, 0, s.length);
+            System.arraycopy(a, 0, result, s.length, a.length);
 
             return result;
         }
@@ -262,17 +283,17 @@ public class EdDSA {
          * Parses from byte array.
          * 
          * @param bytes
-         * @return a signature if success,or null
+         * @return a {@link Signature} if success,or null
          */
         public static Signature fromBytes(byte[] bytes) {
-            if (bytes == null || bytes.length != SIG_LENGTH + PUB_LENGTH) {
+            if (bytes == null || bytes.length != S_LEN + A_LEN) {
                 return null;
             }
 
-            byte[] sig = Arrays.copyOf(bytes, SIG_LENGTH);
-            byte[] pub = Arrays.copyOfRange(bytes, SIG_LENGTH, bytes.length);
+            byte[] s = Arrays.copyOfRange(bytes, 0, S_LEN);
+            byte[] a = Arrays.copyOfRange(bytes, S_LEN, S_LEN + A_LEN);
 
-            return new Signature(sig, pub);
+            return new Signature(s, a);
         }
     }
 
diff --git a/src/test/java/org/semux/crypto/EdDSATest.java b/src/test/java/org/semux/crypto/EdDSATest.java
index 4c209f8a..b4da9133 100644
--- a/src/test/java/org/semux/crypto/EdDSATest.java
+++ b/src/test/java/org/semux/crypto/EdDSATest.java
@@ -56,15 +56,15 @@ public class EdDSATest {
         Signature sig = key.sign(hash);
         assertTrue(EdDSA.verify(hash, sig));
 
-        byte[] R = Arrays.copyOf(sig.getSignature(), 32);
-        byte[] S = Arrays.copyOfRange(sig.getSignature(), 32, 64);
+        byte[] R = Arrays.copyOf(sig.getS(), 32);
+        byte[] S = Arrays.copyOfRange(sig.getS(), 32, 64);
 
         BigInteger s = new BigInteger(1, S);
         BigInteger l = BigInteger.valueOf(2).pow(252).add(new BigInteger("27742317777372353535851937790883648493"));
         byte[] sPlusL = s.add(l).toByteArray();
         sPlusL = Arrays.copyOfRange(sPlusL, sPlusL.length - 32, sPlusL.length);
 
-        Signature sig2 = new Signature(Bytes.merge(R, sPlusL), sig.getPublicKey());
+        Signature sig2 = new Signature(Bytes.merge(R, sPlusL), sig.getA());
         assertFalse(EdDSA.verify(hash, sig2));
     }
 
@@ -72,8 +72,8 @@ public class EdDSATest {
     public void testGenerateKeyPair() throws InvalidKeySpecException {
         EdDSA key1 = new EdDSA();
 
-        assertEquals(44, key1.getPublicKey().length);
-        assertEquals(48, key1.getPrivateKey().length);
+        assertEquals(EdDSA.PUBLIC_KEY_LEN, key1.getPublicKey().length);
+        assertEquals(EdDSA.PRIVATE_KEY_LEN, key1.getPrivateKey().length);
 
         EdDSA key2 = new EdDSA(key1.getPrivateKey(), key1.getPublicKey());
 
@@ -81,6 +81,13 @@ public class EdDSATest {
         Assert.assertArrayEquals(key1.getPrivateKey(), key2.getPrivateKey());
     }
 
+    @Test(expected = InvalidKeySpecException.class)
+    public void testPublicPrivateKeyMismatch() throws InvalidKeySpecException {
+        EdDSA key1 = new EdDSA();
+
+        new EdDSA(key1.getPrivateKey(), new byte[EdDSA.PUBLIC_KEY_LEN]);
+    }
+
     @Test
     public void testSignAndVerify() throws SignatureException {
         EdDSA key = new EdDSA();
@@ -89,6 +96,7 @@ public class EdDSATest {
         byte[] hash = Hash.h256(data);
         byte[] sig = key.sign(hash).toBytes();
 
+        assertEquals(EdDSA.SIGNATURE_LEN, sig.length);
         assertTrue(EdDSA.verify(hash, sig));
         assertArrayEquals(key.getPublicKey(), Signature.fromBytes(sig).getPublicKey());
         assertArrayEquals(key.toAddress(), Signature.fromBytes(sig).getAddress());
