diff --git a/src/yb/integration-tests/xcluster/xcluster-test.cc b/src/yb/integration-tests/xcluster/xcluster-test.cc
index ec63356223..02928fab34 100644
--- a/src/yb/integration-tests/xcluster/xcluster-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster-test.cc
@@ -3848,4 +3848,53 @@ TEST_F_EX(XClusterTest, VerifyReplicationError, XClusterTestNoParam) {
   ASSERT_OK(VerifyReplicationError(consumer_table_->id(), stream_id, std::nullopt));
 }
 
+// Test deleting inbound replication group without performing source stream cleanup.
+TEST_F_EX(XClusterTest, DeleteWithoutStreamCleanup, XClusterTestNoParam) {
+  constexpr int kNTabletsPerTable = 1;
+  constexpr int kReplicationFactor = 1;
+  std::vector<uint32_t> tables_vector = {kNTabletsPerTable};
+  ASSERT_OK(SetUpWithParams(tables_vector, kReplicationFactor));
+
+  ASSERT_OK(SetupReplication());
+
+  ASSERT_OK(VerifyNumCDCStreams(producer_client(), producer_cluster(), /* num_streams = */ 1));
+  auto stream_id = ASSERT_RESULT(GetCDCStreamID(producer_table_->id()));
+
+  // Delete with skip_producer_stream_deletion set.
+  master::DeleteUniverseReplicationRequestPB req;
+  master::DeleteUniverseReplicationResponsePB resp;
+  req.set_replication_group_id(kReplicationGroupId.ToString());
+  req.set_skip_producer_stream_deletion(true);
+
+  auto consumer_master_proxy = std::make_shared<master::MasterReplicationProxy>(
+      &consumer_client()->proxy_cache(),
+      ASSERT_RESULT(consumer_cluster()->GetLeaderMiniMaster())->bound_rpc_addr());
+  {
+    rpc::RpcController rpc;
+    rpc.set_timeout(MonoDelta::FromSeconds(kRpcTimeout));
+    ASSERT_OK(consumer_master_proxy->DeleteUniverseReplication(req, &resp, &rpc));
+  }
+  ASSERT_FALSE(resp.has_error());
+
+  // Make sure source stream still exists.
+  ASSERT_OK(VerifyNumCDCStreams(producer_client(), producer_cluster(), /* num_streams = */ 1));
+
+  // Delete the stream manually from the source.
+  master::DeleteCDCStreamRequestPB delete_cdc_stream_req;
+  master::DeleteCDCStreamResponsePB delete_cdc_stream_resp;
+  delete_cdc_stream_req.add_stream_id(stream_id.ToString());
+  delete_cdc_stream_req.set_force_delete(true);
+  {
+    rpc::RpcController rpc;
+    rpc.set_timeout(MonoDelta::FromSeconds(kRpcTimeout));
+    auto producer_proxy = std::make_shared<master::MasterReplicationProxy>(
+        &producer_client()->proxy_cache(),
+        ASSERT_RESULT(producer_cluster()->GetLeaderMiniMaster())->bound_rpc_addr());
+    ASSERT_OK(
+        producer_proxy->DeleteCDCStream(delete_cdc_stream_req, &delete_cdc_stream_resp, &rpc));
+  }
+
+  ASSERT_OK(VerifyNumCDCStreams(producer_client(), producer_cluster(), /* num_streams = */ 0));
+}
+
 }  // namespace yb
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index aede9c217e..57033c7aca 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -2958,7 +2958,7 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
   Status DeleteUniverseReplicationUnlocked(scoped_refptr<UniverseReplicationInfo> info);
   Status DeleteUniverseReplication(
       const xcluster::ReplicationGroupId& replication_group_id, bool ignore_errors,
-      DeleteUniverseReplicationResponsePB* resp);
+      bool skip_producer_stream_deletion, DeleteUniverseReplicationResponsePB* resp);
 
   void MarkUniverseReplicationFailed(
       scoped_refptr<UniverseReplicationInfo> universe, const Status& failure_status);
diff --git a/src/yb/master/master_replication.proto b/src/yb/master/master_replication.proto
index 76428a69ce..c38238735f 100644
--- a/src/yb/master/master_replication.proto
+++ b/src/yb/master/master_replication.proto
@@ -285,6 +285,7 @@ message SetupUniverseReplicationResponsePB {
 message DeleteUniverseReplicationRequestPB {
   optional string replication_group_id = 1;
   optional bool ignore_errors = 2 [default = false];
+  optional bool skip_producer_stream_deletion = 3 [ default = false ];
 }
 
 message DeleteUniverseReplicationResponsePB {
diff --git a/src/yb/master/xrepl_catalog_manager.cc b/src/yb/master/xrepl_catalog_manager.cc
index 4b92f3e225..59472b634e 100644
--- a/src/yb/master/xrepl_catalog_manager.cc
+++ b/src/yb/master/xrepl_catalog_manager.cc
@@ -4366,7 +4366,7 @@ void CatalogManager::MergeUniverseReplication(
 
 Status CatalogManager::DeleteUniverseReplication(
     const xcluster::ReplicationGroupId& replication_group_id, bool ignore_errors,
-    DeleteUniverseReplicationResponsePB* resp) {
+    bool skip_producer_stream_deletion, DeleteUniverseReplicationResponsePB* resp) {
   scoped_refptr<UniverseReplicationInfo> ri;
   {
     SharedLock lock(mutex_);
@@ -4414,7 +4414,7 @@ Status CatalogManager::DeleteUniverseReplication(
   }
 
   // Delete CDC stream config on the Producer.
-  if (!l->pb.table_streams().empty()) {
+  if (!l->pb.table_streams().empty() && !skip_producer_stream_deletion) {
     auto result = ri->GetOrCreateXClusterRpcTasks(l->pb.producer_master_addresses());
     if (!result.ok()) {
       LOG(WARNING) << "Unable to create cdc rpc task. CDC streams won't be deleted: " << result;
@@ -4493,7 +4493,8 @@ Status CatalogManager::DeleteUniverseReplication(
   }
 
   RETURN_NOT_OK(DeleteUniverseReplication(
-      xcluster::ReplicationGroupId(req->replication_group_id()), req->ignore_errors(), resp));
+      xcluster::ReplicationGroupId(req->replication_group_id()), req->ignore_errors(),
+      req->skip_producer_stream_deletion(), resp));
   LOG(INFO) << "Successfully completed DeleteUniverseReplication request from "
             << RequestorString(rpc);
   return Status::OK();
