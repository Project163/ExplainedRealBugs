diff --git a/src/yb/client/client-internal.cc b/src/yb/client/client-internal.cc
index b0a8612eed..d1859020bb 100644
--- a/src/yb/client/client-internal.cc
+++ b/src/yb/client/client-internal.cc
@@ -334,6 +334,7 @@ YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, GetXClusterOutboundReplicationGroupI
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, GetUniverseReplications);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, GetUniverseReplicationInfo);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, WaitForReplicationDrain);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, XClusterEnsureSequenceUpdatesAreInWal);
 
 #define YB_CLIENT_SPECIALIZE_SIMPLE_EX_EACH(i, data, set) YB_CLIENT_SPECIALIZE_SIMPLE_EX set
 
diff --git a/src/yb/client/xcluster_client.cc b/src/yb/client/xcluster_client.cc
index c9db9eea4f..5c189a9db0 100644
--- a/src/yb/client/xcluster_client.cc
+++ b/src/yb/client/xcluster_client.cc
@@ -246,6 +246,31 @@ Status XClusterClient::IsBootstrapRequired(
       &yb_client_, deadline, replication_group_id, namespace_id, std::move(callback));
 }
 
+Status XClusterClient::EnsureSequenceUpdatesAreInWal(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::vector<NamespaceId>& namespace_ids, CoarseTimePoint deadline) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication group ID");
+  SCHECK(!namespace_ids.empty(), InvalidArgument, "No Namespace IDs provided");
+  for (const auto& namespace_id : namespace_ids) {
+    SCHECK(!namespace_id.empty(), InvalidArgument, "Invalid empty Namespace ID provided");
+  }
+
+  master::XClusterEnsureSequenceUpdatesAreInWalRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+  for (const auto& namespace_id : namespace_ids) {
+    req.add_namespace_ids(namespace_id);
+  }
+
+  master::XClusterEnsureSequenceUpdatesAreInWalResponsePB resp;
+  RETURN_NOT_OK(yb_client_.data_->SyncLeaderMasterRpc(
+      deadline, req, &resp, "XClusterEnsureSequenceUpdatesAreInWal",
+      &master::MasterReplicationProxy::XClusterEnsureSequenceUpdatesAreInWalAsync));
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+  return Status::OK();
+}
+
 Status XClusterClient::RemoveNamespaceFromOutboundReplicationGroup(
     const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
     const std::string& target_master_addresses) {
diff --git a/src/yb/client/xcluster_client.h b/src/yb/client/xcluster_client.h
index 81f473ba97..36ccf088fd 100644
--- a/src/yb/client/xcluster_client.h
+++ b/src/yb/client/xcluster_client.h
@@ -105,6 +105,10 @@ class XClusterClient {
       CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
       const NamespaceId& namespace_id, IsXClusterBootstrapRequiredCallback callback);
 
+  Status EnsureSequenceUpdatesAreInWal(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::vector<NamespaceId>& namespace_ids, CoarseTimePoint deadline);
+
   // Count of table_names and pg_schema_names must match. If no table_names are provided then all
   // tables of the namespace are returned.
   Status GetXClusterStreams(
diff --git a/src/yb/integration-tests/sequence_utility-itest.cc b/src/yb/integration-tests/sequence_utility-itest.cc
index f1fba3159a..e0a78b0e08 100644
--- a/src/yb/integration-tests/sequence_utility-itest.cc
+++ b/src/yb/integration-tests/sequence_utility-itest.cc
@@ -186,17 +186,17 @@ TEST_F(SequencesUtilTest, ScanWithReadFailure) {
   LOG(INFO) << "return status is " << result.status();
 }
 
-TEST_F(SequencesUtilTest, EnsureSequenceUpdatesInWalWhenNoChanges) {
+TEST_F(SequencesUtilTest, EnsureSequenceUpdatesAreInWalWhenNoChanges) {
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_docdb_log_write_batches) = true;
   ASSERT_OK(CreateSampleSequences());
   auto expected = ASSERT_RESULT(GetSequencesData());
   auto sequences = ASSERT_RESULT(master::ScanSequencesDataTable(*client_.get(), namespace_oid_));
   auto updates =
-      ASSERT_RESULT(EnsureSequenceUpdatesInWal(*client_.get(), namespace_oid_, sequences));
+      ASSERT_RESULT(EnsureSequenceUpdatesAreInWal(*client_.get(), namespace_oid_, sequences));
 
   // For this test we assume there were no changes since the scan used to call
-  // EnsureSequenceUpdatesInWal was done.  Thus EnsureSequenceUpdatesInWal should have made one
-  // update for each sequence.
+  // EnsureSequenceUpdatesAreInWal was done.  Thus EnsureSequenceUpdatesAreInWal should have made
+  // one update for each sequence.
   ASSERT_EQ(updates, expected.size());
 
   // Ensure the updates it made are nops.
@@ -206,14 +206,14 @@ TEST_F(SequencesUtilTest, EnsureSequenceUpdatesInWalWhenNoChanges) {
   }
 }
 
-TEST_F(SequencesUtilTest, EnsureSequenceUpdatesInWalWithConcurrentChanges) {
+TEST_F(SequencesUtilTest, EnsureSequenceUpdatesAreInWalWithConcurrentChanges) {
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_docdb_log_write_batches) = true;
   ASSERT_OK(CreateSampleSequences());
   auto sequences = ASSERT_RESULT(master::ScanSequencesDataTable(*client_.get(), namespace_oid_));
 
   // Here we are testing changes that occur between the scan used to get the sequence information
-  // and the call to EnsureSequenceUpdatesInWal.  This should make EnsureSequenceUpdatesInWal do
-  // fewer updates because it should not update changes since the scan was done.
+  // and the call to EnsureSequenceUpdatesAreInWal.  This should make EnsureSequenceUpdatesAreInWal
+  // do fewer updates because it should not update changes since the scan was done.
 
   auto conn = ASSERT_RESULT(ConnectToDB(kNamespaceName));
   ASSERT_OK(conn.Execute("ALTER SEQUENCE altered_sequence RESTART WITH 22"));
@@ -222,7 +222,7 @@ TEST_F(SequencesUtilTest, EnsureSequenceUpdatesInWalWithConcurrentChanges) {
   ASSERT_OK(conn.Execute("DROP SEQUENCE extra_sequence"));
 
   auto updates =
-      ASSERT_RESULT(EnsureSequenceUpdatesInWal(*client_.get(), namespace_oid_, sequences));
+      ASSERT_RESULT(EnsureSequenceUpdatesAreInWal(*client_.get(), namespace_oid_, sequences));
   ASSERT_EQ(updates, sequences.size() - /*number of sequences changed above*/ 3);
 
   // Ensure the updates it did make are nops.
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
index 0dcb51f5f1..bbbbbd7128 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
@@ -130,8 +130,10 @@ TEST_F(XClusterDDLReplicationTest, Bootstrapping) {
   auto producer_table_name = ASSERT_RESULT(CreateYsqlTable(
       /*idx=*/1, /*num_tablets=*/3, &producer_cluster_));
 
-  ASSERT_OK(CheckpointReplicationGroup());
-  ASSERT_OK(CreateReplicationFromCheckpointUsingBackupRestore());
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces({namespace_name}));
+  ASSERT_OK(BackupFromProducer());
+  ASSERT_OK(RestoreToConsumer());
+  ASSERT_OK(CreateReplicationFromCheckpoint());
 }
 
 // TODO(Julien): As part of #24888, undisable this or make this a test that this correctly fails
@@ -143,8 +145,10 @@ TEST_F(XClusterDDLReplicationTest, YB_DISABLE_TEST(BootstrappingWithNoTables)) {
 
   ASSERT_OK(SetUpClusters(/*is_colocated=*/false, /*start_yb_controller_servers=*/true));
 
-  ASSERT_OK(CheckpointReplicationGroup());
-  ASSERT_OK(CreateReplicationFromCheckpointUsingBackupRestore());
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces({namespace_name}));
+  ASSERT_OK(BackupFromProducer());
+  ASSERT_OK(RestoreToConsumer());
+  ASSERT_OK(CreateReplicationFromCheckpoint());
 }
 
 TEST_F(XClusterDDLReplicationTest, CreateTable) {
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
index aecf083771..0acf41932f 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
@@ -60,15 +60,15 @@ Status XClusterDDLReplicationTestBase::SetUpClusters(
   return XClusterYsqlTestBase::SetUpClusters(kDefaultParams);
 }
 
-Status XClusterDDLReplicationTestBase::CheckpointReplicationGroupWithoutRequiringNoBootstrapNeeded(
+Status XClusterDDLReplicationTestBase::CheckpointReplicationGroupOnNamespaces(
     const std::vector<NamespaceName>& namespace_names) {
   std::vector<NamespaceId> namespace_ids;
   for (const auto& namespace_name : namespace_names) {
     namespace_ids.push_back(VERIFY_RESULT(GetNamespaceId(producer_client(), namespace_name)));
   }
-  RETURN_NOT_OK(client::XClusterClient(*producer_client())
-                .CreateOutboundReplicationGroup(
-                    kReplicationGroupId, namespace_ids, UseAutomaticMode()));
+  RETURN_NOT_OK(
+      client::XClusterClient(*producer_client())
+          .CreateOutboundReplicationGroup(kReplicationGroupId, namespace_ids, UseAutomaticMode()));
 
   for (const auto& namespace_id : namespace_ids) {
     auto bootstrap_required =
@@ -79,17 +79,8 @@ Status XClusterDDLReplicationTestBase::CheckpointReplicationGroupWithoutRequirin
   return Status::OK();
 }
 
-Status XClusterDDLReplicationTestBase::CreateReplicationFromCheckpointUsingBackupRestore(
-    const std::string& target_master_addresses,
-    const xcluster::ReplicationGroupId& replication_group_id,
-    std::vector<NamespaceName> namespace_names, std::function<Status()> between_backup_and_restore,
-    std::function<Status()> after_restore) {
-  RETURN_NOT_OK(SetupCertificates(replication_group_id));
-
-  auto master_addr = target_master_addresses;
-  if (master_addr.empty()) {
-    master_addr = consumer_cluster()->GetMasterAddresses();
-  }
+Status XClusterDDLReplicationTestBase::BackupFromProducer(
+    std::vector<NamespaceName> namespace_names) {
   if (namespace_names.empty()) {
     namespace_names = {namespace_name};
   }
@@ -105,8 +96,17 @@ Status XClusterDDLReplicationTestBase::CreateReplicationFromCheckpointUsingBacku
          Format("ysql.$0", namespace_name), "create"},
         &*producer_cluster_.mini_cluster_));
   }
+  return Status::OK();
+}
 
-  RETURN_NOT_OK(between_backup_and_restore());
+Status XClusterDDLReplicationTestBase::RestoreToConsumer(
+    std::vector<NamespaceName> namespace_names) {
+  if (namespace_names.empty()) {
+    namespace_names = {namespace_name};
+  }
+  auto BackupDir = [&](NamespaceName namespace_name) {
+    return GetTempDir(Format("backup_$0", namespace_name));
+  };
 
   // Restore to new databases on the consumer.
   for (const auto& namespace_name : namespace_names) {
@@ -116,13 +116,7 @@ Status XClusterDDLReplicationTestBase::CreateReplicationFromCheckpointUsingBacku
          Format("ysql.$0", namespace_name), "restore"},
         &*consumer_cluster_.mini_cluster_));
   }
-
-  RETURN_NOT_OK(after_restore());
-
-  RETURN_NOT_OK(client::XClusterClient(*producer_client())
-                    .CreateXClusterReplicationFromCheckpoint(replication_group_id, master_addr));
-
-  return WaitForCreateReplicationToFinish(master_addr, namespace_names);
+  return Status::OK();
 }
 
 Status XClusterDDLReplicationTestBase::RunBackupCommand(
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h
index cb4d789cd8..6a23ac7bcb 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h
@@ -40,16 +40,15 @@ class XClusterDDLReplicationTestBase : public XClusterYsqlTestBase {
   }
 
   // Unlike the previous method, this one does not fail if bootstrap is required.
-  Status CheckpointReplicationGroupWithoutRequiringNoBootstrapNeeded(
-      const std::vector<NamespaceName>& namespace_names);
+  Status CheckpointReplicationGroupOnNamespaces(const std::vector<NamespaceName>& namespace_names);
 
   // A empty list for namespace_names (the default) means just the namespace namespace_name.
-  Status CreateReplicationFromCheckpointUsingBackupRestore(
-      const std::string& target_master_addresses = {},
-      const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId,
-      std::vector<NamespaceName> namespace_names = {},
-      std::function<Status()> between_backup_and_restore = [](){ return Status::OK(); },
-      std::function<Status()> after_restore = [](){ return Status::OK(); });
+  // Saves backups in TmpDir directories.
+  Status BackupFromProducer(std::vector<NamespaceName> namespace_names = {});
+
+  // A empty list for namespace_names (the default) means just the namespace namespace_name.
+  // Restores backups saved by BackupFromProducer.
+  Status RestoreToConsumer(std::vector<NamespaceName> namespace_names = {});
 
   Status RunBackupCommand(const std::vector<std::string>& args, MiniClusterBase* cluster);
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc b/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
index 94f2ff2ed4..10449b8a7c 100644
--- a/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
@@ -20,8 +20,10 @@
 #include "yb/util/flags.h"
 #include "yb/util/logging_test_util.h"
 
+DECLARE_bool(TEST_simulate_EnsureSequenceUpdatesAreInWal_failure);
 DECLARE_bool(ysql_enable_packed_row);
 DECLARE_int32(TEST_xcluster_simulated_lag_ms);
+DECLARE_int32(xcluster_ensure_sequence_updates_in_wal_timeout_sec);
 DECLARE_int32(ysql_num_shards_per_tserver);
 
 namespace yb {
@@ -30,12 +32,14 @@ class XClusterAutomaticModeTest : public XClusterDDLReplicationTestBase {
  public:
   Status SetUpClusters(
       bool use_different_database_oids, NamespaceName first_namespace,
-      std::optional<NamespaceName> second_namespace = std::nullopt) {
+      std::optional<NamespaceName> second_namespace = std::nullopt,
+      bool start_yb_controller_servers = false) {
     // Set up first namespace.
     namespace_name = first_namespace;
     SetupParams params;
     params.replication_factor = 1;
     params.use_different_database_oids = use_different_database_oids;
+    params.start_yb_controller_servers = start_yb_controller_servers;
     RETURN_NOT_OK(XClusterYsqlTestBase::SetUpClusters(params));
 
     // Set up second namespace if requested.
@@ -114,7 +118,6 @@ class XClusterAutomaticModeTest : public XClusterDDLReplicationTestBase {
   }
 };
 
-
 TEST_F(XClusterAutomaticModeTest, StraightforwardSequenceReplication) {
   // Make sure we correctly wait for replications to drain in order to avoid flakiness.
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_simulated_lag_ms) = 2000;
@@ -132,7 +135,7 @@ TEST_F(XClusterAutomaticModeTest, StraightforwardSequenceReplication) {
   ASSERT_OK(SetUpSequences(&consumer_cluster_, namespace1));
   ASSERT_OK(VerifySequencesSameOnBothSides(namespace1));
 
-  ASSERT_OK(CheckpointReplicationGroupWithoutRequiringNoBootstrapNeeded({namespace1}));
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces({namespace1}));
   ASSERT_OK(CreateReplicationFromCheckpoint());
   ASSERT_OK(VerifySequencesSameOnBothSides(namespace1));
 
@@ -176,7 +179,7 @@ TEST_F(XClusterAutomaticModeTest, SequenceReplicationWithFiltering) {
   // namespace1 on the consumer unchanged when we bump sequences of
   // namespace1 on the producer.
   std::vector<NamespaceName> namespaces_to_replicate = {namespace2};
-  ASSERT_OK(CheckpointReplicationGroupWithoutRequiringNoBootstrapNeeded(namespaces_to_replicate));
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces(namespaces_to_replicate));
   ASSERT_OK(CreateReplicationFromCheckpoint({}, kReplicationGroupId, namespaces_to_replicate));
   EXPECT_EQ(
       original_namespace1_consumer_sequences,
@@ -209,7 +212,7 @@ TEST_F(XClusterAutomaticModeTest, SequenceReplicationWithTwoDbs) {
   std::vector<NamespaceName> namespaces_to_replicate = {namespace1, namespace2};
   {
     SCOPED_TRACE("Setting up replication");
-    ASSERT_OK(CheckpointReplicationGroupWithoutRequiringNoBootstrapNeeded(namespaces_to_replicate));
+    ASSERT_OK(CheckpointReplicationGroupOnNamespaces(namespaces_to_replicate));
     ASSERT_OK(CreateReplicationFromCheckpoint({}, kReplicationGroupId, namespaces_to_replicate));
     ASSERT_OK(VerifySequencesSameOnBothSides(namespace1));
     ASSERT_OK(VerifySequencesSameOnBothSides(namespace2));
@@ -247,7 +250,7 @@ TEST_F(XClusterAutomaticModeTest, SequenceReplicationWithTransform) {
   ASSERT_OK(VerifySequencesSameOnBothSides(namespace1));
 
   std::vector<NamespaceName> namespaces_to_replicate = {namespace1};
-  ASSERT_OK(CheckpointReplicationGroupWithoutRequiringNoBootstrapNeeded(namespaces_to_replicate));
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces(namespaces_to_replicate));
   ASSERT_OK(CreateReplicationFromCheckpoint({}, kReplicationGroupId, namespaces_to_replicate));
   ASSERT_OK(VerifySequencesSameOnBothSides(namespace1));
 
@@ -264,7 +267,7 @@ TEST_F(XClusterAutomaticModeTest, SequenceSafeTime) {
   ASSERT_OK(SetUpSequences(&consumer_cluster_, namespace1));
 
   std::vector<NamespaceName> namespaces_to_replicate = {namespace1};
-  ASSERT_OK(CheckpointReplicationGroupWithoutRequiringNoBootstrapNeeded(namespaces_to_replicate));
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces(namespaces_to_replicate));
   ASSERT_OK(CreateReplicationFromCheckpoint({}, kReplicationGroupId, namespaces_to_replicate));
   ASSERT_OK(WaitForSafeTimeToAdvanceToNow(namespaces_to_replicate));
   ASSERT_OK(VerifySequencesSameOnBothSides(namespace1));
@@ -286,7 +289,7 @@ TEST_F(XClusterAutomaticModeTest, SequencePausingAndSafeTime) {
   ASSERT_OK(SetUpSequences(&consumer_cluster_, namespace1));
 
   std::vector<NamespaceName> namespaces_to_replicate = {namespace1};
-  ASSERT_OK(CheckpointReplicationGroupWithoutRequiringNoBootstrapNeeded(namespaces_to_replicate));
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces(namespaces_to_replicate));
   ASSERT_OK(CreateReplicationFromCheckpoint({}, kReplicationGroupId, namespaces_to_replicate));
   ASSERT_OK(WaitForSafeTimeToAdvanceToNow(namespaces_to_replicate));
 
@@ -313,7 +316,7 @@ TEST_F(XClusterAutomaticModeTest, SequencePausingIsolation) {
   }));
 
   std::vector<NamespaceName> namespaces_to_replicate = {namespace1, namespace2};
-  ASSERT_OK(CheckpointReplicationGroupWithoutRequiringNoBootstrapNeeded(namespaces_to_replicate));
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces(namespaces_to_replicate));
   ASSERT_OK(CreateReplicationFromCheckpoint({}, kReplicationGroupId, namespaces_to_replicate));
   ASSERT_OK(WaitForSafeTimeToAdvanceToNow(namespaces_to_replicate));
 
@@ -348,4 +351,96 @@ TEST_F(XClusterAutomaticModeTest, SequencePausingIsolation) {
   pause_one_namespace_temporarily(namespace2, namespace1);
 }
 
+TEST_F(XClusterAutomaticModeTest, SequenceReplicationBootstrappingWithoutBumps) {
+  if (!UseYbController()) {
+    GTEST_SKIP() << "This test does not work with yb_backup.py";
+  }
+
+  const std::string namespace1{"yugabyte"};
+  ASSERT_OK(SetUpClusters(
+      /*use_different_database_oids=*/false, namespace1, /*second_namespace=*/std::nullopt,
+      /*start_yb_controller_servers=*/true));
+
+  ASSERT_OK(SetUpSequences(&producer_cluster_, namespace1));
+
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces({namespace1}));
+  ASSERT_OK(BackupFromProducer({namespace1}));
+  ASSERT_OK(RestoreToConsumer({namespace1}));
+  ASSERT_OK(CreateReplicationFromCheckpoint({}, kReplicationGroupId, {namespace1}));
+  ASSERT_OK(VerifySequencesSameOnBothSides(namespace1));
+
+  ASSERT_OK(BumpSequences(&producer_cluster_, namespace1));
+  ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
+  ASSERT_OK(VerifySequencesSameOnBothSides(namespace1));
+}
+
+TEST_F(XClusterAutomaticModeTest, SequenceReplicationBootstrappingBumpInMiddle) {
+  if (!UseYbController()) {
+    GTEST_SKIP() << "This test does not work with yb_backup.py";
+  }
+
+  const std::string namespace1{"yugabyte"};
+  ASSERT_OK(SetUpClusters(
+      /*use_different_database_oids=*/false, namespace1, /*second_namespace=*/std::nullopt,
+      /*start_yb_controller_servers=*/true));
+  ASSERT_OK(SetUpSequences(&producer_cluster_, namespace1));
+
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces({namespace1}));
+  ASSERT_OK(BackupFromProducer({namespace1}));
+
+  ASSERT_OK(BumpSequences(&producer_cluster_, namespace1));
+
+  ASSERT_OK(RestoreToConsumer({namespace1}));
+  ASSERT_OK(CreateReplicationFromCheckpoint({}, kReplicationGroupId, {namespace1}));
+  ASSERT_OK(VerifySequencesSameOnBothSides(namespace1));
+
+  ASSERT_OK(BumpSequences(&producer_cluster_, namespace1));
+  ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
+  ASSERT_OK(VerifySequencesSameOnBothSides(namespace1));
+}
+
+TEST_F(XClusterAutomaticModeTest, SequenceReplicationBootstrappingWith2Databases) {
+  if (!UseYbController()) {
+    GTEST_SKIP() << "This test does not work with yb_backup.py";
+  }
+
+  const std::string namespace1{"yugabyte"};
+  const std::string namespace2{"yugabyte2"};
+  ASSERT_OK(SetUpClusters(
+      /*use_different_database_oids=*/false, namespace1, namespace2,
+      /*start_yb_controller_servers=*/true));
+  ASSERT_OK(SetUpSequences(&producer_cluster_, namespace1));
+  ASSERT_OK(BumpSequences(&producer_cluster_, namespace1));
+  ASSERT_OK(SetUpSequences(&producer_cluster_, namespace2));
+
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces({namespace1, namespace2}));
+  ASSERT_OK(BackupFromProducer({namespace1, namespace2}));
+
+  ASSERT_OK(BumpSequences(&producer_cluster_, namespace1));
+  ASSERT_OK(BumpSequences(&producer_cluster_, namespace2));
+
+  ASSERT_OK(RestoreToConsumer({namespace1, namespace2}));
+  ASSERT_OK(CreateReplicationFromCheckpoint({}, kReplicationGroupId, {namespace1, namespace2}));
+
+  ASSERT_OK(VerifySequencesSameOnBothSides(namespace1));
+  ASSERT_OK(VerifySequencesSameOnBothSides(namespace2));
+}
+
+TEST_F(XClusterAutomaticModeTest, SequenceReplicationEnsureWalsFails) {
+  if (!UseYbController()) {
+    GTEST_SKIP() << "This test does not work with yb_backup.py";
+  }
+
+  // Make the EnsureSequenceUpdatesAreInWal call, which is part of bootstrapping, fail.
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_simulate_EnsureSequenceUpdatesAreInWal_failure) = true;
+
+  const std::string namespace1{"yugabyte"};
+  ASSERT_OK(SetUpClusters(
+      /*use_different_database_oids=*/false, namespace1, /*second_namespace=*/std::nullopt,
+      /*start_yb_controller_servers=*/true));
+  ASSERT_OK(SetUpSequences(&producer_cluster_, namespace1));
+
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces({namespace1}));
+}
+
 }  // namespace yb
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
index 51e572709e..70cb234b93 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
@@ -1015,6 +1015,9 @@ Status XClusterYsqlTestBase::CreateReplicationFromCheckpoint(
   if (master_addr.empty()) {
     master_addr = consumer_cluster()->GetMasterAddresses();
   }
+  if (namespace_names.empty()) {
+    namespace_names = {namespace_name};
+  }
 
   RETURN_NOT_OK(client::XClusterClient(*producer_client())
                     .CreateXClusterReplicationFromCheckpoint(replication_group_id, master_addr));
diff --git a/src/yb/master/master_replication.proto b/src/yb/master/master_replication.proto
index b967c8ee99..ad0ad35056 100644
--- a/src/yb/master/master_replication.proto
+++ b/src/yb/master/master_replication.proto
@@ -621,6 +621,15 @@ message IsXClusterBootstrapRequiredResponsePB {
   optional bool initial_bootstrap_required = 3;
 }
 
+message XClusterEnsureSequenceUpdatesAreInWalRequestPB {
+  required string replication_group_id = 1;
+  repeated string namespace_ids = 2;
+}
+
+message XClusterEnsureSequenceUpdatesAreInWalResponsePB {
+  optional MasterErrorPB error = 1;
+}
+
 message GetXClusterStreamsRequestPB {
   required string replication_group_id = 1;
   required string namespace_id = 2;
@@ -906,6 +915,8 @@ service MasterReplication {
       returns (XClusterDeleteOutboundReplicationGroupResponsePB);
   rpc IsXClusterBootstrapRequired(IsXClusterBootstrapRequiredRequestPB)
       returns (IsXClusterBootstrapRequiredResponsePB);
+  rpc XClusterEnsureSequenceUpdatesAreInWal(XClusterEnsureSequenceUpdatesAreInWalRequestPB)
+      returns (XClusterEnsureSequenceUpdatesAreInWalResponsePB);
   rpc GetXClusterStreams(GetXClusterStreamsRequestPB)
       returns (GetXClusterStreamsResponsePB);
   rpc RepairOutboundXClusterReplicationGroupAddTable(
diff --git a/src/yb/master/master_replication_service.cc b/src/yb/master/master_replication_service.cc
index ecfa60b022..97c3600279 100644
--- a/src/yb/master/master_replication_service.cc
+++ b/src/yb/master/master_replication_service.cc
@@ -84,6 +84,7 @@ class MasterReplicationServiceImpl : public MasterServiceBase, public MasterRepl
       (AlterUniverseReplication)
       (DeleteUniverseReplication)
       (InsertPackedSchemaForXClusterTarget)
+      (XClusterEnsureSequenceUpdatesAreInWal)
   )
 };
 
diff --git a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
index 441504b0c5..03b9adae7f 100644
--- a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
+++ b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
@@ -37,6 +37,7 @@
 #include "yb/tserver/pg_create_table.h"
 
 #include "yb/util/async_util.h"
+#include "yb/util/flag_validators.h"
 #include "yb/util/flags/auto_flags_util.h"
 #include "yb/util/status.h"
 #include "yb/util/status_format.h"
@@ -46,6 +47,11 @@
 DEFINE_RUNTIME_bool(check_bootstrap_required, false,
     "Is it necessary to check whether bootstrap is required for Universe Replication.");
 
+DEFINE_RUNTIME_uint32(
+    xcluster_ensure_sequence_updates_in_wal_timeout_sec, 3 * 60,
+    "Timeout for XClusterEnsureSequenceUpdatesAreInWal RPCs.");
+DEFINE_validator(xcluster_ensure_sequence_updates_in_wal_timeout_sec, FLAG_GT_VALUE_VALIDATOR(0));
+
 DEFINE_test_flag(bool, allow_ycql_transactional_xcluster, false,
     "Determines if xCluster transactional replication on YCQL tables is allowed.");
 
@@ -260,7 +266,7 @@ Status XClusterInboundReplicationGroupSetupTask::FirstStep() {
     auto local_client = master_.client_future();
     RETURN_NOT_OK(tserver::CreateSequencesDataTable(
         local_client.get(), CoarseMonoClock::now() +
-                                MonoDelta::FromSeconds(FLAGS_xcluster_ysql_statement_timeout_sec)));
+        MonoDelta::FromSeconds(FLAGS_xcluster_ysql_statement_timeout_sec)));
   }
 
   ScheduleNextStep(
@@ -277,8 +283,8 @@ Status XClusterInboundReplicationGroupSetupTask::SetupDDLReplicationExtension()
     for (const auto& namespace_id : data_.target_namespace_ids) {
       auto namespace_name = VERIFY_RESULT(catalog_manager_.FindNamespaceById(namespace_id))->name();
       Synchronizer sync;
-      LOG(INFO) << "Setting up DDL replication extension for namespace " << namespace_id << " ("
-                << namespace_name << ")";
+      LOG_WITH_PREFIX(INFO) << "Setting up DDL replication extension for namespace " << namespace_id
+                            << " (" << namespace_name << ")";
       RETURN_NOT_OK(master::SetupDDLReplicationExtension(
           catalog_manager_, namespace_name, XClusterDDLReplicationRole::kTarget,
           CoarseMonoClock::now() +
@@ -288,6 +294,29 @@ Status XClusterInboundReplicationGroupSetupTask::SetupDDLReplicationExtension()
     }
   }
 
+  if (data_.automatic_ddl_mode && FLAGS_TEST_xcluster_enable_sequence_replication &&
+      !is_alter_replication_) {
+    ScheduleNextStep(
+        std::bind(
+            &XClusterInboundReplicationGroupSetupTask::BootstrapSequencesData, shared_from(this)),
+        "BootstrapSequencesData");
+  } else {
+    ScheduleNextStep(
+        std::bind(&XClusterInboundReplicationGroupSetupTask::CreateTableTasks, shared_from(this)),
+        "CreateTableTasks");
+  }
+  return Status::OK();
+}
+
+Status XClusterInboundReplicationGroupSetupTask::BootstrapSequencesData() {
+  LOG_WITH_PREFIX(INFO) << "Bootstrapping sequences_data for namespaces "
+                        << AsString(data_.source_namespace_ids);
+
+  auto deadline = CoarseMonoClock::Now() +
+                  MonoDelta::FromSeconds(FLAGS_xcluster_ensure_sequence_updates_in_wal_timeout_sec);
+  RETURN_NOT_OK(GetXClusterClient().EnsureSequenceUpdatesAreInWal(
+      data_.replication_group_id, data_.source_namespace_ids, deadline));
+
   ScheduleNextStep(
       std::bind(&XClusterInboundReplicationGroupSetupTask::CreateTableTasks, shared_from(this)),
       "CreateTableTasks");
diff --git a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h
index 70ab98374b..f5cadab0f9 100644
--- a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h
+++ b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h
@@ -210,6 +210,7 @@ class XClusterInboundReplicationGroupSetupTask : public XClusterInboundReplicati
 
   Status FirstStep() override;
   Status SetupDDLReplicationExtension();
+  Status BootstrapSequencesData();
   Status CreateTableTasks();
 
   void TaskCompleted(const Status& status) override EXCLUDES(done_result_mutex_);
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index a340802ca9..cf38cefdfa 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -400,6 +400,18 @@ Status XClusterManager::IsXClusterBootstrapRequired(
   return Status::OK();
 }
 
+Status XClusterManager::XClusterEnsureSequenceUpdatesAreInWal(
+    const XClusterEnsureSequenceUpdatesAreInWalRequestPB* req,
+    XClusterEnsureSequenceUpdatesAreInWalResponsePB* resp, rpc::RpcContext* rpc,
+    const LeaderEpoch& epoch) {
+  LOG_FUNC_AND_RPC;
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id, namespace_ids);
+
+  std::vector<NamespaceId> namespace_ids{req->namespace_ids().begin(), req->namespace_ids().end()};
+  return EnsureSequenceUpdatesAreInWal(
+      xcluster::ReplicationGroupId(req->replication_group_id()), namespace_ids);
+}
+
 Status XClusterManager::GetXClusterStreams(
     const GetXClusterStreamsRequestPB* req, GetXClusterStreamsResponsePB* resp,
     rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
diff --git a/src/yb/master/xcluster/xcluster_manager.h b/src/yb/master/xcluster/xcluster_manager.h
index f60924d9a2..6653b190a1 100644
--- a/src/yb/master/xcluster/xcluster_manager.h
+++ b/src/yb/master/xcluster/xcluster_manager.h
@@ -167,6 +167,10 @@ class XClusterManager : public XClusterManagerIf,
   Status IsXClusterBootstrapRequired(
       const IsXClusterBootstrapRequiredRequestPB* req, IsXClusterBootstrapRequiredResponsePB* resp,
       rpc::RpcContext* rpc, const LeaderEpoch& epoch);
+  Status XClusterEnsureSequenceUpdatesAreInWal(
+      const XClusterEnsureSequenceUpdatesAreInWalRequestPB* req,
+      XClusterEnsureSequenceUpdatesAreInWalResponsePB* resp, rpc::RpcContext* rpc,
+      const LeaderEpoch& epoch);
   Status GetXClusterStreams(
       const GetXClusterStreamsRequestPB* req, GetXClusterStreamsResponsePB* resp,
       rpc::RpcContext* rpc, const LeaderEpoch& epoch);
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index 8e74cd856d..a0ce6f4c54 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -30,6 +30,7 @@
 #include "yb/master/xcluster/xcluster_outbound_replication_group.h"
 #include "yb/master/xcluster/xcluster_outbound_replication_group_tasks.h"
 #include "yb/master/xcluster/xcluster_status.h"
+#include "yb/master/ysql_sequence_util.h"
 
 #include "yb/tserver/pg_create_table.h"
 
@@ -40,6 +41,10 @@ DEFINE_RUNTIME_bool(enable_tablet_split_of_xcluster_bootstrapping_tables, false,
     "When set, it enables automatic tablet splitting for tables that are part of an "
     "xCluster replication setup and are currently being bootstrapped for xCluster.");
 
+DEFINE_test_flag(
+    bool, simulate_EnsureSequenceUpdatesAreInWal_failure, false,
+    "Simulate failure during EnsureSequenceUpdatesAreInWal RPC.");
+
 DECLARE_int32(master_yb_client_default_timeout_ms);
 DECLARE_uint32(cdc_wal_retention_time_secs);
 DECLARE_bool(TEST_disable_cdc_state_insert_on_setup);
@@ -397,6 +402,26 @@ Result<std::optional<bool>> XClusterSourceManager::IsBootstrapRequired(
   return outbound_replication_group->IsBootstrapRequired(namespace_id);
 }
 
+Status XClusterSourceManager::EnsureSequenceUpdatesAreInWal(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::vector<NamespaceId>& namespace_ids) const {
+  if (FLAGS_TEST_simulate_EnsureSequenceUpdatesAreInWal_failure) {
+    return STATUS(
+        RuntimeError,
+        "EnsureSequenceUpdatesAreInWal call failed due to test flag "
+        "simulate_EnsureSequenceUpdatesAreInWal_failure");
+  }
+  auto client = master_.client_future().get();
+  for (const auto& namespace_id : namespace_ids) {
+    uint32_t db_oid = VERIFY_RESULT(GetPgsqlDatabaseOid(namespace_id));
+    auto sequence_info = VERIFY_RESULT(ScanSequencesDataTable(*client, db_oid));
+    VLOG(1) << "Found " << sequence_info.size() << " sequences in namespace " << namespace_id;
+    RETURN_NOT_OK(::yb::master::EnsureSequenceUpdatesAreInWal(*client, db_oid, sequence_info));
+    VLOG(1) << "Successfully ensured new updates for their values in the WALs";
+  }
+  return Status::OK();
+}
+
 Result<std::optional<NamespaceCheckpointInfo>> XClusterSourceManager::GetXClusterStreams(
     const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
     const std::vector<std::pair<TableName, PgSchemaName>>& opt_table_names) const {
diff --git a/src/yb/master/xcluster/xcluster_source_manager.h b/src/yb/master/xcluster/xcluster_source_manager.h
index d389319cfa..0a6a4f3048 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.h
+++ b/src/yb/master/xcluster/xcluster_source_manager.h
@@ -113,6 +113,10 @@ class XClusterSourceManager {
       const xcluster::ReplicationGroupId& replication_group_id,
       const NamespaceId& namespace_id) const;
 
+  Status EnsureSequenceUpdatesAreInWal(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::vector<NamespaceId>& namespace_ids) const;
+
   // If opt_table_names is empty, all tables in the namespace are returned.
   Result<std::optional<NamespaceCheckpointInfo>> GetXClusterStreams(
       const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
diff --git a/src/yb/master/ysql_sequence_util.cc b/src/yb/master/ysql_sequence_util.cc
index be3a829c03..500f8134e2 100644
--- a/src/yb/master/ysql_sequence_util.cc
+++ b/src/yb/master/ysql_sequence_util.cc
@@ -146,7 +146,7 @@ Result<std::vector<YsqlSequenceInfo>> ScanSequencesDataTable(
   return results;
 }
 
-Result<int> EnsureSequenceUpdatesInWal(
+Result<int> EnsureSequenceUpdatesAreInWal(
     client::YBClient& client, uint32_t db_oid, const std::vector<YsqlSequenceInfo>& sequences) {
   auto table = VERIFY_RESULT(OpenSequencesDataTable(client));
 
diff --git a/src/yb/master/ysql_sequence_util.h b/src/yb/master/ysql_sequence_util.h
index 87e08048de..189efbcc75 100644
--- a/src/yb/master/ysql_sequence_util.h
+++ b/src/yb/master/ysql_sequence_util.h
@@ -49,7 +49,7 @@ Result<std::vector<YsqlSequenceInfo>> ScanSequencesDataTable(
 // or some other update to S in the WAL with commit timestamp after the time the scan was done.
 //
 // When successful returns the number of updates it makes.
-Result<int> EnsureSequenceUpdatesInWal(
+Result<int> EnsureSequenceUpdatesAreInWal(
     client::YBClient& client, uint32_t db_oid, const std::vector<YsqlSequenceInfo>& sequences);
 
 }  // namespace yb::master
