diff --git a/src/yb/consensus/log_util-test.cc b/src/yb/consensus/log_util-test.cc
index 260559bec4..f84e89a6e7 100644
--- a/src/yb/consensus/log_util-test.cc
+++ b/src/yb/consensus/log_util-test.cc
@@ -16,6 +16,8 @@
 #include "yb/consensus/log_util.h"
 #include "yb/util/test_macros.h"
 
+DECLARE_string(fs_data_dirs);
+
 namespace yb {
 
 #if defined(__linux__)
diff --git a/src/yb/consensus/log_util.h b/src/yb/consensus/log_util.h
index 938060fb3b..4a8c6daa2d 100644
--- a/src/yb/consensus/log_util.h
+++ b/src/yb/consensus/log_util.h
@@ -62,7 +62,6 @@
 DECLARE_bool(durable_wal_write);
 DECLARE_bool(require_durable_wal_write);
 DECLARE_string(fs_wal_dirs);
-DECLARE_string(fs_data_dirs);
 
 namespace yb {
 namespace log {
diff --git a/src/yb/integration-tests/CMakeLists.txt b/src/yb/integration-tests/CMakeLists.txt
index 4575055460..e78f623d4f 100644
--- a/src/yb/integration-tests/CMakeLists.txt
+++ b/src/yb/integration-tests/CMakeLists.txt
@@ -119,7 +119,8 @@ target_link_libraries(integration-tests
   master_test_common
   master_proto
   cdc_test_util
-  test_echo_service_proto)
+  test_echo_service_proto
+  tools_test_utils)
 
 add_dependencies(integration-tests
   "${YB_MASTER_DYNAMIC_EXE_NAME}"
diff --git a/src/yb/integration-tests/cql-backup-test.cc b/src/yb/integration-tests/cql-backup-test.cc
index 00752436fb..f67f540c7a 100644
--- a/src/yb/integration-tests/cql-backup-test.cc
+++ b/src/yb/integration-tests/cql-backup-test.cc
@@ -23,7 +23,7 @@ using std::make_unique;
 using std::string;
 using std::unique_ptr;
 
-DECLARE_bool(TEST_mini_cluster_mode);
+DECLARE_bool(TEST_use_custom_varz);
 DECLARE_bool(TEST_import_snapshot_failed);
 
 namespace yb {
@@ -38,8 +38,8 @@ class CqlBackupTest : public CqlTestBase<MiniCluster> {
   virtual ~CqlBackupTest() = default;
 
   void SetUp() override {
-    // Provide correct '--fs_data_dirs' via TS Web UI.
-    ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_mini_cluster_mode) = true;
+    // We need the following to be able to run yb-controller with internal mini cluster.
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_use_custom_varz) = true;
     CqlTestBase<MiniCluster>::SetUp();
 
     // Start Yb Controllers for backup/restore.
diff --git a/src/yb/integration-tests/external_daemon.cc b/src/yb/integration-tests/external_daemon.cc
index e96d984f6e..e461db8559 100644
--- a/src/yb/integration-tests/external_daemon.cc
+++ b/src/yb/integration-tests/external_daemon.cc
@@ -148,7 +148,10 @@ ExternalDaemon::LogTailerThread::LogTailerThread(
           lock_guard<mutex> lock(logging_mutex);
           if (stopped->load()) break;
           // Make sure we always output an end-of-line character.
-          *out << line_prefix << " " << buf << maybe_end_of_line;
+          // Use only one call to << to minimize chance of interleaving of our output with Google
+          // logging.
+          std::string output = line_prefix + " " + buf + maybe_end_of_line;
+          *out << output;
           if (!stopped->load()) {
             auto listener = listener_.load(std::memory_order_acquire);
             if (!stopped->load() && listener) {
diff --git a/src/yb/integration-tests/external_yb_controller.cc b/src/yb/integration-tests/external_yb_controller.cc
index afc7f8bb48..cda71500c4 100644
--- a/src/yb/integration-tests/external_yb_controller.cc
+++ b/src/yb/integration-tests/external_yb_controller.cc
@@ -12,6 +12,7 @@
 //
 
 #include "yb/integration-tests/external_yb_controller.h"
+
 #include <gtest/gtest.h>
 
 #include "yb/gutil/strings/join.h"
@@ -20,6 +21,7 @@
 #include "yb/util/status.h"
 #include "yb/util/status_format.h"
 #include "yb/util/test_util.h"
+#include "yb/util/thread.h"
 
 using std::string;
 
@@ -98,10 +100,15 @@ Status ExternalYbController::Start() {
     return STATUS_FORMAT(InternalError, "Failed to ping YB Controller server!");
   }
 
-  auto default_output_prefix = Format("[yb-controller-$0]", idx_);
+  std::string existing_prefix = TEST_GetThreadUnformattedLogPrefix();
+  if (!existing_prefix.empty()) {
+    existing_prefix += "-";
+  }
+  auto stdout_prefix = Format("[$0yb-controller-$1 stdout]", existing_prefix, idx_);
+  auto stderr_prefix = Format("[$0yb-controller-$1]", existing_prefix, idx_);
   auto* listener = stdout_tailer_thread_ ? stdout_tailer_thread_->listener() : nullptr;
   stdout_tailer_thread_ = std::make_unique<ExternalDaemon::LogTailerThread>(
-      Format("[yb-controller-$0 stdout]", idx_), p->ReleaseChildStdoutFd(), &std::cout);
+      stdout_prefix, p->ReleaseChildStdoutFd(), &std::cout);
   if (listener) {
     stdout_tailer_thread_->SetListener(listener);
   }
@@ -110,7 +117,7 @@ Status ExternalYbController::Start() {
   // We will mostly see stderr output from the child process (because of --logtostderr), so we'll
   // assume that by default in the output prefix.
   stderr_tailer_thread_ = std::make_unique<ExternalDaemon::LogTailerThread>(
-      default_output_prefix, p->ReleaseChildStderrFd(), &std::cerr);
+      stderr_prefix, p->ReleaseChildStderrFd(), &std::cerr);
   if (listener) {
     stderr_tailer_thread_->SetListener(listener);
   }
diff --git a/src/yb/integration-tests/mini_cluster.cc b/src/yb/integration-tests/mini_cluster.cc
index ad760edf9d..599ae499f9 100644
--- a/src/yb/integration-tests/mini_cluster.cc
+++ b/src/yb/integration-tests/mini_cluster.cc
@@ -236,16 +236,6 @@ Status MiniCluster::StartAsync(
     }
   }
 
-  string ts_data_dirs;
-  for (const shared_ptr<MiniTabletServer>& ts : mini_tablet_servers_) {
-    for (const string& dir : ts->options()->fs_opts.data_paths) {
-      ts_data_dirs += string(ts_data_dirs.empty() ? "" : ",") +  dir;
-    }
-  }
-  // All TSes have the same following g-flags, because this is all-in-one-process MiniCluster.
-  // Use ExternalMiniCluster if you need independent values.
-  ANNOTATE_UNPROTECTED_WRITE(FLAGS_fs_data_dirs) = ts_data_dirs;
-
   running_ = true;
   rpc::MessengerBuilder builder("minicluster-messenger");
   builder.set_num_reactors(1);
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
index 3601302aff..0dcb51f5f1 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
@@ -121,6 +121,32 @@ TEST_F(XClusterDDLReplicationTest, DDLReplicationTablesNotColocated) {
   }
 }
 
+TEST_F(XClusterDDLReplicationTest, Bootstrapping) {
+  if (!UseYbController()) {
+    GTEST_SKIP() << "This test does not work with yb_backup.py";
+  }
+
+  ASSERT_OK(SetUpClusters(/*is_colocated=*/false, /*start_yb_controller_servers=*/true));
+  auto producer_table_name = ASSERT_RESULT(CreateYsqlTable(
+      /*idx=*/1, /*num_tablets=*/3, &producer_cluster_));
+
+  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CreateReplicationFromCheckpointUsingBackupRestore());
+}
+
+// TODO(Julien): As part of #24888, undisable this or make this a test that this correctly fails
+// with an error.
+TEST_F(XClusterDDLReplicationTest, YB_DISABLE_TEST(BootstrappingWithNoTables)) {
+  if (!UseYbController()) {
+    GTEST_SKIP() << "This test does not work with yb_backup.py";
+  }
+
+  ASSERT_OK(SetUpClusters(/*is_colocated=*/false, /*start_yb_controller_servers=*/true));
+
+  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CreateReplicationFromCheckpointUsingBackupRestore());
+}
+
 TEST_F(XClusterDDLReplicationTest, CreateTable) {
   ASSERT_OK(SetUpClusters());
   ASSERT_OK(CheckpointReplicationGroup());
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
index 3849aac4b9..aecf083771 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
@@ -40,7 +40,8 @@ void XClusterDDLReplicationTestBase::SetUp() {
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_ddl_queue_handler_log_queries) = true;
 }
 
-Status XClusterDDLReplicationTestBase::SetUpClusters(bool is_colocated) {
+Status XClusterDDLReplicationTestBase::SetUpClusters(
+    bool is_colocated, bool start_yb_controller_servers) {
   if (is_colocated) {
     namespace_name = "colocated_test_db";
   }
@@ -54,6 +55,7 @@ Status XClusterDDLReplicationTestBase::SetUpClusters(bool is_colocated) {
       .num_masters = 1,
       .ranged_partitioned = false,
       .is_colocated = is_colocated,
+      .start_yb_controller_servers = start_yb_controller_servers,
   };
   return XClusterYsqlTestBase::SetUpClusters(kDefaultParams);
 }
@@ -77,6 +79,65 @@ Status XClusterDDLReplicationTestBase::CheckpointReplicationGroupWithoutRequirin
   return Status::OK();
 }
 
+Status XClusterDDLReplicationTestBase::CreateReplicationFromCheckpointUsingBackupRestore(
+    const std::string& target_master_addresses,
+    const xcluster::ReplicationGroupId& replication_group_id,
+    std::vector<NamespaceName> namespace_names, std::function<Status()> between_backup_and_restore,
+    std::function<Status()> after_restore) {
+  RETURN_NOT_OK(SetupCertificates(replication_group_id));
+
+  auto master_addr = target_master_addresses;
+  if (master_addr.empty()) {
+    master_addr = consumer_cluster()->GetMasterAddresses();
+  }
+  if (namespace_names.empty()) {
+    namespace_names = {namespace_name};
+  }
+
+  auto BackupDir = [&](NamespaceName namespace_name) {
+    return GetTempDir(Format("backup_$0", namespace_name));
+  };
+
+  // Backup databases from producer.
+  for (const auto& namespace_name : namespace_names) {
+    RETURN_NOT_OK(RunBackupCommand(
+        {"--backup_location", BackupDir(namespace_name), "--keyspace",
+         Format("ysql.$0", namespace_name), "create"},
+        &*producer_cluster_.mini_cluster_));
+  }
+
+  RETURN_NOT_OK(between_backup_and_restore());
+
+  // Restore to new databases on the consumer.
+  for (const auto& namespace_name : namespace_names) {
+    (void)DropDatabase(consumer_cluster_, namespace_name);
+    RETURN_NOT_OK(RunBackupCommand(
+        {"--backup_location", BackupDir(namespace_name), "--keyspace",
+         Format("ysql.$0", namespace_name), "restore"},
+        &*consumer_cluster_.mini_cluster_));
+  }
+
+  RETURN_NOT_OK(after_restore());
+
+  RETURN_NOT_OK(client::XClusterClient(*producer_client())
+                    .CreateXClusterReplicationFromCheckpoint(replication_group_id, master_addr));
+
+  return WaitForCreateReplicationToFinish(master_addr, namespace_names);
+}
+
+Status XClusterDDLReplicationTestBase::RunBackupCommand(
+    const std::vector<std::string>& args, MiniClusterBase* cluster) {
+  if (UseYbController()) {
+    return tools::RunYbControllerCommand(cluster, *tmp_dir_, args);
+  }
+  // We should have skipped this test but just in case fail here.
+  ADD_FAILURE()
+      << "This test does not work with yb_backup.py; did you forget to skip this in that case?";
+  return STATUS(
+      IllegalState,
+      "XClusterDDLReplicationTestBase::RunBackupCommand does not work with yb_backup.py");
+}
+
 Result<std::shared_ptr<client::YBTable>> XClusterDDLReplicationTestBase::GetProducerTable(
     const client::YBTableName& producer_table_name) {
   std::shared_ptr<client::YBTable> producer_table;
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h
index 2ff00b480d..cb4d789cd8 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h
@@ -14,6 +14,7 @@
 #pragma once
 
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
+#include "yb/tools/tools_test_utils.h"
 
 namespace yb {
 
@@ -29,7 +30,7 @@ class XClusterDDLReplicationTestBase : public XClusterYsqlTestBase {
     return true;
   }
 
-  Status SetUpClusters(bool is_colocated = false);
+  Status SetUpClusters(bool is_colocated = false, bool start_yb_controller_servers = false);
 
   Status EnableDDLReplicationExtension();
 
@@ -42,6 +43,18 @@ class XClusterDDLReplicationTestBase : public XClusterYsqlTestBase {
   Status CheckpointReplicationGroupWithoutRequiringNoBootstrapNeeded(
       const std::vector<NamespaceName>& namespace_names);
 
+  // A empty list for namespace_names (the default) means just the namespace namespace_name.
+  Status CreateReplicationFromCheckpointUsingBackupRestore(
+      const std::string& target_master_addresses = {},
+      const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId,
+      std::vector<NamespaceName> namespace_names = {},
+      std::function<Status()> between_backup_and_restore = [](){ return Status::OK(); },
+      std::function<Status()> after_restore = [](){ return Status::OK(); });
+
+  Status RunBackupCommand(const std::vector<std::string>& args, MiniClusterBase* cluster);
+
+  std::string GetTempDir(const std::string& subdir) { return tmp_dir_ / subdir; }
+
   Result<std::shared_ptr<client::YBTable>> GetProducerTable(
       const client::YBTableName& producer_table_name);
 
@@ -53,6 +66,9 @@ class XClusterDDLReplicationTestBase : public XClusterYsqlTestBase {
   Status WaitForSafeTimeToAdvanceToNowWithoutDDLQueue();
 
   Status PrintDDLQueue(Cluster& cluster);
+
+ private:
+  tools::TmpDirProvider tmp_dir_;
 };
 
 }  // namespace yb
diff --git a/src/yb/integration-tests/xcluster/xcluster_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_test_base.cc
index e7dd5aef47..7f0e0389e8 100644
--- a/src/yb/integration-tests/xcluster/xcluster_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_test_base.cc
@@ -225,7 +225,9 @@ Status XClusterTestBase::CreateDatabase(
 }
 
 Status XClusterTestBase::DropDatabase(Cluster& cluster, const std::string& namespace_name) {
-  auto conn = VERIFY_RESULT(cluster.Connect());
+  // Connect to template1 so we can delete yugabyte database if desired (you cannot DROP a database
+  // you are connected to).
+  auto conn = VERIFY_RESULT(cluster.ConnectToDB("template1"));
   return conn.ExecuteFormat("DROP DATABASE $0", namespace_name);
 }
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
index 681dcea17e..51e572709e 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
@@ -12,10 +12,12 @@
 //
 
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
+
 #include "yb/client/client.h"
 #include "yb/client/table.h"
 #include "yb/client/xcluster_client.h"
 #include "yb/client/yb_table_name.h"
+
 #include "yb/master/master_cluster.pb.h"
 #include "yb/master/master_cluster.proxy.h"
 #include "yb/master/master_ddl.pb.h"
@@ -23,12 +25,16 @@
 #include "yb/master/master_replication.proxy.h"
 #include "yb/master/mini_master.h"
 #include "yb/master/sys_catalog_initialization.h"
+
 #include "yb/server/server_base.h"
+
 #include "yb/tserver/mini_tablet_server.h"
 #include "yb/tserver/tablet_server.h"
+
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/is_operation_done_result.h"
 #include "yb/util/thread.h"
+
 #include "yb/yql/pgwrapper/libpq_utils.h"
 
 DECLARE_bool(enable_ysql);
@@ -41,6 +47,7 @@ DECLARE_int32(replication_factor);
 DECLARE_bool(enable_tablet_split_of_xcluster_replicated_tables);
 
 DECLARE_bool(TEST_create_table_with_empty_pgschema_name);
+DECLARE_bool(TEST_use_custom_varz);
 DECLARE_bool(TEST_xcluster_enable_ddl_replication);
 DECLARE_bool(TEST_xcluster_enable_sequence_replication);
 DECLARE_uint64(TEST_pg_auth_key);
@@ -94,22 +101,28 @@ Status XClusterYsqlTestBase::InitClusters(const MiniClusterOptions& opts) {
 
   auto producer_opts = opts;
   producer_opts.cluster_id = "producer";
-
   producer_cluster_.mini_cluster_ = std::make_unique<MiniCluster>(producer_opts);
 
   // Randomly select the tserver index that will serve the postgres proxy.
   const size_t pg_ts_idx = RandomUniformInt<size_t>(0, opts.num_tablet_servers - 1);
   const std::string pg_addr = server::TEST_RpcAddress(pg_ts_idx + 1, server::Private::kTrue);
-  // The 'pgsql_proxy_bind_address' flag must be set before starting the producer cluster. Each
+
+  // The 'pgsql_proxy_bind_address' flag must be set before starting each cluster.  Each
   // tserver will store this address when it starts.
   const uint16_t producer_pg_port = producer_cluster_.mini_cluster_->AllocateFreePort();
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_pgsql_proxy_bind_address) =
       Format("$0:$1", pg_addr, producer_pg_port);
+  // In order for yb-controller to access this and other gflags to find Postgres or the
+  // masters, we must make /varz reflect the startup value of these gflags.  Otherwise, both
+  // clusters will have the same information and yb-controller will only talk to one of them.
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_use_custom_varz) = true;
 
+  RETURN_NOT_OK(PreProducerCreate());
   {
     TEST_SetThreadPrefixScoped prefix_se("P");
     RETURN_NOT_OK(producer_cluster()->StartAsync());
   }
+  RETURN_NOT_OK(PostProducerCreate());
 
   auto consumer_opts = opts;
   consumer_opts.cluster_id = "consumer";
@@ -120,10 +133,12 @@ Status XClusterYsqlTestBase::InitClusters(const MiniClusterOptions& opts) {
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_pgsql_proxy_bind_address) =
       Format("$0:$1", pg_addr, consumer_pg_port);
 
+  RETURN_NOT_OK(PreConsumerCreate());
   {
     TEST_SetThreadPrefixScoped prefix_se("C");
     RETURN_NOT_OK(consumer_cluster()->StartAsync());
   }
+  RETURN_NOT_OK(PostConsumerCreate());
 
   RETURN_NOT_OK(
       RunOnBothClusters([](MiniCluster* cluster) { return cluster->WaitForAllTabletServers(); }));
@@ -157,7 +172,6 @@ Status XClusterYsqlTestBase::InitProducerClusterOnly(const MiniClusterOptions& o
 
   auto producer_opts = opts;
   producer_opts.cluster_id = "producer";
-
   producer_cluster_.mini_cluster_ = std::make_unique<MiniCluster>(producer_opts);
 
   // Randomly select the tserver index that will serve the postgres proxy.
@@ -862,6 +876,17 @@ Status XClusterYsqlTestBase::SetUpClusters(const SetupParams& params) {
 
   RETURN_NOT_OK(Initialize(params.replication_factor, params.num_masters));
 
+  if (params.start_yb_controller_servers) {
+    {
+      TEST_SetThreadPrefixScoped prefix_se("P");
+      RETURN_NOT_OK(producer_cluster_.mini_cluster_->StartYbControllerServers());
+    }
+    {
+      TEST_SetThreadPrefixScoped prefix_se("C");
+      RETURN_NOT_OK(consumer_cluster_.mini_cluster_->StartYbControllerServers());
+    }
+  }
+
   SCHECK_EQ(
       params.num_consumer_tablets.size(), params.num_producer_tablets.size(), IllegalState,
       Format(
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
index 8a672dedcb..0cc328b525 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
@@ -30,6 +30,7 @@ class XClusterYsqlTestBase : public XClusterTestBase {
     // Should setup ensure that the DBs with the same names on the source and target universes have
     // different OIDs?
     bool use_different_database_oids = false;
+    bool start_yb_controller_servers = false;
   };
 
   void SetUp() override;
diff --git a/src/yb/master/xcluster/master_xcluster_util.cc b/src/yb/master/xcluster/master_xcluster_util.cc
index a93ddb668b..ec9e5266f0 100644
--- a/src/yb/master/xcluster/master_xcluster_util.cc
+++ b/src/yb/master/xcluster/master_xcluster_util.cc
@@ -140,6 +140,8 @@ Status SetupDDLReplicationExtension(
   } else {
     // We could have older data in the table due to a backup restore from the source universe.
     // So, we drop the extension and recreate it so that we start with empty tables.
+    // TODO(#19185) Revisit this GUC disabling when we implement proper extension shutdown.
+    statements.push_back(Format("SET $0.replication_role = DISABLED", kXClusterDDLExtensionName));
     statements.push_back(Format("DROP EXTENSION IF EXISTS $0", kXClusterDDLExtensionName));
     statements.push_back(Format("CREATE EXTENSION $0", kXClusterDDLExtensionName));
   }
diff --git a/src/yb/rpc/secure_stream.cc b/src/yb/rpc/secure_stream.cc
index 1f712ef8d1..7307dccd55 100644
--- a/src/yb/rpc/secure_stream.cc
+++ b/src/yb/rpc/secure_stream.cc
@@ -43,7 +43,6 @@
 
 using namespace std::literals;
 
-DECLARE_string(fs_data_dirs);
 DEFINE_UNKNOWN_bool(allow_insecure_connections, true,
     "Whether we should allow insecure connections.");
 DEFINE_UNKNOWN_bool(dump_certificate_entries, false, "Whether we should dump certificate entries.");
diff --git a/src/yb/server/default-path-handlers.cc b/src/yb/server/default-path-handlers.cc
index 59263dbe1d..5be7393740 100644
--- a/src/yb/server/default-path-handlers.cc
+++ b/src/yb/server/default-path-handlers.cc
@@ -102,7 +102,7 @@ DEFINE_RUNTIME_uint32(max_prometheus_metric_entries, UINT32_MAX,
     "Thus, the actual number of metric entries returned might be smaller than the limit.");
 
 DECLARE_bool(track_stack_traces);
-DECLARE_bool(TEST_mini_cluster_mode);
+DECLARE_bool(TEST_use_custom_varz);
 
 namespace yb {
 
@@ -219,10 +219,11 @@ void ConvertFlagsToJson(
 std::unordered_map<FlagType, std::vector<FlagInfo>> GetFlagInfos(
     const Webserver::WebRequest& req, Webserver* webserver, bool filter_default_flags) {
   std::map<std::string, std::string> custom_varz;
-  if (FLAGS_TEST_mini_cluster_mode) {
+  if (FLAGS_TEST_use_custom_varz) {
     const string* custom_varz_ptr = FindOrNull(req.parsed_args, "TEST_custom_varz");
     if (custom_varz_ptr != nullptr) {
-      SplitStringToMapUsing(*custom_varz_ptr, "\n", &custom_varz);
+      // Note that Split does not ignore empty components so flags with value "" work.
+      custom_varz = strings::Split(*custom_varz_ptr, "\n");
     }
   }
 
diff --git a/src/yb/server/rpc_server.h b/src/yb/server/rpc_server.h
index 87b9eee99a..616e5c8ebe 100644
--- a/src/yb/server/rpc_server.h
+++ b/src/yb/server/rpc_server.h
@@ -43,6 +43,7 @@
 #include "yb/util/status_fwd.h"
 #include "yb/util/enums.h"
 #include "yb/util/net/net_fwd.h"
+#include "yb/util/tostring.h"
 
 namespace yb {
 namespace server {
@@ -53,6 +54,10 @@ struct RpcServerOptions {
   std::string rpc_bind_addresses;
   uint16_t default_port = 0;
   int32_t connection_keepalive_time_ms;
+
+  std::string ToString() const {
+    return YB_STRUCT_TO_STRING(rpc_bind_addresses, default_port, connection_keepalive_time_ms);
+  }
 };
 
 class RpcServer {
diff --git a/src/yb/server/server_base_options.cc b/src/yb/server/server_base_options.cc
index 182df5d14d..021bb0e232 100644
--- a/src/yb/server/server_base_options.cc
+++ b/src/yb/server/server_base_options.cc
@@ -32,29 +32,21 @@
 
 #include "yb/server/server_base_options.h"
 
-#include <functional>
 #include <memory>
 #include <mutex>
+#include <regex>
 #include <string>
 #include <thread>
-#include <unordered_map>
 #include <vector>
 
-#include "yb/util/logging.h"
-
 #include "yb/common/common_net.pb.h"
 
-#include "yb/gutil/macros.h"
-#include "yb/gutil/ref_counted.h"
 #include "yb/gutil/strings/join.h"
 
 #include "yb/master/master_defaults.h"
 
 #include "yb/rpc/rpc_fwd.h"
 
-#include "yb/util/faststring.h"
-#include "yb/util/flags.h"
-#include "yb/util/monotime.h"
 #include "yb/util/net/net_util.h"
 #include "yb/util/net/sockaddr.h"
 #include "yb/util/result.h"
@@ -69,7 +61,7 @@ DEFINE_UNKNOWN_int32(master_discovery_timeout_ms, 3600000,
              "Timeout for masters to discover each other during cluster creation/startup");
 TAG_FLAG(master_discovery_timeout_ms, hidden);
 
-DECLARE_bool(TEST_mini_cluster_mode);
+DECLARE_bool(TEST_use_custom_varz);
 
 DECLARE_string(placement_cloud);
 DECLARE_string(placement_region);
@@ -148,8 +140,17 @@ WebserverOptions& ServerBaseOptions::CompleteWebserverOptions() {
     }
   }
 
-  if (FLAGS_TEST_mini_cluster_mode &&  !fs_opts.data_paths.empty()) {
-    webserver_opts.TEST_custom_varz = "\nfs_data_dirs\n" + JoinStrings(fs_opts.data_paths, ",");
+  if (FLAGS_TEST_use_custom_varz) {
+    if (!fs_opts.data_paths.empty() &&
+        // Only add information about fs_data_dirs once even if called multiple times.
+        webserver_opts.TEST_custom_varz.find("fs_data_dirs") == std::string::npos) {
+      if (!webserver_opts.TEST_custom_varz.empty()) {
+        webserver_opts.TEST_custom_varz += "\n";
+      }
+      webserver_opts.TEST_custom_varz += "fs_data_dirs\n" + JoinStrings(fs_opts.data_paths, ",");
+    }
+    LOG(INFO) << "custom_varz is "
+              << std::regex_replace(webserver_opts.TEST_custom_varz, std::regex{"\n"}, " | ");
   }
 
   return webserver_opts;
diff --git a/src/yb/server/webserver.cc b/src/yb/server/webserver.cc
index e789c9336c..0d7d8ed4d5 100644
--- a/src/yb/server/webserver.cc
+++ b/src/yb/server/webserver.cc
@@ -110,8 +110,13 @@ DEFINE_RUNTIME_bool(
     "http request to https to avoid man-in-the-middle attacks. The original http request is never "
     "sent.");
 
-DEFINE_test_flag(
-    bool, mini_cluster_mode, false, "Enable special fixes for MiniCluster test cluster.");
+// This flag is used to give different internal mini cluster TServers different values of flags like
+// --tserver_master_addrs at least as far as seen via the /varz endpoint; this is necessary because
+// yb-controller uses this endpoint to figure out information on how to contact TServers and
+// masters.
+DEFINE_test_flag(bool, use_custom_varz, false,
+    "Cause /varz endpoint of TServers to output for selected gflags their values at "
+    "startup rather than their current values.");
 
 namespace yb {
 
@@ -635,7 +640,7 @@ sq_callback_result_t Webserver::Impl::RunPathHandler(const PathHandler& handler,
     BuildArgumentMap(request_info->query_string, &req.parsed_args);
   }
 
-  if (FLAGS_TEST_mini_cluster_mode) {
+  if (FLAGS_TEST_use_custom_varz) {
     // Pass custom G-flags into the request handler.
     req.parsed_args["TEST_custom_varz"] = opts_.TEST_custom_varz;
   }
diff --git a/src/yb/tserver/tablet_server_options.cc b/src/yb/tserver/tablet_server_options.cc
index 6293ad113e..0ed93de49a 100644
--- a/src/yb/tserver/tablet_server_options.cc
+++ b/src/yb/tserver/tablet_server_options.cc
@@ -36,6 +36,10 @@
 #include "yb/tserver/tserver_flags.h"
 #include "yb/util/result.h"
 
+DECLARE_string(pgsql_proxy_bind_address);
+DECLARE_string(rpc_bind_addresses);
+
+DECLARE_bool(TEST_use_custom_varz);
 
 namespace yb {
 namespace tserver {
@@ -61,8 +65,16 @@ TabletServerOptions::TabletServerOptions(server::MasterAddressesPtr master_addre
 
   SetMasterAddresses(std::move(master_addresses));
   ValidateMasterAddresses();
-}
 
+  if (FLAGS_TEST_use_custom_varz) {
+    // clang-format off
+    webserver_opts.TEST_custom_varz =
+        "pgsql_proxy_bind_address\n" + FLAGS_pgsql_proxy_bind_address +
+        "\nrpc_bind_addresses\n" + FLAGS_rpc_bind_addresses +
+        "\ntserver_master_addrs\n" + FLAGS_tserver_master_addrs;
+    // clang-format on
+  }
+}
 
 void TabletServerOptions::ValidateMasterAddresses() const {
   auto master_addresses = GetMasterAddresses();
diff --git a/src/yb/util/thread.cc b/src/yb/util/thread.cc
index 4bf6927235..8e76688e50 100644
--- a/src/yb/util/thread.cc
+++ b/src/yb/util/thread.cc
@@ -601,30 +601,34 @@ void InitThreadingInternal() {
 }
 
 // Thread local prefix used in tests to display the daemon name.
-std::string* TEST_GetThreadFormattedLogPrefix() {
+std::string* AccessThreadFormattedLogPrefix() {
   BLOCK_STATIC_THREAD_LOCAL(std::string, log_prefix);
   return log_prefix;
 }
 
-std::string* TEST_GetThreadUnformattedLogPrefix() {
+std::string* AccessThreadUnformattedLogPrefix() {
   BLOCK_STATIC_THREAD_LOCAL(std::string, log_prefix_unformatted);
   return log_prefix_unformatted;
 }
 
 void TEST_FormatAndSetThreadLogPrefix(const std::string& new_prefix) {
-  *TEST_GetThreadUnformattedLogPrefix() = new_prefix;
-  *TEST_GetThreadFormattedLogPrefix() =
+  *AccessThreadUnformattedLogPrefix() = new_prefix;
+  *AccessThreadFormattedLogPrefix() =
       new_prefix.empty() ? new_prefix : Format("[$0] ", new_prefix);
 }
 
 } // anonymous namespace
 
 const char* TEST_GetThreadLogPrefix() {
-  return TEST_GetThreadFormattedLogPrefix()->c_str();
+  return AccessThreadFormattedLogPrefix()->c_str();
+}
+
+std::string TEST_GetThreadUnformattedLogPrefix() {
+  return *AccessThreadUnformattedLogPrefix();
 }
 
 TEST_SetThreadPrefixScoped::TEST_SetThreadPrefixScoped(const std::string& prefix)
-    : old_prefix_(*TEST_GetThreadUnformattedLogPrefix()) {
+    : old_prefix_(*AccessThreadUnformattedLogPrefix()) {
   TEST_FormatAndSetThreadLogPrefix(
       Format("$0$1$2", old_prefix_, old_prefix_.empty() ? "" : "-", prefix));
 }
@@ -739,7 +743,7 @@ Thread::Thread(std::string category, std::string name, ThreadFunctor functor)
     : thread_(0),
       category_(std::move(category)),
       name_(std::move(name)),
-      TEST_log_prefix_(*TEST_GetThreadUnformattedLogPrefix()),
+      TEST_log_prefix_(*AccessThreadUnformattedLogPrefix()),
       tid_(CHILD_WAITING_TID),
       functor_(std::move(functor)),
       done_(1),
diff --git a/src/yb/util/thread.h b/src/yb/util/thread.h
index e66d862c83..1afcd2db1e 100644
--- a/src/yb/util/thread.h
+++ b/src/yb/util/thread.h
@@ -56,6 +56,7 @@ class Thread;
 class WebCallbackRegistry;
 
 const char* TEST_GetThreadLogPrefix();
+std::string TEST_GetThreadUnformattedLogPrefix();
 
 class TEST_SetThreadPrefixScoped {
  public:
diff --git a/src/yb/yql/pgwrapper/pg_master_failover-test.cc b/src/yb/yql/pgwrapper/pg_master_failover-test.cc
index 9ac8e05d65..157d81cdd0 100644
--- a/src/yb/yql/pgwrapper/pg_master_failover-test.cc
+++ b/src/yb/yql/pgwrapper/pg_master_failover-test.cc
@@ -12,6 +12,7 @@
 //
 
 #include <vector>
+
 #include "yb/master/mini_master.h"
 #include "yb/master/ts_manager.h"
 
@@ -26,6 +27,7 @@
 using namespace std::literals;
 
 DECLARE_bool(TEST_timeout_non_leader_master_rpcs);
+DECLARE_bool(TEST_use_custom_varz);
 
 namespace yb::pgwrapper {
 
@@ -33,6 +35,11 @@ YB_STRONGLY_TYPED_BOOL(WaitForTS);
 
 class PgMasterFailoverTest : public PgMiniTestBase {
  protected:
+  void SetUp() override {
+    // We need the following to be able to run yb-controller with internal mini cluster.
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_use_custom_varz) = true;
+    PgMiniTestBase::SetUp();
+  }
   void ElectNewLeaderAfterShutdown();
   void TestNonRespondingMaster(WaitForTS wait_for_ts);
  public:
