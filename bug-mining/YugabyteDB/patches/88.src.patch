diff --git a/src/yb/client/client-internal.cc b/src/yb/client/client-internal.cc
index 70318ba0d5..f166da5741 100644
--- a/src/yb/client/client-internal.cc
+++ b/src/yb/client/client-internal.cc
@@ -255,11 +255,11 @@ YB_CLIENT_SPECIALIZE_SIMPLE(IsAlterTableDone);
 YB_CLIENT_SPECIALIZE_SIMPLE(IsCreateNamespaceDone);
 YB_CLIENT_SPECIALIZE_SIMPLE(IsCreateTableDone);
 YB_CLIENT_SPECIALIZE_SIMPLE(IsDeleteNamespaceDone);
-YB_CLIENT_SPECIALIZE_SIMPLE(IsCloneDone);
 YB_CLIENT_SPECIALIZE_SIMPLE(IsDeleteTableDone);
 YB_CLIENT_SPECIALIZE_SIMPLE(IsFlushTablesDone);
 YB_CLIENT_SPECIALIZE_SIMPLE(GetCompactionStatus);
 YB_CLIENT_SPECIALIZE_SIMPLE(IsTruncateTableDone);
+YB_CLIENT_SPECIALIZE_SIMPLE(ListClones);
 YB_CLIENT_SPECIALIZE_SIMPLE(ListNamespaces);
 YB_CLIENT_SPECIALIZE_SIMPLE(ListTablegroups);
 YB_CLIENT_SPECIALIZE_SIMPLE(ListTables);
@@ -1121,11 +1121,11 @@ Status YBClient::Data::WaitForDeleteNamespaceToFinish(YBClient* client,
 }
 
 Status YBClient::Data::IsCloneNamespaceInProgress(
-    YBClient* client, const std::string& source_namespace_id, int clone_seq_no,
+    YBClient* client, const std::string& source_namespace_id, uint32_t clone_seq_no,
     CoarseTimePoint deadline, bool* create_in_progress) {
   DCHECK_ONLY_NOTNULL(create_in_progress);
-  IsCloneDoneRequestPB req;
-  IsCloneDoneResponsePB resp;
+  ListClonesRequestPB req;
+  ListClonesResponsePB resp;
 
   req.set_source_namespace_id(source_namespace_id);
   req.set_seq_no(clone_seq_no);
@@ -1133,22 +1133,27 @@ Status YBClient::Data::IsCloneNamespaceInProgress(
   // and SyncLeaderMasterRpc must be explicitly instantiated, else the
   // compiler complains.
   const Status s = SyncLeaderMasterRpc(
-      deadline, req, &resp, "IsCloneDone", &master::MasterBackupProxy::IsCloneDoneAsync);
+      deadline, req, &resp, "ListClones", &master::MasterBackupProxy::ListClonesAsync);
 
   RETURN_NOT_OK(s);
-  // IsCloneDone could return a terminal/done state as FAILED. This would result in an error'd
+  // ListClones could return a terminal/done state as FAILED. This would result in an error'd
   // Status.
   if (resp.has_error()) {
     return StatusFromPB(resp.error().status());
   }
 
-  *create_in_progress = !resp.is_done();
+  if (resp.entries_size() != 1) {
+    return STATUS_FORMAT(InternalError, "Expected 1 clone entry, got $0", resp.entries_size());
+  }
+  auto state = resp.entries(0).aggregate_state();
+  *create_in_progress =
+      !(state == master::SysCloneStatePB::ABORTED || state == master::SysCloneStatePB::RESTORED);
 
   return Status::OK();
 }
 
 Status YBClient::Data::WaitForCloneNamespaceToFinish(
-    YBClient* client, const std::string& source_namespace_id, int clone_seq_no,
+    YBClient* client, const std::string& source_namespace_id, uint32_t clone_seq_no,
     CoarseTimePoint deadline) {
   return RetryFunc(
       deadline, "Waiting on Clone Namespace to be completed",
diff --git a/src/yb/client/client-internal.h b/src/yb/client/client-internal.h
index 9180ac031a..20d18a39f1 100644
--- a/src/yb/client/client-internal.h
+++ b/src/yb/client/client-internal.h
@@ -118,10 +118,10 @@ class YBClient::Data {
                                         CoarseTimePoint deadline);
 
   Status IsCloneNamespaceInProgress(
-      YBClient* client, const std::string& source_namespace_id, int clone_seq_no,
+      YBClient* client, const std::string& source_namespace_id, uint32_t clone_seq_no,
       CoarseTimePoint deadline, bool* create_in_progress);
   Status WaitForCloneNamespaceToFinish(
-      YBClient* client, const std::string& source_namespace_id, int clone_seq_no,
+      YBClient* client, const std::string& source_namespace_id, uint32_t clone_seq_no,
       CoarseTimePoint deadline);
 
   Status CreateTable(YBClient* client,
diff --git a/src/yb/client/clone_namespace-test.cc b/src/yb/client/clone_namespace-test.cc
index 7951b066e7..78d1d391ec 100644
--- a/src/yb/client/clone_namespace-test.cc
+++ b/src/yb/client/clone_namespace-test.cc
@@ -55,19 +55,23 @@ class CloneNamespaceTest : public SnapshotScheduleTest {
     }
 
     // Wait until clone is done.
-    master::IsCloneDoneRequestPB done_req;
-    master::IsCloneDoneResponsePB done_resp;
+    master::ListClonesRequestPB done_req;
+    master::ListClonesResponsePB done_resp;
     done_req.set_seq_no(clone_resp.seq_no());
     done_req.set_source_namespace_id(clone_resp.source_namespace_id());
     RETURN_NOT_OK(WaitFor([&]() -> Result<bool> {
       controller.Reset();
-      RETURN_NOT_OK(backup_proxy.IsCloneDone(done_req, &done_resp, &controller));
+      RETURN_NOT_OK(backup_proxy.ListClones(done_req, &done_resp, &controller));
       if (done_resp.has_error()) {
         return StatusFromPB(clone_resp.error().status());
       }
-      return done_resp.is_done();
+      RSTATUS_DCHECK(
+          done_resp.entries_size() == 1, IllegalState,
+          Format("Expected 1 clone entry, got $0", done_resp.entries_size()));
+      auto state = done_resp.entries(0).aggregate_state();
+      return state == master::SysCloneStatePB::ABORTED ||
+             state == master::SysCloneStatePB::RESTORED;
     }, 60s, "Wait for clone to finish"));
-
     return Status::OK();
   }
   const std::string kTargetNamespaceName = "clone_namespace";
diff --git a/src/yb/integration-tests/minicluster-snapshot-test.cc b/src/yb/integration-tests/minicluster-snapshot-test.cc
index a519ac1551..7725d75246 100644
--- a/src/yb/integration-tests/minicluster-snapshot-test.cc
+++ b/src/yb/integration-tests/minicluster-snapshot-test.cc
@@ -538,18 +538,23 @@ class PgCloneTest : public PostgresMiniClusterTest {
     }
 
     // Wait until clone is done.
-    master::IsCloneDoneRequestPB done_req;
-    master::IsCloneDoneResponsePB done_resp;
+    master::ListClonesRequestPB done_req;
+    master::ListClonesResponsePB done_resp;
     done_req.set_seq_no(clone_resp.seq_no());
     done_req.set_source_namespace_id(clone_resp.source_namespace_id());
     RETURN_NOT_OK(WaitFor(
         [&]() -> Result<bool> {
           controller.Reset();
-          RETURN_NOT_OK(master_backup_proxy_->IsCloneDone(done_req, &done_resp, &controller));
+          RETURN_NOT_OK(master_backup_proxy_->ListClones(done_req, &done_resp, &controller));
           if (done_resp.has_error()) {
             return StatusFromPB(clone_resp.error().status());
           }
-          return done_resp.is_done();
+          RSTATUS_DCHECK(
+              done_resp.entries_size() == 1, IllegalState,
+              Format("Expected 1 clone entry, got $0", done_resp.entries_size()));
+          auto state = done_resp.entries(0).aggregate_state();
+          return state == master::SysCloneStatePB::RESTORED ||
+                 state == master::SysCloneStatePB::ABORTED;
         },
         120s, "Wait for clone to finish"));
 
diff --git a/src/yb/master/clone/clone_state_entity.h b/src/yb/master/clone/clone_state_entity.h
index cdeb0061f4..120b02634e 100644
--- a/src/yb/master/clone/clone_state_entity.h
+++ b/src/yb/master/clone/clone_state_entity.h
@@ -75,6 +75,13 @@ class CloneStateInfo : public RefCountedThreadSafe<CloneStateInfo>,
   DISALLOW_COPY_AND_ASSIGN(CloneStateInfo);
 };
 
+struct CloneStateInfoComparator {
+    bool operator()(const CloneStateInfoPtr& a, const CloneStateInfoPtr& b) const {
+        return a->LockForRead()->pb.clone_request_seq_no() <
+               b->LockForRead()->pb.clone_request_seq_no();
+    }
+};
+
 DECLARE_MULTI_INSTANCE_LOADER_CLASS(CloneState, std::string, SysCloneStatePB);
 
 } // namespace yb::master
diff --git a/src/yb/master/clone/clone_state_manager-test.cc b/src/yb/master/clone/clone_state_manager-test.cc
index d94257d615..e504ed6575 100644
--- a/src/yb/master/clone/clone_state_manager-test.cc
+++ b/src/yb/master/clone/clone_state_manager-test.cc
@@ -273,8 +273,15 @@ class CloneStateManagerTest : public YBTest {
     return clone_state_manager_->HandleRestoringState(clone_state);
   }
 
-  Result<CloneStateInfoPtr> GetCloneStateFromSourceNamespace(const NamespaceId& namespace_id) {
-    return clone_state_manager_->GetCloneStateFromSourceNamespace(namespace_id);
+  CloneStateManager::CloneStateSet GetCloneStates() {
+    std::lock_guard lock(clone_state_manager_->mutex_);
+    return clone_state_manager_->source_clone_state_map_.at(kSourceNamespaceId);
+  }
+
+  CloneStateInfoPtr GetLatestCloneState() {
+    auto clone_states = GetCloneStates();
+    DCHECK(!clone_states.empty());
+    return *clone_states.rbegin();
   }
 
   Status ScheduleCloneOps(
@@ -282,7 +289,6 @@ class CloneStateManagerTest : public YBTest {
       const std::unordered_set<TabletId>& not_snapshotted_tablets) {
     return clone_state_manager_->ScheduleCloneOps(clone_state, epoch, not_snapshotted_tablets);
   }
-
   Result<std::pair<NamespaceId, uint32_t>> CloneNamespace(
       const NamespaceIdentifierPB& source_namespace_identifier,
       const HybridTime& restore_time,
@@ -301,6 +307,13 @@ class CloneStateManagerTest : public YBTest {
       clone_state, snapshot_schedule_id, target_namespace_name, deadline, epoch);
   }
 
+  void AssertCloneIsAborted() {
+    auto clone_state = GetLatestCloneState();
+    auto lock = clone_state->LockForRead();
+    ASSERT_EQ(lock->pb.aggregate_state(), SysCloneStatePB::ABORTED);
+    ASSERT_FALSE(lock->pb.abort_message().empty());
+  }
+
   MockExternalFunctions& MockFuncs() {
     return static_cast<MockExternalFunctions&>(*clone_state_manager_->external_funcs_);
   }
@@ -352,8 +365,7 @@ TEST_F(CloneStateManagerTest, CreateCloneState) {
   ASSERT_TRUE(same) << diff;
 
   // Check clone state manager in-memory fields.
-  ASSERT_EQ(ASSERT_RESULT(
-      GetCloneStateFromSourceNamespace(kSourceNamespaceId)), clone_state);
+  ASSERT_EQ(GetLatestCloneState(), clone_state);
 }
 
 TEST_F(CloneStateManagerTest, CreateSecondCloneState) {
@@ -363,7 +375,7 @@ TEST_F(CloneStateManagerTest, CreateSecondCloneState) {
 
   for (int i = SysCloneStatePB::State_MIN; i <= SysCloneStatePB::State_MAX; ++i) {
     auto state = SysCloneStatePB_State(i);
-    auto current_clone_state = ASSERT_RESULT(GetCloneStateFromSourceNamespace(kSourceNamespaceId));
+    auto current_clone_state = GetLatestCloneState();
 
     LOG(INFO) << "Setting previous state to " << SysCloneStatePB::State_Name(state);
     auto l = current_clone_state->LockForWrite();
@@ -517,12 +529,6 @@ TEST_F(CloneStateManagerTest, HandleRestoringStateRestored) {
   ASSERT_EQ(clone_state->LockForRead()->pb.aggregate_state(), SysCloneStatePB::RESTORED);
 }
 
-void AssertCloneIsAborted(const CloneStateInfoPtr& clone_state) {
-  auto lock = clone_state->LockForRead();
-  ASSERT_EQ(lock->pb.aggregate_state(), SysCloneStatePB::ABORTED);
-  ASSERT_FALSE(lock->pb.abort_message().empty());
-}
-
 TEST_F(CloneStateManagerTest, AbortInStartTabletsCloning) {
   EXPECT_CALL(MockFuncs(), FindNamespace).WillOnce(Return(source_ns_));
   EXPECT_CALL(MockFuncs(), ListSnapshotSchedules)
@@ -535,7 +541,7 @@ TEST_F(CloneStateManagerTest, AbortInStartTabletsCloning) {
       source_ns_identifier_, kRestoreTime, kTargetNamespaceName,
       CoarseMonoClock::Now() + 10s /* deadline */, kEpoch));
 
-  AssertCloneIsAborted(ASSERT_RESULT(GetCloneStateFromSourceNamespace(kSourceNamespaceId)));
+  AssertCloneIsAborted();
 }
 
 TEST_F_EX(CloneStateManagerTest, AbortIfFailToSchedulePgCloneSchema, CloneStateManagerPgTest) {
@@ -552,7 +558,7 @@ TEST_F_EX(CloneStateManagerTest, AbortIfFailToSchedulePgCloneSchema, CloneStateM
       source_ns_identifier_, kRestoreTime, kTargetNamespaceName,
       CoarseMonoClock::Now() + 10s /* deadline */, kEpoch));
 
-  AssertCloneIsAborted(ASSERT_RESULT(GetCloneStateFromSourceNamespace(kSourceNamespaceId)));
+  AssertCloneIsAborted();
 }
 
 TEST_F_EX(CloneStateManagerTest, AbortInPgSchemaClone, CloneStateManagerPgTest) {
@@ -566,7 +572,7 @@ TEST_F_EX(CloneStateManagerTest, AbortInPgSchemaClone, CloneStateManagerPgTest)
   EXPECT_CALL(MockFuncs(), Upsert(_));
   ASSERT_OK(callback(STATUS_FORMAT(IllegalState, "Fail pg schema clone for test")));
 
-  AssertCloneIsAborted(clone_state);
+  AssertCloneIsAborted();
 }
 
 TEST_F_EX(CloneStateManagerTest, AbortInStartTabletsCloningPg, CloneStateManagerPgTest) {
@@ -582,7 +588,7 @@ TEST_F_EX(CloneStateManagerTest, AbortInStartTabletsCloningPg, CloneStateManager
   EXPECT_CALL(MockFuncs(), Upsert(_));
   ASSERT_OK(callback(Status::OK() /* pg_schema_cloning_status */));
 
-  AssertCloneIsAborted(clone_state);
+  AssertCloneIsAborted();
 }
 
 TEST_F(CloneStateManagerTest, AbortInCreatingState) {
@@ -594,7 +600,7 @@ TEST_F(CloneStateManagerTest, AbortInCreatingState) {
   EXPECT_CALL(MockFuncs(), Upsert(_));
   ASSERT_OK(clone_state_manager_->Run());
 
-  AssertCloneIsAborted(clone_state);
+  AssertCloneIsAborted();
 }
 
 TEST_F(CloneStateManagerTest, AbortInRestoringState) {
@@ -611,92 +617,51 @@ TEST_F(CloneStateManagerTest, AbortInRestoringState) {
   EXPECT_CALL(MockFuncs(), Upsert(_));
   ASSERT_OK(clone_state_manager_->Run());
 
-  AssertCloneIsAborted(clone_state);
+  AssertCloneIsAborted();
 }
 
 TEST_F(CloneStateManagerTest, Load) {
-  auto clone_state = ASSERT_RESULT(CreateCloneStateAndStartCloning());
-  {
-    auto lock = clone_state->LockForWrite();
-    lock.mutable_data()->pb.set_aggregate_state(SysCloneStatePB::RESTORED);
-    lock.mutable_data()->pb.set_target_namespace_name(kTargetNamespaceName);
-    lock.mutable_data()->pb.set_restore_time(kRestoreTime.ToUint64());
-    lock.mutable_data()->pb.set_clone_request_seq_no(kSeqNo);
-    lock.Commit();
-  }
+  // Check that multiple clone states are all loaded and can be queried with ListClones.
+  SysCloneStatePB clone_state1;
+  clone_state1.set_aggregate_state(SysCloneStatePB::RESTORED);
+  clone_state1.set_source_namespace_id(kSourceNamespaceId);
+  clone_state1.set_target_namespace_name(kTargetNamespaceName);
+  clone_state1.set_restore_time(kRestoreTime.ToUint64());
+  clone_state1.set_clone_request_seq_no(kSeqNo);
+
+  SysCloneStatePB clone_state2;
+  clone_state2.set_aggregate_state(SysCloneStatePB::ABORTED);
+  clone_state2.set_source_namespace_id(kSourceNamespaceId);
+  clone_state2.set_abort_message("Test abort message");
+  clone_state2.set_target_namespace_name(kTargetNamespaceName);
+  clone_state2.set_restore_time(kRestoreTime.ToUint64() + 1);
+  clone_state2.set_clone_request_seq_no(kSeqNo + 1);
 
   // When the loader runs, we will save the function that is normally passed to
   // sys_catalog Load in 'inserter'.
   std::function<Status(const std::string&, const SysCloneStatePB&)> inserter;
   EXPECT_CALL(MockFuncs(), Load)
-      .WillOnce(DoAll(SaveArg<1>(&inserter), Return(Status::OK())));
+      .WillRepeatedly(DoAll(SaveArg<1>(&inserter), Return(Status::OK())));
   ASSERT_OK(clone_state_manager_->ClearAndRunLoaders());
 
-  // Run the inserter to actually load the data.
-  ASSERT_OK(inserter(clone_state->id(), clone_state->LockForRead()->pb));
-
-  auto loaded_clone_state = ASSERT_RESULT(GetCloneStateFromSourceNamespace(kSourceNamespaceId));
+  // Run the inserter to actually load the data. Load them in reverse order to test that the
+  // clone state map ordering works.
+  ASSERT_OK(inserter(GenerateObjectId(), clone_state2));
+  ASSERT_OK(inserter(GenerateObjectId(), clone_state1));
 
-  // The loaded clone state should be a new object.
-  ASSERT_NE(clone_state, loaded_clone_state);
+  ListClonesRequestPB req;
+  ListClonesResponsePB resp;
+  req.set_source_namespace_id(kSourceNamespaceId);
+  ASSERT_OK(clone_state_manager_->ListClones(&req, &resp));
+  ASSERT_FALSE(resp.has_error()) << resp.error().ShortDebugString();
+  ASSERT_EQ(resp.entries_size(), 2);
 
+  // Check that the clone states were loaded correctly.
   std::string diff;
-  bool same = pb_util::ArePBsEqual(clone_state->LockForRead()->pb,
-                                   loaded_clone_state->LockForRead()->pb, &diff);
+  bool same = pb_util::ArePBsEqual(clone_state1, resp.entries(0), &diff);
+  ASSERT_TRUE(same) << diff;
+  same = pb_util::ArePBsEqual(clone_state2, resp.entries(1), &diff);
   ASSERT_TRUE(same) << diff;
-}
-
-TEST_F(CloneStateManagerTest, LoadUsesLatestSeqNo) {
-  // When there are multiple clone state infos, we should load the one with the latest seq_no.
-
-  // Mark the clone state as RESTORED otherwise we will not be able to create the next clone state.
-  auto clone_state1 = ASSERT_RESULT(CreateCloneStateAndStartCloning());
-  {
-    auto lock = clone_state1->LockForWrite();
-    lock.mutable_data()->pb.set_aggregate_state(SysCloneStatePB::RESTORED);
-    lock.Commit();
-  }
-
-  auto clone_state2 = ASSERT_RESULT(CreateSecondCloneState());
-  {
-    auto lock = clone_state2->LockForWrite();
-    lock.mutable_data()->pb.set_aggregate_state(SysCloneStatePB::RESTORED);
-    lock.Commit();
-  }
-
-  // Should load clone_state2 since it has a higher seq_no.
-  {
-    // When the loader runs, we will save the function that is normally passed to
-    // sys_catalog Load in 'inserter'.
-    std::function<Status(const std::string&, const SysCloneStatePB&)> inserter;
-    EXPECT_CALL(MockFuncs(), Load)
-        .WillRepeatedly(DoAll(SaveArg<1>(&inserter), Return(Status::OK())));
-    ASSERT_OK(clone_state_manager_->ClearAndRunLoaders());
-
-    // Run the inserter to actually load the data.
-    ASSERT_OK(inserter(clone_state1->id(), clone_state1->LockForRead()->pb));
-    ASSERT_OK(inserter(clone_state2->id(), clone_state2->LockForRead()->pb));
-
-    // Should overwrite the first clone state.
-    auto loaded_clone_state = ASSERT_RESULT(GetCloneStateFromSourceNamespace(kSourceNamespaceId));
-    ASSERT_EQ(loaded_clone_state->LockForRead()->pb.clone_request_seq_no(),
-              clone_state2->LockForRead()->pb.clone_request_seq_no());
-  }
-
-  // Same test as above but with the reversed sys catalog load order.
-  {
-    std::function<Status(const std::string&, const SysCloneStatePB&)> inserter;
-    EXPECT_CALL(MockFuncs(), Load)
-        .WillRepeatedly(DoAll(SaveArg<1>(&inserter), Return(Status::OK())));
-    ASSERT_OK(clone_state_manager_->ClearAndRunLoaders());
-
-    ASSERT_OK(inserter(clone_state2->id(), clone_state2->LockForRead()->pb));
-    ASSERT_OK(inserter(clone_state1->id(), clone_state1->LockForRead()->pb));
-
-    auto loaded_clone_state = ASSERT_RESULT(GetCloneStateFromSourceNamespace(kSourceNamespaceId));
-    ASSERT_EQ(loaded_clone_state->LockForRead()->pb.clone_request_seq_no(),
-              clone_state2->LockForRead()->pb.clone_request_seq_no());
-  }
 }
 
 TEST_F(CloneStateManagerTest, AbortIncompleteCloneOnLoad) {
@@ -731,7 +696,7 @@ TEST_F(CloneStateManagerTest, AbortIncompleteCloneOnLoad) {
       EXPECT_CALL(MockFuncs(), Upsert(_));
     }
     ASSERT_OK(inserter(clone_state->id(), orig_lock->pb));
-    auto loaded_clone_state = ASSERT_RESULT(GetCloneStateFromSourceNamespace(kSourceNamespaceId));
+    auto loaded_clone_state = GetLatestCloneState();
     auto loaded_lock = loaded_clone_state->LockForRead();
 
     // The state should change to ABORTED if and only if the clone is in a non-terminal state.
diff --git a/src/yb/master/clone/clone_state_manager.cc b/src/yb/master/clone/clone_state_manager.cc
index 68de46ec88..898395f20c 100644
--- a/src/yb/master/clone/clone_state_manager.cc
+++ b/src/yb/master/clone/clone_state_manager.cc
@@ -169,20 +169,30 @@ CloneStateManager::CloneStateManager(
     std::unique_ptr<CloneStateManagerExternalFunctionsBase> external_funcs):
     external_funcs_(std::move(external_funcs)) {}
 
-Status CloneStateManager::IsCloneDone(
-    const IsCloneDoneRequestPB* req, IsCloneDoneResponsePB* resp) {
-  auto clone_state = VERIFY_RESULT(GetCloneStateFromSourceNamespace(req->source_namespace_id()));
-  auto lock = clone_state->LockForRead();
-  auto seq_no = req->seq_no();
-  auto current_seq_no = lock->pb.clone_request_seq_no();
-  if (current_seq_no > seq_no) {
-    resp->set_is_done(true);
-  } else if (current_seq_no == seq_no) {
-    resp->set_is_done(lock->IsDone());
-  } else {
-    return STATUS_FORMAT(IllegalState,
-        "Clone seq_no $0 never started for namespace $1 (current seq no $2)",
-        seq_no, req->source_namespace_id(), current_seq_no);
+Status CloneStateManager::ListClones(const ListClonesRequestPB* req, ListClonesResponsePB* resp) {
+  if (!req->has_source_namespace_id()) {
+    return STATUS_FORMAT(InvalidArgument, "Missing source namespace id in request: $0",
+                         req->ShortDebugString());
+  }
+
+  // Get matching clone states.
+  std::vector<CloneStateInfoPtr> clone_states;
+  {
+    std::lock_guard l(mutex_);
+    auto it = source_clone_state_map_.find(req->source_namespace_id());
+    if (it != source_clone_state_map_.end()) {
+      std::copy_if(
+        it->second.begin(), it->second.end(), std::back_inserter(clone_states),
+        [req](const auto& clone) {
+          return !req->has_seq_no() ||
+                 req->seq_no() == clone->LockForRead()->pb.clone_request_seq_no();
+      });
+    }
+  }
+
+  // Populate the response.
+  for (const auto& clone_state : clone_states) {
+    *resp->add_entries() = clone_state->LockForRead()->pb;
   }
   return Status::OK();
 }
@@ -359,36 +369,25 @@ Status CloneStateManager::ClearAndRunLoaders() {
 Status CloneStateManager::LoadCloneState(const std::string& id, const SysCloneStatePB& metadata) {
   auto clone_state = CloneStateInfoPtr(new CloneStateInfo(id));
   clone_state->Load(metadata);
-  std::lock_guard lock(mutex_);
 
   std::string source_namespace_id;
-  uint32_t seq_no;
   bool is_done;
   {
+    // Release the read lock before calling MarkCloneAborted to avoid deadlock.
     auto read_lock = clone_state->LockForRead();
     source_namespace_id = read_lock->pb.source_namespace_id();
-    seq_no = read_lock->pb.clone_request_seq_no();
     is_done = read_lock->IsDone();
   }
 
-  auto it = source_clone_state_map_.find(source_namespace_id);
-  if (it != source_clone_state_map_.end()) {
-    auto existing_seq_no = it->second->LockForRead()->pb.clone_request_seq_no();
-    LOG(INFO) << Format(
-        "Found existing clone state for source namespace $0 with seq_no $1. This clone "
-        "state's seq_no is $2", source_namespace_id, existing_seq_no, seq_no);
-    if (seq_no < existing_seq_no) {
-      // Do not overwrite the higher seq_no clone state.
-      return Status::OK();
-    }
-    // TODO: Delete clone state with lower seq_no from sys catalog.
-  }
-
   // Abort the clone if it was not in a terminal state.
   if (!is_done) {
     RETURN_NOT_OK(MarkCloneAborted(clone_state, "aborted by master failover"));
   }
-  source_clone_state_map_[source_namespace_id] = clone_state;
+
+  {
+    std::lock_guard lock(mutex_);
+    source_clone_state_map_[source_namespace_id].insert(clone_state);
+  }
   return Status::OK();
 }
 
@@ -397,15 +396,19 @@ Result<CloneStateInfoPtr> CloneStateManager::CreateCloneState(
     const NamespaceId& source_namespace_id,
     const std::string& target_namespace_name,
     const HybridTime& restore_time) {
+  // Check if there is an ongoing clone for the source namespace.
   std::lock_guard lock(mutex_);
   auto it = source_clone_state_map_.find(source_namespace_id);
   if (it != source_clone_state_map_.end()) {
-    auto lock = it->second->LockForRead();
-    if (!lock->IsDone()) {
-      return STATUS_FORMAT(
-          AlreadyPresent, "Cannot create new clone state because there is already an ongoing "
-          "clone for source namespace $0 in state $1", source_namespace_id,
-          lock->pb.aggregate_state());
+    auto latest_clone_it = it->second.rbegin();
+    if (latest_clone_it != it->second.rend()) {
+      auto lock = (*latest_clone_it)->LockForRead();
+      if (!lock->IsDone()) {
+        return STATUS_FORMAT(
+            AlreadyPresent, "Cannot create new clone state because there is already an ongoing "
+            "clone for source namespace $0 in state $1", source_namespace_id,
+            lock->pb.aggregate_state());
+      }
     }
   }
 
@@ -421,7 +424,7 @@ Result<CloneStateInfoPtr> CloneStateManager::CreateCloneState(
   clone_state->mutable_metadata()->CommitMutation();
 
   // Add to the in-memory map.
-  source_clone_state_map_[source_namespace_id] = clone_state;
+  source_clone_state_map_[source_namespace_id].insert(clone_state);
 
   return clone_state;
 }
@@ -497,12 +500,6 @@ Status CloneStateManager::ScheduleCloneOps(
   return Status::OK();
 }
 
-Result<CloneStateInfoPtr> CloneStateManager::GetCloneStateFromSourceNamespace(
-    const NamespaceId& namespace_id) {
-  std::lock_guard lock(mutex_);
-  return FIND_OR_STATUS(source_clone_state_map_, namespace_id);
-}
-
 AsyncClonePgSchema::ClonePgSchemaCallbackType CloneStateManager::MakeDoneClonePgSchemaCallback(
     CloneStateInfoPtr clone_state, const SnapshotScheduleId& snapshot_schedule_id,
     const std::string& target_namespace_name,
@@ -596,14 +593,15 @@ Status CloneStateManager::Run() {
     std::lock_guard lock(mutex_);
     source_clone_state_map = source_clone_state_map_;
   }
-  for (auto& [source_namespace_id, clone_state] : source_clone_state_map) {
+  for (auto& [source_namespace_id, clone_states] : source_clone_state_map) {
     Status s;
-    switch (clone_state->LockForRead()->pb.aggregate_state()) {
+    auto& latest_clone_state = *clone_states.rbegin();
+    switch (latest_clone_state->LockForRead()->pb.aggregate_state()) {
       case SysCloneStatePB::CREATING:
-        s = HandleCreatingState(clone_state);
+        s = HandleCreatingState(latest_clone_state);
         break;
       case SysCloneStatePB::RESTORING:
-        s = HandleRestoringState(clone_state);
+        s = HandleRestoringState(latest_clone_state);
         break;
       case SysCloneStatePB::CLONE_SCHEMA_STARTED: FALLTHROUGH_INTENDED;
       case SysCloneStatePB::RESTORED: FALLTHROUGH_INTENDED;
@@ -611,7 +609,7 @@ Status CloneStateManager::Run() {
         break;
     }
     if (!s.ok()) {
-      RETURN_NOT_OK(MarkCloneAborted(clone_state, s.ToString()));
+      RETURN_NOT_OK(MarkCloneAborted(latest_clone_state, s.ToString()));
     }
   }
   return Status::OK();
diff --git a/src/yb/master/clone/clone_state_manager.h b/src/yb/master/clone/clone_state_manager.h
index 540aee5708..b8405d7b85 100644
--- a/src/yb/master/clone/clone_state_manager.h
+++ b/src/yb/master/clone/clone_state_manager.h
@@ -42,9 +42,7 @@ class CloneStateManager {
 
   Status Run();
 
-  Status IsCloneDone(
-      const IsCloneDoneRequestPB* req,
-      IsCloneDoneResponsePB* resp);
+  Status ListClones(const ListClonesRequestPB* req, ListClonesResponsePB* resp);
 
   Status CloneNamespace(
       const CloneNamespaceRequestPB* req,
@@ -96,8 +94,6 @@ class CloneStateManager {
       const CloneStateInfoPtr& clone_state, const LeaderEpoch& epoch,
       const std::unordered_set<TabletId>& not_snapshotted_tablets);
 
-  Result<CloneStateInfoPtr> GetCloneStateFromSourceNamespace(const NamespaceId& namespace_id);
-
   AsyncClonePgSchema::ClonePgSchemaCallbackType MakeDoneClonePgSchemaCallback(
       CloneStateInfoPtr clone_state, const SnapshotScheduleId& snapshot_schedule_id,
       const std::string& target_namespace_name,
@@ -112,8 +108,10 @@ class CloneStateManager {
 
   std::mutex mutex_;
 
-  // Map from clone source namespace id to the latest clone state for that namespace.
-  using CloneStateMap = std::unordered_map<NamespaceId, CloneStateInfoPtr>;
+  using CloneStateSet = std::set<CloneStateInfoPtr, CloneStateInfoComparator>;
+  using CloneStateMap = std::unordered_map<NamespaceId, CloneStateSet>;
+
+  // Map from clone source namespace id to all clone states for that namespace.
   CloneStateMap source_clone_state_map_ GUARDED_BY(mutex_);
 
   std::unique_ptr<CloneStateManagerExternalFunctionsBase> external_funcs_;
diff --git a/src/yb/master/master_backup.proto b/src/yb/master/master_backup.proto
index 9b2e419b9b..60511fb5f9 100644
--- a/src/yb/master/master_backup.proto
+++ b/src/yb/master/master_backup.proto
@@ -281,19 +281,19 @@ message CloneNamespaceRequestPB {
 
 message CloneNamespaceResponsePB {
   optional MasterErrorPB error = 1;
-  // If the call returned without error, then these are the fields to pass to IsCloneDone.
+  // If the call returned without error, then these are the fields to pass to ListClones.
   optional string source_namespace_id = 2;
   optional uint32 seq_no = 3;
 }
 
-message IsCloneDoneRequestPB {
+message ListClonesRequestPB {
   optional string source_namespace_id = 1;
   optional uint32 seq_no = 2;
 }
 
-message IsCloneDoneResponsePB {
+message ListClonesResponsePB {
   optional MasterErrorPB error = 1;
-  optional bool is_done = 2;
+  repeated SysCloneStatePB entries = 2;
 }
 
 service MasterBackup {
@@ -317,5 +317,5 @@ service MasterBackup {
       returns (RestoreSnapshotScheduleResponsePB);
   rpc CloneNamespace(CloneNamespaceRequestPB)
       returns (CloneNamespaceResponsePB);
-  rpc IsCloneDone(IsCloneDoneRequestPB) returns (IsCloneDoneResponsePB);
+  rpc ListClones(ListClonesRequestPB) returns (ListClonesResponsePB);
 }
diff --git a/src/yb/master/master_backup_service.cc b/src/yb/master/master_backup_service.cc
index c778338608..3c9bb896b0 100644
--- a/src/yb/master/master_backup_service.cc
+++ b/src/yb/master/master_backup_service.cc
@@ -48,7 +48,7 @@ class MasterBackupServiceImpl : public MasterBackupIf, public MasterServiceBase
   MASTER_SERVICE_IMPL_ON_LEADER_WITH_LOCK(
       CloneStateManager,
       (CloneNamespace)
-      (IsCloneDone)
+      (ListClones)
   )
 
  private:
diff --git a/src/yb/tools/yb-admin-snapshot-schedule-test.cc b/src/yb/tools/yb-admin-snapshot-schedule-test.cc
index 1ed13ce9b0..a764163b69 100644
--- a/src/yb/tools/yb-admin-snapshot-schedule-test.cc
+++ b/src/yb/tools/yb-admin-snapshot-schedule-test.cc
@@ -255,14 +255,15 @@ class YbAdminSnapshotScheduleTest : public AdminTestBase {
     std::string seq_no = VERIFY_RESULT(Get(out, "seq_no")).get().GetString();
 
     RETURN_NOT_OK(WaitFor([&]() -> Result<bool> {
-      out = VERIFY_RESULT(CallJsonAdmin("is_clone_done", source_namespace_id, seq_no));
-      std::string is_done = VERIFY_RESULT(Get(out, "is_done")).get().GetString();
-      if (is_done == "true") {
-        return true;
-      } else if (is_done == "false") {
-        return false;
-      }
-      return STATUS_FORMAT(InvalidArgument, is_done);
+      rapidjson::Document out = VERIFY_RESULT(
+          CallJsonAdmin("list_clones", source_namespace_id, seq_no));
+      const auto entries = out.GetArray();
+      SCHECK_EQ(entries.Size(), 1, IllegalState, "Wrong number of entries. Expected 1");
+      master::SysCloneStatePB::State state;
+      master::SysCloneStatePB::State_Parse(
+          VERIFY_RESULT(Get(entries[0], "aggregate_state")).get().GetString(), &state);
+      return state == master::SysCloneStatePB::ABORTED ||
+             state == master::SysCloneStatePB::RESTORED;
     }, timeout, "Wait for clone to complete"));
     return Status::OK();
   }
diff --git a/src/yb/tools/yb-admin_cli.cc b/src/yb/tools/yb-admin_cli.cc
index 963b55e257..c3fbc79e8b 100644
--- a/src/yb/tools/yb-admin_cli.cc
+++ b/src/yb/tools/yb-admin_cli.cc
@@ -1522,15 +1522,18 @@ Status clone_namespace_action(
   return Status::OK();
 }
 
-const auto is_clone_done_args = "<source_namespace_id> <seq_no>";
-Status is_clone_done_action(
+const auto list_clones_args = "<source_namespace_id> [<seq_no>]";
+Status list_clones_action(
     const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
-  RETURN_NOT_OK(CheckArgumentsCount(args.size(), 2, 2));
+  RETURN_NOT_OK(CheckArgumentsCount(args.size(), 1, 2));
 
   auto source_namespace_id = args[0];
-  uint32_t seq_no = narrow_cast<uint32_t>(std::stoul(args[1]));
+  std::optional<uint32_t> seq_no;
+  if (args.size() >= 2) {
+    seq_no = narrow_cast<uint32_t>(std::stoul(args[1]));
+  }
 
-  return PrintJsonResult(client->IsCloneDone(source_namespace_id, seq_no));
+  return PrintJsonResult(client->ListClones(source_namespace_id, seq_no));
 }
 
 const auto edit_snapshot_schedule_args =
@@ -2589,7 +2592,7 @@ void ClusterAdminCli::RegisterCommandHandlers() {
   REGISTER_COMMAND(delete_snapshot_schedule);
   REGISTER_COMMAND(restore_snapshot_schedule);
   REGISTER_COMMAND(clone_namespace);
-  REGISTER_COMMAND(is_clone_done);
+  REGISTER_COMMAND(list_clones);
   REGISTER_COMMAND(edit_snapshot_schedule);
   REGISTER_COMMAND(create_keyspace_snapshot);
   REGISTER_COMMAND(create_database_snapshot);
diff --git a/src/yb/tools/yb-admin_client.cc b/src/yb/tools/yb-admin_client.cc
index 4c7f37d6a7..7d263f632b 100644
--- a/src/yb/tools/yb-admin_client.cc
+++ b/src/yb/tools/yb-admin_client.cc
@@ -2683,7 +2683,6 @@ Result<rapidjson::Document> ClusterAdminClient::CloneNamespace(
   RpcController rpc;
   rpc.set_deadline(deadline);
   master::CloneNamespaceRequestPB req;
-  master::CloneNamespaceResponsePB resp;
   master::NamespaceIdentifierPB source_namespace_identifier;
   source_namespace_identifier.set_name(source_namespace.name);
   source_namespace_identifier.set_database_type(source_namespace.db_type);
@@ -2691,15 +2690,9 @@ Result<rapidjson::Document> ClusterAdminClient::CloneNamespace(
   req.set_target_namespace_name(target_namespace_name);
   req.set_restore_ht(restore_at.ToUint64());
 
-  Status s = master_backup_proxy_->CloneNamespace(req, &resp, &rpc);
-  if (!s.ok()) {
-    RETURN_NOT_OK_PREPEND(
-        s, Format("Failed to clone namespace $0", source_namespace.name));
-  }
-
-  if (resp.has_error()) {
-    return StatusFromPB(resp.error().status());
-  }
+  const auto resp = VERIFY_RESULT(InvokeRpc(
+      &master::MasterBackupProxy::CloneNamespace, *master_backup_proxy_, req,
+      Format("Failed to clone namespace $0", source_namespace.name).c_str()));
 
   rapidjson::Document document;
   document.SetObject();
@@ -2709,31 +2702,47 @@ Result<rapidjson::Document> ClusterAdminClient::CloneNamespace(
   return document;
 }
 
-Result<rapidjson::Document> ClusterAdminClient::IsCloneDone(
-    const NamespaceId& source_namespace_id, uint32_t seq_no) {
+Result<rapidjson::Document> ClusterAdminClient::ListClones(
+    const NamespaceId& source_namespace_id, std::optional<uint32_t> seq_no) {
   auto deadline = CoarseMonoClock::now() + timeout_;
 
   RpcController rpc;
   rpc.set_deadline(deadline);
-  master::IsCloneDoneRequestPB req;
-  master::IsCloneDoneResponsePB resp;
+  master::ListClonesRequestPB req;
   req.set_source_namespace_id(source_namespace_id);
-  req.set_seq_no(seq_no);
-
-  Status s = master_backup_proxy_->IsCloneDone(req, &resp, &rpc);
-  if (!s.ok()) {
-    RETURN_NOT_OK_PREPEND(
-        s, Format("Failed to get clone status for namespace $0 and seq_no $1", source_namespace_id,
-        seq_no));
+  if (seq_no.has_value()) {
+    req.set_seq_no(*seq_no);
   }
 
-  if (resp.has_error()) {
-    return StatusFromPB(resp.error().status());
-  }
+  const auto error_msg = Format(
+      "Failed to get clone status for namespace $0", source_namespace_id) +
+      (req.has_seq_no() ? Format(" and seq_no $0", seq_no) : "");
+  const auto resp = VERIFY_RESULT(InvokeRpc(
+      &master::MasterBackupProxy::ListClones, *master_backup_proxy_, req, error_msg.c_str()));
 
   rapidjson::Document document;
-  document.SetObject();
-  AddStringField("is_done", resp.is_done() ? "true" : "false", &document, &document.GetAllocator());
+  document.SetArray();
+  for (const auto& entry : resp.entries()) {
+    rapidjson::Value json_entry(rapidjson::kObjectType);
+    AddStringField(
+        "aggregate_state", master::SysCloneStatePB::State_Name(entry.aggregate_state()),
+        &json_entry, &document.GetAllocator());
+    AddStringField(
+        "source_namespace_id", entry.source_namespace_id(), &json_entry, &document.GetAllocator());
+    AddStringField(
+        "seq_no", std::to_string(entry.clone_request_seq_no()), &json_entry,
+        &document.GetAllocator());
+    AddStringField(
+        "target_namespace_name", entry.target_namespace_name(), &json_entry,
+        &document.GetAllocator());
+    AddStringField(
+        "restore_time", HybridTimeToString(HybridTime(entry.restore_time())), &json_entry,
+        &document.GetAllocator());
+    if (entry.has_abort_message()) {
+      AddStringField("abort_message", entry.abort_message(), &json_entry, &document.GetAllocator());
+    }
+    document.PushBack(json_entry, document.GetAllocator());
+  }
   return document;
 }
 
diff --git a/src/yb/tools/yb-admin_client.h b/src/yb/tools/yb-admin_client.h
index 153b25c119..ce0f0ae52f 100644
--- a/src/yb/tools/yb-admin_client.h
+++ b/src/yb/tools/yb-admin_client.h
@@ -354,7 +354,8 @@ class ClusterAdminClient {
   Result<rapidjson::Document> CloneNamespace(
       const TypedNamespaceName& source_namespace, const std::string& target_namespace_name,
       HybridTime restore_at);
-  Result<rapidjson::Document> IsCloneDone(const NamespaceId& source_namespace_id, uint32_t seq_no);
+  Result<rapidjson::Document> ListClones(
+      const NamespaceId& source_namespace_id, std::optional<uint32_t> seq_no);
   Status RestoreSnapshot(const std::string& snapshot_id, HybridTime timestamp);
 
   Result<rapidjson::Document> EditSnapshotSchedule(
