diff --git a/build-support/common-build-env.sh b/build-support/common-build-env.sh
index 5c8e454e5c..2efc434253 100644
--- a/build-support/common-build-env.sh
+++ b/build-support/common-build-env.sh
@@ -2474,12 +2474,15 @@ lint_java_code() {
          ! grep -Eq '@RunWith\((value[ ]*=[ ]*)?YBTestRunnerReleaseOnly\.class\)' \
              "$java_test_file" &&
          ! grep -Eq '@RunWith\((value[ ]*=[ ]*)?YBTestRunnerYsqlConnMgr\.class\)' \
+             "$java_test_file" &&
+         ! grep -Eq '@RunWith\((value[ ]*=[ ]*)?YBTestRunnerNonMac\.class\)' \
              "$java_test_file"
       then
         log "$log_prefix: neither YBTestRunner, YBParameterizedTestRunner, " \
             "YBTestRunnerNonTsanOnly, YBTestRunnerNonTsanAsan, YBTestRunnerNonSanitizersOrMac, " \
             "YBTestRunnerNonSanOrAArch64Mac, " \
-            "YBTestRunnerReleaseOnly, nor YBTestRunnerYsqlConnMgr are being used in test"
+            "YBTestRunnerReleaseOnly, YBTestRunnerYsqlConnMgr, nor YBTestRunnerNonMac are being " \
+            "used in test"
         num_errors+=1
       fi
       if grep -Fq 'import static org.junit.Assert' "$java_test_file" ||
diff --git a/java/yb-client/src/test/java/org/yb/util/YBTestRunnerNonMac.java b/java/yb-client/src/test/java/org/yb/util/YBTestRunnerNonMac.java
new file mode 100644
index 0000000000..ed3b940786
--- /dev/null
+++ b/java/yb-client/src/test/java/org/yb/util/YBTestRunnerNonMac.java
@@ -0,0 +1,29 @@
+/**
+ * Copyright (c) YugaByte, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied.  See the License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+package org.yb.util;
+
+import org.junit.runners.model.InitializationError;
+import org.yb.YBTestRunner;
+
+public class YBTestRunnerNonMac extends YBTestRunner {
+  public YBTestRunnerNonMac(Class<?> klass) throws InitializationError {
+    super(klass);
+  }
+
+  @Override
+  public boolean shouldRunTests() {
+    return super.shouldRunTests() && SystemUtil.IS_LINUX;
+  }
+}
diff --git a/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestCassandraSpark3WordCount.java b/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestCassandraSpark3WordCount.java
index 5a8a61fa80..82e5538a59 100644
--- a/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestCassandraSpark3WordCount.java
+++ b/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestCassandraSpark3WordCount.java
@@ -12,36 +12,33 @@
 //
 package org.yb.loadtest;
 
+import static org.yb.AssertionWrappers.assertEquals;
+import static org.yb.AssertionWrappers.assertTrue;
+
+import com.datastax.oss.driver.api.core.CqlSession;
 import com.datastax.oss.driver.api.core.cql.ResultSet;
 import com.datastax.oss.driver.api.core.cql.Row;
-import com.datastax.oss.driver.api.core.CqlSession;
 import com.yugabyte.sample.apps.CassandraSparkWordCount;
 import com.yugabyte.sample.common.CmdLineOpts;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import static org.yb.AssertionWrappers.assertTrue;
-import static org.yb.AssertionWrappers.assertEquals;
-
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.TreeMap;
 import java.util.stream.Collectors;
-
+import org.junit.Test;
+import org.junit.runner.RunWith;
 import org.yb.minicluster.BaseMiniClusterTest;
-import org.yb.YBTestRunner;
+import org.yb.util.YBTestRunnerNonMac;
 
-@RunWith(value=YBTestRunner.class)
+@RunWith(value = YBTestRunnerNonMac.class)
 public class TestCassandraSpark3WordCount extends BaseMiniClusterTest {
+  private CassandraSparkWordCount app = new CassandraSparkWordCount();
 
-    private CassandraSparkWordCount app = new CassandraSparkWordCount();
-
-    protected Map<String, String> getTServerFlags() {
-        Map<String, String> flagMap = new TreeMap<>();
-        flagMap.put("cql_update_system_query_cache_msecs", "1000");
-        return flagMap;
-    }
+  protected Map<String, String> getTServerFlags() {
+    Map<String, String> flagMap = new TreeMap<>();
+    flagMap.put("cql_update_system_query_cache_msecs", "1000");
+    return flagMap;
+  }
 
   protected Iterator<Row> execSelect(String select_stmt) {
     CqlSession session = app.getCqlSession();
diff --git a/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestReadReplica.java b/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestReadReplica.java
index 85df01ed02..1a8419097c 100644
--- a/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestReadReplica.java
+++ b/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestReadReplica.java
@@ -12,6 +12,9 @@
 //
 package org.yb.loadtest;
 
+import static org.yb.AssertionWrappers.assertEquals;
+import static org.yb.AssertionWrappers.assertTrue;
+
 import com.datastax.oss.driver.api.core.ConsistencyLevel;
 import com.datastax.oss.driver.api.core.CqlSession;
 import com.datastax.oss.driver.api.core.CqlSessionBuilder;
@@ -25,35 +28,28 @@ import com.google.common.collect.ImmutableMap;
 import com.google.common.net.HostAndPort;
 import com.google.protobuf.ByteString;
 import com.yugabyte.oss.driver.internal.core.loadbalancing.PartitionAwarePolicy;
+import java.net.InetSocketAddress;
+import java.time.Duration;
+import java.util.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.yb.ColumnSchema;
-import org.yb.Common;
 import org.yb.CommonTypes;
 import org.yb.Schema;
 import org.yb.Type;
 import org.yb.client.*;
-import org.yb.consensus.Metadata;
 import org.yb.master.CatalogEntityInfo.PlacementBlockPB;
 import org.yb.master.CatalogEntityInfo.PlacementInfoPB;
 import org.yb.minicluster.BaseMiniClusterTest;
 import org.yb.minicluster.Metrics;
 import org.yb.minicluster.MiniYBCluster;
 import org.yb.minicluster.MiniYBDaemon;
-import org.yb.YBTestRunner;
-
-import java.net.InetSocketAddress;
-import java.time.Duration;
-import java.util.*;
+import org.yb.util.YBTestRunnerNonMac;
 
-import static org.yb.AssertionWrappers.assertEquals;
-import static org.yb.AssertionWrappers.assertTrue;
-
-@RunWith(value= YBTestRunner.class)
+@RunWith(value = YBTestRunnerNonMac.class)
 public class TestReadReplica extends BaseMiniClusterTest {
-
   protected static final Logger LOG = LoggerFactory.getLogger(TestReadReplica.class);
   private static final String PLACEMENT_CLOUD = "testCloud";
   private static final String PLACEMENT_REGION_LIVE = "testRegionLive";
diff --git a/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestSpark3Jsonb.java b/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestSpark3Jsonb.java
index ef3940aa5a..4841d0eecc 100644
--- a/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestSpark3Jsonb.java
+++ b/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestSpark3Jsonb.java
@@ -12,41 +12,32 @@
 //
 package org.yb.loadtest;
 
+import static org.yb.AssertionWrappers.assertEquals;
+import static org.yb.AssertionWrappers.assertTrue;
+
+import com.datastax.oss.driver.api.core.CqlSession;
+import com.datastax.spark.connector.CassandraSparkExtensions;
+import com.datastax.spark.connector.cql.CassandraConnector;
+import java.net.InetSocketAddress;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
 import org.apache.spark.SparkConf;
-import org.apache.spark.SparkContext;
 import org.apache.spark.sql.Dataset;
 import org.apache.spark.sql.Row;
 import org.apache.spark.sql.SaveMode;
 import org.apache.spark.sql.SparkSession;
-
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import static org.yb.AssertionWrappers.assertTrue;
-import static org.yb.AssertionWrappers.assertEquals;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-
-import java.net.InetSocketAddress;
-import java.net.URL;
-import java.util.Iterator;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.stream.Collectors;
-
 import org.yb.minicluster.BaseMiniClusterTest;
-import org.yb.minicluster.MiniYBClusterBuilder;
-import org.yb.YBTestRunner;
+import org.yb.util.YBTestRunnerNonMac;
 
-import com.datastax.oss.driver.api.core.CqlSession;
-import com.datastax.oss.driver.api.core.cql.ResultSet;
-import com.datastax.spark.connector.cql.CassandraConnector;
-import com.datastax.spark.connector.CassandraSparkExtensions;
-
-@RunWith(value=YBTestRunner.class)
+@RunWith(value = YBTestRunnerNonMac.class)
 public class TestSpark3Jsonb extends BaseMiniClusterTest {
-
   private Logger logger = LoggerFactory.getLogger(TestSpark3Jsonb.class);
   private static String KEYSPACE = "test";
   private static String INPUT_TABLE = "person";
diff --git a/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestSpark3Locality.java b/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestSpark3Locality.java
index 8d195091e9..26c1a2c2c2 100644
--- a/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestSpark3Locality.java
+++ b/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestSpark3Locality.java
@@ -12,33 +12,30 @@
 //
 package org.yb.loadtest;
 
-import com.datastax.oss.driver.api.core.cql.Row;
+import static org.yb.AssertionWrappers.assertEquals;
+import static org.yb.AssertionWrappers.assertTrue;
+
 import com.datastax.oss.driver.api.core.CqlSession;
+import com.datastax.oss.driver.api.core.cql.Row;
+import com.yugabyte.oss.driver.api.core.DefaultPartitionMetadata;
+import com.yugabyte.oss.driver.api.core.TableSplitMetadata;
 import com.yugabyte.sample.apps.CassandraSparkKeyValueCopy;
 import com.yugabyte.sample.common.CmdLineOpts;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Optional;
+import java.util.stream.Collectors;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.yb.YBTestRunner;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.yb.minicluster.BaseMiniClusterTest;
 import org.yb.minicluster.IOMetrics;
 import org.yb.minicluster.MiniYBClusterBuilder;
 import org.yb.minicluster.MiniYBDaemon;
-import com.yugabyte.oss.driver.api.core.DefaultPartitionMetadata;
-import com.yugabyte.oss.driver.api.core.TableSplitMetadata;
-import com.yugabyte.sample.apps.CassandraSparkWordCount;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Optional;
-import java.util.stream.Collectors;
-
-import static org.yb.AssertionWrappers.assertEquals;
-import static org.yb.AssertionWrappers.assertTrue;
+import org.yb.util.YBTestRunnerNonMac;
 
-@RunWith(value=YBTestRunner.class)
+@RunWith(value = YBTestRunnerNonMac.class)
 public class TestSpark3Locality extends BaseMiniClusterTest {
   private Logger logger = LoggerFactory.getLogger(TestSpark3Locality.class);
 
diff --git a/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestTupleOperators.java b/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestTupleOperators.java
index 606a8a6ac7..34bf8739d8 100644
--- a/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestTupleOperators.java
+++ b/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestTupleOperators.java
@@ -12,206 +12,199 @@
 //
 package org.yb.loadtest;
 
-import org.apache.spark.SparkConf;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import static org.yb.AssertionWrappers.assertTrue;
 import static org.yb.AssertionWrappers.assertEquals;
+import static org.yb.AssertionWrappers.assertTrue;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
+import com.datastax.oss.driver.api.core.CqlSession;
+import com.datastax.oss.driver.api.core.cql.BoundStatement;
+import com.datastax.oss.driver.api.core.cql.PreparedStatement;
+import com.datastax.oss.driver.api.core.cql.ResultSet;
+import com.datastax.oss.driver.api.core.cql.Row;
+import com.datastax.oss.driver.api.core.data.TupleValue;
+import com.datastax.oss.driver.api.core.type.DataTypes;
+import com.datastax.oss.driver.api.core.type.TupleType;
+import com.datastax.spark.connector.cql.CassandraConnector;
 import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
-
+import org.apache.spark.SparkConf;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.yb.minicluster.BaseMiniClusterTest;
-import org.yb.YBTestRunner;
-
-import com.datastax.spark.connector.cql.CassandraConnector;
+import org.yb.util.YBTestRunnerNonMac;
 
-import com.datastax.oss.driver.api.core.CqlSession;
-import com.datastax.oss.driver.api.core.cql.ResultSet;
-import com.datastax.oss.driver.api.core.cql.PreparedStatement;
-import com.datastax.oss.driver.api.core.cql.BoundStatement;
-import com.datastax.oss.driver.api.core.cql.Row;
+@RunWith(value = YBTestRunnerNonMac.class)
+public class TestTupleOperators extends BaseMiniClusterTest {
+  private static Logger logger = LoggerFactory.getLogger(TestTupleOperators.class);
+  private static String KEYSPACE = "test";
+
+  @Test
+  public void testTupleBind() throws Exception {
+    // Set up config.
+    List<InetSocketAddress> addresses = miniCluster.getCQLContactPoints();
+
+    // Setup the local spark master
+    SparkConf conf = new SparkConf()
+                         .setAppName("yb.spark-jsonb")
+                         .setMaster("local[1]")
+                         .set("spark.cassandra.connection.localDC", "datacenter1")
+                         .set("spark.cassandra.connection.host", addresses.get(0).getHostName())
+                         .set("spark.sql.catalog.mycatalog",
+                             "com.datastax.spark.connector.datasource.CassandraCatalog");
+
+    CassandraConnector connector = CassandraConnector.apply(conf);
+
+    // Create a Cassandra session, and initialize the keyspace.
+    CqlSession session = connector.openSession();
+
+    String createKeyspace = "CREATE KEYSPACE IF NOT EXISTS " + KEYSPACE + ";";
+    session.execute(createKeyspace);
+
+    String tbl = KEYSPACE + ".test_tuple_bind";
+    session.execute("CREATE TABLE " + tbl + " (h1 INT, h2 TEXT,"
+        + "  r1 INT, r2 TEXT,"
+        + "  v1 INT, v2 TEXT, PRIMARY KEY ((h1, h2), r1, r2))"
+        + "  WITH transactions = {'enabled': 'true'}");
+
+    // Insert data.
+    int insert_row_count = 10;
+    String stmt = String.format("INSERT INTO %s(h1, h2, r1, r2, v1, v2) "
+            + "VALUES(?, ?, ?, ?, ?, ?)",
+        tbl);
+    PreparedStatement insertStmt = session.prepare(stmt);
+    for (int idx = 0; idx < insert_row_count; idx++) {
+      session.execute(insertStmt.bind(
+          idx, "h" + idx, idx + 100, "r" + (idx + 100), idx + 1000, "v" + (idx + 1000)));
+    }
 
-import com.datastax.oss.driver.api.core.type.DataTypes;
-import com.datastax.oss.driver.api.core.type.TupleType;
-import com.datastax.oss.driver.api.core.data.TupleValue;
+    // Simple SELECT to verify that this setup works.
+    String selectStmt = String.format("SELECT h1, h2, r1, r2, v1, v2 FROM %s"
+            + "  WHERE h1 = 7 AND h2 = 'h7' AND r1 = 107;",
+        tbl);
+    ResultSet rs = session.execute(selectStmt);
+
+    int select_row_count = 0;
+    Iterator<Row> iter = rs.iterator();
+    while (iter.hasNext()) {
+      Row row = iter.next();
+      assertEquals(row.getInt(0), 7);
+      assertEquals(row.getString(1), "h7");
+      assertEquals(row.getInt(2), 107);
+      assertEquals(row.getString(3), "r107");
+      assertEquals(row.getInt(4), 1007);
+      assertEquals(row.getString(5), "v1007");
+      select_row_count++;
+    }
+    assertEquals(select_row_count, 1);
+
+    // Bind by name - one variable per tuple
+    selectStmt = String.format("SELECT * FROM %s WHERE (r1, r2) IN (:tup1, :tup2);", tbl);
+    PreparedStatement preparedSelect = session.prepare(selectStmt);
+    TupleType tupleType = DataTypes.tupleOf(DataTypes.INT, DataTypes.TEXT);
+    BoundStatement boundStmt = preparedSelect.boundStatementBuilder()
+                                   .setTupleValue("tup1", tupleType.newValue(101, "r101"))
+                                   .setTupleValue("tup2", tupleType.newValue(102, "r102"))
+                                   .build();
+    rs = session.execute(boundStmt);
+
+    select_row_count = 0;
+    iter = rs.iterator();
+    int counter = 1;
+    while (iter.hasNext()) {
+      Row row = iter.next();
+      assertEquals(row.getInt(0), counter); /* h1 */
+      assertEquals(row.getInt(2), counter + 100); /* r1 */
+      assertEquals(row.getInt(4), counter + 1000); /* v1 */
+      select_row_count++;
+      counter++;
+    }
+    assertEquals(select_row_count, 2);
+
+    // Basic bind - one variable per tuple
+    selectStmt = String.format("SELECT * FROM %s WHERE (r1, r2) IN (?, ?);", tbl);
+    preparedSelect = session.prepare(selectStmt);
+    List<TupleValue> choices = new ArrayList<>();
+    choices.add(tupleType.newValue(101, "r101"));
+    choices.add(tupleType.newValue(102, "r102"));
+    rs = session.execute(preparedSelect.bind(choices.toArray()));
+    select_row_count = 0;
+    iter = rs.iterator();
+    counter = 1;
+    while (iter.hasNext()) {
+      Row row = iter.next();
+      assertEquals(row.getInt(0), counter); /* h1 */
+      assertEquals(row.getInt(2), counter + 100); /* r1 */
+      assertEquals(row.getInt(4), counter + 1000); /* v1 */
+      select_row_count++;
+      counter++;
+    }
+    assertEquals(select_row_count, 2);
+
+    // Invalid number of variables - one variable per tuple
+    List<TupleValue> invalid_choices = new ArrayList<>();
+    invalid_choices.add(tupleType.newValue(101, "r101"));
+    invalid_choices.add(tupleType.newValue(102, "r102"));
+    invalid_choices.add(tupleType.newValue(103, "r103"));
+    try {
+      rs = session.execute(preparedSelect.bind(invalid_choices.toArray()));
+    } catch (java.lang.IllegalArgumentException e) {
+      assertTrue(e.getMessage().contains("Too many variables (expected 2, got 3)"));
+      logger.info("Expected exception", e);
+    }
 
-@RunWith(value = YBTestRunner.class)
-public class TestTupleOperators extends BaseMiniClusterTest {
+    // Invalid tuple type - one variable per tuple
+    invalid_choices = new ArrayList<>();
+    TupleType invalidTupleType = DataTypes.tupleOf(DataTypes.INT, DataTypes.INT);
+    invalid_choices.add(invalidTupleType.newValue(101, 101));
+    invalid_choices.add(invalidTupleType.newValue(102, 102));
+    try {
+      rs = session.execute(preparedSelect.bind(invalid_choices.toArray()));
+    } catch (java.lang.IllegalArgumentException e) {
+      assertTrue(e.getMessage().contains("Invalid tuple type, expected Tuple(INT, TEXT) but got "
+          + "Tuple(INT, INT)"));
+      logger.info("Expected exception", e);
+    }
 
-    private static Logger logger = LoggerFactory.getLogger(TestTupleOperators.class);
-    private static String KEYSPACE = "test";
-
-    @Test
-    public void testTupleBind() throws Exception {
-        // Set up config.
-        List<InetSocketAddress> addresses = miniCluster.getCQLContactPoints();
-
-        // Setup the local spark master
-        SparkConf conf = new SparkConf().setAppName("yb.spark-jsonb")
-                .setMaster("local[1]")
-                .set("spark.cassandra.connection.localDC", "datacenter1")
-                .set("spark.cassandra.connection.host", addresses.get(0).getHostName())
-                .set("spark.sql.catalog.mycatalog",
-                        "com.datastax.spark.connector.datasource.CassandraCatalog");
-
-        CassandraConnector connector = CassandraConnector.apply(conf);
-
-        // Create a Cassandra session, and initialize the keyspace.
-        CqlSession session = connector.openSession();
-
-        String createKeyspace = "CREATE KEYSPACE IF NOT EXISTS " + KEYSPACE + ";";
-        session.execute(createKeyspace);
-
-        String tbl = KEYSPACE + ".test_tuple_bind";
-        session.execute("CREATE TABLE " + tbl +
-                " (h1 INT, h2 TEXT," +
-                "  r1 INT, r2 TEXT," +
-                "  v1 INT, v2 TEXT, PRIMARY KEY ((h1, h2), r1, r2))" +
-                "  WITH transactions = {'enabled': 'true'}");
-
-        // Insert data.
-        int insert_row_count = 10;
-        String stmt = String.format("INSERT INTO %s(h1, h2, r1, r2, v1, v2) " +
-                "VALUES(?, ?, ?, ?, ?, ?)", tbl);
-        PreparedStatement insertStmt = session.prepare(stmt);
-        for (int idx = 0; idx < insert_row_count; idx++) {
-            session.execute(insertStmt.bind(idx, "h" + idx,
-                    idx + 100, "r" + (idx + 100),
-                    idx + 1000, "v" + (idx + 1000)));
-        }
-
-        // Simple SELECT to verify that this setup works.
-        String selectStmt = String.format("SELECT h1, h2, r1, r2, v1, v2 FROM %s" +
-                "  WHERE h1 = 7 AND h2 = 'h7' AND r1 = 107;", tbl);
-        ResultSet rs = session.execute(selectStmt);
-
-        int select_row_count = 0;
-        Iterator<Row> iter = rs.iterator();
-        while (iter.hasNext()) {
-            Row row = iter.next();
-            assertEquals(row.getInt(0), 7);
-            assertEquals(row.getString(1), "h7");
-            assertEquals(row.getInt(2), 107);
-            assertEquals(row.getString(3), "r107");
-            assertEquals(row.getInt(4), 1007);
-            assertEquals(row.getString(5), "v1007");
-            select_row_count++;
-        }
-        assertEquals(select_row_count, 1);
-
-        // Bind by name - one variable per tuple
-        selectStmt = String.format("SELECT * FROM %s WHERE (r1, r2) IN (:tup1, :tup2);", tbl);
-        PreparedStatement preparedSelect = session.prepare(selectStmt);
-        TupleType tupleType = DataTypes.tupleOf(DataTypes.INT, DataTypes.TEXT);
-        BoundStatement boundStmt = preparedSelect.boundStatementBuilder()
-                .setTupleValue("tup1", tupleType.newValue(101, "r101"))
-                .setTupleValue("tup2", tupleType.newValue(102, "r102"))
-                .build();
-        rs = session.execute(boundStmt);
-
-        select_row_count = 0;
-        iter = rs.iterator();
-        int counter = 1;
-        while (iter.hasNext()) {
-            Row row = iter.next();
-            assertEquals(row.getInt(0), counter); /* h1 */
-            assertEquals(row.getInt(2), counter + 100); /* r1 */
-            assertEquals(row.getInt(4), counter + 1000); /* v1 */
-            select_row_count++;
-            counter++;
-        }
-        assertEquals(select_row_count, 2);
-
-        // Basic bind - one variable per tuple
-        selectStmt = String.format("SELECT * FROM %s WHERE (r1, r2) IN (?, ?);", tbl);
-        preparedSelect = session.prepare(selectStmt);
-        List<TupleValue> choices = new ArrayList<>();
-        choices.add(tupleType.newValue(101, "r101"));
-        choices.add(tupleType.newValue(102, "r102"));
-        rs = session.execute(preparedSelect.bind(choices.toArray()));
-        select_row_count = 0;
-        iter = rs.iterator();
-        counter = 1;
-        while (iter.hasNext()) {
-            Row row = iter.next();
-            assertEquals(row.getInt(0), counter); /* h1 */
-            assertEquals(row.getInt(2), counter + 100); /* r1 */
-            assertEquals(row.getInt(4), counter + 1000); /* v1 */
-            select_row_count++;
-            counter++;
-        }
-        assertEquals(select_row_count, 2);
-
-        // Invalid number of variables - one variable per tuple
-        List<TupleValue> invalid_choices = new ArrayList<>();
-        invalid_choices.add(tupleType.newValue(101, "r101"));
-        invalid_choices.add(tupleType.newValue(102, "r102"));
-        invalid_choices.add(tupleType.newValue(103, "r103"));
-        try {
-            rs = session.execute(preparedSelect.bind(invalid_choices.toArray()));
-        } catch (java.lang.IllegalArgumentException e) {
-            assertTrue(e.getMessage().contains("Too many variables (expected 2, got 3)"));
-            logger.info("Expected exception", e);
-        }
-
-        // Invalid tuple type - one variable per tuple
-        invalid_choices = new ArrayList<>();
-        TupleType invalidTupleType = DataTypes.tupleOf(DataTypes.INT, DataTypes.INT);
-        invalid_choices.add(invalidTupleType.newValue(101, 101));
-        invalid_choices.add(invalidTupleType.newValue(102, 102));
-        try {
-            rs = session.execute(preparedSelect.bind(invalid_choices.toArray()));
-        } catch (java.lang.IllegalArgumentException e) {
-            assertTrue(e.getMessage()
-                    .contains("Invalid tuple type, expected Tuple(INT, TEXT) but got " +
-                            "Tuple(INT, INT)"));
-            logger.info("Expected exception", e);
-        }
-
-        // Bind by name - one variable for entire list
-        selectStmt = String.format("SELECT * FROM %s WHERE (r1, r2) IN :choices;", tbl);
-        preparedSelect = session.prepare(selectStmt);
-        boundStmt = preparedSelect.boundStatementBuilder()
-                .setList("choices", choices, TupleValue.class).build();
-        rs = session.execute(boundStmt);
-
-        select_row_count = 0;
-        iter = rs.iterator();
-        counter = 1;
-        while (iter.hasNext()) {
-            Row row = iter.next();
-            assertEquals(row.getInt(0), counter); /* h1 */
-            assertEquals(row.getInt(2), counter + 100); /* r1 */
-            assertEquals(row.getInt(4), counter + 1000); /* v1 */
-            select_row_count++;
-            counter++;
-        }
-        assertEquals(select_row_count, 2);
-
-
-        // Basic bind - one variable for entire list
-        selectStmt = String.format("SELECT * FROM %s WHERE (r1, r2) IN ?;", tbl);
-        preparedSelect = session.prepare(selectStmt);
-        rs = session.execute(preparedSelect.bind(choices));
-
-        select_row_count = 0;
-        iter = rs.iterator();
-        counter = 1;
-        while (iter.hasNext()) {
-            Row row = iter.next();
-            assertEquals(row.getInt(0), counter); /* h1 */
-            assertEquals(row.getInt(2), counter + 100); /* r1 */
-            assertEquals(row.getInt(4), counter + 1000); /* v1 */
-            select_row_count++;
-            counter++;
-        }
-        assertEquals(select_row_count, 2);
+    // Bind by name - one variable for entire list
+    selectStmt = String.format("SELECT * FROM %s WHERE (r1, r2) IN :choices;", tbl);
+    preparedSelect = session.prepare(selectStmt);
+    boundStmt = preparedSelect.boundStatementBuilder()
+                    .setList("choices", choices, TupleValue.class)
+                    .build();
+    rs = session.execute(boundStmt);
+
+    select_row_count = 0;
+    iter = rs.iterator();
+    counter = 1;
+    while (iter.hasNext()) {
+      Row row = iter.next();
+      assertEquals(row.getInt(0), counter); /* h1 */
+      assertEquals(row.getInt(2), counter + 100); /* r1 */
+      assertEquals(row.getInt(4), counter + 1000); /* v1 */
+      select_row_count++;
+      counter++;
+    }
+    assertEquals(select_row_count, 2);
+
+    // Basic bind - one variable for entire list
+    selectStmt = String.format("SELECT * FROM %s WHERE (r1, r2) IN ?;", tbl);
+    preparedSelect = session.prepare(selectStmt);
+    rs = session.execute(preparedSelect.bind(choices));
+
+    select_row_count = 0;
+    iter = rs.iterator();
+    counter = 1;
+    while (iter.hasNext()) {
+      Row row = iter.next();
+      assertEquals(row.getInt(0), counter); /* h1 */
+      assertEquals(row.getInt(2), counter + 100); /* r1 */
+      assertEquals(row.getInt(4), counter + 1000); /* v1 */
+      select_row_count++;
+      counter++;
     }
+    assertEquals(select_row_count, 2);
+  }
 }
diff --git a/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestUnsetDC.java b/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestUnsetDC.java
index d4a88d1d31..d968037893 100644
--- a/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestUnsetDC.java
+++ b/java/yb-cql-4x/src/test/java/org/yb/loadtest/TestUnsetDC.java
@@ -13,6 +13,9 @@
 
 package org.yb.loadtest;
 
+import static org.yb.AssertionWrappers.assertEquals;
+import static org.yb.AssertionWrappers.assertTrue;
+
 import com.datastax.oss.driver.api.core.ConsistencyLevel;
 import com.datastax.oss.driver.api.core.CqlSession;
 import com.datastax.oss.driver.api.core.CqlSessionBuilder;
@@ -22,31 +25,23 @@ import com.datastax.oss.driver.api.core.config.ProgrammaticDriverConfigLoaderBui
 import com.datastax.oss.driver.api.core.cql.PreparedStatement;
 import com.datastax.oss.driver.api.core.cql.Row;
 import com.datastax.oss.driver.api.querybuilder.SchemaBuilder;
-
 import com.google.common.collect.ImmutableMap;
+import com.google.common.net.HostAndPort;
 import com.yugabyte.oss.driver.internal.core.loadbalancing.PartitionAwarePolicy;
+import java.net.InetSocketAddress;
+import java.time.Duration;
+import java.util.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import com.google.common.net.HostAndPort;
 import org.yb.*;
-import org.yb.CommonTypes;
 import org.yb.client.*;
-import org.yb.consensus.Metadata;
 import org.yb.minicluster.*;
-import org.yb.YBTestRunner;
+import org.yb.util.YBTestRunnerNonMac;
 
-import java.net.InetSocketAddress;
-import java.time.Duration;
-import java.util.*;
-
-import static org.yb.AssertionWrappers.assertEquals;
-import static org.yb.AssertionWrappers.assertTrue;
-
-@RunWith(value= YBTestRunner.class)
+@RunWith(value = YBTestRunnerNonMac.class)
 public class TestUnsetDC extends BaseMiniClusterTest {
-
   protected static final Logger LOG = LoggerFactory.getLogger(TestUnsetDC.class);
   private YBTable ybTable = null;
   private LocatedTablet tablet = null;
@@ -371,5 +366,4 @@ public class TestUnsetDC extends BaseMiniClusterTest {
       "placement_region", PLACEMENT_REGION_LIVE+i ,
       "placement_zone", PLACEMENT_ZONE + i);
   }
-
 }
