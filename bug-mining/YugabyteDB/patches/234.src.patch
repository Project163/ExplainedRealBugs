diff --git a/architecture/design/auto_flags.md b/architecture/design/auto_flags.md
index ba53d1c544..32701029c8 100644
--- a/architecture/design/auto_flags.md
+++ b/architecture/design/auto_flags.md
@@ -22,7 +22,7 @@ New AutoFlags are defined using the following syntax in the primary cpp file whe
 
 - value_type: [`bool`, `int32`, `int64`, `uint64`, `double`, `string`]
 - flag_name: A friendly descriptive name for the AutoFlag.
-- flag_class: [`kLocalVolatile`, `kLocalPersisted`, `kExternal`, `kNewInstallsOnly`]
+- flag_class: [`kLocalVolatile`, `kLocalPersisted`, `kExternal`]
 - initial_value: The initial value of type `<value_type>`.
 - target_value: The target value of type `<value_type>`.
 - usage: Usage information about the AutoFlag.
@@ -65,7 +65,6 @@ AutoFlag class is picked based on the persistence property of the data, and whic
 | LocalVolatile     | After all the processes in our universe have been upgraded to the new code version.   | Yes | yb_enable_expression_pushdown |
 | LocalPersisted    | After all the processes in our universe have been upgraded to the new code version.   | No | enable_flush_retryable_requests |
 | External          | After all the processes in our universe and other dependent universes and processes have been upgraded to the new code version.   | No | regular_tablets_data_block_key_value_encoding, enable_stream_compression |
-| NewInstallsOnly   | No promotion after upgrades.  | No | TEST_auto_flags_new_install |
 
 >Note:  
 >String flags are not Runtime safe. Avoid these until #16593 is fixed.
diff --git a/docs/content/v2.18/admin/yb-admin.md b/docs/content/v2.18/admin/yb-admin.md
index 3cd60a686f..c00affe74e 100644
--- a/docs/content/v2.18/admin/yb-admin.md
+++ b/docs/content/v2.18/admin/yb-admin.md
@@ -2447,7 +2447,7 @@ yb-admin \
 ```
 
 * *master-addresses*: Comma-separated list of YB-Master hosts and ports. Default value is `localhost:7100`.
-* *max_flags_class*: The maximum AutoFlag class to promote. Allowed values are `kLocalVolatile`, `kLocalPersisted`, `kExternal`, `kNewInstallsOnly`. Default value is `kExternal`.
+* *max_flags_class*: The maximum AutoFlag class to promote. Allowed values are `kLocalVolatile`, `kLocalPersisted`, `kExternal`. Default value is `kExternal`.
 * *promote_non_runtime_flags*: Weather to promote non-runtime flags. Allowed values are `true` and `false`. Default value is `true`.
 * *force*: Forces the generation of a new AutoFlag configuration and sends it to all YugabyteDB processes even if there are no new AutoFlags to promote.
 
diff --git a/docs/content/v2.20/admin/yb-admin.md b/docs/content/v2.20/admin/yb-admin.md
index ecaf3698da..c28dd7ef28 100644
--- a/docs/content/v2.20/admin/yb-admin.md
+++ b/docs/content/v2.20/admin/yb-admin.md
@@ -2508,7 +2508,7 @@ yb-admin \
 ```
 
 * *master-addresses*: Comma-separated list of YB-Master hosts and ports. Default value is `localhost:7100`.
-* *max_flags_class*: The maximum AutoFlag class to promote. Allowed values are `kLocalVolatile`, `kLocalPersisted`, `kExternal`, `kNewInstallsOnly`. Default value is `kExternal`.
+* *max_flags_class*: The maximum AutoFlag class to promote. Allowed values are `kLocalVolatile`, `kLocalPersisted`, `kExternal`. Default value is `kExternal`.
 * *promote_non_runtime_flags*: Weather to promote non-runtime flags. Allowed values are `true` and `false`. Default value is `true`.
 * *force*: Forces the generation of a new AutoFlag configuration and sends it to all YugabyteDB processes even if there are no new AutoFlags to promote.
 
diff --git a/src/yb/integration-tests/auto_flags-itest.cc b/src/yb/integration-tests/auto_flags-itest.cc
index fa5b7c2bab..a0ebba450d 100644
--- a/src/yb/integration-tests/auto_flags-itest.cc
+++ b/src/yb/integration-tests/auto_flags-itest.cc
@@ -39,7 +39,6 @@
 #include "yb/common/version_info.h"
 
 DECLARE_bool(TEST_auto_flags_initialized);
-DECLARE_bool(TEST_auto_flags_new_install);
 DECLARE_bool(disable_auto_flags_management);
 DECLARE_int32(limit_auto_flag_promote_for_new_universe);
 DECLARE_int32(heartbeat_interval_ms);
@@ -61,7 +60,6 @@ using OK = Status::OK;
 
 const string kDisableAutoFlagsManagementFlagName = "disable_auto_flags_management";
 const string kTESTAutoFlagsInitializedFlagName = "TEST_auto_flags_initialized";
-const string kTESTAutoFlagsNewInstallFlagName = "TEST_auto_flags_new_install";
 const string kAutoFlagsApplyDelayFlagName = "auto_flags_apply_delay_ms";
 const string kDisableAutoFlagsApplyDelay = Format("--$0=0", kAutoFlagsApplyDelayFlagName);
 const string kDisableAutoFlagPromoteForNewUniverse = "--limit_auto_flag_promote_for_new_universe=0";
@@ -134,9 +132,6 @@ Status TestPromote(
       resp.new_config_version(), previous_config.config_version(), IllegalState,
       "Invalid config version");
   SCHECK_GE(previous_config.promoted_flags_size(), 1, IllegalState, "Invalid promoted flags");
-  SCHECK_EQ(
-      0, CountFlagsInConfig(kTESTAutoFlagsNewInstallFlagName, previous_config), IllegalState,
-      "Invalid promoted flags");
   SCHECK_EQ(
       previous_config.promoted_flags_size(),
       CountFlagsInConfig(kTESTAutoFlagsInitializedFlagName, previous_config), IllegalState,
@@ -158,9 +153,6 @@ Status TestPromote(
   SCHECK_EQ(
       resp.new_config_version(), previous_config.config_version(), IllegalState,
       "Invalid config version");
-  SCHECK_EQ(
-      0, CountFlagsInConfig(kTESTAutoFlagsNewInstallFlagName, previous_config), IllegalState,
-      "Invalid promoted flags");
   SCHECK_EQ(
       previous_config.promoted_flags_size(),
       CountFlagsInConfig(kTESTAutoFlagsInitializedFlagName, previous_config), IllegalState,
@@ -169,14 +161,6 @@ Status TestPromote(
       count_promoted_flags, CountPromotedFlags(previous_config), IllegalState,
       "No new flags should be promoted");
 
-  // Verify it is not possible to promote with AutoFlagClass::kNewInstallsOnly.
-  req.set_max_flag_class(ToString(AutoFlagClass::kNewInstallsOnly));
-  auto result = promote_auto_flags(req);
-  SCHECK(!result.ok(), IllegalState, "Invalid result");
-  SCHECK(
-      result.status().IsInvalidArgument(), IllegalState, "Invalid outcome ",
-      result.status().ToString());
-
   return Status::OK();
 }
 
@@ -212,24 +196,15 @@ class AutoFlagsMiniClusterTest : public MiniClusterTestWithClient<MiniCluster> {
     SCHECK_EQ(
         CountFlagsInConfig(kTESTAutoFlagsInitializedFlagName, leader_config, promoted_version),
         leader_config_process_count, IllegalState, Format("Unable to find $0", promoted_version));
-    SCHECK_EQ(
-        CountFlagsInConfig(kTESTAutoFlagsNewInstallFlagName, leader_config, promoted_version),
-        leader_config_process_count, IllegalState, "Unable to find");
 
     if (FLAGS_disable_auto_flags_management) {
       SCHECK(
           !FLAGS_TEST_auto_flags_initialized, IllegalState,
           "TEST_auto_flags_initialized should not be set");
-      SCHECK(
-          !FLAGS_TEST_auto_flags_new_install, IllegalState,
-          "TEST_auto_flags_new_install should not be set");
     } else {
       SCHECK(
           FLAGS_TEST_auto_flags_initialized, IllegalState,
           "TEST_auto_flags_initialized should be set");
-      SCHECK(
-          FLAGS_TEST_auto_flags_new_install, IllegalState,
-          "TEST_auto_flags_new_install should be set");
     }
 
     for (size_t i = 0; i < cluster_->num_masters(); i++) {
@@ -1002,7 +977,6 @@ TEST_F(AutoFlagsExternalMiniClusterTest, NewCluster) {
   ASSERT_NO_FATALS(BuildAndStart());
 
   ASSERT_OK(CheckFlagOnAllNodes(kTESTAutoFlagsInitializedFlagName, kTrue));
-  ASSERT_OK(CheckFlagOnAllNodes(kTESTAutoFlagsNewInstallFlagName, kTrue));
 
   auto new_master = ASSERT_RESULT(cluster_->StartShellMaster());
 
@@ -1012,19 +986,16 @@ TEST_F(AutoFlagsExternalMiniClusterTest, NewCluster) {
   ASSERT_OK(cluster_->WaitForMastersToCommitUpTo(op_id.index()));
 
   ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsInitializedFlagName, kTrue, new_master.get()));
-  ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsNewInstallFlagName, kTrue, new_master.get()));
 
   ASSERT_OK(cluster_->AddTabletServer());
   ASSERT_OK(cluster_->WaitForTabletServerCount(cluster_->num_tablet_servers(), kTimeout));
 
   ASSERT_OK(CheckFlagOnAllNodes(kTESTAutoFlagsInitializedFlagName, kTrue));
-  ASSERT_OK(CheckFlagOnAllNodes(kTESTAutoFlagsNewInstallFlagName, kTrue));
 
   for (auto* master : cluster_->master_daemons()) {
     master->Shutdown();
     ASSERT_OK(master->Restart());
     ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsInitializedFlagName, kTrue, master));
-    ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsNewInstallFlagName, kTrue, master));
     ASSERT_EQ(GetAutoFlagConfigVersion(master), 1);
   }
 
@@ -1032,7 +1003,6 @@ TEST_F(AutoFlagsExternalMiniClusterTest, NewCluster) {
     tserver->Shutdown();
     ASSERT_OK(tserver->Restart());
     ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsInitializedFlagName, kTrue, tserver));
-    ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsNewInstallFlagName, kTrue, tserver));
     ASSERT_EQ(GetAutoFlagConfigVersion(tserver), 1);
   }
 }
@@ -1049,7 +1019,6 @@ TEST_F(AutoFlagsExternalMiniClusterTest, UpgradeCluster) {
 
   ASSERT_OK(CheckFlagOnAllNodes(kDisableAutoFlagsManagementFlagName, kTrue));
   ASSERT_OK(CheckFlagOnAllNodes(kTESTAutoFlagsInitializedFlagName, kFalse));
-  ASSERT_OK(CheckFlagOnAllNodes(kTESTAutoFlagsNewInstallFlagName, kFalse));
 
   // Remove the disable_auto_flag_management flag from cluster config
   ASSERT_TRUE(Erase(disable_auto_flag_management, cluster_->mutable_extra_master_flags()));
@@ -1062,7 +1031,6 @@ TEST_F(AutoFlagsExternalMiniClusterTest, UpgradeCluster) {
   auto* new_tserver = cluster_->tablet_server(cluster_->num_tablet_servers() - 1);
   ASSERT_OK(CheckFlagOnNode(kDisableAutoFlagsManagementFlagName, kFalse, new_tserver));
   ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsInitializedFlagName, kFalse, new_tserver));
-  ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsNewInstallFlagName, kFalse, new_tserver));
   ASSERT_EQ(GetAutoFlagConfigVersion(new_tserver), 0);
 
   // Restart the new tserver
@@ -1072,7 +1040,6 @@ TEST_F(AutoFlagsExternalMiniClusterTest, UpgradeCluster) {
   ASSERT_OK(cluster_->WaitForTabletServerCount(cluster_->num_tablet_servers(), kTimeout));
   ASSERT_OK(CheckFlagOnNode(kDisableAutoFlagsManagementFlagName, kFalse, new_tserver));
   ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsInitializedFlagName, kFalse, new_tserver));
-  ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsNewInstallFlagName, kFalse, new_tserver));
   ASSERT_EQ(GetAutoFlagConfigVersion(new_tserver), 0);
 
   // Add a new master
@@ -1084,7 +1051,6 @@ TEST_F(AutoFlagsExternalMiniClusterTest, UpgradeCluster) {
   ASSERT_OK(cluster_->WaitForMastersToCommitUpTo(op_id.index()));
   ASSERT_OK(CheckFlagOnNode(kDisableAutoFlagsManagementFlagName, kFalse, new_master.get()));
   ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsInitializedFlagName, kFalse, new_master.get()));
-  ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsNewInstallFlagName, kFalse, new_master.get()));
   ASSERT_EQ(GetAutoFlagConfigVersion(new_master.get()), 0);
 
   // Restart the master
@@ -1092,7 +1058,6 @@ TEST_F(AutoFlagsExternalMiniClusterTest, UpgradeCluster) {
   ASSERT_OK(new_master->Restart());
   ASSERT_OK(CheckFlagOnNode(kDisableAutoFlagsManagementFlagName, kFalse, new_master.get()));
   ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsInitializedFlagName, kFalse, new_master.get()));
-  ASSERT_OK(CheckFlagOnNode(kTESTAutoFlagsNewInstallFlagName, kFalse, new_master.get()));
   ASSERT_EQ(GetAutoFlagConfigVersion(new_master.get()), 0);
 
   // Remove disable_auto_flag_management from each process config and restart
@@ -1117,7 +1082,6 @@ TEST_F(AutoFlagsExternalMiniClusterTest, UpgradeCluster) {
   }
 
   ASSERT_OK(CheckFlagOnAllNodes(kTESTAutoFlagsInitializedFlagName, kFalse));
-  ASSERT_OK(CheckFlagOnAllNodes(kTESTAutoFlagsNewInstallFlagName, kFalse));
 
   ASSERT_OK(TestPromote(
       [&]() -> Result<AutoFlagsConfigPB> { return GetAutoFlagsConfig(); },
diff --git a/src/yb/integration-tests/xcluster/xcluster_upgrade-test.cc b/src/yb/integration-tests/xcluster/xcluster_upgrade-test.cc
index 1b80e6a34a..2e777b05f4 100644
--- a/src/yb/integration-tests/xcluster/xcluster_upgrade-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_upgrade-test.cc
@@ -330,84 +330,4 @@ TEST_F(XClusterUpgradeTest, DemoteTargetUniverseFlag) {
   ASSERT_OK(VerifyReplicationError(consumer_table_id, stream_id, std::nullopt));
 }
 
-class XClusterUpgradeExternalMiniClusterTest : public XClusterExternalMiniClusterBase {
- public:
-  static constexpr auto kAutoFlagValidationFlag = "enable_xcluster_auto_flag_validation";
-  const std::string kDisableAutoFlagValidation = Format("--$0=false", kAutoFlagValidationFlag);
-  const std::string kLimitLocalAutoFlagsOnCreate = Format(
-      "--limit_auto_flag_promote_for_new_universe=$0",
-      to_underlying(AutoFlagClass::kLocalPersisted));
-  const std::string kLimitExternalAutoFlagsOnCreate = Format(
-      "--limit_auto_flag_promote_for_new_universe=$0", to_underlying(AutoFlagClass::kExternal));
-
-  void AddCommonOptions() override {
-    XClusterExternalMiniClusterBase::AddCommonOptions();
-
-    setup_opts_.tserver_flags.push_back(
-        "--replication_failure_delay_exponent=10");  // 1s max backoff.
-  }
-};
-
-// Verify xCluster Setup and replication works when Source universe is on a version that does not
-// support AutoFlag validation.
-TEST_F_EX(
-    XClusterUpgradeTest, SourceWithoutAutoFlagCompatiblity,
-    XClusterUpgradeExternalMiniClusterTest) {
-  source_cluster_.setup_opts_.master_flags.emplace_back(kLimitLocalAutoFlagsOnCreate);
-  source_cluster_.setup_opts_.master_flags.emplace_back(kDisableAutoFlagValidation);
-  source_cluster_.setup_opts_.tserver_flags.emplace_back(kDisableAutoFlagValidation);
-
-  ASSERT_OK(SetupClustersAndReplicationGroup());
-
-  auto stream_id = ASSERT_RESULT(GetStreamId());
-  ASSERT_OK(VerifyReplicationError(TargetTable(), stream_id, std::nullopt));
-
-  // Insert rows and validate
-  ASSERT_OK(VerifyReplicationError(TargetTable(), stream_id, std::nullopt));
-
-  ASSERT_OK(SourceCluster()->SetFlagOnMasters(kAutoFlagValidationFlag, "true"));
-  ASSERT_OK(SourceCluster()->SetFlagOnTServers(kAutoFlagValidationFlag, "true"));
-  ASSERT_OK(PromoteAutoFlags(SourceCluster(), AutoFlagClass::kLocalPersisted, /* force */ true));
-
-  // Insert rows and validate
-  ASSERT_OK(VerifyReplicationError(TargetTable(), stream_id, std::nullopt));
-
-  ASSERT_OK(PromoteAutoFlags(SourceCluster()));
-  // Insert rows and validate
-  ASSERT_OK(VerifyReplicationError(TargetTable(), stream_id, std::nullopt));
-}
-
-// Verify xCluster Setup and replication works when Target universe is on a version that does not
-// support AutoFlag validation.
-TEST_F_EX(
-    XClusterUpgradeTest, TargetWithoutAutoFlagCompatiblity,
-    XClusterUpgradeExternalMiniClusterTest) {
-  // We dont want kNewInstallsOnly AutoFlags as those never get promoted.
-  source_cluster_.setup_opts_.master_flags.emplace_back(kLimitExternalAutoFlagsOnCreate);
-
-  target_cluster_.setup_opts_.master_flags.emplace_back(kLimitLocalAutoFlagsOnCreate);
-  target_cluster_.setup_opts_.master_flags.emplace_back(kDisableAutoFlagValidation);
-  target_cluster_.setup_opts_.tserver_flags.emplace_back(kDisableAutoFlagValidation);
-
-  ASSERT_OK(SetupClustersAndReplicationGroup());
-
-  auto stream_id = ASSERT_RESULT(GetStreamId());
-  ASSERT_OK(VerifyReplicationError(TargetTable(), stream_id, std::nullopt));
-
-  // Insert rows and validate
-  ASSERT_OK(VerifyReplicationError(TargetTable(), stream_id, std::nullopt));
-
-  ASSERT_OK(TargetCluster()->SetFlagOnMasters(kAutoFlagValidationFlag, "true"));
-  ASSERT_OK(TargetCluster()->SetFlagOnTServers(kAutoFlagValidationFlag, "true"));
-
-  // Force promote flags so that AutoFlag validation runs.
-  ASSERT_OK(PromoteAutoFlags(TargetCluster(), AutoFlagClass::kLocalPersisted, /* force */ true));
-
-  ASSERT_OK(VerifyReplicationError(
-      TargetTable(), stream_id, REPLICATION_AUTO_FLAG_CONFIG_VERSION_MISMATCH));
-
-  ASSERT_OK(PromoteAutoFlags(TargetCluster(), AutoFlagClass::kExternal, /* force */ true));
-  ASSERT_OK(VerifyReplicationError(TargetTable(), stream_id, std::nullopt));
-}
-
 }  // namespace yb
diff --git a/src/yb/master/master_auto_flags_manager.cc b/src/yb/master/master_auto_flags_manager.cc
index 7e35fb0133..207889a758 100644
--- a/src/yb/master/master_auto_flags_manager.cc
+++ b/src/yb/master/master_auto_flags_manager.cc
@@ -22,9 +22,9 @@
 #include "yb/util/scope_exit.h"
 
 DEFINE_NON_RUNTIME_int32(limit_auto_flag_promote_for_new_universe,
-    yb::to_underlying(yb::AutoFlagClass::kNewInstallsOnly),
+    yb::to_underlying(yb::AutoFlagClass::kExternal),
     "The maximum class value up to which AutoFlags are promoted during new cluster creation. "
-    "Value should be in the range [0-4]. Will not promote any AutoFlags if set to 0.");
+    "Value should be in the range [0-3]. Will not promote any AutoFlags if set to 0.");
 TAG_FLAG(limit_auto_flag_promote_for_new_universe, stable);
 
 DEFINE_test_flag(bool, disable_versioned_auto_flags, false,
@@ -526,12 +526,6 @@ Status MasterAutoFlagsManager::PromoteAutoFlags(
       ParseEnumInsensitive<AutoFlagClass>(req->max_flag_class()),
       "Invalid value provided for flag class");
 
-  // It is expected PromoteAutoFlags RPC is triggered only for upgrades, hence it is required
-  // to avoid promotion of flags with AutoFlagClass::kNewInstallsOnly class.
-  SCHECK_LT(
-      max_class, AutoFlagClass::kNewInstallsOnly, InvalidArgument,
-      Format("max_class cannot be set to $0.", ToString(AutoFlagClass::kNewInstallsOnly)));
-
   auto [new_config_version, outcome] = VERIFY_RESULT(PromoteAutoFlags(
       max_class, PromoteNonRuntimeAutoFlags(req->promote_non_runtime_flags()), req->force()));
 
diff --git a/src/yb/previous_auto_flags.json b/src/yb/previous_auto_flags.json
index ecb6d74b8d..53a768a859 100644
--- a/src/yb/previous_auto_flags.json
+++ b/src/yb/previous_auto_flags.json
@@ -10,7 +10,7 @@
         },
         {
           "name": "TEST_auto_flags_new_install",
-          "class": 4,
+          "class": 3,
           "is_runtime": true
         },
         {
@@ -200,7 +200,7 @@
         },
         {
           "name": "TEST_auto_flags_new_install",
-          "class": 4,
+          "class": 3,
           "is_runtime": true
         },
         {
diff --git a/src/yb/server/auto_flags_manager_base.cc b/src/yb/server/auto_flags_manager_base.cc
index 02028ca99b..40c3301a65 100644
--- a/src/yb/server/auto_flags_manager_base.cc
+++ b/src/yb/server/auto_flags_manager_base.cc
@@ -41,8 +41,8 @@ DEFINE_RUNTIME_AUTO_bool(TEST_auto_flags_initialized, kLocalPersisted, false, tr
     "AutoFlag that indicates initialization of AutoFlags. Not meant to be overridden.");
 TAG_FLAG(TEST_auto_flags_initialized, hidden);
 
-DEFINE_RUNTIME_AUTO_bool(TEST_auto_flags_new_install, kNewInstallsOnly, false, true,
-    "AutoFlag that indicates initialization of AutoFlags for new installs only.");
+DEFINE_RUNTIME_AUTO_bool(TEST_auto_flags_new_install, kExternal, false, true,
+    "DEPRECATED AutoFlag.");
 TAG_FLAG(TEST_auto_flags_new_install, hidden);
 
 DEFINE_NON_RUNTIME_int32(auto_flags_load_from_master_backoff_increment_ms, 100,
diff --git a/src/yb/tools/yb-admin-test.cc b/src/yb/tools/yb-admin-test.cc
index ffea05bbe2..bfa10ac69f 100644
--- a/src/yb/tools/yb-admin-test.cc
+++ b/src/yb/tools/yb-admin-test.cc
@@ -1248,12 +1248,6 @@ TEST_F(AdminCliTest, PromoteAutoFlags) {
       "PromoteAutoFlags completed successfully\n"
       "New AutoFlags were promoted\n"
       "New config version: 2");
-
-  status = CallAdmin(kPromoteAutoFlagsCmd, "kNewInstallsOnly", "true", "force");
-  ASSERT_NOK(status);
-  ASSERT_STR_CONTAINS(
-      status.ToString(),
-      "Unable to promote AutoFlags: max_class cannot be set to kNewInstallsOnly.");
 }
 
 TEST_F(AdminCliTest, RollbackAutoFlags) {
diff --git a/src/yb/util/flags/auto_flags-test.cc b/src/yb/util/flags/auto_flags-test.cc
index c4d4763443..8af6bad9ad 100644
--- a/src/yb/util/flags/auto_flags-test.cc
+++ b/src/yb/util/flags/auto_flags-test.cc
@@ -206,8 +206,7 @@ TEST(AutoFlagsTest, TestDemote) {
 // min_class in base_flags exist in to_check_flags.
 TEST(AutoFlagsTest, AreAutoFlagsCompatible) {
   const string kProcess1 = "p1", kProcess2 = "p2", kProcess3 = "p3";
-  const string kLocalVolatileFlag = "LV1", kLocalPersistedFlag = "LP1", kExternalFlag = "E1",
-               kNewInstallsOnlyFlag = "NI1";
+  const string kLocalVolatileFlag = "LV1", kLocalPersistedFlag = "LP1", kExternalFlag = "E1";
   AutoFlagsInfoMap flag_infos;
   flag_infos[kProcess1].emplace_back(
       kLocalVolatileFlag, AutoFlagClass::kLocalVolatile, RuntimeAutoFlag::kTrue);
@@ -215,8 +214,6 @@ TEST(AutoFlagsTest, AreAutoFlagsCompatible) {
       kLocalPersistedFlag, AutoFlagClass::kLocalPersisted, RuntimeAutoFlag::kTrue);
   flag_infos[kProcess3].emplace_back(
       kExternalFlag, AutoFlagClass::kExternal, RuntimeAutoFlag::kFalse);
-  flag_infos[kProcess3].emplace_back(
-      kNewInstallsOnlyFlag, AutoFlagClass::kNewInstallsOnly, RuntimeAutoFlag::kTrue);
 
   AutoFlagsNameMap base_flags;
   AutoFlagsNameMap to_check_flags;
@@ -257,14 +254,13 @@ TEST(AutoFlagsTest, AreAutoFlagsCompatible) {
   to_check_flags[kProcess3].emplace(kLocalPersistedFlag);
   ASSERT_FALSE(ASSERT_RESULT(are_flags_compatible(AutoFlagClass::kLocalPersisted)));
 
-  // to_check_flags has extra kNewInstallsOnly and kExternal.
+  // to_check_flags has extra kExternal.
   to_check_flags[kProcess3].emplace(kExternalFlag);
-  to_check_flags[kProcess3].emplace(kNewInstallsOnlyFlag);
   ASSERT_FALSE(ASSERT_RESULT(are_flags_compatible(AutoFlagClass::kLocalPersisted)));
 
   // Add the missing flag to to_check_flags.
   to_check_flags[kProcess2].emplace(kLocalPersistedFlag);
-  ASSERT_TRUE(ASSERT_RESULT(are_flags_compatible(AutoFlagClass::kNewInstallsOnly)));
+  ASSERT_TRUE(ASSERT_RESULT(are_flags_compatible(AutoFlagClass::kExternal)));
 }
 
 }  // namespace yb
diff --git a/src/yb/util/flags/auto_flags.h b/src/yb/util/flags/auto_flags.h
index 4cdfdf6bf1..f13d177339 100644
--- a/src/yb/util/flags/auto_flags.h
+++ b/src/yb/util/flags/auto_flags.h
@@ -65,10 +65,8 @@ YB_DEFINE_ENUM(
     ((kLocalPersisted, 2))
     // Adds/modifies format of data which might be used outside the universe.
     // Example of external processes: XCluster and CDCServer.
-    ((kExternal, 3))
-    // Promotes a flag only for new installs, no promotions for upgrade workflow.
-    // Example: features that are not yet safe for upgrades.
-    ((kNewInstallsOnly, 4)));
+    ((kExternal, 3)));
+    // ((kNewInstallsOnly, 4))); DEPRECATED
 
 // Disable Auto Flag Promotion for a test file
 #define DISABLE_PROMOTE_ALL_AUTO_FLAGS_FOR_TEST \
