diff --git a/pg15_tests/common_upgrade.sh b/pg15_tests/common_upgrade.sh
index 6d3b993515..51d40a79f5 100644
--- a/pg15_tests/common_upgrade.sh
+++ b/pg15_tests/common_upgrade.sh
@@ -8,9 +8,12 @@ pghost3=127.0.0.$((ip_start + 2))
 # TEST_always_return_consensus_info_for_succeeded_rpc=false is needed to upgrade a release build to
 # debug.
 common_pg15_flags="TEST_always_return_consensus_info_for_succeeded_rpc=false"
+# Set ysql_hba_conf to allow local socket connections. This is needed for older builds that do not
+# have D39564.
+ysql_hba_conf_flag='"ysql_hba_conf=""local all yugabyte trust,host all all all trust"""'
 # yb_enable_expression_pushdown=false is needed because the expression pushdown rewriter is not yet
 # implemented.
-common_tserver_flags='"ysql_pg_conf_csv=yb_enable_expression_pushdown=false"'
+common_tserver_flags=$ysql_hba_conf_flag',"ysql_pg_conf_csv=yb_enable_expression_pushdown=false"'
 
 # Downloads, runs, and pushds the directory for pg11.
 # Sets $pg11path to the pg11 directory.
@@ -49,7 +52,7 @@ run_and_pushd_pg11() {
 upgrade_masters() {
   for i in {1..3}; do
     yb_ctl restart_node $i --master \
-      --master_flags="TEST_online_pg11_to_pg15_upgrade=true,master_join_existing_universe=true,$common_pg15_flags"
+      --master_flags="$ysql_hba_conf_flag,TEST_online_pg11_to_pg15_upgrade=true,master_join_existing_universe=true,$common_pg15_flags"
   done
 }
 
diff --git a/src/postgres/src/bin/pg_upgrade/option.c b/src/postgres/src/bin/pg_upgrade/option.c
index 7af2b0bd40..1a146cc3e3 100644
--- a/src/postgres/src/bin/pg_upgrade/option.c
+++ b/src/postgres/src/bin/pg_upgrade/option.c
@@ -53,13 +53,14 @@ parseCommandLine(int argc, char *argv[])
 		{"link", no_argument, NULL, 'k'},
 		{"retain", no_argument, NULL, 'r'},
 		{"jobs", required_argument, NULL, 'j'},
-		{"socketdir", required_argument, NULL, 's'},
 		{"verbose", no_argument, NULL, 'v'},
 		{"clone", no_argument, NULL, 1},
 
 		/* Yugabyte flags */
 		{"old-host", required_argument, NULL, 'h'},
 		{"new-host", required_argument, NULL, 'H'},
+		{"old-socketdir", required_argument, NULL, 's'},
+		{"new-socketdir", required_argument, NULL, 'S'},
 		{NULL, 0, NULL, 0}
 	};
 	int			option;			/* Command line option */
@@ -102,7 +103,7 @@ parseCommandLine(int argc, char *argv[])
 	if (os_user_effective_id == 0)
 		pg_fatal("%s: cannot be run as root\n", os_info.progname);
 
-	while ((option = getopt_long(argc, argv, "d:D:b:B:ch:H:j:kNo:O:p:P:rs:U:v",
+	while ((option = getopt_long(argc, argv, "d:D:b:B:ch:H:j:kNo:O:p:P:rs:S:U:v",
 								 long_options, &optindex)) != -1)
 	{
 		switch (option)
@@ -188,7 +189,11 @@ parseCommandLine(int argc, char *argv[])
 				break;
 
 			case 's':
-				user_opts.socketdir = pg_strdup(optarg);
+				old_cluster.sockdir = pg_strdup(optarg);
+				break;
+
+			case 'S':
+				new_cluster.sockdir = pg_strdup(optarg);
 				break;
 
 			case 'U':
@@ -297,11 +302,14 @@ usage(void)
 	printf(_("  -p, --old-port=PORT           old cluster port number (default %d)\n"), old_cluster.port);
 	printf(_("  -P, --new-port=PORT           new cluster port number (default %d)\n"), new_cluster.port);
 	printf(_("  -r, --retain                  retain SQL and log files after success\n"));
-	printf(_("  -s, --socketdir=DIR           socket directory to use (default current dir.)\n"));
 	printf(_("  -U, --username=NAME           cluster superuser (default \"%s\")\n"), os_info.user);
 	printf(_("  -v, --verbose                 enable verbose internal logging\n"));
 	printf(_("  -V, --version                 display version information, then exit\n"));
 	printf(_("  --clone                       clone instead of copying files to new cluster\n"));
+	printf(_("  -h, --old-host=HOST           old cluster host address\n"));
+	printf(_("  -H, --new-host=HOST           new cluster host address\n"));
+	printf(_("  -s, --old-socketdir=DIR       old cluster socket directory\n"));
+	printf(_("  -S, --new-socketdir=DIR       new cluster socket directory\n"));
 	printf(_("  -?, --help                    show this help, then exit\n"));
 	printf(_("\n"
 			 "Before running pg_upgrade you must:\n"
@@ -463,6 +471,9 @@ adjust_data_dir(ClusterInfo *cluster)
 void
 get_sock_dir(ClusterInfo *cluster, bool live_check)
 {
+	/* In Yugabyte socket directory are specified via the input arguments. */
+	Assert(!is_yugabyte_enabled());
+
 #if defined(HAVE_UNIX_SOCKETS) && !defined(WIN32)
 	if (!live_check)
 		cluster->sockdir = user_opts.socketdir;
diff --git a/src/postgres/src/bin/pg_upgrade/pg_upgrade.c b/src/postgres/src/bin/pg_upgrade/pg_upgrade.c
index 89eb0154f3..368fdc7b64 100644
--- a/src/postgres/src/bin/pg_upgrade/pg_upgrade.c
+++ b/src/postgres/src/bin/pg_upgrade/pg_upgrade.c
@@ -138,14 +138,15 @@ main(int argc, char **argv)
 	output_check_banner(live_check);
 
 	/*
-	 * This checks for Postgres versions.
-	 * The check isn't relevant to Yugabyte right now.
+	 * YB: The check for Postgres versions is performed at higher layers.
+	 * Socket directories are explicitly set from input arguments.
 	 */
 	if (!is_yugabyte_enabled())
+	{
 		check_cluster_versions();
-
-	get_sock_dir(&old_cluster, live_check);
-	get_sock_dir(&new_cluster, false);
+		get_sock_dir(&old_cluster, live_check);
+		get_sock_dir(&new_cluster, false);
+	}
 
 	/*
 	 * This checks for global state information initialized
diff --git a/src/postgres/src/bin/pg_upgrade/server.c b/src/postgres/src/bin/pg_upgrade/server.c
index 51506d690f..ecdd927d40 100644
--- a/src/postgres/src/bin/pg_upgrade/server.c
+++ b/src/postgres/src/bin/pg_upgrade/server.c
@@ -66,22 +66,16 @@ get_db_conn(ClusterInfo *cluster, const char *db_name)
 	appendPQExpBufferStr(&conn_opts, " user=");
 	appendConnStrVal(&conn_opts, os_info.user);
 	appendPQExpBuffer(&conn_opts, " port=%d", cluster->port);
-	if (is_yugabyte_enabled())
+	if (is_yugabyte_enabled() && cluster->yb_hostaddr)
 	{
-		if (cluster->yb_hostaddr)
-		{
-			appendPQExpBufferStr(&conn_opts, " host=");
-			appendConnStrVal(&conn_opts, cluster->yb_hostaddr);
-		}
+		appendPQExpBufferStr(&conn_opts, " host=");
+		appendConnStrVal(&conn_opts, cluster->yb_hostaddr);
 	}
-	else
+	else if (cluster->sockdir)
 	{
-		if (cluster->sockdir)
-		{
-			appendPQExpBufferStr(&conn_opts, " host=");
-			appendConnStrVal(&conn_opts, cluster->sockdir);
-		}
-	}	
+		appendPQExpBufferStr(&conn_opts, " host=");
+		appendConnStrVal(&conn_opts, cluster->sockdir);
+	}
 
 	conn = PQconnectdb(conn_opts.data);
 	termPQExpBuffer(&conn_opts);
@@ -109,23 +103,17 @@ cluster_conn_opts(ClusterInfo *cluster)
 	else
 		resetPQExpBuffer(buf);
 
-	if (is_yugabyte_enabled())
+	if (is_yugabyte_enabled() && cluster->yb_hostaddr)
 	{
-		if (cluster->yb_hostaddr)
-		{
-			appendPQExpBufferStr(buf, "--host ");
-			appendShellString(buf, cluster->yb_hostaddr);
-			appendPQExpBufferChar(buf, ' ');
-		}
+		appendPQExpBufferStr(buf, "--host ");
+		appendShellString(buf, cluster->yb_hostaddr);
+		appendPQExpBufferChar(buf, ' ');
 	}
-	else
+	else if (cluster->sockdir)
 	{
-		if (cluster->sockdir)
-		{
-			appendPQExpBufferStr(buf, "--host ");
-			appendShellString(buf, cluster->sockdir);
-			appendPQExpBufferChar(buf, ' ');
-		}
+		appendPQExpBufferStr(buf, "--host ");
+		appendShellString(buf, cluster->sockdir);
+		appendPQExpBufferChar(buf, ' ');
 	}
 	appendPQExpBuffer(buf, "--port %d --username ", cluster->port);
 	appendShellString(buf, os_info.user);
diff --git a/src/yb/integration-tests/external_mini_cluster.cc b/src/yb/integration-tests/external_mini_cluster.cc
index cbf74fe788..60956b96c9 100644
--- a/src/yb/integration-tests/external_mini_cluster.cc
+++ b/src/yb/integration-tests/external_mini_cluster.cc
@@ -539,6 +539,9 @@ Result<ExternalMasterPtr> ExternalMiniCluster::StartMaster(
   if (opts_.enable_ysql) {
     flags.push_back("--enable_ysql=true");
     flags.push_back("--master_auto_run_initdb");
+    if (opts_.enable_ysql_auth) {
+      flags.push_back("--ysql_enable_auth=true");
+    }
   } else {
     flags.push_back("--enable_ysql=false");
   }
@@ -1431,6 +1434,9 @@ Status ExternalMiniCluster::AddTabletServer(
   vector<string> flags = opts_.extra_tserver_flags;
   if (opts_.enable_ysql) {
     flags.push_back("--enable_ysql=true");
+    if (opts_.enable_ysql_auth) {
+      flags.push_back("--ysql_enable_auth=true");
+    }
   } else {
     flags.push_back("--enable_ysql=false");
   }
@@ -2122,9 +2128,15 @@ Result<pgwrapper::PGConn> ExternalMiniCluster::ConnectToDB(
   LOG(INFO) << "Connecting to PG database " << db_name << " on tserver " << *node_index;
 
   auto* ts = tablet_server(*node_index);
-  return pgwrapper::PGConnBuilder(
-             {.host = ts->bind_host(), .port = ts->pgsql_rpc_port(), .dbname = db_name})
-      .Connect(simple_query_protocol);
+
+  auto settings = pgwrapper::PGConnSettings{
+      .host = ts->bind_host(), .port = ts->pgsql_rpc_port(), .dbname = db_name};
+
+  if (opts_.enable_ysql_auth) {
+    settings.user = "yugabyte";
+    settings.password = "yugabyte";
+  }
+  return pgwrapper::PGConnBuilder(settings).Connect(simple_query_protocol);
 }
 
 namespace {
diff --git a/src/yb/integration-tests/external_mini_cluster.h b/src/yb/integration-tests/external_mini_cluster.h
index 450d191ef2..bf206807e9 100644
--- a/src/yb/integration-tests/external_mini_cluster.h
+++ b/src/yb/integration-tests/external_mini_cluster.h
@@ -132,6 +132,7 @@ struct ExternalMiniClusterOptions {
 #endif
 
   bool enable_ysql = false;
+  bool enable_ysql_auth = false;
 
   // Directory in which to store data.
   // Default: "", which auto-generates a unique path for this cluster.
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
index 7b18add886..1cbcce2f4c 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
@@ -27,6 +27,65 @@ class Pg15UpgradeTest : public Pg15UpgradeTestBase {
   constexpr static auto kYugabyte = "yugabyte";
   constexpr static auto kPostgres = "postgres";
   constexpr static auto kSystemPlatform = "system_platform";
+
+  void TestSimpleTableUpgrade() {
+    const size_t kRowCount = 100;
+    // Create a table with 3 tablets and kRowCount rows so that each tablet has at least a few rows.
+    ASSERT_OK(ExecuteStatements(
+        {"CREATE TABLE t (a INT) SPLIT INTO 3 TABLETS",
+         Format("INSERT INTO t VALUES(generate_series(1, $0))", kRowCount)}));
+    static const auto kSelectFromTable = "SELECT * FROM t";
+
+    ASSERT_OK(UpgradeClusterToMixedMode());
+
+    {
+      auto conn = ASSERT_RESULT(CreateConnToTs(kMixedModeTserverPg15));
+      auto count = ASSERT_RESULT(conn.Fetch(kSelectFromTable));
+      ASSERT_EQ(PQntuples(count.get()), kRowCount);
+    }
+    {
+      auto conn = ASSERT_RESULT(CreateConnToTs(kMixedModeTserverPg11));
+      auto count = ASSERT_RESULT(conn.Fetch(kSelectFromTable));
+      ASSERT_EQ(PQntuples(count.get()), kRowCount);
+    }
+
+    ASSERT_OK(FinalizeUpgradeFromMixedMode());
+
+    // Verify row count from a random tserver.
+    {
+      auto conn = ASSERT_RESULT(cluster_->ConnectToDB());
+      auto count = ASSERT_RESULT(conn.Fetch(kSelectFromTable));
+      ASSERT_EQ(PQntuples(count.get()), kRowCount);
+    }
+  }
+
+  // Stops the tserver running on the yb-master leader node.
+  // The tserver must be restarted before the test completes for it to succeed the shutdown in the
+  // success case.
+  Result<ExternalTabletServer*> StopMasterLeaderTServer() {
+    const auto master = cluster_->GetLeaderMaster();
+    RETURN_NOT_OK(cluster_->SetFlag(
+        master, "tserver_unresponsive_timeout_ms", ToString(2000 * kTimeMultiplier)));
+
+    const auto num_tservers = cluster_->num_tablet_servers();
+    size_t master_tserver_idx = num_tservers;
+    const auto master_host = master->bound_rpc_addr().host();
+    for (size_t i = 0; i < num_tservers; ++i) {
+      if (cluster_->tablet_server(i)->bind_host() == master->bound_rpc_addr().host()) {
+        master_tserver_idx = i;
+        break;
+      }
+    }
+    SCHECK_NE(
+        master_tserver_idx, num_tservers, IllegalState,
+        Format("Tserver not found on master host $0", master_host));
+
+    auto master_tserver = cluster_->tablet_server(master_tserver_idx);
+    master_tserver->Shutdown();
+    RETURN_NOT_OK(cluster_->WaitForMasterToMarkTSDead(static_cast<int>(master_tserver_idx)));
+
+    return master_tserver;
+  }
 };
 
 TEST_F(Pg15UpgradeTest, CheckVersion) {
@@ -59,36 +118,7 @@ TEST_F(Pg15UpgradeTest, CheckVersion) {
   }
 }
 
-TEST_F(Pg15UpgradeTest, SimpleTable) {
-  const size_t kRowCount = 100;
-  // Create a table with 3 tablets and kRowCount rows so that each tablet has at least a few rows.
-  ASSERT_OK(ExecuteStatements(
-      {"CREATE TABLE t (a INT) SPLIT INTO 3 TABLETS",
-       Format("INSERT INTO t VALUES(generate_series(1, $0))", kRowCount)}));
-  static const auto kSelectFromTable = "SELECT * FROM t";
-
-  ASSERT_OK(UpgradeClusterToMixedMode());
-
-  {
-    auto conn = ASSERT_RESULT(CreateConnToTs(kMixedModeTserverPg15));
-    auto count = ASSERT_RESULT(conn.Fetch(kSelectFromTable));
-    ASSERT_EQ(PQntuples(count.get()), kRowCount);
-  }
-  {
-    auto conn = ASSERT_RESULT(CreateConnToTs(kMixedModeTserverPg11));
-    auto count = ASSERT_RESULT(conn.Fetch(kSelectFromTable));
-    ASSERT_EQ(PQntuples(count.get()), kRowCount);
-  }
-
-  ASSERT_OK(FinalizeUpgradeFromMixedMode());
-
-  // Verify row count from a random tserver.
-  {
-    auto conn = ASSERT_RESULT(cluster_->ConnectToDB());
-    auto count = ASSERT_RESULT(conn.Fetch(kSelectFromTable));
-    ASSERT_EQ(PQntuples(count.get()), kRowCount);
-  }
-}
+TEST_F(Pg15UpgradeTest, SimpleTable) { ASSERT_NO_FATALS(TestSimpleTableUpgrade()); }
 
 TEST_F(Pg15UpgradeTest, BackslashD) {
   ASSERT_OK(ExecuteStatement("CREATE TABLE t (a INT)"));
@@ -790,4 +820,44 @@ TEST_F(Pg15UpgradeTest, PartitionedTables) {
   }
 }
 
+class Pg15UpgradeTestWithAuth : public Pg15UpgradeTest {
+ public:
+  Pg15UpgradeTestWithAuth() = default;
+
+  void SetUpOptions(ExternalMiniClusterOptions& opts) override {
+    opts.enable_ysql_auth = true;
+    Pg15UpgradeTest::SetUpOptions(opts);
+  }
+};
+
+// Make sure upgrade succeeds in non auth universes even if there is no tserver on the master node.
+TEST_F(Pg15UpgradeTest, NoTserverOnMasterNode) {
+  static const MonoDelta no_delay_between_nodes = 0s;
+  ASSERT_OK(RestartAllMastersInCurrentVersion(no_delay_between_nodes));
+
+  auto master_tserver = ASSERT_RESULT(StopMasterLeaderTServer());
+
+  ASSERT_OK(PerformYsqlMajorVersionUpgrade());
+  ASSERT_OK(master_tserver->Restart());
+  ASSERT_OK(WaitForClusterToStabilize());
+
+  ASSERT_OK(RestartAllTServersInCurrentVersion(no_delay_between_nodes));
+  ASSERT_OK(FinalizeUpgrade());
+}
+
+// Make sure upgrade fails in auth enabled universes if there is no tserver on the master node.
+TEST_F(Pg15UpgradeTestWithAuth, NoTserverOnMasterNode) {
+  static const MonoDelta no_delay_between_nodes = 0s;
+  ASSERT_OK(RestartAllMastersInCurrentVersion(no_delay_between_nodes));
+
+  auto master_tserver = ASSERT_RESULT(StopMasterLeaderTServer());
+
+  ASSERT_NOK_STR_CONTAINS(PerformYsqlMajorVersionUpgrade(), "Failed to run pg_upgrade");
+  ASSERT_OK(master_tserver->Restart());
+}
+
+TEST_F(Pg15UpgradeTestWithAuth, UpgradeAuthEnabledUniverse) {
+  ASSERT_NO_FATALS(TestSimpleTableUpgrade());
+}
+
 }  // namespace yb
diff --git a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
index 5daa167712..d4bf6d2a2c 100644
--- a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
+++ b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
@@ -179,16 +179,16 @@ Status RestartDaemonInVersion(T& daemon, const std::string& bin_path) {
   return daemon.Restart();
 }
 
-void AddFlagToCsvFlag(
+void AppendCsvFlagValue(
     std::vector<std::string>& flag_list, const std::string& flag_name,
-    const std::string& flag_to_add) {
+    const std::string& value_to_add) {
   for (auto& flag : flag_list) {
     if (flag.starts_with(Format("--$0=", flag_name))) {
-      flag += Format(",$0", flag_to_add);
+      flag += Format(",$0", value_to_add);
       return;
     }
   }
-  flag_list.push_back(Format("--$0=$1", flag_name, flag_to_add));
+  flag_list.push_back(Format("--$0=$1", flag_name, value_to_add));
 }
 
 // Add the flag_name to undefok list, so that it can be set on all versions even if the version does
@@ -197,7 +197,7 @@ void AddFlagToCsvFlag(
 void AddUnDefOkAndSetFlag(
     std::vector<std::string>& flag_list, const std::string& flag_name,
     const std::string& flag_value) {
-  AddFlagToCsvFlag(flag_list, "undefok", flag_name);
+  AppendCsvFlagValue(flag_list, "undefok", flag_name);
   flag_list.emplace_back(Format("--$0=$1", flag_name, flag_value));
 }
 
@@ -276,10 +276,24 @@ Status UpgradeTestBase::StartClusterInOldVersion() {
   return StartClusterInOldVersion(default_opts);
 }
 
-Status UpgradeTestBase::StartClusterInOldVersion(const ExternalMiniClusterOptions& options) {
-  ExternalMiniClusterOptions opts = options;
+void UpgradeTestBase::SetUpOptions(ExternalMiniClusterOptions& opts) {
   opts.enable_ysql = true;
-  opts.daemon_bin_path = VERIFY_RESULT(DownloadAndGetBinPath(old_version_info_));
+  opts.daemon_bin_path = ASSERT_RESULT(DownloadAndGetBinPath(old_version_info_));
+
+  // There should be at least one tserver running on the same address as master.
+  // This will force all masters to run on 127.0.0.2 and tservers to run on 127.0.0.2, 127.0.0.4
+  // and 127.0.0.6.
+  opts.use_even_ips = true;
+
+  // Allow local socket connections for ysqlsh. This was added in newer versions as part of
+  // D39566.
+  std::string hba_conf_value = "local all yugabyte trust";
+  if (!opts.enable_ysql_auth) {
+    // Include the default allow all setting.
+    hba_conf_value += ",host all all all trust";
+  }
+  AppendCsvFlagValue(opts.extra_master_flags, "ysql_hba_conf_csv", hba_conf_value);
+  AppendCsvFlagValue(opts.extra_tserver_flags, "ysql_hba_conf_csv", hba_conf_value);
 
   // Disable TEST_always_return_consensus_info_for_succeeded_rpc since it is not upgrade safe.
   AddUnDefOkAndSetFlag(
@@ -287,9 +301,13 @@ Status UpgradeTestBase::StartClusterInOldVersion(const ExternalMiniClusterOption
   AddUnDefOkAndSetFlag(
       opts.extra_tserver_flags, "TEST_always_return_consensus_info_for_succeeded_rpc", "false");
 
+  ExternalMiniClusterITestBase::SetUpOptions(opts);
+}
+
+Status UpgradeTestBase::StartClusterInOldVersion(const ExternalMiniClusterOptions& options) {
   LOG(INFO) << "Starting cluster in version: " << old_version_info_.version;
 
-  RETURN_NOT_OK(ExternalMiniClusterITestBase::StartCluster(opts));
+  RETURN_NOT_OK(ExternalMiniClusterITestBase::StartCluster(options));
 
   old_version_bin_path_ = cluster_->GetDaemonBinPath();
   old_version_master_bin_path_ = cluster_->GetMasterBinaryPath();
diff --git a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h
index 91c810ba1d..bc00178c37 100644
--- a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h
+++ b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h
@@ -39,6 +39,7 @@ class UpgradeTestBase : public ExternalMiniClusterITestBase {
   void SetUp() override;
 
  protected:
+  void SetUpOptions(ExternalMiniClusterOptions& opts) override;
   Status StartClusterInOldVersion();
   Status StartClusterInOldVersion(const ExternalMiniClusterOptions& options);
 
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 461c6041f4..7f949a059b 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -13354,7 +13354,11 @@ Result<TablegroupId> CatalogManager::GetTablegroupId(const TableId& table_id) {
   return tablegroup->id();
 }
 
-Result<TSDescriptorPtr> CatalogManager::GetClosestLiveTserver() const {
+Result<TSDescriptorPtr> CatalogManager::GetClosestLiveTserver(bool* local_ts) const {
+  if (local_ts) {
+    *local_ts = false;
+  }
+
   ServerRegistrationPB local_registration;
   RETURN_NOT_OK(master_->GetMasterRegistration(&local_registration));
 
@@ -13387,6 +13391,9 @@ Result<TSDescriptorPtr> CatalogManager::GetClosestLiveTserver() const {
       // If this tserver is on the same node as master pick it.
       for (const auto& addr : ts_info.registration().common().private_rpc_addresses()) {
         if (local_hosts.contains(addr.host())) {
+          if (local_ts) {
+            *local_ts = true;
+          }
           return desc;
         }
       }
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index 1f14435ca3..47b3bbf9b6 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -1699,7 +1699,7 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
       SysRowEntryType type, const std::string& item_id, const std::string& debug_string,
       QLWriteRequestPB::QLStmtType op_type);
 
-  Result<TSDescriptorPtr> GetClosestLiveTserver() const override;
+  Result<TSDescriptorPtr> GetClosestLiveTserver(bool* local_ts = nullptr) const override;
 
  protected:
   // TODO Get rid of these friend classes and introduce formal interface.
diff --git a/src/yb/master/catalog_manager_if.h b/src/yb/master/catalog_manager_if.h
index 672009591d..c2524daf24 100644
--- a/src/yb/master/catalog_manager_if.h
+++ b/src/yb/master/catalog_manager_if.h
@@ -343,7 +343,7 @@ class CatalogManagerIf {
   virtual Status CanSupportAdditionalTablet(
       const TableInfoPtr& table, const ReplicationInfoPB& replication_info) const = 0;
 
-  virtual Result<TSDescriptorPtr> GetClosestLiveTserver() const = 0;
+  virtual Result<TSDescriptorPtr> GetClosestLiveTserver(bool* local_ts = nullptr) const = 0;
 
   virtual ~CatalogManagerIf() = default;
 };
diff --git a/src/yb/master/master-test.cc b/src/yb/master/master-test.cc
index 614ffa0f05..63e65425fd 100644
--- a/src/yb/master/master-test.cc
+++ b/src/yb/master/master-test.cc
@@ -2778,10 +2778,12 @@ TEST_F(MasterStartUpTest, JoinExistingClusterUnsetWithoutMasterAddresses) {
 TEST_F(MasterTest, TestGetClosestLiveTserver) {
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_tserver_unresponsive_timeout_ms) = 5 * 60 * 1000;
 
+  bool local_ts = false;
   auto& catalog_manager = mini_master_->catalog_manager();
-  auto result = catalog_manager.GetClosestLiveTserver();
+  auto result = catalog_manager.GetClosestLiveTserver(&local_ts);
   // No valid tservers.
   ASSERT_NOK(result);
+  ASSERT_FALSE(local_ts);
 
   uint32 tserver_idx = 1;
   auto add_tserver = [this, &tserver_idx](
@@ -2805,23 +2807,25 @@ TEST_F(MasterTest, TestGetClosestLiveTserver) {
   {
     const auto tserver1_uuid = "uuid-1";
     ASSERT_OK(add_tserver(tserver1_uuid, "cloud2", "rack1", "zone", "host1"));
-    auto closest_tserver = ASSERT_RESULT(catalog_manager.GetClosestLiveTserver());
+    auto closest_tserver = ASSERT_RESULT(catalog_manager.GetClosestLiveTserver(&local_ts));
     ASSERT_EQ(closest_tserver->permanent_uuid(), tserver1_uuid);
+    ASSERT_FALSE(local_ts);
   }
 
   // Add tserver in same cloud, different region.
   {
     const auto tserver2_uuid = "uuid-2";
     ASSERT_OK(add_tserver(tserver2_uuid, "cloud1", "rack2", "zone", "host1"));
-    auto closest_tserver = ASSERT_RESULT(catalog_manager.GetClosestLiveTserver());
+    auto closest_tserver = ASSERT_RESULT(catalog_manager.GetClosestLiveTserver(&local_ts));
     ASSERT_EQ(closest_tserver->permanent_uuid(), tserver2_uuid);
+    ASSERT_FALSE(local_ts);
   }
 
   // Add tserver in same cloud, same region, different zone.
   {
     const auto tserver3_uuid = "uuid-3";
     ASSERT_OK(add_tserver(tserver3_uuid, "cloud1", "rack1", "zone2", "host1"));
-    auto closest_tserver = ASSERT_RESULT(catalog_manager.GetClosestLiveTserver());
+    auto closest_tserver = ASSERT_RESULT(catalog_manager.GetClosestLiveTserver(&local_ts));
     ASSERT_EQ(closest_tserver->permanent_uuid(), tserver3_uuid);
   }
 
@@ -2829,8 +2833,9 @@ TEST_F(MasterTest, TestGetClosestLiveTserver) {
   {
     const auto tserver4_uuid = "uuid-4";
     ASSERT_OK(add_tserver(tserver4_uuid, "cloud1", "rack1", "zone", "host1"));
-    auto closest_tserver = ASSERT_RESULT(catalog_manager.GetClosestLiveTserver());
+    auto closest_tserver = ASSERT_RESULT(catalog_manager.GetClosestLiveTserver(&local_ts));
     ASSERT_EQ(closest_tserver->permanent_uuid(), tserver4_uuid);
+    ASSERT_FALSE(local_ts);
   }
 
   // Add tserver in same host as master.
@@ -2840,8 +2845,9 @@ TEST_F(MasterTest, TestGetClosestLiveTserver) {
     auto master_host = master_registration.private_rpc_addresses().begin()->host();
     const auto tserver5_uuid = "uuid-5";
     ASSERT_OK(add_tserver(tserver5_uuid, "cloud1", "rack1", "zone", std::move(master_host)));
-    auto closest_tserver = ASSERT_RESULT(catalog_manager.GetClosestLiveTserver());
+    auto closest_tserver = ASSERT_RESULT(catalog_manager.GetClosestLiveTserver(&local_ts));
     ASSERT_EQ(closest_tserver->permanent_uuid(), tserver5_uuid);
+    ASSERT_TRUE(local_ts);
   }
 }
 
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
index 700367b5cc..49d770453a 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
@@ -20,6 +20,8 @@
 #include "yb/tablet/tablet_peer.h"
 
 #include "yb/util/async_util.h"
+#include "yb/util/net/net_util.h"
+#include "yb/util/pg_util.h"
 #include "yb/util/scope_exit.h"
 #include "yb/util/status.h"
 
@@ -224,13 +226,25 @@ Status YsqlInitDBAndMajorUpgradeHandler::PerformPgUpgrade(const LeaderEpoch& epo
   auto se = ScopeExit([&pg_supervisor]() { pg_supervisor.Stop(); });
   RETURN_NOT_OK(pg_supervisor.Start());
 
-  auto closest_ts = VERIFY_RESULT(master_.catalog_manager()->GetClosestLiveTserver());
-  PgWrapper::PgUpgradeParams pg_upgrade_params{
-      .data_dir = pg_conf.data_dir,
-      .old_version_pg_address = VERIFY_RESULT(closest_ts->GetHostPort()).host(),
-      .old_version_pg_port = narrow_cast<uint16_t>(closest_ts->GetRegistration().pg_port()),
-      .new_version_pg_address = pg_conf.listen_addresses,
-      .new_version_pg_port = pg_conf.pg_port};
+  PgWrapper::PgUpgradeParams pg_upgrade_params;
+  pg_upgrade_params.data_dir = pg_conf.data_dir;
+  pg_upgrade_params.new_version_socket_dir =
+      PgDeriveSocketDir(HostPort(pg_conf.listen_addresses, pg_conf.pg_port));
+  pg_upgrade_params.new_version_pg_port = pg_conf.pg_port;
+
+  bool local_ts = false;
+  auto closest_ts = VERIFY_RESULT(master_.catalog_manager()->GetClosestLiveTserver(&local_ts));
+  auto closest_ts_hp = HostPort(
+      VERIFY_RESULT(closest_ts->GetHostPort()).host(),
+      narrow_cast<uint16_t>(closest_ts->GetRegistration().pg_port()));
+
+  if (local_ts) {
+    pg_upgrade_params.old_version_socket_dir = PgDeriveSocketDir(closest_ts_hp);
+  } else {
+    pg_upgrade_params.old_version_pg_address = closest_ts_hp.host();
+  }
+  pg_upgrade_params.old_version_pg_port = closest_ts_hp.port();
+
   RETURN_NOT_OK(PgWrapper::RunPgUpgrade(pg_upgrade_params));
 
   return Status::OK();
diff --git a/src/yb/yql/pgwrapper/pg_wrapper.cc b/src/yb/yql/pgwrapper/pg_wrapper.cc
index aacb927f4d..3614ff2223 100644
--- a/src/yb/yql/pgwrapper/pg_wrapper.cc
+++ b/src/yb/yql/pgwrapper/pg_wrapper.cc
@@ -101,8 +101,8 @@ TAG_FLAG(pg_stat_statements_enabled, advanced);
 TAG_FLAG(pg_stat_statements_enabled, hidden);
 
 // Top-level postgres configuration flags.
-DEFINE_UNKNOWN_bool(ysql_enable_auth, false,
-              "True to enforce password authentication for all connections");
+DEFINE_NON_RUNTIME_bool(ysql_enable_auth, false,
+    "True to enforce password authentication for all connections");
 
 // Catch-all postgres configuration flags.
 DEFINE_RUNTIME_string(ysql_pg_conf_csv, "",
@@ -910,11 +910,18 @@ Status PgWrapper::RunPgUpgrade(const PgUpgradeParams& param) {
   std::vector<std::string> args{
       program_path,
       "--new-datadir", param.data_dir,
-      "--old-host", param.old_version_pg_address,
-      "--old-port", ToString(param.old_version_pg_port),
-      "--new-host", param.new_version_pg_address,
+      "--username", "yugabyte",
+      "--new-socketdir", param.new_version_socket_dir,
       "--new-port", ToString(param.new_version_pg_port),
-      "--username", "yugabyte"};
+      "--old-port", ToString(param.old_version_pg_port)};
+
+  if (!param.old_version_socket_dir.empty()) {
+    args.push_back("--old-socketdir");
+    args.push_back(param.old_version_socket_dir);
+  } else {
+    args.push_back("--old-host");
+    args.push_back(param.old_version_pg_address);
+  }
 
   LOG(INFO) << "Launching pg_upgrade: " << AsString(args);
   Subprocess subprocess(program_path, args);
diff --git a/src/yb/yql/pgwrapper/pg_wrapper.h b/src/yb/yql/pgwrapper/pg_wrapper.h
index fc2cd62e9c..246b5550cf 100644
--- a/src/yb/yql/pgwrapper/pg_wrapper.h
+++ b/src/yb/yql/pgwrapper/pg_wrapper.h
@@ -97,8 +97,9 @@ class PgWrapper : public ProcessWrapper {
   struct PgUpgradeParams {
     std::string data_dir;
     std::string old_version_pg_address;
+    std::string old_version_socket_dir;
     uint16_t old_version_pg_port;
-    std::string new_version_pg_address;
+    std::string new_version_socket_dir;
     uint16_t new_version_pg_port;
   };
 
