diff --git a/src/yb/master/cluster_balance.cc b/src/yb/master/cluster_balance.cc
index 34c5780e32..d2241a4239 100644
--- a/src/yb/master/cluster_balance.cc
+++ b/src/yb/master/cluster_balance.cc
@@ -236,10 +236,9 @@ void ClusterLoadBalancer::InitTablespaceManager() {
 
 Status ClusterLoadBalancer::PopulateReplicationInfo(
     const scoped_refptr<TableInfo>& table, const ReplicationInfoPB& replication_info) {
-  PlacementInfoPB pb;
 
   if (state_->options_->type == ReplicaType::kLive) {
-    pb.CopyFrom(replication_info.live_replicas());
+    state_->placement_.CopyFrom(replication_info.live_replicas());
   } else if (state_->options_->type == ReplicaType::kReadOnly) {
     if (replication_info.read_replicas_size() == 0) {
       // Should not reach here as tables that should not have read replicas should
@@ -248,11 +247,9 @@ Status ClusterLoadBalancer::PopulateReplicationInfo(
           IllegalState, "Encountered a table $0 with no read replicas. Placement info $1",
           table->id(), replication_info);
     }
-    pb.CopyFrom(GetReadOnlyPlacementFromUuid(replication_info));
+    state_->placement_.CopyFrom(GetReadOnlyPlacementFromUuid(replication_info));
   }
 
-  state_->placement_by_table_[table->id()] = std::move(pb);
-
   bool is_txn_table = table->GetTableType() == TRANSACTION_STATUS_TABLE_TYPE;
   state_->use_preferred_zones_ = !is_txn_table || FLAGS_transaction_tables_use_preferred_zones;
   if (state_->use_preferred_zones_) {
@@ -262,21 +259,6 @@ Status ClusterLoadBalancer::PopulateReplicationInfo(
   return Status::OK();
 }
 
-Status ClusterLoadBalancer::UpdateTabletInfo(TabletInfo* tablet) {
-  // The placement information should already be set.
-  if (!state_->placement_by_table_.count(tablet->table()->id())) {
-    return STATUS_FORMAT(
-        IllegalState, "Encountered a table $0 with no Placement info.", tablet->table()->name());
-  }
-
-  return state_->UpdateTablet(tablet);
-}
-
-const PlacementInfoPB& ClusterLoadBalancer::GetPlacementByTablet(const TabletId& tablet_id) const {
-  const auto& table_id = GetTabletMap().at(tablet_id)->table()->id();
-  return state_->placement_by_table_.at(table_id);
-}
-
 size_t ClusterLoadBalancer::get_total_wrong_placement() const {
   return state_->tablets_wrong_placement_.size();
 }
@@ -873,7 +855,7 @@ Status ClusterLoadBalancer::AnalyzeTabletsUnlocked(const TableId& table_uuid) {
     // concerned, but just be underreplicated, and have some TS currently bootstrapping instances
     // of the tablet.
     if (tablet_running) {
-      RETURN_NOT_OK(UpdateTabletInfo(tablet.get()));
+      RETURN_NOT_OK(state_->UpdateTablet(tablet.get()));
     }
   }
   state_->SetInitialized();
@@ -918,7 +900,6 @@ Result<bool> ClusterLoadBalancer::HandleAddIfMissingPlacement(
   RETURN_NOT_OK(CanAddReplicas());
 
   const auto& tablet_meta = state_->per_tablet_meta_[tablet_id];
-  const auto& placement_info = GetPlacementByTablet(tablet_id);
   const auto& missing_placements = tablet_meta.under_replicated_placements;
   if (VLOG_IS_ON(3)) {
     std::ostringstream out;
@@ -934,48 +915,34 @@ Result<bool> ClusterLoadBalancer::HandleAddIfMissingPlacement(
   // Loop through TSs by load to find a TS that matches the placement needed and does not already
   // host this tablet.
   for (const auto& ts_uuid : state_->sorted_load_) {
-    bool can_choose_ts = false;
-    // If we had no placement information, it means we are just under-replicated, so just check
-    // that we can use this tablet server.
-    if (placement_info.placement_blocks().empty()) {
-      // No need to check placement info, as there is none.
-      can_choose_ts = VERIFY_RESULT(
-          state_->CanAddTabletToTabletServer(tablet_id, ts_uuid, nullptr /* placement_info */));
-      VLOG(3) << "Placement info is not available for tablet " << tablet_id << " so this tablet "
-              << "can be added to any valid TS. TS " << ts_uuid
-              << ", can choose: " << can_choose_ts;
-    } else {
-      // We added a tablet to the set with missing replicas both if it is under-replicated, and we
-      // added a placement to the tablet_meta under_replicated_placements if the num replicas in
-      // that placement is fewer than min_num_replicas. If the under-replicated tablet has a
-      // placement that is under-replicated and the ts is not in that placement, then that ts
-      // isn't valid.
-      const auto& ts_meta = state_->per_ts_meta_[ts_uuid];
-      // Either we have specific placement blocks that are under-replicated, so confirm
-      // that this TS matches or all the placement blocks have min_num_replicas
-      // but overall num_replicas is fewer than expected.
-      // In the latter case, we still need to conform to the placement rules.
-      VLOG(3) << "Tablet " << tablet_id << " has " << missing_placements.size()
-              << " missing placements, checking if we can add to tserver " << ts_uuid;
-      if (missing_placements.empty() ||
-          tablet_meta.CanAddTSToMissingPlacements(ts_meta.descriptor)) {
-        // If we don't have any missing placements but are under-replicated then we need to
-        // validate placement information in order to avoid adding to a wrong placement block.
-        //
-        // Do the placement check for both the cases.
-        // If we have missing placements then this check is a tautology otherwise it matters.
-        can_choose_ts =
-            VERIFY_RESULT(state_->CanAddTabletToTabletServer(tablet_id, ts_uuid, &placement_info));
+    // We added a tablet to the set with missing replicas both if it is under-replicated, and we
+    // added a placement to the tablet_meta under_replicated_placements if the num replicas in
+    // that placement is fewer than min_num_replicas. If the under-replicated tablet has a
+    // placement that is under-replicated and the ts is not in that placement, then that ts
+    // isn't valid.
+    const auto& ts_meta = state_->per_ts_meta_[ts_uuid];
+    // Either we have specific placement blocks that are under-replicated, so confirm
+    // that this TS matches or all the placement blocks have min_num_replicas
+    // but overall num_replicas is fewer than expected.
+    // In the latter case, we still need to conform to the placement rules.
+    VLOG(3) << "Tablet " << tablet_id << " has " << missing_placements.size()
+            << " missing placements, checking if we can add to tserver " << ts_uuid;
+    if (missing_placements.empty() || tablet_meta.CanAddTSToMissingPlacements(ts_meta.descriptor)) {
+      // If we don't have any missing placements but are under-replicated then we need to
+      // validate placement information in order to avoid adding to a wrong placement block.
+      //
+      // Do the placement check for both the cases.
+      // If we have missing placements then this check is a tautology otherwise it matters.
+      bool can_choose_ts = VERIFY_RESULT(state_->CanAddTabletToTabletServer(tablet_id, ts_uuid));
+      // If we've passed the checks, then we can choose this TS to add the replica to.
+      if (can_choose_ts) {
+        *out_to_ts = ts_uuid;
+        VLOG(3) << "Found tserver " << ts_uuid << " to add a replica of tablet " << tablet_id;
+        RETURN_NOT_OK(AddReplica(tablet_id, ts_uuid));
+        state_->tablets_missing_replicas_.erase(tablet_id);
+        return true;
       }
     }
-    // If we've passed the checks, then we can choose this TS to add the replica to.
-    if (can_choose_ts) {
-      *out_to_ts = ts_uuid;
-      VLOG(3) << "Found tserver " << ts_uuid << " to add a replica of tablet " << tablet_id;
-      RETURN_NOT_OK(AddReplica(tablet_id, ts_uuid));
-      state_->tablets_missing_replicas_.erase(tablet_id);
-      return true;
-    }
   }
   return false;
 }
@@ -991,7 +958,7 @@ Result<bool> ClusterLoadBalancer::HandleAddIfWrongPlacement(
       continue;
     }
     if (VERIFY_RESULT(state_->CanSelectWrongPlacementReplicaToMove(
-            tablet_id, GetPlacementByTablet(tablet_id), out_from_ts, out_to_ts))) {
+            tablet_id, out_from_ts, out_to_ts))) {
       *out_tablet_id = tablet_id;
       VLOG(3) << "Found destination server " << *out_to_ts << " to move tablet replica "
               << tablet_id << " from " << *out_from_ts;
@@ -1194,7 +1161,7 @@ Result<bool> ClusterLoadBalancer::GetTabletToMove(
       }
 
       if (VERIFY_RESULT(
-          state_->CanAddTabletToTabletServer(tablet_id, to_ts, &GetPlacementByTablet(tablet_id)))) {
+          state_->CanAddTabletToTabletServer(tablet_id, to_ts))) {
         filtered_drive_tablets.insert(tablet_id);
       }
     }
@@ -1212,7 +1179,6 @@ Result<bool> ClusterLoadBalancer::GetTabletToMove(
     CatalogManagerUtil::CloudInfoSimilarity chosen_tablet_ci_similarity =
         CatalogManagerUtil::NO_MATCH;
     for (const TabletId& tablet_id : drive_tablets) {
-      const auto& placement_info = GetPlacementByTablet(tablet_id);
       // TODO(#15853): this should be augmented as well to allow dropping by one replica, if still
       // leaving us with more than the minimum.
       //
@@ -1226,15 +1192,15 @@ Result<bool> ClusterLoadBalancer::GetTabletToMove(
       // Note that we've assumed that for every TS there is a unique placement block to which it
       // can be mapped (see the validation rules in yb_admin-client). If there is no unique
       // placement block then it is simply the C.R.Z of the TS itself.
-      auto from_ts_block = state_->GetValidPlacement(from_ts, &placement_info);
-      auto to_ts_block = state_->GetValidPlacement(to_ts, &placement_info);
+      auto from_ts_block = state_->GetValidPlacement(from_ts);
+      auto to_ts_block = state_->GetValidPlacement(to_ts);
       bool same_placement = false;
       if (to_ts_block.has_value() && from_ts_block.has_value()) {
           same_placement = TSDescriptor::generate_placement_id(*from_ts_block) ==
                                   TSDescriptor::generate_placement_id(*to_ts_block);
       }
 
-      if (!placement_info.placement_blocks().empty() && !same_placement) {
+      if (!state_->placement_.placement_blocks().empty() && !same_placement) {
         continue;
       }
 
diff --git a/src/yb/master/cluster_balance.h b/src/yb/master/cluster_balance.h
index 2165ce801b..137cd1ab18 100644
--- a/src/yb/master/cluster_balance.h
+++ b/src/yb/master/cluster_balance.h
@@ -212,11 +212,6 @@ class ClusterLoadBalancer {
 
   virtual void InitTablespaceManager();
 
-  // Method called when initially analyzing tablets, to build up load and usage information.
-  // Returns an OK status if the method succeeded or an error if there are transient errors in
-  // updating the internal state.
-  Status UpdateTabletInfo(TabletInfo* tablet);
-
   // If a tablet is under-replicated, or has certain placements that have less than the minimum
   // required number of replicas, we need to add extra tablets to its peer set.
   // Takes in a specific tablet id which we will try to fix.
@@ -315,10 +310,6 @@ class ClusterLoadBalancer {
       REQUIRES_SHARED(catalog_manager_->mutex_);
 
   // Methods called for returning tablet id sets, for figuring out tablets to move around.
-
-  const PlacementInfoPB& GetPlacementByTablet(const TabletId& tablet_id) const
-      REQUIRES_SHARED(catalog_manager_->mutex_);
-
   // Get access to all the tablets for the given table.
   Result<TabletInfos> GetTabletsForTable(const TableId& table_uuid) const
       REQUIRES_SHARED(catalog_manager_->mutex_);
diff --git a/src/yb/master/cluster_balance_util.cc b/src/yb/master/cluster_balance_util.cc
index 10233e14d0..f04bbebf33 100644
--- a/src/yb/master/cluster_balance_util.cc
+++ b/src/yb/master/cluster_balance_util.cc
@@ -190,11 +190,6 @@ Status PerTableLoadState::UpdateTablet(TabletInfo *tablet) {
   // Set the per-tablet entry to empty default and get the reference for filling up information.
   auto& tablet_meta = per_tablet_meta_[tablet_id];
 
-  // Get the placement for this tablet.
-  const auto& placement = placement_by_table_[tablet->table()->id()];
-  VLOG(3) << "Placement policy for tablet " << tablet->tablet_id()
-          << ": " << placement.ShortDebugString();
-
   // Get replicas for this tablet.
   auto replica_map = tablet->GetReplicaLocations();
 
@@ -297,8 +292,8 @@ Status PerTableLoadState::UpdateTablet(TabletInfo *tablet) {
   }
 
   // Only set the over-replication section if we need to.
-  size_t placement_num_replicas = placement.num_replicas() > 0 ?
-      placement.num_replicas() : FLAGS_replication_factor;
+  size_t placement_num_replicas = placement_.num_replicas() > 0 ?
+      placement_.num_replicas() : FLAGS_replication_factor;
   tablet_meta.is_over_replicated = placement_num_replicas < replica_size;
   tablet_meta.is_under_replicated = placement_num_replicas > replica_size;
   if (VLOG_IS_ON(3)) {
@@ -314,7 +309,7 @@ Status PerTableLoadState::UpdateTablet(TabletInfo *tablet) {
   // use that as a marker that we are in this situation.
   //
   // For over-replication, we just add all the ts_uuids as candidates.
-  if (placement.placement_blocks().empty()) {
+  if (placement_.placement_blocks().empty()) {
     VLOG(3) << "Tablet " << tablet->tablet_id() << " does not have custom placement";
     if (tablet_meta.is_over_replicated) {
       for (auto& replica_entry : *replica_map) {
@@ -334,7 +329,7 @@ Status PerTableLoadState::UpdateTablet(TabletInfo *tablet) {
         placement_to_replicas;
     std::unordered_map<CloudInfoPB, int, cloud_hash, cloud_equal_to> placement_to_min_replicas;
     // Preset the min_replicas, so we know if we're missing replicas somewhere as well.
-    for (const auto& pb : placement.placement_blocks()) {
+    for (const auto& pb : placement_.placement_blocks()) {
       // Default empty vector.
       placement_to_replicas[pb.cloud_info()];
       placement_to_min_replicas[pb.cloud_info()] = pb.min_num_replicas();
@@ -345,7 +340,7 @@ Status PerTableLoadState::UpdateTablet(TabletInfo *tablet) {
         continue;
       }
 
-      auto ci = GetValidPlacement(ts_uuid, &placement);
+      auto ci = GetValidPlacement(ts_uuid);
       if (ci.has_value()) {
         placement_to_replicas[*ci].emplace_back(ts_uuid, &replica);
       } else {
@@ -496,7 +491,7 @@ void PerTableLoadState::UpdateTabletServer(std::shared_ptr<TSDescriptor> ts_desc
 }
 
 Result<bool> PerTableLoadState::CanAddTabletToTabletServer(
-    const TabletId& tablet_id, const TabletServerId& to_ts, const PlacementInfoPB* placement_info) {
+    const TabletId& tablet_id, const TabletServerId& to_ts) {
   const auto& ts_meta = per_ts_meta_[to_ts];
 
   // If this server is deemed DEAD then don't add it.
@@ -525,7 +520,7 @@ Result<bool> PerTableLoadState::CanAddTabletToTabletServer(
   }
 
   // If we ask to use placement information, check against it.
-  if (placement_info && !GetValidPlacement(to_ts, placement_info).has_value()) {
+  if (placement_.placement_blocks_size() > 0 && !GetValidPlacement(to_ts).has_value()) {
     YB_LOG_EVERY_N_SECS_OR_VLOG(INFO, 30, 4) << "tablet server " << to_ts << " has placement info "
         << "incompatible with tablet " << tablet_id << ". Not allowing it to host this tablet.";
     return false;
@@ -550,10 +545,9 @@ Result<bool> PerTableLoadState::CanAddTabletToTabletServer(
   return true;
 }
 
-boost::optional<CloudInfoPB> PerTableLoadState::GetValidPlacement(
-    const TabletServerId& ts_uuid, const PlacementInfoPB* placement_info) {
-  if (!placement_info->placement_blocks().empty()) {
-    for (const auto& pb : placement_info->placement_blocks()) {
+std::optional<CloudInfoPB> PerTableLoadState::GetValidPlacement(const TabletServerId& ts_uuid) {
+  if (!placement_.placement_blocks().empty()) {
+    for (const auto& pb : placement_.placement_blocks()) {
       if (per_ts_meta_[ts_uuid].descriptor->MatchesCloudInfo(pb.cloud_info())) {
         VLOG(4) << "Found matching placement for ts " << ts_uuid
                 << ", placement: " << pb.cloud_info().ShortDebugString();
@@ -561,7 +555,7 @@ boost::optional<CloudInfoPB> PerTableLoadState::GetValidPlacement(
       }
     }
     VLOG(4) << "Found no matching placement for ts " << ts_uuid;
-    return boost::none;
+    return std::nullopt;
   }
   // Return the cloudInfoPB of TS if no placement policy is specified
   VLOG(4) << "No placement policy is specified so returning default cloud info of ts"
@@ -571,8 +565,7 @@ boost::optional<CloudInfoPB> PerTableLoadState::GetValidPlacement(
 }
 
 Result<bool> PerTableLoadState::CanSelectWrongPlacementReplicaToMove(
-    const TabletId& tablet_id, const PlacementInfoPB& placement_info, TabletServerId* out_from_ts,
-    TabletServerId* out_to_ts) {
+    const TabletId& tablet_id, TabletServerId* out_from_ts, TabletServerId* out_to_ts) {
   // We consider both invalid placements (potentially due to config or schema changes) and
   // blacklisted servers as wrong placement.
   const auto& tablet_meta = per_tablet_meta_[tablet_id];
@@ -593,12 +586,12 @@ Result<bool> PerTableLoadState::CanSelectWrongPlacementReplicaToMove(
       // just try to move the load to the same placement. However, if the from_uuid was
       // previously invalidly placed, then we should ignore its placement.
       if (invalid_placement &&
-          VERIFY_RESULT(CanAddTabletToTabletServer(tablet_id, to_uuid, &placement_info))) {
+          VERIFY_RESULT(CanAddTabletToTabletServer(tablet_id, to_uuid))) {
         VLOG(3) << "Found destination " << to_uuid << " where replica can be added"
                 << ". Blacklisted tserver is also in an invalid placement";
         found_match = true;
       } else {
-        if (VERIFY_RESULT(CanAddTabletToTabletServer(tablet_id, to_uuid, &placement_info))) {
+        if (VERIFY_RESULT(CanAddTabletToTabletServer(tablet_id, to_uuid))) {
           // If we have placement information, we want to only pick the tablet if it's moving
           // to the same placement, so we guarantee we're keeping the same type of distribution.
           // Since we allow prefixes as well, we can still respect the placement of this tablet
@@ -609,8 +602,8 @@ Result<bool> PerTableLoadState::CanSelectWrongPlacementReplicaToMove(
           // Note that we've assumed that for every TS there is a unique placement block
           // to which it can be mapped (see the validation rules in yb_admin-client).
           // If there is no unique placement block then it is simply the C.R.Z of the TS itself.
-          auto ci_from_ts = GetValidPlacement(from_uuid, &placement_info);
-          auto ci_to_ts = GetValidPlacement(to_uuid, &placement_info);
+          auto ci_from_ts = GetValidPlacement(from_uuid);
+          auto ci_to_ts = GetValidPlacement(to_uuid);
           if (ci_to_ts.has_value() && ci_from_ts.has_value() &&
               TSDescriptor::generate_placement_id(*ci_from_ts) ==
                   TSDescriptor::generate_placement_id(*ci_to_ts)) {
@@ -661,7 +654,7 @@ Result<bool> PerTableLoadState::CanSelectWrongPlacementReplicaToMove(
       VLOG(3) << out.str();
     }
     for (const auto& to_uuid : sorted_load_) {
-      if (VERIFY_RESULT(CanAddTabletToTabletServer(tablet_id, to_uuid, &placement_info))) {
+      if (VERIFY_RESULT(CanAddTabletToTabletServer(tablet_id, to_uuid))) {
         *out_from_ts = *tablet_meta.wrong_placement_tablet_servers.begin();
         *out_to_ts = to_uuid;
         VLOG(3) << "Found " << to_uuid << " for tablet " << tablet_id << " source "
@@ -917,7 +910,7 @@ Status PerTableLoadState::AddStartingTablet(
     ++global_state_->total_starting_tablets_;
     ++per_tablet_meta_[tablet_id].starting;
     // If we are initializing, tablets_missing_replicas_ is not initialized yet, but
-    // UpdateTabletInfo will add the tablet to the over-replicated map if required.
+    // state_->UpdateTablet will add the tablet to the over-replicated map if required.
     // If we have already initialized and the tablet wasn't over replicated before the
     // add, it's over replicated now.
     if (initialized_ && tablets_missing_replicas_.count(tablet_id) == 0) {
diff --git a/src/yb/master/cluster_balance_util.h b/src/yb/master/cluster_balance_util.h
index 6306c566e2..e319634d00 100644
--- a/src/yb/master/cluster_balance_util.h
+++ b/src/yb/master/cluster_balance_util.h
@@ -340,7 +340,9 @@ class PerTableLoadState {
     return ts_desc->placement_uuid() == options_->live_placement_uuid;
   }
 
-  // Update the per-tablet information for this tablet.
+  // Method called when initially analyzing tablets, to build up load and usage information.
+  // Returns an OK status if the method succeeded or an error if there are transient errors in
+  // updating the internal state.
   Status UpdateTablet(TabletInfo* tablet);
 
   virtual void UpdateTabletServer(std::shared_ptr<TSDescriptor> ts_desc);
@@ -350,21 +352,18 @@ class PerTableLoadState {
     initialized_ = true;
   }
 
-  Result<bool> CanAddTabletToTabletServer(
-    const TabletId& tablet_id, const TabletServerId& to_ts, const PlacementInfoPB* placement_info);
+  Result<bool> CanAddTabletToTabletServer(const TabletId& tablet_id, const TabletServerId& to_ts);
 
   // For a TS specified by ts_uuid, this function checks if there is a placement
   // block in placement_info where this TS can be placed. If there doesn't exist
-  // any, it returns boost::none. On the other hand if there is a placement block
+  // any, it returns std::nullopt. On the other hand if there is a placement block
   // that satisfies the criteria then it returns the cloud info of that block.
   // If there wasn't any placement information passed in placement_info then
   // it returns the cloud info of the TS itself.
-  boost::optional<CloudInfoPB> GetValidPlacement(const TabletServerId& ts_uuid,
-                                                 const PlacementInfoPB* placement_info);
+  std::optional<CloudInfoPB> GetValidPlacement(const TabletServerId& ts_uuid);
 
   Result<bool> CanSelectWrongPlacementReplicaToMove(
-    const TabletId& tablet_id, const PlacementInfoPB& placement_info, TabletServerId* out_from_ts,
-    TabletServerId* out_to_ts);
+    const TabletId& tablet_id, TabletServerId* out_from_ts, TabletServerId* out_to_ts);
 
   Status AddReplica(const TabletId& tablet_id, const TabletServerId& to_ts);
 
@@ -417,12 +416,9 @@ class PerTableLoadState {
     for (const auto& ts_meta : per_ts_meta_) {
       out << " " + ts_meta.first + ": " + ts_meta.second.ToString();
     }
-    out << " ], placement_by_table: [";
-    for (const auto& table_placement : placement_by_table_) {
-      out << " " + table_placement.first + ": " + table_placement.second.ShortDebugString();
-    }
     out << " ], ";
 
+    out << Format("placement: $0, ", placement_.ShortDebugString());
     out << Format("total_running: $0, ", total_running_);
     out << Format("total_starting: $0, ", total_starting_);
     out << Format("sorted_load: $0, ", sorted_load_);
@@ -457,10 +453,10 @@ class PerTableLoadState {
   // Map from tablet server ids to the metadata we store for each.
   std::unordered_map<TabletServerId, CBTabletServerMetadata> per_ts_meta_;
 
-  // Map from table id to placement information for this table. This will be used for both
+  // Placement information for this table. This will be used for both
   // determining over-replication, by checking num_replicas, but also for az awareness, by keeping
   // track of the placement block policies between cluster and table level.
-  std::unordered_map<TableId, PlacementInfoPB> placement_by_table_;
+  PlacementInfoPB placement_;
 
   // Total number of running tablets in the clusters (including replicas).
   int total_running_ = 0;
