diff --git a/src/yb/master/CMakeLists.txt b/src/yb/master/CMakeLists.txt
index d44c794cd7..8d86e6f3aa 100644
--- a/src/yb/master/CMakeLists.txt
+++ b/src/yb/master/CMakeLists.txt
@@ -176,6 +176,7 @@ set(MASTER_SRCS
   yql_vtable_iterator.cc
   ysql/ysql_catalog_config.cc
   ysql/ysql_initdb_major_upgrade_handler.cc
+  ysql/ysql_manager.cc
   ysql_backends_manager.cc
   ysql_ddl_handler.cc
   ysql_ddl_verification_task.cc
diff --git a/src/yb/master/catalog_loaders.cc b/src/yb/master/catalog_loaders.cc
index ceb2e15206..7be6e6df8d 100644
--- a/src/yb/master/catalog_loaders.cc
+++ b/src/yb/master/catalog_loaders.cc
@@ -38,6 +38,7 @@
 #include "yb/master/async_rpc_tasks.h"
 #include "yb/master/backfill_index.h"
 #include "yb/master/master_util.h"
+#include "yb/master/ysql/ysql_manager.h"
 #include "yb/master/ysql_ddl_verification_task.h"
 #include "yb/master/ysql_tablegroup_manager.h"
 
@@ -661,7 +662,7 @@ Status SysConfigLoader::Visit(const std::string& config_type, const SysConfigEnt
     if (config_type == kSecurityConfigType) {
       catalog_manager_->permissions_manager()->SetSecurityConfigOnLoadUnlocked(config);
     } else if (config_type == kYsqlCatalogConfigType) {
-      catalog_manager_->ysql_catalog_config_.SetConfig(config);
+      catalog_manager_->GetYsqlManagerImpl().LoadConfig(config);
     } else if (config_type == kTransactionTablesConfigType) {
       LOG_IF(WARNING, catalog_manager_->transaction_tables_config_ != nullptr)
           << "Multiple sys config type " << config_type << " found";
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index d28afe3bd1..2fb64afe88 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -58,7 +58,6 @@
 
 #include <algorithm>
 #include <atomic>
-#include <bitset>
 #include <chrono>
 #include <functional>
 #include <memory>
@@ -105,11 +104,9 @@
 #include "yb/dockv/partial_row.h"
 #include "yb/dockv/partition.h"
 
-#include "yb/gutil/atomicops.h"
 #include "yb/gutil/bind.h"
 #include "yb/gutil/casts.h"
 #include "yb/gutil/map-util.h"
-#include "yb/gutil/mathlimits.h"
 #include "yb/gutil/stl_util.h"
 #include "yb/gutil/strings/escaping.h"
 #include "yb/gutil/strings/join.h"
@@ -146,7 +143,6 @@
 #include "yb/master/object_lock_info_manager.h"
 #include "yb/master/permissions_manager.h"
 #include "yb/master/post_tablet_create_task_base.h"
-#include "yb/master/scoped_leader_shared_lock-internal.h"
 #include "yb/master/sys_catalog.h"
 #include "yb/master/sys_catalog_constants.h"
 #include "yb/master/tablet_split_manager.h"
@@ -157,7 +153,6 @@
 #include "yb/master/yql_auth_role_permissions_vtable.h"
 #include "yb/master/yql_auth_roles_vtable.h"
 #include "yb/master/yql_columns_vtable.h"
-#include "yb/master/yql_empty_vtable.h"
 #include "yb/master/yql_functions_vtable.h"
 #include "yb/master/yql_indexes_vtable.h"
 #include "yb/master/yql_keyspaces_vtable.h"
@@ -169,6 +164,7 @@
 #include "yb/master/yql_triggers_vtable.h"
 #include "yb/master/yql_types_vtable.h"
 #include "yb/master/yql_views_vtable.h"
+#include "yb/master/ysql/ysql_manager.h"
 #include "yb/master/ysql_ddl_verification_task.h"
 #include "yb/master/ysql_tablegroup_manager.h"
 #include "yb/master/ysql/ysql_initdb_major_upgrade_handler.h"
@@ -178,7 +174,6 @@
 
 #include "yb/tablet/operations/change_metadata_operation.h"
 #include "yb/tablet/tablet.h"
-#include "yb/tablet/tablet_metadata.h"
 #include "yb/tablet/tablet_peer.h"
 #include "yb/tablet/tablet_retention_policy.h"
 
@@ -191,14 +186,10 @@
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/countdown_latch.h"
 #include "yb/util/debug-util.h"
-#include "yb/util/debug/trace_event.h"
 #include "yb/util/flags.h"
 #include "yb/util/format.h"
-#include "yb/util/hash_util.h"
 #include "yb/util/is_operation_done_result.h"
-#include "yb/util/locks.h"
 #include "yb/util/logging.h"
-#include "yb/util/math_util.h"
 #include "yb/util/metrics.h"
 #include "yb/util/monotime.h"
 #include "yb/util/net/net_util.h"
@@ -206,8 +197,6 @@
 #include "yb/util/random_util.h"
 #include "yb/util/rw_mutex.h"
 #include "yb/util/scope_exit.h"
-#include "yb/util/semaphore.h"
-#include "yb/util/shared_lock.h"
 #include "yb/util/size_literals.h"
 #include "yb/util/status_format.h"
 #include "yb/util/status_log.h"
@@ -216,7 +205,6 @@
 #include "yb/util/string_case.h"
 #include "yb/util/string_util.h"
 #include "yb/util/sync_point.h"
-#include "yb/util/thread.h"
 #include "yb/util/threadpool.h"
 #include "yb/util/to_stream.h"
 #include "yb/util/trace.h"
@@ -407,11 +395,6 @@ DEFINE_RUNTIME_int32(txn_table_wait_min_ts_count, 1,
     " is smaller than that");
 TAG_FLAG(txn_table_wait_min_ts_count, advanced);
 
-// TODO (mbautin, 2019-12): switch the default to true after updating all external callers
-// (yb-ctl, YugaWare) and unit tests.
-DEFINE_RUNTIME_bool(master_auto_run_initdb, false,
-    "Automatically run initdb on master leader initialization");
-
 DEFINE_RUNTIME_bool(enable_ysql_tablespaces_for_placement, true,
     "If set, tablespaces will be used for placement of YSQL tables.");
 
@@ -939,7 +922,6 @@ std::vector<scoped_refptr<NamespaceInfo>> CatalogManager::NamespaceNameMapper::G
 CatalogManager::CatalogManager(Master* master, SysCatalogTable* sys_catalog)
     : master_(DCHECK_NOTNULL(master)),
       sys_catalog_(DCHECK_NOTNULL(sys_catalog)),
-      ysql_catalog_config_(*sys_catalog),
       tablet_exists_(false),
       state_(kConstructed),
       leader_ready_term_(-1),
@@ -961,8 +943,7 @@ CatalogManager::CatalogManager(Master* master, SysCatalogTable* sys_catalog)
   CHECK_OK(ThreadPoolBuilder("async-tasks").Build(&async_task_pool_));
   CHECK_OK(sys_catalog_->Start(Bind(&CatalogManager::ElectedAsLeaderCb, Unretained(this))));
   xcluster_manager_ = std::make_unique<XClusterManager>(*master_, *this, *sys_catalog_);
-  ysql_initdb_and_major_upgrade_helper_ = std::make_unique<YsqlInitDBAndMajorUpgradeHandler>(
-      *master_, *this, *sys_catalog_, *background_tasks_thread_pool_);
+  ysql_manager_ = std::make_unique<YsqlManager>(*master_, *this, *sys_catalog_);
 }
 
 CatalogManager::~CatalogManager() {
@@ -1034,6 +1015,8 @@ XClusterManagerIf* CatalogManager::GetXClusterManager() {
   return xcluster_manager_.get();
 }
 
+YsqlManagerIf& CatalogManager::GetYsqlManager() { return GetYsqlManagerImpl(); }
+
 Status CatalogManager::ElectedAsLeaderCb() {
   if (FLAGS_emergency_repair_mode) {
     // In this mode the sys_catalog leader will not start CatalogManager. The only operations that
@@ -1230,7 +1213,7 @@ Status CatalogManager::MaybeRestoreInitialSysCatalogSnapshotAndReloadSysCatalog(
     return Status::OK();
   }
 
-  if (ysql_initdb_and_major_upgrade_helper_->IsInitDbDone()) {
+  if (ysql_manager_->IsInitDbDone()) {
     LOG_WITH_PREFIX(INFO) << "initdb has been run before, no need to restore sys catalog from "
                           << "the initial snapshot";
     return Status::OK();
@@ -1257,7 +1240,7 @@ Status CatalogManager::MaybeRestoreInitialSysCatalogSnapshotAndReloadSysCatalog(
       state->epoch.leader_term, /* recreate = */ true));
 
   LOG_WITH_PREFIX(INFO) << "Restoring snapshot completed, considering initdb finished";
-  RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->SetInitDbDone(state->epoch));
+  RETURN_NOT_OK(ysql_manager_->SetInitDbDone(state->epoch));
   // TODO(asrivastava): Can we get rid of this Reset() by calling RunLoaders just once
   // instead of calling it here and in VisitSysCatalog?
   state->Reset();
@@ -1363,6 +1346,8 @@ Status CatalogManager::VisitSysCatalog(SysCatalogLoadingState* state) {
     // Prepare various default system configurations.
     RETURN_NOT_OK(PrepareDefaultSysConfig(term));
 
+    RETURN_NOT_OK(ysql_manager_->PrepareDefaultSysConfig(state->epoch));
+
     RETURN_NOT_OK(MaybeRestoreInitialSysCatalogSnapshotAndReloadSysCatalog(state));
 
     // Create the system namespaces (created only if they don't already exist).
@@ -1382,11 +1367,11 @@ Status CatalogManager::VisitSysCatalog(SysCatalogLoadingState* state) {
 
     permissions_manager_->BuildRecursiveRoles();
 
-    if (!VERIFY_RESULT(StartRunningInitDbIfNeeded(state->epoch))) {
+    if (!VERIFY_RESULT(ysql_manager_->StartRunningInitDbIfNeeded(state->epoch))) {
       // If we are not running initdb, this is an existing cluster, and we need to check whether we
       // need to do a one-time migration to make YSQL system catalog tables transactional.
       RETURN_NOT_OK(MakeYsqlSysCatalogTablesTransactional(
-          tables_->GetAllTables(), sys_catalog_, ysql_catalog_config_, state->epoch));
+          tables_->GetAllTables(), sys_catalog_, *ysql_manager_.get(), state->epoch));
     }
   }  // Exclusive mutex_ scope.
   return Status::OK();
@@ -1430,9 +1415,6 @@ Status CatalogManager::RunLoaders(SysCatalogLoadingState* state) {
   // Clear Object lock mapping.
   object_lock_info_manager_->Clear();
 
-  // Clear ysql catalog config.
-  ysql_catalog_config_.Reset();
-
   // Clear transaction tables config.
   transaction_tables_config_.reset();
 
@@ -1450,6 +1432,7 @@ Status CatalogManager::RunLoaders(SysCatalogLoadingState* state) {
     ysql_ddl_txn_verfication_state_map_.clear();
   }
 
+  ysql_manager_->Clear();
   xcluster_manager_->Clear();
 
   // This is unnecessary if persist_tserver_registry is set.
@@ -1671,8 +1654,6 @@ Status CatalogManager::PrepareDefaultSysConfig(int64_t term) {
     RETURN_NOT_OK(permissions_manager()->PrepareDefaultSecurityConfigUnlocked(term));
   }
 
-  RETURN_NOT_OK(ysql_catalog_config_.PrepareDefaultIfNeeded(term));
-
   if (!transaction_tables_config_) {
     RETURN_NOT_OK(InitializeTransactionTablesConfig(term));
   }
@@ -1680,35 +1661,6 @@ Status CatalogManager::PrepareDefaultSysConfig(int64_t term) {
   return Status::OK();
 }
 
-Result<bool> CatalogManager::StartRunningInitDbIfNeeded(const LeaderEpoch& epoch) {
-  if (ysql_initdb_and_major_upgrade_helper_->IsInitDbDone()) {
-    LOG(INFO) << "Cluster configuration indicates that initdb has already completed";
-    return false;
-  }
-
-  if (pg_proc_exists_.load(std::memory_order_acquire)) {
-    LOG(INFO) << "Table pg_proc exists, assuming initdb has already been run";
-    // Mark initdb as done, in case it was done externally.
-    // We assume pg_proc table means initdb is done.
-    // We do NOT handle the case when initdb was terminated mid-run (neither here nor in
-    // MakeYsqlSysCatalogTablesTransactional).
-    RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->SetInitDbDone( epoch));
-    return false;
-  }
-
-  if (!FLAGS_master_auto_run_initdb) {
-    LOG(INFO) << "--master_auto_run_initdb is set to false, not running initdb";
-    return false;
-  }
-
-  LOG(INFO) << "initdb has never been run on this cluster, running it";
-
-  RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->StartNewClusterGlobalInitDB(epoch));
-
-  LOG(INFO) << "Successfully started initdb";
-  return true;
-}
-
 Status CatalogManager::PrepareDefaultNamespaces(int64_t term) {
   RETURN_NOT_OK(PrepareNamespace(
       YQL_DATABASE_CQL, kSystemNamespaceName, kSystemNamespaceId, term));
@@ -3217,52 +3169,6 @@ Status CatalogManager::DdlLog(
   return sys_catalog_->FetchDdlLog(resp->mutable_entries());
 }
 
-Status CatalogManager::StartYsqlMajorCatalogUpgrade(
-    const StartYsqlMajorCatalogUpgradeRequestPB* req, StartYsqlMajorCatalogUpgradeResponsePB* resp,
-    rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
-  LOG(INFO) << "Running ysql major upgrade";
-  RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->StartYsqlMajorCatalogUpgrade(epoch));
-
-  return Status::OK();
-}
-
-Status CatalogManager::IsYsqlMajorCatalogUpgradeDone(
-    const IsYsqlMajorCatalogUpgradeDoneRequestPB* req,
-    IsYsqlMajorCatalogUpgradeDoneResponsePB* resp, rpc::RpcContext* rpc) {
-  LOG(INFO) << "Checking if ysql major catalog upgrade is done";
-  auto is_operation_done = ysql_initdb_and_major_upgrade_helper_->IsYsqlMajorCatalogUpgradeDone();
-  if (is_operation_done.done()) {
-    resp->set_done(true);
-    if (!is_operation_done.status().ok()) {
-      return is_operation_done.status();
-    }
-  } else {
-    resp->set_done(false);
-  }
-  return Status::OK();
-}
-
-Status CatalogManager::FinalizeYsqlMajorCatalogUpgrade(
-    const FinalizeYsqlMajorCatalogUpgradeRequestPB* req,
-    FinalizeYsqlMajorCatalogUpgradeResponsePB* resp, rpc::RpcContext* rpc,
-    const LeaderEpoch& epoch) {
-  LOG(INFO) << "Finalizing ysql major catalog upgrade";
-  return ysql_initdb_and_major_upgrade_helper_->FinalizeYsqlMajorCatalogUpgrade(epoch);
-}
-
-// Note that this function should be able to be called any number of times while in upgrade mode.
-Status CatalogManager::RollbackYsqlMajorCatalogVersion(
-    const RollbackYsqlMajorCatalogVersionRequestPB* req,
-    RollbackYsqlMajorCatalogVersionResponsePB* resp, rpc::RpcContext* rpc,
-    const LeaderEpoch& epoch) {
-  LOG(INFO) << "YSQL major catalog upgrade rollback initiated";
-
-  RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->RollbackYsqlMajorCatalogVersion(epoch));
-
-  LOG(INFO) << "YSQL major catalog upgrade rollback completed";
-  return Status::OK();
-}
-
 namespace {
 
 Status ValidateCreateTableSchema(const Schema& schema, CreateTableResponsePB* resp) {
@@ -3551,7 +3457,7 @@ Status CatalogManager::GetYsqlCatalogConfig(const GetYsqlCatalogConfigRequestPB*
     return Status::OK();
   }
 
-  resp->set_version(ysql_catalog_config_.GetVersion());
+  resp->set_version(ysql_manager_->GetYsqlCatalogVersion());
   return Status::OK();
 }
 
@@ -9933,13 +9839,12 @@ Status CatalogManager::ListUDTypes(const ListUDTypesRequestPB* req,
 }
 
 Result<uint64_t> CatalogManager::IncrementYsqlCatalogVersion() {
-  return ysql_catalog_config_.IncrementVersion(GetLeaderEpochInternal());
+  return ysql_manager_->IncrementYsqlCatalogVersion(GetLeaderEpochInternal());
 }
 
 Status CatalogManager::IsInitDbDone(
     const IsInitDbDoneRequestPB* req, IsInitDbDoneResponsePB* resp) {
-  resp->set_pg_proc_exists(pg_proc_exists_.load(std::memory_order_acquire));
-  auto is_operation_done = ysql_initdb_and_major_upgrade_helper_->IsInitDbDone();
+  auto is_operation_done = ysql_manager_->IsInitDbDone();
 
   if (is_operation_done.done()) {
     resp->set_done(true);
@@ -9994,7 +9899,7 @@ Status CatalogManager::GetYsqlDBCatalogVersion(uint32_t db_oid,
     // In this case we'd like to fall back to the legacy approach.
   }
 
-  const auto version = ysql_catalog_config_.GetVersion();
+  const auto version = ysql_manager_->GetYsqlCatalogVersion();
   // last_breaking_version is the last version (change) that invalidated ongoing transactions.
   // If using the old (protobuf-based) version method, we do not have any information about
   // breaking changes so assuming every change is a breaking change.
@@ -12289,10 +12194,7 @@ void CatalogManager::AbortAndWaitForAllTasksUnlocked() {
 }
 
 void CatalogManager::HandleNewTableId(const TableId& table_id) {
-  if (table_id == kPgProcTableId) {
-    // Needed to track whether initdb has started running.
-    pg_proc_exists_.store(true, std::memory_order_release);
-  }
+  ysql_manager_->HandleNewTableId(table_id);
 }
 
 scoped_refptr<TableInfo> CatalogManager::NewTableInfo(TableId id, bool colocated) {
@@ -12884,7 +12786,7 @@ void CatalogManager::SysCatalogLoaded(SysCatalogLoadingState&& state) {
         "Failed to read all DB catalog versions");
   }
 
-  ysql_initdb_and_major_upgrade_helper_->SysCatalogLoaded(state.epoch);
+  ysql_manager_->SysCatalogLoaded(state.epoch);
 
   master_->snapshot_coordinator().SysCatalogLoaded(state.epoch.leader_term);
 
@@ -13452,7 +13354,7 @@ Result<TSDescriptorPtr> CatalogManager::GetClosestLiveTserver(bool* local_ts) co
 }
 
 bool CatalogManager::IsYsqlMajorCatalogUpgradeInProgress() const {
-  return ysql_initdb_and_major_upgrade_helper_->IsYsqlMajorCatalogUpgradeInProgress();
+  return ysql_manager_->IsYsqlMajorCatalogUpgradeInProgress();
 }
 
 bool CatalogManager::SkipCatalogVersionChecks() {
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index 5065ada17b..9f220545db 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -52,7 +52,6 @@
 #include "yb/master/catalog_entity_info.pb.h"
 #include "yb/master/leader_epoch.h"
 #include "yb/master/restore_sys_catalog_state.h"
-#include "yb/master/ysql/ysql_catalog_config.h"
 #include "yb/qlexpr/index.h"
 #include "yb/dockv/partition.h"
 #include "yb/common/transaction.h"
@@ -149,6 +148,8 @@ struct DeferredAssignmentActions;
 struct SysCatalogLoadingState;
 struct KeyRange;
 class YsqlInitDBAndMajorUpgradeHandler;
+class YsqlManagerIf;
+class YsqlManager;
 
 using PlacementId = std::string;
 
@@ -788,6 +789,9 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
   XClusterManagerIf* GetXClusterManager() override;
   XClusterManager* GetXClusterManagerImpl() override { return xcluster_manager_.get(); }
 
+  YsqlManagerIf& GetYsqlManager();
+  YsqlManager& GetYsqlManagerImpl() { return *ysql_manager_.get(); }
+
   // Dump all of the current state about tables and tablets to the
   // given output stream. This is verbose, meant for debugging.
   Status DumpState(std::ostream* out, bool on_disk_dump = false) const override;
@@ -1136,33 +1140,6 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
   Status DdlLog(
       const DdlLogRequestPB* req, DdlLogResponsePB* resp, rpc::RpcContext* rpc);
 
-  // Initiates ysql major catalog upgrade which involves global initdb, pg_upgrade, and catalog
-  // version fixups.
-  // IsYsqlMajorCatalogUpgradeDone must be called to track the completion status of the
-  // operation.
-  Status StartYsqlMajorCatalogUpgrade(
-      const StartYsqlMajorCatalogUpgradeRequestPB* req,
-      StartYsqlMajorCatalogUpgradeResponsePB* resp, rpc::RpcContext* rpc, const LeaderEpoch& epoch);
-
-  // Checks if ysql major catalog upgrade has completed.
-  Status IsYsqlMajorCatalogUpgradeDone(
-      const IsYsqlMajorCatalogUpgradeDoneRequestPB* req,
-      IsYsqlMajorCatalogUpgradeDoneResponsePB* resp, rpc::RpcContext* rpc);
-
-  Status FinalizeYsqlMajorCatalogUpgrade(
-      const FinalizeYsqlMajorCatalogUpgradeRequestPB* req,
-      FinalizeYsqlMajorCatalogUpgradeResponsePB* resp, rpc::RpcContext* rpc,
-      const LeaderEpoch& epoch);
-
-  // Rolls back the major YSQL catalog to the previous version. Deletes all of the new YSQL
-  // version's catalog tables, and resets all upgrade-related state to initial values. Blocks until
-  // the rollback is finished or fails.
-  // Takes a long time to run. Use a timeout of at least 5 minutes when calling.
-  Status RollbackYsqlMajorCatalogVersion(
-      const RollbackYsqlMajorCatalogVersionRequestPB* req,
-      RollbackYsqlMajorCatalogVersionResponsePB* resp, rpc::RpcContext* rpc,
-      const LeaderEpoch& epoch);
-
   // Test wrapper around protected DoSplitTablet method.
   Status TEST_SplitTablet(
       const TabletInfoPtr& source_tablet_info,
@@ -1678,9 +1655,6 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
   Status CreateTransactionAwareSnapshot(
       const CreateSnapshotRequestPB& req, CreateSnapshotResponsePB* resp, CoarseTimePoint deadline);
 
-  YsqlCatalogConfig& GetYsqlCatalogConfig() { return ysql_catalog_config_; }
-  const YsqlCatalogConfig& GetYsqlCatalogConfig() const { return ysql_catalog_config_; }
-
   InitialSysCatalogSnapshotWriter& AllocateAndGetInitialSysCatalogSnapshotWriter();
 
   Result<std::vector<SysCatalogEntryDumpPB>> FetchFromSysCatalog(
@@ -1757,10 +1731,6 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
   // Sets up various system configs.
   Status PrepareDefaultSysConfig(int64_t term) REQUIRES(mutex_);
 
-  // Starts an asynchronous run of initdb. Errors are handled in the callback. Returns true
-  // if started running initdb, false if decided that it is not needed.
-  Result<bool> StartRunningInitDbIfNeeded(const LeaderEpoch& epoch) REQUIRES_SHARED(mutex_);
-
   Status PrepareDefaultNamespaces(int64_t term) REQUIRES(mutex_);
 
   Status PrepareSystemTables(const LeaderEpoch& epoch) REQUIRES(mutex_);
@@ -2316,9 +2286,6 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
 
   SysCatalogTable* sys_catalog_;
 
-  // YSQL Catalog information.
-  YsqlCatalogConfig ysql_catalog_config_;
-
   // Mutex to avoid concurrent remote bootstrap sessions.
   std::mutex remote_bootstrap_mtx_;
 
@@ -2429,9 +2396,6 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
 
   std::unique_ptr<PermissionsManager> permissions_manager_;
 
-  // This is used for tracking that initdb has started running previously.
-  std::atomic<bool> pg_proc_exists_{false};
-
   // Tracks most recent async tasks.
   scoped_refptr<TasksTracker> tasks_tracker_;
 
@@ -2457,6 +2421,8 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
 
   std::unique_ptr<XClusterManager> xcluster_manager_;
 
+  std::unique_ptr<YsqlManager> ysql_manager_;
+
   Status CanAddPartitionsToTable(
       size_t desired_partitions, const PlacementInfoPB& placement_info) override;
 
@@ -3124,8 +3090,6 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
 
   std::atomic<bool> pg_cron_service_created_{false};
 
-  std::unique_ptr<YsqlInitDBAndMajorUpgradeHandler> ysql_initdb_and_major_upgrade_helper_;
-
   DISALLOW_COPY_AND_ASSIGN(CatalogManager);
 };
 
diff --git a/src/yb/master/master.cc b/src/yb/master/master.cc
index 91bb690952..0049d81cce 100644
--- a/src/yb/master/master.cc
+++ b/src/yb/master/master.cc
@@ -613,6 +613,10 @@ XClusterManager* Master::xcluster_manager_impl() const {
   return catalog_manager_->GetXClusterManagerImpl();
 }
 
+YsqlManagerIf& Master::ysql_manager() const { return catalog_manager_->GetYsqlManager(); }
+
+YsqlManager& Master::ysql_manager_impl() const { return catalog_manager_->GetYsqlManagerImpl(); }
+
 SysCatalogTable& Master::sys_catalog() const {
   return *catalog_manager_->sys_catalog();
 }
diff --git a/src/yb/master/master.h b/src/yb/master/master.h
index 9e901f3fe7..908a017106 100644
--- a/src/yb/master/master.h
+++ b/src/yb/master/master.h
@@ -117,6 +117,10 @@ class Master : public tserver::DbServerBase {
 
   XClusterManager* xcluster_manager_impl() const;
 
+  YsqlManagerIf& ysql_manager() const;
+
+  YsqlManager& ysql_manager_impl() const;
+
   FlushManager* flush_manager() const { return flush_manager_.get(); }
 
   TestAsyncRpcManager* test_async_rpc_manager() const { return test_async_rpc_manager_.get(); }
diff --git a/src/yb/master/master_admin_service.cc b/src/yb/master/master_admin_service.cc
index c5674cc554..4f268c8742 100644
--- a/src/yb/master/master_admin_service.cc
+++ b/src/yb/master/master_admin_service.cc
@@ -19,6 +19,7 @@
 #include "yb/master/master_service_base-internal.h"
 #include "yb/master/tablet_split_manager.h"
 #include "yb/master/test_async_rpc_manager.h"
+#include "yb/master/ysql/ysql_manager.h"
 #include "yb/master/ysql_backends_manager.h"
 
 #include "yb/util/flags.h"
@@ -78,10 +79,6 @@ class MasterAdminServiceImpl : public MasterServiceBase, public MasterAdminIf {
       (GetCompactionStatus)
       (CreateTransactionStatusTable)
       (DdlLog)
-      (StartYsqlMajorCatalogUpgrade)
-      (IsYsqlMajorCatalogUpgradeDone)
-      (FinalizeYsqlMajorCatalogUpgrade)
-      (RollbackYsqlMajorCatalogVersion)
       (DeleteNotServingTablet)
       (FlushSysCatalog)
       (SplitTablet)
@@ -114,6 +111,14 @@ class MasterAdminServiceImpl : public MasterServiceBase, public MasterAdminIf {
       YsqlBackendsManager,
       (WaitForYsqlBackendsCatalogVersion)
   )
+
+  MASTER_SERVICE_IMPL_ON_LEADER_WITH_LOCK(
+      YsqlManager,
+      (StartYsqlMajorCatalogUpgrade)
+      (IsYsqlMajorCatalogUpgradeDone)
+      (FinalizeYsqlMajorCatalogUpgrade)
+      (RollbackYsqlMajorCatalogVersion)
+  )
 };
 
 } // namespace
diff --git a/src/yb/master/master_fwd.h b/src/yb/master/master_fwd.h
index 0c56730927..3832bd1652 100644
--- a/src/yb/master/master_fwd.h
+++ b/src/yb/master/master_fwd.h
@@ -92,6 +92,8 @@ class XClusterManagerIf;
 class YQLPartitionsVTable;
 class YQLVirtualTable;
 class YsqlBackendsManager;
+class YsqlManager;
+class YsqlManagerIf;
 class YsqlTablegroupManager;
 class YsqlTablespaceManager;
 class YsqlTransactionDdl;
diff --git a/src/yb/master/master_service_base.cc b/src/yb/master/master_service_base.cc
index c608f44e78..03df49d028 100644
--- a/src/yb/master/master_service_base.cc
+++ b/src/yb/master/master_service_base.cc
@@ -69,6 +69,8 @@ MasterClusterHandler* MasterServiceBase::handler(MasterClusterHandler*) {
   return server_->master_cluster_handler();
 }
 
+YsqlManager* MasterServiceBase::handler(YsqlManager*) { return &server_->ysql_manager_impl(); }
+
 Status HandleLockAndCallFunction(
     const std::function<Status()>& f,
     HoldCatalogLock hold_catalog_lock,
diff --git a/src/yb/master/master_service_base.h b/src/yb/master/master_service_base.h
index 762e3fc2d8..07d1b1adac 100644
--- a/src/yb/master/master_service_base.h
+++ b/src/yb/master/master_service_base.h
@@ -39,6 +39,7 @@ struct LeaderEpoch;
 class XClusterManager;
 class MasterAutoFlagsManager;
 class MasterClusterHandler;
+class YsqlManager;
 
 // Tells HandleIn/HandleOnLeader to either acquire the lock briefly to check leadership (kFalse)
 // or to hold it throughout the handler invocation (kTrue).
@@ -119,6 +120,7 @@ class MasterServiceBase {
   TabletSplitManager* handler(TabletSplitManager*);
   FlushManager* handler(FlushManager*);
   TabletHealthManager* handler(TabletHealthManager*);
+  YsqlManager* handler(YsqlManager*);
   YsqlBackendsManager* handler(YsqlBackendsManager*);
   PermissionsManager* handler(PermissionsManager*);
   EncryptionManager* handler(EncryptionManager*);
diff --git a/src/yb/master/master_tablet_service.cc b/src/yb/master/master_tablet_service.cc
index 88393c38e5..6cfc742455 100644
--- a/src/yb/master/master_tablet_service.cc
+++ b/src/yb/master/master_tablet_service.cc
@@ -117,9 +117,9 @@ void MasterTabletServiceImpl::Write(const tserver::WriteRequestPB* req,
 
   bool log_versions = false;
   std::unordered_set<uint32_t> db_oids;
-  for (const auto& pg_req : req->pgsql_write_batch()) {
+  for (const auto &pg_req : req->pgsql_write_batch()) {
     if (pg_req.is_ysql_catalog_change_using_protobuf()) {
-      const auto &res = master_->catalog_manager()->IncrementYsqlCatalogVersion();
+      const auto& res = master_->catalog_manager()->IncrementYsqlCatalogVersion();
       if (!res.ok()) {
         context.RespondRpcFailure(rpc::ErrorStatusPB::ERROR_APPLICATION,
             STATUS(InternalError, "Failed to increment YSQL catalog version"));
diff --git a/src/yb/master/sys_catalog_initialization.cc b/src/yb/master/sys_catalog_initialization.cc
index dffcae92b6..2ed59450af 100644
--- a/src/yb/master/sys_catalog_initialization.cc
+++ b/src/yb/master/sys_catalog_initialization.cc
@@ -20,7 +20,7 @@
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/sys_catalog.h"
 
-#include "yb/master/ysql/ysql_catalog_config.h"
+#include "yb/master/ysql/ysql_manager_if.h"
 #include "yb/tablet/operations/change_metadata_operation.h"
 #include "yb/tablet/operations/snapshot_operation.h"
 #include "yb/tablet/tablet.h"
@@ -209,9 +209,9 @@ void SetDefaultInitialSysCatalogSnapshotFlags() {
 }
 
 Status MakeYsqlSysCatalogTablesTransactional(
-    TableIndex::TablesRange tables, SysCatalogTable* sys_catalog,
-    YsqlCatalogConfig& ysql_catalog_config, const LeaderEpoch& epoch) {
-  if (ysql_catalog_config.IsTransactionalSysCatalogEnabled()) {
+    TableIndex::TablesRange tables, SysCatalogTable* sys_catalog, YsqlManagerIf& ysql_manager,
+    const LeaderEpoch& epoch) {
+  if (ysql_manager.IsTransactionalSysCatalogEnabled()) {
     LOG(INFO) << "YSQL catalog tables are already transactional";
     return Status::OK();
   }
@@ -275,7 +275,7 @@ Status MakeYsqlSysCatalogTablesTransactional(
     LOG(INFO) << "Made " << num_updated_tables << " YSQL sys catalog tables transactional";
   }
 
-  RETURN_NOT_OK(ysql_catalog_config.SetTransactionalSysCatalogEnabled(epoch));
+  RETURN_NOT_OK(ysql_manager.SetTransactionalSysCatalogEnabled(epoch));
 
   return Status::OK();
 }
diff --git a/src/yb/master/sys_catalog_initialization.h b/src/yb/master/sys_catalog_initialization.h
index f8d7927f17..f71195220c 100644
--- a/src/yb/master/sys_catalog_initialization.h
+++ b/src/yb/master/sys_catalog_initialization.h
@@ -36,7 +36,7 @@ namespace yb {
 namespace master {
 
 struct LeaderEpoch;
-class YsqlCatalogConfig;
+class YsqlManagerIf;
 
 // Used by the catalog manager to prepare an initial sys catalog snapshot.
 class InitialSysCatalogSnapshotWriter {
@@ -67,7 +67,7 @@ void SetDefaultInitialSysCatalogSnapshotFlags();
 // is_transactional flags to true on YSQL system catalog tables.
 Status MakeYsqlSysCatalogTablesTransactional(
     TableIndex::TablesRange tables, SysCatalogTable* sys_catalog,
-    YsqlCatalogConfig& ysql_catalog_config, const LeaderEpoch& epoch);
+    YsqlManagerIf& ysql_manager, const LeaderEpoch& epoch);
 
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/ysql/ysql_catalog_config.cc b/src/yb/master/ysql/ysql_catalog_config.cc
index 6432cd24b4..a4b9624459 100644
--- a/src/yb/master/ysql/ysql_catalog_config.cc
+++ b/src/yb/master/ysql/ysql_catalog_config.cc
@@ -43,7 +43,7 @@ uint32 GetMajorVersionOfCurrentBuild() {
 
 YsqlCatalogConfig::YsqlCatalogConfig(SysCatalogTable& sys_catalog) : sys_catalog_(sys_catalog) {}
 
-Status YsqlCatalogConfig::PrepareDefaultIfNeeded(int64_t term) {
+Status YsqlCatalogConfig::PrepareDefaultIfNeeded(const LeaderEpoch& epoch) {
   std::lock_guard m_lock(mutex_);
   if (config_) {
     return Status::OK();
@@ -58,7 +58,7 @@ Status YsqlCatalogConfig::PrepareDefaultIfNeeded(int64_t term) {
   auto l = config_->LockForWrite();
   *l.mutable_data()->pb.mutable_ysql_catalog_config() = std::move(ysql_catalog_config);
 
-  RETURN_NOT_OK(sys_catalog_.Upsert(term, config_));
+  RETURN_NOT_OK(sys_catalog_.Upsert(epoch, config_));
   l.Commit();
 
   return Status::OK();
diff --git a/src/yb/master/ysql/ysql_catalog_config.h b/src/yb/master/ysql/ysql_catalog_config.h
index 7a924c8a26..0be29b3ac1 100644
--- a/src/yb/master/ysql/ysql_catalog_config.h
+++ b/src/yb/master/ysql/ysql_catalog_config.h
@@ -33,7 +33,7 @@ class YsqlCatalogConfig {
   explicit YsqlCatalogConfig(SysCatalogTable& sys_catalog);
   ~YsqlCatalogConfig() = default;
 
-  Status PrepareDefaultIfNeeded(int64_t term) EXCLUDES(mutex_);
+  Status PrepareDefaultIfNeeded(const LeaderEpoch& epoch) EXCLUDES(mutex_);
   void SetConfig(scoped_refptr<SysConfigInfo> config) EXCLUDES(mutex_);
   void Reset() EXCLUDES(mutex_);
 
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
index 6545b8ce63..a8a563ca1b 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
@@ -16,6 +16,7 @@
 #include "yb/master/catalog_manager.h"
 #include "yb/master/leader_epoch.h"
 #include "yb/master/master.h"
+#include "yb/master/ysql/ysql_catalog_config.h"
 
 #include "yb/tablet/tablet_peer.h"
 
@@ -40,36 +41,21 @@ using yb::pgwrapper::PgWrapper;
 namespace yb::master {
 
 YsqlInitDBAndMajorUpgradeHandler::YsqlInitDBAndMajorUpgradeHandler(
-    Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog,
-    yb::ThreadPool& thread_pool)
+    Master& master, YsqlCatalogConfig& ysql_catalog_config, CatalogManager& catalog_manager,
+    SysCatalogTable& sys_catalog, yb::ThreadPool& thread_pool)
     : master_(master),
+      ysql_catalog_config_(ysql_catalog_config),
       catalog_manager_(catalog_manager),
       sys_catalog_(sys_catalog),
       thread_pool_(thread_pool) {}
 
-YsqlCatalogConfig& YsqlInitDBAndMajorUpgradeHandler::GetYsqlCatalogConfig() {
-  return catalog_manager_.GetYsqlCatalogConfig();
-}
-
-const YsqlCatalogConfig& YsqlInitDBAndMajorUpgradeHandler::GetYsqlCatalogConfig() const {
-  return catalog_manager_.GetYsqlCatalogConfig();
-}
-
-IsOperationDoneResult YsqlInitDBAndMajorUpgradeHandler::IsInitDbDone() const {
-  return GetYsqlCatalogConfig().IsInitDbDone();
-}
-
-Status YsqlInitDBAndMajorUpgradeHandler::SetInitDbDone(const LeaderEpoch& epoch) {
-  return GetYsqlCatalogConfig().SetInitDbDone(Status::OK(), epoch);
-}
-
 void YsqlInitDBAndMajorUpgradeHandler::SysCatalogLoaded(const LeaderEpoch& epoch) {
   // A new yb-master leader has started. If we were in the middle of the ysql major catalog upgrade
   // (initdb, pg_upgrade, or rollback) then mark the major upgrade as failed. No action is taken if
   // we are in the monitoring phase.
   if (IsYsqlMajorCatalogUpgradeInProgress()) {
     ERROR_NOT_OK(
-        GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+        ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
             YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch,
             STATUS(InternalError, "yb-master restarted during ysql major catalog upgrade")),
         "Failed to set major version upgrade state to FAILED");
@@ -86,13 +72,13 @@ Status YsqlInitDBAndMajorUpgradeHandler::StartNewClusterGlobalInitDB(const Leade
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::StartYsqlMajorCatalogUpgrade(const LeaderEpoch& epoch) {
-  RETURN_NOT_OK(GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+  RETURN_NOT_OK(ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
       YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB, epoch));
 
   auto status = RunOperationAsync([this, epoch]() { RunMajorVersionUpgrade(epoch); });
   if (!status.ok()) {
     ERROR_NOT_OK(
-        GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+        ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
             YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch, status),
         "Failed to set major version upgrade state");
   }
@@ -101,11 +87,11 @@ Status YsqlInitDBAndMajorUpgradeHandler::StartYsqlMajorCatalogUpgrade(const Lead
 }
 
 IsOperationDoneResult YsqlInitDBAndMajorUpgradeHandler::IsYsqlMajorCatalogUpgradeDone() const {
-  return GetYsqlCatalogConfig().IsYsqlMajorCatalogUpgradeDone();
+  return ysql_catalog_config_.IsYsqlMajorCatalogUpgradeDone();
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::FinalizeYsqlMajorCatalogUpgrade(const LeaderEpoch& epoch) {
-  return GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+  return ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
       YsqlMajorCatalogUpgradeInfoPB::DONE, epoch);
 }
 
@@ -153,7 +139,7 @@ void YsqlInitDBAndMajorUpgradeHandler::RunNewClusterGlobalInitDB(const LeaderEpo
   auto status =
       InitDBAndSnapshotSysCatalog(/*db_name_to_oid_list=*/{}, /*is_major_upgrade=*/false, epoch);
   ERROR_NOT_OK(
-      GetYsqlCatalogConfig().SetInitDbDone(status, epoch),
+      ysql_catalog_config_.SetInitDbDone(status, epoch),
       "Failed to set global initdb as finished in sys catalog");
 }
 
@@ -186,7 +172,7 @@ Status YsqlInitDBAndMajorUpgradeHandler::InitDBAndSnapshotSysCatalog(
 void YsqlInitDBAndMajorUpgradeHandler::RunMajorVersionUpgrade(const LeaderEpoch& epoch) {
   auto status = RunMajorVersionUpgradeImpl(epoch);
   if (status.ok()) {
-    auto update_state_status = GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+    auto update_state_status = ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
         YsqlMajorCatalogUpgradeInfoPB::MONITORING, epoch);
     if (update_state_status.ok()) {
       LOG(INFO) << "Ysql major catalog upgrade completed successfully";
@@ -198,7 +184,7 @@ void YsqlInitDBAndMajorUpgradeHandler::RunMajorVersionUpgrade(const LeaderEpoch&
 
   LOG(ERROR) << "Ysql major catalog upgrade failed: " << status;
   ERROR_NOT_OK(
-      GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+      ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
           YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch, status),
       "Failed to set major version upgrade state");
 }
@@ -226,7 +212,7 @@ Status YsqlInitDBAndMajorUpgradeHandler::RunMajorVersionCatalogUpgrade(const Lea
       InitDBAndSnapshotSysCatalog(db_name_to_oid_list, /*is_major_upgrade=*/true, epoch),
       "Failed to run initdb");
 
-  RETURN_NOT_OK(GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+  RETURN_NOT_OK(ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
       YsqlMajorCatalogUpgradeInfoPB::PERFORMING_PG_UPGRADE, epoch));
 
   RETURN_NOT_OK_PREPEND(PerformPgUpgrade(epoch), "Failed to run pg_upgrade");
@@ -302,21 +288,21 @@ Status YsqlInitDBAndMajorUpgradeHandler::PerformPgUpgrade(const LeaderEpoch& epo
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::RunRollbackMajorVersionUpgrade(const LeaderEpoch& epoch) {
-  if (GetYsqlCatalogConfig().GetMajorCatalogUpgradeState() == YsqlMajorCatalogUpgradeInfoPB::DONE) {
+  if (ysql_catalog_config_.GetMajorCatalogUpgradeState() == YsqlMajorCatalogUpgradeInfoPB::DONE) {
     LOG_WITH_FUNC(INFO)
         << "No inflight Ysql major catalog upgrade in progress. Nothing to rollback.";
     return Status::OK();
   }
 
-  RETURN_NOT_OK(GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+  RETURN_NOT_OK(ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
       YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK, epoch));
 
   auto status = RollbackMajorVersionCatalogImpl(epoch);
   if (status.ok()) {
-    RETURN_NOT_OK(GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+    RETURN_NOT_OK(ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
         YsqlMajorCatalogUpgradeInfoPB::DONE, epoch));
   } else {
-    RETURN_NOT_OK(GetYsqlCatalogConfig().TransitionMajorCatalogUpgradeState(
+    RETURN_NOT_OK(ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
         YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch, status));
   }
 
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
index 46180c0fa8..06185af412 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
@@ -32,17 +32,11 @@ class YsqlCatalogConfig;
 class YsqlInitDBAndMajorUpgradeHandler {
  public:
   YsqlInitDBAndMajorUpgradeHandler(
-      Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog,
-      yb::ThreadPool& thread_pool);
+      Master& master, YsqlCatalogConfig& ysql_catalog_config, CatalogManager& catalog_manager,
+      SysCatalogTable& sys_catalog, yb::ThreadPool& thread_pool);
 
   ~YsqlInitDBAndMajorUpgradeHandler() = default;
 
-  IsOperationDoneResult IsInitDbDone() const;
-
-  Status SetInitDbDone(const LeaderEpoch& epoch);
-
-  IsOperationDoneResult IsCurrentVersionInitDbDone() const;
-
   void SysCatalogLoaded(const LeaderEpoch& epoch);
 
   // Starts the global initdb procedure to create the initial universe level ysql sys catalog using
@@ -102,11 +96,8 @@ class YsqlInitDBAndMajorUpgradeHandler {
   // Get the address to a live tserver process that is closest to the master.
   Result<std::string> GetClosestLiveTserverAddress();
 
-  YsqlCatalogConfig& GetYsqlCatalogConfig();
-
-  const YsqlCatalogConfig& GetYsqlCatalogConfig() const;
-
   Master& master_;
+  YsqlCatalogConfig& ysql_catalog_config_;
   CatalogManager& catalog_manager_;
   SysCatalogTable& sys_catalog_;
   yb::ThreadPool& thread_pool_;
diff --git a/src/yb/master/ysql/ysql_manager.cc b/src/yb/master/ysql/ysql_manager.cc
new file mode 100644
index 0000000000..0fcba089e7
--- /dev/null
+++ b/src/yb/master/ysql/ysql_manager.cc
@@ -0,0 +1,159 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/master/ysql/ysql_manager.h"
+
+#include "yb/master/catalog_manager.h"
+#include "yb/master/ysql/ysql_initdb_major_upgrade_handler.h"
+#include "yb/util/is_operation_done_result.h"
+
+// TODO (mbautin, 2019-12): switch the default to true after updating all external callers
+// (yb-ctl, YugaWare) and unit tests.
+DEFINE_RUNTIME_bool(master_auto_run_initdb, false,
+    "Automatically run initdb on master leader initialization");
+
+namespace yb::master {
+
+YsqlManager::YsqlManager(
+    Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog)
+    : master_(master),
+      catalog_manager_(catalog_manager),
+      sys_catalog_(sys_catalog),
+      ysql_catalog_config_(sys_catalog) {
+  ysql_initdb_and_major_upgrade_helper_ = std::make_unique<YsqlInitDBAndMajorUpgradeHandler>(
+      master, ysql_catalog_config_, catalog_manager, sys_catalog, *catalog_manager.AsyncTaskPool());
+}
+
+void YsqlManager::Clear() { ysql_catalog_config_.Reset(); }
+
+Status YsqlManager::PrepareDefaultSysConfig(const LeaderEpoch& epoch) {
+  return ysql_catalog_config_.PrepareDefaultIfNeeded(epoch);
+}
+
+void YsqlManager::LoadConfig(scoped_refptr<SysConfigInfo> config) {
+  return ysql_catalog_config_.SetConfig(config);
+}
+
+void YsqlManager::SysCatalogLoaded(const LeaderEpoch& epoch) {
+  ysql_initdb_and_major_upgrade_helper_->SysCatalogLoaded(epoch);
+}
+
+Result<bool> YsqlManager::StartRunningInitDbIfNeeded(const LeaderEpoch& epoch) {
+  if (IsInitDbDone()) {
+    LOG(INFO) << "Cluster configuration indicates that initdb has already completed";
+    return false;
+  }
+
+  if (pg_proc_exists_.load(std::memory_order_acquire)) {
+    LOG(INFO) << "Table pg_proc exists, assuming initdb has already been run";
+    // Mark initdb as done, in case it was done externally.
+    // We assume pg_proc table means initdb is done.
+    // We do NOT handle the case when initdb was terminated mid-run (neither here nor in
+    // MakeYsqlSysCatalogTablesTransactional).
+    RETURN_NOT_OK(SetInitDbDone(epoch));
+    return false;
+  }
+
+  if (!FLAGS_master_auto_run_initdb) {
+    LOG(INFO) << "--master_auto_run_initdb is set to false, not running initdb";
+    return false;
+  }
+
+  LOG(INFO) << "initdb has never been run on this cluster, running it";
+
+  RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->StartNewClusterGlobalInitDB(epoch));
+
+  LOG(INFO) << "Successfully started initdb";
+  return true;
+}
+
+bool YsqlManager::IsTransactionalSysCatalogEnabled() const {
+  return ysql_catalog_config_.IsTransactionalSysCatalogEnabled();
+}
+
+Status YsqlManager::SetTransactionalSysCatalogEnabled(const LeaderEpoch& epoch) {
+  return ysql_catalog_config_.SetTransactionalSysCatalogEnabled(epoch);
+}
+
+IsOperationDoneResult YsqlManager::IsInitDbDone() const {
+  return ysql_catalog_config_.IsInitDbDone();
+}
+
+Status YsqlManager::SetInitDbDone(const LeaderEpoch& epoch) {
+  return ysql_catalog_config_.SetInitDbDone(Status::OK(), epoch);
+}
+
+bool YsqlManager::IsYsqlMajorCatalogUpgradeInProgress() const {
+  return !ysql_catalog_config_.IsYsqlMajorCatalogUpgradeDone().done();
+}
+
+uint64_t YsqlManager::GetYsqlCatalogVersion() const { return ysql_catalog_config_.GetVersion(); }
+
+Result<uint64_t> YsqlManager::IncrementYsqlCatalogVersion(const LeaderEpoch& epoch) {
+  return ysql_catalog_config_.IncrementVersion(epoch);
+}
+
+void YsqlManager::HandleNewTableId(const TableId& table_id) {
+  if (table_id == kPgProcTableId) {
+    // Needed to track whether initdb has started running.
+    pg_proc_exists_.store(true, std::memory_order_release);
+  }
+}
+
+Status YsqlManager::StartYsqlMajorCatalogUpgrade(
+    const StartYsqlMajorCatalogUpgradeRequestPB* req, StartYsqlMajorCatalogUpgradeResponsePB* resp,
+    rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
+  LOG(INFO) << "Running ysql major catalog upgrade";
+  RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->StartYsqlMajorCatalogUpgrade(epoch));
+
+  return Status::OK();
+}
+
+Status YsqlManager::IsYsqlMajorCatalogUpgradeDone(
+    const IsYsqlMajorCatalogUpgradeDoneRequestPB* req,
+    IsYsqlMajorCatalogUpgradeDoneResponsePB* resp, rpc::RpcContext* rpc) {
+  LOG(INFO) << "Checking if ysql major catalog upgrade is done";
+  auto is_operation_done = ysql_initdb_and_major_upgrade_helper_->IsYsqlMajorCatalogUpgradeDone();
+  if (is_operation_done.done()) {
+    resp->set_done(true);
+    if (!is_operation_done.status().ok()) {
+      return is_operation_done.status();
+    }
+  } else {
+    resp->set_done(false);
+  }
+  return Status::OK();
+}
+
+Status YsqlManager::FinalizeYsqlMajorCatalogUpgrade(
+    const FinalizeYsqlMajorCatalogUpgradeRequestPB* req,
+    FinalizeYsqlMajorCatalogUpgradeResponsePB* resp, rpc::RpcContext* rpc,
+    const LeaderEpoch& epoch) {
+  LOG(INFO) << "Finalizing ysql major catalog upgrade";
+  return ysql_initdb_and_major_upgrade_helper_->FinalizeYsqlMajorCatalogUpgrade(epoch);
+}
+
+// Note that this function should be able to be called any number of times while in upgrade mode.
+Status YsqlManager::RollbackYsqlMajorCatalogVersion(
+    const RollbackYsqlMajorCatalogVersionRequestPB* req,
+    RollbackYsqlMajorCatalogVersionResponsePB* resp, rpc::RpcContext* rpc,
+    const LeaderEpoch& epoch) {
+  LOG(INFO) << "YSQL major catalog upgrade rollback initiated";
+
+  RETURN_NOT_OK(ysql_initdb_and_major_upgrade_helper_->RollbackYsqlMajorCatalogVersion(epoch));
+
+  LOG(INFO) << "YSQL major catalog upgrade rollback completed";
+  return Status::OK();
+}
+
+}  // namespace yb::master
diff --git a/src/yb/master/ysql/ysql_manager.h b/src/yb/master/ysql/ysql_manager.h
new file mode 100644
index 0000000000..900ff64567
--- /dev/null
+++ b/src/yb/master/ysql/ysql_manager.h
@@ -0,0 +1,113 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include "yb/master/ysql/ysql_manager_if.h"
+#include "yb/master/ysql/ysql_catalog_config.h"
+
+#include "yb/master/master_admin.pb.h"
+
+namespace yb {
+
+namespace rpc {
+class RpcContext;
+}  // namespace rpc
+
+namespace master {
+
+class YsqlInitDBAndMajorUpgradeHandler;
+
+class YsqlManager : public YsqlManagerIf {
+ public:
+  YsqlManager(Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog);
+
+  virtual ~YsqlManager() = default;
+
+  void Clear();
+
+  Status PrepareDefaultSysConfig(const LeaderEpoch& epoch);
+
+  void LoadConfig(scoped_refptr<SysConfigInfo> config);
+
+  void SysCatalogLoaded(const LeaderEpoch& epoch);
+
+  uint64_t GetYsqlCatalogVersion() const;
+
+  Result<uint64_t> IncrementYsqlCatalogVersion(const LeaderEpoch& epoch) override;
+
+  // Starts an asynchronous run of initdb. Errors are handled in the callback. Returns true
+  // if started running initdb, false if decided that it is not needed.
+  Result<bool> StartRunningInitDbIfNeeded(const LeaderEpoch& epoch);
+
+  YsqlCatalogConfig& GetYsqlCatalogConfig() override { return ysql_catalog_config_; }
+  const YsqlCatalogConfig& GetYsqlCatalogConfig() const override { return ysql_catalog_config_; }
+
+  IsOperationDoneResult IsInitDbDone() const;
+
+  Status SetInitDbDone(const LeaderEpoch& epoch);
+
+  bool IsYsqlMajorCatalogUpgradeInProgress() const;
+
+  void HandleNewTableId(const TableId& table_id);
+
+  bool IsTransactionalSysCatalogEnabled() const override;
+  Status SetTransactionalSysCatalogEnabled(const LeaderEpoch& epoch) override;
+
+  // Initiates ysql major catalog upgrade which involves global initdb, pg_upgrade, and catalog
+  // version fixups.
+  // IsYsqlMajorCatalogUpgradeDone must be called to track the completion status of the
+  // operation.
+  Status StartYsqlMajorCatalogUpgrade(
+      const StartYsqlMajorCatalogUpgradeRequestPB* req,
+      StartYsqlMajorCatalogUpgradeResponsePB* resp, rpc::RpcContext* rpc, const LeaderEpoch& epoch);
+
+  // Checks if ysql major catalog upgrade has completed.
+  Status IsYsqlMajorCatalogUpgradeDone(
+      const IsYsqlMajorCatalogUpgradeDoneRequestPB* req,
+      IsYsqlMajorCatalogUpgradeDoneResponsePB* resp, rpc::RpcContext* rpc);
+
+  Status FinalizeYsqlMajorCatalogUpgrade(
+      const FinalizeYsqlMajorCatalogUpgradeRequestPB* req,
+      FinalizeYsqlMajorCatalogUpgradeResponsePB* resp, rpc::RpcContext* rpc,
+      const LeaderEpoch& epoch);
+
+  // Rolls back the major YSQL catalog to the previous version. Deletes all of the new YSQL
+  // version's catalog tables, and resets all upgrade-related state to initial values. Blocks until
+  // the rollback is finished or fails.
+  // Takes a long time to run. Use a timeout of at least 5 minutes when calling.
+  Status RollbackYsqlMajorCatalogVersion(
+      const RollbackYsqlMajorCatalogVersionRequestPB* req,
+      RollbackYsqlMajorCatalogVersionResponsePB* resp, rpc::RpcContext* rpc,
+      const LeaderEpoch& epoch);
+
+ private:
+  Result<bool> StartRunningInitDbIfNeededInternal(const LeaderEpoch& epoch);
+
+  Master& master_;
+  CatalogManager& catalog_manager_;
+  SysCatalogTable& sys_catalog_;
+
+  YsqlCatalogConfig ysql_catalog_config_;
+
+  std::unique_ptr<YsqlInitDBAndMajorUpgradeHandler> ysql_initdb_and_major_upgrade_helper_;
+
+  // This is used for tracking that initdb has started running previously.
+  std::atomic<bool> pg_proc_exists_{false};
+
+  DISALLOW_COPY_AND_ASSIGN(YsqlManager);
+};
+
+}  // namespace master
+
+}  // namespace yb
diff --git a/src/yb/master/ysql/ysql_manager_if.h b/src/yb/master/ysql/ysql_manager_if.h
new file mode 100644
index 0000000000..03abe16534
--- /dev/null
+++ b/src/yb/master/ysql/ysql_manager_if.h
@@ -0,0 +1,36 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include "yb/master/leader_epoch.h"
+#include "yb/util/status_fwd.h"
+
+namespace yb::master {
+
+class YsqlCatalogConfig;
+
+class YsqlManagerIf {
+ public:
+  virtual ~YsqlManagerIf() = default;
+
+  virtual YsqlCatalogConfig& GetYsqlCatalogConfig() = 0;
+  virtual const YsqlCatalogConfig& GetYsqlCatalogConfig() const = 0;
+
+  virtual Result<uint64_t> IncrementYsqlCatalogVersion(const LeaderEpoch& epoch) = 0;
+
+  virtual bool IsTransactionalSysCatalogEnabled() const = 0;
+  virtual Status SetTransactionalSysCatalogEnabled(const LeaderEpoch& epoch) = 0;
+};
+
+}  // namespace yb::master
