diff --git a/src/yb/integration-tests/external_daemon.cc b/src/yb/integration-tests/external_daemon.cc
index 477e6fdeac..44955ede50 100644
--- a/src/yb/integration-tests/external_daemon.cc
+++ b/src/yb/integration-tests/external_daemon.cc
@@ -509,7 +509,7 @@ void ExternalDaemon::Shutdown(SafeShutdown safe_shutdown, RequireExitCode0 requi
   WARN_NOT_OK(process_->Wait(&ret), Format("$0 Waiting on $1", LogPrefix(), process_name_and_pid));
   process_.reset();
   LOG_WITH_PREFIX(INFO) << "Process " << process_name_and_pid << " shutdown completed in "
-                        << CoarseMonoClock::Now() - start_time << "ms";
+                        << ToMilliseconds(CoarseMonoClock::Now() - start_time) << "ms";
 }
 
 void ExternalDaemon::FlushCoverage() {
diff --git a/src/yb/master/clone/clone_state_manager.cc b/src/yb/master/clone/clone_state_manager.cc
index 430464783e..f61f830ae8 100644
--- a/src/yb/master/clone/clone_state_manager.cc
+++ b/src/yb/master/clone/clone_state_manager.cc
@@ -672,6 +672,8 @@ Status CloneStateManager::EnableDbConnections(const CloneStateInfoPtr& clone_sta
       auto lock = clone_state->LockForWrite();
       SCHECK_EQ(lock->pb.aggregate_state(), SysCloneStatePB::RESTORED, IllegalState,
           "Expected clone to be in restored state");
+      LOG(INFO) << Format("Marking clone as complete for source namespace $0 with seq_no $1",
+                          lock->pb.source_namespace_id(), lock->pb.clone_request_seq_no());
       lock.mutable_data()->pb.set_aggregate_state(SysCloneStatePB::COMPLETE);
       LOG(INFO) << Format(
           "Marking clone of namespace: $0 as complete", lock->pb.source_namespace_id());
diff --git a/src/yb/tools/yb-admin-snapshot-schedule-test.cc b/src/yb/tools/yb-admin-snapshot-schedule-test.cc
index 89fbfd818b..b918d7c8c7 100644
--- a/src/yb/tools/yb-admin-snapshot-schedule-test.cc
+++ b/src/yb/tools/yb-admin-snapshot-schedule-test.cc
@@ -201,7 +201,7 @@ class YbAdminSnapshotScheduleTest : public AdminTestBase {
     return restoration_id;
   }
 
-  Status RestoreSnapshotSchedule(const std::string& schedule_id, Timestamp restore_at) {
+  virtual Status RestoreSnapshotSchedule(const std::string& schedule_id, Timestamp restore_at) {
     return WaitRestorationDone(
         VERIFY_RESULT(StartRestoreSnapshotSchedule(schedule_id, restore_at)),
         40s * kTimeMultiplier);
@@ -538,6 +538,7 @@ class YbAdminSnapshotScheduleTestWithYsql : public YbAdminSnapshotScheduleTest {
     return LoggedWaitFor([&]() -> Result<bool> {
       auto res = conn->FetchRow<std::string>(query);
       if (!res.ok()) {
+        LOG(INFO) << "Fetch row failed. Status: " << res.status();
         return false;
       }
       LOG(INFO) << "Got value: " << *res << ", expected: " << expectation;
@@ -1113,13 +1114,27 @@ TEST_F(YbAdminSnapshotScheduleTest, ListRestorationsTestMigration) {
   LOG(INFO) << "Restoration: " << restorations[0];
 }
 
-// This class simplifies the way to run PITR tests against (not) colocated database.
-// After setting proper callback functions, calling RunTestWithColocatedParam performs the test.
-// You can also write tests inherit from this class without using this framework.
+YB_DEFINE_ENUM(RestoreType, (kPITR)(kClone));
+using ScheduleRestoreTestParams = std::tuple<YsqlColocationConfig, RestoreType>;
+
+// This class simplifies the way to run PITR and DB clone tests against colocated & non-colocated
+// databases. After setting the callback functions, calling RunTestWithColocatedParam performs the
+// test.
+// This class should not be instantiated directly. Instead, use the classes that specify
+// which combinations to run.
 class YbAdminSnapshotScheduleTestWithYsqlParam
     : public YbAdminSnapshotScheduleTestWithYsql,
-      public ::testing::WithParamInterface<YsqlColocationConfig> {
+      public ::testing::WithParamInterface<ScheduleRestoreTestParams> {
  public:
+  void SetUp() override {
+    if (GetRestoreType() == RestoreType::kClone && IsAsan()) {
+      LOG(INFO) << "This test is disabled in ASAN as ysql_dump fails due to memory leaks inherited "
+                << "from pg_dump.";
+      GTEST_SKIP();
+    }
+    YbAdminSnapshotScheduleTestWithYsql::SetUp();
+  }
+
   using StepCallback = std::function<void(const std::string&, const std::string&)>;
 
   void UpdateMiniClusterOptions(ExternalMiniClusterOptions* opts) override {
@@ -1127,7 +1142,45 @@ class YbAdminSnapshotScheduleTestWithYsqlParam
     opts->extra_tserver_flags.emplace_back("--ysql_beta_feature_tablegroup=true");
   }
 
-  Result<std::string> PreparePgWithColocatedParam() { return PreparePg(GetParam()); }
+  virtual std::vector<std::string> ExtraTSFlags() override {
+    auto flags = YbAdminSnapshotScheduleTestWithYsql::ExtraTSFlags();
+    flags.push_back("--ysql_hba_conf_csv=local all yugabyte trust, host all all all trust");
+    return flags;
+  }
+
+  virtual std::vector<std::string> ExtraMasterFlags() override {
+    auto flags = YbAdminSnapshotScheduleTestWithYsql::ExtraMasterFlags();
+    flags.push_back("--allowed_preview_flags_csv=enable_db_clone");
+    flags.push_back("--enable_db_clone=true");
+    return flags;
+  }
+
+  YsqlColocationConfig GetColocationParam() { return std::get<0>(GetParam()); }
+  RestoreType GetRestoreType() { return std::get<1>(GetParam()); }
+
+  Result<std::string> PreparePgWithColocatedParam() { return PreparePg(GetColocationParam()); }
+
+  std::string GetRestoredDbName() {
+    return GetRestoreType() == RestoreType::kClone ?
+           "clone_target_db" :
+           kTableName.namespace_name();
+  }
+
+  Result<pgwrapper::PGConn> ConnectToRestoredDb() {
+    return PgConnect(GetRestoredDbName());
+  }
+
+  virtual Status RestoreSnapshotSchedule(
+      const std::string& schedule_id, Timestamp restore_at) override {
+    if (GetRestoreType() == RestoreType::kClone) {
+      RETURN_NOT_OK(CloneAndWait(
+          "ysql." + kTableName.namespace_name(), GetRestoredDbName(), 2min /* timeout */,
+          restore_at.ToFormattedString()));
+      return Status::OK();
+    } else {
+      return YbAdminSnapshotScheduleTest::RestoreSnapshotSchedule(schedule_id, restore_at);
+    }
+  }
 
   void ExecuteOnTables(std::string non_colo_prefix,
                        std::string non_colo_option,
@@ -1138,7 +1191,7 @@ class YbAdminSnapshotScheduleTestWithYsqlParam
       return;
     }
 
-    if (GetParam() != YsqlColocationConfig::kNotColocated) {
+    if (GetColocationParam() != YsqlColocationConfig::kNotColocated) {
       for (const auto& colo_prefix : colo_prefixes) {
         step(colo_prefix, colo_option);
       }
@@ -1151,7 +1204,9 @@ class YbAdminSnapshotScheduleTestWithYsqlParam
   void RunTestWithColocatedParam(std::string schedule_id) {
     std::vector<std::string> colocated_prefixes = {"colocated", "colocated2"};
     std::string colocated_option =
-        GetParam() == YsqlColocationConfig::kTablegroup ? "TABLEGROUP " + kTablegroupName : "";
+        GetColocationParam() == YsqlColocationConfig::kTablegroup ?
+                                "TABLEGROUP " + kTablegroupName :
+                                "";
     std::string not_colocated_prefix = "not_colocated";
     std::string not_colocated_option = "WITH (COLOCATION = FALSE)";
 
@@ -1177,12 +1232,28 @@ class YbAdminSnapshotScheduleTestWithYsqlParam
   StepCallback CheckAfterPITR;
 };
 
-INSTANTIATE_TEST_CASE_P(Colocation, YbAdminSnapshotScheduleTestWithYsqlParam,
-                        ::testing::Values(YsqlColocationConfig::kNotColocated,
-                                          YsqlColocationConfig::kDBColocated,
-                                          YsqlColocationConfig::kTablegroup));
-
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, Pgsql) {
+// Test for PITR against colocated and non-colocated databases.
+class YbAdminSnapshotScheduleTestWithYsqlColocationParam:
+    public YbAdminSnapshotScheduleTestWithYsqlParam {};
+INSTANTIATE_TEST_CASE_P(
+    Colocation, YbAdminSnapshotScheduleTestWithYsqlColocationParam, ::testing::Values(
+        ScheduleRestoreTestParams(YsqlColocationConfig::kNotColocated, RestoreType::kPITR),
+        ScheduleRestoreTestParams(YsqlColocationConfig::kDBColocated, RestoreType::kPITR),
+        ScheduleRestoreTestParams(YsqlColocationConfig::kTablegroup, RestoreType::kPITR)));
+
+// Test for PITR and DB clone against colocated and non-colocated databases.
+class YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam:
+    public YbAdminSnapshotScheduleTestWithYsqlParam {};
+INSTANTIATE_TEST_CASE_P(
+    ColocationAndRestoreType, YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam,
+    ::testing::Values(
+        ScheduleRestoreTestParams(YsqlColocationConfig::kNotColocated, RestoreType::kPITR),
+        ScheduleRestoreTestParams(YsqlColocationConfig::kDBColocated, RestoreType::kPITR),
+        ScheduleRestoreTestParams(YsqlColocationConfig::kTablegroup, RestoreType::kPITR),
+        ScheduleRestoreTestParams(YsqlColocationConfig::kNotColocated, RestoreType::kClone),
+        ScheduleRestoreTestParams(YsqlColocationConfig::kDBColocated, RestoreType::kClone)));
+
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, Pgsql) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1194,12 +1265,13 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, Pgsql) {
   ASSERT_OK(conn.Execute("UPDATE test_table SET value = 'after'"));
 
   ASSERT_OK(RestoreSnapshotSchedule(schedule_id, time));
+  conn = ASSERT_RESULT(ConnectToRestoredDb());
 
   auto res = ASSERT_RESULT(conn.FetchRow<std::string>("SELECT value FROM test_table"));
   ASSERT_EQ(res, "before");
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropDatabaseAndSchedule) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationParam, PgsqlDropDatabaseAndSchedule) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect());
 
@@ -1212,7 +1284,9 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropDatabaseAndSchedule) {
   ASSERT_OK(conn.Execute(Format("DROP DATABASE $0", client::kTableName.namespace_name())));
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlCreateTable) {
+// TODO(asrivastava): This test sometimes fails to delete the table on PITR if we refresh the PG
+// connection after the restore.
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationParam, PgsqlCreateTable) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1267,7 +1341,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlCreateTable) {
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropTable) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlDropTable) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1285,7 +1359,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropTable) {
     ASSERT_OK(conn.ExecuteFormat("DROP TABLE $0", table_name));
   };
 
-  CheckAfterPITR = [&conn](const std::string& prefix, const std::string& option) {
+  CheckAfterPITR = [this](const std::string& prefix, const std::string& option) {
+    auto conn = ASSERT_RESULT(ConnectToRestoredDb());
     const auto table_name = prefix + "_table";
 
     auto res = ASSERT_RESULT(conn.FetchRow<std::string>(Format(
@@ -1300,7 +1375,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropTable) {
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, FailAfterMigration) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationParam, FailAfterMigration) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1323,7 +1398,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, FailAfterMigration) {
       restore_status.message().ToBuffer(), "Unable to restore as YSQL upgrade was performed");
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlCreateIndex) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlCreateIndex) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1348,7 +1423,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlCreateIndex) {
     ASSERT_TRUE(is_index_scan);
   };
 
-  CheckAfterPITR = [&conn](const std::string& prefix, const std::string& option) {
+  CheckAfterPITR = [this](const std::string& prefix, const std::string& option) {
+    auto conn = ASSERT_RESULT(ConnectToRestoredDb());
     const auto table_name = prefix + "_table";
     const auto table_idx_name = prefix + "_table_idx";
 
@@ -1381,7 +1457,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlCreateIndex) {
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropIndex) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlDropIndex) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1408,7 +1484,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropIndex) {
     ASSERT_FALSE(is_index_scan);
   };
 
-  CheckAfterPITR = [&conn](const std::string& prefix, const std::string& option) {
+  CheckAfterPITR = [this](const std::string& prefix, const std::string& option) {
+    auto conn = ASSERT_RESULT(ConnectToRestoredDb());
     const auto table_name = prefix + "_table";
     const auto table_idx_name = prefix + "_table_idx";
 
@@ -1438,7 +1515,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropIndex) {
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAddColumn) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlAddColumn) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1463,7 +1540,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAddColumn) {
     ASSERT_EQ(res, "now2");
   };
 
-  CheckAfterPITR = [this, &conn](const std::string& prefix, const std::string& option) {
+  CheckAfterPITR = [this](const std::string& prefix, const std::string& option) {
+    auto conn = ASSERT_RESULT(ConnectToRestoredDb());
     const auto table_name = prefix + "_table";
 
     LOG(INFO) << "Select data from the table after restore";
@@ -1486,7 +1564,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAddColumn) {
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDeleteColumn) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlDeleteColumn) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1520,7 +1598,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDeleteColumn) {
     ASSERT_STR_CONTAINS(insert_status.ToString(), "more expressions than target columns");
   };
 
-  CheckAfterPITR = [this, &conn](const std::string& prefix, const std::string& option) {
+  CheckAfterPITR = [this](const std::string& prefix, const std::string& option) {
+    auto conn = ASSERT_RESULT(ConnectToRestoredDb());
     const auto table_name = prefix + "_table";
 
     LOG(INFO) << "Select data from the table after restore";
@@ -1536,7 +1615,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDeleteColumn) {
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDeleteColumnWithMissingDefault) {
+// TODO(asrivastava): Fails with DB cloning.
+TEST_P( YbAdminSnapshotScheduleTestWithYsqlColocationParam, PgsqlDeleteColumnWithMissingDefault) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1573,7 +1653,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDeleteColumnWithMissingDef
     ASSERT_STR_CONTAINS(insert_status.ToString(), "more expressions than target columns");
   };
 
-  CheckAfterPITR = [this, &conn](const std::string& prefix, const std::string& option) {
+  CheckAfterPITR = [this](const std::string& prefix, const std::string& option) {
+    auto conn = ASSERT_RESULT(ConnectToRestoredDb());
     const auto table_name = prefix + "_table";
 
     LOG(INFO) << "Select data from the table after restore";
@@ -1593,7 +1674,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDeleteColumnWithMissingDef
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlRenameTable) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlRenameTable) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1616,6 +1697,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlRenameTable) {
   ASSERT_FALSE(result_with_old_name.ok());
 
   ASSERT_OK(RestoreSnapshotSchedule(schedule_id, time));
+  conn = ASSERT_RESULT(ConnectToRestoredDb());
 
   LOG(INFO) << "Select data from table after restore";
   // There might be a transient period when we get stale data before
@@ -1635,7 +1717,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlRenameTable) {
   ASSERT_OK(conn.Execute("INSERT INTO test_table VALUES (2, 'new value')"));
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlRenameColumn) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlRenameColumn) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1659,6 +1741,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlRenameColumn) {
   ASSERT_EQ(select_res, "before");
 
   ASSERT_OK(RestoreSnapshotSchedule(schedule_id, time));
+  conn = ASSERT_RESULT(ConnectToRestoredDb());
 
   LOG(INFO) << "Select data from table after restore";
   std::string query = "SELECT value FROM test_table";
@@ -1674,7 +1757,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlRenameColumn) {
   ASSERT_OK(conn.Execute("INSERT INTO test_table(key, value) VALUES (2, 'new_value')"));
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSetDefault) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlSetDefault) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1698,6 +1781,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSetDefault) {
 
   LOG(INFO) << "Perform a Restore to the time noted above";
   ASSERT_OK(RestoreSnapshotSchedule(schedule_id, time));
+  conn = ASSERT_RESULT(ConnectToRestoredDb());
 
   LOG(INFO) << "Insert a new row and verify that the default clause is no longer present";
   // There might be a transient period when we get stale data before
@@ -1711,7 +1795,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSetDefault) {
   ASSERT_NOK(conn.FetchRow<std::string>("SELECT * FROM test_table where key=2"));
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropDefault) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlDropDefault) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1743,7 +1827,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropDefault) {
     ASSERT_EQ(res2, std::nullopt);
   };
 
-  CheckAfterPITR = [this, &conn](const std::string& prefix, const std::string& option) {
+  CheckAfterPITR = [this](const std::string& prefix, const std::string& option) {
+    auto conn = ASSERT_RESULT(ConnectToRestoredDb());
     const auto table_name = prefix + "_table";
 
     LOG(INFO) << "Insert a row and verify that the default clause is still present";
@@ -1914,7 +1999,7 @@ void YbAdminSnapshotScheduleTestWithYsql::TestPgsqlDropDefault() {
   ASSERT_FALSE(result_status.ok());
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSetNotNull) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlSetNotNull) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1936,6 +2021,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSetNotNull) {
 
   LOG(INFO) << "Perform a Restore to the time noted above";
   ASSERT_OK(RestoreSnapshotSchedule(schedule_id, time));
+  conn = ASSERT_RESULT(ConnectToRestoredDb());
 
   LOG(INFO) << "Insert rows with null values and verify it goes through successfully";
   // There might be a transient period of time when constraint exists since
@@ -1948,7 +2034,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSetNotNull) {
   ASSERT_EQ(res3, std::nullopt);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropNotNull) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlDropNotNull) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -1973,6 +2059,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropNotNull) {
 
   LOG(INFO) << "Perform a Restore to the time noted above";
   ASSERT_OK(RestoreSnapshotSchedule(schedule_id, time));
+  conn = ASSERT_RESULT(ConnectToRestoredDb());
 
   LOG(INFO) << "Verify failure on null insertion since the drop is restored via PITR";
   // There might be a transient period of time when constraint does not exist
@@ -1981,7 +2068,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropNotNull) {
   ASSERT_OK(WaitForInsertQueryToStopWorking(query_template, &conn, 3));
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAlterTableAddPK) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlAlterTableAddPK) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2010,7 +2097,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAlterTableAddPK) {
     ASSERT_STR_CONTAINS(insert_res.ToString(), "violates not-null constraint");
   };
 
-  CheckAfterPITR = [this, &conn](const std::string& prefix, const std::string& option) {
+  CheckAfterPITR = [this](const std::string& prefix, const std::string& option) {
+    auto conn = ASSERT_RESULT(ConnectToRestoredDb());
     const auto table_name = prefix + "_table";
 
     LOG(INFO) << "Verify primary key constraint no longer exists";
@@ -2027,7 +2115,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAlterTableAddPK) {
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAlterTableAddFK) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlAlterTableAddFK) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2056,7 +2144,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAlterTableAddFK) {
     ASSERT_STR_CONTAINS(insert_res.ToString(), "violates foreign key constraint");
   };
 
-  CheckAfterPITR = [this, &conn](const std::string& prefix, const std::string& option) {
+  CheckAfterPITR = [this](const std::string& prefix, const std::string& option) {
+    auto conn = ASSERT_RESULT(ConnectToRestoredDb());
     const auto table_name = prefix + "_table";
     const auto table_name_2 = prefix + "_table_2";
 
@@ -2073,7 +2162,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAlterTableAddFK) {
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAlterTableSetOwner) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlAlterTableSetOwner) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2107,6 +2196,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAlterTableSetOwner) {
 
   LOG(INFO) << "Perform a Restore to the time noted above";
   ASSERT_OK(RestoreSnapshotSchedule(schedule_id, time));
+  conn = ASSERT_RESULT(ConnectToRestoredDb());
 
   // Wait for the tservers to refresh their cache.
   // We wait for 4 cycles of Heartbeats.
@@ -2126,7 +2216,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAlterTableSetOwner) {
   ASSERT_OK(conn.Execute("ALTER TABLE test_table RENAME key TO key_new3"));
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlTestTruncate) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlTestTruncate) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2154,7 +2244,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlTestTruncate) {
     ASSERT_OK(conn.ExecuteFormat("INSERT INTO $0 VALUES (2, 'after')", table_name));
   };
 
-  CheckAfterPITR = [this, &conn](const std::string& prefix, const std::string& option) {
+  CheckAfterPITR = [this](const std::string& prefix, const std::string& option) {
+    auto conn = ASSERT_RESULT(ConnectToRestoredDb());
     const auto table_name = prefix + "_table";
 
     LOG(INFO) << "Select data from the table after restore";
@@ -2176,7 +2267,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlTestTruncate) {
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAlterTableWithRewrite) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlAlterTableWithRewrite) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2195,12 +2286,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAlterTableWithRewrite) {
 
     LOG(INFO) << "Perform some table rewrite operations on the table";
     ASSERT_OK(conn.ExecuteFormat("ALTER TABLE $0 DROP CONSTRAINT $0_pkey", table_name));
-    // Set the yb_ddl_rollback_enabled GUC var so that we can perform an
-    // ADD COLUMN ... PRIMARY KEY operation.
-    ASSERT_OK(conn.ExecuteFormat("SET yb_ddl_rollback_enabled = ON"));
     ASSERT_OK(conn.ExecuteFormat(
         "ALTER TABLE $0 ADD COLUMN newcol INT PRIMARY KEY DEFAULT 2", table_name));
-    ASSERT_OK(conn.ExecuteFormat("SET yb_ddl_rollback_enabled = OFF"));
     ASSERT_OK(conn.ExecuteFormat(
         "ALTER TABLE $0 ALTER COLUMN value TYPE int USING length(value)", table_name));
     // Verify that we can't insert duplicate values into the pkey column (newcol).
@@ -2215,7 +2302,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAlterTableWithRewrite) {
     ASSERT_OK(conn.ExecuteFormat("INSERT INTO $0 VALUES (1, 7, 3)", table_name));
   };
 
-  CheckAfterPITR = [this, &conn](const std::string& prefix, const std::string& option) {
+  CheckAfterPITR = [this](const std::string& prefix, const std::string& option) {
+    auto conn = ASSERT_RESULT(ConnectToRestoredDb());
     const auto table_name = prefix + "_table";
 
     LOG(INFO) << "Select data from the table after restore";
@@ -2241,7 +2329,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAlterTableWithRewrite) {
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAddUniqueConstraint) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlAddUniqueConstraint) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2267,7 +2355,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAddUniqueConstraint) {
     ASSERT_STR_CONTAINS(insert_res.ToString(), "violates unique constraint");
   };
 
-  CheckAfterPITR = [this, &conn](const std::string& prefix, const std::string& option) {
+  CheckAfterPITR = [this](const std::string& prefix, const std::string& option) {
+    auto conn = ASSERT_RESULT(ConnectToRestoredDb());
     const auto table_name = prefix + "_table";
 
     LOG(INFO) << "Verify unique constraint is no longer present";
@@ -2280,7 +2369,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAddUniqueConstraint) {
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropUniqueConstraint) {
+// TODO(asrivastava): Fails for DB cloning with colocated databases.
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationParam, PgsqlDropUniqueConstraint) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2314,7 +2404,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropUniqueConstraint) {
     ASSERT_OK(conn.ExecuteFormat("INSERT INTO $0 VALUES (2, 'ABC')", table_name));
   };
 
-  CheckAfterPITR = [this, &conn](const std::string& prefix, const std::string& option) {
+  CheckAfterPITR = [this](const std::string& prefix, const std::string& option) {
+    auto conn = ASSERT_RESULT(ConnectToRestoredDb());
     const auto table_name = prefix + "_table";
 
     LOG(INFO) << "Verify that the unique constraint is present and drop is restored";
@@ -2333,7 +2424,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropUniqueConstraint) {
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAddCheckConstraint) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlAddCheckConstraint) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2355,6 +2446,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAddCheckConstraint) {
 
   LOG(INFO) << "Perform a Restore to the time noted above";
   ASSERT_OK(RestoreSnapshotSchedule(schedule_id, time));
+  conn = ASSERT_RESULT(ConnectToRestoredDb());
 
   LOG(INFO) << "Verify check constraint is removed post PITR";
   // There might be a transient period of time when constraint exists since
@@ -2363,7 +2455,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlAddCheckConstraint) {
   ASSERT_OK(WaitForInsertQueryToSucceed(query, &conn));
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropCheckConstraint) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationRestoreParam, PgsqlDropCheckConstraint) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2383,6 +2475,7 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropCheckConstraint) {
 
   LOG(INFO) << "Perform a Restore to the time noted above";
   ASSERT_OK(RestoreSnapshotSchedule(schedule_id, time));
+  conn = ASSERT_RESULT(ConnectToRestoredDb());
 
   LOG(INFO) << "Verify drop constraint is undone post PITR";
   // There might be a transient period of time when constraint does not exist
@@ -2398,7 +2491,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlDropCheckConstraint) {
   ASSERT_FALSE(result_status.ok());
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSequenceUndoDeletedData) {
+// TODO(yamen): Fails for DB cloning with colocated databases.
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationParam, PgsqlSequenceUndoDeletedData) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2435,7 +2529,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSequenceUndoDeletedData) {
   ASSERT_EQ(res, 16);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSequenceUndoInsertedData) {
+// TODO(yamen): Fails for DB cloning with colocated databases.
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationParam, PgsqlSequenceUndoInsertedData) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2480,7 +2575,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSequenceUndoInsertedData)
   ASSERT_EQ(res, 21);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSequenceUndoCreateSequence) {
+// TODO(yamen): Fails for DB cloning with colocated databases.
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationParam, PgsqlSequenceUndoCreateSequence) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2531,7 +2627,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSequenceUndoCreateSequence
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSequenceUndoDropSequence) {
+// TODO(yamen): Fails for DB cloning with colocated databases.
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationParam, PgsqlSequenceUndoDropSequence) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2570,7 +2667,8 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSequenceUndoDropSequence)
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSequenceVerifyPartialRestore) {
+// TODO(yamen): Fails for DB cloning with colocated databases.
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationParam, PgsqlSequenceVerifyPartialRestore) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
   // Connection to yugabyte database.
@@ -2682,7 +2780,9 @@ TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSequenceVerifyPartialResto
   RunTestWithColocatedParam(schedule_id);
 }
 
-TEST_P(YbAdminSnapshotScheduleTestWithYsqlParam, PgsqlSequencePartialCleanupAfterRestore) {
+// TODO(yamen): Fails for DB cloning with colocated databases.
+TEST_P(
+    YbAdminSnapshotScheduleTestWithYsqlColocationParam, PgsqlSequencePartialCleanupAfterRestore) {
   auto schedule_id = ASSERT_RESULT(PreparePgWithColocatedParam());
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
   // Connection to yugabyte database.
@@ -2944,8 +3044,7 @@ TEST_F_EX(YbAdminSnapshotScheduleTest, PgsqlTestPerDbCatalogVersion,
   ASSERT_TRUE(found_my_ns);
 }
 
-TEST_F_EX(YbAdminSnapshotScheduleTest, RestoreDroppedTablegroup,
-          YbAdminSnapshotScheduleTestWithYsqlParam) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationParam, RestoreDroppedTablegroup) {
   auto schedule_id = ASSERT_RESULT(PreparePg(YsqlColocationConfig::kTablegroup));
   auto conn = ASSERT_RESULT(PgConnect(client::kTableName.namespace_name()));
 
@@ -2996,8 +3095,7 @@ TEST_F_EX(YbAdminSnapshotScheduleTest, RestoreDroppedTablegroup,
   ASSERT_OK(conn.Execute("INSERT INTO test_table_2 VALUES (1, 'after')"));
 }
 
-TEST_F_EX(YbAdminSnapshotScheduleTest, DropTablegroupWithRestoredTable,
-          YbAdminSnapshotScheduleTestWithYsqlParam) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationParam, DropTablegroupWithRestoredTable) {
   // Verify when a tablegroup child table is HIDDEN in both current and restoring time, then PITR
   // should NOT unhide it accidently.
   auto schedule_id = ASSERT_RESULT(PreparePg(YsqlColocationConfig::kTablegroup));
@@ -3035,8 +3133,7 @@ TEST_F_EX(YbAdminSnapshotScheduleTest, DropTablegroupWithRestoredTable,
   ASSERT_OK(conn.ExecuteFormat("DROP TABLEGROUP $0", kTablegroupName));
 }
 
-TEST_F_EX(YbAdminSnapshotScheduleTest, RestoreWithTwoTablegroups,
-          YbAdminSnapshotScheduleTestWithYsqlParam) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationParam, RestoreWithTwoTablegroups) {
   // Verify PITR restore does HIDE the current tablegroup which didn't exist in the restoring time
   // and recover the one exists in the restoring time.
   auto schedule_id = ASSERT_RESULT(PreparePg(YsqlColocationConfig::kTablegroup));
@@ -3072,8 +3169,7 @@ TEST_F_EX(YbAdminSnapshotScheduleTest, RestoreWithTwoTablegroups,
   ASSERT_NOK(conn.ExecuteFormat(query, "test_tg"));
 }
 
-TEST_F_EX(YbAdminSnapshotScheduleTest, TablegroupGCAfterRestore,
-          YbAdminSnapshotScheduleTestWithYsqlParam) {
+TEST_P(YbAdminSnapshotScheduleTestWithYsqlColocationParam, TablegroupGCAfterRestore) {
   // Verify the tablegroup gets cleaned up if it is marked as HIDDEN after PITR restore and
   // goes out of retention period.
   auto schedule_id = ASSERT_RESULT(PreparePg(
@@ -3239,8 +3335,7 @@ TEST_F(YbAdminSnapshotScheduleUpgradeTestWithYsql,
   Timestamp time = ASSERT_RESULT(GetCurrentTime());
   ASSERT_OK(conn.Execute("DROP TABLE test_table"));
 
-  auto restore_status = RestoreSnapshotSchedule(schedule_id, time);
-  ASSERT_OK(restore_status);
+  ASSERT_OK(RestoreSnapshotSchedule(schedule_id, time));
 
   auto res = ASSERT_RESULT(conn.FetchRow<std::string>(
       "SELECT value FROM test_table WHERE key = 1"));
@@ -3298,6 +3393,7 @@ TEST_F(YbAdminSnapshotScheduleTest, UndeleteIndex) {
   ASSERT_OK(conn.ExecuteQuery("INSERT INTO test_table (key, value) VALUES (3, 'value')"));
 
   ASSERT_OK(RestoreSnapshotSchedule(schedule_id, time));
+  conn = ASSERT_RESULT(CqlConnect(client::kTableName.namespace_name()));
 
   ASSERT_NOK(conn.ExecuteQuery("INSERT INTO test_table (key, value) VALUES (5, 'value')"));
 
diff --git a/src/yb/util/tsan_util.h b/src/yb/util/tsan_util.h
index 812b55258c..2e3d02f5af 100644
--- a/src/yb/util/tsan_util.h
+++ b/src/yb/util/tsan_util.h
@@ -28,6 +28,14 @@ constexpr bool IsTsan() {
   return NonTsanVsTsan(false, true);
 }
 
+constexpr bool IsAsan() {
+#if ADDRESS_SANITIZER
+  return true;
+#else
+  return false;
+#endif
+}
+
 template <class T>
 constexpr T RegularBuildVsSanitizers(T regular_build_value, T sanitizer_value) {
 #if defined(THREAD_SANITIZER) || defined(ADDRESS_SANITIZER)
