diff --git a/src/yb/master/master-path-handlers.cc b/src/yb/master/master-path-handlers.cc
index 1ead68b866..56fc14673d 100644
--- a/src/yb/master/master-path-handlers.cc
+++ b/src/yb/master/master-path-handlers.cc
@@ -2877,14 +2877,13 @@ void MasterPathHandlers::HandleXCluster(
 
   uint32 outbound_group_table_id = 0;
   if (!xcluster_status.outbound_replication_group_statuses.empty()) {
-    output << "<h3>Outbound ReplicationGroups</h3>\n";
+    output << "<br><h3>Outbound Replication Groups</h3>\n";
     for (const auto& outbound_replication_group :
          xcluster_status.outbound_replication_group_statuses) {
       auto group_fs = AutoFieldsetScope(
           output, Format("Group: $0", outbound_replication_group.replication_group_id));
 
-      output << "<pre class=\"prettyprint\">"
-             << "state: " << outbound_replication_group.state;
+      output << "<pre class=\"prettyprint\">" << "state: " << outbound_replication_group.state;
       if (!outbound_replication_group.target_universe_info.empty()) {
         output << "\ntarget_universe_info: " << outbound_replication_group.target_universe_info;
       }
@@ -2902,14 +2901,14 @@ void MasterPathHandlers::HandleXCluster(
         output << "</pre>";
 
         HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(
-            outbound_replication_group, outbound_group_table_id, "Table Id", "Stream Id", "State",
-            "Checkpointing", "Part of initial bootstrap");
+            outbound_replication_group, outbound_group_table_id, "Table name", "Table Id",
+            "Stream Id", "State", "Checkpointing", "Part of initial bootstrap");
         outbound_group_table_id++;
 
         for (const auto& table_status : namespace_status.table_statuses) {
           HTML_PRINT_TABLE_ROW(
-              table_status.table_id, table_status.stream_id, table_status.state,
-              BoolToString(table_status.is_checkpointing),
+              table_status.full_table_name, table_status.table_id, table_status.stream_id,
+              table_status.state, BoolToString(table_status.is_checkpointing),
               BoolToString(table_status.is_part_of_initial_bootstrap));
         }
         HTML_END_TABLE;
@@ -2919,22 +2918,24 @@ void MasterPathHandlers::HandleXCluster(
 
   if (!xcluster_status.outbound_table_stream_statuses.empty()) {
     output << "<br><h3>Outbound table streams</h3>\n";
-    HTML_PRINT_TABLE_WITH_HEADER_ROW(outbound_table_streams, "Table Id", "Stream Id", "State");
+    HTML_PRINT_TABLE_WITH_HEADER_ROW(
+        outbound_table_streams, "Table name", "Table Id", "Stream Id", "State");
     for (const auto& table_status : xcluster_status.outbound_table_stream_statuses) {
-      HTML_PRINT_TABLE_ROW(table_status.table_id, table_status.stream_id, table_status.state);
+      HTML_PRINT_TABLE_ROW(
+          table_status.full_table_name, table_status.table_id, table_status.stream_id,
+          table_status.state);
     }
     HTML_END_TABLE;
   }
 
-  output << "<br><h3>Inbound ReplicationGroups</h3>\n";
+  output << "<br><h3>Inbound Replication Groups</h3>\n";
 
   uint32 inbound_group_table_id = 0;
   for (const auto& inbound_replication_group : xcluster_status.inbound_replication_group_statuses) {
     auto group_fs = AutoFieldsetScope(
         output, Format("Group: $0", inbound_replication_group.replication_group_id));
 
-    output << "<pre class=\"prettyprint\">"
-           << "state: " << inbound_replication_group.state
+    output << "<pre class=\"prettyprint\">" << "state: " << inbound_replication_group.state
            << "\ndisable_stream: " << BoolToString(inbound_replication_group.disable_stream)
            << "\ntransactional: " << BoolToString(inbound_replication_group.transactional)
            << "\nmaster_addrs: " << inbound_replication_group.master_addrs;
@@ -2949,20 +2950,26 @@ void MasterPathHandlers::HandleXCluster(
            << inbound_replication_group.compatible_auto_flag_config_version;
     output << "</pre>";
 
-    HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(
-        inbound_replication_group, inbound_group_table_id, "Producer Table Id", "Stream Id",
-        "Consumer Table Id", "Producer Tablet Count", "Consumer Tablet Count",
-        "Local tserver optimized", "Producer schema version", "Consumer schema version", "Status");
-    inbound_group_table_id++;
-
-    for (const auto& table_status : inbound_replication_group.table_statuses) {
-      HTML_PRINT_TABLE_ROW(
-          table_status.source_table_id, table_status.stream_id, table_status.target_table_id,
-          table_status.source_tablet_count, table_status.target_tablet_count,
-          BoolToString(table_status.local_tserver_optimized), table_status.source_schema_version,
-          table_status.target_schema_version, table_status.status);
+    for (const auto& [namespace_name, table_statuses] :
+         inbound_replication_group.table_statuses_by_namespace) {
+      auto namespace_fs = AutoFieldsetScope(output, Format("Namespace: $0", namespace_name));
+
+      HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(
+          inbound_replication_group, inbound_group_table_id, "Table name", "Producer Table Id",
+          "Stream Id", "Consumer Table Id", "Producer Tablet Count", "Consumer Tablet Count",
+          "Local tserver optimized", "Producer schema version", "Consumer schema version",
+          "Status");
+      inbound_group_table_id++;
+      for (const auto& table_status : table_statuses) {
+        HTML_PRINT_TABLE_ROW(
+            table_status.full_table_name, table_status.source_table_id, table_status.stream_id,
+            table_status.target_table_id, table_status.source_tablet_count,
+            table_status.target_tablet_count, BoolToString(table_status.local_tserver_optimized),
+            table_status.source_schema_version, table_status.target_schema_version,
+            table_status.status);
+      }
+      HTML_END_TABLE;
     }
-    HTML_END_TABLE;
   }
 
   HTML_ADD_SORT_AND_FILTER_TABLE_SCRIPT;
diff --git a/src/yb/master/xcluster/master_xcluster_util.cc b/src/yb/master/xcluster/master_xcluster_util.cc
index 802435d1b5..fc2c968425 100644
--- a/src/yb/master/xcluster/master_xcluster_util.cc
+++ b/src/yb/master/xcluster/master_xcluster_util.cc
@@ -55,4 +55,13 @@ bool IsTableEligibleForXClusterReplication(const master::TableInfo& table) {
   return true;
 }
 
+std::string GetFullTableName(const TableInfo& table_info) {
+  const auto& schema_name = table_info.pgschema_name();
+  if (schema_name.empty()) {
+    return table_info.name();
+  }
+
+  return Format("$0.$1", schema_name, table_info.name());
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/master_xcluster_util.h b/src/yb/master/xcluster/master_xcluster_util.h
index 28deb2eb1c..5d75a95f46 100644
--- a/src/yb/master/xcluster/master_xcluster_util.h
+++ b/src/yb/master/xcluster/master_xcluster_util.h
@@ -13,10 +13,15 @@
 
 #pragma once
 
+#include <string>
+
 namespace yb::master {
 class TableInfo;
 
 // Should the table be automatically added to xCluster replication?
 bool IsTableEligibleForXClusterReplication(const master::TableInfo& table);
 
+// Get the table name along with the YSQL schema name if this is a YSQL table.
+std::string GetFullTableName(const TableInfo& table_info);
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index 1b970432d7..8d62f3b644 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -920,6 +920,10 @@ Status XClusterSourceManager::PopulateXClusterStatus(
   for (const auto& [table_id, streams] : GetAllStreams()) {
     for (const auto& stream : streams) {
       XClusterOutboundTableStreamStatus table_stream_status;
+      auto table_info_res = catalog_manager_.GetTableById(table_id);
+      if (table_info_res) {
+        table_stream_status.full_table_name = GetFullTableName(*table_info_res.get());
+      }
       table_stream_status.table_id = table_id;
       table_stream_status.stream_id = stream->StreamId();
       table_stream_status.state =
@@ -961,7 +965,6 @@ Status XClusterSourceManager::PopulateXClusterStatus(
 
       for (const auto& [table_id, table_info] : namespace_status.table_infos()) {
         XClusterOutboundReplicationGroupTableStatus table_status;
-        table_status.table_id = table_id;
         if (table_info.has_stream_id()) {
           auto stream_id = VERIFY_RESULT(xrepl::StreamId::FromString(table_info.stream_id()));
           auto stream_status = FindOrNull(stream_status_map, stream_id);
diff --git a/src/yb/master/xcluster/xcluster_status.h b/src/yb/master/xcluster/xcluster_status.h
index 7786892927..1da9df4d1f 100644
--- a/src/yb/master/xcluster/xcluster_status.h
+++ b/src/yb/master/xcluster/xcluster_status.h
@@ -22,6 +22,7 @@ namespace yb {
 namespace master {
 
 struct InboundXClusterReplicationGroupTableStatus {
+  std::string full_table_name;
   TableId source_table_id;
   xrepl::StreamId stream_id = xrepl::StreamId::Nil();
   TableId target_table_id;
@@ -43,11 +44,13 @@ struct XClusterInboundReplicationGroupStatus {
   uint32 validated_remote_auto_flags_config_version = 0;
   uint32 validated_local_auto_flags_config_version = 0;
   std::string db_scoped_info;
-  std::vector<InboundXClusterReplicationGroupTableStatus> table_statuses;
+  std::map<NamespaceName, std::vector<InboundXClusterReplicationGroupTableStatus>>
+      table_statuses_by_namespace;
 };
 
 class XClusterOutboundTableStreamStatus {
  public:
+  std::string full_table_name;
   TableId table_id;
   xrepl::StreamId stream_id = xrepl::StreamId::Nil();
   std::string state;
diff --git a/src/yb/master/xcluster/xcluster_target_manager.cc b/src/yb/master/xcluster/xcluster_target_manager.cc
index 9831c327c9..4c9ad38381 100644
--- a/src/yb/master/xcluster/xcluster_target_manager.cc
+++ b/src/yb/master/xcluster/xcluster_target_manager.cc
@@ -18,6 +18,7 @@
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master.h"
 #include "yb/master/xcluster/add_table_to_xcluster_target_task.h"
+#include "yb/master/xcluster/master_xcluster_util.h"
 #include "yb/master/xcluster/xcluster_replication_group.h"
 #include "yb/master/xcluster/xcluster_safe_time_service.h"
 
@@ -366,36 +367,47 @@ Status XClusterTargetManager::PopulateXClusterStatus(XClusterStatus& xcluster_st
     }
 
     for (const auto& source_table_id : replication_info.tables()) {
-      InboundXClusterReplicationGroupTableStatus table_statuses;
-      table_statuses.source_table_id = source_table_id;
+      NamespaceName namespace_name = "<Unknown>";
+
+      InboundXClusterReplicationGroupTableStatus table_status;
+      table_status.source_table_id = source_table_id;
 
       auto* stream_id_it = FindOrNull(replication_info.table_streams(), source_table_id);
       if (stream_id_it) {
-        table_statuses.stream_id = VERIFY_RESULT(xrepl::StreamId::FromString(*stream_id_it));
-        auto it = FindOrNull(stream_status, table_statuses.stream_id);
-        table_statuses.status = it ? *it : "OK";
+        table_status.stream_id = VERIFY_RESULT(xrepl::StreamId::FromString(*stream_id_it));
+        auto it = FindOrNull(stream_status, table_status.stream_id);
+        table_status.status = it ? *it : "OK";
 
         if (producer_map) {
           auto* stream_info =
-              FindOrNull(producer_map->stream_map(), table_statuses.stream_id.ToString());
+              FindOrNull(producer_map->stream_map(), table_status.stream_id.ToString());
           if (stream_info) {
-            table_statuses.target_table_id = stream_info->consumer_table_id();
-            table_statuses.target_tablet_count = stream_info->consumer_producer_tablet_map_size();
-            table_statuses.local_tserver_optimized = stream_info->local_tserver_optimized();
-            table_statuses.source_schema_version =
+            table_status.target_table_id = stream_info->consumer_table_id();
+
+            auto table_info_res = catalog_manager_.GetTableById(table_status.target_table_id);
+            if (table_info_res) {
+              const auto& table_info = table_info_res.get();
+              namespace_name = table_info->namespace_name();
+              table_status.full_table_name = GetFullTableName(*table_info);
+            }
+
+            table_status.target_tablet_count = stream_info->consumer_producer_tablet_map_size();
+            table_status.local_tserver_optimized = stream_info->local_tserver_optimized();
+            table_status.source_schema_version =
                 stream_info->schema_versions().current_producer_schema_version();
-            table_statuses.target_schema_version =
+            table_status.target_schema_version =
                 stream_info->schema_versions().current_consumer_schema_version();
             for (const auto& [_, producer_tablets] : stream_info->consumer_producer_tablet_map()) {
-              table_statuses.source_tablet_count += producer_tablets.tablets_size();
+              table_status.source_tablet_count += producer_tablets.tablets_size();
             }
           }
         }
       } else {
-        table_statuses.status = "Not Ready";
+        table_status.status = "Not Ready";
       }
 
-      replication_group_status.table_statuses.push_back(std::move(table_statuses));
+      replication_group_status.table_statuses_by_namespace[namespace_name].push_back(
+          std::move(table_status));
     }
 
     xcluster_status.inbound_replication_group_statuses.push_back(
