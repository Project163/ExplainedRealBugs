diff --git a/src/postgres/src/tools/pgindent/yb_typedefs.list b/src/postgres/src/tools/pgindent/yb_typedefs.list
index b8983a51d0..be13834cd4 100644
--- a/src/postgres/src/tools/pgindent/yb_typedefs.list
+++ b/src/postgres/src/tools/pgindent/yb_typedefs.list
@@ -58,7 +58,6 @@ YbCatalogVersionType
 YbChangedSessionParametersList
 YbChildScan
 YbChildScanData
-YbClusterReplicationRole
 YbConcurrencyContext
 YbCounters
 YbCreateProfileStmt
@@ -205,6 +204,7 @@ YbUpdateEntity
 YbUpdateRelationCacheState
 YbValidateOkeysState
 YbVirtualWalRecord
+YbXClusterReplicationRole
 YbYsqlConnMgrShmemHeader
 YbcAdvisoryLockId
 YbcAdvisoryLockMode
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/Makefile b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/Makefile
index 3d333495a2..1b8489726c 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/Makefile
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/Makefile
@@ -4,6 +4,7 @@ PGFILEDESC = "yb_xcluster_ddl_replication - YugaByte xCluster DDL replication"
 
 EXTENSION = yb_xcluster_ddl_replication
 DATA = yb_xcluster_ddl_replication--1.0.sql
+SHLIB_LINK += -L$(YB_BUILD_ROOT)/lib -lyb_pggate
 
 MODULE_big = yb_xcluster_ddl_replication
 OBJS = \
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/colocated_setup.out b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/colocated_setup.out
index d28bbb92b0..b712fb360e 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/colocated_setup.out
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/colocated_setup.out
@@ -3,11 +3,19 @@ CREATE DATABASE colocation_test colocation = true;
 \i sql/setup.sql
 -- Initial test setup.
 CREATE EXTENSION yb_xcluster_ddl_replication;
-ALTER DATABASE :DBNAME SET yb_xcluster_ddl_replication.replication_role = SOURCE;
+-- workaround for lack of CREATE ROLE IF NOT EXISTS
+DO $$
+BEGIN
+  IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'testuser') THEN
+    CREATE ROLE testuser LOGIN;
+  END IF;
+END
+$$;
 -- Setup function, to be called at the top of each test file.
 CREATE PROCEDURE TEST_reset()
   LANGUAGE SQL AS
 $$
+  CALL yb_xcluster_ddl_replication.TEST_override_replication_role('source');
   DELETE FROM yb_xcluster_ddl_replication.ddl_queue;
   DELETE FROM yb_xcluster_ddl_replication.replicated_ddls;
 $$;
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/create_colocated_table.out b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/create_colocated_table.out
index bc90604fec..264a9ea829 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/create_colocated_table.out
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/create_colocated_table.out
@@ -1,5 +1,11 @@
 \c colocation_test
 CALL TEST_reset();
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ source
+(1 row)
+
 -- Verify that temporary objects are allowed but not captured.
 CREATE TEMP TABLE temp_foo(i int PRIMARY KEY);
 -- Verify that colocated tables are allowed.
@@ -7,7 +13,7 @@ CREATE TABLE coloc_foo(i int PRIMARY KEY);
 SELECT yb_data FROM yb_xcluster_ddl_replication.ddl_queue ORDER BY ddl_end_time;
                                                                                                                 yb_data                                                                                                                 
 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- {"user": "yugabyte", "query": "CREATE TABLE coloc_foo(i int PRIMARY KEY);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "coloc_foo", "relfile_oid": 16414, "colocation_id": 20001}]}
+ {"user": "yugabyte", "query": "CREATE TABLE coloc_foo(i int PRIMARY KEY);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "coloc_foo", "relfile_oid": 16416, "colocation_id": 20001}]}
 (1 row)
 
 -- Verify that non-colocated table is captured.
@@ -15,8 +21,8 @@ CREATE TABLE non_coloc_foo(i int PRIMARY KEY) WITH (COLOCATION = false);
 SELECT yb_data FROM yb_xcluster_ddl_replication.ddl_queue ORDER BY ddl_end_time;
                                                                                                                      yb_data                                                                                                                      
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- {"user": "yugabyte", "query": "CREATE TABLE coloc_foo(i int PRIMARY KEY);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "coloc_foo", "relfile_oid": 16414, "colocation_id": 20001}]}
- {"user": "yugabyte", "query": "CREATE TABLE non_coloc_foo(i int PRIMARY KEY) WITH (COLOCATION = false);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "non_coloc_foo", "relfile_oid": 16419}]}
+ {"user": "yugabyte", "query": "CREATE TABLE coloc_foo(i int PRIMARY KEY);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "coloc_foo", "relfile_oid": 16416, "colocation_id": 20001}]}
+ {"user": "yugabyte", "query": "CREATE TABLE non_coloc_foo(i int PRIMARY KEY) WITH (COLOCATION = false);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "non_coloc_foo", "relfile_oid": 16421}]}
 (2 rows)
 
 SELECT yb_data FROM yb_xcluster_ddl_replication.replicated_ddls ORDER BY ddl_end_time;
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/create_drop_index.out b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/create_drop_index.out
index d20c4bdd90..10cfd5e9b4 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/create_drop_index.out
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/create_drop_index.out
@@ -1,4 +1,10 @@
 CALL TEST_reset();
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ source
+(1 row)
+
 CREATE SCHEMA create_index;
 SET search_path TO create_index;
 -- Test temp table and index.
@@ -27,11 +33,11 @@ SELECT yb_data FROM yb_xcluster_ddl_replication.ddl_queue ORDER BY ddl_end_time;
                                                                                                                                       yb_data                                                                                                                                      
 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  {"user": "yugabyte", "query": "CREATE SCHEMA create_index;", "schema": "public", "version": 1, "command_tag": "CREATE SCHEMA"}
- {"user": "yugabyte", "query": "CREATE TABLE foo(i int PRIMARY KEY, a int, b text, c int);", "schema": "create_index", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "foo", "relfile_oid": 16460}]}
- {"user": "yugabyte", "query": "CREATE INDEX foo_idx_simple ON foo(a);", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_simple", "relfile_oid": 16465}]}
- {"user": "yugabyte", "query": "CREATE UNIQUE INDEX foo_idx_unique ON foo(b);", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_unique", "relfile_oid": 16466}]}
- {"user": "yugabyte", "query": "CREATE INDEX foo_idx_filtered ON foo(c ASC, a) WHERE a > c;", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_filtered", "relfile_oid": 16467}]}
- {"user": "new_role", "query": "CREATE INDEX foo_idx_include ON foo(lower(b)) INCLUDE (a) SPLIT INTO 2 TABLETS;", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_include", "relfile_oid": 16468}]}
+ {"user": "yugabyte", "query": "CREATE TABLE foo(i int PRIMARY KEY, a int, b text, c int);", "schema": "create_index", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "foo", "relfile_oid": 16462}]}
+ {"user": "yugabyte", "query": "CREATE INDEX foo_idx_simple ON foo(a);", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_simple", "relfile_oid": 16467}]}
+ {"user": "yugabyte", "query": "CREATE UNIQUE INDEX foo_idx_unique ON foo(b);", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_unique", "relfile_oid": 16468}]}
+ {"user": "yugabyte", "query": "CREATE INDEX foo_idx_filtered ON foo(c ASC, a) WHERE a > c;", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_filtered", "relfile_oid": 16469}]}
+ {"user": "new_role", "query": "CREATE INDEX foo_idx_include ON foo(lower(b)) INCLUDE (a) SPLIT INTO 2 TABLETS;", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_include", "relfile_oid": 16470}]}
 (6 rows)
 
 SELECT yb_data FROM yb_xcluster_ddl_replication.replicated_ddls ORDER BY ddl_end_time;
@@ -55,11 +61,11 @@ SELECT yb_data FROM yb_xcluster_ddl_replication.ddl_queue ORDER BY ddl_end_time;
                                                                                                                                       yb_data                                                                                                                                      
 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  {"user": "yugabyte", "query": "CREATE SCHEMA create_index;", "schema": "public", "version": 1, "command_tag": "CREATE SCHEMA"}
- {"user": "yugabyte", "query": "CREATE TABLE foo(i int PRIMARY KEY, a int, b text, c int);", "schema": "create_index", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "foo", "relfile_oid": 16460}]}
- {"user": "yugabyte", "query": "CREATE INDEX foo_idx_simple ON foo(a);", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_simple", "relfile_oid": 16465}]}
- {"user": "yugabyte", "query": "CREATE UNIQUE INDEX foo_idx_unique ON foo(b);", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_unique", "relfile_oid": 16466}]}
- {"user": "yugabyte", "query": "CREATE INDEX foo_idx_filtered ON foo(c ASC, a) WHERE a > c;", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_filtered", "relfile_oid": 16467}]}
- {"user": "new_role", "query": "CREATE INDEX foo_idx_include ON foo(lower(b)) INCLUDE (a) SPLIT INTO 2 TABLETS;", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_include", "relfile_oid": 16468}]}
+ {"user": "yugabyte", "query": "CREATE TABLE foo(i int PRIMARY KEY, a int, b text, c int);", "schema": "create_index", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "foo", "relfile_oid": 16462}]}
+ {"user": "yugabyte", "query": "CREATE INDEX foo_idx_simple ON foo(a);", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_simple", "relfile_oid": 16467}]}
+ {"user": "yugabyte", "query": "CREATE UNIQUE INDEX foo_idx_unique ON foo(b);", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_unique", "relfile_oid": 16468}]}
+ {"user": "yugabyte", "query": "CREATE INDEX foo_idx_filtered ON foo(c ASC, a) WHERE a > c;", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_filtered", "relfile_oid": 16469}]}
+ {"user": "new_role", "query": "CREATE INDEX foo_idx_include ON foo(lower(b)) INCLUDE (a) SPLIT INTO 2 TABLETS;", "schema": "create_index", "version": 1, "command_tag": "CREATE INDEX", "new_rel_map": [{"is_index": true, "rel_name": "foo_idx_include", "relfile_oid": 16470}]}
  {"user": "yugabyte", "query": "DROP INDEX foo_idx_unique;", "schema": "create_index", "version": 1, "command_tag": "DROP INDEX"}
  {"user": "yugabyte", "query": "DROP INDEX foo_idx_filtered;", "schema": "create_index", "version": 1, "command_tag": "DROP INDEX"}
  {"user": "yugabyte", "query": "DROP TABLE foo;", "schema": "create_index", "version": 1, "command_tag": "DROP TABLE"}
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/create_drop_table.out b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/create_drop_table.out
index 6dbdf171a6..577e105876 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/create_drop_table.out
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/create_drop_table.out
@@ -1,4 +1,10 @@
 CALL TEST_reset();
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ source
+(1 row)
+
 -- Verify that temporary objects are not captured.
 CREATE TEMP TABLE temp_foo(i int PRIMARY KEY);
 DROP TABLE temp_foo;
@@ -20,10 +26,10 @@ CREATE TABLE unique_foo(i int PRIMARY KEY, u text UNIQUE);
 SELECT yb_data FROM yb_xcluster_ddl_replication.ddl_queue ORDER BY ddl_end_time;
                                                                                                                                                   yb_data                                                                                                                                                  
 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- {"user": "yugabyte", "query": "CREATE TABLE foo(i int PRIMARY KEY);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "foo", "relfile_oid": 16413}]}
+ {"user": "yugabyte", "query": "CREATE TABLE foo(i int PRIMARY KEY);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "foo", "relfile_oid": 16415}]}
  {"user": "yugabyte", "query": "CREATE TABLE manual_foo(i int PRIMARY KEY);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "manual_replication": true}
- {"user": "yugabyte", "query": "CREATE TABLE extra_foo(i int PRIMARY KEY) WITH (COLOCATION = false) SPLIT INTO 1 TABLETS;", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "extra_foo", "relfile_oid": 16423}]}
- {"user": "yugabyte", "query": "CREATE TABLE unique_foo(i int PRIMARY KEY, u text UNIQUE);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "unique_foo", "relfile_oid": 16428}, {"is_index": true, "rel_name": "unique_foo_u_key", "relfile_oid": 16433}]}
+ {"user": "yugabyte", "query": "CREATE TABLE extra_foo(i int PRIMARY KEY) WITH (COLOCATION = false) SPLIT INTO 1 TABLETS;", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "extra_foo", "relfile_oid": 16425}]}
+ {"user": "yugabyte", "query": "CREATE TABLE unique_foo(i int PRIMARY KEY, u text UNIQUE);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "unique_foo", "relfile_oid": 16430}, {"is_index": true, "rel_name": "unique_foo_u_key", "relfile_oid": 16435}]}
 (4 rows)
 
 SELECT yb_data FROM yb_xcluster_ddl_replication.replicated_ddls ORDER BY ddl_end_time;
@@ -51,12 +57,12 @@ DROP TABLE foo_partitioned_by_col;
 SELECT yb_data FROM yb_xcluster_ddl_replication.ddl_queue ORDER BY ddl_end_time;
                                                                                                                                                   yb_data                                                                                                                                                  
 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
- {"user": "yugabyte", "query": "CREATE TABLE foo(i int PRIMARY KEY);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "foo", "relfile_oid": 16413}]}
+ {"user": "yugabyte", "query": "CREATE TABLE foo(i int PRIMARY KEY);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "foo", "relfile_oid": 16415}]}
  {"user": "yugabyte", "query": "CREATE TABLE manual_foo(i int PRIMARY KEY);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "manual_replication": true}
- {"user": "yugabyte", "query": "CREATE TABLE extra_foo(i int PRIMARY KEY) WITH (COLOCATION = false) SPLIT INTO 1 TABLETS;", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "extra_foo", "relfile_oid": 16423}]}
- {"user": "yugabyte", "query": "CREATE TABLE unique_foo(i int PRIMARY KEY, u text UNIQUE);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "unique_foo", "relfile_oid": 16428}, {"is_index": true, "rel_name": "unique_foo_u_key", "relfile_oid": 16433}]}
- {"user": "yugabyte", "query": "CREATE TABLE foo_partitioned_by_pkey(id int, PRIMARY KEY (id)) PARTITION BY RANGE (id);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "foo_partitioned_by_pkey", "relfile_oid": 16435}]}
- {"user": "yugabyte", "query": "CREATE TABLE foo_partitioned_by_col(id int) PARTITION BY RANGE (id);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "foo_partitioned_by_col", "relfile_oid": 16440}]}
+ {"user": "yugabyte", "query": "CREATE TABLE extra_foo(i int PRIMARY KEY) WITH (COLOCATION = false) SPLIT INTO 1 TABLETS;", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "extra_foo", "relfile_oid": 16425}]}
+ {"user": "yugabyte", "query": "CREATE TABLE unique_foo(i int PRIMARY KEY, u text UNIQUE);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "unique_foo", "relfile_oid": 16430}, {"is_index": true, "rel_name": "unique_foo_u_key", "relfile_oid": 16435}]}
+ {"user": "yugabyte", "query": "CREATE TABLE foo_partitioned_by_pkey(id int, PRIMARY KEY (id)) PARTITION BY RANGE (id);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "foo_partitioned_by_pkey", "relfile_oid": 16437}]}
+ {"user": "yugabyte", "query": "CREATE TABLE foo_partitioned_by_col(id int) PARTITION BY RANGE (id);", "schema": "public", "version": 1, "command_tag": "CREATE TABLE", "new_rel_map": [{"rel_name": "foo_partitioned_by_col", "relfile_oid": 16442}]}
  {"user": "yugabyte", "query": "DROP TABLE foo;", "schema": "public", "version": 1, "command_tag": "DROP TABLE"}
  {"user": "yugabyte", "query": "DROP TABLE manual_foo;", "schema": "public", "version": 1, "command_tag": "DROP TABLE", "manual_replication": true}
  {"user": "yugabyte", "query": "DROP TABLE extra_foo;", "schema": "public", "version": 1, "command_tag": "DROP TABLE"}
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/routines.out b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/routines.out
new file mode 100644
index 0000000000..518e4c9327
--- /dev/null
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/routines.out
@@ -0,0 +1,94 @@
+-- Check connections start in role not_automatic_mode.
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ not_automatic_mode
+(1 row)
+
+-- Check can override with every possible role.
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('unspecified');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ unspecified
+(1 row)
+
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('unavailable');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ERROR:  unable to fetch replication role
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('not_automatic_mode');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ not_automatic_mode
+(1 row)
+
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('automatic_source');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ source
+(1 row)
+
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('automatic_target');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ target
+(1 row)
+
+-- Shortcuts for automatic roles.
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('source');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ source
+(1 row)
+
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('target');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ target
+(1 row)
+
+-- Check for invalid roles.
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('invalid');
+ERROR:  invalid replication role: 'invalid'
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ target
+(1 row)
+
+-- Check we can turn off override.
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('source');
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('no_override');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ not_automatic_mode
+(1 row)
+
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('target');
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ not_automatic_mode
+(1 row)
+
+-- Check override cannot be called if you are not superuser but
+-- get_replication_role can.
+SET SESSION AUTHORIZATION testuser;
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('target');
+ERROR:  permission denied for procedure test_override_replication_role
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+ get_replication_role 
+----------------------
+ not_automatic_mode
+(1 row)
+
+-- Check no select access to tables.
+SELECT * FROM yb_xcluster_ddl_replication.ddl_queue;
+ERROR:  permission denied for table ddl_queue
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/setup.out b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/setup.out
index d82a3e9d19..78a7162610 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/setup.out
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/expected/setup.out
@@ -1,10 +1,18 @@
 -- Initial test setup.
 CREATE EXTENSION yb_xcluster_ddl_replication;
-ALTER DATABASE :DBNAME SET yb_xcluster_ddl_replication.replication_role = SOURCE;
+-- workaround for lack of CREATE ROLE IF NOT EXISTS
+DO $$
+BEGIN
+  IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'testuser') THEN
+    CREATE ROLE testuser LOGIN;
+  END IF;
+END
+$$;
 -- Setup function, to be called at the top of each test file.
 CREATE PROCEDURE TEST_reset()
   LANGUAGE SQL AS
 $$
+  CALL yb_xcluster_ddl_replication.TEST_override_replication_role('source');
   DELETE FROM yb_xcluster_ddl_replication.ddl_queue;
   DELETE FROM yb_xcluster_ddl_replication.replicated_ddls;
 $$;
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/extension_util.c b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/extension_util.c
index 4281a791b2..044d1e8671 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/extension_util.c
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/extension_util.c
@@ -53,12 +53,12 @@ GetInt64FromVariable(const char *var, const char *var_name)
 	return ret;
 }
 
-static Oid	CachedExtensionOwnerOid = InvalidOid;	/* Cached for a pg connection. */
+static Oid	cached_extension_owner_oid = InvalidOid;	/* Cached for a pg connection. */
 Oid
 XClusterExtensionOwner(void)
 {
-	if (CachedExtensionOwnerOid > InvalidOid)
-		return CachedExtensionOwnerOid;
+	if (cached_extension_owner_oid > InvalidOid)
+		return cached_extension_owner_oid;
 
 	Relation	extensionRelation = table_open(ExtensionRelationId,
 											   AccessShareLock);
@@ -88,7 +88,7 @@ XClusterExtensionOwner(void)
 	table_close(extensionRelation, AccessShareLock);
 
 	/* Cache this value for future calls. */
-	CachedExtensionOwnerOid = extensionOwner;
+	cached_extension_owner_oid = extensionOwner;
 	return extensionOwner;
 }
 
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/create_colocated_table.sql b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/create_colocated_table.sql
index bb6e5998b0..d5d46a762f 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/create_colocated_table.sql
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/create_colocated_table.sql
@@ -1,5 +1,6 @@
 \c colocation_test
 CALL TEST_reset();
+SELECT yb_xcluster_ddl_replication.get_replication_role();
 
 -- Verify that temporary objects are allowed but not captured.
 CREATE TEMP TABLE temp_foo(i int PRIMARY KEY);
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/create_drop_index.sql b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/create_drop_index.sql
index 13713d0912..a72e389190 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/create_drop_index.sql
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/create_drop_index.sql
@@ -1,4 +1,5 @@
 CALL TEST_reset();
+SELECT yb_xcluster_ddl_replication.get_replication_role();
 
 CREATE SCHEMA create_index;
 SET search_path TO create_index;
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/create_drop_table.sql b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/create_drop_table.sql
index ddee67a851..e36fc13188 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/create_drop_table.sql
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/create_drop_table.sql
@@ -1,4 +1,5 @@
 CALL TEST_reset();
+SELECT yb_xcluster_ddl_replication.get_replication_role();
 
 -- Verify that temporary objects are not captured.
 CREATE TEMP TABLE temp_foo(i int PRIMARY KEY);
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/routines.sql b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/routines.sql
new file mode 100644
index 0000000000..fbd86a3470
--- /dev/null
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/routines.sql
@@ -0,0 +1,53 @@
+-- Check connections start in role not_automatic_mode.
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+
+
+-- Check can override with every possible role.
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('unspecified');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('unavailable');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('not_automatic_mode');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('automatic_source');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('automatic_target');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+
+-- Shortcuts for automatic roles.
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('source');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('target');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+
+
+-- Check for invalid roles.
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('invalid');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+
+
+
+-- Check we can turn off override.
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('source');
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('no_override');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('target');
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+
+
+-- Check override cannot be called if you are not superuser but
+-- get_replication_role can.
+SET SESSION AUTHORIZATION testuser;
+CALL yb_xcluster_ddl_replication.TEST_override_replication_role('target');
+SELECT yb_xcluster_ddl_replication.get_replication_role();
+
+
+-- Check no select access to tables.
+SELECT * FROM yb_xcluster_ddl_replication.ddl_queue;
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/setup.sql b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/setup.sql
index 398eb97d4a..5f6b03aa15 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/setup.sql
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/sql/setup.sql
@@ -1,11 +1,20 @@
 -- Initial test setup.
 CREATE EXTENSION yb_xcluster_ddl_replication;
-ALTER DATABASE :DBNAME SET yb_xcluster_ddl_replication.replication_role = SOURCE;
+
+-- workaround for lack of CREATE ROLE IF NOT EXISTS
+DO $$
+BEGIN
+  IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'testuser') THEN
+    CREATE ROLE testuser LOGIN;
+  END IF;
+END
+$$;
 
 -- Setup function, to be called at the top of each test file.
 CREATE PROCEDURE TEST_reset()
   LANGUAGE SQL AS
 $$
+  CALL yb_xcluster_ddl_replication.TEST_override_replication_role('source');
   DELETE FROM yb_xcluster_ddl_replication.ddl_queue;
   DELETE FROM yb_xcluster_ddl_replication.replicated_ddls;
 $$;
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_schedule b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_schedule
index 33b6e948b3..ea1d3136ed 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_schedule
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_schedule
@@ -1,4 +1,7 @@
 test: setup
+
+test: routines
+
 test: create_drop_table
 test: create_drop_index
 
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_xcluster_ddl_replication--1.0.sql b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_xcluster_ddl_replication--1.0.sql
index f4404cd957..7e7e31d514 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_xcluster_ddl_replication--1.0.sql
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_xcluster_ddl_replication--1.0.sql
@@ -16,6 +16,18 @@ CREATE TABLE yb_xcluster_ddl_replication.replicated_ddls(
   yb_data jsonb NOT NULL,
   PRIMARY KEY (ddl_end_time, query_id));
 
+/* ------------------------------------------------------------------------- */
+/* Create routines for user of extension. */
+
+CREATE FUNCTION yb_xcluster_ddl_replication.get_replication_role()
+  RETURNS text
+  LANGUAGE C
+  AS 'MODULE_PATHNAME', 'get_replication_role';
+
+CREATE PROCEDURE yb_xcluster_ddl_replication.TEST_override_replication_role(role text)
+  LANGUAGE C
+  AS 'MODULE_PATHNAME', 'TEST_override_replication_role';
+
 /* ------------------------------------------------------------------------- */
 /* Create event triggers. */
 
@@ -54,3 +66,14 @@ CREATE FUNCTION yb_xcluster_ddl_replication.handle_table_rewrite()
 CREATE EVENT TRIGGER yb_xcluster_ddl_replication_handle_table_rewrite_trigger
   ON table_rewrite
   EXECUTE FUNCTION yb_xcluster_ddl_replication.handle_table_rewrite();
+
+/* ------------------------------------------------------------------------- */
+/* Set allowed access. */
+
+GRANT USAGE ON SCHEMA yb_xcluster_ddl_replication TO PUBLIC;
+-- At this point access for non-super users is allowed only to functions and procedures.
+
+REVOKE EXECUTE ON ALL FUNCTIONS IN SCHEMA yb_xcluster_ddl_replication FROM PUBLIC;
+REVOKE EXECUTE ON ALL PROCEDURES IN SCHEMA yb_xcluster_ddl_replication FROM PUBLIC;
+
+GRANT EXECUTE ON FUNCTION yb_xcluster_ddl_replication.get_replication_role() TO PUBLIC;
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_xcluster_ddl_replication.c b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_xcluster_ddl_replication.c
index 861e403ca1..e4dabd02ca 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_xcluster_ddl_replication.c
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_xcluster_ddl_replication.c
@@ -18,45 +18,62 @@
 
 #include "postgres.h"
 
-#include "access/xact.h"
 #include "catalog/pg_type_d.h"
 #include "commands/event_trigger.h"
 #include "executor/spi.h"
 #include "extension_util.h"
 #include "json_util.h"
 #include "nodes/pg_list.h"
-#include "pg_yb_utils.h"
 #include "source_ddl_end_handler.h"
+#include "utils/builtins.h"
 #include "utils/fmgrprotos.h"
 
 PG_MODULE_MAGIC;
 
-/* Extension variables. */
-typedef enum YbClusterReplicationRole
+
+/*
+ * Extension variables.
+ */
+
+static bool enable_manual_ddl_replication = false;
+char *ddl_queue_primary_key_ddl_end_time = NULL;
+char *ddl_queue_primary_key_queue_id = NULL;
+
+typedef enum YbXClusterReplicationRole
 {
-	REPLICATION_ROLE_DISABLED,
-	REPLICATION_ROLE_SOURCE,
-	REPLICATION_ROLE_TARGET,
-	REPLICATION_ROLE_BIDIRECTIONAL,
-} YbClusterReplicationRole;
-
-static const struct config_enum_entry replication_roles[] = {
-	{"DISABLED", REPLICATION_ROLE_DISABLED, false},
-	{"SOURCE", REPLICATION_ROLE_SOURCE, false},
-	{"TARGET", REPLICATION_ROLE_TARGET, false},
-	{"BIDIRECTIONAL", REPLICATION_ROLE_BIDIRECTIONAL, /* hidden */ true},
-	{NULL, 0, false},
-};
-
-static int	ReplicationRole = REPLICATION_ROLE_DISABLED;
-static bool EnableManualDDLReplication = false;
-char	   *DDLQueuePrimaryKeyDDLEndTime = NULL;
-char	   *DDLQueuePrimaryKeyQueryId = NULL;
-
-/* Util functions. */
+	/*
+	 * Taken from XClusterNamespaceInfoPB.XClusterRole in
+	 * yb/common/common_types.proto.
+	 */
+	UNSPECIFIED = 0,
+	UNAVAILABLE = 1,
+	NOT_AUTOMATIC_MODE = 2,
+	AUTOMATIC_SOURCE = 3,
+	AUTOMATIC_TARGET = 4,
+} YbXClusterReplicationRole;
+
+/*
+ * Call FetchReplicationRole() at the start of every DDL to fill this variable
+ * in before using it.
+ */
+static int replication_role = UNAVAILABLE;
+static bool role_override_present = false;
+/*
+ * If role_override_present, then this overrides the value of replication_role
+ * fetched from the TServer.
+ */
+static int replication_role_override = UNSPECIFIED;
+
+/*
+ * Util functions.
+ */
+
 static bool IsInIgnoreList(EventTriggerData *trig_data);
 
-/* Per DDL Variables. */
+
+/*
+ * Per DDL Variables.
+ */
 
 /*
  * This is updated as the DDL triggers run, ending up with the decision of
@@ -66,6 +83,7 @@ static bool IsInIgnoreList(EventTriggerData *trig_data);
  */
 static bool yb_should_replicate_ddl = false;
 
+
 /*
  * _PG_init gets called when the extension is loaded.
  */
@@ -75,23 +93,12 @@ _PG_init(void)
 	if (IsBinaryUpgrade)
 		return;
 
-	DefineCustomEnumVariable("yb_xcluster_ddl_replication.replication_role",
-							 gettext_noop("xCluster Replication role per database. "
-										  "NOTE: Manually changing this can lead to replication errors."),
-							 NULL,
-							 &ReplicationRole,
-							 REPLICATION_ROLE_DISABLED,
-							 replication_roles,
-							 PGC_SUSET,
-							 0,
-							 NULL, NULL, NULL);
-
 	DefineCustomBoolVariable("yb_xcluster_ddl_replication.enable_manual_ddl_replication",
 							 gettext_noop("Temporarily disable automatic xCluster DDL replication - DDLs will have "
 										  "to be manually executed on the target."),
 							 gettext_noop("DDL strings will still be captured and replicated, but will be marked "
 										  "with a 'manual_replication' flag."),
-							 &EnableManualDDLReplication,
+							 &enable_manual_ddl_replication,
 							 false,
 							 PGC_USERSET,
 							 0,
@@ -100,7 +107,7 @@ _PG_init(void)
 	DefineCustomStringVariable("yb_xcluster_ddl_replication.ddl_queue_primary_key_ddl_end_time",
 							   gettext_noop("Internal use only: Used by HandleTargetDDLEnd function."),
 							   NULL,
-							   &DDLQueuePrimaryKeyDDLEndTime,
+							   &ddl_queue_primary_key_ddl_end_time,
 							   "",
 							   PGC_SUSET,
 							   0,
@@ -109,25 +116,111 @@ _PG_init(void)
 	DefineCustomStringVariable("yb_xcluster_ddl_replication.ddl_queue_primary_key_query_id",
 							   gettext_noop("Internal use only: Used by HandleTargetDDLEnd function."),
 							   NULL,
-							   &DDLQueuePrimaryKeyQueryId,
+							   &ddl_queue_primary_key_queue_id,
 							   "",
 							   PGC_SUSET,
 							   0,
 							   NULL, NULL, NULL);
 }
 
+void
+FetchReplicationRole()
+{
+	if (role_override_present)
+		replication_role = replication_role_override;
+	else
+		replication_role = YBCGetXClusterRole(MyDatabaseId);
+
+	if (replication_role == UNAVAILABLE)
+	{
+		ereport(ERROR,
+				(errcode(ERRCODE_YB_ERROR),
+				 errmsg("unable to fetch replication role")));
+	}
+}
+
+bool
+IsDisabled()
+{
+	return (replication_role != AUTOMATIC_SOURCE &&
+			replication_role != AUTOMATIC_TARGET);
+}
+
 bool
 IsReplicationSource()
 {
-	return (ReplicationRole == REPLICATION_ROLE_SOURCE ||
-			ReplicationRole == REPLICATION_ROLE_BIDIRECTIONAL);
+	return (replication_role == AUTOMATIC_SOURCE);
 }
 
 bool
 IsReplicationTarget()
 {
-	return (ReplicationRole == REPLICATION_ROLE_TARGET ||
-			ReplicationRole == REPLICATION_ROLE_BIDIRECTIONAL);
+	return (replication_role == AUTOMATIC_TARGET);
+}
+
+PG_FUNCTION_INFO_V1(get_replication_role);
+Datum
+get_replication_role(PG_FUNCTION_ARGS)
+{
+	FetchReplicationRole();
+	char *role_name;
+	switch (replication_role)
+	{
+		case UNSPECIFIED:
+			role_name = "unspecified";
+			break;
+		case UNAVAILABLE:
+			role_name = "unavailable";
+			break;
+		case NOT_AUTOMATIC_MODE:
+			role_name = "not_automatic_mode";
+			break;
+		case AUTOMATIC_SOURCE:
+			role_name = "source";
+			break;
+		case AUTOMATIC_TARGET:
+			role_name = "target";
+			break;
+		default:
+			role_name = "unknown";
+			break;
+	}
+	PG_RETURN_TEXT_P(cstring_to_text(role_name));
+}
+
+PG_FUNCTION_INFO_V1(TEST_override_replication_role);
+Datum
+TEST_override_replication_role(PG_FUNCTION_ARGS)
+{
+	text       *role_text = PG_GETARG_TEXT_PP(0);
+	char       *role_name = text_to_cstring(role_text);
+
+	if (pg_strcasecmp(role_name, "no_override") == 0 ||
+		pg_strcasecmp(role_name, "") == 0)
+	{
+		role_override_present = false;
+		PG_RETURN_VOID();
+	}
+
+	if (pg_strcasecmp(role_name, "unspecified") == 0)
+		replication_role_override = UNSPECIFIED;
+	else if (pg_strcasecmp(role_name, "unavailable") == 0)
+		replication_role_override = UNAVAILABLE;
+	else if (pg_strcasecmp(role_name, "not_automatic_mode") == 0)
+		replication_role_override = NOT_AUTOMATIC_MODE;
+	else if (pg_strcasecmp(role_name, "source") == 0 ||
+			 pg_strcasecmp(role_name, "automatic_source") == 0)
+		replication_role_override = AUTOMATIC_SOURCE;
+	else if (pg_strcasecmp(role_name, "target") == 0 ||
+			 pg_strcasecmp(role_name, "automatic_target") == 0)
+		replication_role_override = AUTOMATIC_TARGET;
+	else
+		ereport(ERROR,
+				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
+				 errmsg("invalid replication role: '%s'", role_name)));
+
+	role_override_present = true;
+	PG_RETURN_VOID();
 }
 
 void
@@ -319,7 +412,7 @@ HandleSourceDDLEnd(EventTriggerData *trig_data)
 	if (cur_schema)
 		(void) AddStringJsonEntry(state, "schema", cur_schema);
 
-	if (EnableManualDDLReplication)
+	if (enable_manual_ddl_replication)
 	{
 		(void) AddBoolJsonEntry(state, "manual_replication", true);
 	}
@@ -352,19 +445,16 @@ HandleSourceDDLEnd(EventTriggerData *trig_data)
 
 		InsertIntoTable(DDL_QUEUE_TABLE_NAME, epoch_time, query_id, jsonb);
 
-		if (ReplicationRole == REPLICATION_ROLE_SOURCE)
-		{
-			/*
-			 * Also insert into the replicated_ddls table to handle switchovers.
-			 *
-			 * During switchover, we have a middle state with A target <-> B target.
-			 * In this state, A is polling from B, and so ddl_queue on A could try to
-			 * process its ddl_queue entries. But since we write to replicated_ddls on
-			 * A, the ddl_queue handler will see that all DDLs in the queue have been
-			 * processed.
-			 */
-			InsertIntoReplicatedDDLs(epoch_time, query_id);
-		}
+		/*
+		 * Also insert into the replicated_ddls table to handle switchovers.
+		 *
+		 * During switchover, we have a middle state with A target <-> B
+		 * target.  In this state, A is polling from B, and so ddl_queue on A
+		 * could try to process its ddl_queue entries. But since we write to
+		 * replicated_ddls on A, the ddl_queue handler will see that all DDLs
+		 * in the queue have been processed.
+		 */
+		InsertIntoReplicatedDDLs(epoch_time, query_id);
 	}
 
 	CLOSE_MEM_CONTEXT_AND_SPI;
@@ -374,15 +464,15 @@ void
 HandleTargetDDLEnd(EventTriggerData *trig_data)
 {
 	/* Manual DDLs are not captured at all on the target. */
-	if (EnableManualDDLReplication)
+	if (enable_manual_ddl_replication)
 		return;
 	/*
 	 * We expect ddl_queue_primary_key_* variables to have been set earlier in
 	 * the transaction by the ddl_queue handler.
 	 */
-	int64		pkey_ddl_end_time = GetInt64FromVariable(DDLQueuePrimaryKeyDDLEndTime,
+	int64		pkey_ddl_end_time = GetInt64FromVariable(ddl_queue_primary_key_ddl_end_time,
 															 "ddl_queue_primary_key_ddl_end_time");
-	int64		pkey_query_id = GetInt64FromVariable(DDLQueuePrimaryKeyQueryId,
+	int64		pkey_query_id = GetInt64FromVariable(ddl_queue_primary_key_queue_id,
 													 "ddl_queue_primary_key_query_id");
 
 	InsertIntoReplicatedDDLs(pkey_ddl_end_time, pkey_query_id);
@@ -391,7 +481,7 @@ HandleTargetDDLEnd(EventTriggerData *trig_data)
 void
 HandleSourceSQLDrop(EventTriggerData *trig_data)
 {
-	if (EnableManualDDLReplication)
+	if (enable_manual_ddl_replication)
 		return;
 
 	/* Create memory context for handling query execution. */
@@ -410,7 +500,7 @@ HandleSourceSQLDrop(EventTriggerData *trig_data)
 void
 HandleSourceTableRewrite(EventTriggerData *trig_data)
 {
-	if (EnableManualDDLReplication)
+	if (enable_manual_ddl_replication)
 		return;
 
 	/* Create memory context for handling query execution. */
@@ -431,7 +521,7 @@ HandleSourceDDLStart(EventTriggerData *trig_data)
 {
 	/* By default we don't replicate. */
 	yb_should_replicate_ddl = false;
-	if (EnableManualDDLReplication)
+	if (enable_manual_ddl_replication)
 	{
 		/*
 		 * Always replicate manual DDLs regardless of what they are.
@@ -455,7 +545,8 @@ handle_ddl_start(PG_FUNCTION_ARGS)
 	if (!CALLED_AS_EVENT_TRIGGER(fcinfo))	/* internal error */
 		elog(ERROR, "not fired by event trigger manager");
 
-	if (ReplicationRole == REPLICATION_ROLE_DISABLED)
+	FetchReplicationRole();
+	if (IsDisabled())
 		PG_RETURN_NULL();
 
 	EventTriggerData *trig_data = (EventTriggerData *) fcinfo->context;
@@ -478,7 +569,7 @@ handle_ddl_end(PG_FUNCTION_ARGS)
 	if (!CALLED_AS_EVENT_TRIGGER(fcinfo))	/* internal error */
 		elog(ERROR, "not fired by event trigger manager");
 
-	if (ReplicationRole == REPLICATION_ROLE_DISABLED)
+	if (IsDisabled())
 		PG_RETURN_NULL();
 
 	EventTriggerData *trig_data = (EventTriggerData *) fcinfo->context;
@@ -512,7 +603,7 @@ handle_sql_drop(PG_FUNCTION_ARGS)
 	if (!CALLED_AS_EVENT_TRIGGER(fcinfo))	/* internal error */
 		elog(ERROR, "not fired by event trigger manager");
 
-	if (ReplicationRole == REPLICATION_ROLE_DISABLED)
+	if (IsDisabled())
 		PG_RETURN_NULL();
 
 	EventTriggerData *trig_data = (EventTriggerData *) fcinfo->context;
@@ -537,7 +628,7 @@ handle_table_rewrite(PG_FUNCTION_ARGS)
 	if (!CALLED_AS_EVENT_TRIGGER(fcinfo))	/* internal error */
 		elog(ERROR, "not fired by event trigger manager");
 
-	if (ReplicationRole == REPLICATION_ROLE_DISABLED)
+	if (IsDisabled())
 		PG_RETURN_NULL();
 
 	EventTriggerData *trig_data = (EventTriggerData *) fcinfo->context;
diff --git a/src/yb/ash/wait_state.h b/src/yb/ash/wait_state.h
index 96ade91ab9..404920d8dd 100644
--- a/src/yb/ash/wait_state.h
+++ b/src/yb/ash/wait_state.h
@@ -22,9 +22,6 @@
 #include "yb/common/entity_ids_types.h"
 #include "yb/common/wire_protocol.h"
 
-#include "yb/gutil/casts.h"
-
-#include "yb/util/atomic.h"
 #include "yb/util/enums.h"
 #include "yb/util/locks.h"
 #include "yb/util/net/net_util.h"
@@ -270,6 +267,7 @@ YB_DEFINE_TYPED_ENUM(PggateRPC, uint16_t,
   (kImportTxnSnapshot)
   (kClearExportedTxnSnapshots)
   (kPollVectorIndexReady)
+  (kGetXClusterRole)
 );
 
 struct WaitStatesDescription {
@@ -486,7 +484,7 @@ class WaitStateInfo {
   }
 
   virtual void VTrace(int level, GStringPiece data) {
-    VTraceTo(nullptr, level, data);
+    VTraceTo(/*trace=*/nullptr, level, data);
   }
 
   virtual std::string DumpTraceToString() {
diff --git a/src/yb/common/common_types.proto b/src/yb/common/common_types.proto
index ba1dcb8d6f..3d01213245 100644
--- a/src/yb/common/common_types.proto
+++ b/src/yb/common/common_types.proto
@@ -215,3 +215,17 @@ enum XClusterReplicationType {
   XCLUSTER_YSQL_TRANSACTIONAL = 1; // YSQL, Unidirectional only. Table level.
   XCLUSTER_YSQL_DB_SCOPED = 2;     // YSQL, Transactional and Unidirectional only. DB level.
 }
+
+// Information for a namespace currently/previously under automatic mode xCluster replication.
+message XClusterNamespaceInfoPB {
+  enum XClusterRole {
+    UNSPECIFIED = 0;         // This should never occur; not stored.
+    UNAVAILABLE = 1;         // Used to denote that we cannot determine the role; not stored.
+
+    NOT_AUTOMATIC_MODE = 2;  // No automatic mode replication is occurring for this namespace.
+
+    AUTOMATIC_SOURCE = 3;
+    AUTOMATIC_TARGET = 4;
+  }
+  optional XClusterRole role = 1 [default = NOT_AUTOMATIC_MODE];
+}
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
index 9415e41320..c30a02f874 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
@@ -12,15 +12,26 @@
 //
 
 #include "yb/cdc/xcluster_types.h"
+
 #include "yb/client/schema.h"
 #include "yb/client/table.h"
 #include "yb/client/xcluster_client.h"
 #include "yb/client/yb_table_name.h"
+
 #include "yb/common/colocated_util.h"
+#include "yb/common/common_types.pb.h"
+
 #include "yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h"
 #include "yb/integration-tests/xcluster/xcluster_test_base.h"
+
 #include "yb/master/catalog_manager.h"
 #include "yb/master/mini_master.h"
+#include "yb/master/xcluster/xcluster_manager.h"
+
+#include "yb/tserver/mini_tablet_server.h"
+#include "yb/tserver/tablet_server.h"
+#include "yb/tserver/tserver_xcluster_context_if.h"
+
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/debug.h"
 #include "yb/util/logging_test_util.h"
@@ -143,6 +154,62 @@ TEST_F(XClusterDDLReplicationTest, YB_DISABLE_TEST_ON_MACOS(SurviveRestarts)) {
   ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
 }
 
+TEST_F(XClusterDDLReplicationTest, ExtensionRoleUpdating) {
+  ASSERT_OK(SetUpClusters());
+  auto& catalog_manager =
+      ASSERT_RESULT(producer_cluster_.mini_cluster_->GetLeaderMiniMaster())->catalog_manager_impl();
+  auto* xcluster_manager = catalog_manager.GetXClusterManagerImpl();
+  const auto namespace_id = ASSERT_RESULT(GetNamespaceId(producer_client(), namespace_name));
+  auto* tserver = producer_cluster_.mini_cluster_->mini_tablet_server(0);
+  auto& xcluster_context = tserver->server()->GetXClusterContext();
+  auto conn = ASSERT_RESULT(producer_cluster_.ConnectToDB(namespace_name));
+
+  // We expect role NOT_AUTOMATIC_MODE here since no replication is set up yet.
+  EXPECT_EQ(
+      xcluster_context.GetXClusterRole(namespace_id),
+      XClusterNamespaceInfoPB_XClusterRole_NOT_AUTOMATIC_MODE);
+
+  ASSERT_OK(CheckpointReplicationGroup(kReplicationGroupId, /*require_no_bootstrap_needed=*/false));
+  // Bootstrap here would have no effect because the database is empty so we skip it for the test.
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+
+  // The producer should have role AUTOMATIC_SOURCE after automatic mode replication is set up.
+  // We should see this both at the TServer's xcluster_context and on the existing Postgres backend.
+  {
+    EXPECT_EQ(
+        xcluster_context.GetXClusterRole(namespace_id),
+        XClusterNamespaceInfoPB_XClusterRole_AUTOMATIC_SOURCE);
+    std::string current_role = ASSERT_RESULT(
+        conn.FetchRowAsString("SELECT yb_xcluster_ddl_replication.get_replication_role()"));
+    EXPECT_EQ(current_role, "source");
+  }
+
+  // Manually change the role to AUTOMATIC_TARGET and verify the change is seen.
+  ASSERT_OK(xcluster_manager->SetXClusterRole(
+      catalog_manager.GetLeaderEpochInternal(), namespace_id,
+      XClusterNamespaceInfoPB_XClusterRole_AUTOMATIC_TARGET));
+  // TODO(mlillibridge): replace with a call to wait for heartbeats once that call is available.
+  std::this_thread::sleep_for(30s);
+  {
+    EXPECT_EQ(
+        xcluster_context.GetXClusterRole(namespace_id),
+        XClusterNamespaceInfoPB_XClusterRole_AUTOMATIC_TARGET);
+    std::string current_role = ASSERT_RESULT(
+        conn.FetchRowAsString("SELECT yb_xcluster_ddl_replication.get_replication_role()"));
+    EXPECT_EQ(current_role, "target");
+  }
+
+  ASSERT_OK(DeleteOutboundReplicationGroup());
+  // TODO(mlillibridge): modify DeleteOutboundReplicationGroup() with a call to wait for heartbeats
+  // once that call is available.
+  std::this_thread::sleep_for(30s);
+
+  // After replication is dropped, we should be back to role NOT_AUTOMATIC_MODE.
+  EXPECT_EQ(
+      xcluster_context.GetXClusterRole(namespace_id),
+      XClusterNamespaceInfoPB_XClusterRole_NOT_AUTOMATIC_MODE);
+}
+
 TEST_F(XClusterDDLReplicationTest, TestExtensionDeletionWithMultipleReplicationGroups) {
   const xcluster::ReplicationGroupId kReplicationGroupId2("ReplicationGroup2");
   ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
@@ -319,6 +386,30 @@ TEST_F(XClusterDDLReplicationTest, CreateTable) {
   InsertRowsIntoProducerTableAndVerifyConsumer(producer_table_name_new_user);
 }
 
+TEST_F(XClusterDDLReplicationTest, CreateTableInExistingConnection) {
+  ASSERT_OK(SetUpClusters());
+  {
+    auto conn = ASSERT_RESULT(producer_cluster_.ConnectToDB(namespace_name));
+
+    ASSERT_OK(
+        CheckpointReplicationGroup(kReplicationGroupId, /*require_no_bootstrap_needed=*/false));
+    // Bootstrap here would have no effect because the database is empty so we skip it for the test.
+    ASSERT_OK(CreateReplicationFromCheckpoint());
+
+    // Here we create a table using a connection open before replication got set up.
+    ASSERT_OK(conn.Execute("CREATE TABLE test_table_1 (key int PRIMARY KEY);"));
+    ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
+  }
+
+  {
+    auto conn = ASSERT_RESULT(consumer_cluster_.ConnectToDB(namespace_name));
+    std::string row_count =
+        ASSERT_RESULT(conn.FetchRowAsString("SELECT count(*) FROM test_table_1;"));
+    // Check that the CREATE TABLE DDL got replicated.
+    ASSERT_EQ(row_count, "0");
+  }
+}
+
 TEST_F(XClusterDDLReplicationTest, CreateTableWithEnum) {
   ASSERT_OK(SetUpClusters());
   ASSERT_OK(CheckpointReplicationGroup(kReplicationGroupId, /*require_no_bootstrap_needed=*/false));
@@ -1248,6 +1339,9 @@ TEST_F(XClusterDDLReplicationSwitchoverTest, SwitchoverWithPendingDDL) {
         "Could not find matching table");
     // Note that A will get marked as a target at this point.
     // TODO(#26160): reset A back to a source on replication failure.
+    // TODO(mlillibridge): Add a call to wait for heartbeats to create replication from checkpoint
+    // code once that call is available.
+    std::this_thread::sleep_for(30s);
     ASSERT_OK(ValidateReplicationRole(*cluster_A_, "target"));
     ASSERT_OK(ValidateReplicationRole(*cluster_B_, "target"));
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
index 531f635f24..bab5e664ca 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
@@ -17,7 +17,6 @@
 #include "yb/client/table.h"
 #include "yb/client/xcluster_client.h"
 #include "yb/client/yb_table_name.h"
-#include "yb/common/common_types.pb.h"
 #include "yb/integration-tests/xcluster/xcluster_test_base.h"
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
 #include "yb/master/mini_master.h"
@@ -234,7 +233,7 @@ Result<std::string> XClusterDDLReplicationTestBase::GetReplicationRole(
     Cluster& cluster, const NamespaceName& database) {
   const auto& db_name = database.empty() ? namespace_name : database;
   auto conn = VERIFY_RESULT(cluster.ConnectToDB(db_name));
-  return conn.FetchRowAsString("SHOW yb_xcluster_ddl_replication.replication_role");
+  return conn.FetchRowAsString("SELECT yb_xcluster_ddl_replication.get_replication_role();");
 }
 
 Status XClusterDDLReplicationTestBase::ValidateReplicationRole(
diff --git a/src/yb/master/catalog_entity_info.cc b/src/yb/master/catalog_entity_info.cc
index abe50f6935..971abec0bc 100644
--- a/src/yb/master/catalog_entity_info.cc
+++ b/src/yb/master/catalog_entity_info.cc
@@ -47,22 +47,18 @@
 
 #include "yb/dockv/partition.h"
 
-#include "yb/gutil/map-util.h"
-
 #include "yb/master/master_client.pb.h"
 #include "yb/master/master_defaults.h"
 #include "yb/master/master_error.h"
-#include "yb/master/master_util.h"
 #include "yb/master/ts_descriptor.h"
-#include "yb/master/xcluster_rpc_tasks.h"
 #include "yb/master/xcluster/master_xcluster_util.h"
+#include "yb/master/xcluster_rpc_tasks.h"
 
 #include "yb/util/atomic.h"
+#include "yb/util/flags/auto_flags.h"
 #include "yb/util/format.h"
 #include "yb/util/oid_generator.h"
 #include "yb/util/status_format.h"
-#include "yb/util/string_util.h"
-#include "yb/util/flags/auto_flags.h"
 
 using std::string;
 
@@ -620,7 +616,8 @@ Result<TabletWithSplitPartitions> TableInfo::FindSplittableHashPartitionForStatu
     dockv::Partition::FromPB(metadata->pb.partition(), &partition);
     auto result = dockv::PartitionSchema::SplitHashPartitionForStatusTablet(partition);
     if (result) {
-      return TabletWithSplitPartitions{tablet, result->first, result->second};
+      return TabletWithSplitPartitions{
+          .tablet = tablet, .left = result->first, .right = result->second};
     }
   }
 
diff --git a/src/yb/master/catalog_entity_info.h b/src/yb/master/catalog_entity_info.h
index c1158d3e1e..91f29ff9ea 100644
--- a/src/yb/master/catalog_entity_info.h
+++ b/src/yb/master/catalog_entity_info.h
@@ -39,23 +39,20 @@
 
 #include "yb/cdc/cdc_types.h"
 #include "yb/cdc/xcluster_types.h"
-#include "yb/master/catalog_entity_base.h"
-#include "yb/master/leader_epoch.h"
-#include "yb/master/master_backup.pb.h"
-#include "yb/qlexpr/index.h"
-#include "yb/dockv/partition.h"
 #include "yb/common/snapshot.h"
 #include "yb/common/transaction.h"
-
 #include "yb/consensus/consensus_types.pb.h"
+#include "yb/dockv/partition.h"
 
+#include "yb/master/catalog_entity_base.h"
+#include "yb/master/catalog_entity_info.pb.h"
+#include "yb/master/leader_epoch.h"
+#include "yb/master/master_backup.pb.h"
 #include "yb/master/master_client.fwd.h"
 #include "yb/master/master_fwd.h"
-#include "yb/master/catalog_entity_info.pb.h"
 #include "yb/master/tasks_tracker.h"
 
-#include "yb/server/monitored_task.h"
-
+#include "yb/qlexpr/index.h"
 #include "yb/tablet/metadata.pb.h"
 
 #include "yb/util/cow_object.h"
@@ -65,8 +62,7 @@
 
 DECLARE_bool(use_parent_table_id_field);
 
-namespace yb {
-namespace master {
+namespace yb::master {
 
 class RetryingRpcTask;
 
@@ -83,8 +79,8 @@ struct ExternalTableSnapshotData {
   SysTablesEntryPB table_entry_pb;
   std::string pg_schema_name;
   size_t num_tablets = 0;
-  typedef std::pair<std::string, std::string> PartitionKeys;
-  typedef std::map<PartitionKeys, TabletId> PartitionToIdMap;
+  using PartitionKeys = std::pair<std::string, std::string>;
+  using PartitionToIdMap = std::map<PartitionKeys, TabletId>;
   std::vector<std::pair<TabletId, PartitionPB>> old_tablets;
   PartitionToIdMap new_tablets_map;
   // Mapping: Old tablet ID -> New tablet ID.
@@ -94,7 +90,7 @@ struct ExternalTableSnapshotData {
   // the clone_op.
   std::optional<int> new_table_schema_version = std::nullopt;
 };
-typedef std::unordered_map<TableId, ExternalTableSnapshotData> ExternalTableSnapshotDataMap;
+using ExternalTableSnapshotDataMap = std::unordered_map<TableId, ExternalTableSnapshotData>;
 
 struct ExternalNamespaceSnapshotData {
   ExternalNamespaceSnapshotData() : db_type(YQL_DATABASE_UNKNOWN), just_created(false) {}
@@ -104,7 +100,7 @@ struct ExternalNamespaceSnapshotData {
   bool just_created;
 };
 // Map: old_namespace_id (key) -> new_namespace_id + db_type + created-flag.
-typedef std::unordered_map<NamespaceId, ExternalNamespaceSnapshotData> NamespaceMap;
+using NamespaceMap = std::unordered_map<NamespaceId, ExternalNamespaceSnapshotData>;
 
 struct ExternalUDTypeSnapshotData {
   ExternalUDTypeSnapshotData() : just_created(false) {}
@@ -1585,5 +1581,4 @@ void SetupTabletInfo(
     const PartitionPB& partition,
     SysTabletsEntryPB::State state);
 
-}  // namespace master
-}  // namespace yb
+} // namespace yb::master
diff --git a/src/yb/master/catalog_entity_info.proto b/src/yb/master/catalog_entity_info.proto
index 6b59cf54c7..b2c5062e50 100644
--- a/src/yb/master/catalog_entity_info.proto
+++ b/src/yb/master/catalog_entity_info.proto
@@ -442,6 +442,8 @@ message SysObjectLockEntryPB {
 message SysXClusterConfigEntryPB {
   optional uint32 version = 1;
   optional xcluster.ProducerRegistryPB xcluster_producer_registry = 2;
+  // Local NamespaceId -> xCluster info for that namespace.
+  map<string, XClusterNamespaceInfoPB> xcluster_info_per_namespace = 3;
 }
 
 // The data part of a SysRowEntry in the sys.catalog table for Redis Config.
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index a620eb6e49..800e33c668 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -101,7 +101,6 @@
 #include "yb/consensus/quorum_util.h"
 
 #include "yb/dockv/doc_key.h"
-#include "yb/dockv/partial_row.h"
 #include "yb/dockv/partition.h"
 
 #include "yb/gutil/bind.h"
@@ -167,11 +166,11 @@
 #include "yb/master/yql_triggers_vtable.h"
 #include "yb/master/yql_types_vtable.h"
 #include "yb/master/yql_views_vtable.h"
+#include "yb/master/ysql/ysql_initdb_major_upgrade_handler.h"
 #include "yb/master/ysql/ysql_manager.h"
 #include "yb/master/ysql_ddl_verification_task.h"
 #include "yb/master/ysql_tablegroup_manager.h"
 #include "yb/master/ysql_tablespace_manager.h"
-#include "yb/master/ysql/ysql_initdb_major_upgrade_handler.h"
 
 #include "yb/rpc/messenger.h"
 #include "yb/rpc/rpc_controller.h"
@@ -201,9 +200,9 @@
 #include "yb/util/random_util.h"
 #include "yb/util/scope_exit.h"
 #include "yb/util/size_literals.h"
+#include "yb/util/status.h"
 #include "yb/util/status_format.h"
 #include "yb/util/status_log.h"
-#include "yb/util/status.h"
 #include "yb/util/stopwatch.h"
 #include "yb/util/string_case.h"
 #include "yb/util/string_util.h"
@@ -827,7 +826,7 @@ GetMoreEligibleSysCatalogLeaders(
   for (const auto& master : masters) {
     auto master_score = get_score(master.registration());
     if (master_score < my_score) {
-      scored_masters.push_back({master, get_score(master.registration())});
+      scored_masters.emplace_back(master, get_score(master.registration()));
     }
   }
 
@@ -4510,15 +4509,14 @@ Status CatalogManager::CreateTableIfNotFound(
   return Status::OK();
 }
 
-void CatalogManager::ScheduleVerifyTablePgLayer(TransactionMetadata txn,
-                                                const TableInfoPtr& table,
-                                                const LeaderEpoch& epoch) {
+void CatalogManager::ScheduleVerifyTablePgLayer(
+    TransactionMetadata txn, const TableInfoPtr& table, const LeaderEpoch& epoch) {
   auto when_done = [this, table, epoch](Result<std::optional<bool>> exists) {
     WARN_NOT_OK(VerifyTablePgLayer(table, exists, epoch), "Failed to verify table");
   };
   TableSchemaVerificationTask::CreateAndStartTask(
       *this, table, txn, std::move(when_done), sys_catalog_, master_->client_future(),
-      *master_->messenger(), epoch, false /* ddl_atomicity_enabled */);
+      *master_->messenger(), epoch, /*ddl_atomicity_enabled=*/false);
 }
 
 Status CatalogManager::VerifyTablePgLayer(
@@ -8248,12 +8246,12 @@ std::vector<TableInfoPtr> CatalogManager::GetTables(
   FATAL_INVALID_ENUM_VALUE(GetTablesMode, mode);
 }
 
-void CatalogManager::GetAllNamespaces(std::vector<scoped_refptr<NamespaceInfo>>* namespaces,
-                                      bool includeOnlyRunningNamespaces) {
+void CatalogManager::GetAllNamespaces(
+    std::vector<scoped_refptr<NamespaceInfo>>* namespaces, bool include_only_running_namespaces) {
   namespaces->clear();
   SharedLock lock(mutex_);
   for (const NamespaceInfoMap::value_type& e : namespace_ids_map_) {
-    if (includeOnlyRunningNamespaces && e.second->state() != SysNamespaceEntryPB::RUNNING) {
+    if (include_only_running_namespaces && e.second->state() != SysNamespaceEntryPB::RUNNING) {
       continue;
     }
     namespaces->push_back(e.second);
@@ -9459,11 +9457,11 @@ Status CatalogManager::DeleteYsqlDBTables(
       // Colocation parent tables should be deleted last, so we store them separately and append to
       // the end of the list later.
       if (table->IsColocationParentTable()) {
-        colocation_parents.push_back({table, std::move(l)});
+        colocation_parents.emplace_back(table, std::move(l));
       } else if (IsTable(l->pb)) {
         tables_and_locks.insert(tables_and_locks.begin(), {table, std::move(l)});
       } else {
-        tables_and_locks.push_back({table, std::move(l)});
+        tables_and_locks.emplace_back(table, std::move(l));
       }
     }
 
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index ad77c037fc..ba43ca72e4 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -134,9 +134,9 @@ class YsqlManager;
 
 using PlacementId = std::string;
 
-typedef std::unordered_map<TabletId, TabletServerId> TabletToTabletServerMap;
+using TabletToTabletServerMap = std::unordered_map<TabletId, TabletServerId>;
 
-typedef std::unordered_map<TableId, std::vector<TabletInfoPtr>> TableToTabletInfos;
+using TableToTabletInfos = std::unordered_map<TableId, std::vector<TabletInfoPtr>>;
 
 YB_DEFINE_ENUM(
     CDCSDKStreamCreationState,
@@ -191,7 +191,7 @@ struct YsqlTableDdlTxnState;
 //
 // Thread-safe.
 class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContext {
-  typedef std::unordered_map<NamespaceName, scoped_refptr<NamespaceInfo> > NamespaceInfoMap;
+  using NamespaceInfoMap = std::unordered_map<NamespaceName, scoped_refptr<NamespaceInfo>>;
 
   class NamespaceNameMapper {
    public:
@@ -1435,8 +1435,8 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
       const std::function<Status(UniverseReplicationInfo&)>& add_historical_schema_fn);
 
   // Wait for replication to drain on CDC streams.
-  typedef std::pair<xrepl::StreamId, TabletId> StreamTabletIdPair;
-  typedef boost::hash<StreamTabletIdPair> StreamTabletIdHash;
+  using StreamTabletIdPair = std::pair<xrepl::StreamId, TabletId>;
+  using StreamTabletIdHash = boost::hash<StreamTabletIdPair>;
   Status WaitForReplicationDrain(
       const WaitForReplicationDrainRequestPB* req,
       WaitForReplicationDrainResponsePB* resp,
@@ -1444,7 +1444,7 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
 
   std::vector<SysUniverseReplicationEntryPB> GetAllXClusterUniverseReplicationInfos();
 
-  typedef std::unordered_map<TableId, std::list<CDCStreamInfoPtr>> TableStreamIdsMap;
+  using TableStreamIdsMap = std::unordered_map<TableId, std::list<CDCStreamInfoPtr>>;
 
   // Find all CDCSDK streams which do not have metadata for the newly added tables.
   Status FindCDCSDKStreamsForAddedTables(TableStreamIdsMap* table_to_unprocessed_streams_map);
@@ -2253,7 +2253,7 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
   UDTypeInfoByNameMap udtype_names_map_ GUARDED_BY(mutex_);
 
   // RedisConfig map: RedisConfigKey -> RedisConfigInfo
-  typedef std::unordered_map<RedisConfigKey, scoped_refptr<RedisConfigInfo>> RedisConfigInfoMap;
+  using RedisConfigInfoMap = std::unordered_map<RedisConfigKey, scoped_refptr<RedisConfigInfo>>;
   RedisConfigInfoMap redis_config_map_ GUARDED_BY(mutex_);
 
   // Config information.
@@ -3062,16 +3062,15 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
   std::unordered_map<ReplicationSlotName, xrepl::StreamId> cdcsdk_replication_slots_to_stream_map_
       GUARDED_BY(mutex_);
 
-  typedef std::unordered_map<xcluster::ReplicationGroupId, scoped_refptr<UniverseReplicationInfo>>
-      UniverseReplicationInfoMap;
+  using UniverseReplicationInfoMap =
+      std::unordered_map<xcluster::ReplicationGroupId, scoped_refptr<UniverseReplicationInfo>>;
   UniverseReplicationInfoMap universe_replication_map_ GUARDED_BY(mutex_);
 
   // List of universe ids to universes that must be deleted
   std::deque<xcluster::ReplicationGroupId> universes_to_clear_ GUARDED_BY(mutex_);
 
-  typedef std::unordered_map<
-      xcluster::ReplicationGroupId, scoped_refptr<UniverseReplicationBootstrapInfo>>
-      UniverseReplicationBootstrapInfoMap;
+  using UniverseReplicationBootstrapInfoMap = std::unordered_map<
+      xcluster::ReplicationGroupId, scoped_refptr<UniverseReplicationBootstrapInfo>>;
   UniverseReplicationBootstrapInfoMap universe_replication_bootstrap_map_ GUARDED_BY(mutex_);
 
   std::deque<xcluster::ReplicationGroupId> replication_bootstraps_to_clear_ GUARDED_BY(mutex_);
diff --git a/src/yb/master/catalog_manager_if.h b/src/yb/master/catalog_manager_if.h
index 427ba7b2da..cf478b5a9a 100644
--- a/src/yb/master/catalog_manager_if.h
+++ b/src/yb/master/catalog_manager_if.h
@@ -39,12 +39,10 @@
 #include "yb/util/result.h"
 #include "yb/util/status.h"
 
-namespace google {
-namespace protobuf {
+namespace google::protobuf {
 template <class T>
 class RepeatedPtrField;
 }
-}
 
 namespace yb {
 
diff --git a/src/yb/master/master_heartbeat.proto b/src/yb/master/master_heartbeat.proto
index 48ca1847b8..9b0be86bf8 100644
--- a/src/yb/master/master_heartbeat.proto
+++ b/src/yb/master/master_heartbeat.proto
@@ -20,13 +20,13 @@ import "yb/cdc/cdc_consumer.proto";
 import "yb/cdc/xcluster_producer.proto";
 import "yb/common/common_types.proto";
 import "yb/common/wire_protocol.proto";
-import "yb/consensus/metadata.proto";
 import "yb/consensus/consensus_types.proto";
+import "yb/consensus/metadata.proto";
 import "yb/encryption/encryption.proto";
 import "yb/master/master_types.proto";
+import "yb/rpc/service.proto";
 import "yb/tablet/tablet_types.proto";
 import "yb/tserver/tserver.proto";
-import "yb/rpc/service.proto";
 
 // Common information sent with every request from the tablet server
 // to the master.
@@ -323,7 +323,7 @@ message TSHeartbeatResponsePB {
   // Specify whether or not the cluster is a producer of a valid replication stream.
   optional bool xcluster_enabled_on_producer = 19;
 
-  // Map[Local NamespaceId]: xCluester safe read HybridTime
+  // Map[Local NamespaceId]: xCluster safe read HybridTime
   map<string, fixed64> xcluster_namespace_to_safe_time = 21;
 
   optional AutoFlagsConfigPB auto_flags_config = 22;
@@ -339,6 +339,12 @@ message TSHeartbeatResponsePB {
   optional bool is_fatal_error = 27;
 
   optional uint32 oid_cache_invalidations_count = 29;
+
+  message XClusterHeartbeatInfo {
+    // Local NamespaceId -> xCluster info for that namespace.
+    map<string, XClusterNamespaceInfoPB> xcluster_info_per_namespace = 1;
+  }
+  optional XClusterHeartbeatInfo xcluster_heartbeat_info = 30;
 }
 
 service MasterHeartbeat {
diff --git a/src/yb/master/xcluster/master_xcluster_util.cc b/src/yb/master/xcluster/master_xcluster_util.cc
index 887db812e7..bf49a5dcfe 100644
--- a/src/yb/master/xcluster/master_xcluster_util.cc
+++ b/src/yb/master/xcluster/master_xcluster_util.cc
@@ -18,6 +18,7 @@
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/catalog_manager_util.h"
+#include "yb/master/xcluster/xcluster_manager.h"
 
 DECLARE_uint32(xcluster_ysql_statement_timeout_sec);
 
@@ -139,39 +140,41 @@ bool IsAutomaticDdlMode(const SysUniverseReplicationEntryPB& replication_info) {
 }
 
 Status SetupDDLReplicationExtension(
-    CatalogManagerIf& catalog_manager, const std::string& database_name,
+    CatalogManagerIf& catalog_manager, const NamespaceId& namespace_id,
     XClusterDDLReplicationRole role, StdStatusCallback callback) {
-  std::vector<std::string> statements;
-
-  statements.push_back(Format("CREATE EXTENSION IF NOT EXISTS $0", kXClusterDDLExtensionName));
-  statements.push_back(Format(
-      "ALTER DATABASE \"$0\" SET $1.replication_role = $2", database_name,
-      kXClusterDDLExtensionName,
-      role == XClusterDDLReplicationRole::kSource ? "SOURCE" : "TARGET"));
+  auto namespace_name = VERIFY_RESULT(catalog_manager.FindNamespaceById(namespace_id))->name();
+  LOG(INFO) << "Creating if exists " << kXClusterDDLExtensionName << " extension for namespace "
+            << namespace_id << " (" << namespace_name << ")";
 
-  return ExecutePgsqlStatements(
-      database_name, statements, catalog_manager,
+  auto statement = Format("CREATE EXTENSION IF NOT EXISTS $0", kXClusterDDLExtensionName);
+  RETURN_NOT_OK(ExecutePgsqlStatements(
+      namespace_name, {statement}, catalog_manager,
       CoarseMonoClock::now() + MonoDelta::FromSeconds(FLAGS_xcluster_ysql_statement_timeout_sec),
-      std::move(callback));
+      std::move(callback)));
+
+  auto* xcluster_manager = catalog_manager.GetXClusterManagerImpl();
+  return xcluster_manager->SetXClusterRole(catalog_manager.GetLeaderEpochInternal(),
+      namespace_id, role == XClusterDDLReplicationRole::kSource
+                        ? XClusterNamespaceInfoPB_XClusterRole_AUTOMATIC_SOURCE
+                        : XClusterNamespaceInfoPB_XClusterRole_AUTOMATIC_TARGET);
 }
 
 Status DropDDLReplicationExtensionIfExists(
     CatalogManagerIf& catalog_manager, const NamespaceId& namespace_id,
     StdStatusCallback callback) {
   auto namespace_name = VERIFY_RESULT(catalog_manager.FindNamespaceById(namespace_id))->name();
-  LOG(INFO) << "Dropping " << kXClusterDDLExtensionName << " extension for namespace "
+  LOG(INFO) << "Dropping if exists " << kXClusterDDLExtensionName << " extension for namespace "
             << namespace_id << " (" << namespace_name << ")";
-  std::vector<std::string> statements;
+
   // Disable the extension first to prevent any conflicts with later setups.
-  statements.push_back(Format(
-      "ALTER DATABASE \"$0\" SET $1.replication_role = DISABLED", namespace_name,
-      kXClusterDDLExtensionName));
-  // Also disable for the current session.
-  statements.push_back(Format("SET $0.replication_role = DISABLED", kXClusterDDLExtensionName));
-  statements.push_back(Format("DROP EXTENSION IF EXISTS $0", kXClusterDDLExtensionName));
+  auto* xcluster_manager = catalog_manager.GetXClusterManagerImpl();
+  RETURN_NOT_OK(xcluster_manager->SetXClusterRole(
+      catalog_manager.GetLeaderEpochInternal(), namespace_id,
+      XClusterNamespaceInfoPB_XClusterRole_NOT_AUTOMATIC_MODE));
 
+  auto statement = Format("DROP EXTENSION IF EXISTS $0", kXClusterDDLExtensionName);
   return ExecutePgsqlStatements(
-      namespace_name, statements, catalog_manager,
+      namespace_name, {statement}, catalog_manager,
       CoarseMonoClock::now() + MonoDelta::FromSeconds(FLAGS_xcluster_ysql_statement_timeout_sec),
       std::move(callback));
 }
diff --git a/src/yb/master/xcluster/master_xcluster_util.h b/src/yb/master/xcluster/master_xcluster_util.h
index 2ed7704a58..527c94c1d8 100644
--- a/src/yb/master/xcluster/master_xcluster_util.h
+++ b/src/yb/master/xcluster/master_xcluster_util.h
@@ -61,7 +61,7 @@ bool IsAutomaticDdlMode(const SysUniverseReplicationEntryPB& replication_info);
 YB_DEFINE_ENUM(XClusterDDLReplicationRole, (kSource)(kTarget));
 
 Status SetupDDLReplicationExtension(
-    CatalogManagerIf& catalog_manager, const std::string& database_name,
+    CatalogManagerIf& catalog_manager, const NamespaceId& namespace_id,
     XClusterDDLReplicationRole role, StdStatusCallback callback);
 
 Status DropDDLReplicationExtensionIfExists(
diff --git a/src/yb/master/xcluster/xcluster_config.cc b/src/yb/master/xcluster/xcluster_config.cc
index 89908c88b1..420c345969 100644
--- a/src/yb/master/xcluster/xcluster_config.cc
+++ b/src/yb/master/xcluster/xcluster_config.cc
@@ -99,6 +99,12 @@ Status XClusterConfig::FillHeartbeatResponse(
     *resp->mutable_xcluster_producer_registry() = config_pb.xcluster_producer_registry();
   }
 
+  auto& xcluster_info_per_namespace =
+      *resp->mutable_xcluster_heartbeat_info()->mutable_xcluster_info_per_namespace();
+  for (const auto& [namespace_id, xcluster_info] : config_pb.xcluster_info_per_namespace()) {
+    xcluster_info_per_namespace[namespace_id] = xcluster_info;
+  }
+
   return Status::OK();
 }
 
@@ -114,6 +120,21 @@ Status XClusterConfig::BumpVersionUpsertAndCommit(
   return Status::OK();
 }
 
+Status XClusterConfig::SetXClusterRole(
+    const LeaderEpoch& epoch, const NamespaceId& namespace_id,
+    XClusterNamespaceInfoPB_XClusterRole role) {
+  SharedLock mutex_lock(mutex_);
+  SCHECK(xcluster_config_info_, IllegalState, "XCluster config is not initialized");
+
+  auto l = xcluster_config_info_->LockForWrite();
+  auto& config_pb = l.mutable_data()->pb;
+  auto* xcluster_info_per_namespace =
+      config_pb.mutable_xcluster_info_per_namespace();
+  (*xcluster_info_per_namespace)[namespace_id].set_role(role);
+
+  return BumpVersionUpsertAndCommit(epoch, l);
+}
+
 Status XClusterConfig::RemoveStreams(
     const LeaderEpoch& epoch, const std::vector<CDCStreamInfo*>& streams) {
   SharedLock mutex_lock(mutex_);
diff --git a/src/yb/master/xcluster/xcluster_config.h b/src/yb/master/xcluster/xcluster_config.h
index c116eee1e7..14c8394481 100644
--- a/src/yb/master/xcluster/xcluster_config.h
+++ b/src/yb/master/xcluster/xcluster_config.h
@@ -27,13 +27,13 @@ class CowWriteLock;
 
 namespace master {
 
+class CDCStreamInfo;
 class SysCatalogTable;
-class XClusterConfigInfo;
 class SysXClusterConfigEntryPB;
 class TSHeartbeatRequestPB;
 class TSHeartbeatResponsePB;
+class XClusterConfigInfo;
 struct PersistentXClusterConfigInfo;
-class CDCStreamInfo;
 
 // Wrapper over XClusterConfigInfo that provides safe utils to access and modify XClusterConfigInfo.
 class XClusterConfig {
@@ -56,6 +56,10 @@ class XClusterConfig {
   Status FillHeartbeatResponse(const TSHeartbeatRequestPB& req, TSHeartbeatResponsePB* resp) const
       EXCLUDES(mutex_);
 
+  Status SetXClusterRole(
+      const LeaderEpoch& epoch, const NamespaceId& namespace_id,
+      XClusterNamespaceInfoPB_XClusterRole role) EXCLUDES(mutex_);
+
   Status RemoveStreams(const LeaderEpoch& epoch, const std::vector<CDCStreamInfo*>& streams);
 
   Status PauseResumeXClusterProducerStreams(
diff --git a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
index 972cfb33ec..6ebd96bc86 100644
--- a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
+++ b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
@@ -296,7 +296,7 @@ Status XClusterInboundReplicationGroupSetupTask::SetupDDLReplicationExtension()
       // Set up the extension and set our role as a target to prevent writes.
       Synchronizer sync;
       RETURN_NOT_OK(master::SetupDDLReplicationExtension(
-          catalog_manager_, namespace_name, XClusterDDLReplicationRole::kTarget,
+          catalog_manager_, namespace_id, XClusterDDLReplicationRole::kTarget,
           sync.AsStdStatusCallback()));
       RETURN_NOT_OK_PREPEND(sync.Wait(), "Failed to setup xCluster DDL replication extension");
     }
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index 8b4c16e0d4..30e89adf56 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -21,16 +21,17 @@
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master_cluster.pb.h"
+#include "yb/master/master_heartbeat.pb.h"
 #include "yb/master/master_replication.pb.h"
 #include "yb/master/xcluster/master_xcluster_util.h"
+#include "yb/master/xcluster/xcluster_config.h"
 #include "yb/master/xcluster/xcluster_status.h"
 #include "yb/master/xcluster/xcluster_universe_replication_setup_helper.h"
-#include "yb/util/backoff_waiter.h"
-#include "yb/util/is_operation_done_result.h"
-#include "yb/master/xcluster/xcluster_config.h"
 
 #include "yb/rpc/rpc_context.h"
 
+#include "yb/util/backoff_waiter.h"
+#include "yb/util/is_operation_done_result.h"
 #include "yb/util/logging.h"
 #include "yb/util/result.h"
 
@@ -190,6 +191,12 @@ Status XClusterManager::FillHeartbeatResponse(
   return xcluster_config_->FillHeartbeatResponse(req, resp);
 }
 
+Status XClusterManager::SetXClusterRole(
+    const LeaderEpoch& epoch, const NamespaceId& namespace_id,
+    XClusterNamespaceInfoPB_XClusterRole role) {
+  return xcluster_config_->SetXClusterRole(epoch, namespace_id, role);
+}
+
 Status XClusterManager::PrepareDefaultXClusterConfig(int64_t term, bool recreate) {
   return xcluster_config_->PrepareDefault(term, recreate);
 }
diff --git a/src/yb/master/xcluster/xcluster_manager.h b/src/yb/master/xcluster/xcluster_manager.h
index 67a303cbdb..c9068467f3 100644
--- a/src/yb/master/xcluster/xcluster_manager.h
+++ b/src/yb/master/xcluster/xcluster_manager.h
@@ -23,9 +23,8 @@
 #include "yb/master/xcluster/xcluster_source_manager.h"
 #include "yb/master/xcluster/xcluster_target_manager.h"
 
-namespace yb {
+namespace yb::master {
 
-namespace master {
 class CDCStreamInfo;
 class GetMasterXClusterConfigResponsePB;
 class PauseResumeXClusterProducerStreamsRequestPB;
@@ -76,6 +75,10 @@ class XClusterManager : public XClusterManagerIf,
 
   Status FillHeartbeatResponse(const TSHeartbeatRequestPB& req, TSHeartbeatResponsePB* resp) const;
 
+  Status SetXClusterRole(
+      const LeaderEpoch& epoch, const NamespaceId& namespace_id,
+      XClusterNamespaceInfoPB_XClusterRole role);
+
   // Remove deleted xcluster stream IDs from producer stream Id map.
   Status RemoveStreamsFromSysCatalog(
       const LeaderEpoch& epoch, const std::vector<CDCStreamInfo*>& streams);
@@ -311,6 +314,4 @@ class XClusterManager : public XClusterManagerIf,
   std::unordered_set<server::MonitoredTaskPtr> monitored_tasks_ GUARDED_BY(monitored_tasks_mutex_);
 };
 
-}  // namespace master
-
-}  // namespace yb
+} // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_replication_group.cc b/src/yb/master/xcluster/xcluster_replication_group.cc
index c5a1fe6496..1fc828b380 100644
--- a/src/yb/master/xcluster/xcluster_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_replication_group.cc
@@ -216,7 +216,7 @@ Status HandleExtensionOnDropReplication(
               << "), switching yb_xcluster_ddl_replication extension role to Source.";
     Synchronizer sync;
     RETURN_NOT_OK(master::SetupDDLReplicationExtension(
-        catalog_manager, namespace_name, XClusterDDLReplicationRole::kSource,
+        catalog_manager, namespace_id, XClusterDDLReplicationRole::kSource,
         sync.AsStdStatusCallback()));
     return sync.Wait();
   }
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index 75040793f9..6445a8169f 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -1345,8 +1345,6 @@ bool XClusterSourceManager::IsNamespaceInAutomaticDDLMode(const NamespaceId& nam
 
 Status XClusterSourceManager::SetupDDLReplicationExtension(
     const NamespaceId& namespace_id, StdStatusCallback callback) const {
-  auto namespace_name = VERIFY_RESULT(catalog_manager_.FindNamespaceById(namespace_id))->name();
-
   bool is_switchover =
       catalog_manager_.GetXClusterManager()->IsNamespaceInAutomaticModeTarget(namespace_id);
   if (is_switchover) {
@@ -1359,7 +1357,7 @@ Status XClusterSourceManager::SetupDDLReplicationExtension(
   }
 
   return master::SetupDDLReplicationExtension(
-      catalog_manager_, namespace_name, XClusterDDLReplicationRole::kSource, std::move(callback));
+      catalog_manager_, namespace_id, XClusterDDLReplicationRole::kSource, std::move(callback));
 }
 
 Status XClusterSourceManager::DropDDLReplicationExtensionIfExists(
diff --git a/src/yb/tserver/pg_client.proto b/src/yb/tserver/pg_client.proto
index 66d846ab69..a1d8dad8ed 100644
--- a/src/yb/tserver/pg_client.proto
+++ b/src/yb/tserver/pg_client.proto
@@ -49,6 +49,7 @@ service PgClientService {
   rpc FinishTransaction(PgFinishTransactionRequestPB) returns (PgFinishTransactionResponsePB);
   rpc GetCatalogMasterVersion(PgGetCatalogMasterVersionRequestPB)
       returns (PgGetCatalogMasterVersionResponsePB);
+  rpc GetXClusterRole(PgGetXClusterRoleRequestPB) returns (PgGetXClusterRoleResponsePB);
   rpc GetDatabaseInfo(PgGetDatabaseInfoRequestPB) returns (PgGetDatabaseInfoResponsePB);
   rpc GetLockStatus(PgGetLockStatusRequestPB) returns (PgGetLockStatusResponsePB);
   rpc GetReplicationSlot(PgGetReplicationSlotRequestPB) returns (PgGetReplicationSlotResponsePB);
@@ -448,6 +449,11 @@ message PgDropTablegroupResponsePB {
 message PgGetCatalogMasterVersionRequestPB {
 }
 
+message PgGetXClusterRoleRequestPB {
+  uint32 db_oid = 1;
+  AshMetadataPB ash_metadata = 2;
+}
+
 message PgFinishTransactionRequestPB {
   message DdlModePB {
     // This transaction contains changes to the DocDB schema protobufs.
@@ -476,6 +482,11 @@ message PgGetCatalogMasterVersionResponsePB {
   uint64 version = 2;
 }
 
+message PgGetXClusterRoleResponsePB {
+  AppStatusPB status = 1;
+  uint32 xcluster_role = 2;  // Really XClusterNamespaceInfoPB.XClusterRole.
+}
+
 message PgGetDatabaseInfoRequestPB {
   uint32 oid = 1;
 }
diff --git a/src/yb/tserver/pg_client_service.cc b/src/yb/tserver/pg_client_service.cc
index e319b48407..e97cadc58b 100644
--- a/src/yb/tserver/pg_client_service.cc
+++ b/src/yb/tserver/pg_client_service.cc
@@ -19,7 +19,6 @@
 #include <algorithm>
 #include <mutex>
 #include <queue>
-#include <regex>
 #include <unordered_set>
 #include <vector>
 
@@ -35,7 +34,6 @@
 #include "yb/client/schema.h"
 #include "yb/client/stateful_services/pg_cron_leader_service_client.h"
 #include "yb/client/table.h"
-#include "yb/client/table_creator.h"
 #include "yb/client/table_info.h"
 #include "yb/client/tablet_server.h"
 #include "yb/client/transaction.h"
@@ -45,28 +43,21 @@
 #include "yb/common/pgsql_error.h"
 #include "yb/common/wire_protocol.h"
 
-#include "yb/dockv/partition.h"
-
 #include "yb/master/master_admin.proxy.h"
-#include "yb/master/master_backup.proxy.h"
+#include "yb/master/master_backup.pb.h"
 #include "yb/master/master_client.pb.h"
 #include "yb/master/master_ddl.pb.h"
 #include "yb/master/master_heartbeat.pb.h"
 #include "yb/master/sys_catalog_constants.h"
 
-#include "yb/rocksdb/db/db_impl.h"
-
 #include "yb/rpc/messenger.h"
-#include "yb/rpc/poller.h"
 #include "yb/rpc/rpc_context.h"
 #include "yb/rpc/rpc_controller.h"
 #include "yb/rpc/rpc_introspection.pb.h"
 #include "yb/rpc/scheduler.h"
-#include "yb/rpc/tasks_pool.h"
 
 #include "yb/server/server_base.h"
 
-#include "yb/tserver/pg_client.proxy.h"
 #include "yb/tserver/pg_client_service_util.h"
 #include "yb/tserver/pg_create_table.h"
 #include "yb/tserver/pg_response_cache.h"
@@ -75,7 +66,6 @@
 #include "yb/tserver/pg_table_cache.h"
 #include "yb/tserver/pg_txn_snapshot_manager.h"
 #include "yb/tserver/tablet_server_interface.h"
-#include "yb/tserver/tablet_server_options.h"
 #include "yb/tserver/tserver_service.pb.h"
 #include "yb/tserver/tserver_service.proxy.h"
 #include "yb/tserver/tserver_shared_mem.h"
@@ -83,9 +73,7 @@
 #include "yb/tserver/ysql_advisory_lock_table.h"
 
 #include "yb/util/debug.h"
-#include "yb/util/flags.h"
 #include "yb/util/flags/flag_tags.h"
-#include "yb/util/jsonwriter.h"
 #include "yb/util/logging.h"
 #include "yb/util/net/net_util.h"
 #include "yb/util/random_util.h"
@@ -578,7 +566,7 @@ class PgClientServiceImpl::Impl {
 
     std::lock_guard lock(mutex_);
     auto it = sessions_.insert(std::move(session_info)).first;
-    session_expiration_queue_.push({(**it).session().expiration(), session_id});
+    session_expiration_queue_.emplace((**it).session().expiration(), session_id);
     return Status::OK();
   }
 
@@ -594,7 +582,7 @@ class PgClientServiceImpl::Impl {
       return;
     }
     (**it).session().SetExpiration(now);
-    session_expiration_queue_.push({now, session_id});
+    session_expiration_queue_.emplace(now, session_id);
     ScheduleCheckExpiredSessions(now);
   }
 
@@ -790,6 +778,19 @@ class PgClientServiceImpl::Impl {
     return Status::OK();
   }
 
+  Status GetXClusterRole(
+      const PgGetXClusterRoleRequestPB& req, PgGetXClusterRoleResponsePB* resp,
+      rpc::RpcContext* context) {
+    NamespaceId namespace_id = GetPgsqlNamespaceId(req.db_oid());
+    const auto* xcluster_context = session_context_.xcluster_context;
+    int32_t role = XClusterNamespaceInfoPB_XClusterRole_UNAVAILABLE;
+    if (xcluster_context) {
+      role = xcluster_context->GetXClusterRole(namespace_id);
+    }
+    resp->set_xcluster_role(role);
+    return Status::OK();
+  }
+
   Status CreateSequencesDataTable(
       const PgCreateSequencesDataTableRequestPB& req,
       PgCreateSequencesDataTableResponsePB* resp,
@@ -2219,7 +2220,7 @@ class PgClientServiceImpl::Impl {
         if (it != sessions_.end()) {
           auto current_expiration = (**it).session().expiration();
           if (current_expiration > now) {
-            session_expiration_queue_.push({current_expiration, id});
+            session_expiration_queue_.emplace(current_expiration, id);
           } else {
             expired_sessions.push_back(*it);
             sessions_.erase(it);
diff --git a/src/yb/tserver/pg_client_service.h b/src/yb/tserver/pg_client_service.h
index f23f5e69fc..e572e5619f 100644
--- a/src/yb/tserver/pg_client_service.h
+++ b/src/yb/tserver/pg_client_service.h
@@ -16,7 +16,6 @@
 #include <functional>
 #include <future>
 #include <memory>
-#include <optional>
 #include <string>
 #include <unordered_map>
 
@@ -24,13 +23,10 @@
 
 #include "yb/gutil/ref_counted.h"
 
-#include "yb/master/master_heartbeat.fwd.h"
-
 #include "yb/rpc/rpc_fwd.h"
 
 #include "yb/server/server_base_options.h"
 
-#include "yb/tserver/pg_client_session.h"
 #include "yb/tserver/pg_client.service.h"
 #include "yb/tserver/pg_txn_snapshot_manager.h"
 
@@ -73,8 +69,9 @@ class TserverXClusterContextIf;
     (GetReplicationSlot) \
     (GetTableDiskSize) \
     (GetTablePartitionList) \
-    (GetTserverCatalogVersionInfo) \
     (GetTserverCatalogMessageLists) \
+    (GetTserverCatalogVersionInfo) \
+    (GetXClusterRole) \
     (Heartbeat) \
     (InsertSequenceTuple) \
     (IsInitDbDone) \
diff --git a/src/yb/tserver/tablet_server.cc b/src/yb/tserver/tablet_server.cc
index 21deb33e36..21e06ad84a 100644
--- a/src/yb/tserver/tablet_server.cc
+++ b/src/yb/tserver/tablet_server.cc
@@ -33,9 +33,6 @@
 #include "yb/tserver/tablet_server.h"
 
 #include <algorithm>
-#include <limits>
-#include <list>
-#include <thread>
 #include <utility>
 
 #include "yb/cdc/cdc_service.h"
@@ -59,7 +56,6 @@
 
 #include "yb/fs/fs_manager.h"
 
-#include "yb/gutil/hash/city.h"
 #include "yb/gutil/strings/substitute.h"
 
 #include "yb/master/master_ddl.pb.h"
@@ -76,7 +72,6 @@
 #include "yb/server/async_client_initializer.h"
 #include "yb/server/hybrid_clock.h"
 #include "yb/server/rpc_server.h"
-#include "yb/server/webserver.h"
 #include "yb/server/ycql_stat_provider.h"
 
 #include "yb/tablet/maintenance_manager.h"
@@ -91,6 +86,9 @@
 #include "yb/tserver/pg_client_service.h"
 #include "yb/tserver/pg_table_mutation_count_sender.h"
 #include "yb/tserver/remote_bootstrap_service.h"
+#include "yb/tserver/stateful_services/pg_auto_analyze_service.h"
+#include "yb/tserver/stateful_services/pg_cron_leader_service.h"
+#include "yb/tserver/stateful_services/test_echo_service.h"
 #include "yb/tserver/tablet_service.h"
 #include "yb/tserver/ts_local_lock_manager.h"
 #include "yb/tserver/ts_tablet_manager.h"
@@ -101,20 +99,17 @@
 #include "yb/tserver/tserver_xcluster_context.h"
 #include "yb/tserver/xcluster_consumer_if.h"
 #include "yb/tserver/ysql_lease_poller.h"
-#include "yb/tserver/stateful_services/pg_auto_analyze_service.h"
-#include "yb/tserver/stateful_services/pg_cron_leader_service.h"
-#include "yb/tserver/stateful_services/test_echo_service.h"
 
 #include "yb/util/flags.h"
 #include "yb/util/logging.h"
+#include "yb/util/net/net_util.h"
+#include "yb/util/net/sockaddr.h"
 #include "yb/util/ntp_clock.h"
 #include "yb/util/pg_util.h"
 #include "yb/util/random_util.h"
 #include "yb/util/size_literals.h"
 #include "yb/util/status.h"
 #include "yb/util/status_log.h"
-#include "yb/util/net/net_util.h"
-#include "yb/util/net/sockaddr.h"
 
 #include "yb/yql/pgwrapper/libpq_utils.h"
 #include "yb/yql/pgwrapper/pg_wrapper.h"
@@ -1608,6 +1603,8 @@ Status TabletServer::XClusterPopulateMasterHeartbeatRequest(
 Status TabletServer::XClusterHandleMasterHeartbeatResponse(
     const master::TSHeartbeatResponsePB& resp) {
   xcluster_context_->UpdateSafeTimeMap(resp.xcluster_namespace_to_safe_time());
+  xcluster_context_->UpdateXClusterInfoPerNamespace(
+      resp.xcluster_heartbeat_info().xcluster_info_per_namespace());
 
   auto* xcluster_consumer = GetXClusterConsumer();
 
diff --git a/src/yb/tserver/tablet_server.h b/src/yb/tserver/tablet_server.h
index a8fbcc293a..65319bcded 100644
--- a/src/yb/tserver/tablet_server.h
+++ b/src/yb/tserver/tablet_server.h
@@ -71,6 +71,7 @@
 #include "yb/tserver/tablet_server_options.h"
 #include "yb/tserver/tserver.pb.h"
 
+#include "yb/util/atomic.h"
 #include "yb/util/locks.h"
 #include "yb/util/net/net_util.h"
 #include "yb/util/net/sockaddr.h"
diff --git a/src/yb/tserver/tserver_xcluster_context.cc b/src/yb/tserver/tserver_xcluster_context.cc
index ba7053fc0a..2e59a50770 100644
--- a/src/yb/tserver/tserver_xcluster_context.cc
+++ b/src/yb/tserver/tserver_xcluster_context.cc
@@ -28,6 +28,19 @@ Result<std::optional<HybridTime>> TserverXClusterContext::GetSafeTime(
   return safe_time_map_.GetSafeTime(namespace_id);
 }
 
+XClusterNamespaceInfoPB_XClusterRole TserverXClusterContext::GetXClusterRole(
+    const NamespaceId& namespace_id) const {
+  SharedLock lock(mutex_);
+  if (!have_received_a_heartbeat_) {
+    return XClusterNamespaceInfoPB_XClusterRole_UNAVAILABLE;
+  }
+  if (auto* xcluster_info_per_namespace = FindOrNull(xcluster_info_per_namespace_, namespace_id)) {
+    return xcluster_info_per_namespace->role();
+  } else {
+    return XClusterNamespaceInfoPB_XClusterRole_NOT_AUTOMATIC_MODE;
+  }
+}
+
 bool TserverXClusterContext::IsReadOnlyMode(const NamespaceId& namespace_id) const {
   // Namespaces that are part of the safe time belong to an inbound transactional xCluster
   // replication.
@@ -35,7 +48,7 @@ bool TserverXClusterContext::IsReadOnlyMode(const NamespaceId& namespace_id) con
 }
 
 bool TserverXClusterContext::IsTargetAndInAutomaticMode(const NamespaceId& namespace_id) const {
-  SharedLock lock(target_namespaces_in_automatic_mode_mutex_);
+  SharedLock lock(mutex_);
   return target_namespaces_in_automatic_mode_.contains(namespace_id);
 }
 
@@ -44,9 +57,20 @@ void TserverXClusterContext::UpdateSafeTimeMap(
   safe_time_map_.Update(safe_time_map);
 }
 
+void TserverXClusterContext::UpdateXClusterInfoPerNamespace(
+    const ::google::protobuf::Map<std::string, XClusterNamespaceInfoPB>&
+        xcluster_info_per_namespace) {
+  std::lock_guard lock(mutex_);
+  have_received_a_heartbeat_ = true;
+  xcluster_info_per_namespace_.clear();
+  for (const auto& [namespace_id, info] : xcluster_info_per_namespace) {
+    xcluster_info_per_namespace_[namespace_id] = info;
+  }
+}
+
 void TserverXClusterContext::UpdateTargetNamespacesInAutomaticModeSet(
     const std::unordered_set<NamespaceId>& target_namespaces_in_automatic_mode) {
-  std::lock_guard lock(target_namespaces_in_automatic_mode_mutex_);
+  std::lock_guard lock(mutex_);
   target_namespaces_in_automatic_mode_ = target_namespaces_in_automatic_mode;
 }
 
diff --git a/src/yb/tserver/tserver_xcluster_context.h b/src/yb/tserver/tserver_xcluster_context.h
index 60ac2b23fe..7925c5b7c4 100644
--- a/src/yb/tserver/tserver_xcluster_context.h
+++ b/src/yb/tserver/tserver_xcluster_context.h
@@ -17,6 +17,7 @@
 #include <shared_mutex>
 #include <unordered_map>
 
+#include "yb/common/common_types.pb.h"  // gcc needs for std::unordered_map XClusterNamespaceInfoPB
 #include "yb/common/entity_ids_types.h"
 #include "yb/common/pg_types.h"
 #include "yb/tserver/tserver_xcluster_context_if.h"
@@ -35,17 +36,24 @@ class TserverXClusterContext : public TserverXClusterContextIf {
 
   Result<std::optional<HybridTime>> GetSafeTime(const NamespaceId& namespace_id) const override;
 
+  XClusterNamespaceInfoPB_XClusterRole GetXClusterRole(
+      const NamespaceId& namespace_id) const override EXCLUDES(mutex_);
+
   bool IsReadOnlyMode(const NamespaceId& namespace_id) const override;
-  bool IsTargetAndInAutomaticMode(const NamespaceId& namespace_id) const override
-      EXCLUDES(target_namespaces_in_automatic_mode_mutex_);
+  bool IsTargetAndInAutomaticMode(const NamespaceId& namespace_id) const override EXCLUDES(mutex_);
 
   bool SafeTimeComputationRequired() const override;
   bool SafeTimeComputationRequired(const NamespaceId& namespace_id) const override;
 
   void UpdateSafeTimeMap(const XClusterNamespaceToSafeTimePBMap& safe_time_map);
+
+  void UpdateXClusterInfoPerNamespace(
+      const ::google::protobuf::Map<std::string, XClusterNamespaceInfoPB>&
+          automatic_mode_replication_state_per_namespace) EXCLUDES(mutex_);
+
   void UpdateTargetNamespacesInAutomaticModeSet(
       const std::unordered_set<NamespaceId>& target_namespaces_in_automatic_mode) override
-      EXCLUDES(target_namespaces_in_automatic_mode_mutex_);
+      EXCLUDES(mutex_);
 
   Status SetSourceTableInfoMappingForCreateTable(
       const YsqlFullTableName& table_name, const PgObjectId& source_table_id,
@@ -60,11 +68,14 @@ class TserverXClusterContext : public TserverXClusterContextIf {
  private:
   XClusterSafeTimeMap safe_time_map_;
 
-  mutable std::shared_mutex target_namespaces_in_automatic_mode_mutex_;
+  mutable std::shared_mutex mutex_;
+  bool have_received_a_heartbeat_ GUARDED_BY(mutex_) = false;
   // The set of namespaces that for this universe are targets of xCluster automatic mode
   // replication.
-  std::unordered_set<NamespaceId> target_namespaces_in_automatic_mode_
-      GUARDED_BY(target_namespaces_in_automatic_mode_mutex_);
+  std::unordered_set<NamespaceId> target_namespaces_in_automatic_mode_ GUARDED_BY(mutex_);
+
+  std::unordered_map<NamespaceId, XClusterNamespaceInfoPB> xcluster_info_per_namespace_
+      GUARDED_BY(mutex_);
 
   struct CreateTableInfo {
     PgObjectId source_table_id;
diff --git a/src/yb/tserver/tserver_xcluster_context_if.h b/src/yb/tserver/tserver_xcluster_context_if.h
index c66fe32f34..4781b122f9 100644
--- a/src/yb/tserver/tserver_xcluster_context_if.h
+++ b/src/yb/tserver/tserver_xcluster_context_if.h
@@ -35,6 +35,9 @@ class TserverXClusterContextIf {
 
   virtual Result<std::optional<HybridTime>> GetSafeTime(const NamespaceId& namespace_id) const = 0;
 
+  virtual XClusterNamespaceInfoPB_XClusterRole GetXClusterRole(
+      const NamespaceId& namespace_id) const = 0;
+
   virtual bool IsReadOnlyMode(const NamespaceId& namespace_id) const = 0;
   virtual bool IsTargetAndInAutomaticMode(const NamespaceId& namespace_id) const = 0;
 
diff --git a/src/yb/tserver/tserver_xcluster_context_mock.h b/src/yb/tserver/tserver_xcluster_context_mock.h
index b8322d5099..ca36de3b62 100644
--- a/src/yb/tserver/tserver_xcluster_context_mock.h
+++ b/src/yb/tserver/tserver_xcluster_context_mock.h
@@ -18,10 +18,10 @@
 #include "yb/common/hybrid_time.h"
 #include "yb/common/pg_types.h"
 
-#include "yb/util/result.h"
-
 #include "yb/tserver/tserver_xcluster_context_if.h"
 
+#include "yb/util/result.h"
+
 namespace yb {
 
 // This is needed for the mock of GetSafeTime.
@@ -36,6 +36,10 @@ class MockTserverXClusterContext : public TserverXClusterContextIf {
       (Result<std::optional<HybridTime>>), GetSafeTime, (const NamespaceId& namespace_id),
       (const, override));
 
+  MOCK_METHOD(
+      XClusterNamespaceInfoPB_XClusterRole, GetXClusterRole, (const NamespaceId& namespace_id),
+      (const, override));
+
   MOCK_METHOD(bool, IsReadOnlyMode, (const NamespaceId& namespace_id), (const, override));
   MOCK_METHOD(
       bool, IsTargetAndInAutomaticMode, (const NamespaceId& namespace_id), (const, override));
diff --git a/src/yb/yql/pggate/pg_client.cc b/src/yb/yql/pggate/pg_client.cc
index 4a978155c7..fb535931b0 100644
--- a/src/yb/yql/pggate/pg_client.cc
+++ b/src/yb/yql/pggate/pg_client.cc
@@ -36,19 +36,15 @@
 #include "yb/tserver/pg_client.proxy.h"
 #include "yb/tserver/tserver_shared_mem.h"
 
-#include "yb/util/debug-util.h"
 #include "yb/util/logging.h"
-#include "yb/util/protobuf_util.h"
 #include "yb/util/result.h"
 #include "yb/util/scope_exit.h"
-#include "yb/util/shared_mem.h"
 #include "yb/util/status.h"
 
 #include "yb/yql/pggate/pg_op.h"
 #include "yb/yql/pggate/pg_tabledesc.h"
 #include "yb/yql/pggate/pggate_flags.h"
 #include "yb/yql/pggate/util/ybc_guc.h"
-#include "yb/util/flags.h"
 
 DECLARE_bool(use_node_hostname_for_local_tserver);
 DECLARE_int32(backfill_index_client_rpc_timeout_ms);
@@ -260,7 +256,7 @@ struct PerformData : public FetchBigDataCallback {
     }
   }
 
-  void BigDataFetched(Result<rpc::CallData>* call_data) {
+  void BigDataFetched(Result<rpc::CallData>* call_data) override {
     std::lock_guard lock(exchange_mutex);
     if (!call_data->ok()) {
       exchange_result = call_data->status();
@@ -906,6 +902,18 @@ class PgClient::Impl : public BigDataFetcher {
     return resp.version();
   }
 
+  Result<uint32_t> GetXClusterRole(uint32_t db_oid) {
+    tserver::PgGetXClusterRoleRequestPB req;
+    tserver::PgGetXClusterRoleResponsePB resp;
+
+    req.set_db_oid(db_oid);
+    RETURN_NOT_OK(DoSyncRPC(
+        &tserver::PgClientServiceProxy::GetXClusterRole, req, resp,
+        ash::PggateRPC::kGetXClusterRole));
+    RETURN_NOT_OK(ResponseStatus(resp));
+    return resp.xcluster_role();
+  }
+
   Status CreateSequencesDataTable() {
     tserver::PgCreateSequencesDataTableRequestPB req;
     tserver::PgCreateSequencesDataTableResponsePB resp;
@@ -1301,7 +1309,7 @@ class PgClient::Impl : public BigDataFetcher {
     }
 
     if (FLAGS_ysql_yb_enable_consistent_replication_from_hash_range) {
-      if (slot_hash_range != NULL) {
+      if (slot_hash_range != nullptr) {
         VLOG(1) << "Setting hash ranges in InitVirtualVWAL request - start_range: "
                 << slot_hash_range->start_range << ", end_range: " << slot_hash_range->end_range;
         auto req_slot_range = req.mutable_slot_hash_range();
@@ -1629,6 +1637,10 @@ Result<uint64_t> PgClient::GetCatalogMasterVersion() {
   return impl_->GetCatalogMasterVersion();
 }
 
+Result<uint32_t> PgClient::GetXClusterRole(uint32_t db_oid) {
+  return impl_->GetXClusterRole(db_oid);
+}
+
 Status PgClient::CreateSequencesDataTable() {
   return impl_->CreateSequencesDataTable();
 }
diff --git a/src/yb/yql/pggate/pg_client.h b/src/yb/yql/pggate/pg_client.h
index 0da94dd323..de94d3d4ea 100644
--- a/src/yb/yql/pggate/pg_client.h
+++ b/src/yb/yql/pggate/pg_client.h
@@ -34,11 +34,9 @@
 
 #include "yb/rpc/rpc_fwd.h"
 
-#include "yb/tserver/tserver_fwd.h"
 #include "yb/tserver/tserver_util_fwd.h"
 #include "yb/tserver/pg_client.fwd.h"
 
-#include "yb/util/enums.h"
 #include "yb/util/lw_function.h"
 #include "yb/util/monotime.h"
 #include "yb/util/ref_cnt_buffer.h"
@@ -158,6 +156,8 @@ class PgClient {
 
   Result<uint64_t> GetCatalogMasterVersion();
 
+  Result<uint32_t> GetXClusterRole(uint32_t db_oid);
+
   Status CreateSequencesDataTable();
 
   Result<client::YBTableName> DropTable(
diff --git a/src/yb/yql/pggate/pg_operation_buffer.cc b/src/yb/yql/pggate/pg_operation_buffer.cc
index b17da08d80..528312ada0 100644
--- a/src/yb/yql/pggate/pg_operation_buffer.cc
+++ b/src/yb/yql/pggate/pg_operation_buffer.cc
@@ -36,6 +36,7 @@
 #include "yb/gutil/casts.h"
 #include "yb/gutil/port.h"
 
+#include "yb/util/atomic.h"
 #include "yb/util/lw_function.h"
 #include "yb/util/status.h"
 
diff --git a/src/yb/yql/pggate/pg_select_index.cc b/src/yb/yql/pggate/pg_select_index.cc
index 377a4071ef..9898124247 100644
--- a/src/yb/yql/pggate/pg_select_index.cc
+++ b/src/yb/yql/pggate/pg_select_index.cc
@@ -15,6 +15,7 @@
 
 #include "yb/yql/pggate/pg_select_index.h"
 
+#include "yb/util/atomic.h"
 #include "yb/util/status_format.h"
 
 #include "yb/yql/pggate/pggate_flags.h"
diff --git a/src/yb/yql/pggate/pg_session.cc b/src/yb/yql/pggate/pg_session.cc
index 3c9edd25bc..e4a5e89a8c 100644
--- a/src/yb/yql/pggate/pg_session.cc
+++ b/src/yb/yql/pggate/pg_session.cc
@@ -16,38 +16,31 @@
 #include "yb/yql/pggate/pg_session.h"
 
 #include <algorithm>
-#include <future>
 #include <optional>
 #include <utility>
 
 #include "yb/client/table_info.h"
 
 #include "yb/common/pg_types.h"
-#include "yb/common/tablespace_parser.h"
-#include "yb/qlexpr/ql_expr.h"
-#include "yb/common/ql_value.h"
 #include "yb/common/read_hybrid_time.h"
 #include "yb/common/row_mark.h"
 #include "yb/common/schema.h"
-#include "yb/common/transaction_error.h"
+#include "yb/common/tablespace_parser.h"
 
 #include "yb/gutil/casts.h"
 
-#include "yb/tserver/pg_client.messages.h"
-
 #include "yb/util/flags.h"
 #include "yb/util/format.h"
 #include "yb/util/logging.h"
+#include "yb/util/oid_generator.h"
 #include "yb/util/result.h"
 #include "yb/util/status_format.h"
-#include "yb/util/string_util.h"
 
 #include "yb/yql/pggate/pg_client.h"
-#include "yb/yql/pggate/pg_expr.h"
 #include "yb/yql/pggate/pg_op.h"
 #include "yb/yql/pggate/pggate_flags.h"
-#include "yb/yql/pggate/ybc_pggate.h"
 #include "yb/yql/pggate/util/ybc_util.h"
+#include "yb/yql/pggate/ybc_pggate.h"
 
 using namespace std::literals;
 
@@ -498,6 +491,10 @@ Status PgSession::GetCatalogMasterVersion(uint64_t *version) {
   return Status::OK();
 }
 
+Result<int> PgSession::GetXClusterRole(uint32_t db_oid) {
+  return pg_client_.GetXClusterRole(db_oid);
+}
+
 Status PgSession::CancelTransaction(const unsigned char* transaction_id) {
   return pg_client_.CancelTransaction(transaction_id);
 }
diff --git a/src/yb/yql/pggate/pg_session.h b/src/yb/yql/pggate/pg_session.h
index 57796a1a2d..3733c24eab 100644
--- a/src/yb/yql/pggate/pg_session.h
+++ b/src/yb/yql/pggate/pg_session.h
@@ -28,10 +28,7 @@
 
 #include "yb/gutil/ref_counted.h"
 
-#include "yb/tserver/tserver_util_fwd.h"
-
 #include "yb/util/lw_function.h"
-#include "yb/util/oid_generator.h"
 #include "yb/util/result.h"
 
 #include "yb/yql/pggate/insert_on_conflict_buffer.h"
@@ -89,6 +86,8 @@ class PgSession final : public RefCountedThreadSafe<PgSession> {
 
   Status GetCatalogMasterVersion(uint64_t *version);
 
+  Result<int> GetXClusterRole(uint32_t db_oid);
+
   Status CancelTransaction(const unsigned char* transaction_id);
 
   // API for sequences data operations.
diff --git a/src/yb/yql/pggate/pggate.cc b/src/yb/yql/pggate/pggate.cc
index c64f00a96b..69ec2846d8 100644
--- a/src/yb/yql/pggate/pggate.cc
+++ b/src/yb/yql/pggate/pggate.cc
@@ -29,11 +29,9 @@
 
 #include "yb/dockv/partition.h"
 #include "yb/common/pg_system_attr.h"
-#include "yb/common/pgsql_protocol.pb.h"
 #include "yb/common/schema.h"
 
 #include "yb/dockv/doc_key.h"
-#include "yb/dockv/primitive_value.h"
 #include "yb/dockv/value_type.h"
 
 #include "yb/gutil/casts.h"
@@ -71,7 +69,6 @@
 #include "yb/yql/pggate/pg_session.h"
 #include "yb/yql/pggate/pg_shared_mem.h"
 #include "yb/yql/pggate/pg_statement.h"
-#include "yb/yql/pggate/pg_table.h"
 #include "yb/yql/pggate/pg_tabledesc.h"
 #include "yb/yql/pggate/pg_tools.h"
 #include "yb/yql/pggate/pg_truncate_colocated.h"
@@ -1836,6 +1833,10 @@ pid_t PgApiImpl::GetLocalTServerPid() const {
   return tserver_shared_object_->pid();
 }
 
+Result<int> PgApiImpl::GetXClusterRole(uint32_t db_oid) {
+  return pg_session_->GetXClusterRole(db_oid);
+}
+
 // Tuple Expression -----------------------------------------------------------------------------
 Status PgApiImpl::NewTupleExpr(
     PgStatement* stmt, const YbcPgTypeEntity* tuple_type_entity, const YbcPgTypeAttrs* type_attrs,
diff --git a/src/yb/yql/pggate/pggate.h b/src/yb/yql/pggate/pggate.h
index e717766335..142f5c871c 100644
--- a/src/yb/yql/pggate/pggate.h
+++ b/src/yb/yql/pggate/pggate.h
@@ -17,10 +17,9 @@
 #include <optional>
 #include <string>
 #include <string_view>
-#include <vector>
-#include <unordered_map>
 #include <unordered_set>
 #include <utility>
+#include <vector>
 
 #include "yb/client/tablet_server.h"
 
@@ -36,14 +35,12 @@
 #include "yb/rpc/rpc_fwd.h"
 
 #include "yb/server/hybrid_clock.h"
-#include "yb/server/server_base_options.h"
 
 #include "yb/tserver/tserver_util_fwd.h"
 
 #include "yb/util/mem_tracker.h"
-#include "yb/util/memory/arena.h"
+#include "yb/util/metrics.h"
 #include "yb/util/result.h"
-#include "yb/util/shared_mem.h"
 #include "yb/util/status.h"
 #include "yb/util/status_fwd.h"
 #include "yb/util/uuid.h"
@@ -166,6 +163,7 @@ class PgApiImpl {
   uint64_t GetSharedAuthKey() const;
   const unsigned char *GetLocalTserverUuid() const;
   pid_t GetLocalTServerPid() const;
+  Result<int> GetXClusterRole(uint32_t db_oid);
 
   Status NewTupleExpr(
     YbcPgStatement stmt, const YbcPgTypeEntity *tuple_type_entity,
diff --git a/src/yb/yql/pggate/util/ybc_guc.h b/src/yb/yql/pggate/util/ybc_guc.h
index f8af31df42..eb78aecdbe 100644
--- a/src/yb/yql/pggate/util/ybc_guc.h
+++ b/src/yb/yql/pggate/util/ybc_guc.h
@@ -15,6 +15,7 @@
 
 #pragma once
 
+#include <stdbool.h>  // Needed for bool in C.
 #include <stdint.h>
 
 #ifdef __cplusplus
diff --git a/src/yb/yql/pggate/ybc_pggate.cc b/src/yb/yql/pggate/ybc_pggate.cc
index eda69e0c5b..787cef0138 100644
--- a/src/yb/yql/pggate/ybc_pggate.cc
+++ b/src/yb/yql/pggate/ybc_pggate.cc
@@ -14,10 +14,8 @@
 
 #include <algorithm>
 #include <atomic>
-#include <iterator>
 #include <limits>
 #include <memory>
-#include <set>
 #include <string>
 #include <string_view>
 #include <thread>
@@ -36,11 +34,8 @@
 #include "yb/common/ql_value.h"
 #include "yb/common/schema.h"
 
-#include "yb/dockv/doc_key.h"
-#include "yb/dockv/partition.h"
 #include "yb/dockv/pg_key_decoder.h"
 #include "yb/dockv/pg_row.h"
-#include "yb/dockv/primitive_value.h"
 #include "yb/dockv/reader_projection.h"
 #include "yb/dockv/value_type.h"
 
@@ -67,8 +62,6 @@
 
 #include "yb/yql/pggate/pg_expr.h"
 #include "yb/yql/pggate/pg_gate_fwd.h"
-#include "yb/yql/pggate/pg_memctx.h"
-#include "yb/yql/pggate/pg_statement.h"
 #include "yb/yql/pggate/pg_tabledesc.h"
 #include "yb/yql/pggate/pg_tools.h"
 #include "yb/yql/pggate/pg_value.h"
@@ -790,7 +783,7 @@ void YBCDumpTcMallocHeapProfile(bool peak_heap, size_t max_call_stacks) {
 // YB Bitmap Scan Operations
 //--------------------------------------------------------------------------------------------------
 
-typedef std::unordered_set<Slice, Slice::Hash> UnorderedSliceSet;
+using UnorderedSliceSet = std::unordered_set<Slice, Slice::Hash>;
 
 static void FreeSlice(Slice slice) {
   delete[] slice.data(), slice.size();
@@ -880,7 +873,7 @@ YbcConstSliceVector YBCBitmapGetVectorRange(YbcConstSliceVector vec, size_t star
   const size_t end_index = std::min(start + length, v->size());
 
   if (end_index <= start)
-    return NULL;
+    return nullptr;
 
   return new std::vector<Slice>(v->begin() + start, v->begin() + end_index);
 }
@@ -981,7 +974,7 @@ YbcStatus YBCPgGetCatalogMasterVersion(uint64_t *version) {
 }
 
 YbcStatus YBCPgInvalidateTableCacheByTableId(const char *table_id) {
-  if (table_id == NULL) {
+  if (table_id == nullptr) {
     return ToYBCStatus(STATUS(InvalidArgument, "table_id is null"));
   }
   std::string table_id_str = table_id;
@@ -1596,7 +1589,7 @@ YbcStatus YBCPgNewInsertBlock(
       PgObjectId(database_oid, table_oid), is_region_local, transaction_setting);
   if (result.ok()) {
     *handle = *result;
-    return NULL;
+    return nullptr;
   }
   return ToYBCStatus(result.status());
 }
@@ -2196,7 +2189,7 @@ YbcStatus YBCGetTserverCatalogMessageLists(
       // This entire invalidation message list is a PG null. This will force full
       // catalog cache refresh.
       current.num_bytes = 0;
-      current.message_list = NULL;
+      current.message_list = nullptr;
     }
   }
   return YBCStatusOK();
@@ -2314,7 +2307,7 @@ YbcStatus YBCGetTabletServerHosts(YbcServerDescriptor **servers, size_t *count)
   }
   const auto &servers_info = result.get().tablet_servers;
   *count = servers_info.size();
-  *servers = NULL;
+  *servers = nullptr;
   if (!servers_info.empty()) {
     *servers = static_cast<YbcServerDescriptor *>(
         YBCPAlloc(sizeof(YbcServerDescriptor) * servers_info.size()));
@@ -2535,7 +2528,7 @@ YbcStatus YBCPgListReplicationSlots(
 
   const auto &replication_slots_info = result.get().replication_slots();
   *DCHECK_NOTNULL(numreplicationslots) = replication_slots_info.size();
-  *DCHECK_NOTNULL(replication_slots) = NULL;
+  *DCHECK_NOTNULL(replication_slots) = nullptr;
   if (!replication_slots_info.empty()) {
     *replication_slots = static_cast<YbcReplicationSlotDescriptor *>(
         YBCPAlloc(sizeof(YbcReplicationSlotDescriptor) * replication_slots_info.size()));
@@ -2653,7 +2646,7 @@ YbcStatus YBCYcqlStatementStats(YbcYCQLStatementStats** stats, size_t* num_stats
   }
   const auto& statements_stat = result->statements();
   *num_stats = statements_stat.size();
-  *stats = NULL;
+  *stats = nullptr;
   if (!statements_stat.empty()) {
     *stats = static_cast<YbcYCQLStatementStats*>(
         YBCPAlloc(sizeof(YbcYCQLStatementStats) * statements_stat.size()));
@@ -2777,7 +2770,7 @@ YbcStatus YBCPgGetCDCConsistentChanges(
     return ToYBCStatus(result.status());
   }
 
-  *DCHECK_NOTNULL(record_batch) = NULL;
+  *DCHECK_NOTNULL(record_batch) = nullptr;
   const auto resp = result.get();
   VLOG(4) << "The GetConsistentChangesForCDC response: " << resp.DebugString();
   auto response_to_pg_conversion_start = GetCurrentTimeMicros();
@@ -3054,6 +3047,14 @@ YbcStatus YBCDatabaseClones(YbcPgDatabaseCloneInfo** database_clones, size_t* co
 
 bool YBCIsCronLeader() { return pgapi->IsCronLeader(); }
 
+int YBCGetXClusterRole(uint32_t db_oid) {
+  auto result = pgapi->GetXClusterRole(db_oid);
+  if (result.ok()) {
+    return *result;
+  }
+  return XClusterNamespaceInfoPB_XClusterRole_UNAVAILABLE;
+}
+
 YbcStatus YBCSetCronLastMinute(int64_t last_minute) {
   return ToYBCStatus(pgapi->SetCronLastMinute(last_minute));
 }
diff --git a/src/yb/yql/pggate/ybc_pggate.h b/src/yb/yql/pggate/ybc_pggate.h
index c226fbdee6..3dd677b46d 100644
--- a/src/yb/yql/pggate/ybc_pggate.h
+++ b/src/yb/yql/pggate/ybc_pggate.h
@@ -143,6 +143,8 @@ bool YBCIsCronLeader();
 YbcStatus YBCSetCronLastMinute(int64_t last_minute);
 YbcStatus YBCGetCronLastMinute(int64_t* last_minute);
 
+int YBCGetXClusterRole(uint32_t db_oid);
+
 //--------------------------------------------------------------------------------------------------
 // YB Bitmap Scan Operations
 //--------------------------------------------------------------------------------------------------
