diff --git a/src/yb/util/signal_util.cc b/src/yb/util/signal_util.cc
index dc78832fa8..2d4bdc54e8 100644
--- a/src/yb/util/signal_util.cc
+++ b/src/yb/util/signal_util.cc
@@ -61,7 +61,8 @@ const std::vector<int> kYsqlHandledSignals{
     SIGUSR1, // procsignal_sigusr1_handler
     SIGFPE, // FloatExceptionHandler
     SIGTERM, // bgworker_die
-    SIGQUIT // bgworker_quickdie
+    SIGQUIT, // bgworker_quickdie
+    SIGALRM // handle_sig_alarm
 };
 
 Result<sigset_t> ThreadYsqlSignalMaskBlock() {
diff --git a/src/yb/yql/pggate/ybc_pggate.cc b/src/yb/yql/pggate/ybc_pggate.cc
index d9bacd64cf..548503851a 100644
--- a/src/yb/yql/pggate/ybc_pggate.cc
+++ b/src/yb/yql/pggate/ybc_pggate.cc
@@ -522,8 +522,8 @@ void YBCInitPgGate(const YBCPgTypeEntity *data_type_table, int count, PgCallback
 }
 
 void YBCDestroyPgGate() {
-  LOG_IF(DFATAL, !is_main_thread())
-    << __PRETTY_FUNCTION__ << " should only be invoked from the main thread";
+  LOG_IF(FATAL, !is_main_thread())
+      << __PRETTY_FUNCTION__ << " should only be invoked from the main thread";
 
   if (pgapi_shutdown_done.exchange(true)) {
     LOG(DFATAL) << __PRETTY_FUNCTION__ << " should only be called once";
@@ -537,8 +537,8 @@ void YBCDestroyPgGate() {
 }
 
 void YBCInterruptPgGate() {
-  LOG_IF(DFATAL, !is_main_thread())
-    << __PRETTY_FUNCTION__ << " should only be invoked from the main thread";
+  LOG_IF(FATAL, !is_main_thread())
+      << __PRETTY_FUNCTION__ << " should only be invoked from the main thread";
 
   pgapi->Interrupt();
 }
diff --git a/src/yb/yql/process_wrapper/process_wrapper.cc b/src/yb/yql/process_wrapper/process_wrapper.cc
index a4f819cf34..9630f2d863 100644
--- a/src/yb/yql/process_wrapper/process_wrapper.cc
+++ b/src/yb/yql/process_wrapper/process_wrapper.cc
@@ -44,14 +44,7 @@ Result<int> ProcessWrapper::Wait() {
   return proc_->Wait();
 }
 
-void ProcessWrapper::Kill() {
-  // TODO(fizaa): Use SIGQUIT in asan build until GH #15168 is fixed.
-#ifdef ADDRESS_SANITIZER
-  Kill(SIGQUIT);
-#else
-  Kill(SIGINT);
-#endif
-}
+void ProcessWrapper::Kill() { Kill(SIGQUIT); }
 
 void ProcessWrapper::Kill(int signal) {
   WARN_NOT_OK(proc_->Kill(signal), "Kill process failed");
@@ -163,20 +156,17 @@ void ProcessSupervisor::Stop() {
     if (thread_finished_latch_.WaitFor(10s)) {
       break;
     }
-    auto passed = MonoDelta(CoarseMonoClock::now() - start);
-    bool force_kill = passed >= 1min;
-    auto message = Format(
-        "$0 did not gracefully exist after $1. $2.",
-        GetProcessName(), passed,
-        force_kill ? "Force killing it" : "Retry");
-    if (force_kill) {
-      LOG(DFATAL) << message;
+    const auto passed = MonoDelta(CoarseMonoClock::now() - start);
+    if (passed >= 1min) {
+      LOG(DFATAL) << GetProcessName() << " did not gracefully exit after " << passed
+                  << ". Force killing it with SIGKILL";
+      std::lock_guard lock(mtx_);
+      if (process_wrapper_) {
+        process_wrapper_->Kill(SIGKILL);
+      }
+      break;
     } else {
-      LOG(WARNING) << message;
-    }
-    std::lock_guard lock(mtx_);
-    if (process_wrapper_) {
-      process_wrapper_->Kill(force_kill ? SIGQUIT : SIGINT);
+      LOG(WARNING) << GetProcessName() << " did not gracefully exist after " << passed;
     }
   }
   supervisor_thread_->Join();
