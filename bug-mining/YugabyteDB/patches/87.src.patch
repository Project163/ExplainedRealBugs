diff --git a/src/yb/util/mem_tracker.cc b/src/yb/util/mem_tracker.cc
index a53d751efa..33a8bbdc56 100644
--- a/src/yb/util/mem_tracker.cc
+++ b/src/yb/util/mem_tracker.cc
@@ -59,6 +59,7 @@
 #include "yb/util/status.h"
 #include "yb/util/status_log.h"
 #include "yb/util/logging.h"
+#include "yb/util/tcmalloc_profile.h"
 #include "yb/util/tcmalloc_trace.h"
 #include "yb/util/tcmalloc_util.h"
 #include "yb/util/tcmalloc_impl_util.h"
@@ -267,8 +268,8 @@ void MemTracker::CreateRootTracker() {
 
   LOG(INFO) << "Root memory limit is " << limit;
   root_tracker = std::make_shared<MemTracker>(
-      limit, "root", std::move(consumption_functor), nullptr /* parent */, AddToParent::kTrue,
-      CreateMetrics::kFalse);
+      limit, "root", std::move(consumption_functor), nullptr /* parent */, AddToParent::kFalse,
+      CreateMetrics::kFalse, std::string() /* metric_name */, IsRootTracker::kTrue);
 }
 
 shared_ptr<MemTracker> MemTracker::CreateTracker(int64_t byte_limit,
@@ -300,7 +301,7 @@ shared_ptr<MemTracker> MemTracker::CreateChild(int64_t byte_limit,
   }
   auto result = std::make_shared<MemTracker>(
       byte_limit, id, std::move(consumption_functor), shared_from_this(), add_to_parent,
-          create_metrics, metric_name);
+          create_metrics, metric_name, IsRootTracker::kFalse);
   auto [iter, inserted] = child_trackers_.emplace(id, result);
   if (!inserted) {
     auto& tracker_weak_ptr = iter->second;
@@ -318,7 +319,7 @@ shared_ptr<MemTracker> MemTracker::CreateChild(int64_t byte_limit,
 MemTracker::MemTracker(int64_t byte_limit, const string& id,
                        ConsumptionFunctor consumption_functor, std::shared_ptr<MemTracker> parent,
                        AddToParent add_to_parent, CreateMetrics create_metrics,
-                       const std::string& metric_name)
+                       const std::string& metric_name, IsRootTracker is_root_tracker)
     : limit_(byte_limit),
       soft_limit_(limit_ == -1 ? -1 : (limit_ * FLAGS_memory_limit_soft_percentage) / 100),
       id_(id),
@@ -328,7 +329,8 @@ MemTracker::MemTracker(int64_t byte_limit, const string& id,
       enable_logging_(FLAGS_mem_tracker_logging),
       log_stack_(FLAGS_mem_tracker_log_stack_trace),
       add_to_parent_(add_to_parent),
-      metric_name_(CreateMetricName(*this, metric_name)) {
+      metric_name_(CreateMetricName(*this, metric_name)),
+      is_root_tracker_(is_root_tracker) {
   VLOG(1) << "Creating tracker " << ToString();
   UpdateConsumption();
 
@@ -617,30 +619,43 @@ bool MemTracker::LimitExceeded() {
 }
 
 SoftLimitExceededResult MemTracker::SoftLimitExceeded(double* score) {
-  // Did we exceed the actual limit?
-  if (LimitExceeded()) {
-    return {ToString(), true, consumption() * 100.0 / limit()};
-  }
+  int64_t usage = consumption();
+  // If we have exceed the hard limit, we can skip the soft limit calculations.
+  if (!LimitExceeded()) {
+    // No soft limit defined.
+    if (!has_limit() || limit_ == soft_limit_) {
+      return SoftLimitExceededResult::NotExceeded();
+    }
 
-  // No soft limit defined.
-  if (!has_limit() || limit_ == soft_limit_) {
-    return SoftLimitExceededResult::NotExceeded();
-  }
+    // Are we under the soft limit threshold?
+    if (usage < soft_limit_) {
+      return SoftLimitExceededResult::NotExceeded();
+    }
 
-  // Are we under the soft limit threshold?
-  int64_t usage = consumption();
-  if (usage < soft_limit_) {
-    return SoftLimitExceededResult::NotExceeded();
-  }
+    // We're over the threshold; were we randomly chosen to be over the soft limit?
+    if (*score == 0.0) {
+      *score = RandomUniformReal<double>();
+    }
+    if (usage + (limit_ - soft_limit_) * *score <= limit_) {
+      return SoftLimitExceededResult::NotExceeded();
+    }
 
-  // We're over the threshold; were we randomly chosen to be over the soft limit?
-  if (*score == 0.0) {
-    *score = RandomUniformReal<double>();
+    if (!GcMemory(soft_limit_)) {
+      // We were able to GC enough to be below the soft memory limit.
+      return SoftLimitExceededResult::NotExceeded();
+    }
   }
-  if (usage + (limit_ - soft_limit_) * *score > limit_ && GcMemory(soft_limit_)) {
-    return {ToString(), true, usage * 100.0 / limit()};
+
+  // Soft limit exceeded.
+  // Dump heap snapshot for debugging if this is the root tracker (and we have not dumped recently).
+  if (IsRoot()) {
+    DumpHeapSnapshotUnlessThrottled();
   }
-  return SoftLimitExceededResult::NotExceeded();
+  return SoftLimitExceededResult {
+    .tracker_path = ToString(),
+    .exceeded = true,
+    .current_capacity_pct = usage * 100.0 / limit()
+  };
 }
 
 SoftLimitExceededResult MemTracker::AnySoftLimitExceeded(double* score) {
diff --git a/src/yb/util/mem_tracker.h b/src/yb/util/mem_tracker.h
index 796765f227..f06134d149 100644
--- a/src/yb/util/mem_tracker.h
+++ b/src/yb/util/mem_tracker.h
@@ -68,9 +68,10 @@ class GarbageCollector {
   virtual void CollectGarbage(size_t required) = 0;
 };
 
-YB_STRONGLY_TYPED_BOOL(MayExist);
 YB_STRONGLY_TYPED_BOOL(AddToParent);
 YB_STRONGLY_TYPED_BOOL(CreateMetrics);
+YB_STRONGLY_TYPED_BOOL(IsRootTracker);
+YB_STRONGLY_TYPED_BOOL(MayExist);
 YB_STRONGLY_TYPED_BOOL(OnlyChildren);
 
 using ConsumptionFunctor = std::function<int64_t()>;
@@ -151,7 +152,8 @@ class MemTracker : public std::enable_shared_from_this<MemTracker> {
              ConsumptionFunctor consumption_functor,
              std::shared_ptr<MemTracker> parent,
              AddToParent add_to_parent, CreateMetrics create_metrics,
-             const std::string& metric_name = std::string());
+             const std::string& metric_name,
+             IsRootTracker is_root_tracker);
 
   ~MemTracker();
 
@@ -438,6 +440,10 @@ class MemTracker : public std::enable_shared_from_this<MemTracker> {
   // This is needed in some tests to create deterministic GC behavior.
   static void TEST_SetReleasedMemorySinceGC(int64_t bytes);
 
+  bool IsRoot() {
+    return is_root_tracker_;
+  }
+
  private:
   template<class GC>
   using GarbageCollectorsContainer = boost::container::small_vector<GC, 8>;
@@ -520,6 +526,8 @@ class MemTracker : public std::enable_shared_from_this<MemTracker> {
 
   // Concatenated with parents tracker's metric name.
   const std::string metric_name_;
+
+  const bool is_root_tracker_;
 };
 
 // An std::allocator that manipulates a MemTracker during allocation
diff --git a/src/yb/util/tcmalloc_profile-test.cc b/src/yb/util/tcmalloc_profile-test.cc
index 84a8efe441..1b9541fb04 100644
--- a/src/yb/util/tcmalloc_profile-test.cc
+++ b/src/yb/util/tcmalloc_profile-test.cc
@@ -24,6 +24,7 @@
 
 #include "yb/util/flags.h"
 #include "yb/util/logging.h"
+#include "yb/util/mem_tracker.h"
 #include "yb/util/monotime.h"
 #include "yb/util/size_literals.h"
 #include "yb/util/tcmalloc_util.h"
@@ -31,6 +32,7 @@
 #include "yb/util/test_util.h"
 #include "yb/util/thread.h"
 
+DECLARE_int32(dump_heap_snapshot_min_interval_sec);
 DECLARE_int32(v);
 DECLARE_string(vmodule);
 
@@ -247,6 +249,61 @@ TEST_F(SamplingProfilerTest, EstimatedBytesAndCount) {
   ASSERT_NEAR(actual_bytes, estimated_bytes, margin);
 }
 
+TEST(ThrottledHeapSnapshotDumperTest, DoNotDumpIfBelowSoftLimit) {
+  // Create a fake root tracker that does not use a consumption_functor as its source of truth.
+  auto hard_limit = 100000;
+  auto root_tracker = std::make_shared<MemTracker>(
+      hard_limit, "root", ConsumptionFunctor(), nullptr /* parent */, AddToParent::kFalse,
+      CreateMetrics::kFalse, std::string() /* metric_name */, IsRootTracker::kTrue);
+
+  // Should not dump in SoftLimitExceeded because we have not exceeded the soft limit.
+  root_tracker->Consume(root_tracker->soft_limit());
+  ASSERT_FALSE(root_tracker->AnySoftLimitExceeded(/*score=*/ 1.0).exceeded);
+
+  // Should dump because we did not dump during the SoftLimitExceeded call.
+  ASSERT_TRUE(DumpHeapSnapshotUnlessThrottled());
+}
+
+TEST(ThrottledHeapSnapshotDumperTest, DumpIfSoftLimitExceeded) {
+  // Create a fake root tracker that does not use a consumption_functor as its source of truth.
+  auto hard_limit = 100000;
+  auto root_tracker = std::make_shared<MemTracker>(
+      hard_limit, "root", ConsumptionFunctor(), nullptr /* parent */, AddToParent::kFalse,
+      CreateMetrics::kFalse, std::string() /* metric_name */, IsRootTracker::kTrue);
+
+  // Exceed the soft memory limit.
+  root_tracker->Consume(root_tracker->soft_limit() + 1);
+
+  // Deterministically choose to reject this request.
+  ASSERT_TRUE(root_tracker->AnySoftLimitExceeded(/*score=*/ 1.0).exceeded);
+
+  // The heap snapshot should not dump, because it just did during the SoftLimitExceeded call.
+  ASSERT_FALSE(DumpHeapSnapshotUnlessThrottled());
+}
+
+TEST(ThrottledHeapSnapshotDumperTest, OnlyDumpOnRootRejection) {
+  // Check that only a child tracker hitting its soft memory limit does not cause a dump.
+  auto root_hard_limit = 100000;
+  auto child_hard_limit = 1000;
+
+  auto root_tracker = std::make_shared<MemTracker>(
+      root_hard_limit, "root", ConsumptionFunctor(), nullptr /* parent */, AddToParent::kTrue,
+      CreateMetrics::kFalse, std::string() /* metric_name */, IsRootTracker::kTrue);
+  auto child_tracker = MemTracker::CreateTracker(
+      child_hard_limit, "child", ConsumptionFunctor(), root_tracker);
+
+  // Exceed the soft memory limit.
+  child_tracker->Consume(child_tracker->soft_limit() + 1);
+
+  // Deterministically choose to reject this request.
+  auto result = child_tracker->AnySoftLimitExceeded(1.0);
+  ASSERT_TRUE(result.exceeded);
+  ASSERT_STR_CONTAINS(result.tracker_path, "child");
+
+  // The heap snapshot should dump, because it did not dump SoftLimitExceeded call.
+  ASSERT_TRUE(DumpHeapSnapshotUnlessThrottled());
+}
+
 #endif // YB_GOOGLE_TCMALLOC
 
 #endif // YB_TCMALLOC_ENABLED
diff --git a/src/yb/util/tcmalloc_profile.cc b/src/yb/util/tcmalloc_profile.cc
index 5424710521..9350da6ca1 100644
--- a/src/yb/util/tcmalloc_profile.cc
+++ b/src/yb/util/tcmalloc_profile.cc
@@ -69,7 +69,8 @@ bool Symbolize(void *pc, char *out, int out_size) {
 #endif
 
 Result<std::vector<Sample>> GetAggregateAndSortHeapSnapshot(
-    SampleOrder order, HeapSnapshotType snapshot_type, SampleFilter filter) {
+    SampleOrder order, HeapSnapshotType snapshot_type, SampleFilter filter,
+    const std::string& separator) {
 #if YB_GPERFTOOLS_TCMALLOC
   switch (order) {
     case SampleOrder::kSampledBytes:
@@ -91,10 +92,10 @@ Result<std::vector<Sample>> GetAggregateAndSortHeapSnapshot(
     case SampleFilter::kAllSamples:
       break;
   }
-  return GetAggregateAndSortHeapSnapshotGperftools(order);
+  return GetAggregateAndSortHeapSnapshotGperftools(order, separator);
 #elif YB_GOOGLE_TCMALLOC
   auto current_profile = GetHeapSnapshot(snapshot_type);
-  return AggregateAndSortProfile(current_profile, filter, order);
+  return AggregateAndSortProfile(current_profile, filter, order, separator);
 #else
   return STATUS(NotSupported, "Heap snapshot is only available if tcmalloc is enabled.");
 #endif
@@ -134,7 +135,8 @@ tcmalloc::Profile GetHeapSnapshot(HeapSnapshotType snapshot_type) {
 }
 
 std::vector<Sample> AggregateAndSortProfile(
-    const tcmalloc::Profile& profile, SampleFilter filter, SampleOrder order) {
+    const tcmalloc::Profile& profile, SampleFilter filter, SampleOrder order,
+    const std::string& separator) {
   LOG(INFO) << "Analyzing TCMalloc sampling profile";
   int failed_symbolizations = 0;
   std::unordered_map<std::string, SampleInfo> samples_map;
@@ -157,9 +159,10 @@ std::vector<Sample> AggregateAndSortProfile(
     std::stringstream sstream;
     // 256 is arbitrary. Symbolize will return false if the symbol is longer than that.
     char buf[256];
+    sstream << separator;
     for (int64_t i = 0; i < sample.depth; ++i) {
       if (Symbolize(sample.stack[i], buf, sizeof(buf))) {
-        sstream << buf << std::endl;
+        sstream << buf << separator;
       } else {
         ++failed_symbolizations;
         sstream << "Failed to symbolize" << std::endl;
@@ -218,7 +221,8 @@ void* GetSampleProgramCounter(void** entry, uintptr_t i) {
 
 // Do not call this directly, instead use GetAggregateAndSortHeapSnapshot.
 // Assumes that the supplied sample order is valid for gperftools tcmalloc.
-std::vector<Sample> GetAggregateAndSortHeapSnapshotGperftools(SampleOrder order) {
+std::vector<Sample> GetAggregateAndSortHeapSnapshotGperftools(
+    SampleOrder order, const std::string& separator) {
   int sample_period;
   void** samples = MallocExtension::instance()->ReadStackTraces(&sample_period);
 
@@ -234,7 +238,7 @@ std::vector<Sample> GetAggregateAndSortHeapSnapshotGperftools(SampleOrder order)
     char buf[256];
     for (uintptr_t i = 0; i < GetSampleDepth(sample); ++i) {
       if (Symbolize(GetSampleProgramCounter(sample, i), buf, sizeof(buf))) {
-        sstream << buf << std::endl;
+        sstream << buf << separator;
       } else {
         ++failed_symbolizations;
         sstream << "Failed to symbolize" << std::endl;
@@ -266,4 +270,53 @@ std::vector<Sample> GetAggregateAndSortHeapSnapshotGperftools(SampleOrder order)
 
 #endif // YB_GPERFTOOLS_TCMALLOC
 
+#if YB_GOOGLE_TCMALLOC
+// Initialize to nullopt to indicate that we have not yet dumped a snapshot.
+static std::atomic<std::optional<yb::CoarseTimePoint>> last_heap_snapshot_dump_time(std::nullopt);
+#endif // YB_GOOGLE_TCMALLOC
+
+// Returns true if we attempted to dump the heap snapshot, false otherwise.
+bool DumpHeapSnapshotUnlessThrottled() {
+#if YB_GOOGLE_TCMALLOC
+  auto orig_last_dump_time = last_heap_snapshot_dump_time.load();
+  if (orig_last_dump_time) {
+    auto time_since_last_log_sec = ToSeconds(CoarseMonoClock::Now() - *orig_last_dump_time);
+    if (time_since_last_log_sec <= FLAGS_dump_heap_snapshot_min_interval_sec) {
+      VLOG(3) << Format(
+          "Not dumping snapshot since it was last dumped $0 seconds ago", time_since_last_log_sec);
+      return false;
+    }
+  }
+
+  if (!last_heap_snapshot_dump_time.compare_exchange_strong(
+      orig_last_dump_time, CoarseMonoClock::Now())) {
+    // Lost the race to update last_heap_snapshot_dump_time.
+    return false;
+  }
+
+  // Use a non-newline separator to keep logs readable.
+  auto result = GetAggregateAndSortHeapSnapshot(
+      SampleOrder::kEstimatedBytes, HeapSnapshotType::kCurrentHeap, SampleFilter::kAllSamples,
+      ";;" /* separator */);
+  if (!result.ok()) {
+    LOG(WARNING) << result.status();
+    return false;
+  }
+
+  const int32 stacks_to_dump =
+      std::min(FLAGS_dump_heap_snapshot_max_call_stacks, narrow_cast<int32>(result->size()));
+  LOG(INFO) << Format("Dumping top $0 stacks from heap snapshot", stacks_to_dump);
+  for (auto i = 0; i < stacks_to_dump; ++i) {
+    const auto& [stack, sample_info] = (*result)[i];
+    LOG(INFO) << Format(
+        "Estimated bytes: $0, estimated count: $1, sampled bytes: $2, sampled count: $3, stack: $4",
+        sample_info.estimated_bytes, sample_info.estimated_count,
+        sample_info.sampled_allocated_bytes, sample_info.sampled_count, stack);
+  }
+  return true;
+#else
+  return false;
+#endif
+}
+
 } // namespace yb
diff --git a/src/yb/util/tcmalloc_profile.h b/src/yb/util/tcmalloc_profile.h
index 21492a5902..b137aaad88 100644
--- a/src/yb/util/tcmalloc_profile.h
+++ b/src/yb/util/tcmalloc_profile.h
@@ -49,7 +49,8 @@ YB_DEFINE_ENUM(SampleFilter, (kAllSamples)(kGrowthOnly));
 Result<std::vector<Sample>> GetAggregateAndSortHeapSnapshot(
     SampleOrder order = SampleOrder::kSampledCount,
     HeapSnapshotType snapshot_type = HeapSnapshotType::kCurrentHeap,
-    SampleFilter filter = SampleFilter::kAllSamples);
+    SampleFilter filter = SampleFilter::kAllSamples,
+    const std::string& separator = "\n");
 
 #if YB_GOOGLE_TCMALLOC
 
@@ -59,14 +60,18 @@ Result<tcmalloc::Profile> GetHeapProfile(int seconds, int64_t sample_freq_bytes)
 tcmalloc::Profile GetHeapSnapshot(HeapSnapshotType snapshot_type);
 
 std::vector<Sample> AggregateAndSortProfile(
-    const tcmalloc::Profile& profile, SampleFilter filter, SampleOrder order);
+    const tcmalloc::Profile& profile, SampleFilter filter, SampleOrder order,
+    const std::string& separator = "\n");
 
 #endif // YB_GOOGLE_TCMALLOC
 
 #if YB_GPERFTOOLS_TCMALLOC
 
-std::vector<Sample> GetAggregateAndSortHeapSnapshotGperftools(SampleOrder order);
+std::vector<Sample> GetAggregateAndSortHeapSnapshotGperftools(
+    SampleOrder order, const std::string& separator);
 
 #endif // YB_GPERFTOOLS_TCMALLOC
 
+bool DumpHeapSnapshotUnlessThrottled();
+
 } // namespace yb
