diff --git a/src/postgres/src/backend/catalog/pg_type.c b/src/postgres/src/backend/catalog/pg_type.c
index 1f3d3989ff..fecca5aeea 100644
--- a/src/postgres/src/backend/catalog/pg_type.c
+++ b/src/postgres/src/backend/catalog/pg_type.c
@@ -39,6 +39,7 @@
 
 /* YB includes */
 #include "catalog/catalog.h"
+#include "catalog/yb_oid_assignment.h"
 #include "pg_yb_utils.h"
 
 static char *makeUniqueTypeName(const char *typeName, Oid typeNamespace,
@@ -142,6 +143,11 @@ TypeShellMake(const char *typeName, Oid typeNamespace, Oid ownerId)
 		typoid = binary_upgrade_next_pg_type_oid;
 		binary_upgrade_next_pg_type_oid = InvalidOid;
 	}
+	else if (YbUsingTypeOidAssignment())
+	{
+		typoid = YbLookupOidAssignmentForType(get_namespace_name(typeNamespace),
+											  typeName);
+	}
 	else
 	{
 		typoid = GetNewOidWithIndex(pg_type_desc, TypeOidIndexId,
@@ -524,6 +530,11 @@ TypeCreate(Oid newTypeOid,
 					(errcode(ERRCODE_INVALID_TABLE_DEFINITION),
 					 errmsg("system relations must have an explicit type OID!")));
 		}
+		else if (YbUsingTypeOidAssignment())
+		{
+			typeObjectId = YbLookupOidAssignmentForType(get_namespace_name(typeNamespace),
+														typeName);
+		}
 		/* else allow system to assign oid */
 		else
 		{
diff --git a/src/postgres/src/backend/catalog/yb_catalog/yb_oid_assignment.c b/src/postgres/src/backend/catalog/yb_catalog/yb_oid_assignment.c
index e9fefc1269..b0b0e3a111 100644
--- a/src/postgres/src/backend/catalog/yb_catalog/yb_oid_assignment.c
+++ b/src/postgres/src/backend/catalog/yb_catalog/yb_oid_assignment.c
@@ -21,7 +21,6 @@
  *--------------------------------------------------------------------------------------------------
  */
 
-
 #include "postgres.h"
 
 #include "utils/builtins.h"
@@ -32,7 +31,8 @@
 static HTAB *yb_enum_label_assignment_map = NULL;
 static bool yb_enum_label_assignment_exists = false;
 
-static HTAB *yb_sequence_oid_assignment_map = NULL;
+static HTAB *yb_oid_assignment_map = NULL;
+static bool yb_type_oid_assignment_exists = false;
 static bool yb_sequence_oid_assignment_exists = false;
 
 /*
@@ -66,12 +66,6 @@ YbClearEnumLabelMap(void)
 static void
 YbCreateEnumLabelMapKey(Oid enum_oid, const char *label, char *key_buffer)
 {
-	/*
-	 * For now ignore enum OID field.  See YbLookupOidAssignmentForEnumLabel
-	 * for why.
-	 */
-	enum_oid = 42;
-
 	int written_bytes = snprintf(key_buffer,
 								 YB_ENUM_LABEL_ASSIGNMENT_MAP_KEY_SIZE, "%u.%s",
 								 enum_oid, label);
@@ -114,40 +108,44 @@ YbLookupOidForEnumLabel(Oid enum_oid, const char *label)
 	return InvalidOid;
 }
 
+#define YB_OID_KIND_TYPE "type"
+#define YB_OID_KIND_SEQUENCE "sequence"
+
 /*
- * yb_sequence_oid_assignment_map key format is <schema>.<name>\0
+ * yb_oid_assignment_map key format is <oid_kind>.<schema>.<name>\0
+ * <oid_kind>\0 is guaranteed to fit in 20 characters.
  * <identifier>\0 is guaranteed to fit in NAMEDATALEN characters.
  */
-#define YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE (NAMEDATALEN + NAMEDATALEN)
+#define YB_OID_ASSIGNMENT_MAP_KEY_SIZE (20 + NAMEDATALEN + NAMEDATALEN)
 
-typedef struct YbSequenceOidAssignmentMapEntry {
-	/* encodes schema, name */
-	char		key[YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE];
+typedef struct YbOidAssignmentMapEntry {
+	/* encodes oid_kind, schema, name */
+	char		key[YB_OID_ASSIGNMENT_MAP_KEY_SIZE];
 	Oid			oid;
-} YbSequenceOidAssignmentMapEntry;
+} YbOidAssignmentMapEntry;
 
 static void
-YbClearSequenceOidMap(void)
+YbClearOidMap(void)
 {
 	HASHCTL ctl;
 
-	if (yb_sequence_oid_assignment_map != NULL)
-		hash_destroy(yb_sequence_oid_assignment_map);
+	if (yb_oid_assignment_map != NULL)
+		hash_destroy(yb_oid_assignment_map);
 	memset(&ctl, 0, sizeof(ctl));
-	ctl.keysize = YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE;
-	ctl.entrysize = sizeof(YbSequenceOidAssignmentMapEntry);
-	yb_sequence_oid_assignment_map = hash_create("YB sequence OIDs map",
-											   /* initial size */ 20, &ctl,
-											   HASH_ELEM | HASH_STRINGS);
+	ctl.keysize = YB_OID_ASSIGNMENT_MAP_KEY_SIZE;
+	ctl.entrysize = sizeof(YbOidAssignmentMapEntry);
+	yb_oid_assignment_map = hash_create("YB OIDs map",
+										/* initial size */ 20, &ctl,
+										HASH_ELEM | HASH_STRINGS);
 }
 
 static void
-YbCreateSequenceOidMapKey(const char *schema, const char *name, char *key_buffer)
+YbCreateOidMapKey(const char *oid_kind, const char *schema, const char *name,
+				  char *key_buffer)
 {
-	int written_bytes = snprintf(key_buffer,
-								 YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE,
-								 "%s.%s", schema, name);
-	if (written_bytes >= YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE)
+	int written_bytes = snprintf(key_buffer, YB_OID_ASSIGNMENT_MAP_KEY_SIZE,
+								 "%s.%s.%s", oid_kind, schema, name);
+	if (written_bytes >= YB_OID_ASSIGNMENT_MAP_KEY_SIZE)
 		elog(ERROR,
 			 "unexpectedly large schema/name in OID assignment (schema '%s', "
 			 "name '%s')",
@@ -155,33 +153,33 @@ YbCreateSequenceOidMapKey(const char *schema, const char *name, char *key_buffer
 }
 
 static void
-YbInsertSequenceOid(const char *schema, const char *name, Oid sequence_oid)
+YbInsertOid(const char *oid_kind, const char *schema, const char *name, Oid oid)
 {
-	char key[YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE];
-	YbCreateSequenceOidMapKey(schema, name, key);
+	char key[YB_OID_ASSIGNMENT_MAP_KEY_SIZE];
+	YbCreateOidMapKey(oid_kind, schema, name, key);
 
 	bool found;
-	YbSequenceOidAssignmentMapEntry *entry =
-		hash_search(yb_sequence_oid_assignment_map, key, HASH_ENTER, &found);
+	YbOidAssignmentMapEntry *entry =
+		hash_search(yb_oid_assignment_map, key, HASH_ENTER, &found);
 	if (!found)
-		entry->oid = sequence_oid;
-	else if (entry->oid != sequence_oid)
+		entry->oid = oid;
+	else if (entry->oid != oid)
 		elog(ERROR,
-			 "attempt to provide multiple OIDs for sequence %s.%s: %u vs "
+			 "attempt to provide multiple OIDs for %s %s.%s: %u vs "
 			 "%u",
-			 schema, name, entry->oid, sequence_oid);
+			 oid_kind, schema, name, entry->oid, oid);
 }
 
 /* Returns InvalidOid on not found. */
 static Oid
-YbLookupOidForSequence(const char *schema, const char *name)
+YbLookupOid(const char *oid_kind, const char *schema, const char *name)
 {
-	char key[YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE];
-	YbCreateSequenceOidMapKey(schema, name, key);
+	char key[YB_OID_ASSIGNMENT_MAP_KEY_SIZE];
+	YbCreateOidMapKey(oid_kind, schema, name, key);
 
 	bool found;
-	YbSequenceOidAssignmentMapEntry *entry =
-		hash_search(yb_sequence_oid_assignment_map, key, HASH_FIND, &found);
+	YbOidAssignmentMapEntry *entry =
+		hash_search(yb_oid_assignment_map, key, HASH_FIND, &found);
 	if (found)
 		return entry->oid;
 	return InvalidOid;
@@ -201,6 +199,76 @@ YbGetOidFromText(const text *input)
 	return result;
 }
 
+static void
+YbExtractEnumLabelMap(text *json_text, char *map_key, bool *found)
+{
+	text       *map_json = json_get_value(json_text, map_key);
+	if (!map_json)
+	{
+		*found = false;
+		return;
+	}
+	*found = true;
+
+	int length = get_json_array_length(map_json);
+	for (int i = 0; i < length; i++)
+	{
+		text *label_info_entry = get_json_array_element(map_json, i);
+		char *label = text_to_cstring(json_get_denormalized_value(label_info_entry,
+																  "label"));
+		text *label_oid_text = json_get_value(label_info_entry,
+											  "label_oid");
+		text *enum_oid_text = json_get_value(label_info_entry,
+											 "enum_oid");
+
+		Oid label_oid = YbGetOidFromText(label_oid_text);
+		Oid enum_oid = YbGetOidFromText(enum_oid_text);
+		if (label_oid == InvalidOid || enum_oid == InvalidOid)
+		{
+			elog(ERROR,
+				 "invalid JSON passed to "
+				 "yb_xcluster_set_next_oid_assignments: '%s'",
+				 text_to_cstring(json_text));
+		}
+
+		YbInsertEnumLabel(enum_oid, label, label_oid);
+	}
+}
+
+static void
+YbExtractNameToOidMap(text *json_text, char *map_key, const char *oid_kind,
+					  bool *found)
+{
+	text       *map_json = json_get_value(json_text, map_key);
+	if (!map_json)
+	{
+		*found = false;
+		return;
+	}
+	*found = true;
+
+	int length = get_json_array_length(map_json);
+	for (int i = 0; i < length; i++)
+	{
+		text *type_info_entry = get_json_array_element(map_json, i);
+		char *schema = text_to_cstring(json_get_denormalized_value(type_info_entry,
+																   "schema"));
+		char *name = text_to_cstring(json_get_denormalized_value(type_info_entry,
+																 "name"));
+		text *oid_text = json_get_value(type_info_entry, "oid");
+		Oid oid = YbGetOidFromText(oid_text);
+		if (oid == InvalidOid)
+		{
+			elog(ERROR,
+				 "invalid JSON passed to "
+				 "yb_xcluster_set_next_oid_assignments: '%s'",
+				 text_to_cstring(json_text));
+		}
+
+		YbInsertOid(oid_kind, schema, name, oid);
+	}
+}
+
 PG_FUNCTION_INFO_V1(yb_xcluster_set_next_oid_assignments);
 
 /*
@@ -231,6 +299,24 @@ PG_FUNCTION_INFO_V1(yb_xcluster_set_next_oid_assignments);
  *
  * Example:
  *    SELECT pg_catalog.yb_xcluster_set_next_oid_assignments(
+ *       '{"type_info":['                                        ||
+ *            '{"schema":"public","name":"my_range","oid":16406}' ||
+ *            ']}');
+ *
+ * This indicates that the type named my_range in schema public should
+ * be assigned the OID 16406.
+ *
+ * The type_info key is optional; if it is present then all types created
+ * directly via CREATE TYPE until the assignment is changed are expected to be
+ * covered by the assignment.  In the example this means that if the DDL
+ * attempts to create a range not_my_range then an error will occur.  It is
+ * not an error if the DDL does not create all the types mentioned in the
+ * assignment.  Multi-ranges are not covered here as they are not directly
+ * created via CREATE TYPE.
+ *
+ *
+ * Example:
+ *    SELECT pg_catalog.yb_xcluster_set_next_oid_assignments(
  *       '{"sequence_info":['                                        ||
  *            '{"schema":"public","name":"my_sequence","oid":16406}' ||
  *            ']}');
@@ -263,62 +349,14 @@ yb_xcluster_set_next_oid_assignments(PG_FUNCTION_ARGS)
 	text *json_text = PG_GETARG_TEXT_P(0);
 
 	YbClearEnumLabelMap();
-	yb_enum_label_assignment_exists = false;
-	text *enum_label_info = json_get_value(json_text, "enum_label_info");
-	if (enum_label_info != NULL)
-	{
-		yb_enum_label_assignment_exists = true;
-		int length = get_json_array_length(enum_label_info);
-		for (int i = 0; i < length; i++)
-		{
-			text *label_info_entry = get_json_array_element(enum_label_info, i);
-			char *label = text_to_cstring(json_get_denormalized_value(label_info_entry, "label"));
-			text *label_oid_text = json_get_value(label_info_entry,
-												  "label_oid");
-			text *enum_oid_text = json_get_value(label_info_entry,
-												 "enum_oid");
-
-			Oid label_oid = YbGetOidFromText(label_oid_text);
-			Oid enum_oid = YbGetOidFromText(enum_oid_text);
-			if (label_oid == InvalidOid || enum_oid == InvalidOid)
-			{
-				elog(ERROR,
-					 "corrupted JSON passed to "
-					 "yb_xcluster_set_next_oid_assignments: '%s'",
-					 text_to_cstring(json_text));
-			}
-
-			YbInsertEnumLabel(enum_oid, label, label_oid);
-		}
-	}
+	YbExtractEnumLabelMap(json_text, "enum_label_info",
+						  &yb_enum_label_assignment_exists);
 
-	YbClearSequenceOidMap();
-	yb_sequence_oid_assignment_exists = false;
-	text *sequence_info = json_get_value(json_text, "sequence_info");
-	if (sequence_info != NULL)
-	{
-		yb_sequence_oid_assignment_exists = true;
-		int length = get_json_array_length(sequence_info);
-		for (int i = 0; i < length; i++)
-		{
-			text *sequence_info_entry = get_json_array_element(sequence_info, i);
-			char *schema = text_to_cstring(json_get_denormalized_value(sequence_info_entry,
-				"schema"));
-			char *name = text_to_cstring(json_get_denormalized_value(sequence_info_entry,
-				"name"));
-			text *oid_text = json_get_value(sequence_info_entry, "oid");
-			Oid sequence_oid = YbGetOidFromText(oid_text);
-			if (sequence_oid == InvalidOid)
-			{
-				elog(ERROR,
-					 "corrupted JSON passed to "
-					 "yb_xcluster_set_next_oid_assignments: '%s'",
-					 text_to_cstring(json_text));
-			}
-
-			YbInsertSequenceOid(schema, name, sequence_oid);
-		}
-	}
+	YbClearOidMap();
+	YbExtractNameToOidMap(json_text, "type_info", YB_OID_KIND_TYPE,
+						  &yb_type_oid_assignment_exists);
+	YbExtractNameToOidMap(json_text, "sequence_info", YB_OID_KIND_SEQUENCE,
+						  &yb_sequence_oid_assignment_exists);
 
 	PG_RETURN_VOID();
 }
@@ -332,17 +370,6 @@ YbUsingEnumLabelOidAssignment(void)
 Oid
 YbLookupOidAssignmentForEnumLabel(Oid enum_oid, const char *label)
 {
-	/*----------
-	 * Currently we do not ensure that enums have the same *pg_type*
-	 * OIDs.  We will fix that later, but in the meantime we take
-	 * advantage of the fact that we currently never have a
-	 * replicating DDL that refers to two different enums to ignore
-	 * the actual enum OID field when comparing labels.
-	 *
-	 * See YbCreateEnumLabelMapKey for the temporary code to ignore the enum
-	 * OID field.
-	 *----------
-	 */
 	Oid label_oid = YbLookupOidForEnumLabel(enum_oid, label);
 	if (label_oid == InvalidOid)
 		elog(ERROR, "no OID assignment for enum label %u.%s in OID assignment",
@@ -350,6 +377,22 @@ YbLookupOidAssignmentForEnumLabel(Oid enum_oid, const char *label)
 	return label_oid;
 }
 
+bool
+YbUsingTypeOidAssignment(void)
+{
+	return yb_type_oid_assignment_exists;
+}
+
+Oid
+YbLookupOidAssignmentForType(const char *schema, const char *name)
+{
+	Oid type_oid = YbLookupOid(YB_OID_KIND_TYPE, schema, name);
+	if (type_oid == InvalidOid)
+		elog(ERROR, "no OID assignment for type %s.%s in OID assignment",
+			 schema, name);
+	return type_oid;
+}
+
 bool
 YbUsingSequenceOidAssignment(void)
 {
@@ -359,7 +402,7 @@ YbUsingSequenceOidAssignment(void)
 Oid
 YbLookupOidAssignmentForSequence(const char *schema, const char *name)
 {
-	Oid sequence_oid = YbLookupOidForSequence(schema, name);
+	Oid sequence_oid = YbLookupOid(YB_OID_KIND_SEQUENCE, schema, name);
 	if (sequence_oid == InvalidOid)
 		elog(ERROR, "no OID assignment for sequence %s.%s in OID assignment",
 			 schema, name);
diff --git a/src/postgres/src/include/catalog/yb_oid_assignment.h b/src/postgres/src/include/catalog/yb_oid_assignment.h
index 45a6de54a1..7dfcad6f85 100644
--- a/src/postgres/src/include/catalog/yb_oid_assignment.h
+++ b/src/postgres/src/include/catalog/yb_oid_assignment.h
@@ -30,6 +30,10 @@ extern bool YbUsingEnumLabelOidAssignment(void);
 
 extern Oid YbLookupOidAssignmentForEnumLabel(Oid enum_oid, const char *label);
 
+extern bool YbUsingTypeOidAssignment(void);
+
+extern Oid YbLookupOidAssignmentForType(const char *schema, const char *name);
+
 extern bool YbUsingSequenceOidAssignment(void);
 
 extern Oid YbLookupOidAssignmentForSequence(const char *schema, const char *name);
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/extension_util.c b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/extension_util.c
index ade3546ae1..2a12300f4e 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/extension_util.c
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/extension_util.c
@@ -21,15 +21,16 @@
 #include "access/genam.h"
 #include "access/heapam.h"
 #include "access/htup_details.h"
-#include "catalog/indexing.h"
 #include "catalog/pg_extension.h"
 #include "catalog/pg_extension_d.h"
+#include "catalog/pg_type.h"
 #include "executor/spi.h"
 #include "extension_util.h"
 #include "utils/builtins.h"
 #include "utils/fmgroids.h"
 #include "utils/lsyscache.h"
 #include "utils/relcache.h"
+#include "utils/syscache.h"
 
 const char *kManualReplicationErrorMsg =
 "To manually replicate, run DDL on the source followed by the target with "
@@ -207,3 +208,22 @@ GetColocationIdFromRelation(Relation *rel)
 
 	return table_props->colocation_id;
 }
+
+char *
+get_typname(Oid pg_type_oid)
+{
+	HeapTuple type_tuple = SearchSysCache1(TYPEOID,
+										   ObjectIdGetDatum(pg_type_oid));
+	if (!HeapTupleIsValid(type_tuple))
+	{
+		ereport(ERROR,
+				(errcode(ERRCODE_UNDEFINED_OBJECT),
+				 errmsg("type OID %u not found", pg_type_oid)));
+	}
+
+	Form_pg_type type_form = (Form_pg_type) GETSTRUCT(type_tuple);
+	char *type_name = pstrdup(NameStr(type_form->typname));
+
+	ReleaseSysCache(type_tuple);
+	return type_name;
+}
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/extension_util.h b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/extension_util.h
index 7afc90efae..131bacf296 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/extension_util.h
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/extension_util.h
@@ -22,7 +22,6 @@
 #include "postgres.h"
 
 #include "tcop/deparse_utility.h"
-#include "utils/guc.h"
 #include "utils/memutils.h"
 
 #define EXTENSION_NAME			   "yb_xcluster_ddl_replication"
@@ -91,4 +90,6 @@ extern bool IsTempSchema(const char *schema_name);
 /* Returns the relation's colocation id or 0 if not colocated. */
 extern Oid GetColocationIdFromRelation(Relation *rel);
 
+extern char *get_typname(Oid pg_type_oid);
+
 #endif
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/source_ddl_end_handler.c b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/source_ddl_end_handler.c
index 045bc66e01..b0a78a5c1a 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/source_ddl_end_handler.c
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/source_ddl_end_handler.c
@@ -170,12 +170,12 @@ typedef struct YbEnumLabelMapEntry
 	char *label_name;
 } YbEnumLabelMapEntry;
 
-typedef struct YbSequenceInfoMapEntry
+typedef struct YbNameToOidMapEntry
 {
 	char       *schema;
 	char       *name;
-	Oid         pg_class_oid;
-} YbSequenceInfoMapEntry;
+	Oid         oid;
+} YbNameToOidMapEntry;
 
 void
 CheckAlterColumnTypeDDL(CollectedCommand *cmd)
@@ -432,6 +432,19 @@ GetEnumLabels(Oid enum_oid, List **enum_label_list)
 	}
 }
 
+static void
+AddNameToOidInfo(char *schema, char *name, Oid oid,
+				 List **name_to_oid_info_list)
+{
+	YbNameToOidMapEntry *name_to_oid_info_entry =
+		palloc(sizeof(YbNameToOidMapEntry));
+	name_to_oid_info_entry->name = name;
+	name_to_oid_info_entry->schema = pstrdup(schema);
+	name_to_oid_info_entry->oid = oid;
+	*name_to_oid_info_list = lappend(*name_to_oid_info_list,
+									 name_to_oid_info_entry);
+}
+
 static void
 AddSequenceInfo(Oid pg_class_oid, char *schema, List **sequence_info_list)
 {
@@ -442,13 +455,20 @@ AddSequenceInfo(Oid pg_class_oid, char *schema, List **sequence_info_list)
 	if (!schema)
 		elog(ERROR, "Schema of sequence with pg_class OID %u unknown",
 			 pg_class_oid);
+	AddNameToOidInfo(schema, name, pg_class_oid, sequence_info_list);
+}
 
-	YbSequenceInfoMapEntry *sequence_info_entry =
-		palloc(sizeof(YbSequenceInfoMapEntry));
-	sequence_info_entry->name = name;
-	sequence_info_entry->schema = pstrdup(schema);
-	sequence_info_entry->pg_class_oid = pg_class_oid;
-	*sequence_info_list = lappend(*sequence_info_list, sequence_info_entry);
+static void
+AddTypeInfo(Oid pg_type_oid, char *schema, List **type_info_list)
+{
+	char       *name = get_typname(pg_type_oid);
+	if (!name)
+		elog(ERROR, "Unable to find name of type with pg_type OID %u",
+			 pg_type_oid);
+	if (!schema)
+		elog(ERROR, "Schema of type with pg_type OID %u unknown",
+			 pg_type_oid);
+	AddNameToOidInfo(schema, name, pg_type_oid, type_info_list);
 }
 
 typedef struct YbCommandInfo
@@ -489,6 +509,79 @@ GetSourceEventTriggerDDLCommands(YbCommandInfo **info_array_out)
 	return num_of_rows;
 }
 
+void
+PushEnumLabelMap(JsonbParseState *state, char *map_key,
+				 List *enum_label_list)
+{
+	if (!enum_label_list)
+		return;
+
+	/*----------
+	 * Add the enum_label_list to the JSON output.  We use a flat array of
+	 * entries because JSON doesn't allow maps on composite values.
+	 *
+	 * If two entries have the same enum and label OIDs, then the
+	 * remaining fields are guaranteed to be the same.
+	 *----------
+	 */
+	AddJsonKey(state, map_key);
+	(void) pushJsonbValue(&state, WJB_BEGIN_ARRAY, NULL);
+
+	ListCell *l;
+	foreach (l, enum_label_list)
+	{
+		YbEnumLabelMapEntry *entry = (YbEnumLabelMapEntry *) lfirst(l);
+
+		(void) pushJsonbValue(&state, WJB_BEGIN_OBJECT, NULL);
+		AddNumericJsonEntry(state, "enum_oid", entry->enum_oid);
+		AddStringJsonEntry(state, "label", entry->label_name);
+		AddNumericJsonEntry(state, "label_oid", entry->label_oid);
+		(void) pushJsonbValue(&state, WJB_END_OBJECT, NULL);
+
+		pfree(entry->label_name);
+		pfree(entry);
+	}
+
+	(void) pushJsonbValue(&state, WJB_END_ARRAY, NULL);
+}
+
+void
+PushNameToOidMap(JsonbParseState *state, char *map_key,
+				 List *name_to_oid_info_list)
+{
+	if (!name_to_oid_info_list)
+		return;
+
+	/*----------
+	 * Add the name_to_oid_info_list to the JSON output.  We use a flat array
+	 * of entries because JSON doesn't allow maps on composite values.
+	 *
+	 * If two entries have the same schema and name, then the oid field is
+	 * guaranteed to be the same.
+	 *----------
+	 */
+	AddJsonKey(state, map_key);
+	(void) pushJsonbValue(&state, WJB_BEGIN_ARRAY, NULL);
+
+	ListCell *l;
+	foreach (l, name_to_oid_info_list)
+	{
+		YbNameToOidMapEntry *entry = (YbNameToOidMapEntry *) lfirst(l);
+
+		(void) pushJsonbValue(&state, WJB_BEGIN_OBJECT, NULL);
+		AddStringJsonEntry(state, "schema", entry->schema);
+		AddStringJsonEntry(state, "name", entry->name);
+		AddNumericJsonEntry(state, "oid", entry->oid);
+		(void) pushJsonbValue(&state, WJB_END_OBJECT, NULL);
+
+		pfree(entry->schema);
+		pfree(entry->name);
+		pfree(entry);
+	}
+
+	(void) pushJsonbValue(&state, WJB_END_ARRAY, NULL);
+}
+
 bool
 ProcessSourceEventTriggerDDLCommands(JsonbParseState *state)
 {
@@ -505,6 +598,7 @@ ProcessSourceEventTriggerDDLCommands(JsonbParseState *state)
 	List	   *new_rel_list = NIL;
 	List       *enum_label_list = NIL;
 	List       *sequence_info_list = NIL;
+	List       *type_info_list = NIL;
 	/*
 	 * As long as there is at least one command that needs to be replicated, we
 	 * will set this to true and replicate the entire query string.
@@ -535,6 +629,7 @@ ProcessSourceEventTriggerDDLCommands(JsonbParseState *state)
 		{
 			if (type_is_enum(obj_id))
 				GetEnumLabels(obj_id, &enum_label_list);
+			AddTypeInfo(obj_id, schema, &type_info_list);
 			should_replicate_ddl |= true;
 		}
 		else if (command_tag == CMDTAG_CREATE_SEQUENCE ||
@@ -609,67 +704,12 @@ ProcessSourceEventTriggerDDLCommands(JsonbParseState *state)
 
 	ProcessNewRelationsList(state, &new_rel_list);
 
-	if (enum_label_list)
-	{
-		/*----------
-		 * Add the enum_label_list to the JSON output.  We use a flat array of
-		 * entries because JSON doesn't allow maps on composite values.
-		 *
-		 * If two entries have the same enum and label OIDs, then the
-		 * remaining fields are guaranteed to be the same.
-		 *----------
-		 */
-		AddJsonKey(state, "enum_label_info");
-		(void) pushJsonbValue(&state, WJB_BEGIN_ARRAY, NULL);
-
-		ListCell *l;
-		foreach (l, enum_label_list)
-		{
-			YbEnumLabelMapEntry *entry = (YbEnumLabelMapEntry *) lfirst(l);
-
-			(void) pushJsonbValue(&state, WJB_BEGIN_OBJECT, NULL);
-			AddNumericJsonEntry(state, "enum_oid", entry->enum_oid);
-			AddStringJsonEntry(state, "label", entry->label_name);
-			AddNumericJsonEntry(state, "label_oid", entry->label_oid);
-			(void) pushJsonbValue(&state, WJB_END_OBJECT, NULL);
-
-			pfree(entry->label_name);
-			pfree(entry);
-		}
-
-		(void) pushJsonbValue(&state, WJB_END_ARRAY, NULL);
-	}
-	if (sequence_info_list)
-	{
-		/*----------
-		 * Add the sequence_info_list to the JSON output.  We use a flat array
-		 * of entries because JSON doesn't allow maps on composite values.
-		 *
-		 * If two entries have the same schema and name, then the remaining
-		 * fields are guaranteed to be the same.
-		 *----------
-		 */
-		AddJsonKey(state, "sequence_info");
-		(void) pushJsonbValue(&state, WJB_BEGIN_ARRAY, NULL);
-
-		ListCell *l;
-		foreach (l, sequence_info_list)
-		{
-			YbSequenceInfoMapEntry *entry = (YbSequenceInfoMapEntry *) lfirst(l);
-
-			(void) pushJsonbValue(&state, WJB_BEGIN_OBJECT, NULL);
-			AddStringJsonEntry(state, "schema", entry->schema);
-			AddStringJsonEntry(state, "name", entry->name);
-			AddNumericJsonEntry(state, "oid", entry->pg_class_oid);
-			(void) pushJsonbValue(&state, WJB_END_OBJECT, NULL);
-
-			pfree(entry->schema);
-			pfree(entry->name);
-			pfree(entry);
-		}
-
-		(void) pushJsonbValue(&state, WJB_END_ARRAY, NULL);
-	}
+	/*
+	 * Add non-empty OID assignment maps to JSON.
+	 */
+	PushEnumLabelMap(state, "enum_label_info", enum_label_list);
+	PushNameToOidMap(state, "sequence_info", sequence_info_list);
+	PushNameToOidMap(state, "type_info", type_info_list);
 
 	return should_replicate_ddl;
 }
diff --git a/src/yb/integration-tests/xcluster/sql/create_enum.sql b/src/yb/integration-tests/xcluster/sql/create_enum.sql
index 36d8d45c12..ed9cf53e92 100644
--- a/src/yb/integration-tests/xcluster/sql/create_enum.sql
+++ b/src/yb/integration-tests/xcluster/sql/create_enum.sql
@@ -175,3 +175,11 @@ CREATE TYPE empty_enum AS ENUM ();
 
 
 CREATE TYPE huge_label AS ENUM ('exactly_63_character_identifier_1234567890abcdefghijklmnopqrstu');
+
+
+-- Enums with the same name but different schemas
+CREATE SCHEMA schema1;
+CREATE SCHEMA schema2;
+
+CREATE TYPE schema1.enum_in_schema AS ();
+CREATE TYPE schema2.enum_in_schema AS ();
diff --git a/src/yb/integration-tests/xcluster/sql/create_type.sql b/src/yb/integration-tests/xcluster/sql/create_type.sql
new file mode 100644
index 0000000000..daf48de467
--- /dev/null
+++ b/src/yb/integration-tests/xcluster/sql/create_type.sql
@@ -0,0 +1,105 @@
+--
+-- Creating types
+--
+
+-- Taken from postgres/src/test/regress/sql/yb.orig.create_type.sql
+-- Taken from postgres/src/test/regress/sql/create_type.sql
+
+
+--
+-- Create shell type
+--
+CREATE TYPE shell;
+
+
+--
+-- Create composite type
+--
+
+CREATE TYPE composite_type AS (
+  i INT,
+  v VARCHAR
+);
+
+CREATE TYPE composite_type2;
+CREATE TYPE composite_type2 AS (
+  i INT,
+  v VARCHAR
+);
+
+
+--
+-- Create enum type
+--
+-- See separate create_enum.sql file
+--
+
+CREATE TYPE empty_enum;
+CREATE TYPE empty_enum AS ENUM ();
+
+
+--
+-- Create range type
+--
+CREATE TYPE range_type AS RANGE (
+    subtype = float
+);
+
+CREATE TYPE two_ints AS (a INT, b INT);
+CREATE TYPE two_ints_range AS RANGE (SUBTYPE = two_ints);
+
+CREATE TYPE textrange1 AS RANGE(SUBTYPE=TEXT, MULTIRANGE_TYPE_NAME=multirange_of_text, COLLATION="C");
+-- should pass, because existing _textrange1 is automatically renamed
+CREATE TYPE textrange2 AS RANGE(SUBTYPE=TEXT, MULTIRANGE_TYPE_NAME=_textrange1, COLLATION="C");
+
+CREATE TYPE range_type_in_two_steps;
+CREATE TYPE range_type_in_two_steps AS RANGE (
+    subtype = float
+);
+
+
+--
+-- Create base type
+--
+-- Taken from https://stackoverflow.com/questions/45188301/
+CREATE TYPE base_type;
+CREATE FUNCTION base_type_in(cstring) RETURNS base_type
+   LANGUAGE internal IMMUTABLE STRICT PARALLEL SAFE AS 'int2in';
+CREATE FUNCTION base_type_out(base_type) RETURNS cstring
+   LANGUAGE internal IMMUTABLE STRICT PARALLEL SAFE AS 'int2out';
+CREATE FUNCTION base_type_recv(internal) RETURNS base_type
+   LANGUAGE internal IMMUTABLE STRICT PARALLEL SAFE AS 'int2recv';
+CREATE FUNCTION base_type_send(base_type) RETURNS bytea
+   LANGUAGE internal IMMUTABLE STRICT PARALLEL SAFE AS 'int2send';
+CREATE TYPE base_type (
+   INPUT = base_type_in,
+   OUTPUT = base_type_out,
+   RECEIVE = base_type_recv,
+   SEND = base_type_send,
+   LIKE = smallint,
+   CATEGORY = 'N',
+   PREFERRED = FALSE,
+   DELIMITER = ',',
+   COLLATABLE = FALSE
+);
+
+
+-- Composite types with the same name but different schemas
+CREATE SCHEMA schema1;
+CREATE SCHEMA schema2;
+
+CREATE TYPE schema1.composite_type_in_schema AS (
+  i INT,
+  v VARCHAR
+);
+CREATE TYPE schema2.composite_type_in_schema AS (
+  i INT,
+  v VARCHAR
+);
+
+
+-- Types with weird names
+CREATE TYPE "funny type +" AS (i int);
+CREATE TYPE "inside ""quotes""!" AS (i int);
+CREATE TYPE "inside ""quotes"" 'here'!" AS (i int);
+CREATE TYPE "CREATE" AS (i int);   -- use keyword
diff --git a/src/yb/integration-tests/xcluster/sql/drop_enum.sql b/src/yb/integration-tests/xcluster/sql/drop_enum.sql
index 5cb34b06dd..2897949a97 100644
--- a/src/yb/integration-tests/xcluster/sql/drop_enum.sql
+++ b/src/yb/integration-tests/xcluster/sql/drop_enum.sql
@@ -25,3 +25,6 @@ DROP TYPE paint_color;
 DROP TYPE empty_enum;
 
 DROP TYPE huge_label;
+
+DROP TYPE schema1.enum_in_schema;
+DROP SCHEMA schema2 CASCADE;
diff --git a/src/yb/integration-tests/xcluster/sql/drop_type.sql b/src/yb/integration-tests/xcluster/sql/drop_type.sql
new file mode 100644
index 0000000000..0655788e53
--- /dev/null
+++ b/src/yb/integration-tests/xcluster/sql/drop_type.sql
@@ -0,0 +1,53 @@
+--
+-- Drops enums from yb/integration-tests/xcluster/sql/create_type.sql
+--
+
+--
+-- Drop shell type
+--
+DROP TYPE shell;
+
+
+--
+-- Drop composite type
+--
+DROP TYPE composite_type;
+DROP TYPE composite_type2;
+
+
+--
+-- Drop enum type
+--
+DROP TYPE empty_enum;
+
+
+--
+-- Drop range type
+--
+DROP TYPE range_type;
+
+DROP TYPE two_ints CASCADE;
+
+DROP TYPE textrange1;
+DROP TYPE textrange2;
+
+DROP TYPE range_type_in_two_steps;
+
+
+--
+-- Drop base type
+--
+DROP TYPE base_type CASCADE;
+
+
+--
+-- Composite types with the same name but different schemas
+--
+DROP TYPE schema1.composite_type_in_schema;
+DROP TYPE schema2.composite_type_in_schema;
+
+
+-- Types with weird names
+DROP TYPE "funny type +";
+DROP TYPE "inside ""quotes""!";
+DROP TYPE "CREATE";
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
index 38473e36df..50360711b3 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
@@ -321,15 +321,6 @@ TEST_F(XClusterDDLReplicationTest, CreateTable) {
 
 TEST_F(XClusterDDLReplicationTest, CreateTableWithEnum) {
   ASSERT_OK(SetUpClusters());
-  {
-    // Perturb OIDs on consumer side to make sure we don't accidentally preserve OIDs.
-    auto conn = ASSERT_RESULT(consumer_cluster_.ConnectToDB(namespace_name));
-    ASSERT_OK(
-        conn.Execute("CREATE TYPE gratuitous_enum AS ENUM ('red', 'orange', 'yellow', 'green', "
-                     "'blue', 'purple');"));
-    ASSERT_OK(conn.Execute("DROP TYPE gratuitous_enum;"));
-  }
-
   ASSERT_OK(CheckpointReplicationGroup(kReplicationGroupId, /*require_no_bootstrap_needed=*/false));
   // Bootstrap here would have no effect because the database is empty so we skip it for the test.
   ASSERT_OK(CreateReplicationFromCheckpoint());
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc
index 05e0ea0170..321a24ab97 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc
@@ -92,6 +92,28 @@ class XClusterPgRegressDDLReplicationTest : public XClusterDDLReplicationTestBas
         ", ", "\n"));
   }
 
+  Result<std::string> ReadTypeInfoThatMustMatch(Cluster& cluster) {
+    auto conn = VERIFY_RESULT(cluster.ConnectToDB(namespace_name));
+    return VERIFY_RESULT(conn.FetchAllAsString(R"(
+        SELECT
+            n.nspname,
+            t.typname,
+            t.oid,
+            t.typtype::text AS typtype_str,
+            c.relkind::text AS relkind_str
+        FROM pg_type t
+          LEFT JOIN pg_class c     ON t.typrelid     = c.oid
+          LEFT JOIN pg_namespace n ON t.typnamespace = n.oid
+        WHERE
+              t.typtype = 'e'                              -- enum type
+          OR (t.typtype = 'c' AND c.relkind = 'c')         -- user-defined composite type
+          OR  t.typtype = 'r'                              -- single range type
+          OR (t.typtype = 'b' AND NOT t.typcategory = 'A') -- base type that is not an array
+          OR (t.typtype = 'p' AND NOT t.typisdefined)      -- shell type
+        ORDER BY t.typnamespace ASC, t.typname ASC;
+      )", ", ", "\n"));
+  }
+
   Result<std::string> ReadSequenceOidInfo(Cluster& cluster) {
     auto conn = VERIFY_RESULT(cluster.ConnectToDB(namespace_name));
     return VERIFY_RESULT(conn.FetchAllAsString(
@@ -104,11 +126,12 @@ class XClusterPgRegressDDLReplicationTest : public XClusterDDLReplicationTestBas
   }
 
   void ExpectEqOidsNeedingPreservation(Cluster& consumer_cluster, Cluster& producer_cluster) {
-    // Enums pg_enum OIDs.
+    // pg_enum OIDs.
     auto producer_enum_label_info = ASSERT_RESULT(ReadEnumLabelInfo(producer_cluster));
     auto consumer_enum_label_info = ASSERT_RESULT(ReadEnumLabelInfo(consumer_cluster));
     ASSERT_EQ(producer_enum_label_info, consumer_enum_label_info)
         << "enum label OID information does not match";
+    LOG(INFO) << "pg_enum OIDs on both sides are:\n" << producer_enum_label_info;
 
     // Sequence pg_class OIDs.
     auto producer_sequence_info = ASSERT_RESULT(ReadSequenceOidInfo(producer_cluster));
@@ -116,6 +139,13 @@ class XClusterPgRegressDDLReplicationTest : public XClusterDDLReplicationTestBas
     ASSERT_EQ(producer_sequence_info, consumer_sequence_info)
         << "sequence OID information does not match";
     LOG(INFO) << "Sequence pg_class OIDs on both sides are:\n" << producer_sequence_info;
+
+    // pg_type OIDs.
+    auto producer_type_info = ASSERT_RESULT(ReadTypeInfoThatMustMatch(producer_cluster));
+    auto consumer_type_info = ASSERT_RESULT(ReadTypeInfoThatMustMatch(consumer_cluster));
+    ASSERT_EQ(producer_type_info, consumer_type_info)
+        << "type OID information that must match does not match";
+    LOG(INFO) << "pg_type OIDs that must match on both sides are:\n" << producer_type_info;
   }
 
   void ExecutePgFile(const std::string& file_path) { ExecutePgFile(file_path, namespace_name); }
@@ -294,6 +324,10 @@ TEST_F(XClusterPgRegressDDLReplicationTest, PgRegressCreateDropEnum) {
   ASSERT_OK(TestPgRegress("create_enum.sql", "drop_enum.sql"));
 }
 
+TEST_F(XClusterPgRegressDDLReplicationTest, PgRegressCreateDropType) {
+  ASSERT_OK(TestPgRegress("create_type.sql", "drop_type.sql"));
+}
+
 TEST_F(XClusterPgRegressDDLReplicationTest, PgRegressCreateDropTemp) {
   ASSERT_OK(TestPgRegress("temporary_objects.sql", ""));
 
diff --git a/src/yb/tserver/xcluster_ddl_queue_handler.cc b/src/yb/tserver/xcluster_ddl_queue_handler.cc
index 047debf24c..e4f32e1ea5 100644
--- a/src/yb/tserver/xcluster_ddl_queue_handler.cc
+++ b/src/yb/tserver/xcluster_ddl_queue_handler.cc
@@ -13,6 +13,8 @@
 
 #include "yb/tserver/xcluster_ddl_queue_handler.h"
 
+#include <regex>
+
 #include <rapidjson/document.h>
 #include <rapidjson/error/en.h>
 #include <rapidjson/stringbuffer.h>
@@ -87,6 +89,7 @@ const char* kDDLJsonRelFileOid = "relfile_oid";
 const char* kDDLJsonColocationId = "colocation_id";
 const char* kDDLJsonIsIndex = "is_index";
 const char* kDDLJsonEnumLabelInfo = "enum_label_info";
+const char* kDDLJsonTypeInfo = "type_info";
 const char* kDDLJsonSequenceInfo = "sequence_info";
 const char* kDDLJsonManualReplication = "manual_replication";
 const char* kDDLPrepStmtManualInsert = "manual_replication_insert";
@@ -324,6 +327,10 @@ Result<XClusterDDLQueueHandler::DDLQueryInfo> XClusterDDLQueueHandler::GetDDLQue
     writer.Key(kDDLJsonEnumLabelInfo);
     doc[kDDLJsonEnumLabelInfo].Accept(writer);
   }
+  if (HAS_MEMBER_OF_TYPE(doc, kDDLJsonTypeInfo, IsArray)) {
+    writer.Key(kDDLJsonTypeInfo);
+    doc[kDDLJsonTypeInfo].Accept(writer);
+  }
   if (HAS_MEMBER_OF_TYPE(doc, kDDLJsonSequenceInfo, IsArray)) {
     writer.Key(kDDLJsonSequenceInfo);
     doc[kDDLJsonSequenceInfo].Accept(writer);
@@ -389,7 +396,7 @@ Status XClusterDDLQueueHandler::ProcessDDLQuery(const DDLQueryInfo& query_info)
   // Pass information needed to assign OIDs that need to be preserved across the universes.
   setup_query << Format(
       "SELECT pg_catalog.yb_xcluster_set_next_oid_assignments('$0');",
-      query_info.json_for_oid_assignment);
+      std::regex_replace(query_info.json_for_oid_assignment, std::regex("'"), "''"));
 
   setup_query << "SET yb_skip_data_insert_for_table_rewrite=true;";
 
