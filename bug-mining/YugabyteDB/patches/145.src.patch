diff --git a/src/yb/client/xcluster_client.cc b/src/yb/client/xcluster_client.cc
index c9e5d66a29..1dfa2e9506 100644
--- a/src/yb/client/xcluster_client.cc
+++ b/src/yb/client/xcluster_client.cc
@@ -215,7 +215,7 @@ Result<IsOperationDoneResult> XClusterClient::IsCreateXClusterReplicationDone(
 
 Status XClusterClient::CreateOutboundReplicationGroup(
     const xcluster::ReplicationGroupId& replication_group_id,
-    const std::vector<NamespaceId>& namespace_ids) {
+    const std::vector<NamespaceId>& namespace_ids, bool automatic_ddl_mode) {
   SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication group Id");
   SCHECK(!namespace_ids.empty(), InvalidArgument, "At least one namespace Id is required");
 
@@ -225,6 +225,8 @@ Status XClusterClient::CreateOutboundReplicationGroup(
     req.add_namespace_ids(namespace_id);
   }
 
+  req.set_automatic_ddl_mode(automatic_ddl_mode);
+
   auto resp = CALL_SYNC_LEADER_MASTER_RPC(XClusterCreateOutboundReplicationGroup, req);
 
   if (resp.has_error()) {
@@ -569,6 +571,7 @@ XClusterClient::GetUniverseReplicationInfo(
     result.db_scope_namespace_id_map.emplace(
         db_scoped_info.target_namespace_id(), db_scoped_info.source_namespace_id());
   }
+  result.automatic_ddl_mode = resp.automatic_ddl_mode();
 
   return result;
 }
@@ -578,8 +581,8 @@ Result<UniverseUuid> XClusterClient::SetupDbScopedUniverseReplication(
     const std::vector<HostPort>& source_master_addresses,
     const std::vector<NamespaceName>& namespace_names,
     const std::vector<NamespaceId>& source_namespace_ids,
-    const std::vector<TableId>& source_table_ids,
-    const std::vector<xrepl::StreamId>& bootstrap_ids) {
+    const std::vector<TableId>& source_table_ids, const std::vector<xrepl::StreamId>& bootstrap_ids,
+    bool automatic_ddl_mode) {
   master::SetupUniverseReplicationRequestPB req;
   req.set_replication_group_id(replication_group_id.ToString());
   req.set_transactional(true);  // Db Scoped replication is always transactional.
@@ -595,6 +598,8 @@ Result<UniverseUuid> XClusterClient::SetupDbScopedUniverseReplication(
     req.add_producer_bootstrap_ids(bootstrap_id.ToString());
   }
 
+  req.set_automatic_ddl_mode(automatic_ddl_mode);
+
   SCHECK_EQ(
       namespace_names.size(), source_namespace_ids.size(), InvalidArgument,
       "Namespace names and IDs count must match");
diff --git a/src/yb/client/xcluster_client.h b/src/yb/client/xcluster_client.h
index 3d85c7d118..845218cb02 100644
--- a/src/yb/client/xcluster_client.h
+++ b/src/yb/client/xcluster_client.h
@@ -99,7 +99,7 @@ class XClusterClient {
   // complete.
   Status CreateOutboundReplicationGroup(
       const xcluster::ReplicationGroupId& replication_group_id,
-      const std::vector<NamespaceId>& namespace_ids);
+      const std::vector<NamespaceId>& namespace_ids, bool automatic_ddl_mode = false);
 
   Status IsBootstrapRequired(
       CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
@@ -197,6 +197,7 @@ class XClusterClient {
     std::string source_master_addrs;
     // Map of target namespace id to source namespace id. Only used in db scope replication.
     std::unordered_map<NamespaceId, NamespaceId> db_scope_namespace_id_map;
+    bool automatic_ddl_mode = false;
 
     struct XClusterInboundReplicationGroupTableInfo {
       TableId target_table_id;
@@ -215,7 +216,7 @@ class XClusterClient {
       const std::vector<NamespaceName>& namespace_names,
       const std::vector<NamespaceId>& source_namespace_ids,
       const std::vector<TableId>& source_table_ids,
-      const std::vector<xrepl::StreamId>& bootstrap_ids);
+      const std::vector<xrepl::StreamId>& bootstrap_ids, bool automatic_ddl_mode);
 
   virtual Result<IsOperationDoneResult> IsSetupUniverseReplicationDone(
       const xcluster::ReplicationGroupId& replication_group_id);
diff --git a/src/yb/client/xcluster_client_mock.h b/src/yb/client/xcluster_client_mock.h
index 7a269ca538..b2db9f1ff4 100644
--- a/src/yb/client/xcluster_client_mock.h
+++ b/src/yb/client/xcluster_client_mock.h
@@ -30,7 +30,7 @@ class MockXClusterClient : public XClusterClient {
       Result<UniverseUuid>, SetupDbScopedUniverseReplication,
       (const xcluster::ReplicationGroupId&, const std::vector<HostPort>&,
        const std::vector<NamespaceName>&, const std::vector<NamespaceId>&,
-       const std::vector<TableId>&, const std::vector<xrepl::StreamId>&),
+       const std::vector<TableId>&, const std::vector<xrepl::StreamId>&, bool),
       (override));
 
   MOCK_METHOD(
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h
index 0a3a75d708..7323b36e50 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h
@@ -28,6 +28,14 @@ class XClusterDDLReplicationTestBase : public XClusterYsqlTestBase {
 
   Status EnableDDLReplicationExtension();
 
+  // Set automatic_ddl_mode to true by default.
+  virtual Status CheckpointReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId,
+      bool automatic_ddl_mode = true) override {
+    return XClusterYsqlTestBase::CheckpointReplicationGroup(
+        replication_group_id, automatic_ddl_mode);
+  }
+
   Result<std::shared_ptr<client::YBTable>> GetProducerTable(
       const client::YBTableName& producer_table_name);
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
index 512f0f57fb..9408958f84 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
@@ -888,10 +888,11 @@ Status XClusterYsqlTestBase::SetUpClusters(const SetupParams& params) {
 }
 
 Status XClusterYsqlTestBase::CheckpointReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id) {
+    const xcluster::ReplicationGroupId& replication_group_id, bool automatic_ddl_mode) {
   auto producer_namespace_id = VERIFY_RESULT(GetNamespaceId(producer_client()));
   RETURN_NOT_OK(client::XClusterClient(*producer_client())
-                    .CreateOutboundReplicationGroup(replication_group_id, {producer_namespace_id}));
+                    .CreateOutboundReplicationGroup(
+                        replication_group_id, {producer_namespace_id}, automatic_ddl_mode));
 
   auto bootstrap_required =
       VERIFY_RESULT(IsXClusterBootstrapRequired(replication_group_id, producer_namespace_id));
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
index 3bfa5521b6..fc21f8e5b5 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
@@ -135,8 +135,9 @@ class XClusterYsqlTestBase : public XClusterTestBase {
       uint32_t start, uint32_t end, Cluster* cluster, const client::YBTableName& table,
       bool delete_op = false, bool use_transaction = false);
 
-  Status CheckpointReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId);
+  virtual Status CheckpointReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId,
+      bool automatic_ddl_mode = false);
   Result<bool> IsXClusterBootstrapRequired(
       const xcluster::ReplicationGroupId& replication_group_id,
       const NamespaceId& source_namespace_id);
diff --git a/src/yb/master/catalog_entity_info.proto b/src/yb/master/catalog_entity_info.proto
index 1aec4caf38..1143e5b193 100644
--- a/src/yb/master/catalog_entity_info.proto
+++ b/src/yb/master/catalog_entity_info.proto
@@ -708,12 +708,15 @@ message SysUniverseReplicationEntryPB {
 
   // DB Scoped repication.
   message DBScopeInfo {
+    optional bool automatic_ddl_mode = 1; // [default = false]
+
     message NamespaceInfo {
       required string consumer_namespace_id = 1;
       required string producer_namespace_id = 2;
     }
     repeated NamespaceInfo namespace_infos = 13;
   }
+
   optional DBScopeInfo db_scoped_info = 13;
 }
 
@@ -881,6 +884,8 @@ message SysXClusterOutboundReplicationGroupEntryPB {
     DELETED = 1;
   }
   optional State state = 3 [ default = READY ];
+
+  optional bool automatic_ddl_mode = 4; // [default = false]
 }
 
 message SysTServerEntryPB {
diff --git a/src/yb/master/master_replication.proto b/src/yb/master/master_replication.proto
index cdd3b79350..00c12a9ba4 100644
--- a/src/yb/master/master_replication.proto
+++ b/src/yb/master/master_replication.proto
@@ -291,6 +291,12 @@ message SetupUniverseReplicationRequestPB {
   // Used for DB Scoped replication. transactional must be set.
   // Both id and name must be set. Only YQL_DATABASE_PGSQL are allowed.
   repeated NamespaceIdentifierPB producer_namespaces = 6;
+
+  // Whether automatic DDL replication is enabled - Creates the
+  // yb_xcluster_ddl_replication extension and sequences_data table.
+  // Requires DB Scoped replication, transactional and producer_namespace to be
+  // set.
+  optional bool automatic_ddl_mode = 7; // [default = false]
 }
 
 message SetupUniverseReplicationResponsePB {
@@ -555,6 +561,7 @@ message YsqlBackfillReplicationSlotNameToCDCSDKStreamResponsePB {
 message XClusterCreateOutboundReplicationGroupRequestPB {
   required string replication_group_id = 1;
   repeated string namespace_ids = 2;
+  optional bool automatic_ddl_mode = 3; // [default = false]
 }
 
 message XClusterCreateOutboundReplicationGroupResponsePB {
@@ -724,6 +731,7 @@ message GetXClusterOutboundReplicationGroupInfoResponsePB {
     map<string, string> table_streams = 2;
   }
   repeated NamespaceInfoPB namespace_infos = 2;
+  optional bool automatic_ddl_mode = 4; // [default = false]
 }
 
 message GetUniverseReplicationsRequestPB {
@@ -758,6 +766,7 @@ message GetUniverseReplicationInfoResponsePB {
   }
 
   repeated DbScopedInfoPB db_scoped_infos = 5;
+  optional bool automatic_ddl_mode = 6; // [default = false]
 }
 
 message DisableDynamicTableAdditionOnCDCSDKStreamRequestPB {
diff --git a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
index ed0e7a6d8b..5c1bab9dbd 100644
--- a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
+++ b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
@@ -95,7 +95,8 @@ CreateSetupUniverseReplicationTask(
       new XClusterInboundReplicationGroupSetupTask(
           master, catalog_manager, epoch, xcluster::ReplicationGroupId(req->replication_group_id()),
           req->producer_master_addresses(), std::move(source_table_ids), std::move(stream_ids),
-          req->transactional(), std::move(source_namespace_ids), std::move(target_namespace_ids)));
+          req->transactional(), std::move(source_namespace_ids), std::move(target_namespace_ids),
+          req->automatic_ddl_mode()));
   RETURN_NOT_OK(setup_task->ValidateInputArguments());
 
   return setup_task;
@@ -107,7 +108,7 @@ XClusterInboundReplicationGroupSetupTask::XClusterInboundReplicationGroupSetupTa
     const google::protobuf::RepeatedPtrField<HostPortPB>& source_masters,
     std::vector<TableId>&& source_table_ids, std::vector<xrepl::StreamId>&& stream_ids,
     bool transactional, std::vector<NamespaceId>&& source_namespace_ids,
-    std::vector<NamespaceId>&& target_namespace_ids)
+    std::vector<NamespaceId>&& target_namespace_ids, bool automatic_ddl_mode)
     : MultiStepMonitoredTask(*catalog_manager.AsyncTaskPool(), *master.messenger()),
       master_(master),
       catalog_manager_(catalog_manager),
@@ -116,14 +117,15 @@ XClusterInboundReplicationGroupSetupTask::XClusterInboundReplicationGroupSetupTa
       epoch_(epoch),
       replication_group_id_(std::move(replication_group_id)),
       source_masters_(source_masters),
-      transactional_(transactional),
       source_table_ids_(std::move(source_table_ids)),
       stream_ids_(std::move(stream_ids)),
       source_namespace_ids_(std::move(source_namespace_ids)),
       target_namespace_ids_(std::move(target_namespace_ids)),
       is_alter_replication_(xcluster::IsAlterReplicationGroupId(replication_group_id_)),
+      stream_ids_provided_(!stream_ids_.empty()),
+      transactional_(transactional),
       is_db_scoped_(!source_namespace_ids_.empty()),
-      stream_ids_provided_(!stream_ids_.empty()) {
+      automatic_ddl_mode_(automatic_ddl_mode) {
   log_prefix_ = Format(
       "xCluster InboundReplicationGroup [$0] $1: ", replication_group_id_,
       (is_alter_replication_ ? "Alter" : "Setup"));
@@ -202,6 +204,10 @@ Status XClusterInboundReplicationGroupSetupTask::ValidateInputArguments() {
   SCHECK(!replication_group_id_.empty(), InvalidArgument, "Invalid Replication Group Id");
   SCHECK(!source_table_ids_.empty(), InvalidArgument, "No tables provided");
 
+  SCHECK(
+      !automatic_ddl_mode_ || is_db_scoped_, InvalidArgument,
+      "Automatic DDL mode is only valid for DB scoped replication groups");
+
   for (const auto& source_table_id : source_table_ids_) {
     SCHECK(!source_table_id.empty(), InvalidArgument, "Invalid Table Id");
     SCHECK(
@@ -586,6 +592,10 @@ XClusterInboundReplicationGroupSetupTask::CreateNewUniverseReplicationInfo() {
   metadata->set_state(SysUniverseReplicationEntryPB::ACTIVE);
   metadata->set_transactional(transactional_);
 
+  if (is_db_scoped_) {
+    metadata->mutable_db_scoped_info()->set_automatic_ddl_mode(automatic_ddl_mode_);
+  }
+
   return ri;
 }
 
@@ -922,12 +932,14 @@ Status XClusterTableSetupTask::PopulateTableStreamEntry(
   stream_entry.mutable_producer_schema()->set_last_compatible_consumer_schema_version(
       target_schema_version);
 
-  // Mark this stream as special if it is for the ddl_queue table.
-  auto yb_table_info = parent_task_->catalog_manager_.GetTableInfo(target_table_id);
-  stream_entry.set_is_ddl_queue_table(
-      yb_table_info->GetTableType() == PGSQL_TABLE_TYPE &&
-      yb_table_info->name() == xcluster::kDDLQueueTableName &&
-      yb_table_info->pgschema_name() == xcluster::kDDLQueuePgSchemaName);
+  if (parent_task_->automatic_ddl_mode_) {
+    // Mark this stream as special if it is for the ddl_queue table.
+    auto yb_table_info = parent_task_->catalog_manager_.GetTableInfo(target_table_id);
+    stream_entry.set_is_ddl_queue_table(
+        yb_table_info->GetTableType() == PGSQL_TABLE_TYPE &&
+        yb_table_info->name() == xcluster::kDDLQueueTableName &&
+        yb_table_info->pgschema_name() == xcluster::kDDLQueuePgSchemaName);
+  }
 
   return Status::OK();
 }
diff --git a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h
index 610543190e..deaf1b2e8c 100644
--- a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h
+++ b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h
@@ -167,7 +167,7 @@ class XClusterInboundReplicationGroupSetupTask : public XClusterInboundReplicati
       const google::protobuf::RepeatedPtrField<HostPortPB>& source_masters,
       std::vector<TableId>&& source_table_ids, std::vector<xrepl::StreamId>&& stream_ids,
       bool transactional, std::vector<NamespaceId>&& source_namespace_ids,
-      std::vector<NamespaceId>&& target_namespace_ids);
+      std::vector<NamespaceId>&& target_namespace_ids, bool automatic_ddl_mode);
 
   ~XClusterInboundReplicationGroupSetupTask() = default;
 
@@ -241,15 +241,18 @@ class XClusterInboundReplicationGroupSetupTask : public XClusterInboundReplicati
 
   const xcluster::ReplicationGroupId replication_group_id_;
   const google::protobuf::RepeatedPtrField<HostPortPB> source_masters_;
-  const bool transactional_;
   // The following lists are preserved in the same order they were provided.
   const std::vector<TableId> source_table_ids_;
   const std::vector<xrepl::StreamId> stream_ids_;
   const std::vector<NamespaceId> source_namespace_ids_;
   const std::vector<NamespaceId> target_namespace_ids_;
+
   const bool is_alter_replication_;
-  const bool is_db_scoped_;
   const bool stream_ids_provided_;
+  const bool transactional_;  // Not used in ALTER.
+  const bool is_db_scoped_;  // Not used in ALTER.
+  const bool automatic_ddl_mode_;  // Not used in ALTER.
+
   std::string log_prefix_;
 
   std::shared_ptr<client::XClusterRemoteClientHolder> remote_client_;
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index 9faa8154cc..e01ad15d84 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -42,6 +42,10 @@ DEFINE_RUNTIME_AUTO_bool(enable_tablet_split_of_xcluster_replicated_tables, kExt
     "When set, it enables automatic tablet splitting for tables that are part of an "
     "xCluster replication setup");
 
+// This flag will be converted to a PREVIEW, and then a kExternal Auto flag as the feature matures.
+DEFINE_test_flag(bool, xcluster_enable_ddl_replication, false,
+    "Enables xCluster automatic DDL replication.");
+
 #define LOG_FUNC_AND_RPC \
   LOG_WITH_FUNC(INFO) << req->ShortDebugString() << ", from: " << RequestorString(rpc)
 
@@ -280,15 +284,19 @@ Status XClusterManager::XClusterCreateOutboundReplicationGroup(
     const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
   SCHECK(FLAGS_enable_xcluster_api_v2, IllegalState, "xCluster API v2 is not enabled.");
-  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id);
-  SCHECK(!req->namespace_ids().empty(), InvalidArgument, "Missing Namespace Ids");
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id, namespace_ids);
+  SCHECK(
+      !req->automatic_ddl_mode() || FLAGS_TEST_xcluster_enable_ddl_replication, InvalidArgument,
+      "Automatic DDL replication (TEST_xcluster_enable_ddl_replication) is not enabled.");
 
   std::vector<NamespaceId> namespace_ids;
   for (const auto& namespace_id : req->namespace_ids()) {
     namespace_ids.emplace_back(namespace_id);
   }
+
   RETURN_NOT_OK(CreateOutboundReplicationGroup(
-      xcluster::ReplicationGroupId(req->replication_group_id()), namespace_ids, epoch));
+      xcluster::ReplicationGroupId(req->replication_group_id()), namespace_ids,
+      req->automatic_ddl_mode(), epoch));
 
   return Status::OK();
 }
@@ -526,7 +534,9 @@ Status XClusterManager::GetXClusterOutboundReplicationGroupInfo(
   auto group_info = VERIFY_RESULT(XClusterSourceManager::GetXClusterOutboundReplicationGroupInfo(
       xcluster::ReplicationGroupId(req->replication_group_id())));
 
-  for (const auto& [namespace_id, table_streams] : group_info) {
+  resp->set_automatic_ddl_mode(group_info.automatic_ddl_mode);
+
+  for (const auto& [namespace_id, table_streams] : group_info.namespace_table_map) {
     auto* ns_info = resp->add_namespace_infos();
     ns_info->set_namespace_id(namespace_id);
     for (const auto& [table_id, stream_id] : table_streams) {
@@ -725,6 +735,9 @@ Status XClusterManager::SetupUniverseReplication(
     const SetupUniverseReplicationRequestPB* req, SetupUniverseReplicationResponsePB* resp,
     rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
+  SCHECK(
+      !req->automatic_ddl_mode() || FLAGS_TEST_xcluster_enable_ddl_replication, InvalidArgument,
+      "Automatic DDL replication (TEST_xcluster_enable_ddl_replication) is not enabled.");
 
   return XClusterTargetManager::SetupUniverseReplication(req, resp, epoch);
 }
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
index 99f00a3e48..74d5154ef9 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
@@ -454,10 +454,10 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, CreateTargetReplicationGroup)
 
   std::vector<xrepl::StreamId> streams{xcluster_streams.begin(), xcluster_streams.end()};
   EXPECT_CALL(
-      xcluster_client,
-      SetupDbScopedUniverseReplication(
-          kReplicationGroupId, _, std::vector<NamespaceName>{kNamespaceName},
-          std::vector<NamespaceId>{kNamespaceId}, std::vector<TableId>{kTableId1}, streams))
+      xcluster_client, SetupDbScopedUniverseReplication(
+                           kReplicationGroupId, _, std::vector<NamespaceName>{kNamespaceName},
+                           std::vector<NamespaceId>{kNamespaceId}, std::vector<TableId>{kTableId1},
+                           streams, /*automatic_ddl_mode=*/false))
       .Times(AtLeast(1));
 
   ASSERT_OK(outbound_rg.CreateXClusterReplication({}, {}, kEpoch));
@@ -496,7 +496,7 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, CreateTargetReplicationGroup)
   EXPECT_CALL(xcluster_client, IsSetupUniverseReplicationDone(_))
       .WillOnce(Return(IsOperationDoneResult::Done()));
 
-  EXPECT_CALL(xcluster_client, SetupDbScopedUniverseReplication(_, _, _, _, _, _));
+  EXPECT_CALL(xcluster_client, SetupDbScopedUniverseReplication(_, _, _, _, _, _, _));
 
   // Calling create again should not do anything.
   ASSERT_OK(outbound_rg.CreateXClusterReplication({}, {}, kEpoch));
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
index 658f1ca63b..df581c84a2 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
@@ -728,9 +728,9 @@ Status XClusterOutboundReplicationGroup::CreateXClusterReplication(
   auto target_uuid =
       VERIFY_RESULT(remote_client->GetXClusterClient().SetupDbScopedUniverseReplication(
           Id(), source_master_addresses, namespace_names, namespace_ids, source_table_ids,
-          bootstrap_ids));
+          bootstrap_ids, outbound_group.automatic_ddl_mode()));
 
-  auto* target_universe_info = l.mutable_data()->pb.mutable_target_universe_info();
+  auto* target_universe_info = outbound_group.mutable_target_universe_info();
 
   target_universe_info->set_universe_uuid(target_uuid.ToString());
   target_universe_info->set_state(
@@ -1147,4 +1147,10 @@ Result<std::string> XClusterOutboundReplicationGroup::GetStreamId(
   return table_info->stream_id();
 }
 
+Result<bool> XClusterOutboundReplicationGroup::AutomaticDDLMode() const {
+  SharedLock mutex_lock(mutex_);
+  auto l = VERIFY_RESULT(LockForRead());
+  return l->pb.automatic_ddl_mode();
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.h b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
index 6e919220ce..62c46b1ecd 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.h
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
@@ -138,6 +138,8 @@ class XClusterOutboundReplicationGroup
   Result<std::string> GetStreamId(const NamespaceId& namespace_id, const TableId& table_id) const
       EXCLUDES(mutex_);
 
+  Result<bool> AutomaticDDLMode() const EXCLUDES(mutex_);
+
  private:
   friend class XClusterOutboundReplicationGroupMocked;
   friend class AddTableToXClusterSourceTask;
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index 5e8f3b8991..96b6b3e2c6 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -274,7 +274,8 @@ std::optional<uint32> XClusterSourceManager::GetDefaultWalRetentionSec(
 
 Status XClusterSourceManager::CreateOutboundReplicationGroup(
     const xcluster::ReplicationGroupId& replication_group_id,
-    const std::vector<NamespaceId>& namespace_ids, const LeaderEpoch& epoch) {
+    const std::vector<NamespaceId>& namespace_ids, bool automatic_ddl_mode,
+    const LeaderEpoch& epoch) {
   {
     std::lock_guard l(outbound_replication_group_map_mutex_);
     SCHECK(
@@ -291,7 +292,8 @@ Status XClusterSourceManager::CreateOutboundReplicationGroup(
     outbound_replication_group_map_.erase(replication_group_id);
   });
 
-  SysXClusterOutboundReplicationGroupEntryPB metadata;  // Empty metadata.
+  SysXClusterOutboundReplicationGroupEntryPB metadata;
+  metadata.set_automatic_ddl_mode(automatic_ddl_mode);
   auto outbound_replication_group = InitOutboundReplicationGroup(replication_group_id, metadata);
 
   // This will persist the group to SysCatalog.
@@ -1136,14 +1138,14 @@ XClusterSourceManager::GetXClusterOutboundReplicationGroups(NamespaceId namespac
   return replication_groups;
 }
 
-Result<std::unordered_map<NamespaceId, std::unordered_map<TableId, xrepl::StreamId>>>
+Result<XClusterSourceManager::XClusterOutboundReplicationGroupUserInfo>
 XClusterSourceManager::GetXClusterOutboundReplicationGroupInfo(
     const xcluster::ReplicationGroupId& replication_group_id) {
   auto outbound_replication_group =
       VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
   const auto namespace_ids = VERIFY_RESULT(outbound_replication_group->GetNamespaces());
 
-  std::unordered_map<NamespaceId, std::unordered_map<TableId, xrepl::StreamId>> result;
+  XClusterOutboundReplicationGroupUserInfo result;
   for (const auto& namespace_id : namespace_ids) {
     const auto namespace_info =
         VERIFY_RESULT(outbound_replication_group->GetNamespaceCheckpointInfo(namespace_id));
@@ -1154,8 +1156,10 @@ XClusterSourceManager::GetXClusterOutboundReplicationGroupInfo(
     for (const auto& table_info : namespace_info->table_infos) {
       ns_info.emplace(table_info.table_id, table_info.stream_id);
     }
-    result[namespace_id] = std::move(ns_info);
+    result.namespace_table_map[namespace_id] = std::move(ns_info);
   }
+  result.automatic_ddl_mode = VERIFY_RESULT(outbound_replication_group->AutomaticDDLMode());
+
   return result;
 }
 
diff --git a/src/yb/master/xcluster/xcluster_source_manager.h b/src/yb/master/xcluster/xcluster_source_manager.h
index 4af8293cc8..0edac3a23b 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.h
+++ b/src/yb/master/xcluster/xcluster_source_manager.h
@@ -93,7 +93,8 @@ class XClusterSourceManager {
 
   Status CreateOutboundReplicationGroup(
       const xcluster::ReplicationGroupId& replication_group_id,
-      const std::vector<NamespaceId>& namespace_ids, const LeaderEpoch& epoch);
+      const std::vector<NamespaceId>& namespace_ids, bool automatic_ddl_mode,
+      const LeaderEpoch& epoch);
 
   Status AddNamespaceToOutboundReplicationGroup(
       const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
@@ -160,8 +161,14 @@ class XClusterSourceManager {
   std::vector<xcluster::ReplicationGroupId> GetXClusterOutboundReplicationGroups(
       NamespaceId namespace_filter);
 
-  Result<std::unordered_map<NamespaceId, std::unordered_map<TableId, xrepl::StreamId>>>
-  GetXClusterOutboundReplicationGroupInfo(const xcluster::ReplicationGroupId& replication_group_id);
+  struct XClusterOutboundReplicationGroupUserInfo {
+    std::unordered_map<NamespaceId, std::unordered_map<TableId, xrepl::StreamId>>
+        namespace_table_map;
+    bool automatic_ddl_mode;
+  };
+
+  Result<XClusterOutboundReplicationGroupUserInfo> GetXClusterOutboundReplicationGroupInfo(
+      const xcluster::ReplicationGroupId& replication_group_id);
 
   bool IsTableReplicated(const TableId& table_id) const EXCLUDES(tables_to_stream_map_mutex_);
 
diff --git a/src/yb/master/xcluster/xcluster_status.h b/src/yb/master/xcluster/xcluster_status.h
index 48391faf5f..d3481c1975 100644
--- a/src/yb/master/xcluster/xcluster_status.h
+++ b/src/yb/master/xcluster/xcluster_status.h
@@ -47,6 +47,7 @@ struct XClusterInboundReplicationGroupStatus {
   std::string db_scoped_info;
   // Map of target namespace id to source namespace id. Only used in db scope replication.
   std::unordered_map<NamespaceId, NamespaceId> db_scope_namespace_id_map;
+  bool automatic_ddl_mode = false;
   std::unordered_map<NamespaceName, std::vector<InboundXClusterReplicationGroupTableStatus>>
       table_statuses_by_namespace;
 };
diff --git a/src/yb/master/xcluster/xcluster_target_manager.cc b/src/yb/master/xcluster/xcluster_target_manager.cc
index db12c45e16..07c8fe1f37 100644
--- a/src/yb/master/xcluster/xcluster_target_manager.cc
+++ b/src/yb/master/xcluster/xcluster_target_manager.cc
@@ -446,6 +446,11 @@ Result<XClusterInboundReplicationGroupStatus> XClusterTargetManager::GetUniverse
 
   if (IsDbScoped(replication_info_pb)) {
     result.replication_type = XClusterReplicationType::XCLUSTER_YSQL_DB_SCOPED;
+    result.automatic_ddl_mode = replication_info_pb.db_scoped_info().automatic_ddl_mode();
+
+    result.db_scoped_info += Format(
+        "ddl_mode: $0",
+        replication_info_pb.db_scoped_info().automatic_ddl_mode() ? "automatic" : "semi-automatic");
     for (const auto& namespace_info : replication_info_pb.db_scoped_info().namespace_infos()) {
       result.db_scope_namespace_id_map[namespace_info.consumer_namespace_id()] =
           namespace_info.producer_namespace_id();
diff --git a/src/yb/tools/yb-admin_cli.cc b/src/yb/tools/yb-admin_cli.cc
index 654470a774..b22d5b7b58 100644
--- a/src/yb/tools/yb-admin_cli.cc
+++ b/src/yb/tools/yb-admin_cli.cc
@@ -2610,7 +2610,10 @@ Status get_universe_replication_info_action(
   if (group_info.replication_type == XClusterReplicationType::XCLUSTER_YSQL_DB_SCOPED) {
     std::cout << std::endl
               << "DB Scoped info(s):" << std::endl
+              << "DDL mode: " << (group_info.automatic_ddl_mode ? "Automatic" : "Semi-automatic")
+              << std::endl
               << "Namespace name\t\tTarget Namespace ID\t\tSource Namespace ID" << std::endl;
+
     for (const auto& [target_namespace_id, source_namespace_id] :
          group_info.db_scope_namespace_id_map) {
       auto* namespace_info = FindOrNull(namespace_map, target_namespace_id);
diff --git a/src/yb/tserver/xcluster_consumer.cc b/src/yb/tserver/xcluster_consumer.cc
index d4a5f55473..17e978b937 100644
--- a/src/yb/tserver/xcluster_consumer.cc
+++ b/src/yb/tserver/xcluster_consumer.cc
@@ -95,9 +95,6 @@ DEFINE_validator(xcluster_safe_time_update_interval_secs, &ValidateXClusterSafeT
 DEFINE_test_flag(bool, xcluster_disable_delete_old_pollers, false,
     "Disables the deleting of old xcluster pollers that are no longer needed.");
 
-DEFINE_test_flag(bool, xcluster_enable_ddl_replication, false,
-    "Enables xCluster automatic DDL replication.");
-
 using namespace std::chrono_literals;
 
 #define ACQUIRE_SHARED_LOCK_IF_ONLINE \
@@ -530,8 +527,7 @@ void XClusterConsumer::TriggerPollForNewTablets() {
             thread_pool_.get(), rpcs_.get(), local_client_, remote_clients_[replication_group_id],
             this, last_compatible_consumer_schema_version, leader_term, get_leader_term_func_);
 
-        if (FLAGS_TEST_xcluster_enable_ddl_replication &&
-            ddl_queue_streams_.contains(producer_tablet_info.stream_id)) {
+        if (ddl_queue_streams_.contains(producer_tablet_info.stream_id)) {
           xcluster_poller->InitDDLQueuePoller(
               use_local_tserver, rate_limiter_.get(), namespace_name, xcluster_context_,
               connect_to_pg_func_);
