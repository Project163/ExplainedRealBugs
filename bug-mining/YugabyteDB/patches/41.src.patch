diff --git a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
index b4c7c6e2a7..61711d97f9 100644
--- a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
@@ -237,5 +237,23 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
   ASSERT_TRUE(final_xcluster_streams.empty());
 }
 
+TEST_F(XClusterOutboundReplicationGroupTest, AddTable) {
+  auto ns1_table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
+
+  ASSERT_OK(client_->XClusterCreateOutboundReplicationGroup(kReplicationGroupId, {kNamespaceName}));
+
+  auto all_xcluster_streams_initial = CleanupAndGetAllXClusterStreams();
+  ASSERT_EQ(all_xcluster_streams_initial.size(), 1);
+
+  auto ns1_table_id_2 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName2));
+
+  all_xcluster_streams_initial = CleanupAndGetAllXClusterStreams();
+  ASSERT_EQ(all_xcluster_streams_initial.size(), 2);
+
+  auto ns1_info = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
+  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(
+      ns1_table_id_1, ns1_table_id_2, all_xcluster_streams_initial, ns1_info));
+}
+
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/CMakeLists.txt b/src/yb/master/CMakeLists.txt
index eb4f70e294..2e43422588 100644
--- a/src/yb/master/CMakeLists.txt
+++ b/src/yb/master/CMakeLists.txt
@@ -131,6 +131,7 @@ set(MASTER_SRCS
   ts_manager.cc
   universe_key_registry_service.cc
   util/yql_vtable_helpers.cc
+  xcluster/add_table_to_xcluster_source_task.cc
   xcluster/add_table_to_xcluster_target_task.cc
   xcluster/xcluster_catalog_entity.cc
   xcluster/xcluster_config.cc
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index ba20766dd2..7a0149b11b 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -1554,6 +1554,11 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
 
   std::shared_ptr<ClusterConfigInfo> ClusterConfig() const;
 
+  Status CreateNewXReplStream(
+      const CreateCDCStreamRequestPB& req, CreateNewCDCStreamMode mode,
+      const std::vector<TableId>& table_ids, const std::optional<const NamespaceId>& namespace_id,
+      CreateCDCStreamResponsePB* resp, const LeaderEpoch& epoch, rpc::RpcContext* rpc);
+
  protected:
   // TODO Get rid of these friend classes and introduce formal interface.
   friend class TableLoader;
@@ -2728,12 +2733,8 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
       SysSnapshotEntryPB::State state, SysSnapshotEntryPB* snapshot_pb);
 
   Status CreateNewCDCStreamForNamespace(
-      const CreateCDCStreamRequestPB& req,
-      CreateCDCStreamResponsePB* resp, rpc::RpcContext* rpc, const LeaderEpoch& epoch);
-  Status CreateNewXReplStream(
-      const CreateCDCStreamRequestPB& req, CreateNewCDCStreamMode mode,
-      const std::vector<TableId>& table_ids, const std::optional<const NamespaceId>& namespace_id,
-      CreateCDCStreamResponsePB* resp, const LeaderEpoch& epoch, rpc::RpcContext* rpc);
+      const CreateCDCStreamRequestPB& req, CreateCDCStreamResponsePB* resp, rpc::RpcContext* rpc,
+      const LeaderEpoch& epoch);
 
   Status PopulateCDCStateTable(const xrepl::StreamId& stream_id,
                                const std::vector<TableId>& table_ids,
diff --git a/src/yb/master/xcluster/add_table_to_xcluster_source_task.cc b/src/yb/master/xcluster/add_table_to_xcluster_source_task.cc
new file mode 100644
index 0000000000..b037264aa0
--- /dev/null
+++ b/src/yb/master/xcluster/add_table_to_xcluster_source_task.cc
@@ -0,0 +1,52 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/master/xcluster/add_table_to_xcluster_source_task.h"
+
+#include "yb/master/catalog_manager.h"
+#include "yb/master/xcluster/xcluster_outbound_replication_group.h"
+
+namespace yb::master {
+
+using namespace std::placeholders;
+
+AddTableToXClusterSourceTask::AddTableToXClusterSourceTask(
+    std::shared_ptr<XClusterOutboundReplicationGroup> outbound_replication_group,
+    CatalogManager& catalog_manager, rpc::Messenger& messenger, TableInfoPtr table_info,
+    const LeaderEpoch& epoch)
+    : PostTabletCreateTaskBase(
+          catalog_manager, *catalog_manager.AsyncTaskPool(), messenger, std::move(table_info),
+          epoch),
+      outbound_replication_group_(std::move(outbound_replication_group)) {}
+
+std::string AddTableToXClusterSourceTask::description() const {
+  return Format("AddTableToXClusterSourceTask [$0]", table_info_->id());
+}
+
+Status AddTableToXClusterSourceTask::FirstStep() {
+  outbound_replication_group_->AddTable(
+      table_info_, epoch_, std::bind(&AddTableToXClusterSourceTask::CompletionCallback, this, _1));
+
+  return Status::OK();
+}
+
+void AddTableToXClusterSourceTask::CompletionCallback(const Status& status) {
+  if (status.ok()) {
+    Complete();
+    return;
+  }
+
+  AbortAndReturnPrevState(status);
+}
+
+}  // namespace yb::master
diff --git a/src/yb/master/xcluster/add_table_to_xcluster_source_task.h b/src/yb/master/xcluster/add_table_to_xcluster_source_task.h
new file mode 100644
index 0000000000..703761c638
--- /dev/null
+++ b/src/yb/master/xcluster/add_table_to_xcluster_source_task.h
@@ -0,0 +1,47 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include "yb/client/client_fwd.h"
+
+#include "yb/master/post_tablet_create_task_base.h"
+
+namespace yb::master {
+
+class XClusterOutboundReplicationGroup;
+
+class AddTableToXClusterSourceTask : public PostTabletCreateTaskBase {
+ public:
+  explicit AddTableToXClusterSourceTask(
+      std::shared_ptr<XClusterOutboundReplicationGroup> outbound_replication_group,
+      CatalogManager& catalog_manager, rpc::Messenger& messenger, TableInfoPtr table_info,
+      const LeaderEpoch& epoch);
+
+  server::MonitoredTaskType type() const override {
+    return server::MonitoredTaskType::kAddTableToXClusterSource;
+  }
+
+  std::string type_name() const override { return "Add table to xCluster source replication"; }
+
+  std::string description() const override;
+
+ private:
+  Status FirstStep() override;
+
+  void CompletionCallback(const Status& status);
+
+  const std::shared_ptr<XClusterOutboundReplicationGroup> outbound_replication_group_;
+};
+
+}  // namespace yb::master
diff --git a/src/yb/master/xcluster/master_xcluster_types.h b/src/yb/master/xcluster/master_xcluster_types.h
index 23c55076bb..bed137e98c 100644
--- a/src/yb/master/xcluster/master_xcluster_types.h
+++ b/src/yb/master/xcluster/master_xcluster_types.h
@@ -44,4 +44,6 @@ struct IsOperationDoneResult {
   Status status;  // If the operation completed and it failed, this will contain the error.
 };
 
+YB_DEFINE_ENUM(StreamCheckpointLocation, (kOpId0)(kCurrentEndOfWAL));
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
index e2551f605a..91f2d0afea 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
@@ -163,8 +163,10 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
       .get_tables_func =
           [this](const NamespaceId& namespace_id) { return namespace_tables[namespace_id]; },
       .bootstrap_tables_func =
-          [this](const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline)
-          -> Result<std::vector<xrepl::StreamId>> {
+          [this](
+              const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline,
+              StreamCheckpointLocation checkpoint_location,
+              const LeaderEpoch& epoch) -> Result<std::vector<xrepl::StreamId>> {
         std::vector<xrepl::StreamId> stream_ids;
         for (const auto& table_info : table_infos) {
           stream_ids.emplace_back(CreateXClusterStream(table_info->id()));
@@ -228,8 +230,10 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, TestMultipleTable) {
   auto outbound_rg_ptr = CreateReplicationGroup();
   auto& outbound_rg = *outbound_rg_ptr;
 
+  ASSERT_FALSE(outbound_rg.HasNamespace(kNamespaceId));
   auto namespace_id = ASSERT_RESULT(outbound_rg.AddNamespace(kEpoch, kNamespaceName, kDeadline));
   ASSERT_EQ(namespace_id, kNamespaceId);
+  ASSERT_TRUE(outbound_rg.HasNamespace(kNamespaceId));
 
   auto ns_info_opt = ASSERT_RESULT(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
   ASSERT_TRUE(ns_info_opt.has_value());
@@ -322,6 +326,7 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddDeleteNamespaces) {
   ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(ns2_table_id_1, ns2_table_id_2, *ns2_info_opt));
 
   ASSERT_OK(outbound_rg.RemoveNamespace(kEpoch, kNamespaceId));
+  ASSERT_FALSE(outbound_rg.HasNamespace(kNamespaceId));
   ASSERT_NOK(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
 
   // We should only have only the streams from second namespace.
@@ -333,6 +338,7 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddDeleteNamespaces) {
   }
 
   ASSERT_OK(outbound_rg.Delete(kEpoch));
+  ASSERT_FALSE(outbound_rg.HasNamespace(namespace_id_2));
   ASSERT_NOK(outbound_rg.GetNamespaceCheckpointInfo(namespace_id_2));
   ASSERT_TRUE(xcluster_streams.empty());
 }
@@ -399,4 +405,39 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, CreateTargetReplicationGroup)
       SysXClusterOutboundReplicationGroupEntryPB::TargetUniverseInfo::REPLICATING);
 }
 
+TEST_F(XClusterOutboundReplicationGroupMockedTest, AddTable) {
+  auto table_info1 = CreateTable(kNamespaceId, kTableId1, kTableName1, kPgSchemaName);
+  CreateTable(kNamespaceId, kTableId2, kTableName2, kPgSchemaName2);
+
+  auto outbound_rg = CreateReplicationGroup();
+  auto namespace_id = ASSERT_RESULT(outbound_rg->AddNamespace(kEpoch, kNamespaceName, kDeadline));
+  ASSERT_TRUE(outbound_rg->HasNamespace(kNamespaceId));
+  ASSERT_EQ(xcluster_streams.size(), 2);
+
+  auto ns_info = ASSERT_RESULT(outbound_rg->GetNamespaceCheckpointInfo(kNamespaceId));
+  ASSERT_EQ(ns_info->table_infos.size(), 2);
+
+  std::promise<Status> promise;
+  auto completion_cb = [&promise](const Status& status) { promise.set_value(status); };
+
+  // Same table should not get added twice.
+  outbound_rg->AddTable(table_info1, kEpoch, completion_cb);
+  ASSERT_OK(promise.get_future().get());
+
+  ASSERT_EQ(ns_info->table_infos.size(), 2);
+
+  const TableName table_3 = "table3";
+  const TableId table_id_3 = "table_id_3";
+  auto table_info3 = CreateTable(kNamespaceId, table_id_3, table_3, kPgSchemaName);
+
+  promise = {};
+  outbound_rg->AddTable(table_info3, kEpoch, completion_cb);
+  ASSERT_OK(promise.get_future().get());
+
+  ASSERT_EQ(xcluster_streams.size(), 3);
+  ns_info = ASSERT_RESULT(outbound_rg->GetNamespaceCheckpointInfo(kNamespaceId));
+  ASSERT_TRUE(ns_info.has_value());
+  ASSERT_EQ(ns_info->table_infos.size(), 3);
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
index 021e5e4c4b..0e304bf728 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
@@ -63,7 +63,7 @@ XClusterOutboundReplicationGroup::LockForWrite() {
 
 Result<SysXClusterOutboundReplicationGroupEntryPB> XClusterOutboundReplicationGroup::GetMetadata()
     const {
-  SharedLock m_l(mutex_);
+  SharedLock mutex_lock(mutex_);
   auto l = VERIFY_RESULT(LockForRead());
   return l->pb;
 }
@@ -77,15 +77,16 @@ Status XClusterOutboundReplicationGroup::Upsert(
 
 Result<SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB>
 XClusterOutboundReplicationGroup::BootstrapTables(
-    const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline) {
+    const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline,
+    const LeaderEpoch& epoch) {
   VLOG_WITH_PREFIX_AND_FUNC(1) << yb::ToString(table_infos);
 
   SCHECK(!table_infos.empty(), InvalidArgument, "No tables to bootstrap");
   SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB ns_info;
   ns_info.set_state(SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB::CHECKPOINTING);
 
-  auto bootstrap_ids =
-      VERIFY_RESULT(helper_functions_.bootstrap_tables_func(table_infos, deadline));
+  auto bootstrap_ids = VERIFY_RESULT(helper_functions_.bootstrap_tables_func(
+      table_infos, deadline, StreamCheckpointLocation::kCurrentEndOfWAL, epoch));
 
   SCHECK_EQ(
       table_infos.size(), bootstrap_ids.size(), IllegalState,
@@ -110,7 +111,7 @@ XClusterOutboundReplicationGroup::BootstrapTables(
 
 Result<NamespaceId> XClusterOutboundReplicationGroup::AddNamespaceInternal(
     const NamespaceName& namespace_name, CoarseTimePoint deadline,
-    XClusterOutboundReplicationGroupInfo::WriteLock& l) {
+    XClusterOutboundReplicationGroupInfo::WriteLock& l, const LeaderEpoch& epoch) {
   SCHECK(!namespace_name.empty(), InvalidArgument, "Namespace name cannot be empty");
   VLOG_WITH_PREFIX_AND_FUNC(1) << namespace_name;
 
@@ -119,14 +120,14 @@ Result<NamespaceId> XClusterOutboundReplicationGroup::AddNamespaceInternal(
 
   auto& outbound_group_pb = l.mutable_data()->pb;
 
-  if (outbound_group_pb.namespace_infos().count(namespace_id) > 0) {
+  if (HasNamespaceUnlocked(namespace_id)) {
     LOG(INFO) << "Skip adding Namespace " << namespace_name << " since it already exists in "
               << ToString();
     return namespace_id;
   }
 
   auto table_infos = VERIFY_RESULT(helper_functions_.get_tables_func(namespace_id));
-  auto ns_checkpoint_info = VERIFY_RESULT(BootstrapTables(table_infos, deadline));
+  auto ns_checkpoint_info = VERIFY_RESULT(BootstrapTables(table_infos, deadline, epoch));
   (*outbound_group_pb.mutable_namespace_infos())[namespace_id] = std::move(ns_checkpoint_info);
 
   return namespace_id;
@@ -135,12 +136,12 @@ Result<NamespaceId> XClusterOutboundReplicationGroup::AddNamespaceInternal(
 Result<std::vector<NamespaceId>> XClusterOutboundReplicationGroup::AddNamespaces(
     const LeaderEpoch& epoch, const std::vector<NamespaceName>& namespace_names,
     CoarseTimePoint deadline) {
-  std::lock_guard m_l(mutex_);
+  std::lock_guard mutex_lock(mutex_);
   auto l = VERIFY_RESULT(LockForWrite());
 
   std::vector<NamespaceId> namespace_ids;
   for (const auto& namespace_name : namespace_names) {
-    auto namespace_id = VERIFY_RESULT(AddNamespaceInternal(namespace_name, deadline, l));
+    auto namespace_id = VERIFY_RESULT(AddNamespaceInternal(namespace_name, deadline, l, epoch));
     namespace_ids.push_back(std::move(namespace_id));
   }
   RETURN_NOT_OK(Upsert(l, epoch));
@@ -149,9 +150,9 @@ Result<std::vector<NamespaceId>> XClusterOutboundReplicationGroup::AddNamespaces
 
 Result<NamespaceId> XClusterOutboundReplicationGroup::AddNamespace(
     const LeaderEpoch& epoch, const NamespaceName& namespace_name, CoarseTimePoint deadline) {
-  std::lock_guard m_l(mutex_);
+  std::lock_guard mutex_lock(mutex_);
   auto l = VERIFY_RESULT(LockForWrite());
-  auto namespace_id = VERIFY_RESULT(AddNamespaceInternal(namespace_name, deadline, l));
+  auto namespace_id = VERIFY_RESULT(AddNamespaceInternal(namespace_name, deadline, l, epoch));
   RETURN_NOT_OK(Upsert(l, epoch));
 
   return namespace_id;
@@ -160,7 +161,7 @@ Result<NamespaceId> XClusterOutboundReplicationGroup::AddNamespace(
 Status XClusterOutboundReplicationGroup::DeleteNamespaceStreams(
     const LeaderEpoch& epoch, const NamespaceId& namespace_id,
     const SysXClusterOutboundReplicationGroupEntryPB& outbound_group_pb) {
-  if (!outbound_group_pb.namespace_infos().count(namespace_id)) {
+  if (!HasNamespaceUnlocked(namespace_id)) {
     return Status::OK();
   }
 
@@ -192,7 +193,7 @@ Status XClusterOutboundReplicationGroup::DeleteNamespaceStreams(
 
 Status XClusterOutboundReplicationGroup::RemoveNamespace(
     const LeaderEpoch& epoch, const NamespaceId& namespace_id) {
-  std::lock_guard m_l(mutex_);
+  std::lock_guard mutex_lock(mutex_);
   auto l = VERIFY_RESULT(LockForWrite());
   auto& outbound_group_pb = l.mutable_data()->pb;
 
@@ -204,7 +205,7 @@ Status XClusterOutboundReplicationGroup::RemoveNamespace(
 }
 
 Status XClusterOutboundReplicationGroup::Delete(const LeaderEpoch& epoch) {
-  std::lock_guard m_l(mutex_);
+  std::lock_guard mutex_lock(mutex_);
   auto l = VERIFY_RESULT(LockForWrite());
   auto& outbound_group_pb = l.mutable_data()->pb;
 
@@ -222,11 +223,11 @@ Status XClusterOutboundReplicationGroup::Delete(const LeaderEpoch& epoch) {
 
 Result<std::optional<bool>> XClusterOutboundReplicationGroup::IsBootstrapRequired(
     const NamespaceId& namespace_id) const {
-  SharedLock m_l(mutex_);
+  SharedLock mutex_lock(mutex_);
   auto l = VERIFY_RESULT(LockForRead());
   auto& outbound_group = l->pb;
   SCHECK(
-      outbound_group.namespace_infos().count(namespace_id) > 0, NotFound,
+      HasNamespaceUnlocked(namespace_id), NotFound,
       Format("Namespace $0 not found in $1", namespace_id, ToString()));
 
   auto& namespace_info = outbound_group.namespace_infos().at(namespace_id);
@@ -242,11 +243,11 @@ Result<std::optional<NamespaceCheckpointInfo>>
 XClusterOutboundReplicationGroup::GetNamespaceCheckpointInfo(
     const NamespaceId& namespace_id,
     const std::vector<std::pair<TableName, PgSchemaName>>& table_names) const {
-  SharedLock m_l(mutex_);
+  SharedLock mutex_lock(mutex_);
   auto l = VERIFY_RESULT(LockForRead());
   auto& outbound_group = l->pb;
   SCHECK(
-      outbound_group.namespace_infos().count(namespace_id) > 0, NotFound,
+      HasNamespaceUnlocked(namespace_id), NotFound,
       Format("Namespace $0 not found in xClusterOutboundReplicationGroup $1", namespace_id, Id()));
 
   auto& namespace_info = outbound_group.namespace_infos().at(namespace_id);
@@ -323,7 +324,7 @@ XClusterOutboundReplicationGroup::GetRemoteClient(
 Status XClusterOutboundReplicationGroup::CreateXClusterReplication(
     const std::vector<HostPort>& source_master_addresses,
     const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch) {
-  std::lock_guard m_l(mutex_);
+  std::lock_guard mutex_lock(mutex_);
   auto l = VERIFY_RESULT(LockForWrite());
   auto& outbound_group = l.mutable_data()->pb;
 
@@ -382,7 +383,7 @@ Status XClusterOutboundReplicationGroup::CreateXClusterReplication(
 
 Result<IsOperationDoneResult> XClusterOutboundReplicationGroup::IsCreateXClusterReplicationDone(
     const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch) {
-  std::lock_guard m_l(mutex_);
+  std::lock_guard mutex_lock(mutex_);
   auto l = VERIFY_RESULT(LockForWrite());
   auto& outbound_group = l.mutable_data()->pb;
   SCHECK(outbound_group.has_target_universe_info(), IllegalState, "Target universe info not found");
@@ -430,4 +431,68 @@ Result<IsOperationDoneResult> XClusterOutboundReplicationGroup::IsCreateXCluster
   return setup_result;
 }
 
+bool XClusterOutboundReplicationGroup::HasNamespace(const NamespaceId& namespace_id) const {
+  SharedLock mutex_lock(mutex_);
+  auto lock_result = LockForRead();
+  if (!lock_result.ok()) {
+    // The only allowed error is NotFound which indicates the group is deleted.
+    LOG_IF_WITH_PREFIX(DFATAL, !lock_result.status().IsNotFound())
+        << "Unexpected lock outcome: " << lock_result.status();
+    return false;
+  }
+  return HasNamespaceUnlocked(namespace_id);
+}
+
+bool XClusterOutboundReplicationGroup::HasNamespaceUnlocked(const NamespaceId& namespace_id) const {
+  return outbound_rg_info_->old_pb().namespace_infos().count(namespace_id) > 0;
+}
+
+Status XClusterOutboundReplicationGroup::AddTableInternal(
+    TableInfoPtr table_info, const LeaderEpoch& epoch) {
+  std::lock_guard mutex_lock(mutex_);
+  auto lock_result = LockForWrite();
+  if (!lock_result.ok()) {
+    RSTATUS_DCHECK(
+        lock_result.status().IsNotFound(), IllegalState, "Unexpected lock outcome: $0",
+        lock_result.status());
+    VLOG_WITH_PREFIX_AND_FUNC(2) << "Replication group deleted";
+    return Status::OK();
+  }
+
+  const auto table_id = table_info->id();
+  const auto namespace_id = table_info->namespace_id();
+  auto& outbound_group_pb = lock_result->mutable_data()->pb;
+  if (!HasNamespaceUnlocked(namespace_id)) {
+    // Namespace was deleted between between locks. Since this is used in
+    // AddTableToXClusterSourceTask, which runs asynchronously and we do not want to fail the task,
+    // we can just return OK.
+    VLOG_WITH_PREFIX_AND_FUNC(2) << "Namespace " << namespace_id
+                                 << " is no longer part of this replication group";
+    return Status::OK();
+  }
+  auto& ns_info = outbound_group_pb.mutable_namespace_infos()->at(namespace_id);
+  if (ns_info.table_infos().count(table_id)) {
+    VLOG_WITH_PREFIX_AND_FUNC(2) << "Table " << table_info
+                                 << " is already a part of this replication group";
+    return Status::OK();
+  }
+
+  auto stream_ids = VERIFY_RESULT(helper_functions_.bootstrap_tables_func(
+      {table_info}, CoarseMonoClock::now(), StreamCheckpointLocation::kOpId0, epoch));
+  CHECK_EQ(stream_ids.size(), 1);
+
+  SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB::TableInfoPB ns_table_info;
+  ns_table_info.set_stream_id(stream_ids.front().ToString());
+  ns_info.mutable_table_infos()->insert({table_id, std::move(ns_table_info)});
+
+  return Upsert(*lock_result, epoch);
+}
+
+void XClusterOutboundReplicationGroup::AddTable(
+    const TableInfoPtr& table_info, const LeaderEpoch& epoch, StdStatusCallback completion_cb) {
+  // TODO(#20810): Perform checkpointing step which involves a cdc_state_table write asynchronously
+  // and push down the callback.
+  completion_cb(AddTableInternal(table_info, epoch));
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.h b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
index 7ccc8c7dd3..a3123f75c3 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.h
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
@@ -37,7 +37,8 @@ class XClusterOutboundReplicationGroup
     const std::function<Result<NamespaceName>(const NamespaceId&)> get_namespace_name_func;
     const std::function<Result<std::vector<TableInfoPtr>>(const NamespaceId&)> get_tables_func;
     const std::function<Result<std::vector<xrepl::StreamId>>(
-        const std::vector<TableInfoPtr>&, CoarseTimePoint)>
+        const std::vector<TableInfoPtr>&, CoarseTimePoint,
+        StreamCheckpointLocation checkpoint_location, const LeaderEpoch& epoch)>
         bootstrap_tables_func;
     const std::function<Result<DeleteCDCStreamResponsePB>(
         const DeleteCDCStreamRequestPB&, const LeaderEpoch&)>
@@ -97,6 +98,12 @@ class XClusterOutboundReplicationGroup
       const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch)
       EXCLUDES(mutex_);
 
+  bool HasNamespace(const NamespaceId& namespace_id) const EXCLUDES(mutex_);
+
+  void AddTable(
+      const TableInfoPtr& table_info, const LeaderEpoch& epoch, StdStatusCallback completion_cb)
+      EXCLUDES(mutex_);
+
  private:
   friend class XClusterOutboundReplicationGroupMocked;
 
@@ -110,7 +117,8 @@ class XClusterOutboundReplicationGroup
 
   Result<NamespaceId> AddNamespaceInternal(
       const NamespaceName& namespace_name, CoarseTimePoint deadline,
-      XClusterOutboundReplicationGroupInfo::WriteLock& l) REQUIRES(mutex_);
+      XClusterOutboundReplicationGroupInfo::WriteLock& l, const LeaderEpoch& epoch)
+      REQUIRES(mutex_);
 
   Status Upsert(XClusterOutboundReplicationGroupInfo::WriteLock& l, const LeaderEpoch& epoch)
       REQUIRES(mutex_);
@@ -121,13 +129,22 @@ class XClusterOutboundReplicationGroup
       const SysXClusterOutboundReplicationGroupEntryPB& pb) REQUIRES(mutex_);
 
   Result<SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB> BootstrapTables(
-      const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline) REQUIRES(mutex_);
+      const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline,
+      const LeaderEpoch& epoch) REQUIRES(mutex_);
 
   virtual Result<std::shared_ptr<client::XClusterRemoteClient>> GetRemoteClient(
       const std::vector<HostPort>& remote_masters) const;
 
+  // Checks if the namespace is part of this replication group. Caller must hold the read or write
+  // lock on outbound_rg_info_. Checks the old_pb
+  bool HasNamespaceUnlocked(const NamespaceId& namespace_id) const REQUIRES_SHARED(mutex_);
+
+  Status AddTableInternal(TableInfoPtr table_info, const LeaderEpoch& epoch)
+      EXCLUDES(mutex_);
+
   HelperFunctions helper_functions_;
 
+  // Mutex used to ensure reads are not allowed when writes are happening.
   mutable std::shared_mutex mutex_;
   std::unique_ptr<XClusterOutboundReplicationGroupInfo> outbound_rg_info_;
 
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index 9e53e3077f..7f0efc5dad 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -15,6 +15,8 @@
 
 #include "yb/cdc/cdc_service.proxy.h"
 #include "yb/master/catalog_manager.h"
+#include "yb/master/master.h"
+#include "yb/master/xcluster/add_table_to_xcluster_source_task.h"
 #include "yb/master/xcluster/xcluster_catalog_entity.h"
 
 #include "yb/rpc/rpc_context.h"
@@ -128,9 +130,11 @@ XClusterSourceManager::InitOutboundReplicationGroup(
       .get_tables_func =
           [this](const NamespaceId& namespace_id) { return GetTablesToReplicate(namespace_id); },
       .bootstrap_tables_func =
-          [this](const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline)
-          -> Result<std::vector<xrepl::StreamId>> {
-        return BootstrapTables(table_infos, deadline);
+          [this](
+              const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline,
+              StreamCheckpointLocation checkpoint_location,
+              const LeaderEpoch& epoch) -> Result<std::vector<xrepl::StreamId>> {
+        return BootstrapTables(table_infos, deadline, checkpoint_location, epoch);
       },
       .delete_cdc_stream_func = [&catalog_manager = catalog_manager_](
                                     const DeleteCDCStreamRequestPB& req,
@@ -177,7 +181,34 @@ Result<std::vector<TableInfoPtr>> XClusterSourceManager::GetTablesToReplicate(
 }
 
 Result<std::vector<xrepl::StreamId>> XClusterSourceManager::BootstrapTables(
-    const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline) {
+    const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline,
+    StreamCheckpointLocation checkpoint_location, const LeaderEpoch& epoch) {
+  if (checkpoint_location == StreamCheckpointLocation::kOpId0) {
+    std::vector<xrepl::StreamId> stream_ids;
+    for (const auto& table_info : table_infos) {
+      const auto& table_id = table_info->id();
+      master::CreateCDCStreamRequestPB create_stream_req;
+      master::CreateCDCStreamResponsePB create_stream_resp;
+      create_stream_req.set_table_id(table_info->id());
+
+      // TODO: #20769 Apply appropriate WAL retention on the table.
+      RETURN_NOT_OK(catalog_manager_.CreateNewXReplStream(
+          create_stream_req, CreateNewCDCStreamMode::kXClusterTableIds, {table_id},
+          /*namespace_id=*/std::nullopt, &create_stream_resp, epoch, /*rpc=*/nullptr));
+
+      if (create_stream_resp.has_error()) {
+        return StatusFromPB(create_stream_resp.error().status());
+      }
+      stream_ids.emplace_back(
+          VERIFY_RESULT(xrepl::StreamId::FromString(create_stream_resp.stream_id())));
+    }
+
+    return stream_ids;
+  }
+
+  LOG_IF(DFATAL, checkpoint_location != StreamCheckpointLocation::kCurrentEndOfWAL)
+      << "Not implemented yet. Checkpoint location: " << checkpoint_location;
+
   cdc::BootstrapProducerRequestPB bootstrap_req;
   master::TSDescriptor* ts = nullptr;
   for (const auto& table_info : table_infos) {
@@ -216,7 +247,23 @@ Result<std::vector<xrepl::StreamId>> XClusterSourceManager::BootstrapTables(
 std::vector<std::shared_ptr<PostTabletCreateTaskBase>>
 XClusterSourceManager::GetPostTabletCreateTasks(
     const TableInfoPtr& table_info, const LeaderEpoch& epoch) {
-  return {};
+  if (!ShouldReplicateTable(table_info)) {
+    return {};
+  }
+
+  // Create a AddTableToXClusterSourceTask for each outbound replication group that has the
+  // tables namespace.
+  std::vector<std::shared_ptr<PostTabletCreateTaskBase>> tasks;
+  const auto namespace_id = table_info->namespace_id();
+  SharedLock l(outbound_replication_group_map_mutex_);
+  for (const auto& [_, outbound_replication_group] : outbound_replication_group_map_) {
+    if (outbound_replication_group && outbound_replication_group->HasNamespace(namespace_id)) {
+      tasks.emplace_back(std::make_shared<AddTableToXClusterSourceTask>(
+          outbound_replication_group, catalog_manager_, *master_.messenger(), table_info, epoch));
+    }
+  }
+
+  return tasks;
 }
 
 Result<std::vector<NamespaceId>> XClusterSourceManager::CreateOutboundReplicationGroup(
diff --git a/src/yb/master/xcluster/xcluster_source_manager.h b/src/yb/master/xcluster/xcluster_source_manager.h
index fd86a5d2b5..2bddf21f68 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.h
+++ b/src/yb/master/xcluster/xcluster_source_manager.h
@@ -102,7 +102,8 @@ class XClusterSourceManager {
   Result<std::vector<TableInfoPtr>> GetTablesToReplicate(const NamespaceId& namespace_id);
 
   Result<std::vector<xrepl::StreamId>> BootstrapTables(
-      const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline);
+      const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline,
+      StreamCheckpointLocation checkpoint_location, const LeaderEpoch& epoch);
 
   Master& master_;
   CatalogManager& catalog_manager_;
diff --git a/src/yb/server/monitored_task.h b/src/yb/server/monitored_task.h
index 48286eb578..2afcda1e97 100644
--- a/src/yb/server/monitored_task.h
+++ b/src/yb/server/monitored_task.h
@@ -84,7 +84,8 @@ YB_DEFINE_ENUM(MonitoredTaskType,
   (kTryStepDown)
   (kUpdateTransactionTablesVersion)
   (kAddTableToXClusterTarget)
-  (kMarkTableAsRunning));
+  (kMarkTableAsRunning)
+  (kAddTableToXClusterSource));
 
 class MonitoredTask : public std::enable_shared_from_this<MonitoredTask> {
  public:
