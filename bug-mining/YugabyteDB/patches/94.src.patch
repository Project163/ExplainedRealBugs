diff --git a/src/yb/cdc/xcluster_util.cc b/src/yb/cdc/xcluster_util.cc
index d4229fbf19..4fa22a3163 100644
--- a/src/yb/cdc/xcluster_util.cc
+++ b/src/yb/cdc/xcluster_util.cc
@@ -12,6 +12,7 @@
 //
 
 #include "yb/cdc/xcluster_util.h"
+#include "yb/gutil/strings/util.h"
 
 namespace yb::xcluster {
 
@@ -35,4 +36,10 @@ ReplicationGroupId GetOriginalReplicationGroupId(const ReplicationGroupId& repli
   }
   return ReplicationGroupId(clean_id.ToString());
 }
+
+std::string ShortReplicationType(XClusterReplicationType type) {
+  return StringReplace(
+      XClusterReplicationType_Name(type), "XCLUSTER_", "",
+      /*replace_all=*/false);
+}
 }  // namespace yb::xcluster
diff --git a/src/yb/cdc/xcluster_util.h b/src/yb/cdc/xcluster_util.h
index 3b25685314..98c6154008 100644
--- a/src/yb/cdc/xcluster_util.h
+++ b/src/yb/cdc/xcluster_util.h
@@ -23,4 +23,6 @@ bool IsAlterReplicationGroupId(const ReplicationGroupId& replication_group_id);
 
 ReplicationGroupId GetOriginalReplicationGroupId(const ReplicationGroupId& replication_group_id);
 
+std::string ShortReplicationType(XClusterReplicationType type);
+
 }  // namespace yb::xcluster
diff --git a/src/yb/client/client-internal.cc b/src/yb/client/client-internal.cc
index ec4d923409..5535dd4bdf 100644
--- a/src/yb/client/client-internal.cc
+++ b/src/yb/client/client-internal.cc
@@ -330,6 +330,8 @@ YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, RepairOutboundXClusterReplicationGro
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, RepairOutboundXClusterReplicationGroupRemoveTable);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, GetXClusterOutboundReplicationGroups);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, GetXClusterOutboundReplicationGroupInfo);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, GetUniverseReplications);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, GetUniverseReplicationInfo);
 
 #define YB_CLIENT_SPECIALIZE_SIMPLE_EX_EACH(i, data, set) YB_CLIENT_SPECIALIZE_SIMPLE_EX set
 
diff --git a/src/yb/client/xcluster_client.cc b/src/yb/client/xcluster_client.cc
index eb959bfd3d..1cfb0c0aae 100644
--- a/src/yb/client/xcluster_client.cc
+++ b/src/yb/client/xcluster_client.cc
@@ -400,6 +400,52 @@ XClusterClient::GetXClusterOutboundReplicationGroupInfo(
   return result;
 }
 
+Result<std::vector<xcluster::ReplicationGroupId>> XClusterClient::GetUniverseReplications(
+    const NamespaceId& consumer_namespace_id) {
+  master::GetUniverseReplicationsRequestPB req;
+  if (!consumer_namespace_id.empty()) {
+    req.set_namespace_id(consumer_namespace_id);
+  }
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(GetUniverseReplications, req);
+
+  std::vector<xcluster::ReplicationGroupId> replication_group_ids;
+  for (const auto& replication_group_id : resp.replication_group_ids()) {
+    replication_group_ids.emplace_back(replication_group_id);
+  }
+
+  return replication_group_ids;
+}
+
+Result<XClusterClient::XClusterInboundReplicationGroupInfo>
+XClusterClient::GetUniverseReplicationInfo(
+    const xcluster::ReplicationGroupId& replication_group_id) {
+  master::GetUniverseReplicationInfoRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(GetUniverseReplicationInfo, req);
+
+  XClusterClient::XClusterInboundReplicationGroupInfo result;
+  result.replication_type = resp.replication_type();
+  result.source_master_addrs = resp.source_master_addresses();
+
+  for (const auto& pb_table_info : resp.table_infos()) {
+    XClusterClient::XClusterInboundReplicationGroupInfo::XClusterInboundReplicationGroupTableInfo
+        table_info;
+    table_info.target_table_id = pb_table_info.target_table_id();
+    table_info.source_table_id = pb_table_info.source_table_id();
+    table_info.stream_id = VERIFY_RESULT(xrepl::StreamId::FromString(pb_table_info.stream_id()));
+    result.table_infos.emplace_back(std::move(table_info));
+  }
+
+  for (const auto& db_scoped_info : resp.db_scoped_infos()) {
+    result.db_scope_namespace_id_map.emplace(
+        db_scoped_info.target_namespace_id(), db_scoped_info.source_namespace_id());
+  }
+
+  return result;
+}
+
 // XClusterRemoteClient
 
 XClusterRemoteClient::XClusterRemoteClient(const std::string& certs_for_cdc_dir, MonoDelta timeout)
diff --git a/src/yb/client/xcluster_client.h b/src/yb/client/xcluster_client.h
index 955a2fb517..f60649dc0a 100644
--- a/src/yb/client/xcluster_client.h
+++ b/src/yb/client/xcluster_client.h
@@ -143,6 +143,28 @@ class XClusterClient {
   Result<std::unordered_map<NamespaceId, std::unordered_map<TableId, xrepl::StreamId>>>
   GetXClusterOutboundReplicationGroupInfo(const xcluster::ReplicationGroupId& replication_group_id);
 
+  // Returns list of all universe replication group ids if consumer_namespace_id is empty. If
+  // consumer_namespace_id is not empty then returns DB scoped replication groups that contain the
+  // namespace.
+  Result<std::vector<xcluster::ReplicationGroupId>> GetUniverseReplications(
+      const NamespaceId& consumer_namespace_id);
+
+  struct XClusterInboundReplicationGroupInfo {
+    XClusterReplicationType replication_type = XClusterReplicationType::XCLUSTER_NON_TRANSACTIONAL;
+    std::string source_master_addrs;
+    // Map of target namespace id to source namespace id. Only used in db scope replication.
+    std::unordered_map<NamespaceId, NamespaceId> db_scope_namespace_id_map;
+
+    struct XClusterInboundReplicationGroupTableInfo {
+      TableId target_table_id;
+      TableId source_table_id;
+      xrepl::StreamId stream_id = xrepl::StreamId::Nil();
+    };
+    std::vector<XClusterInboundReplicationGroupTableInfo> table_infos;
+  };
+  Result<XClusterInboundReplicationGroupInfo> GetUniverseReplicationInfo(
+      const xcluster::ReplicationGroupId& replication_group_id);
+
  private:
   CoarseTimePoint GetDeadline() const;
 
diff --git a/src/yb/common/common_types.proto b/src/yb/common/common_types.proto
index 4e30961b84..194a76b06c 100644
--- a/src/yb/common/common_types.proto
+++ b/src/yb/common/common_types.proto
@@ -193,3 +193,9 @@ enum PgReplicaIdentity {
   // This is the default replica identity mode in YSQL
   CHANGE = 3;
 }
+
+enum XClusterReplicationType {
+  XCLUSTER_NON_TRANSACTIONAL = 0;  // YCQL and YSQL. Unidirectional and Bidirectional. Table level.
+  XCLUSTER_YSQL_TRANSACTIONAL = 1; // YSQL, Unidirectional only. Table level.
+  XCLUSTER_YSQL_DB_SCOPED = 2;     // YSQL, Transactional and Unidirectional only. DB level.
+}
diff --git a/src/yb/integration-tests/xcluster/xcluster-test.cc b/src/yb/integration-tests/xcluster/xcluster-test.cc
index f3c7f125dc..a76eb7d87c 100644
--- a/src/yb/integration-tests/xcluster/xcluster-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster-test.cc
@@ -4008,4 +4008,53 @@ TEST_F_EX(XClusterTest, DeleteWhenSourceIsDown, XClusterTestNoParam) {
   }
 }
 
+TEST_F_EX(XClusterTest, TestYbAdmin, XClusterTestNoParam) {
+  // Create 2 tables with 1 tablet each.
+  ASSERT_OK(SetUpWithParams({1, 1}, /*replication_factor=*/1));
+
+  auto result = ASSERT_RESULT(CallAdmin(consumer_cluster(), "list_universe_replications"));
+  ASSERT_STR_NOT_CONTAINS(result, kReplicationGroupId.ToString());
+
+  ASSERT_OK(SetupReplication());
+
+  result =
+      ASSERT_RESULT(CallAdmin(consumer_cluster(), "list_universe_replications", "NonExistent"));
+  ASSERT_STR_NOT_CONTAINS(result, kReplicationGroupId.ToString());
+
+  // This is not a db scoped replication group so it should not be listed.
+  result = ASSERT_RESULT(CallAdmin(
+      consumer_cluster(), "list_universe_replications",
+      producer_tables_[0]->name().namespace_id()));
+  ASSERT_STR_NOT_CONTAINS(result, kReplicationGroupId.ToString());
+
+  result = ASSERT_RESULT(CallAdmin(consumer_cluster(), "list_universe_replications"));
+  ASSERT_STR_CONTAINS(result, kReplicationGroupId.ToString());
+
+  result = ASSERT_RESULT(
+      CallAdmin(consumer_cluster(), "get_universe_replication_info", kReplicationGroupId));
+  ASSERT_STR_CONTAINS(result, kReplicationGroupId.ToString());
+  constexpr auto host_port_str = "host: \"$0\" port: $1";
+  const auto& source_addr =
+      ASSERT_RESULT(producer_cluster()->GetLeaderMiniMaster())->bound_rpc_addr();
+  ASSERT_STR_CONTAINS(result, Format(host_port_str, source_addr.host(), source_addr.port()));
+  const auto& consumer_addr =
+      ASSERT_RESULT(consumer_cluster()->GetLeaderMiniMaster())->bound_rpc_addr();
+  ASSERT_STR_NOT_CONTAINS(
+      result, Format(host_port_str, consumer_addr.host(), consumer_addr.port()));
+  ASSERT_STR_CONTAINS(result, xcluster::ShortReplicationType(XCLUSTER_NON_TRANSACTIONAL));
+  ASSERT_STR_CONTAINS(result, producer_tables_[0]->id());
+  ASSERT_STR_CONTAINS(result, producer_tables_[1]->id());
+
+  ASSERT_OK(DeleteUniverseReplication());
+
+  ASSERT_OK(SetupUniverseReplication(producer_tables_, {LeaderOnly::kFalse, Transactional::kTrue}));
+
+  result = ASSERT_RESULT(
+      CallAdmin(consumer_cluster(), "get_universe_replication_info", kReplicationGroupId));
+  ASSERT_STR_CONTAINS(result, kReplicationGroupId.ToString());
+  ASSERT_STR_CONTAINS(result, xcluster::ShortReplicationType(XCLUSTER_YSQL_TRANSACTIONAL));
+  ASSERT_STR_CONTAINS(result, producer_tables_[0]->id());
+  ASSERT_STR_CONTAINS(result, producer_tables_[1]->id());
+}
+
 }  // namespace yb
diff --git a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
index 318884365e..825e2c8980 100644
--- a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
@@ -11,13 +11,13 @@
 // under the License.
 //
 
+#include "yb/cdc/xcluster_util.h"
 #include "yb/client/table.h"
 #include "yb/client/xcluster_client.h"
 #include "yb/client/yb_table_name.h"
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/mini_master.h"
-#include "yb/util/backoff_waiter.h"
 
 DECLARE_bool(enable_xcluster_api_v2);
 DECLARE_int32(cdc_parent_tablet_deletion_task_retry_secs);
@@ -109,6 +109,28 @@ TEST_F(XClusterDBScopedTest, TestCreateWithCheckpoint) {
   ASSERT_EQ(resp.entry().tables_size(), 1);
   ASSERT_EQ(resp.entry().tables(0), producer_table_->id());
 
+  // Verify the groups shows up in GetUniverseReplications and GetUniverseReplicationInfo client
+  // APIs.
+  auto target_xcluster_client = client::XClusterClient(*consumer_client());
+  auto replication_groups = ASSERT_RESULT(target_xcluster_client.GetUniverseReplications(""));
+  ASSERT_EQ(replication_groups.size(), 1);
+  ASSERT_EQ(replication_groups.front(), kReplicationGroupId);
+  replication_groups = ASSERT_RESULT(
+      target_xcluster_client.GetUniverseReplications(producer_table_->name().namespace_id()));
+  ASSERT_EQ(replication_groups.size(), 1);
+  ASSERT_EQ(replication_groups.front(), kReplicationGroupId);
+  auto replication_info =
+      ASSERT_RESULT(target_xcluster_client.GetUniverseReplicationInfo(kReplicationGroupId));
+  ASSERT_EQ(replication_info.replication_type, XClusterReplicationType::XCLUSTER_YSQL_DB_SCOPED);
+  ASSERT_EQ(replication_info.db_scope_namespace_id_map.size(), 1);
+  const auto& source_namespace_id = producer_table_->name().namespace_id();
+  ASSERT_TRUE(replication_info.db_scope_namespace_id_map.contains(source_namespace_id));
+  const auto& target_namespace_id = consumer_table_->name().namespace_id();
+  ASSERT_EQ(replication_info.db_scope_namespace_id_map[source_namespace_id], target_namespace_id);
+  ASSERT_EQ(replication_info.table_infos.size(), 1);
+  ASSERT_EQ(replication_info.table_infos[0].source_table_id, producer_table_->id());
+  ASSERT_EQ(replication_info.table_infos[0].target_table_id, consumer_table_->id());
+
   ASSERT_OK(InsertRowsInProducer(50, 100));
 
   ASSERT_OK(VerifyWrittenRecords());
@@ -743,6 +765,24 @@ TEST_F_EX(XClusterDBScopedTest, TestYbAdmin, XClusterDBScopedTestWithTwoDBs) {
   ASSERT_STR_NOT_CONTAINS(result, source_namespace2_id_);
   ASSERT_STR_NOT_CONTAINS(result, source_namespace2_table_->id());
 
+  // Test target side commands.
+  const auto target_namespace_id = consumer_table_->name().namespace_id();
+  result = ASSERT_RESULT(CallAdmin(consumer_cluster(), "list_universe_replications", "na"));
+  ASSERT_STR_NOT_CONTAINS(result, kReplicationGroupId.ToString());
+  result = ASSERT_RESULT(
+      CallAdmin(consumer_cluster(), "list_universe_replications", target_namespace2_id_));
+  ASSERT_STR_NOT_CONTAINS(result, kReplicationGroupId.ToString());
+  result = ASSERT_RESULT(
+      CallAdmin(consumer_cluster(), "list_universe_replications", target_namespace_id));
+  ASSERT_STR_CONTAINS(result, kReplicationGroupId.ToString());
+  result = ASSERT_RESULT(CallAdmin(
+      consumer_cluster(), "get_universe_replication_info", kReplicationGroupId.ToString()));
+  ASSERT_STR_CONTAINS(result, xcluster::ShortReplicationType(XCLUSTER_YSQL_DB_SCOPED));
+  ASSERT_STR_CONTAINS(result, namespace_name);
+  ASSERT_STR_CONTAINS(result, target_namespace_id);
+  ASSERT_STR_CONTAINS(result, source_namespace_id);
+  ASSERT_STR_NOT_CONTAINS(result, target_namespace2_id_);
+
   ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
 
   ASSERT_OK(InsertRowsInProducer(0, 10));
diff --git a/src/yb/master/master-path-handlers.cc b/src/yb/master/master-path-handlers.cc
index de5c91f670..de0a65389c 100644
--- a/src/yb/master/master-path-handlers.cc
+++ b/src/yb/master/master-path-handlers.cc
@@ -42,6 +42,7 @@
 
 #include <boost/date_time/posix_time/time_formatters.hpp>
 
+#include "yb/cdc/xcluster_util.h"
 #include "yb/common/common_types_util.h"
 #include "yb/common/hybrid_time.h"
 #include "yb/common/path-handler-util.h"
@@ -3033,9 +3034,11 @@ void MasterPathHandlers::HandleXCluster(
     auto group_fs = AutoFieldsetScope(
         output, Format("Group: $0", inbound_replication_group.replication_group_id));
 
-    output << "<pre class=\"prettyprint\">" << "state: " << inbound_replication_group.state
+    output << "<pre class=\"prettyprint\">"
+           << "state: " << inbound_replication_group.state
            << "\ndisable_stream: " << BoolToString(inbound_replication_group.disable_stream)
-           << "\ntransactional: " << BoolToString(inbound_replication_group.transactional)
+           << "\ntype: "
+           << xcluster::ShortReplicationType(inbound_replication_group.replication_type)
            << "\nmaster_addrs: " << inbound_replication_group.master_addrs;
     if (!inbound_replication_group.db_scoped_info.empty()) {
       output << "\ndb_scoped_info: " << inbound_replication_group.db_scoped_info;
diff --git a/src/yb/master/master_replication.proto b/src/yb/master/master_replication.proto
index a1a0ab8b31..d0832391f1 100644
--- a/src/yb/master/master_replication.proto
+++ b/src/yb/master/master_replication.proto
@@ -721,6 +721,40 @@ message GetXClusterOutboundReplicationGroupInfoResponsePB {
   repeated NamespaceInfoPB namespace_infos = 2;
 }
 
+message GetUniverseReplicationsRequestPB {
+  optional string namespace_id = 1;
+}
+
+message GetUniverseReplicationsResponsePB {
+  optional MasterErrorPB error = 1;
+  repeated string replication_group_ids = 2;
+}
+
+message GetUniverseReplicationInfoRequestPB {
+  required string replication_group_id = 1;
+}
+
+message GetUniverseReplicationInfoResponsePB {
+  optional MasterErrorPB error = 1;
+
+  optional XClusterReplicationType replication_type = 2;
+  optional string source_master_addresses = 3;
+
+  message TableInfoPB {
+    required string target_table_id = 1;
+    required string source_table_id = 2;
+    required string stream_id = 3;
+  }
+  repeated TableInfoPB table_infos = 4;
+
+  message DbScopedInfoPB {
+    required string target_namespace_id = 1;
+    required string source_namespace_id = 2;
+  }
+
+  repeated DbScopedInfoPB db_scoped_infos = 5;
+}
+
 service MasterReplication {
   option (yb.rpc.custom_service_name) = "yb.master.MasterService";
 
@@ -774,6 +808,10 @@ service MasterReplication {
   rpc UpdateConsumerOnProducerMetadata(UpdateConsumerOnProducerMetadataRequestPB)
       returns (UpdateConsumerOnProducerMetadataResponsePB);
 
+  rpc GetUniverseReplications(GetUniverseReplicationsRequestPB)
+      returns (GetUniverseReplicationsResponsePB);
+  rpc GetUniverseReplicationInfo(GetUniverseReplicationInfoRequestPB)
+      returns (GetUniverseReplicationInfoResponsePB);
   rpc GetReplicationStatus(GetReplicationStatusRequestPB)
       returns (GetReplicationStatusResponsePB);
 
diff --git a/src/yb/master/master_replication_service.cc b/src/yb/master/master_replication_service.cc
index fabf225e6c..54fed364fa 100644
--- a/src/yb/master/master_replication_service.cc
+++ b/src/yb/master/master_replication_service.cc
@@ -78,6 +78,8 @@ class MasterReplicationServiceImpl : public MasterServiceBase, public MasterRepl
       (RepairOutboundXClusterReplicationGroupRemoveTable)
       (GetXClusterOutboundReplicationGroups)
       (GetXClusterOutboundReplicationGroupInfo)
+      (GetUniverseReplications)
+      (GetUniverseReplicationInfo)
   )
 };
 
diff --git a/src/yb/master/xcluster/master_xcluster_types.h b/src/yb/master/xcluster/master_xcluster_types.h
index e7eb0d2bd2..eb262ffda7 100644
--- a/src/yb/master/xcluster/master_xcluster_types.h
+++ b/src/yb/master/xcluster/master_xcluster_types.h
@@ -13,6 +13,7 @@
 
 #pragma once
 
+#include "yb/cdc/xcluster_types.h"
 #include "yb/cdc/xrepl_types.h"
 #include "yb/common/schema.h"
 
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index a426771591..dd36a88b4f 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -118,7 +118,8 @@ Result<XClusterStatus> XClusterManager::GetXClusterStatus() const {
   XClusterStatus status;
   RETURN_NOT_OK(XClusterSourceManager::PopulateXClusterStatus(
       status, VERIFY_RESULT(xcluster_config_->GetXClusterConfigEntryPB())));
-  RETURN_NOT_OK(XClusterTargetManager::PopulateXClusterStatus(status));
+  status.inbound_replication_group_statuses =
+      VERIFY_RESULT(XClusterTargetManager::GetXClusterStatus());
   return status;
 }
 
@@ -473,6 +474,49 @@ Status XClusterManager::GetXClusterOutboundReplicationGroupInfo(
   return Status::OK();
 }
 
+Status XClusterManager::GetUniverseReplications(
+    const GetUniverseReplicationsRequestPB* req, GetUniverseReplicationsResponsePB* resp,
+    rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
+  const auto& namespace_filter = req->namespace_id();
+
+  const auto replication_groups = XClusterTargetManager::GetUniverseReplications(namespace_filter);
+  for (const auto& replication_group : replication_groups) {
+    resp->add_replication_group_ids(replication_group.ToString());
+  }
+
+  return Status::OK();
+}
+
+Status XClusterManager::GetUniverseReplicationInfo(
+    const GetUniverseReplicationInfoRequestPB* req, GetUniverseReplicationInfoResponsePB* resp,
+    rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id);
+
+  const auto replication_info = VERIFY_RESULT(XClusterTargetManager::GetUniverseReplicationInfo(
+      xcluster::ReplicationGroupId(req->replication_group_id())));
+
+  resp->set_replication_type(replication_info.replication_type);
+  resp->set_source_master_addresses(replication_info.master_addrs);
+
+  for (const auto& [_, tables] : replication_info.table_statuses_by_namespace) {
+    for (const auto& table_status : tables) {
+      auto* table_info = resp->add_table_infos();
+      table_info->set_target_table_id(table_status.target_table_id);
+      table_info->set_source_table_id(table_status.source_table_id);
+      table_info->set_stream_id(table_status.stream_id.ToString());
+    }
+  }
+
+  for (const auto& [target_namespace_id, source_namespace_id] :
+       replication_info.db_scope_namespace_id_map) {
+    auto* ns_info = resp->add_db_scoped_infos();
+    ns_info->set_target_namespace_id(target_namespace_id);
+    ns_info->set_source_namespace_id(source_namespace_id);
+  }
+
+  return Status::OK();
+}
+
 std::vector<std::shared_ptr<PostTabletCreateTaskBase>> XClusterManager::GetPostTabletCreateTasks(
     const TableInfoPtr& table_info, const LeaderEpoch& epoch) {
   std::vector<std::shared_ptr<PostTabletCreateTaskBase>> result;
diff --git a/src/yb/master/xcluster/xcluster_manager.h b/src/yb/master/xcluster/xcluster_manager.h
index 1356627eed..e0a4280794 100644
--- a/src/yb/master/xcluster/xcluster_manager.h
+++ b/src/yb/master/xcluster/xcluster_manager.h
@@ -159,6 +159,12 @@ class XClusterManager : public XClusterManagerIf,
       const GetXClusterOutboundReplicationGroupInfoRequestPB* req,
       GetXClusterOutboundReplicationGroupInfoResponsePB* resp, rpc::RpcContext* rpc,
       const LeaderEpoch& epoch);
+  Status GetUniverseReplications(
+      const GetUniverseReplicationsRequestPB* req, GetUniverseReplicationsResponsePB* resp,
+      rpc::RpcContext* rpc, const LeaderEpoch& epoch);
+  Status GetUniverseReplicationInfo(
+      const GetUniverseReplicationInfoRequestPB* req, GetUniverseReplicationInfoResponsePB* resp,
+      rpc::RpcContext* rpc, const LeaderEpoch& epoch);
 
   std::vector<std::shared_ptr<PostTabletCreateTaskBase>> GetPostTabletCreateTasks(
       const TableInfoPtr& table_info, const LeaderEpoch& epoch);
diff --git a/src/yb/master/xcluster/xcluster_replication_group.cc b/src/yb/master/xcluster/xcluster_replication_group.cc
index ffa417d32a..ee71d14a0d 100644
--- a/src/yb/master/xcluster/xcluster_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_replication_group.cc
@@ -638,4 +638,18 @@ Status ValidateTableListForDbScopedReplication(
   return Status::OK();
 }
 
+bool HasNamespace(UniverseReplicationInfo& universe, const NamespaceId& consumer_namespace_id) {
+  auto l = universe.LockForRead();
+  if (!l->IsDbScoped()) {
+    return false;
+  }
+
+  const auto& namespace_infos = l->pb.db_scoped_info().namespace_infos();
+  return std::any_of(
+      namespace_infos.begin(), namespace_infos.end(),
+      [&consumer_namespace_id](const auto& namespace_info) {
+        return namespace_info.consumer_namespace_id() == consumer_namespace_id;
+      });
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_replication_group.h b/src/yb/master/xcluster/xcluster_replication_group.h
index 6208a52bf4..84665ad8f6 100644
--- a/src/yb/master/xcluster/xcluster_replication_group.h
+++ b/src/yb/master/xcluster/xcluster_replication_group.h
@@ -98,5 +98,8 @@ Status ValidateTableListForDbScopedReplication(
     UniverseReplicationInfo& universe, const std::vector<NamespaceId>& namespace_ids,
     const std::set<TableId>& replicated_table_ids, const CatalogManager& catalog_manager);
 
+// Returns true if the namespace is part of the DB Scoped replication group.
+bool HasNamespace(UniverseReplicationInfo& universe, const NamespaceId& consumer_namespace_id);
+
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/xcluster/xcluster_status.h b/src/yb/master/xcluster/xcluster_status.h
index 1da9df4d1f..48391faf5f 100644
--- a/src/yb/master/xcluster/xcluster_status.h
+++ b/src/yb/master/xcluster/xcluster_status.h
@@ -16,6 +16,7 @@
 #include "yb/cdc/xcluster_types.h"
 #include "yb/cdc/xrepl_types.h"
 #include "yb/common/entity_ids_types.h"
+#include "yb/common/common_types.pb.h"
 
 namespace yb {
 
@@ -37,14 +38,16 @@ struct InboundXClusterReplicationGroupTableStatus {
 struct XClusterInboundReplicationGroupStatus {
   xcluster::ReplicationGroupId replication_group_id;
   std::string state;
-  bool transactional = false;
+  XClusterReplicationType replication_type = XClusterReplicationType::XCLUSTER_NON_TRANSACTIONAL;
   std::string master_addrs;
   bool disable_stream = false;
   uint32 compatible_auto_flag_config_version = 0;
   uint32 validated_remote_auto_flags_config_version = 0;
   uint32 validated_local_auto_flags_config_version = 0;
   std::string db_scoped_info;
-  std::map<NamespaceName, std::vector<InboundXClusterReplicationGroupTableStatus>>
+  // Map of target namespace id to source namespace id. Only used in db scope replication.
+  std::unordered_map<NamespaceId, NamespaceId> db_scope_namespace_id_map;
+  std::unordered_map<NamespaceName, std::vector<InboundXClusterReplicationGroupTableStatus>>
       table_statuses_by_namespace;
 };
 
diff --git a/src/yb/master/xcluster/xcluster_target_manager.cc b/src/yb/master/xcluster/xcluster_target_manager.cc
index d14c16ad9f..ec851c4656 100644
--- a/src/yb/master/xcluster/xcluster_target_manager.cc
+++ b/src/yb/master/xcluster/xcluster_target_manager.cc
@@ -13,6 +13,7 @@
 
 #include "yb/master/xcluster/xcluster_target_manager.h"
 
+#include "yb/gutil/strings/util.h"
 #include "yb/master/catalog_entity_info.pb.h"
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/catalog_manager.h"
@@ -304,8 +305,9 @@ Status XClusterTargetManager::RemoveDroppedTablesFromReplication(const LeaderEpo
 }
 
 namespace {
-template <typename PBList>
-std::string PBListAsString(const PBList& pb, const char* delim = ",") {
+template <typename Element>
+std::string PBListAsString(
+    const ::google::protobuf::RepeatedPtrField<Element>& pb, const char* delim = ",") {
   std::stringstream ostream;
   for (int i = 0; i < pb.size(); i++) {
     ostream << (i ? delim : "") << pb.Get(i).ShortDebugString();
@@ -313,9 +315,33 @@ std::string PBListAsString(const PBList& pb, const char* delim = ",") {
 
   return ostream.str();
 }
+
+std::string ShortReplicationErrorName(ReplicationErrorPb error) {
+  return StringReplace(
+      ReplicationErrorPb_Name(error), "REPLICATION_", "",
+      /*replace_all=*/false);
+}
+
+std::string PBListAsString(
+    const ::google::protobuf::RepeatedPtrField<ReplicationStatusErrorPB>& pb,
+    const char* delim = ",") {
+  std::stringstream ostream;
+  for (int i = 0; i < pb.size(); i++) {
+    ostream << (i ? delim : "") << ShortReplicationErrorName(pb.Get(i).error());
+    if (!pb.Get(i).error_detail().empty()) {
+      ostream << ": " << pb.Get(i).error_detail();
+    }
+  }
+
+  return ostream.str();
+}
+
 }  // namespace
 
-Status XClusterTargetManager::PopulateXClusterStatus(XClusterStatus& xcluster_status) const {
+Result<std::vector<XClusterInboundReplicationGroupStatus>>
+XClusterTargetManager::GetXClusterStatus() const {
+  std::vector<XClusterInboundReplicationGroupStatus> result;
+
   GetReplicationStatusResponsePB replication_status;
   GetReplicationStatusRequestPB req;
   RETURN_NOT_OK(catalog_manager_.GetReplicationStatus(&req, &replication_status, /*rpc=*/nullptr));
@@ -329,92 +355,111 @@ Status XClusterTargetManager::PopulateXClusterStatus(XClusterStatus& xcluster_st
     const auto stream_id =
         VERIFY_RESULT(xrepl::StreamId::FromString(table_stream_status.stream_id()));
     stream_status[stream_id] = PBListAsString(table_stream_status.errors(), ";");
-    auto s = table_stream_status.ShortDebugString();
   }
 
-  SysClusterConfigEntryPB cluster_config =
-      VERIFY_RESULT(catalog_manager_.GetClusterConfig());
-  const auto& consumer_registry = cluster_config.consumer_registry();
-
+  const auto cluster_config_pb = VERIFY_RESULT(catalog_manager_.GetClusterConfig());
   const auto replication_infos = catalog_manager_.GetAllXClusterUniverseReplicationInfos();
 
   for (const auto& replication_info : replication_infos) {
-    XClusterInboundReplicationGroupStatus replication_group_status;
-    replication_group_status.replication_group_id =
-        xcluster::ReplicationGroupId(replication_info.replication_group_id());
-    replication_group_status.state =
-        SysUniverseReplicationEntryPB::State_Name(replication_info.state());
-    replication_group_status.transactional = replication_info.transactional();
-    replication_group_status.validated_local_auto_flags_config_version =
-        replication_info.validated_local_auto_flags_config_version();
-
-    for (const auto& namespace_info : replication_info.db_scoped_info().namespace_infos()) {
-      replication_group_status.db_scoped_info += Format(
+    auto replication_group_status =
+        VERIFY_RESULT(GetUniverseReplicationInfo(replication_info, cluster_config_pb));
+
+    for (auto& [_, tables] : replication_group_status.table_statuses_by_namespace) {
+      for (auto& table : tables) {
+        if (table.stream_id.IsNil()) {
+          static const auto repl_error_uninitialized =
+              ShortReplicationErrorName(ReplicationErrorPb::REPLICATION_ERROR_UNINITIALIZED);
+          table.status = repl_error_uninitialized;
+        } else {
+          static const auto repl_ok = ShortReplicationErrorName(ReplicationErrorPb::REPLICATION_OK);
+          table.status = FindWithDefault(stream_status, table.stream_id, repl_ok);
+        }
+      }
+    }
+
+    result.push_back(std::move(replication_group_status));
+  }
+
+  return result;
+}
+
+Result<XClusterInboundReplicationGroupStatus> XClusterTargetManager::GetUniverseReplicationInfo(
+    const SysUniverseReplicationEntryPB& replication_info_pb,
+    const SysClusterConfigEntryPB& cluster_config_pb) const {
+  XClusterInboundReplicationGroupStatus result;
+  result.replication_group_id =
+      xcluster::ReplicationGroupId(replication_info_pb.replication_group_id());
+  result.state = SysUniverseReplicationEntryPB::State_Name(replication_info_pb.state());
+  result.replication_type = replication_info_pb.transactional()
+                                ? XClusterReplicationType::XCLUSTER_YSQL_TRANSACTIONAL
+                                : XClusterReplicationType::XCLUSTER_NON_TRANSACTIONAL;
+  result.validated_local_auto_flags_config_version =
+      replication_info_pb.validated_local_auto_flags_config_version();
+
+  if (IsDbScoped(replication_info_pb)) {
+    result.replication_type = XClusterReplicationType::XCLUSTER_YSQL_DB_SCOPED;
+    for (const auto& namespace_info : replication_info_pb.db_scoped_info().namespace_infos()) {
+      result.db_scope_namespace_id_map[namespace_info.consumer_namespace_id()] =
+          namespace_info.producer_namespace_id();
+      result.db_scoped_info += Format(
           "\n  namespace: $0\n    consumer_namespace_id: $1\n    producer_namespace_id: $2",
           catalog_manager_.GetNamespaceName(namespace_info.consumer_namespace_id()),
           namespace_info.consumer_namespace_id(), namespace_info.producer_namespace_id());
     }
+  }
 
-    auto* producer_map =
-        FindOrNull(consumer_registry.producer_map(), replication_info.replication_group_id());
-    if (producer_map) {
-      replication_group_status.master_addrs = PBListAsString(producer_map->master_addrs());
-      replication_group_status.disable_stream = producer_map->disable_stream();
-      replication_group_status.compatible_auto_flag_config_version =
-          producer_map->compatible_auto_flag_config_version();
-      replication_group_status.validated_remote_auto_flags_config_version =
-          producer_map->validated_auto_flags_config_version();
-    }
+  auto* producer_map = FindOrNull(
+      cluster_config_pb.consumer_registry().producer_map(),
+      replication_info_pb.replication_group_id());
+  if (producer_map) {
+    result.master_addrs = PBListAsString(producer_map->master_addrs());
+    result.disable_stream = producer_map->disable_stream();
+    result.compatible_auto_flag_config_version =
+        producer_map->compatible_auto_flag_config_version();
+    result.validated_remote_auto_flags_config_version =
+        producer_map->validated_auto_flags_config_version();
+  }
+
+  for (const auto& source_table_id : replication_info_pb.tables()) {
+    NamespaceName namespace_name = "<Unknown>";
+
+    InboundXClusterReplicationGroupTableStatus table_status;
+    table_status.source_table_id = source_table_id;
 
-    for (const auto& source_table_id : replication_info.tables()) {
-      NamespaceName namespace_name = "<Unknown>";
-
-      InboundXClusterReplicationGroupTableStatus table_status;
-      table_status.source_table_id = source_table_id;
-
-      auto* stream_id_it = FindOrNull(replication_info.table_streams(), source_table_id);
-      if (stream_id_it) {
-        table_status.stream_id = VERIFY_RESULT(xrepl::StreamId::FromString(*stream_id_it));
-        auto it = FindOrNull(stream_status, table_status.stream_id);
-        table_status.status = it ? *it : "OK";
-
-        if (producer_map) {
-          auto* stream_info =
-              FindOrNull(producer_map->stream_map(), table_status.stream_id.ToString());
-          if (stream_info) {
-            table_status.target_table_id = stream_info->consumer_table_id();
-
-            auto table_info_res = catalog_manager_.GetTableById(table_status.target_table_id);
-            if (table_info_res) {
-              const auto& table_info = table_info_res.get();
-              namespace_name = table_info->namespace_name();
-              table_status.full_table_name = GetFullTableName(*table_info);
-            }
-
-            table_status.target_tablet_count = stream_info->consumer_producer_tablet_map_size();
-            table_status.local_tserver_optimized = stream_info->local_tserver_optimized();
-            table_status.source_schema_version =
-                stream_info->schema_versions().current_producer_schema_version();
-            table_status.target_schema_version =
-                stream_info->schema_versions().current_consumer_schema_version();
-            for (const auto& [_, producer_tablets] : stream_info->consumer_producer_tablet_map()) {
-              table_status.source_tablet_count += producer_tablets.tablets_size();
-            }
+    auto* stream_id_it = FindOrNull(replication_info_pb.table_streams(), source_table_id);
+    if (stream_id_it) {
+      table_status.stream_id = VERIFY_RESULT(xrepl::StreamId::FromString(*stream_id_it));
+
+      if (producer_map) {
+        auto* stream_info =
+            FindOrNull(producer_map->stream_map(), table_status.stream_id.ToString());
+        if (stream_info) {
+          table_status.target_table_id = stream_info->consumer_table_id();
+
+          auto table_info_res = catalog_manager_.GetTableById(table_status.target_table_id);
+          if (table_info_res) {
+            const auto& table_info = table_info_res.get();
+            namespace_name = table_info->namespace_name();
+            table_status.full_table_name = GetFullTableName(*table_info);
+          }
+
+          table_status.target_tablet_count = stream_info->consumer_producer_tablet_map_size();
+          table_status.local_tserver_optimized = stream_info->local_tserver_optimized();
+          table_status.source_schema_version =
+              stream_info->schema_versions().current_producer_schema_version();
+          table_status.target_schema_version =
+              stream_info->schema_versions().current_consumer_schema_version();
+          for (const auto& [_, producer_tablets] : stream_info->consumer_producer_tablet_map()) {
+            table_status.source_tablet_count += producer_tablets.tablets_size();
           }
         }
-      } else {
-        table_status.status = "Not Ready";
       }
-
-      replication_group_status.table_statuses_by_namespace[namespace_name].push_back(
-          std::move(table_status));
     }
 
-    xcluster_status.inbound_replication_group_statuses.push_back(
-        std::move(replication_group_status));
+    result.table_statuses_by_namespace[namespace_name].push_back(std::move(table_status));
   }
 
-  return Status::OK();
+  return result;
 }
 
 Status XClusterTargetManager::PopulateXClusterStatusJson(JsonWriter& jw) const {
@@ -453,4 +498,28 @@ XClusterTargetManager::GetTransactionalReplicationGroups() const {
   return result;
 }
 
+std::vector<xcluster::ReplicationGroupId> XClusterTargetManager::GetUniverseReplications(
+    const NamespaceId& consumer_namespace_id) const {
+  std::vector<xcluster::ReplicationGroupId> result;
+  auto universe_replications = catalog_manager_.GetAllUniverseReplications();
+  for (const auto& replication_info : universe_replications) {
+    if (!consumer_namespace_id.empty() && !HasNamespace(*replication_info, consumer_namespace_id)) {
+      continue;
+    }
+    result.push_back(replication_info->ReplicationGroupId());
+  }
+
+  return result;
+}
+
+Result<XClusterInboundReplicationGroupStatus> XClusterTargetManager::GetUniverseReplicationInfo(
+    const xcluster::ReplicationGroupId& replication_group_id) const {
+  auto replication_info = catalog_manager_.GetUniverseReplication(replication_group_id);
+  SCHECK_FORMAT(replication_info, NotFound, "Replication group $0 not found", replication_group_id);
+
+  const auto cluster_config = VERIFY_RESULT(catalog_manager_.GetClusterConfig());
+  auto l = replication_info->LockForRead();
+  return GetUniverseReplicationInfo(l->pb, cluster_config);
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_target_manager.h b/src/yb/master/xcluster/xcluster_target_manager.h
index 8d0cb5d405..367cb7ccda 100644
--- a/src/yb/master/xcluster/xcluster_target_manager.h
+++ b/src/yb/master/xcluster/xcluster_target_manager.h
@@ -28,7 +28,7 @@ class TSHeartbeatResponsePB;
 class PostTabletCreateTaskBase;
 class UniverseReplicationInfo;
 class XClusterSafeTimeService;
-struct XClusterStatus;
+struct XClusterInboundReplicationGroupStatus;
 
 class XClusterTargetManager {
  public:
@@ -94,13 +94,30 @@ class XClusterTargetManager {
   std::vector<std::shared_ptr<PostTabletCreateTaskBase>> GetPostTabletCreateTasks(
       const TableInfoPtr& table_info, const LeaderEpoch& epoch);
 
-  Status PopulateXClusterStatus(XClusterStatus& xcluster_status) const;
+  Result<std::vector<XClusterInboundReplicationGroupStatus>> GetXClusterStatus() const;
 
   Status PopulateXClusterStatusJson(JsonWriter& jw) const;
 
   std::unordered_set<xcluster::ReplicationGroupId> GetTransactionalReplicationGroups() const;
 
+  // Returns list of all universe replication group ids if consumer_namespace_id is empty. If
+  // consumer_namespace_id is not empty then returns DB scoped replication groups that contain the
+  // namespace.
+  std::vector<xcluster::ReplicationGroupId> GetUniverseReplications(
+      const NamespaceId& consumer_namespace_id) const;
+
+  // Gets the replication group status for the given replication group id. Does not populate the
+  // table statuses (only contains fields required for GetUniverseReplicationInfoResponsePB).
+  Result<XClusterInboundReplicationGroupStatus> GetUniverseReplicationInfo(
+      const xcluster::ReplicationGroupId& replication_group_id) const;
+
  private:
+  // Gets the replication group status for the given replication group id. Does not populate the
+  // table statuses.
+  Result<XClusterInboundReplicationGroupStatus> GetUniverseReplicationInfo(
+      const SysUniverseReplicationEntryPB& replication_info_pb,
+      const SysClusterConfigEntryPB& cluster_config_pb) const;
+
   Master& master_;
   CatalogManager& catalog_manager_;
   SysCatalogTable& sys_catalog_;
diff --git a/src/yb/tools/yb-admin_cli.cc b/src/yb/tools/yb-admin_cli.cc
index 0559b3f1a4..e5b4f8fabd 100644
--- a/src/yb/tools/yb-admin_cli.cc
+++ b/src/yb/tools/yb-admin_cli.cc
@@ -38,8 +38,7 @@
 #include <boost/algorithm/string.hpp>
 #include <boost/lexical_cast.hpp>
 
-#include "yb/cdc/cdc_service.h"
-
+#include "yb/cdc/xcluster_util.h"
 #include "yb/client/xcluster_client.h"
 #include "yb/common/hybrid_time.h"
 #include "yb/common/json_util.h"
@@ -2557,18 +2556,81 @@ Status get_xcluster_outbound_replication_group_info_action(
   std::cout << "Outbound Replication Group: " << replication_group_id << std::endl;
 
   for (const auto& [namespace_id, table_info] : group_info) {
-    std::cout << std::endl << "NamespaceId: " << namespace_id << std::endl;
+    std::cout << std::endl << "Namespace ID: " << namespace_id << std::endl;
     auto* namespace_info = FindOrNull(namespace_map, namespace_id);
     std::cout << "Namespace name: " << (namespace_info ? namespace_info->id.name() : "<N/A>")
-              << std::endl;
+              << std::endl
+              << "Table Id\t\tStream Id" << std::endl;
     for (const auto& [table_id, stream_id] : table_info) {
-      std::cout << "\tTable: " << table_id << ", Stream: " << stream_id << std::endl;
+      std::cout << table_id << "\t\t" << stream_id << std::endl;
     }
   }
 
   return Status::OK();
 }
 
+const auto list_universe_replications_args = "[namespace_id]";
+Status list_universe_replications_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  if (args.size() > 1) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  NamespaceId namespace_id;
+  if (args.size() > 0) {
+    namespace_id = args[0];
+  }
+
+  auto group_ids = VERIFY_RESULT(client->XClusterClient().GetUniverseReplications(namespace_id));
+
+  std::cout << group_ids.size() << " Universe Replication Groups found"
+            << (namespace_id.empty() ? "" : Format(" for namespace $0", namespace_id)) << ": "
+            << std::endl
+            << yb::AsString(group_ids) << std::endl;
+
+  return Status::OK();
+}
+
+const auto get_universe_replication_info_args = "<replication_group_id>";
+Status get_universe_replication_info_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  if (args.size() != 1) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  const auto replication_group_id = xcluster::ReplicationGroupId(args[0]);
+  const auto group_info =
+      VERIFY_RESULT(client->XClusterClient().GetUniverseReplicationInfo(replication_group_id));
+
+  const auto& namespace_map = VERIFY_RESULT_REF(client->GetNamespaceMap());
+
+  std::cout << "Replication Group Id: " << replication_group_id << std::endl;
+  std::cout << "Source master addresses: " << group_info.source_master_addrs << std::endl;
+  std::cout << "Type: " << xcluster::ShortReplicationType(group_info.replication_type) << std::endl;
+
+  if (group_info.replication_type == XClusterReplicationType::XCLUSTER_YSQL_DB_SCOPED) {
+    std::cout << std::endl
+              << "DB Scoped info(s):" << std::endl
+              << "Namespace name\t\tTarget Namespace ID\t\tSource Namespace ID";
+    for (const auto& [target_namespace_id, source_namespace_id] :
+         group_info.db_scope_namespace_id_map) {
+      auto* namespace_info = FindOrNull(namespace_map, target_namespace_id);
+      std::cout << (namespace_info ? namespace_info->id.name() : "<N/A>") << "\t\t"
+                << target_namespace_id << "\t\t" << source_namespace_id << std::endl;
+    }
+  }
+
+  std::cout << std::endl
+            << "Tables:" << std::endl
+            << "Target Table ID\t\tSource Table ID\t\tStreamId";
+  for (const auto& tables : group_info.table_infos) {
+    std::cout << tables.target_table_id << "\t\t" << tables.source_table_id << "\t\t"
+              << tables.stream_id << std::endl;
+  }
+
+  return Status::OK();
+}
+
 }  // namespace
 
 void ClusterAdminCli::RegisterCommandHandlers() {
@@ -2683,6 +2745,8 @@ void ClusterAdminCli::RegisterCommandHandlers() {
   REGISTER_COMMAND(set_universe_replication_enabled);
   REGISTER_COMMAND(get_replication_status);
   REGISTER_COMMAND(get_xcluster_safe_time);
+  REGISTER_COMMAND(list_universe_replications);
+  REGISTER_COMMAND(get_universe_replication_info);
   // xCluster common commands
   REGISTER_COMMAND(change_xcluster_role);
 
