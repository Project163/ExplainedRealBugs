diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
index 7d6d46cfc6..c1290b729e 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
@@ -105,6 +105,30 @@ TEST_F(XClusterDDLReplicationTest, BasicSetupAlterTeardown) {
   ASSERT_OK(VerifyDDLExtensionTablesDeletion(namespace_name2));
 }
 
+TEST_F(XClusterDDLReplicationTest, YB_DISABLE_TEST_ON_MACOS(SurviveRestarts)) {
+  ASSERT_OK(SetUpClusters());
+  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+
+  {
+    TEST_SetThreadPrefixScoped prefix_se("NP");
+    ASSERT_OK(producer_cluster_.mini_cluster_.get()->RestartSync());
+  }
+  ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
+
+  {
+    TEST_SetThreadPrefixScoped prefix_se("NC");
+    ASSERT_OK(consumer_cluster_.mini_cluster_.get()->RestartSync());
+  }
+  ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
+
+  {
+    TEST_SetThreadPrefixScoped prefix_se("NNP");
+    ASSERT_OK(producer_cluster_.mini_cluster_.get()->RestartSync());
+  }
+  ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
+}
+
 TEST_F(XClusterDDLReplicationTest, TestExtensionDeletionWithMultipleReplicationGroups) {
   const xcluster::ReplicationGroupId kReplicationGroupId2("ReplicationGroup2");
   ASSERT_OK(SetUpClusters());
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
index d36ced0f51..c7522389eb 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
@@ -237,22 +237,20 @@ Status XClusterYsqlTestBase::InitPostgres(
   RETURN_NOT_OK(cluster->pg_supervisor_->Start());
 
   pg_ts->SetPgServerHandlers(
-      [this, cluster] { return StartPostgres(cluster); },
-      [this, cluster] { StopPostgres(cluster); });
+      // start_pg
+      [this, cluster, pg_port = pg_process_conf.pg_port] {
+        return InitPostgres(cluster, cluster->pg_ts_idx_, pg_port);
+      },
+      // shutdown_pg
+      [cluster] {
+        cluster->pg_supervisor_->Stop();
+        cluster->pg_supervisor_.reset();
+      });
 
   cluster->pg_host_port_ = HostPort(pg_process_conf.listen_addresses, pg_process_conf.pg_port);
   return OK();
 }
 
-void XClusterYsqlTestBase::StopPostgres(Cluster* cluster) {
-  cluster->pg_supervisor_->Stop();
-  cluster->pg_supervisor_.reset();
-}
-
-Status XClusterYsqlTestBase::StartPostgres(Cluster* cluster) {
-  return InitPostgres(cluster, cluster->pg_ts_idx_, cluster->mini_cluster_->AllocateFreePort());
-}
-
 std::string XClusterYsqlTestBase::GetCompleteTableName(const YBTableName& table) {
   // Append schema name before table name, if schema is available.
   return table.has_pgschema_name() ? Format("$0.$1", table.pgschema_name(), table.table_name())
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
index e5f15aba85..b0e3d62bea 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
@@ -197,9 +197,6 @@ class XClusterYsqlTestBase : public XClusterTestBase {
   // is not safe to run in parallel.
   Status InitPostgres(Cluster* cluster, const size_t pg_ts_idx, uint16_t pg_port);
 
-  void StopPostgres(Cluster* cluster);
-  Status StartPostgres(Cluster* cluster);
-
   Status WriteGenerateSeries(
       uint32_t start, uint32_t end, Cluster* cluster, const client::YBTableName& table);
 
diff --git a/src/yb/master/xrepl_catalog_manager.cc b/src/yb/master/xrepl_catalog_manager.cc
index 04a637f0cc..9feffe9af2 100644
--- a/src/yb/master/xrepl_catalog_manager.cc
+++ b/src/yb/master/xrepl_catalog_manager.cc
@@ -12,19 +12,19 @@
 
 #include "yb/cdc/cdc_service.h"
 #include "yb/cdc/cdc_state_table.h"
-#include "yb/common/xcluster_util.h"
 
 #include "yb/client/meta_cache.h"
 #include "yb/client/schema.h"
 #include "yb/client/table.h"
 #include "yb/client/table_handle.h"
 #include "yb/client/table_info.h"
-
 #include "yb/client/xcluster_client.h"
+
 #include "yb/common/colocated_util.h"
 #include "yb/common/common_flags.h"
 #include "yb/common/pg_system_attr.h"
 #include "yb/common/schema_pbutil.h"
+#include "yb/common/xcluster_util.h"
 
 #include "yb/docdb/docdb_pgapi.h"
 
@@ -229,7 +229,8 @@ class CDCStreamLoader : public Visitor<PersistentCDCStreamInfo> {
         return Status::OK();
       }
     } else {
-      table = catalog_manager_->tables_->FindTableOrNull(metadata.table_id(0));
+      table = catalog_manager_->tables_->FindTableOrNull(
+          xcluster::StripSequencesDataAliasIfPresent(metadata.table_id(0)));
       if (!table) {
         LOG(ERROR) << "Invalid table ID " << metadata.table_id(0) << " for stream " << stream_id;
         // TODO (#2059): Potentially signals a race condition that table got deleted while stream
