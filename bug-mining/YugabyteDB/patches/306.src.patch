diff --git a/src/yb/cdc/cdcsdk_virtual_wal.cc b/src/yb/cdc/cdcsdk_virtual_wal.cc
index 1294c7efbb..0409ef6b94 100644
--- a/src/yb/cdc/cdcsdk_virtual_wal.cc
+++ b/src/yb/cdc/cdcsdk_virtual_wal.cc
@@ -14,6 +14,8 @@
 #include "yb/cdc/cdcsdk_virtual_wal.h"
 #include "yb/cdc/xrepl_stream_metadata.h"
 
+#include "yb/common/entity_ids.h"
+
 #include "yb/master/sys_catalog_constants.h"
 
 #include "yb/util/backoff_waiter.h"
@@ -104,8 +106,7 @@ DECLARE_uint64(cdc_stream_records_threshold_size_bytes);
 DECLARE_bool(ysql_yb_enable_consistent_replication_from_hash_range);
 DECLARE_bool(TEST_ysql_yb_enable_implicit_dynamic_tables_logical_replication);
 
-namespace yb {
-namespace cdc {
+namespace yb::cdc {
 
 using RecordInfo = CDCSDKVirtualWAL::RecordInfo;
 using TabletRecordInfoPair = CDCSDKVirtualWAL::TabletRecordInfoPair;
@@ -1726,5 +1727,4 @@ bool CDCSDKVirtualWAL::DeterminePubRefreshFromMasterRecord(const RecordInfo& rec
   return false;
 }
 
-}  // namespace cdc
-}  // namespace yb
+} // namespace yb::cdc
diff --git a/src/yb/integration-tests/xcluster/xcluster_safe_time-itest.cc b/src/yb/integration-tests/xcluster/xcluster_safe_time-itest.cc
index 6314a3e4d9..aafe842721 100644
--- a/src/yb/integration-tests/xcluster/xcluster_safe_time-itest.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_safe_time-itest.cc
@@ -18,18 +18,14 @@
 #include "yb/client/client.h"
 #include "yb/client/schema.h"
 #include "yb/client/session.h"
-#include "yb/client/table_handle.h"
 #include "yb/client/table.h"
+#include "yb/client/table_handle.h"
 #include "yb/client/yb_op.h"
 #include "yb/client/yb_table_name.h"
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
 #include "yb/master/master_ddl.pb.h"
 #include "yb/master/master_defaults.h"
 #include "yb/master/master_replication.pb.h"
-#include "yb/master/master_replication.proxy.h"
-#include "yb/master/mini_master.h"
-#include "yb/master/xcluster/xcluster_consumer_metrics.h"
-#include "yb/master/xcluster/xcluster_safe_time_service.h"
 #include "yb/tablet/tablet_metadata.h"
 #include "yb/tablet/tablet_peer.h"
 #include "yb/tserver/mini_tablet_server.h"
@@ -68,7 +64,7 @@ const client::YBTableName kSafeTimeTableName(
     YQL_DATABASE_CQL, master::kSystemNamespaceName, master::kXClusterSafeTimeTableName);
 
 class XClusterSafeTimeTest : public XClusterTestBase {
-  typedef XClusterTestBase super;
+  using super = XClusterTestBase;
 
  public:
   void SetUp() override {
@@ -106,7 +102,7 @@ class XClusterSafeTimeTest : public XClusterTestBase {
 
     std::vector<TabletId> producer_tablet_ids;
     ASSERT_OK(producer_cluster_.client_->GetTablets(
-        producer_table_->name(), 0 /* max_tablets */, &producer_tablet_ids, NULL));
+        producer_table_->name(), 0 /* max_tablets */, &producer_tablet_ids, nullptr));
     ASSERT_EQ(producer_tablet_ids.size(), kTabletCount);
 
     auto producer_leader_tserver =
@@ -195,9 +191,12 @@ class XClusterSafeTimeTest : public XClusterTestBase {
       ASSERT_TRUE(safe_time_result.get().has_value());
       auto safe_time = *safe_time_result.get();
       for (auto& tablet : tablet_ptrs) {
+        auto cutoff = ts_manager->AllowedHistoryCutoff(tablet->metadata()).primary_cutoff_ht;
+        ASSERT_TRUE(!tablet->metadata()->namespace_id().empty())
+            << "Tablet metadata for namespace_id not backfilled for tablet ID "
+            << tablet->tablet_id();
         if (tablet->metadata()->namespace_id() == namespace_id_) {
-          ASSERT_EQ(safe_time,
-                    ts_manager->AllowedHistoryCutoff(tablet->metadata()).primary_cutoff_ht);
+          ASSERT_EQ(safe_time, cutoff);
         }
       }
     }
diff --git a/src/yb/tablet/tablet_metadata.h b/src/yb/tablet/tablet_metadata.h
index 27033eab51..23e7aa4203 100644
--- a/src/yb/tablet/tablet_metadata.h
+++ b/src/yb/tablet/tablet_metadata.h
@@ -39,14 +39,12 @@
 
 #include "yb/common/common_fwd.h"
 #include "yb/common/constants.h"
-#include "yb/common/entity_ids.h"
 #include "yb/common/hybrid_time.h"
 #include "yb/common/opid.h"
-#include "yb/common/opid.pb.h"
 #include "yb/common/snapshot.h"
 
-#include "yb/docdb/docdb_fwd.h"
 #include "yb/docdb/docdb_compaction_context.h"
+#include "yb/docdb/docdb_fwd.h"
 #include "yb/docdb/key_bounds.h"
 
 #include "yb/dockv/partition.h"
@@ -54,16 +52,15 @@
 
 #include "yb/fs/fs_manager.h"
 
-#include "yb/gutil/dynamic_annotations.h"
 #include "yb/gutil/macros.h"
 #include "yb/gutil/ref_counted.h"
 
 #include "yb/tablet/tablet_fwd.h"
 #include "yb/tablet/metadata.pb.h"
 
-#include "yb/util/status_fwd.h"
 #include "yb/util/locks.h"
 #include "yb/util/mutex.h"
+#include "yb/util/status_fwd.h"
 
 namespace yb::tablet {
 
@@ -87,7 +84,7 @@ struct TableInfo {
   std::string table_id;
   std::string namespace_name;
   // namespace_id is currently used on the xcluster path to determine safe time on the apply
-  // transaction path.
+  // transaction path.  In some cases this may be empty due to lack of backfilling.
   NamespaceId namespace_id;
   std::string table_name;
   TableType table_type;
@@ -360,6 +357,7 @@ class RaftGroupMetadata : public RefCountedThreadSafe<RaftGroupMetadata>,
   // Returns the name, type, schema, index map, schema, etc of the table.
   std::string namespace_name(const TableId& table_id = "") const;
 
+  // This may be empty if not backfilled; see BackfillNamespaceIdIfNeeded.
   NamespaceId namespace_id() const;
 
   std::string table_name(const TableId& table_id = "") const;
@@ -758,13 +756,13 @@ class RaftGroupMetadata : public RefCountedThreadSafe<RaftGroupMetadata>,
   bool OnPostSplitCompactionDone();
 
  private:
-  typedef simple_spinlock MutexType;
+  using MutexType = simple_spinlock;
 
   friend class RefCountedThreadSafe<RaftGroupMetadata>;
   friend class MetadataTest;
 
   // Compile time assert that no one deletes RaftGroupMetadata objects.
-  ~RaftGroupMetadata();
+  ~RaftGroupMetadata() override;
 
   // Constructor for creating a new Raft group.
   explicit RaftGroupMetadata(
diff --git a/src/yb/tablet/tablet_peer.cc b/src/yb/tablet/tablet_peer.cc
index cef05fc6cf..e3449824fe 100644
--- a/src/yb/tablet/tablet_peer.cc
+++ b/src/yb/tablet/tablet_peer.cc
@@ -45,8 +45,6 @@
 #include "yb/consensus/consensus_util.h"
 #include "yb/consensus/log.h"
 #include "yb/consensus/log_anchor_registry.h"
-#include "yb/consensus/log_util.h"
-#include "yb/consensus/opid_util.h"
 #include "yb/consensus/raft_consensus.h"
 #include "yb/consensus/retryable_requests.h"
 #include "yb/consensus/state_change_context.h"
@@ -55,7 +53,6 @@
 
 #include "yb/gutil/casts.h"
 #include "yb/gutil/strings/substitute.h"
-#include "yb/gutil/sysinfo.h"
 
 #include "yb/master/master_ddl.pb.h"
 
@@ -63,8 +60,6 @@
 
 #include "yb/rpc/messenger.h"
 #include "yb/rpc/periodic.h"
-#include "yb/rpc/strand.h"
-#include "yb/rpc/thread_pool.h"
 
 #include "yb/tablet/operations/change_auto_flags_config_operation.h"
 #include "yb/tablet/operations/change_metadata_operation.h"
@@ -87,14 +82,10 @@
 #include "yb/tablet/transaction_participant.h"
 #include "yb/tablet/write_query.h"
 
-#include "yb/util/debug-util.h"
-#include "yb/util/env_util.h"
 #include "yb/util/fault_injection.h"
-#include "yb/util/flags.h"
 #include "yb/util/format.h"
 #include "yb/util/logging.h"
 #include "yb/util/metrics.h"
-#include "yb/util/scope_exit.h"
 #include "yb/util/status_format.h"
 #include "yb/util/status_log.h"
 #include "yb/util/stopwatch.h"
@@ -136,8 +127,7 @@ DECLARE_uint64(cdc_intent_retention_ms);
 
 DECLARE_bool(enable_flush_retryable_requests);
 
-namespace yb {
-namespace tablet {
+namespace yb::tablet {
 
 METRIC_DEFINE_event_stats(table, op_prepare_queue_length, "Operation Prepare Queue Length",
                         MetricUnit::kTasks,
@@ -1238,36 +1228,8 @@ OpId TabletPeer::GetLatestCheckPoint() {
 
 Result<NamespaceId> TabletPeer::GetNamespaceId() {
   auto tablet = VERIFY_RESULT(shared_tablet());
-  auto namespace_id = tablet->metadata()->namespace_id();
-  if (!namespace_id.empty()) {
-    return namespace_id;
-  }
-  // This is empty the first time we try to fetch the namespace id from the tablet metadata, so
-  // fetch it from the client and populate the tablet metadata.
-  auto* client = client_future().get();
-  master::GetNamespaceInfoResponsePB resp;
-  auto* metadata = tablet->metadata();
-  auto namespace_name = metadata->namespace_name();
-  auto db_type = YQL_DATABASE_CQL;
-  switch (metadata->table_type()) {
-    case PGSQL_TABLE_TYPE:
-      db_type = YQL_DATABASE_PGSQL;
-      break;
-    case REDIS_TABLE_TYPE:
-      db_type = YQL_DATABASE_REDIS;
-      break;
-    default:
-      db_type = YQL_DATABASE_CQL;
-  }
-
-  RETURN_NOT_OK(client->GetNamespaceInfo({} /* namesapce_id */, namespace_name, db_type, &resp));
-  namespace_id = resp.namespace_().id();
-  if (namespace_id.empty()) {
-    return STATUS(IllegalState, Format("Could not get namespace id for $0",
-                                       namespace_name));
-  }
-  RETURN_NOT_OK(metadata->set_namespace_id(namespace_id));
-  return namespace_id;
+  RETURN_NOT_OK(BackfillNamespaceIdIfNeeded(*tablet->metadata(), *client_future().get()));
+  return tablet->metadata()->namespace_id();
 }
 
 HybridTime TabletPeer::GetMinStartHTRunningTxnsOrLeaderSafeTime() {
@@ -1906,5 +1868,35 @@ bool TabletPeer::HasSufficientDiskSpaceForWrite() {
   return true;
 }
 
-}  // namespace tablet
-}  // namespace yb
+Status BackfillNamespaceIdIfNeeded(
+    tablet::RaftGroupMetadata& metadata, client::YBClient& client) {
+  auto namespace_id = metadata.namespace_id();
+  if (!namespace_id.empty()) {
+    return Status::OK();
+  }
+
+  // If the namespace ID hasn't been backfilled yet, fetch it from master and populate the tablet
+  // metadata.
+  master::GetNamespaceInfoResponsePB resp;
+  auto namespace_name = metadata.namespace_name();
+  auto db_type = YQL_DATABASE_CQL;
+  switch (metadata.table_type()) {
+    case PGSQL_TABLE_TYPE:
+      db_type = YQL_DATABASE_PGSQL;
+      break;
+    case REDIS_TABLE_TYPE:
+      db_type = YQL_DATABASE_REDIS;
+      break;
+    default:
+      db_type = YQL_DATABASE_CQL;
+  }
+
+  RETURN_NOT_OK(client.GetNamespaceInfo(
+      /*namespace_id=*/{}, namespace_name, db_type, &resp));
+  namespace_id = resp.namespace_().id();
+  SCHECK_FORMAT(
+      !namespace_id.empty(), IllegalState, "Could not get namespace ID for $0", namespace_name);
+  return metadata.set_namespace_id(namespace_id);
+}
+
+}  // namespace yb::tablet
diff --git a/src/yb/tablet/tablet_peer.h b/src/yb/tablet/tablet_peer.h
index 06b5a11ac1..ade6536192 100644
--- a/src/yb/tablet/tablet_peer.h
+++ b/src/yb/tablet/tablet_peer.h
@@ -36,33 +36,29 @@
 #include <future>
 #include <map>
 #include <memory>
-#include <mutex>
 #include <string>
 #include <vector>
 
-#include "yb/consensus/consensus_fwd.h"
 #include "yb/consensus/consensus_context.h"
+#include "yb/consensus/consensus_fwd.h"
 #include "yb/consensus/consensus_meta.h"
-#include "yb/consensus/consensus_types.h"
 #include "yb/gutil/callback.h"
 #include "yb/gutil/ref_counted.h"
 #include "yb/gutil/thread_annotations.h"
 #include "yb/rpc/rpc_fwd.h"
 
-#include "yb/tablet/tablet_fwd.h"
-#include "yb/tablet/metadata.pb.h"
 #include "yb/tablet/mvcc.h"
-#include "yb/tablet/transaction_coordinator.h"
-#include "yb/tablet/transaction_participant_context.h"
 #include "yb/tablet/operations/operation_tracker.h"
 #include "yb/tablet/preparer.h"
 #include "yb/tablet/tablet_bootstrap_state_flusher.h"
 #include "yb/tablet/tablet_bootstrap_state_manager.h"
+#include "yb/tablet/tablet_fwd.h"
 #include "yb/tablet/tablet_options.h"
+#include "yb/tablet/transaction_coordinator.h"
+#include "yb/tablet/transaction_participant_context.h"
 #include "yb/tablet/write_query_context.h"
 
 #include "yb/util/atomic.h"
-#include "yb/util/semaphore.h"
 
 using yb::consensus::StateChangeContext;
 
@@ -149,7 +145,7 @@ class TabletPeer : public std::enable_shared_from_this<TabletPeer>,
                    public TransactionCoordinatorContext,
                    public WriteQueryContext {
  public:
-  typedef std::map<int64_t, int64_t> MaxIdxToSegmentSizeMap;
+  using MaxIdxToSegmentSizeMap = std::map<int64_t, int64_t>;
 
   // Creates TabletPeer.
   // `tablet_splitter` will be used for applying split tablet Raft operation.
@@ -163,7 +159,7 @@ class TabletPeer : public std::enable_shared_from_this<TabletPeer>,
       TabletSplitter* tablet_splitter,
       const std::shared_future<client::YBClient*>& client_future);
 
-  ~TabletPeer();
+  ~TabletPeer() override;
 
   // Initializes the TabletPeer, namely creating the Log and initializing
   // Consensus.
@@ -647,5 +643,8 @@ class TabletPeer : public std::enable_shared_from_this<TabletPeer>,
   DISALLOW_COPY_AND_ASSIGN(TabletPeer);
 };
 
+Status BackfillNamespaceIdIfNeeded(
+    tablet::RaftGroupMetadata& metadata, client::YBClient& client);
+
 }  // namespace tablet
 }  // namespace yb
diff --git a/src/yb/tablet/tablet_peer_mm_ops.h b/src/yb/tablet/tablet_peer_mm_ops.h
index 1abea68038..302e5ff96f 100644
--- a/src/yb/tablet/tablet_peer_mm_ops.h
+++ b/src/yb/tablet/tablet_peer_mm_ops.h
@@ -34,7 +34,7 @@
 
 #include "yb/tablet/maintenance_manager.h"
 #include "yb/tablet/tablet_peer.h"
-#include "yb/util/stopwatch.h"
+#include "yb/util/semaphore.h"
 
 namespace yb {
 
diff --git a/src/yb/tserver/ts_tablet_manager.cc b/src/yb/tserver/ts_tablet_manager.cc
index 4680e40cd0..b8ced69d15 100644
--- a/src/yb/tserver/ts_tablet_manager.cc
+++ b/src/yb/tserver/ts_tablet_manager.cc
@@ -33,7 +33,6 @@
 #include "yb/tserver/ts_tablet_manager.h"
 
 #include <algorithm>
-#include <chrono>
 #include <memory>
 #include <mutex>
 #include <string>
@@ -52,7 +51,6 @@
 #include "yb/client/meta_data_cache.h"
 #include "yb/client/transaction_manager.h"
 
-#include "yb/common/common.pb.h"
 #include "yb/common/constants.h"
 #include "yb/common/snapshot.h"
 #include "yb/common/wire_protocol.h"
@@ -61,7 +59,6 @@
 #include "yb/consensus/consensus_meta.h"
 #include "yb/consensus/consensus_util.h"
 #include "yb/consensus/log.h"
-#include "yb/consensus/log_anchor_registry.h"
 #include "yb/consensus/metadata.pb.h"
 #include "yb/consensus/multi_raft_batcher.h"
 #include "yb/consensus/opid_util.h"
@@ -75,8 +72,6 @@
 #include "yb/fs/fs_manager.h"
 
 #include "yb/gutil/bind.h"
-#include "yb/gutil/callback.h"
-#include "yb/gutil/stl_util.h"
 #include "yb/gutil/strings/substitute.h"
 #include "yb/gutil/sysinfo.h"
 
@@ -97,7 +92,6 @@
 #include "yb/tablet/operations/clone_operation.h"
 #include "yb/tablet/operations/split_operation.h"
 #include "yb/tablet/tablet.h"
-#include "yb/tablet/tablet.pb.h"
 #include "yb/tablet/tablet_bootstrap_if.h"
 #include "yb/tablet/tablet_fwd.h"
 #include "yb/tablet/tablet_metadata.h"
@@ -106,7 +100,6 @@
 #include "yb/tablet/tablet_snapshots.h"
 
 #include "yb/tablet/tablet_types.pb.h"
-#include "yb/tools/yb-admin_util.h"
 
 #include "yb/tserver/full_compaction_manager.h"
 #include "yb/tserver/heartbeater.h"
@@ -119,9 +112,9 @@
 #include "yb/tserver/tserver.pb.h"
 #include "yb/tserver/tserver_xcluster_context_if.h"
 
+#include "yb/util/debug-util.h"
 #include "yb/util/debug/long_operation_tracker.h"
 #include "yb/util/debug/trace_event.h"
-#include "yb/util/debug-util.h"
 #include "yb/util/env.h"
 #include "yb/util/fault_injection.h"
 #include "yb/util/file_util.h"
@@ -517,13 +510,10 @@ TSTabletManager::TSTabletManager(FsManager* fs_manager,
     metric_registry_(metric_registry),
     state_(MANAGER_INITIALIZING) {
   ThreadPoolMetrics metrics = {
-      METRIC_op_apply_queue_length.Instantiate(server_->metric_entity()),
-      METRIC_op_apply_queue_time.Instantiate(server_->metric_entity()),
-      METRIC_op_apply_run_time.Instantiate(server_->metric_entity())
-  };
-  CHECK_OK(ThreadPoolBuilder("apply")
-               .set_metrics(std::move(metrics))
-               .Build(&apply_pool_));
+      .queue_length_stats = METRIC_op_apply_queue_length.Instantiate(server_->metric_entity()),
+      .queue_time_us_stats = METRIC_op_apply_queue_time.Instantiate(server_->metric_entity()),
+      .run_time_us_stats = METRIC_op_apply_run_time.Instantiate(server_->metric_entity())};
+  CHECK_OK(ThreadPoolBuilder("apply").set_metrics(std::move(metrics)).Build(&apply_pool_));
 
   // This pool is shared by all replicas hosted by this server.
   //
@@ -571,10 +561,9 @@ TSTabletManager::TSTabletManager(FsManager* fs_manager,
                .unlimited_threads()
                .Build(&allocation_pool_));
   ThreadPoolMetrics read_metrics = {
-      METRIC_op_read_queue_length.Instantiate(server_->metric_entity()),
-      METRIC_op_read_queue_time.Instantiate(server_->metric_entity()),
-      METRIC_op_read_run_time.Instantiate(server_->metric_entity())
-  };
+      .queue_length_stats = METRIC_op_read_queue_length.Instantiate(server_->metric_entity()),
+      .queue_time_us_stats = METRIC_op_read_queue_time.Instantiate(server_->metric_entity()),
+      .run_time_us_stats = METRIC_op_read_run_time.Instantiate(server_->metric_entity())};
   CHECK_OK(ThreadPoolBuilder("read-parallel")
                .set_max_threads(FLAGS_read_pool_max_threads)
                .set_max_queue_size(FLAGS_read_pool_max_queue_size)
@@ -661,14 +650,13 @@ Status TSTabletManager::Init() {
     LOG_WITH_PREFIX(INFO) <<  "max_bootstrap_threads=" << max_bootstrap_threads;
   }
   ThreadPoolMetrics bootstrap_metrics = {
-          nullptr,
-          nullptr,
-          METRIC_ts_bootstrap_time.Instantiate(server_->metric_entity())
-  };
+      .queue_length_stats = nullptr,
+      .queue_time_us_stats = nullptr,
+      .run_time_us_stats = METRIC_ts_bootstrap_time.Instantiate(server_->metric_entity())};
   RETURN_NOT_OK(ThreadPoolBuilder("tablet-bootstrap")
-                .set_max_threads(max_bootstrap_threads)
-                .set_metrics(std::move(bootstrap_metrics))
-                .Build(&open_tablet_pool_));
+                    .set_max_threads(max_bootstrap_threads)
+                    .set_metrics(std::move(bootstrap_metrics))
+                    .Build(&open_tablet_pool_));
 
   CleanupCheckpoints();
 
@@ -3348,6 +3336,13 @@ docdb::HistoryCutoff TSTabletManager::AllowedHistoryCutoff(tablet::RaftGroupMeta
     result = metadata->cdc_sdk_safe_time();
   }
 
+  Status s = BackfillNamespaceIdIfNeeded(*metadata, client());
+  if (!s.ok()) {
+    YB_LOG_EVERY_N_SECS(ERROR, 30) << "Unable to backfill tablet metadata namespace_id for tablet: "
+                                   << metadata->raft_group_id() << ": " << s;
+    // Only safe action is to block compaction from deleting any document versions.
+    return {.cotables_cutoff_ht = HybridTime::kInvalid, .primary_cutoff_ht = HybridTime::kMin};
+  }
   auto xcluster_safe_time_result =
       server_->GetXClusterContext().GetSafeTime(metadata->namespace_id());
   if (!xcluster_safe_time_result) {
@@ -3356,7 +3351,7 @@ docdb::HistoryCutoff TSTabletManager::AllowedHistoryCutoff(tablet::RaftGroupMeta
     // GetSafeTime call fails when special safetime value is set for a namespace -- this can happen
     // when we have new replication setup and safe time is not yet computed. In this case, we return
     // HybridTime::kMin to stop compaction from deleting any of the existing versions of documents.
-    return { HybridTime::kInvalid, HybridTime::kMin };
+    return {.cotables_cutoff_ht = HybridTime::kInvalid, .primary_cutoff_ht = HybridTime::kMin};
   }
   auto opt_xcluster_safe_time = *xcluster_safe_time_result;
   if (opt_xcluster_safe_time) {
@@ -3399,7 +3394,7 @@ docdb::HistoryCutoff TSTabletManager::AllowedHistoryCutoff(tablet::RaftGroupMeta
   }
   VLOG(1) << "Setting the allowed history cutoff: " << result
           << " for tablet: " << metadata->raft_group_id();
-  return { HybridTime::kInvalid, result };
+  return {.cotables_cutoff_ht = HybridTime::kInvalid, .primary_cutoff_ht = result};
 }
 
 void TSTabletManager::FlushDirtySuperblocks() {
