diff --git a/src/yb/client/async_rpc.cc b/src/yb/client/async_rpc.cc
index 1c7406020f..735507d6b4 100644
--- a/src/yb/client/async_rpc.cc
+++ b/src/yb/client/async_rpc.cc
@@ -16,6 +16,7 @@
 #include "yb/ash/wait_state.h"
 
 #include "yb/client/batcher.h"
+#include "yb/client/client.h"
 #include "yb/client/client_error.h"
 #include "yb/client/in_flight_op.h"
 #include "yb/client/meta_cache.h"
@@ -37,14 +38,10 @@
 
 #include "yb/tserver/tserver_service.proxy.h"
 
-#include "yb/util/cast.h"
-#include "yb/util/debug-util.h"
-#include "yb/util/flags.h"
 #include "yb/util/logging.h"
 #include "yb/util/metrics.h"
 #include "yb/util/result.h"
 #include "yb/util/size_literals.h"
-#include "yb/util/status_log.h"
 #include "yb/util/sync_point.h"
 #include "yb/util/trace.h"
 #include "yb/util/yb_pg_errcodes.h"
@@ -229,19 +226,22 @@ void AsyncRpc::Finished(const Status& status) {
     }
   }
   if (tablet_invoker_.Done(&new_status)) {
-    if (tablet().is_split() ||
-        ClientError(new_status) == ClientErrorCode::kTablePartitionListIsStale) {
-      ops_[0].yb_op->MarkTablePartitionListAsStale();
-    }
-    if (async_rpc_metrics_ && status.ok() && tablet_invoker_.is_consistent_prefix()) {
-      IncrementCounter(async_rpc_metrics_->consistent_prefix_successful_reads);
-    }
-    ProcessResponseFromTserver(new_status);
-    batcher_->Flushed(ops_, new_status, MakeFlushExtraResult());
-    retained_self_.reset();
+    HandleFinished(new_status);
   }
 }
 
+void AsyncRpc::HandleFinished(const Status& status) {
+  if (tablet().is_split() || ClientError(status) == ClientErrorCode::kTablePartitionListIsStale) {
+    ops_[0].yb_op->MarkTablePartitionListAsStale();
+  }
+  if (async_rpc_metrics_ && status.ok() && tablet_invoker_.is_consistent_prefix()) {
+    IncrementCounter(async_rpc_metrics_->consistent_prefix_successful_reads);
+  }
+  ProcessResponseFromTserver(status);
+  batcher_->Flushed(ops_, status, MakeFlushExtraResult());
+  retained_self_.reset();
+}
+
 void AsyncRpc::Failed(const Status& status) {
   VLOG_WITH_FUNC(4) << "status: " << status.ToString();
   std::string error_message = status.message().ToBuffer();
@@ -389,7 +389,17 @@ void AsyncRpc::SendRpcToTserver(int attempt_num) {
   if (async_rpc_metrics_) {
     async_rpc_metrics_->time_to_send->Increment(ToMicroseconds(CoarseMonoClock::Now() - start_));
   }
-  CallRemoteMethod();
+  auto callback = [this](const Status& status) {
+    TRACE_TO(trace_, "AsyncRpc::SendRpcToTserver WaitForAsyncWrites completed");
+    if (!status.ok()) {
+      HandleFinished(status);
+      return;
+    }
+
+    CallRemoteMethod();
+  };
+
+  batcher_->WaitForAsyncWrites(tablet().tablet_id(), std::move(callback));
 }
 
 template <class Req, class Resp>
@@ -648,6 +658,8 @@ WriteRpc::WriteRpc(const AsyncRpcData& data)
   VLOG(3) << "Created batch for " << data.tablet->tablet_id() << ":\n"
           << req_.ShortDebugString();
 
+  req_.set_use_async_write(data.use_async_write);
+
   if (batcher_->GetLeaderTerm() != OpId::kUnknownTerm) {
     req_.set_leader_term(batcher_->GetLeaderTerm());
   }
@@ -693,16 +705,9 @@ WriteRpc::~WriteRpc() {
 }
 
 void WriteRpc::CallRemoteMethod() {
-  auto trace = trace_; // It is possible that we receive reply before returning from WriteAsync.
-                       // Since send happens before we return from WriteAsync.
-                       // So under heavy load it is possible that our request is handled and
-                       // reply is received before WriteAsync returned.
-  TRACE_TO(trace, "SendRpcToTserver");
-  ADOPT_TRACE(trace.get());
-
-  tablet_invoker_.proxy()->WriteAsync(
+  ts_proxy_ = tablet_invoker_.proxy();
+  ts_proxy_->WriteAsync(
       req_, &resp_, PrepareController(), std::bind(&WriteRpc::Finished, this, Status::OK()));
-  TRACE_TO(trace, "RpcDispatched Asynchronously");
 }
 
 Status WriteRpc::SwapResponses() {
@@ -841,15 +846,9 @@ ReadRpc::~ReadRpc() {
 }
 
 void ReadRpc::CallRemoteMethod() {
-  auto trace = trace_; // It is possible that we receive reply before returning from ReadAsync.
-                       // Detailed explanation in WriteRpc::SendRpcToTserver.
-  TRACE_TO(trace, "SendRpcToTserver");
-  ADOPT_TRACE(trace.get());
-
   DEBUG_ONLY_TEST_SYNC_POINT_CALLBACK("ReadRpc::CallRemoteMethod", &req_);
   tablet_invoker_.proxy()->ReadAsync(
-    req_, &resp_, PrepareController(), std::bind(&ReadRpc::Finished, this, Status::OK()));
-  TRACE_TO(trace, "RpcDispatched Asynchronously");
+      req_, &resp_, PrepareController(), std::bind(&ReadRpc::Finished, this, Status::OK()));
 }
 
 Status ReadRpc::SwapResponses() {
@@ -928,4 +927,62 @@ void ReadRpc::NotifyBatcher(const Status& status) {
   batcher_->ProcessReadResponse(*this, status);
 }
 
+WaitForAsyncWriteRpc::WaitForAsyncWriteRpc(
+    const BatcherPtr& batcher, const TabletId& tablet_id,
+    std::shared_ptr<tserver::TabletServerServiceProxy> ts_proxy, const OpId& op_id)
+    : Rpc(batcher->deadline(), batcher->messenger(), &batcher->proxy_cache()),
+      tablet_id_(tablet_id),
+      op_id_(op_id),
+      batcher_(batcher),
+      ts_proxy_(std::move(ts_proxy)) {
+  TRACE_TO(trace_, "WaitForAsyncWrite initiated");
+  VTRACE_TO(1, trace_, "Tablet $0, op_id $2", tablet_id_, op_id_.ToString());
+
+  req_.set_tablet_id(tablet_id_);
+  op_id_.ToPB(req_.mutable_op_id());
+
+  VLOG(4) << "Created WaitForAsyncWriteRequest" << ":\n" << req_.ShortDebugString();
+}
+
+void WaitForAsyncWriteRpc::SendRpc() {
+  TRACE_TO(trace_, "SendRpc() called.");
+
+  retained_self_ = shared_from_this();
+  ts_proxy_->WaitForAsyncWriteAsync(
+      req_, &resp_, PrepareController(),
+      std::bind(&WaitForAsyncWriteRpc::Finished, this, Status::OK()));
+}
+
+void WaitForAsyncWriteRpc::SendRpcToTserver(int attempt_num) { CHECK(false) << "Not implemented"; }
+
+void WaitForAsyncWriteRpc::Finished(const Status& status) {
+  VLOG_WITH_FUNC(4) << ToString() << "status: " << status
+                    << ", error: " << AsString(response_error());
+
+  Status new_status = status;
+  if (new_status.ok() && mutable_retrier()->HandleResponse(this, &new_status)) {
+    return;
+  }
+
+  if (new_status.ok() && resp_.has_error()) {
+    new_status = StatusFromPB(resp_.error().status());
+  }
+
+  batcher_->RecordAsyncWriteCompletion(tablet_id_, op_id_, new_status);
+  retained_self_.reset();
+}
+
+std::string WaitForAsyncWriteRpc::ToString() const {
+  const auto& metadata = batcher_->in_flight_ops().metadata;
+  return Format(
+      "WaitForAsyncWrite(tablet: $0, op_id: $1, num_attempts: $2, txn: $3, subtxn: $4)", tablet_id_,
+      op_id_, num_attempts(), metadata.transaction.transaction_id,
+      metadata.subtransaction_pb ? AsString(metadata.subtransaction_pb->subtransaction_id())
+                                 : "[none]");
+}
+
+void WaitForAsyncWriteRpc::Failed(const Status& status) {
+  VLOG_WITH_FUNC(4) << ToString() << " status: " << status;
+}
+
 }  // namespace yb::client::internal
diff --git a/src/yb/client/async_rpc.h b/src/yb/client/async_rpc.h
index 809a92b7cc..06c90ce8a0 100644
--- a/src/yb/client/async_rpc.h
+++ b/src/yb/client/async_rpc.h
@@ -20,8 +20,8 @@
 #include "yb/client/tablet_rpc.h"
 
 #include "yb/common/common_types.pb.h"
+#include "yb/common/opid.h"
 #include "yb/common/read_hybrid_time.h"
-#include "yb/common/retryable_request.h"
 
 #include "yb/rpc/rpc_fwd.h"
 
@@ -64,6 +64,7 @@ struct AsyncRpcData {
   bool need_consistent_read = false;
   InFlightOps ops;
   bool need_metadata = false;
+  bool use_async_write = false;
 };
 
 struct FlushExtraResult {
@@ -98,6 +99,8 @@ class AsyncRpc : public rpc::Rpc, public TabletRpc {
  protected:
   void Finished(const Status& status) override;
 
+  void HandleFinished(const Status& status);
+
   void SendRpcToTserver(int attempt_num) override;
 
   virtual void CallRemoteMethod() = 0;
@@ -182,10 +185,14 @@ class WriteRpc : public AsyncRpcBase<tserver::WriteRequestPB, tserver::WriteResp
 
   std::string GetRpcName() override { return "Write"; }
 
+  std::shared_ptr<tserver::TabletServerServiceProxy> ts_proxy() const { return ts_proxy_; }
+
  private:
   Status SwapResponses() override;
   void CallRemoteMethod() override;
   void NotifyBatcher(const Status& status) override;
+
+  std::shared_ptr<tserver::TabletServerServiceProxy> ts_proxy_;
 };
 
 class ReadRpc : public AsyncRpcBase<tserver::ReadRequestPB, tserver::ReadResponsePB> {
@@ -203,6 +210,39 @@ class ReadRpc : public AsyncRpcBase<tserver::ReadRequestPB, tserver::ReadRespons
   void NotifyBatcher(const Status& status) override;
 };
 
+class WaitForAsyncWriteRpc : public rpc::Rpc, public TabletRpc {
+ public:
+  WaitForAsyncWriteRpc(
+      const BatcherPtr& batcher, const TabletId& tablet_id,
+      std::shared_ptr<tserver::TabletServerServiceProxy> ts_proxy, const OpId& op_id);
+
+  ~WaitForAsyncWriteRpc() = default;
+
+  void SendRpc() override;
+  std::string ToString() const override;
+
+ protected:
+  const tserver::TabletServerErrorPB* response_error() const override {
+    return resp_.has_error() ? &resp_.error() : nullptr;
+  }
+
+  void SendRpcToTserver(int attempt_num) override;
+
+  void Finished(const Status& status) override;
+
+  void Failed(const Status& status) override;
+
+ private:
+  const TabletId tablet_id_;
+  const OpId op_id_;
+  BatcherPtr batcher_;
+  std::shared_ptr<tserver::TabletServerServiceProxy> ts_proxy_;
+  tserver::WaitForAsyncWriteRequestPB req_;
+  tserver::WaitForAsyncWriteResponsePB resp_;
+
+  rpc::RpcCommandPtr retained_self_;
+};
+
 }  // namespace internal
 }  // namespace client
 }  // namespace yb
diff --git a/src/yb/client/batcher.cc b/src/yb/client/batcher.cc
index b62c37622e..ea98998bb2 100644
--- a/src/yb/client/batcher.cc
+++ b/src/yb/client/batcher.cc
@@ -67,6 +67,7 @@
 #include "yb/gutil/stl_util.h"
 #include "yb/gutil/strings/join.h"
 
+#include "yb/master/sys_catalog_constants.h"
 #include "yb/util/debug-util.h"
 #include "yb/util/flags.h"
 #include "yb/util/format.h"
@@ -86,6 +87,10 @@ DEFINE_test_flag(double, simulate_tablet_lookup_does_not_match_partition_key_pro
                  "range of the resolved tablet's partition.");
 DEFINE_test_flag(bool, fail_batcher_rpc, false, "Fail batcher RPCs for testing purposes.");
 
+DEFINE_RUNTIME_PREVIEW_bool(ysql_enable_async_writes, false,
+    "Enable asynchronous quorum commit for writes. When enabled, multiple write statements in a "
+    "transaction can execute concurrently, reducing overall latency.");
+
 using std::pair;
 using std::shared_ptr;
 
@@ -106,6 +111,12 @@ namespace {
 
 const auto kGeneralErrorStatus = STATUS(IOError, Batcher::kErrorReachingOutToTServersMsg);
 
+bool UseAsyncWrites(YBTableType table_type, TransactionId txn_id) {
+  // Use async writes for transactional writes in YSQL, or if the test flag is enabled.
+  return FLAGS_ysql_enable_async_writes && table_type == YBTableType::PGSQL_TABLE_TYPE &&
+         !txn_id.IsNil();
+}
+
 }  // namespace
 
 // About lock ordering in this file:
@@ -640,7 +651,8 @@ void Batcher::MoveRequestDetailsFrom(const BatcherPtr& other, RetryableRequestId
 std::shared_ptr<AsyncRpc> Batcher::CreateRpc(
     const BatcherPtr& self, RemoteTablet* tablet, const InFlightOpsGroup& group,
     const bool allow_local_calls_in_curr_thread, const bool need_consistent_read) {
-  VLOG_WITH_PREFIX_AND_FUNC(3) << "tablet: " << tablet->tablet_id();
+  const auto& tablet_id = tablet->tablet_id();
+  VLOG_WITH_PREFIX_AND_FUNC(3) << "tablet: " << tablet_id;
 
   CHECK(group.begin != group.end);
 
@@ -652,8 +664,8 @@ std::shared_ptr<AsyncRpc> Batcher::CreateRpc(
 
   // Split the read operations according to consistency levels since based on consistency
   // levels the read algorithm would differ.
-  const auto op_group = (*group.begin).yb_op->group();
-  AsyncRpcData data {
+
+  AsyncRpcData data{
       .batcher = self,
       .tablet = tablet,
       .allow_local_calls_in_curr_thread = allow_local_calls_in_curr_thread,
@@ -662,13 +674,24 @@ std::shared_ptr<AsyncRpc> Batcher::CreateRpc(
       .need_metadata = group.need_metadata
   };
 
+  const auto& first_op = group.begin->yb_op;
+  auto transaction = this->transaction();
+  if (!data.need_metadata && transaction && transaction->HasPendingAsyncWrites(tablet_id)) {
+    data.need_metadata = true;
+  }
+
+  const auto op_group = first_op->group();
   switch (op_group) {
-    case OpGroup::kWrite: FALLTHROUGH_INTENDED;
-    case OpGroup::kLock: FALLTHROUGH_INTENDED;
-    case OpGroup::kUnlock:
+    case OpGroup::kWrite: [[fallthrough]];
+    case OpGroup::kLock: [[fallthrough]];
+    case OpGroup::kUnlock: {
+      data.use_async_write = UseAsyncWrites(
+          first_op->table()->table_type(), ops_info_.metadata.transaction.transaction_id);
       return std::make_shared<WriteRpc>(data);
-    case OpGroup::kLeaderRead:
+    }
+    case OpGroup::kLeaderRead: {
       return std::make_shared<ReadRpc>(data, YBConsistencyLevel::STRONG);
+    }
     case OpGroup::kConsistentPrefixRead:
       return std::make_shared<ReadRpc>(data, YBConsistencyLevel::CONSISTENT_PREFIX);
   }
@@ -749,8 +772,29 @@ void Batcher::ProcessReadResponse(const ReadRpc &rpc, const Status &s) {
 void Batcher::ProcessWriteResponse(const WriteRpc &rpc, const Status &s) {
   ProcessRpcStatus(rpc, s);
 
-  if (s.ok() && rpc.resp().has_propagated_hybrid_time()) {
-    client_->data_->UpdateLatestObservedHybridTime(rpc.resp().propagated_hybrid_time());
+  if (s.ok()) {
+    const auto& resp = rpc.resp();
+    if (resp.has_async_write_op_id()) {
+      // We have a async write. Record the OpId, and send a async RPC to track its completion.
+      // At time of final commit, we will wait for all these async writes to complete.
+      auto transaction = this->transaction();
+      if (transaction) {
+        const auto op_id = OpId::FromPB(resp.async_write_op_id());
+        const auto& tablet = rpc.tablet();
+
+        if (transaction->RecordAsyncWrite(tablet.tablet_id(), op_id)) {
+          // Multiple write operations can get combined into the same async write RPC resulting in
+          // duplicate OpIds.
+          auto wait_for_async_write_rpc = std::make_shared<WaitForAsyncWriteRpc>(
+              shared_from_this(), tablet.tablet_id(), rpc.ts_proxy(), op_id);
+          wait_for_async_write_rpc->SendRpc();
+        }
+      }
+    }
+
+    if (resp.has_propagated_hybrid_time()) {
+      client_->data_->UpdateLatestObservedHybridTime(resp.propagated_hybrid_time());
+    }
   }
 
   // Check individual row errors.
@@ -815,6 +859,23 @@ void Batcher::InitFromFailedBatcher(const BatcherPtr& failed_batcher,
   SetSubTransactionMetadataPB(failed_batcher->GetSubTransactionMetadataPB());
 }
 
+void Batcher::RecordAsyncWriteCompletion(
+    const TabletId& tablet_id, const OpId& op_id, const Status& status) {
+  auto transaction = this->transaction();
+  if (transaction) {
+    transaction->RecordAsyncWriteCompletion(tablet_id, op_id, status);
+  }
+}
+
+void Batcher::WaitForAsyncWrites(const TabletId& tablet_id, StdStatusCallback&& callback) {
+  auto transaction = this->transaction();
+  if (!transaction) {
+    callback(Status::OK());
+    return;
+  }
+  transaction->WaitForAsyncWrites(tablet_id, std::move(callback));
+}
+
 InFlightOpsGroup::InFlightOpsGroup(const Iterator& group_begin, const Iterator& group_end)
     : begin(group_begin), end(group_end) {
 }
diff --git a/src/yb/client/batcher.h b/src/yb/client/batcher.h
index 00ce9df031..040ec2dab9 100644
--- a/src/yb/client/batcher.h
+++ b/src/yb/client/batcher.h
@@ -32,7 +32,6 @@
 #pragma once
 
 #include <unordered_map>
-#include <unordered_set>
 #include <vector>
 
 #include "yb/ash/ash_fwd.h"
@@ -42,7 +41,6 @@
 #include "yb/client/transaction.h"
 
 #include "yb/common/consistent_read_point.h"
-#include "yb/common/opid.h"
 #include "yb/common/retryable_request.h"
 #include "yb/common/transaction.h"
 
@@ -50,8 +48,6 @@
 #include "yb/gutil/ref_counted.h"
 
 #include "yb/util/async_util.h"
-#include "yb/util/atomic.h"
-#include "yb/util/locks.h"
 #include "yb/util/status_fwd.h"
 #include "yb/util/threadpool.h"
 
@@ -318,10 +314,16 @@ class Batcher : public Runnable, public std::enable_shared_from_this<Batcher> {
   friend class RefCountedThreadSafe<Batcher>;
   friend class AsyncRpc;
   friend class WriteRpc;
+  friend class WaitForAsyncWriteRpc;
   friend class ReadRpc;
 
   void Flushed(const InFlightOps& ops, const Status& status, FlushExtraResult flush_extra_result);
 
+  void RecordAsyncWriteCompletion(
+      const TabletId& tablet_id, const OpId& op_id, const Status& status);
+
+  void WaitForAsyncWrites(const TabletId& tablet_id, StdStatusCallback&& callback);
+
   // Combines new error to existing ones. I.e. updates combined error with new status.
   void CombineError(const InFlightOp& in_flight_op);
 
diff --git a/src/yb/client/session.h b/src/yb/client/session.h
index 45d6f0e2e0..fc2c7635c7 100644
--- a/src/yb/client/session.h
+++ b/src/yb/client/session.h
@@ -284,6 +284,24 @@ class YBSession : public std::enable_shared_from_this<YBSession> {
 
   internal::AsyncRpcMetricsPtr async_rpc_metrics_;
 
+  mutable std::mutex async_write_query_mutex_;
+  struct AsyncWriteQuery {
+    TabletId tablet_id;
+    OpId op_id;
+
+    bool operator<(const AsyncWriteQuery& other) const {
+      return std::tie(tablet_id, op_id) < std::tie(other.tablet_id, other.op_id);
+    }
+
+    bool operator==(const AsyncWriteQuery& other) const {
+      return std::tie(tablet_id, op_id) == std::tie(other.tablet_id, other.op_id);
+    }
+  };
+  std::unordered_map<TableId, std::set<AsyncWriteQuery>> inflight_async_writes_
+      GUARDED_BY(async_write_query_mutex_);
+  Status async_write_status_ GUARDED_BY(async_write_query_mutex_);
+  mutable std::condition_variable async_write_query_completion_cv_;
+
   DISALLOW_COPY_AND_ASSIGN(YBSession);
 };
 
diff --git a/src/yb/client/tablet_rpc.cc b/src/yb/client/tablet_rpc.cc
index cc5aea8bdf..4c4f1148ed 100644
--- a/src/yb/client/tablet_rpc.cc
+++ b/src/yb/client/tablet_rpc.cc
@@ -279,7 +279,14 @@ void TabletInvoker::Execute(const std::string& tablet_id, bool leader_only) {
           << current_ts_->ToString();
   int64_t opid_index = client_->GetRaftConfigOpidIndex(tablet_id_);
   rpc_->SetRequestRaftConfigOpidIndex(opid_index);
+
+  // Keep a refon trace, since it is possible that we receive reply before returning from async rpc,
+  // destroying us.
+  auto trace = trace_;
+  TRACE_TO(trace, "SendRpcToTserver");
+  ADOPT_TRACE(trace);
   rpc_->SendRpcToTserver(retrier_->attempt_num());
+  TRACE_TO(trace, "RpcDispatched Asynchronously");
 }
 
 Status TabletInvoker::FailToNewReplica(const Status& reason,
diff --git a/src/yb/client/transaction.cc b/src/yb/client/transaction.cc
index 55942b09fa..d6d0272b36 100644
--- a/src/yb/client/transaction.cc
+++ b/src/yb/client/transaction.cc
@@ -158,7 +158,12 @@ std::ostream& operator<<(std::ostream& str, const TaggedLogPrefix& value) {
   return str << ": ";
 }
 
-} // namespace
+struct AsyncWriteQuery {
+  std::unordered_set<OpId> op_ids;
+  std::vector<StdStatusCallback> waiters_ = {};
+};
+
+}  // namespace
 
 Result<ChildTransactionData> ChildTransactionData::FromPB(const ChildTransactionDataPB& data) {
   ChildTransactionData result;
@@ -559,6 +564,28 @@ class YBTransaction::Impl final : public internal::TxnBatcherIf {
       EXCLUDES(mutex_) {
     auto transaction = transaction_->shared_from_this();
     TRACE_TO(trace_, __func__);
+    {
+      UniqueLock lock(async_write_query_mutex_);
+      auto status = async_write_status_;
+      if (!status.ok()) {
+        lock.unlock();
+        callback(status);
+        return;
+      }
+      if (!inflight_async_writes_.empty()) {
+        async_write_commit_waiter_ = [transaction, seal_only, deadline,
+                                      callback = std::move(callback)](const Status& status) {
+          TRACE_TO(transaction->trace(), "YBTransaction::Commit Async writes completed");
+          if (status.ok()) {
+            transaction->Commit(deadline, seal_only, std::move(callback));
+          } else {
+            callback(status);
+          }
+        };
+        return;
+      }
+    }
+
     {
       UniqueLock lock(mutex_);
       auto status = CheckCouldCommitUnlocked(seal_only);
@@ -1125,6 +1152,88 @@ class YBTransaction::Impl final : public internal::TxnBatcherIf {
     return wait_state_;
   }
 
+  // Records the Async Write OpId. Returns true if the query was recorded, false if it already
+  // existed.
+  bool RecordAsyncWrite(const TabletId& tablet_id, const OpId& op_id)
+      EXCLUDES(async_write_query_mutex_) {
+    VLOG_WITH_PREFIX_AND_FUNC(4) << YB_STRUCT_TO_STRING(tablet_id, op_id);
+
+    std::lock_guard l(async_write_query_mutex_);
+    return InsertIfNotPresent(&inflight_async_writes_[tablet_id].op_ids, op_id);
+  }
+
+  void RecordAsyncWriteCompletion(
+      const TabletId& tablet_id, const OpId& op_id, const Status& status)
+      EXCLUDES(async_write_query_mutex_) {
+    VLOG_WITH_PREFIX_AND_FUNC(4) << YB_STRUCT_TO_STRING(tablet_id, op_id, status);
+
+    std::vector<StdStatusCallback> waiters;
+    {
+      std::lock_guard l(async_write_query_mutex_);
+      auto table_it = inflight_async_writes_.find(tablet_id);
+      if (table_it == inflight_async_writes_.end()) {
+        // Maybe we got stale responses from multiple retries on the rpc. We dont care about the
+        // status in such cases.
+        return;
+      }
+
+      auto& tablet_data = table_it->second;
+
+      if (status.ok()) {
+        // Partition key is not needed for searching.
+        tablet_data.op_ids.erase(op_id);
+        if (tablet_data.op_ids.empty()) {
+          waiters = std::move(tablet_data.waiters_);
+          inflight_async_writes_.erase(table_it);
+        }
+      } else if (async_write_status_.ok()) {
+        async_write_status_ = status;
+      }
+
+      if (!async_write_status_.ok() || inflight_async_writes_.empty()) {
+        for (auto& [_, tablet_data] : inflight_async_writes_) {
+          MoveCollection(&tablet_data.waiters_, &waiters);
+          tablet_data.waiters_.clear();
+        }
+
+        if (async_write_commit_waiter_) {
+          waiters.push_back(std::move(async_write_commit_waiter_));
+          async_write_commit_waiter_ = nullptr;
+        }
+      }
+    }
+
+    for (auto& waiter : waiters) {
+      waiter(status);
+    }
+  }
+
+  bool HasPendingAsyncWrites(const TabletId& tablet_id) const EXCLUDES(async_write_query_mutex_) {
+    std::lock_guard l(async_write_query_mutex_);
+    return inflight_async_writes_.contains(tablet_id);
+  }
+
+  void WaitForAsyncWrites(const TabletId& tablet_id, StdStatusCallback&& callback) {
+    Status status;
+    {
+      std::lock_guard l(async_write_query_mutex_);
+      status = async_write_status_;
+      if (status.ok()) {
+        // If the tablet has a pending write then we are guaranteed that its parent tablets do not
+        // have pending writes, since new writes wait for the parent tablets writes to complete.
+        auto tablet_it = FindOrNull(inflight_async_writes_, tablet_id);
+        if (tablet_it) {
+          tablet_it->waiters_.emplace_back(std::move(callback));
+          VLOG_WITH_PREFIX_AND_FUNC(4)
+              << "Waiting for async writes: " << YB_STRUCT_TO_STRING(tablet_id, status);
+          return;
+        }
+      }
+    }
+
+    callback(status);
+  }
+
  private:
   void CompleteConstruction() {
     LOG_IF(FATAL, !IsAcceptableAtomicImpl(log_prefix_.tag));
@@ -2461,6 +2570,12 @@ class YBTransaction::Impl final : public internal::TxnBatcherIf {
   // wait-on-dependency from session level transaction -> regular transaction. This is necessary to
   // detect deadlocks involving advisory locks and row-level locks (and object locks in future).
   std::weak_ptr<YBTransaction> background_transaction_;
+
+  mutable std::mutex async_write_query_mutex_;
+  std::unordered_map<TabletId, AsyncWriteQuery> inflight_async_writes_
+      GUARDED_BY(async_write_query_mutex_);
+  StdStatusCallback async_write_commit_waiter_ GUARDED_BY(async_write_query_mutex_);
+  Status async_write_status_ GUARDED_BY(async_write_query_mutex_);
 };
 
 CoarseTimePoint AdjustDeadline(CoarseTimePoint deadline) {
@@ -2662,5 +2777,22 @@ void YBTransaction::SetBackgroundTransaction(const YBTransactionPtr& background_
   return impl_->SetBackgroundTransaction(background_transaction);
 }
 
+bool YBTransaction::RecordAsyncWrite(const TabletId& tablet_id, const OpId& op_id) {
+  return impl_->RecordAsyncWrite(tablet_id, op_id);
+}
+
+void YBTransaction::RecordAsyncWriteCompletion(
+    const TabletId& tablet_id, const OpId& op_id, const Status& status) {
+  return impl_->RecordAsyncWriteCompletion(tablet_id, op_id, status);
+}
+
+bool YBTransaction::HasPendingAsyncWrites(const TabletId& tablet_id) const {
+  return impl_->HasPendingAsyncWrites(tablet_id);
+}
+
+void YBTransaction::WaitForAsyncWrites(const TabletId& tablet_id, StdStatusCallback&& callback) {
+  return impl_->WaitForAsyncWrites(tablet_id, std::move(callback));
+}
+
 } // namespace client
 } // namespace yb
diff --git a/src/yb/client/transaction.h b/src/yb/client/transaction.h
index 3455a251ac..fc1b79b9cf 100644
--- a/src/yb/client/transaction.h
+++ b/src/yb/client/transaction.h
@@ -29,6 +29,7 @@
 #include "yb/client/client_fwd.h"
 #include "yb/client/in_flight_op.h"
 
+#include "yb/util/status_callback.h"
 #include "yb/util/status_fwd.h"
 
 namespace yb {
@@ -210,6 +211,14 @@ class YBTransaction : public std::enable_shared_from_this<YBTransaction> {
 
   const ash::WaitStateInfoPtr wait_state();
 
+  // Records the Async Write OpId. Returns true if the query was recorded, false if it already
+  // existed.
+  bool RecordAsyncWrite(const TabletId& tablet_id, const OpId& op_id);
+  void RecordAsyncWriteCompletion(
+      const TabletId& tablet_id, const OpId& op_id, const Status& status);
+  bool HasPendingAsyncWrites(const TabletId& tablet_id) const;
+  void WaitForAsyncWrites(const TabletId& tablet_id, StdStatusCallback&& callback);
+
  private:
   class Impl;
   std::unique_ptr<Impl> impl_;
diff --git a/src/yb/consensus/consensus_context.h b/src/yb/consensus/consensus_context.h
index 7868732143..5e4b145399 100644
--- a/src/yb/consensus/consensus_context.h
+++ b/src/yb/consensus/consensus_context.h
@@ -56,8 +56,11 @@ class ConsensusContext {
 
   // This is called every time majority-replicated watermarks (OpId / leader leases) change. This is
   // used for updating the "propagated safe time" value in MvccManager and unblocking readers
-  // waiting for it to advance.
-  virtual Status MajorityReplicated() = 0;
+  // waiting for it to advance, and notifying async write operations of completion.
+  virtual Status MajorityReplicated(const OpId& committed_op_id) = 0;
+
+  // This is called when a LEADER transitions to a follower or learner.
+  virtual void BecomeReplica() = 0;
 
   // This is called every time the Raft config was changed and replicated.
   // This is used to notify the higher layer about the config change. Currently it's
diff --git a/src/yb/consensus/consensus_queue.cc b/src/yb/consensus/consensus_queue.cc
index 6a852f9e54..12afcbf880 100644
--- a/src/yb/consensus/consensus_queue.cc
+++ b/src/yb/consensus/consensus_queue.cc
@@ -702,12 +702,12 @@ Result<ReadOpsResult> PeerMessageQueue::ReadFromLogCache(
     if (PREDICT_TRUE(s.IsNotFound())) {
       return s;
     } else if (s.IsIncomplete()) {
-      // IsIncomplete() means that we tried to read beyond the head of the log (in the future).
-      // KUDU-1078 points to a fix of this log spew issue that we've ported. This should not
-      // happen under normal circumstances.
-      LOG_WITH_PREFIX(DFATAL)
-          << "Error trying to read ahead of the log while preparing peer request: "
-          << s << ". Destination peer: " << peer_uuid;
+      // IsIncomplete() means that we tried to read beyond the head of the log (in the future). This
+      // is usually a sign that this peer is under load and is about to step down as leader. See
+      // KUDU-1078.
+      LOG_WITH_PREFIX(INFO)
+          << "Error trying to read ahead of the log while preparing peer request: " << s
+          << ". Destination peer: " << peer_uuid;
       return s;
     } else {
       LOG_WITH_PREFIX(FATAL) << "Error reading the log while preparing peer request: "
diff --git a/src/yb/consensus/raft_consensus.cc b/src/yb/consensus/raft_consensus.cc
index 3105d2f543..3cc9a4bcf6 100644
--- a/src/yb/consensus/raft_consensus.cc
+++ b/src/yb/consensus/raft_consensus.cc
@@ -133,6 +133,10 @@ DEFINE_test_flag(bool, follower_reject_update_consensus_requests, false,
 DEFINE_test_flag(bool, follower_pause_update_consensus_requests, false,
                  "Whether a follower will pause all UpdateConsensus() requests.");
 
+DEFINE_test_flag(int32, delay_update_consensus_requests_ms, 0,
+    "Delay execution of UpdateConsensus() requests for specified amount of milliseconds during "
+    "tests");
+
 DEFINE_test_flag(int32, follower_reject_update_consensus_requests_seconds, 0,
                  "Whether a follower will return an error for all UpdateConsensus() requests for "
                  "the first TEST_follower_reject_update_consensus_requests_seconds seconds after "
@@ -1161,7 +1165,9 @@ Status RaftConsensus::BecomeReplicaUnlocked(
     WithholdElectionAfterStepDown(new_leader_uuid);
   }
 
-  state_->ClearLeaderUnlocked();
+  state_->BecomeReplicaUnlocked();
+
+  state_->context()->BecomeReplica();
 
   // FD should be running while we are a follower.
   EnableFailureDetector(initial_fd_wait);
@@ -1418,7 +1424,7 @@ void RaftConsensus::UpdateMajorityReplicated(
       majority_replicated_data.op_id, committed_op_id, &committed_index_changed,
       last_applied_op_id);
   if (s.ok() && state_->GetLeaderStateUnlocked().ok()) {
-    s = state_->context()->MajorityReplicated();
+    s = state_->context()->MajorityReplicated(*committed_op_id);
   }
   if (PREDICT_FALSE(!s.ok())) {
     string msg = Format("Unable to mark committed up to $0: $1", majority_replicated_data.op_id, s);
@@ -1596,6 +1602,8 @@ Status RaftConsensus::Update(
     auto delay = TEST_delay_update_.load(std::memory_order_acquire);
     if (delay != MonoDelta::kZero) {
       std::this_thread::sleep_for(delay.ToSteadyDuration());
+    } else if (FLAGS_TEST_delay_update_consensus_requests_ms != 0) {
+      std::this_thread::sleep_for(1ms * FLAGS_TEST_delay_update_consensus_requests_ms);
     }
   }
 
diff --git a/src/yb/consensus/replica_state.cc b/src/yb/consensus/replica_state.cc
index 5bfe6f6c86..729d5566c4 100644
--- a/src/yb/consensus/replica_state.cc
+++ b/src/yb/consensus/replica_state.cc
@@ -531,6 +531,10 @@ const string& ReplicaState::GetLeaderUuidUnlocked() const {
   return cmeta_->leader_uuid();
 }
 
+void ReplicaState::BecomeReplicaUnlocked() {
+  ClearLeaderUnlocked();
+}
+
 const bool ReplicaState::HasVotedCurrentTermUnlocked() const {
   DCHECK(IsLocked());
   return cmeta_->has_voted_for();
diff --git a/src/yb/consensus/replica_state.h b/src/yb/consensus/replica_state.h
index 495668604b..7301e78363 100644
--- a/src/yb/consensus/replica_state.h
+++ b/src/yb/consensus/replica_state.h
@@ -246,6 +246,7 @@ class ReplicaState {
   const std::string& GetLeaderUuidUnlocked() const;
   bool HasLeaderUnlocked() const { return !GetLeaderUuidUnlocked().empty(); }
   void ClearLeaderUnlocked() { SetLeaderUuidUnlocked(""); }
+  void BecomeReplicaUnlocked();
 
   // Return whether this peer has voted in the current term.
   const bool HasVotedCurrentTermUnlocked() const;
diff --git a/src/yb/consensus/test_consensus_context.h b/src/yb/consensus/test_consensus_context.h
index 0588099a26..cf0068446c 100644
--- a/src/yb/consensus/test_consensus_context.h
+++ b/src/yb/consensus/test_consensus_context.h
@@ -30,7 +30,9 @@ class TestConsensusContext : public ConsensusContext {
 
   Result<HybridTime> PreparePeerRequest() override { return HybridTime(); }
 
-  Status MajorityReplicated() override { return Status::OK(); }
+  Status MajorityReplicated(const OpId& committed_op_id) override { return Status::OK(); }
+
+  void BecomeReplica() override {}
 
   void ChangeConfigReplicated(const RaftConfigPB&) override {}
 
diff --git a/src/yb/integration-tests/CMakeLists.txt b/src/yb/integration-tests/CMakeLists.txt
index 8ce2bee8a2..0556fbbb29 100644
--- a/src/yb/integration-tests/CMakeLists.txt
+++ b/src/yb/integration-tests/CMakeLists.txt
@@ -305,27 +305,15 @@ if("${COMPILER_FAMILY}" STREQUAL "gcc8")
   YB_TEST_TARGET_COMPILE_OPTIONS(cassandra_cpp_driver-test PUBLIC "-Wno-class-memaccess")
 endif()
 
+ADD_YB_TEST(wait_states-itest)
+YB_TEST_TARGET_LINK_LIBRARIES(wait_states-itest yb-cql pg_wrapper_test_base)
+
 function(ADD_YB_CQL_TEST TEST_NAME)
   ADD_YB_TEST(${TEST_NAME})
   YB_TEST_TARGET_INCLUDE_DIRECTORIES(${TEST_NAME} PUBLIC ${CASS_DRIVER_INTERNAL_INCLUDE})
   YB_TEST_TARGET_LINK_LIBRARIES(${TEST_NAME} yb-cql)
 endfunction()
 
-ADD_YB_TEST(wait_states-itest)
-YB_TEST_TARGET_LINK_LIBRARIES(wait_states-itest yb-cql pg_wrapper_test_base)
-
-ADD_YB_TEST(minicluster-snapshot-test)
-YB_TEST_TARGET_LINK_LIBRARIES(minicluster-snapshot-test pg_wrapper_test_base)
-
-ADD_YB_TEST(disk_full-test)
-YB_TEST_TARGET_LINK_LIBRARIES(disk_full-test pg_wrapper_test_base)
-
-ADD_YB_TEST(sequence_utility-itest)
-YB_TEST_TARGET_LINK_LIBRARIES(sequence_utility-itest pg_wrapper_test_base)
-
-ADD_YB_TEST(upgrade-tests/ysql_ddl_whitelist-test)
-YB_TEST_TARGET_LINK_LIBRARIES(upgrade-tests/ysql_ddl_whitelist-test pg_wrapper_test_base)
-
 ADD_YB_CQL_TEST(cql-index-test)
 ADD_YB_CQL_TEST(cql-packed-row-test)
 ADD_YB_CQL_TEST(cql-tablet-split-test)
@@ -334,7 +322,16 @@ ADD_YB_CQL_TEST(cql_geo_transactions-test)
 ADD_YB_CQL_TEST(external_mini_cluster_secure_test)
 ADD_YB_CQL_TEST(tablet_limits_integration_test)
 
-ADD_YB_TEST(documentdb/documentdb_test)
-YB_TEST_TARGET_LINK_LIBRARIES(documentdb/documentdb_test pg_wrapper_test_base)
+function(ADD_YB_PG_TEST TEST_NAME)
+  ADD_YB_TEST(${TEST_NAME})
+  YB_TEST_TARGET_LINK_LIBRARIES(${TEST_NAME} pg_wrapper_test_base)
+endfunction()
+
+ADD_YB_PG_TEST(async_writes-test)
+ADD_YB_PG_TEST(disk_full-test)
+ADD_YB_PG_TEST(documentdb/documentdb_test)
+ADD_YB_PG_TEST(minicluster-snapshot-test)
+ADD_YB_PG_TEST(sequence_utility-itest)
+ADD_YB_PG_TEST(upgrade-tests/ysql_ddl_whitelist-test)
 
 set(YB_TEST_LINK_LIBS ${YB_TEST_LINK_LIBS_SAVED})
diff --git a/src/yb/integration-tests/async_writes-test.cc b/src/yb/integration-tests/async_writes-test.cc
new file mode 100644
index 0000000000..4207975d70
--- /dev/null
+++ b/src/yb/integration-tests/async_writes-test.cc
@@ -0,0 +1,614 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License. You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/consensus/log.h"
+#include "yb/consensus/raft_consensus.h"
+#include "yb/tablet/tablet_peer.h"
+#include "yb/tablet/tablet.h"
+#include "yb/tablet/transaction_participant.h"
+#include "yb/tserver/mini_tablet_server.h"
+#include "yb/tserver/tablet_server.h"
+#include "yb/util/async_util.h"
+#include "yb/util/backoff_waiter.h"
+#include "yb/util/logging_test_util.h"
+#include "yb/util/scope_exit.h"
+#include "yb/util/sync_point.h"
+#include "yb/util/test_thread_holder.h"
+#include "yb/yql/pgwrapper/pg_mini_test_base.h"
+
+DECLARE_bool(enable_load_balancing);
+DECLARE_bool(TEST_do_not_replicate_async_writes);
+DECLARE_bool(use_create_table_leader_hint);
+DECLARE_bool(yb_enable_read_committed_isolation);
+DECLARE_bool(ysql_enable_async_writes);
+DECLARE_double(leader_failure_max_missed_heartbeat_periods);
+DECLARE_double(transaction_max_missed_heartbeat_periods);
+DECLARE_int32(raft_heartbeat_interval_ms);
+DECLARE_uint64(max_clock_skew_usec);
+
+namespace yb {
+
+constexpr auto kTableName = "tbl1";
+const auto kSelectAllStmt = Format("SELECT * FROM $0 ORDER BY key", kTableName);
+
+class YSqlAsyncWriteTest : public pgwrapper::PgMiniTestBase {
+ public:
+  void SetUp() override {
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_yb_enable_read_committed_isolation) = true;
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_ysql_enable_async_writes) = true;
+
+    // These tests stepdown the leader, so we need to disable load balancing.
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_enable_load_balancing) = false;
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_use_create_table_leader_hint) = false;
+
+    TEST_SETUP_SUPER(pgwrapper::PgMiniTestBase);
+    conn_ = std::make_unique<pgwrapper::PGConn>(ASSERT_RESULT(Connect()));
+  }
+
+  size_t NumMasters() override { return 3; }
+
+  size_t NumTabletServers() override { return 3; }
+
+  Result<TabletId> GetTabletId(const std::string& table_name = kTableName) {
+    auto tablets = VERIFY_RESULT(
+        ListTabletsForTableName(cluster_.get(), table_name, ListPeersFilter::kLeaders));
+    SCHECK_EQ(tablets.size(), 1, IllegalState, "Expected 1 tablet");
+    return tablets.front()->tablet_id();
+  }
+
+  size_t GetLeaderIdx(const TabletId& tablet_id) {
+    size_t leader_idx;
+    GetLeaderForTablet(cluster_.get(), tablet_id, &leader_idx);
+    return leader_idx;
+  }
+
+  Status StepDown(size_t leader_idx, size_t new_leader_idx, TabletId tablet_id) {
+    LOG(INFO) << "StepDown leader_idx: " << leader_idx << " new_leader_idx: " << new_leader_idx
+              << " tablet_id: " << tablet_id;
+    if (leader_idx == new_leader_idx) {
+      return Status::OK();
+    }
+
+    auto leader_peer = VERIFY_RESULT(GetLeaderPeerForTablet(cluster_.get(), tablet_id));
+    SCHECK_EQ(
+        leader_peer->permanent_uuid(),
+        cluster_->mini_tablet_server(leader_idx)->server()->permanent_uuid(), IllegalState,
+        "Unexpected leader peer");
+
+    auto leader_consensus = VERIFY_RESULT(leader_peer->GetRaftConsensus());
+    auto leader_op_id = VERIFY_RESULT(leader_consensus->GetLastOpId(consensus::COMMITTED_OPID));
+    auto new_leader_peer = VERIFY_RESULT(cluster_->mini_tablet_server(new_leader_idx)
+                                             ->server()
+                                             ->tablet_peer_lookup()
+                                             ->GetServingTablet(tablet_id));
+    auto new_leader_consensus = VERIFY_RESULT(new_leader_peer->GetRaftConsensus());
+
+    RETURN_NOT_OK(LoggedWaitFor(
+        [new_leader_consensus, leader_op_id]() -> Result<bool> {
+          return VERIFY_RESULT(new_leader_consensus->GetLastOpId(consensus::RECEIVED_OPID)) >=
+                 leader_op_id;
+        },
+        30s,
+        Format(
+            "Wait for peer $0 to catch up with leader $1. Op id: $2", new_leader_idx, leader_idx,
+            leader_op_id)));
+
+    RETURN_NOT_OK(yb::StepDown(
+        leader_peer, cluster_->mini_tablet_server(new_leader_idx)->server()->permanent_uuid(),
+        ForceStepDown::kTrue));
+
+    return LoggedWaitFor(
+        [this, new_leader_idx, tablet_id]() -> Result<bool> {
+          return GetLeaderIdx(tablet_id) == new_leader_idx;
+        },
+        30s, Format("Wait for tablet $0 leader to be $1", tablet_id, new_leader_idx));
+  }
+
+  Result<size_t> WaitForNewTabletLeader(const std::string& tablet_id, size_t old_leader_idx) {
+    size_t new_leader_idx;
+    RETURN_NOT_OK(LoggedWaitFor(
+        [this, tablet_id, &old_leader_idx, &new_leader_idx]() -> Result<bool> {
+          for (size_t i = 0; i < cluster_->num_tablet_servers(); i++) {
+            if (i == old_leader_idx) {
+              // Old leader is stuck so cannot be queried.
+              continue;
+            }
+            if (cluster_->mini_tablet_server(i)->server()->LeaderAndReady(tablet_id)) {
+              new_leader_idx = i;
+              return true;
+            }
+          }
+          return false;
+        },
+        30s, "Leader election"));
+
+    return new_leader_idx;
+  }
+
+  Status ResolveAndFlushTablet(size_t idx, TabletId tablet_id) {
+    auto leader_peer = VERIFY_RESULT(GetLeaderPeerForTablet(cluster_.get(), tablet_id));
+    auto leader_tablet = VERIFY_RESULT(leader_peer->shared_tablet());
+    auto now_ht = VERIFY_RESULT(leader_tablet->SafeTime());
+
+    auto tablet_peer = cluster_->GetTabletManager(idx)->LookupTablet(tablet_id);
+    auto tablet = VERIFY_RESULT(tablet_peer->shared_tablet());
+
+    RETURN_NOT_OK(
+        tablet->transaction_participant()->ResolveIntents(now_ht, CoarseTimePoint::max()));
+
+    auto log = VERIFY_RESULT(tablet_peer->GetRaftConsensus())->log();
+    RETURN_NOT_OK(log->WaitUntilAllFlushed());
+    RETURN_NOT_OK(tablet->Flush(tablet::FlushMode::kSync));
+    return Status::OK();
+  }
+
+  Status ValidateData(std::string expected_all_as_string) {
+    auto table_data = VERIFY_RESULT(conn_->FetchAllAsString(kSelectAllStmt));
+    SCHECK_EQ(table_data, expected_all_as_string, IllegalState, "Unexpected data in table");
+
+    return Status::OK();
+  }
+
+  std::string DumpTablet(size_t idx, TabletId tablet_id) {
+    return cluster_->GetTabletManager(idx)
+        ->LookupTablet(tablet_id)
+        ->shared_tablet_maybe_null()
+        ->TEST_DocDBDumpStr();
+  }
+
+  // Returns the leader index.
+  Result<size_t> PrepareToBreakConnectivity(TabletId tablet_id) {
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_transaction_max_missed_heartbeat_periods) = 100;
+
+    // Pg is running on tserver 0, so move the leader to tserver 1, so that we can break
+    // connectivity to it.
+    const size_t old_leader_idx = 1;
+    RETURN_NOT_OK(StepDown(GetLeaderIdx(tablet_id), old_leader_idx, tablet_id));
+    return old_leader_idx;
+  }
+
+  void LeaderStepDownAfterWriteAckTest(bool perform_read);
+  void LeaderStepDownBeforeWriteAckTest(bool use_pk);
+
+  std::unique_ptr<pgwrapper::PGConn> conn_;
+};
+
+// Make sure async writes are performed for all transactional writes, and not for non-transactional
+// writes.
+TEST_F(YSqlAsyncWriteTest, SimpleCRUD) {
+  google::SetVLOGLevel("write_query*", 2);
+  auto pattern_count = StringWaiterLogSink("Performing Async write");
+  constexpr auto create_table = "CREATE TABLE $0 (key INT PRIMARY KEY, value TEXT)";
+  constexpr auto insert_query = "INSERT INTO $0 VALUES ($1, 'v$1')";
+  constexpr auto update_query = "UPDATE $0 SET value = 'v$2' WHERE key = $1";
+  constexpr auto delete_query = "DELETE FROM $0 WHERE key = $1";
+  constexpr auto select_all_query = "SELECT * FROM $0";
+
+  // Creating a table should result in a few async writes to pg catalog tables.
+  ASSERT_OK(conn_->ExecuteFormat(create_table, kTableName));
+  auto expected_event_count = pattern_count.GetEventCount();
+  ASSERT_GT(expected_event_count, 0);
+
+  int row_count = 0;
+  // Non transactional writes should not result in async writes.
+  ASSERT_OK(conn_->ExecuteFormat(insert_query, kTableName, row_count++));
+  ASSERT_EQ(pattern_count.GetEventCount(), expected_event_count);
+
+  // A SELECT statement should not result in async writes.
+  auto tbl1_rows = ASSERT_RESULT(conn_->FetchAllAsString(Format(select_all_query, kTableName)));
+  ASSERT_EQ(tbl1_rows, "0, v0");
+  ASSERT_EQ(pattern_count.GetEventCount(), expected_event_count);
+
+  // Inserting rows in a transaction should result in async writes.
+  ASSERT_OK(conn_->Execute("BEGIN"));
+  for (int i = 0; i < 10; ++i) {
+    ASSERT_OK(conn_->ExecuteFormat(insert_query, kTableName, row_count++));
+    expected_event_count++;
+  }
+  ASSERT_EQ(pattern_count.GetEventCount(), expected_event_count);
+  ASSERT_OK(conn_->CommitTransaction());
+
+  // Updating rows without a transaction should not result in async writes.
+  ASSERT_OK(conn_->ExecuteFormat(update_query, kTableName, 0, 0));
+  ASSERT_EQ(pattern_count.GetEventCount(), expected_event_count);
+
+  // Updating rows in a transaction should result in async writes.
+  ASSERT_OK(conn_->Execute("BEGIN"));
+  for (int i = 0; i < row_count; ++i) {
+    ASSERT_OK(conn_->ExecuteFormat(update_query, kTableName, i, i + 10));
+    expected_event_count++;
+  }
+  ASSERT_EQ(pattern_count.GetEventCount(), expected_event_count);
+  ASSERT_OK(conn_->CommitTransaction());
+
+  // Deleting rows without a transaction should not result in async writes.
+  ASSERT_OK(conn_->ExecuteFormat(delete_query, kTableName, 0));
+  ASSERT_EQ(pattern_count.GetEventCount(), expected_event_count);
+
+  // Deleting rows in a transaction should result in async writes.
+  ASSERT_OK(conn_->Execute("BEGIN"));
+  for (int i = 1; i < row_count; ++i) {
+    ASSERT_OK(conn_->ExecuteFormat(delete_query, kTableName, i));
+    expected_event_count++;
+  }
+  ASSERT_EQ(pattern_count.GetEventCount(), expected_event_count);
+  ASSERT_OK(conn_->CommitTransaction());
+}
+
+// Make sure the transaction aborts if the leader steps down after the async write operation is
+// acked to client, but before it is replicated to followers.
+TEST_F(YSqlAsyncWriteTest, LeaderStepDownAfterWriteAck) {
+  ASSERT_NO_FATALS(LeaderStepDownAfterWriteAckTest(/* perform_read */ false));
+}
+
+TEST_F(YSqlAsyncWriteTest, LeaderStepDownAfterWriteAckWithRead) {
+  ASSERT_NO_FATALS(LeaderStepDownAfterWriteAckTest(/* perform_read */ true));
+}
+
+void YSqlAsyncWriteTest::LeaderStepDownAfterWriteAckTest(bool perform_read) {
+  constexpr auto create_table =
+      "CREATE TABLE $0 (key INT PRIMARY KEY, value TEXT) SPLIT INTO 1 TABLETS";
+  ASSERT_OK(conn_->ExecuteFormat(create_table, kTableName));
+
+  auto tablet_id = ASSERT_RESULT(GetTabletId());
+
+  const size_t old_leader_idx = ASSERT_RESULT(PrepareToBreakConnectivity(tablet_id));
+
+  // Block the WriteOperation such that the WAL is not replicated.
+  auto sync_point = SyncPoint::GetInstance();
+  sync_point->LoadDependency({
+      {"LeaderStepDownAfterWriteAck::LeaderConnectivityBroken", "WriteQuery::AfterCallbackInvoke"},
+  });
+  sync_point->EnableProcessing();
+
+  ASSERT_OK(conn_->Execute("BEGIN"));
+  ASSERT_OK(conn_->ExecuteFormat("INSERT INTO $0 VALUES (1, 'A')", kTableName));
+  // Client has received the async write ack, but it is not yet replicated to followers.
+
+  ASSERT_OK(BreakConnectivityWithAll(cluster_.get(), old_leader_idx));
+  TEST_SYNC_POINT("LeaderStepDownAfterWriteAck::LeaderConnectivityBroken");
+
+  // Wait for a new leader to be elected.
+  size_t new_leader_idx = ASSERT_RESULT(WaitForNewTabletLeader(tablet_id, old_leader_idx));
+
+  // Bring back the old leader.
+  ASSERT_OK(SetupConnectivityWithAll(cluster_.get(), old_leader_idx));
+
+  // We should not be able to perform further reads, or commit the transaction.
+  if (perform_read) {
+    ASSERT_NOK(
+        conn_->FetchRow<std::string>(Format("SELECT value FROM $0 WHERE key = 1", kTableName)));
+    // COMMIT of a failed transaction internally performs a ROLLBACK in pg.
+    ASSERT_OK(conn_->CommitTransaction());
+  } else {
+    ASSERT_NOK(conn_->CommitTransaction());
+  }
+
+  // Reset the connection and make sure the transaction was aborted.
+  conn_ = std::make_unique<pgwrapper::PGConn>(ASSERT_RESULT(Connect()));
+  auto row_count = ASSERT_RESULT(
+      conn_->FetchRow<int64_t>(Format("SELECT COUNT(*) FROM $0 WHERE key = 1", kTableName)));
+  ASSERT_EQ(row_count, 0);
+
+  // Go back to the old leader and make sure aborted data is not visible.
+  ASSERT_OK(StepDown(new_leader_idx, old_leader_idx, tablet_id));
+
+  row_count = ASSERT_RESULT(
+      conn_->FetchRow<int64_t>(Format("SELECT COUNT(*) FROM $0 WHERE key = 1", kTableName)));
+  ASSERT_EQ(row_count, 0);
+}
+
+// If the leader steps down before the async write operation is acked to client, make sure the
+// client can retry on the new leader without errors.
+TEST_F(YSqlAsyncWriteTest, LeaderStepDownBeforeWriteAck) {
+  ASSERT_NO_FATALS(LeaderStepDownBeforeWriteAckTest(/* use_pk */ false));
+}
+
+TEST_F(YSqlAsyncWriteTest, LeaderStepDownBeforeWriteAckWithPK) {
+  ASSERT_NO_FATALS(LeaderStepDownBeforeWriteAckTest(/* use_pk */ true));
+}
+
+void YSqlAsyncWriteTest::LeaderStepDownBeforeWriteAckTest(bool use_pk) {
+  const auto create_table = Format(
+      "CREATE TABLE $0 (key INT $1, value TEXT) SPLIT INTO 1 TABLETS", kTableName,
+      use_pk ? "PRIMARY KEY" : "");
+  ASSERT_OK(conn_->Execute(create_table));
+
+  auto tablet_id = ASSERT_RESULT(GetTabletId());
+
+  const size_t old_leader_idx = ASSERT_RESULT(PrepareToBreakConnectivity(tablet_id));
+
+  auto sync_point = SyncPoint::GetInstance();
+  sync_point->LoadDependency({
+      {"WriteQuery::BeforeCallbackInvoke",
+       "LeaderStepDownBeforeWriteAck::LeaderConnectivityBroken1"},
+      {"LeaderStepDownBeforeWriteAck::LeaderConnectivityBroken2",
+       "WriteQuery::AfterCallbackInvoke"},
+  });
+  bool failed_write_once = false;
+  sync_point->SetCallBack("WriteQuery::SetCallbackStatus", [&failed_write_once](void* data) {
+    if (!failed_write_once) {
+      failed_write_once = true;
+      *static_cast<Status*>(data) = STATUS(Aborted, "Simulated failure after DoReplicated");
+    }
+  });
+
+  sync_point->EnableProcessing();
+
+  ASSERT_OK(conn_->Execute("BEGIN"));
+  TestThreadHolder thread_holder;
+  thread_holder.AddThread(
+      [this]() { ASSERT_OK(conn_->ExecuteFormat("INSERT INTO $0 VALUES (1, 'A')", kTableName)); });
+
+  TEST_SYNC_POINT("LeaderStepDownBeforeWriteAck::LeaderConnectivityBroken1");
+  ASSERT_OK(BreakConnectivityWithAll(cluster_.get(), old_leader_idx));
+  TEST_SYNC_POINT("LeaderStepDownBeforeWriteAck::LeaderConnectivityBroken2");
+
+  size_t new_leader_idx = ASSERT_RESULT(WaitForNewTabletLeader(tablet_id, old_leader_idx));
+
+  // Client should have retried the write operation on the new leader.
+  thread_holder.JoinAll();
+  ASSERT_OK(SetupConnectivityWithAll(cluster_.get(), old_leader_idx));
+
+  const auto expected_value = "1, A";
+  ASSERT_OK(ValidateData(expected_value));
+
+  ASSERT_OK(conn_->CommitTransaction());
+  ASSERT_OK(ValidateData(expected_value));
+
+  // Go back to the old leader and make sure data is still visible.
+  ASSERT_OK(StepDown(new_leader_idx, old_leader_idx, tablet_id));
+
+  ASSERT_OK(ValidateData(expected_value));
+
+  // Even after a full flush of the WAL, intents and regular DB the same data should be visible.
+  ASSERT_OK(ResolveAndFlushTablet(old_leader_idx, tablet_id));
+
+  ASSERT_OK(ValidateData(expected_value));
+}
+
+// Make sure there cannot be any situation where a intent that was written but not replicated is
+// visible, even if the transaction is committed.
+// To simulate this we have Client A performing a non-idempotent write, such that the intent written
+// to the original leader is different from the intent written to the new leader.
+// This is done using a statement block with a unique violation error, that is handled with a
+// different write, and using another Client B to insert the dup key at the right moment.
+// In the diagram below, Peer A gets both a (1, A) and (1, B) intent, with both transactions
+// committing.
+// This works because pg picks the read time for the writes causing a write conflict error that
+// aborts the sub transaction.
+//
+// Time flows downwards, with important marked with (T1), (T2), etc.
+//
+// +--------+               +--------+
+// |Client A|               |Client B|             Peer A                 Peer B            Peer C
+// +----+---+               +----+---+                |                     |                 |
+//      v                        |                    |                     |                 |
+//    BEGIN                      |                (Leader)             (Follower)        (Follower)
+//      |                        |                    |                     |                 |
+//      |                        |                    |                     |                 |
+//      |                        |                    |                     |                 |
+//      v                        |                    |                     |                 |
+// INSERT (1, A);                |                    |                     |                 |
+//   WHEN unique_violation -(T1)-+--INSERT(1,A)------>|                     |                 |
+//   INSERT (2, A);              |                    |                     |                 |
+//           | ^ |^ |            |           Insert to intentsDB(1,A)       |                 |
+//       |   | | || |            |     X<---Ack-------+                     |                 |
+//       |   | | || |            |                    +-WAL(1,A)->X         |                 |
+//       |   | | || |            |                    +-WAL(1,A)------------+----->X          |
+//       |   | | || |            |                    |                     |                 |
+//       |   | | || |            |                    |                     |                 |
+//       |   | | || |            |                    |             (T2)(Leader)              |
+//       |   | | || |            v                    |                     |                 |
+//       |   | | || |          BEGIN                  |                     |                 |
+//       |   | | || |            |                    |                     |                 |
+//       |   | | || |            |                    |                     |                 |
+//       |   | | || |            v                    |                     |                 |
+//       |   | | || | INSERT (1, B); --(T3)-----------+----INSERT(1,B)----->|                 |
+//       |   | | || |            |                    |                     |                 |
+//       |   | | || |            |                    |           Insert to intentsDB(1,B)    |
+//       |   | | || |            | <---(T4)-----------+---Ack---------------+                 |
+//       |   | | || |            v                    |                     +-----WAL(1,B)--->|
+//       |   | | || |         COMMIT                  |                     |                 |
+//       |   | | || |          (T5)                   |                     |                 |
+//       |   | | || |                                 |                     |                 |
+//       |   | | || |                                 |                     |                 |
+//       |   | | || |                                 |                     |                 |
+//       |   | | || +-----(T6)---------INSERT(1,A)----+-------------------->|                 |
+//       |   | | ||                                   |                     |                 |
+//       |   | | |+(T7)-conflicts with committed-transaction----------------+                 |
+//       |   | | |                                    |                     |                 |
+//       |   | | |                                    |                     |                 |
+//       |   | | +--------(T8)---------INSERT(1,A)----+-------------------->|                 |
+//       |   | |                                      |                     |                 |
+//       |   | +-----(T9)-unique_violation------------+---------------------+                 |
+//       |   |                                        |                     |                 |
+//       |   |                                        |                     |                 |
+//       |   +----(T1ad0)-----------INSERT(2,A)---------+----------> Insert to intentsDB(2,A)   |
+//       |                                            |                     +-------WAL(2,A)->|
+//       |<--(T11)--------Ack-------------------------+---------------------+                 |
+//       |                                            |                     |                 |
+//       v                                       (Follower)                 |                 |
+//    COMMIT                                          |<------WAL(1,B)------+                 |
+//    (T12)                                           |                     |                 |
+//                                                    |<------WAL(2,A)------+                 |
+//                                                    |                     |                 |
+//                                                    |                     |                 |
+//                                           (T13)(Leader)             (Follower)             |
+//                                                    |                     |                 |
+//                                                    |                     |                 |
+//                                                  (T14)                   |                 |
+//                                             Intent (1,A) should
+//                                             not be visible
+//
+TEST_F(YSqlAsyncWriteTest, FailedInsertOnConflict) {
+  constexpr auto create_table =
+      "CREATE TABLE $0 (key INT PRIMARY KEY, value TEXT) SPLIT INTO 1 TABLETS";
+  ASSERT_OK(conn_->ExecuteFormat(create_table, kTableName));
+
+  auto tablet_id = ASSERT_RESULT(GetTabletId());
+
+  const size_t old_leader_idx = ASSERT_RESULT(PrepareToBreakConnectivity(tablet_id));
+
+  auto sync_point = SyncPoint::GetInstance();
+  sync_point->LoadDependency(
+      {{"WriteQuery::BeforeCallbackInvoke", "FailedInsertOnConflict::LeaderConnectivityBroken1"},
+       {"FailedInsertOnConflict::LeaderConnectivityBroken2", "WriteQuery::AfterCallbackInvoke"},
+       {"FailedInsertOnConflict::Client2TxnCompleted",
+        "FailedInsertOnConflict::SecondWriteAttempt"}});
+
+  bool is_first_write = true;
+  sync_point->SetCallBack("WriteQuery::SetCallbackStatus", [&is_first_write](void* data) {
+    if (is_first_write) {
+      is_first_write = false;
+      // Simulate a network failure from the first write so that the client can retry it.
+      *static_cast<Status*>(data) = STATUS(Aborted, "Simulated failure after DoReplicated");
+    }
+  });
+
+  int async_write_attempt_num = 0;
+  sync_point->SetCallBack(
+      "TabletServiceImpl::PerformWrite", [&async_write_attempt_num](void* data) {
+        async_write_attempt_num++;
+        auto req = static_cast<tserver::WriteRequestPB*>(data);
+        if (!req->use_async_write()) {
+          return;
+        }
+        if (async_write_attempt_num == 2) {
+          // Block the retry attempt so that the other client can insert (1,'B').
+          TEST_SYNC_POINT("FailedInsertOnConflict::SecondWriteAttempt");
+        }
+      });
+
+  sync_point->EnableProcessing();
+
+  TestThreadHolder thread_holder;
+  auto se = ScopeExit([&sync_point] {
+    sync_point->DisableProcessing();
+    sync_point->ClearAllCallBacks();
+  });
+
+  ASSERT_OK(conn_->Execute("BEGIN TRANSACTION"));
+  thread_holder.AddThread([this]() {
+    ASSERT_OK(conn_->ExecuteFormat(
+        R"(DO $$$$
+BEGIN
+  INSERT INTO $0 VALUES (1, 'A');
+EXCEPTION
+  WHEN unique_violation THEN
+    INSERT INTO $0 VALUES (2, 'A');
+END $$$$;)",
+        kTableName));
+  });
+
+  TEST_SYNC_POINT("FailedInsertOnConflict::LeaderConnectivityBroken1");
+  ASSERT_OK(BreakConnectivityWithAll(cluster_.get(), old_leader_idx));
+  TEST_SYNC_POINT("FailedInsertOnConflict::LeaderConnectivityBroken2");
+
+  size_t new_leader_idx;
+  ASSERT_OK(LoggedWaitFor(
+      [this, tablet_id, &old_leader_idx, &new_leader_idx]() -> Result<bool> {
+        for (size_t i = 0; i < cluster_->num_tablet_servers(); i++) {
+          if (i == old_leader_idx) {
+            // Old leader is stuck so cannot be queried.
+            continue;
+          }
+          if (cluster_->mini_tablet_server(i)->server()->LeaderAndReady(tablet_id)) {
+            new_leader_idx = i;
+            return true;
+          }
+        }
+        return false;
+      },
+      30s, "Leader election"));
+
+  ASSERT_OK(SetupConnectivityWithAll(cluster_.get(), old_leader_idx));
+
+  auto conn2 = std::make_unique<pgwrapper::PGConn>(ASSERT_RESULT(Connect()));
+  ASSERT_OK(conn2->Execute("BEGIN TRANSACTION"));
+  ASSERT_OK(conn2->ExecuteFormat("INSERT INTO $0 VALUES (1, 'B')", kTableName));
+  ASSERT_OK(conn2->CommitTransaction());
+
+  TEST_SYNC_POINT("FailedInsertOnConflict::Client2TxnCompleted");
+  thread_holder.JoinAll();
+
+  ASSERT_OK(conn_->CommitTransaction());
+
+  // Validity checks.
+  const auto expected_value = "1, B; 2, A";
+  ASSERT_OK(ValidateData(expected_value));
+
+  // Make sure the same data is visible on the old leader.
+  ASSERT_OK(StepDown(new_leader_idx, old_leader_idx, tablet_id));
+
+  ASSERT_OK(ValidateData(expected_value));
+
+  // Even after a full flush of the WAL, intents and regular DB the (1, 'A') intent should not
+  // become visible.
+  ASSERT_OK(ResolveAndFlushTablet(old_leader_idx, tablet_id));
+
+  LOG(INFO) << "Temp Leader Dump:\n"
+            << DumpTablet(new_leader_idx, tablet_id) << "\nOld Leader Dump:\n"
+            << DumpTablet(old_leader_idx, tablet_id);
+  ASSERT_OK(ValidateData(expected_value));
+}
+
+// Make sure async writes are not blocked by follower network delay, but reads are blocked by the
+// async writes.
+TEST_F(YSqlAsyncWriteTest, ReadsBlockedByAsyncWrites) {
+  ASSERT_OK(
+      conn_->ExecuteFormat("CREATE TABLE $0 (a INT PRIMARY KEY) SPLIT INTO 1 TABLETS", kTableName));
+  ASSERT_OK(conn_->Execute("BEGIN TRANSACTION"));
+
+  auto follower_peers = ASSERT_RESULT(
+      ListTabletPeersForTableName(cluster_.get(), kTableName, ListPeersFilter::kNonLeaders));
+  ASSERT_EQ(follower_peers.size(), 2);
+
+  const auto delay_duration = 30s;
+  for (auto& peer : follower_peers) {
+    ASSERT_RESULT(peer->GetRaftConsensus())->TEST_DelayUpdate(delay_duration);
+  }
+
+  // Async wite should not be blocked by the delay.
+  const auto insert_start_time = CoarseMonoClock::now();
+  ASSERT_OK(conn_->ExecuteFormat("INSERT INTO $0 VALUES (1)", kTableName));
+  auto now = CoarseMonoClock::now();
+  LOG(INFO) << "Insert time: " << MonoDelta(now - insert_start_time);
+  ASSERT_LT(now - insert_start_time, 5s);
+
+  Synchronizer sync;
+  TestThreadHolder thread_holder;
+  std::string result;
+  thread_holder.AddThread([this, callback = sync.AsStdStatusCallback(), &result]() {
+    result = ASSERT_RESULT(conn_->FetchAllAsString(Format("SELECT * FROM $0", kTableName)));
+    callback(Status::OK());
+  });
+
+  // Read should be blocked by the delay.
+  ASSERT_NOK(sync.WaitFor(10s));
+
+  for (auto& peer : follower_peers) {
+    ASSERT_RESULT(peer->GetRaftConsensus())->TEST_DelayUpdate(0s);
+  }
+
+  // Read should be unblocked.
+  ASSERT_OK(sync.WaitFor(delay_duration + 10s));
+  ASSERT_EQ(result, "1");
+
+  ASSERT_OK(conn_->CommitTransaction());
+
+  result = ASSERT_RESULT(conn_->FetchAllAsString(Format("SELECT * FROM $0", kTableName)));
+  ASSERT_EQ(result, "1");
+}
+
+}  // namespace yb
diff --git a/src/yb/integration-tests/mini_cluster.cc b/src/yb/integration-tests/mini_cluster.cc
index 37575a78bf..b61d7d2f72 100644
--- a/src/yb/integration-tests/mini_cluster.cc
+++ b/src/yb/integration-tests/mini_cluster.cc
@@ -1493,14 +1493,14 @@ Status StartAllMasters(MiniCluster* cluster) {
   return Status::OK();
 }
 
-void SetupConnectivity(
+void SetupConnectivityWith(
     rpc::Messenger* messenger, const IpAddress& address, Connectivity connectivity) {
   switch (connectivity) {
     case Connectivity::kOn:
-      messenger->RestoreConnectivityTo(address);
+      messenger->RestoreConnectivityWith(address);
       return;
     case Connectivity::kOff:
-      messenger->BreakConnectivityTo(address);
+      messenger->BreakConnectivityWith(address);
       return;
   }
   FATAL_INVALID_ENUM_VALUE(Connectivity, connectivity);
@@ -1514,11 +1514,11 @@ Status SetupConnectivity(
       // TEST_RpcAddress is 1-indexed; we expect from_idx/to_idx to be 0-indexed.
       auto address = VERIFY_RESULT(HostToAddress(TEST_RpcAddress(to_idx + 1, type)));
       if (from_idx < cluster->num_masters()) {
-        SetupConnectivity(
+        SetupConnectivityWith(
             cluster->mini_master(from_idx)->master()->messenger(), address, connectivity);
       }
       if (from_idx < cluster->num_tablet_servers()) {
-        SetupConnectivity(
+        SetupConnectivityWith(
             cluster->mini_tablet_server(from_idx)->server()->messenger(), address, connectivity);
       }
     }
@@ -1531,6 +1531,22 @@ Status BreakConnectivity(MiniCluster* cluster, size_t idx1, size_t idx2) {
   return SetupConnectivity(cluster, idx1, idx2, Connectivity::kOff);
 }
 
+Status SetupConnectivityWithAll(MiniCluster* cluster, size_t idx, Connectivity connectivity) {
+  const auto max_idx = std::max(cluster->num_masters(), cluster->num_tablet_servers());
+  for (size_t i = 0; i < max_idx; ++i) {
+    if (i == idx) {
+      continue;
+    }
+    RETURN_NOT_OK(SetupConnectivity(cluster, idx, i, connectivity));
+  }
+
+  return Status::OK();
+}
+
+Status BreakConnectivityWithAll(MiniCluster* cluster, size_t idx) {
+  return SetupConnectivityWithAll(cluster, idx, Connectivity::kOff);
+}
+
 Result<size_t> ServerWithLeaders(MiniCluster* cluster) {
   for (size_t i = 0; i != cluster->num_tablet_servers(); ++i) {
     auto* server = cluster->mini_tablet_server(i)->server();
diff --git a/src/yb/integration-tests/mini_cluster.h b/src/yb/integration-tests/mini_cluster.h
index 5bbe0fdba7..374f6ff2fb 100644
--- a/src/yb/integration-tests/mini_cluster.h
+++ b/src/yb/integration-tests/mini_cluster.h
@@ -480,6 +480,11 @@ YB_DEFINE_ENUM(Connectivity, (kOn)(kOff));
 Status BreakConnectivity(MiniCluster* cluster, size_t idx1, size_t idx2);
 Status SetupConnectivity(
     MiniCluster* cluster, size_t idx1, size_t idx2, Connectivity connectivity);
+
+Status BreakConnectivityWithAll(MiniCluster* cluster, size_t idx);
+Status SetupConnectivityWithAll(
+    MiniCluster* cluster, size_t idx, Connectivity connectivity = Connectivity::kOn);
+
 Result<size_t> ServerWithLeaders(MiniCluster* cluster);
 
 // Sets FLAGS_rocksdb_compact_flush_rate_limit_bytes_per_sec and also adjusts rate limiter
diff --git a/src/yb/tablet/local_tablet_writer.h b/src/yb/tablet/local_tablet_writer.h
index 422ed8d5ee..365936f906 100644
--- a/src/yb/tablet/local_tablet_writer.h
+++ b/src/yb/tablet/local_tablet_writer.h
@@ -62,6 +62,11 @@ class LocalTabletWriter : public WriteQueryContext {
   Status Write(QLWriteRequestPB* req);
   Status WriteBatch(Batch* batch);
 
+  void RegisterAsyncWrite(const OpId& op_id) override {}
+  void RegisterAsyncWriteCompletion(const OpId& op_id, StdStatusCallback&& callback) override {
+    callback(Status::OK());
+  }
+
  private:
   void Submit(std::unique_ptr<Operation> operation, int64_t term) override;
   Result<HybridTime> ReportReadRestart() override;
diff --git a/src/yb/tablet/operations/write_operation.cc b/src/yb/tablet/operations/write_operation.cc
index 3e37d0b794..724e6f0819 100644
--- a/src/yb/tablet/operations/write_operation.cc
+++ b/src/yb/tablet/operations/write_operation.cc
@@ -39,6 +39,7 @@
 #include "yb/util/debug-util.h"
 #include "yb/util/debug/trace_event.h"
 #include "yb/util/flags.h"
+#include "yb/util/sync_point.h"
 #include "yb/util/trace.h"
 
 DEFINE_test_flag(int32, tablet_inject_latency_on_apply_write_txn_ms, 0,
@@ -70,6 +71,17 @@ Status WriteOperation::DoAborted(const Status& status) {
   return status;
 }
 
+void WriteOperation::SetAsyncWrite(boost::function<void(OpId)> callback) {
+  added_to_leader_callback_ = std::move(callback);
+}
+
+void WriteOperation::AddedAsPending(const TabletPtr& tablet) {
+  if (added_to_leader_callback_) {
+    added_to_leader_callback_(op_id());
+    added_to_leader_callback_ = {};
+  }
+}
+
 // FIXME: Since this is called as a void in a thread-pool callback,
 // it seems pointless to return a Status!
 Status WriteOperation::DoReplicated(int64_t leader_term, Status* complete_status) {
diff --git a/src/yb/tablet/operations/write_operation.h b/src/yb/tablet/operations/write_operation.h
index 76127b7f2a..2c38066773 100644
--- a/src/yb/tablet/operations/write_operation.h
+++ b/src/yb/tablet/operations/write_operation.h
@@ -36,6 +36,8 @@
 #include <string>
 #include <vector>
 
+#include <boost/function.hpp>
+
 #include "yb/tablet/operations/operation.h"
 #include "yb/tablet/operations.messages.h"
 
@@ -67,6 +69,10 @@ class WriteOperation : public OperationBase<OperationType::kWrite, LWWritePB>  {
     return true;
   }
 
+  void SetAsyncWrite(boost::function<void(OpId)> callback);
+
+  void AddedAsPending(const TabletPtr& tablet) override;
+
  private:
   // Executes a Prepare for a write transaction
   //
@@ -99,6 +105,8 @@ class WriteOperation : public OperationBase<OperationType::kWrite, LWWritePB>  {
   Status DoAborted(const Status& status) override;
 
   HybridTime WriteHybridTime() const override;
+
+  boost::function<void(OpId)> added_to_leader_callback_;
 };
 
 }  // namespace tablet
diff --git a/src/yb/tablet/tablet_peer.cc b/src/yb/tablet/tablet_peer.cc
index e3449824fe..09f3f8773b 100644
--- a/src/yb/tablet/tablet_peer.cc
+++ b/src/yb/tablet/tablet_peer.cc
@@ -82,6 +82,7 @@
 #include "yb/tablet/transaction_participant.h"
 #include "yb/tablet/write_query.h"
 
+#include "yb/util/backoff_waiter.h"
 #include "yb/util/fault_injection.h"
 #include "yb/util/format.h"
 #include "yb/util/logging.h"
@@ -411,14 +412,21 @@ Result<HybridTime> TabletPeer::PreparePeerRequest() {
   return tablet_->mvcc_manager()->SafeTime(ht_lease);
 }
 
-Status TabletPeer::MajorityReplicated() {
+Status TabletPeer::MajorityReplicated(const OpId& committed_op_id) {
   auto ht_lease = VERIFY_RESULT(HybridTimeLease(
       /* min_allowed= */ HybridTime::kMin, /* deadline */ CoarseTimePoint::max()));
 
   tablet_->mvcc_manager()->UpdatePropagatedSafeTimeOnLeader(ht_lease);
+
+  NotifyCommitedAsyncWrites(committed_op_id);
   return Status::OK();
 }
 
+void TabletPeer::BecomeReplica() {
+  FailAllAsyncWrites(
+      STATUS_FORMAT(Aborted, "Tablet $0 leader changed during async write", tablet_id()));
+}
+
 void TabletPeer::ChangeConfigReplicated(const RaftConfigPB& config) {
   tablet_->mvcc_manager()->SetLeaderOnlyMode(config.peers_size() == 1);
 }
@@ -540,6 +548,8 @@ void TabletPeer::CompleteShutdown(
 
   VLOG_WITH_PREFIX(1) << "Shut down!";
 
+  FailAllAsyncWrites(STATUS(IllegalState, "Tablet peer is shutting down"));
+
   if (tablet_) {
     tablet_->CompleteShutdown(disable_flush_on_shutdown, abort_ops);
   }
@@ -1868,6 +1878,110 @@ bool TabletPeer::HasSufficientDiskSpaceForWrite() {
   return true;
 }
 
+void TabletPeer::NotifyCommitedAsyncWrites(const OpId& committed_op_id) {
+  if (!committed_op_id) {
+    return;
+  }
+  LOG_IF(DFATAL, committed_op_id < last_known_committed_op_id_.load(std::memory_order_acquire))
+      << "Tablet " << tablet_id() << " committed op id: " << committed_op_id
+      << ", last known committed op id: " << last_known_committed_op_id_;
+  last_known_committed_op_id_.store(committed_op_id, std::memory_order_release);
+
+  std::vector<std::pair<StdStatusCallback, Status>> callbacks;
+  {
+    std::lock_guard lock(async_write_queries_mutex_);
+    auto it = in_flight_async_write_queries_.begin();
+    while (it != in_flight_async_write_queries_.end()) {
+      Status status;
+      if (it->first.term != committed_op_id.term) {
+        // Stale callback from previous term.
+        status = STATUS_FORMAT(
+            IllegalState, "Unexpected tablet $0 term change. New term: $1, expected term: $2",
+            tablet_id(), committed_op_id.term, it->first.term);
+      } else if (it->first.index > committed_op_id.index) {
+        break;
+      }
+
+      for (auto& callback : it->second) {
+        callbacks.emplace_back(std::move(callback), std::move(status));
+      }
+      it = in_flight_async_write_queries_.erase(it);
+    }
+  }
+
+  for (auto& [callback, status] : callbacks) {
+    callback(status);
+  }
+}
+
+void TabletPeer::FailAllAsyncWrites(const Status& status) {
+  std::vector<StdStatusCallback> callbacks;
+  {
+    std::lock_guard lock(async_write_queries_mutex_);
+    for (auto& [_, in_flight_callbacks] : in_flight_async_write_queries_) {
+      MoveCollection(&in_flight_callbacks, &callbacks);
+    }
+    in_flight_async_write_queries_.clear();
+  }
+
+  for (auto& callback : callbacks) {
+    callback(status);
+  }
+}
+
+void TabletPeer::RegisterAsyncWrite(const OpId& op_id) {
+  std::lock_guard lock(async_write_queries_mutex_);
+  DCHECK(
+      in_flight_async_write_queries_.empty() ||
+      in_flight_async_write_queries_.back().first < op_id);
+  in_flight_async_write_queries_.emplace_back(op_id, std::vector<StdStatusCallback>());
+}
+
+void TabletPeer::RegisterAsyncWriteCompletion(const OpId& op_id, StdStatusCallback&& callback) {
+  // If the write is still in flight, add the callback to the list.
+  {
+    std::lock_guard lock(async_write_queries_mutex_);
+    auto it = std::lower_bound(
+        in_flight_async_write_queries_.begin(), in_flight_async_write_queries_.end(), op_id,
+        [](const auto& pair, const OpId& op_id) { return pair.first < op_id; });
+    if (it != in_flight_async_write_queries_.end() && it->first == op_id) {
+      it->second.emplace_back(std::move(callback));
+      return;
+    }
+  }
+
+  // Write is not in progress. Check the term to make sure the write was received by the current
+  // peer.
+  // TODO(#28383): Handle graceful leader moves without failing user queries.
+  auto is_same_term = [this, &op_id]() -> Status {
+    auto committed_op_id = last_known_committed_op_id_.load(std::memory_order_acquire);
+    if (op_id.term == committed_op_id.term && op_id.index <= committed_op_id.index) {
+      return Status::OK();
+    }
+
+    auto consensus = VERIFY_RESULT(GetRaftConsensus());
+    const auto leader_term = consensus->LeaderTerm();
+    SCHECK_FORMAT(
+        leader_term != OpId::kUnknownTerm, Aborted,
+        "Tablet $0 leader changed during async write", tablet_id());
+
+    SCHECK_FORMAT(
+        leader_term == op_id.term, Aborted,
+        "Tablet $0 leader changed during async write. New term: $1, expected term: $2", tablet_id(),
+        leader_term, op_id.term);
+
+    return Status::OK();
+  }();
+
+  Status status;
+
+  if (!is_same_term.ok()) {
+    status = std::move(is_same_term);
+  }
+
+  callback(status);
+}
+
 Status BackfillNamespaceIdIfNeeded(
     tablet::RaftGroupMetadata& metadata, client::YBClient& client) {
   auto namespace_id = metadata.namespace_id();
diff --git a/src/yb/tablet/tablet_peer.h b/src/yb/tablet/tablet_peer.h
index ade6536192..4ae0e70528 100644
--- a/src/yb/tablet/tablet_peer.h
+++ b/src/yb/tablet/tablet_peer.h
@@ -505,6 +505,14 @@ class TabletPeer : public std::enable_shared_from_this<TabletPeer>,
 
   void SetTabletOnDiskSize(size_t total_on_disk_size);
 
+  void NotifyCommitedAsyncWrites(const OpId& committed_op_id) EXCLUDES(async_write_queries_mutex_);
+
+  void FailAllAsyncWrites(const Status& status) EXCLUDES(async_write_queries_mutex_);
+
+  void RegisterAsyncWrite(const OpId& op_id) override;
+  void RegisterAsyncWriteCompletion(const OpId& op_id, StdStatusCallback&& callback)
+      EXCLUDES(async_write_queries_mutex_) override;
+
  protected:
   friend class RefCountedThreadSafe<TabletPeer>;
   friend class TabletPeerTest;
@@ -600,7 +608,8 @@ class TabletPeer : public std::enable_shared_from_this<TabletPeer>,
 
   Result<FixedHybridTimeLease> HybridTimeLease(HybridTime min_allowed, CoarseTimePoint deadline);
   Result<HybridTime> PreparePeerRequest() override;
-  Status MajorityReplicated() override;
+  Status MajorityReplicated(const OpId& committed_op_id) override;
+  void BecomeReplica() override;
   void ChangeConfigReplicated(const consensus::RaftConfigPB& config) override;
   uint64_t NumSSTFiles() override;
   void ListenNumSSTFilesChanged(std::function<void()> listener) override;
@@ -640,6 +649,11 @@ class TabletPeer : public std::enable_shared_from_this<TabletPeer>,
   // FLAGS_data_size_metric_updater_interval_sec seconds.
   std::atomic<size_t> total_on_disk_size_{0};
 
+  std::mutex async_write_queries_mutex_;
+  std::atomic<OpId> last_known_committed_op_id_;
+  std::deque<std::pair<OpId, std::vector<StdStatusCallback>>> in_flight_async_write_queries_
+      GUARDED_BY(async_write_queries_mutex_);
+
   DISALLOW_COPY_AND_ASSIGN(TabletPeer);
 };
 
diff --git a/src/yb/tablet/write_query.cc b/src/yb/tablet/write_query.cc
index ef4b92e9e7..7b681fe48b 100644
--- a/src/yb/tablet/write_query.cc
+++ b/src/yb/tablet/write_query.cc
@@ -273,6 +273,24 @@ void WriteQuery::DoStartSynchronization(const Status& status) {
     return;
   }
 
+  if (client_request_ && client_request_->use_async_write()) {
+    VLOG(2) << "Performing Async write: " << client_request_->ShortDebugString();
+    operation_->SetAsyncWrite(
+        [query = this](OpId opid) -> void {
+          // TODO: Add metrics for async writes.
+          // Query is still pending, but we are ready to invoke the callback.
+
+          query->context_->RegisterAsyncWrite(opid);
+          opid.ToPB(query->response_->mutable_async_write_op_id());
+
+          TEST_SYNC_POINT("WriteQuery::BeforeCallbackInvoke");
+          Status status;
+          TEST_SYNC_POINT_CALLBACK("WriteQuery::SetCallbackStatus", &status);
+          query->InvokeCallback(status);
+          TEST_SYNC_POINT("WriteQuery::AfterCallbackInvoke");
+        });
+  }
+
   TRACE_FUNC();
   ASH_ENABLE_CONCURRENT_UPDATES();
   SET_WAIT_STATUS(OnCpu_Passive);
@@ -379,9 +397,13 @@ void WriteQuery::Cancel(const Status& status) {
 
 void WriteQuery::Complete(const Status& status) {
   Release();
+  InvokeCallback(status);
+}
 
+void WriteQuery::InvokeCallback(const Status& status) {
   if (callback_) {
     callback_(status);
+    callback_ = nullptr;
   }
 }
 
diff --git a/src/yb/tablet/write_query.h b/src/yb/tablet/write_query.h
index a8194a9879..c0808c4a8e 100644
--- a/src/yb/tablet/write_query.h
+++ b/src/yb/tablet/write_query.h
@@ -138,6 +138,8 @@ class WriteQuery {
 
   void Complete(const Status& status);
 
+  void InvokeCallback(const Status& status);
+
   Status InitExecute(ExecuteMode mode);
 
   void ExecuteDone(const Status& status);
diff --git a/src/yb/tablet/write_query_context.h b/src/yb/tablet/write_query_context.h
index 21c2156e8f..c8c15b7a77 100644
--- a/src/yb/tablet/write_query_context.h
+++ b/src/yb/tablet/write_query_context.h
@@ -16,8 +16,12 @@
 #include "yb/common/hybrid_time.h"
 
 #include "yb/tablet/tablet_fwd.h"
+#include "yb/util/status_callback.h"
 
 namespace yb {
+
+struct OpId;
+
 namespace tablet {
 
 class WriteQueryContext {
@@ -26,6 +30,10 @@ class WriteQueryContext {
   virtual void Submit(std::unique_ptr<Operation> operation, int64_t term) = 0;
   virtual Result<HybridTime> ReportReadRestart() = 0;
 
+  virtual void RegisterAsyncWrite(const OpId& async_write_op_id) = 0;
+  virtual void RegisterAsyncWriteCompletion(
+      const OpId& async_write_op_id, StdStatusCallback&& callback) = 0;
+
   virtual ~WriteQueryContext() {}
 };
 
diff --git a/src/yb/tserver/service_util.h b/src/yb/tserver/service_util.h
index 1839759dea..29f0cfaac1 100644
--- a/src/yb/tserver/service_util.h
+++ b/src/yb/tserver/service_util.h
@@ -319,7 +319,7 @@ Status CheckPeerIsLeader(const tablet::TabletPeer& tablet_peer);
 // allow_split_tablet specifies whether to reject requests to tablets which have been already
 // split.
 Status CheckPeerIsReady(
-    const tablet::TabletPeer& tablet_peer, AllowSplitTablet allow_split_tablet);
+  const tablet::TabletPeer& tablet_peer, AllowSplitTablet allow_split_tablet);
 
 Result<std::shared_ptr<tablet::AbstractTablet>> GetTablet(
     TabletPeerLookupIf* tablet_manager, const TabletId& tablet_id,
diff --git a/src/yb/tserver/tablet_service.cc b/src/yb/tserver/tablet_service.cc
index 70b4782ca1..5b15f55356 100644
--- a/src/yb/tserver/tablet_service.cc
+++ b/src/yb/tserver/tablet_service.cc
@@ -2512,6 +2512,7 @@ Status TabletServiceImpl::PerformWrite(
   VLOG(2) << "Received Write RPC: " << req->DebugString();
 
   UpdateClock(*req, server_->Clock());
+  TEST_SYNC_POINT_CALLBACK("TabletServiceImpl::PerformWrite", const_cast<WriteRequestPB*>(req));
 
   auto tablet =
       VERIFY_RESULT(LookupLeaderTablet(server_->tablet_peer_lookup(), req->tablet_id(), resp));
@@ -2621,6 +2622,30 @@ void TabletServiceImpl::Write(const WriteRequestPB* req,
   }
 }
 
+void TabletServiceImpl::WaitForAsyncWrite(
+    const WaitForAsyncWriteRequestPB* req, WaitForAsyncWriteResponsePB* resp,
+    rpc::RpcContext context) {
+  auto callback = [resp, context_ptr = std::make_shared<rpc::RpcContext>(std::move(context))](
+                      const Status& status) {
+    if (!status.ok()) {
+      SetupErrorAndRespond(resp->mutable_error(), status, context_ptr.get());
+      return;
+    }
+    context_ptr->RespondSuccess();
+  };
+
+  // We dont need the leader check here because if the peer gracefully transitioned to a follower
+  // we still want to succeed previously committed async writes received by this peer.
+  auto tablet_result = LookupTabletPeer(server_->tablet_peer_lookup(), req->tablet_id());
+  if (!tablet_result) {
+    callback(tablet_result.status());
+    return;
+  }
+
+  tablet_result->tablet_peer->RegisterAsyncWriteCompletion(
+      OpId::FromPB(req->op_id()), std::move(callback));
+}
+
 void TabletServiceImpl::Read(const ReadRequestPB* req,
                              ReadResponsePB* resp,
                              rpc::RpcContext context) {
diff --git a/src/yb/tserver/tablet_service.h b/src/yb/tserver/tablet_service.h
index 9b4f63f4d7..48796baa37 100644
--- a/src/yb/tserver/tablet_service.h
+++ b/src/yb/tserver/tablet_service.h
@@ -77,6 +77,10 @@ class TabletServiceImpl : public TabletServerServiceIf, public ReadTabletProvide
 
   void Write(const WriteRequestPB* req, WriteResponsePB* resp, rpc::RpcContext context) override;
 
+  void WaitForAsyncWrite(
+      const WaitForAsyncWriteRequestPB* req, WaitForAsyncWriteResponsePB* resp,
+      rpc::RpcContext context) override;
+
   void Read(const ReadRequestPB* req, ReadResponsePB* resp, rpc::RpcContext context) override;
 
   void VerifyTableRowRange(
diff --git a/src/yb/tserver/tserver.proto b/src/yb/tserver/tserver.proto
index 397c439d8d..5e8cc29dbc 100644
--- a/src/yb/tserver/tserver.proto
+++ b/src/yb/tserver/tserver.proto
@@ -37,6 +37,7 @@ option java_package = "org.yb.tserver";
 
 import "yb/common/common.proto";
 import "yb/common/common_types.proto";
+import "yb/common/opid.proto";
 import "yb/common/redis_protocol.proto";
 import "yb/common/ql_protocol.proto";
 import "yb/common/pgsql_protocol.proto";
@@ -102,6 +103,8 @@ message WriteRequestPB {
   reserved 23; // ASH metadata is now passed in RequestHeader PB
 
   optional int64 raft_config_opid_index = 24;
+
+  optional bool use_async_write = 26;
 }
 
 message WriteResponsePB {
@@ -150,8 +153,20 @@ message WriteResponsePB {
 
   // key causing read restart. Present when restart_read_time is.
   optional string restart_read_key = 16;
+
+  // Only set if use_async_write is true.
+  // If this is set, then the client needs to wait for the async write to
+  // complete using WaitForAsyncWrite before committing the transaction.
+  optional OpIdPB async_write_op_id = 17;
+}
+
+message WaitForAsyncWriteRequestPB {
+  required bytes tablet_id = 1;
+  optional OpIdPB op_id = 2;
 }
 
+message WaitForAsyncWriteResponsePB { optional TabletServerErrorPB error = 1; }
+
 // A list tablets request
 message ListTabletsRequestPB {
   optional bool include_user_tablets_only = 1 [ default = false ];
diff --git a/src/yb/tserver/tserver_service.proto b/src/yb/tserver/tserver_service.proto
index 2ef5f1cd11..bc9e1a25e0 100644
--- a/src/yb/tserver/tserver_service.proto
+++ b/src/yb/tserver/tserver_service.proto
@@ -51,6 +51,7 @@ service TabletServerService {
   rpc Write(WriteRequestPB) returns (WriteResponsePB) {
     option (yb.rpc.send_metadata) = true;
   }
+  rpc WaitForAsyncWrite(WaitForAsyncWriteRequestPB) returns (WaitForAsyncWriteResponsePB);
   rpc Read(ReadRequestPB) returns (ReadResponsePB) {
     option (yb.rpc.send_metadata) = true;
   }
diff --git a/src/yb/util/async_util.cc b/src/yb/util/async_util.cc
index c328bf2ecc..c428210893 100644
--- a/src/yb/util/async_util.cc
+++ b/src/yb/util/async_util.cc
@@ -69,6 +69,15 @@ StatusCallback Synchronizer::AsStatusCallback(const std::shared_ptr<Synchronizer
   return Bind(CallStatusCBMaybe, weak_sync);
 }
 
+StdStatusCallback Synchronizer::AsStdStatusCallback(
+    const std::shared_ptr<Synchronizer>& synchronizer) {
+  DCHECK(!synchronizer->assigned_);
+  // No need to set must_wait_ here -- the callback knows whether Synchronizer still exists.
+  return [weak_sync = std::weak_ptr<Synchronizer>(synchronizer)](const Status& status) {
+    CallStatusCBMaybe(weak_sync, status);
+  };
+}
+
 Status Synchronizer::WaitUntil(const std::chrono::steady_clock::time_point& time) {
   std::unique_lock<std::mutex> lock(mutex_);
   auto predicate = [this] { return assigned_; };
diff --git a/src/yb/util/async_util.h b/src/yb/util/async_util.h
index 0e1e91d2aa..0960effa9e 100644
--- a/src/yb/util/async_util.h
+++ b/src/yb/util/async_util.h
@@ -75,6 +75,7 @@ class Synchronizer {
   // This version of AsStatusCallback is for cases when the callback can outlive the synchronizer.
   // The callback holds a weak pointer to the synchronizer.
   static StatusCallback AsStatusCallback(const std::shared_ptr<Synchronizer>& synchronizer);
+  static StdStatusCallback AsStdStatusCallback(const std::shared_ptr<Synchronizer>& synchronizer);
 
   StatusFunctor AsStatusFunctor() {
     return std::bind(&Synchronizer::StatusCB, this, std::placeholders::_1);
diff --git a/src/yb/util/logging_test_util.cc b/src/yb/util/logging_test_util.cc
index 2b0f0c43b6..25cf39dc92 100644
--- a/src/yb/util/logging_test_util.cc
+++ b/src/yb/util/logging_test_util.cc
@@ -24,8 +24,7 @@ Status PatternWaiterLogSink<Pattern>::WaitFor(MonoDelta timeout) {
   constexpr auto kInitialWaitPeriod = 100ms;
   const auto message = Format("$0 '$1'...", kWaitingMessage, pattern_source_);
   LOG(INFO) << message;
-  return ::yb::WaitFor(
-      [this] { return event_occurred_.load(); }, timeout, message, kInitialWaitPeriod);
+  return ::yb::WaitFor([this] { return IsEventOccurred(); }, timeout, message, kInitialWaitPeriod);
 }
 
 template<>
@@ -35,7 +34,7 @@ void PatternWaiterLogSink<std::string>::send(
   auto log_message = ToString(severity, base_filename, line, tm_time, message, message_len);
   if (log_message.find(pattern_to_wait_for_) != std::string::npos &&
       log_message.find(kWaitingMessage) == std::string::npos) {
-    event_occurred_ = true;
+    event_count_++;
   }
 }
 
@@ -46,7 +45,7 @@ void PatternWaiterLogSink<boost::regex>::send(
   auto log_message = ToString(severity, base_filename, line, tm_time, message, message_len);
   if (boost::regex_match(log_message, pattern_to_wait_for_) &&
       log_message.find(kWaitingMessage) == std::string::npos) {
-    event_occurred_ = true;
+    event_count_++;
   }
 }
 
diff --git a/src/yb/util/logging_test_util.h b/src/yb/util/logging_test_util.h
index e38b0b7ce2..bad0e38ce8 100644
--- a/src/yb/util/logging_test_util.h
+++ b/src/yb/util/logging_test_util.h
@@ -74,14 +74,15 @@ class PatternWaiterLogSink : public google::LogSink {
     google::AddLogSink(this);
   }
 
-  // Wait for string_to_wait to occur in log.
+  // Wait for string_to_wait to occur at least once in log.
   Status WaitFor(MonoDelta timeout);
 
   void send(
       google::LogSeverity severity, const char* full_filename, const char* base_filename, int line,
       const struct ::tm* tm_time, const char* message, size_t message_len) override;
 
-  bool IsEventOccurred() { return event_occurred_; }
+  bool IsEventOccurred() { return GetEventCount() > 0; }
+  int64_t GetEventCount() { return event_count_.load(); }
 
   ~PatternWaiterLogSink() override { google::RemoveLogSink(this); }
 
@@ -92,7 +93,7 @@ class PatternWaiterLogSink : public google::LogSink {
   // PatternWaiterLogSink<std::string> this is the same string pattern we are waiting for.
   std::string pattern_source_;
   Pattern pattern_to_wait_for_;
-  std::atomic<bool> event_occurred_{false};
+  std::atomic<int64_t> event_count_{0};
 };
 
 using StringWaiterLogSink = PatternWaiterLogSink<std::string>;
diff --git a/src/yb/yql/pgwrapper/pg_read_time-test.cc b/src/yb/yql/pgwrapper/pg_read_time-test.cc
index d741c54c9c..41a12a0fff 100644
--- a/src/yb/yql/pgwrapper/pg_read_time-test.cc
+++ b/src/yb/yql/pgwrapper/pg_read_time-test.cc
@@ -34,10 +34,11 @@
 #include "yb/yql/pgwrapper/pg_test_utils.h"
 #include "yb/tools/tools_test_utils.h"
 
-DECLARE_bool(yb_enable_read_committed_isolation);
 DECLARE_bool(enable_wait_queues);
-DECLARE_uint64(max_clock_skew_usec);
+DECLARE_bool(yb_enable_read_committed_isolation);
+DECLARE_bool(ysql_enable_async_writes);
 DECLARE_string(ysql_pg_conf_csv);
+DECLARE_uint64(max_clock_skew_usec);
 
 METRIC_DECLARE_counter(picked_read_time_on_docdb);
 
@@ -306,6 +307,9 @@ TEST_F(PgReadTimeTest, CheckReadTimePickingLocation) {
   // latest read point). For each statement, if the new read time for that statement can be picked
   // on docdb, ensure it is.
   ASSERT_OK(conn.StartTransaction(IsolationLevel::READ_COMMITTED));
+  // Disable async writes, since the metrics are only updated after the entire write query including
+  // the quorum commit completes. The client conn wont wait for these until the final commit.
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_ysql_enable_async_writes) = false;
   CheckReadTimePickedOnDocdb(
       [&conn, kTable]() {
         ASSERT_OK(conn.FetchFormat("SELECT * FROM $0 WHERE k=1", kTable));
@@ -332,6 +336,7 @@ TEST_F(PgReadTimeTest, CheckReadTimePickingLocation) {
       }, 2 /* expected_num_picked_read_time_on_doc_db_metric */);
 
   ASSERT_OK(conn.CommitTransaction());
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_ysql_enable_async_writes) = true;
 
   // 10. Pipeline, copy a file to a table by fast-path transation. Only single tserver is involved
   // during copy.
