diff --git a/src/yb/master/master_cluster_service.cc b/src/yb/master/master_cluster_service.cc
index f7b2f8109b..6e0f411497 100644
--- a/src/yb/master/master_cluster_service.cc
+++ b/src/yb/master/master_cluster_service.cc
@@ -245,9 +245,7 @@ class MasterClusterServiceImpl : public MasterServiceBase, public MasterClusterI
       // be invalid. We need to allow the leader to respond to the GetMasterRegistration request so
       // that the client can then invoke DumpSysCatalogEntries and WriteSysCatalogEntry RPCs.
       if (!l.leader_status().ok()) {
-        YB_LOG_EVERY_N_SECS(INFO, 1)
-            << "Patching role from leader to follower because of: " << l.leader_status()
-            << THROTTLE_MSG;
+        YB_LOG_EVERY_N_SECS(INFO, 5) << l.leader_status();
         role = PeerRole::FOLLOWER;
       }
     }
diff --git a/src/yb/master/scoped_leader_shared_lock.cc b/src/yb/master/scoped_leader_shared_lock.cc
index c76adbd5f8..0acc8cf333 100644
--- a/src/yb/master/scoped_leader_shared_lock.cc
+++ b/src/yb/master/scoped_leader_shared_lock.cc
@@ -123,14 +123,13 @@ ScopedLeaderSharedLock::ScopedLeaderSharedLock(
     leader_status_ = s;
     return;
   }
-  if (PREDICT_FALSE(epoch_.leader_term != cstate.current_term())) {
+  if (epoch_.leader_term != cstate.current_term()) {
     // Normally we use LeaderNotReadyToServe to indicate that the leader has not replicated its
     // NO_OP entry or the previous leader's lease has not expired yet, and the handling logic is to
     // to retry on the same server.
-    leader_status_ = STATUS_SUBSTITUTE(
-        LeaderNotReadyToServe,
-        "Leader not yet ready to serve requests: "
-        "leader_ready_term_ = $0; cstate.current_term = $1",
+    leader_status_ = STATUS_FORMAT(
+        LeaderNotReadyToServe, "$0:leader_ready_term_ = $1; cstate.current_term = $2",
+        (epoch_.leader_term == -1 ? "yb-master leader is initializing" : "Leader term mismatch"),
         epoch_.leader_term, cstate.current_term());
     return;
   }
