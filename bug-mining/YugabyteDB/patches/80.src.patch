diff --git a/src/yb/master/catalog_entity_info.proto b/src/yb/master/catalog_entity_info.proto
index 28326dbef2..945f74c37a 100644
--- a/src/yb/master/catalog_entity_info.proto
+++ b/src/yb/master/catalog_entity_info.proto
@@ -582,14 +582,12 @@ message SysSnapshotEntryPB {
 
 message SysCloneStatePB {
   // State for clone operation.
-  // Initial state:
-  // - For YSQL: CLONE_SCHEMA_STARTED: async task to create PG schema is started.
-  // - For YCQL: CREATING: CLONE_OP for every tablet is issued.
-  // Transitions:
-  // CLONE_SCHEMA_STARTED --> CREATING: After successful response from create pg schema async task.
+  // CLONE_SCHEMA_STARTED: Initial state.
+  // CLONE_SCHEMA_STARTED --> CREATING: Once DB objects have been created by ysql_dump (YSQL) or
+  //     ImportSnapshot (YCQL). Clone tablet RPCs are scheduled for all tablets.
   // CREATING --> RESTORING: All tablets in clone namespace are created and in a running
-  // stated. Restore snapshot is issued.
-  // RESTORING --> RESTORED: Restore snapshot completed
+  // state. Restore snapshot is issued.
+  // RESTORING --> RESTORED: Restore snapshot completed.
   enum State {
     CLONE_SCHEMA_STARTED = 1;
     CREATING = 2;
@@ -597,21 +595,15 @@ message SysCloneStatePB {
     RESTORED = 4;
   }
 
-  message TabletData {
-    optional string source_tablet_id = 1;
-    optional string target_tablet_id = 2;
-  }
+  optional State aggregate_state = 1;
 
-  repeated TabletData tablet_data = 1;
-  optional bytes source_snapshot_id = 2;
-  optional bytes target_snapshot_id = 3;
-  optional string source_namespace_id = 4;
-  optional uint32 clone_request_seq_no = 5;
-  optional fixed64 restore_time = 6;
+  // Needed to load the clone state into the CloneStateManager's map.
+  optional string source_namespace_id = 2;
+  optional uint32 clone_request_seq_no = 3;
 
-  // Aggregate state of the clone operation. Valid transitions:
-  // CLONE_SCHEMA_STARTED --> CREATING --> RESTORING --> RESTORED
-  optional State aggregate_state = 7;
+  // Used for debugging.
+  optional string target_namespace_name = 4;
+  optional fixed64 restore_time = 5;
 }
 
 message SchemaVersionMappingPB {
diff --git a/src/yb/master/clone/clone_state_entity.cc b/src/yb/master/clone/clone_state_entity.cc
index cbfc33beaa..0b9239ef40 100644
--- a/src/yb/master/clone/clone_state_entity.cc
+++ b/src/yb/master/clone/clone_state_entity.cc
@@ -28,4 +28,44 @@ void CloneStateInfo::Load(const SysCloneStatePB& metadata) {
 CloneStateInfo::CloneStateInfo(std::string id):
     clone_request_id_(std::move(id)) {}
 
+std::vector<CloneStateInfo::TabletData> CloneStateInfo::GetTabletData() {
+  std::lock_guard l(mutex_);
+  return tablet_data_;
+}
+
+void CloneStateInfo::AddTabletData(TabletData tablet_data) {
+  std::lock_guard l(mutex_);
+  tablet_data_.push_back(std::move(tablet_data));
+}
+
+const TxnSnapshotId& CloneStateInfo::SourceSnapshotId() {
+  std::lock_guard l(mutex_);
+  return source_snapshot_id_;
+}
+
+void CloneStateInfo::SetSourceSnapshotId(const TxnSnapshotId& source_snapshot_id) {
+  std::lock_guard l(mutex_);
+  source_snapshot_id_ = source_snapshot_id;
+}
+
+const TxnSnapshotId& CloneStateInfo::TargetSnapshotId() {
+  std::lock_guard l(mutex_);
+  return target_snapshot_id_;
+}
+
+void CloneStateInfo::SetTargetSnapshotId(const TxnSnapshotId& target_snapshot_id) {
+  std::lock_guard l(mutex_);
+  target_snapshot_id_ = target_snapshot_id;
+}
+
+const TxnSnapshotRestorationId& CloneStateInfo::RestorationId() {
+  std::lock_guard l(mutex_);
+  return restoration_id_;
+}
+
+void CloneStateInfo::SetRestorationId(const TxnSnapshotRestorationId& restoration_id) {
+  std::lock_guard l(mutex_);
+  restoration_id_ = restoration_id;
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/clone/clone_state_entity.h b/src/yb/master/clone/clone_state_entity.h
index eb115366f7..d2a06a9450 100644
--- a/src/yb/master/clone/clone_state_entity.h
+++ b/src/yb/master/clone/clone_state_entity.h
@@ -14,6 +14,7 @@
 #pragma once
 
 #include "yb/common/entity_ids_types.h"
+#include "yb/common/snapshot.h"
 #include "yb/master/catalog_entity_base.h"
 #include "yb/master/catalog_entity_info.pb.h"
 #include "yb/master/sys_catalog.h"
@@ -26,12 +27,29 @@ struct PersistentCloneStateInfo :
 class CloneStateInfo : public RefCountedThreadSafe<CloneStateInfo>,
                        public MetadataCowWrapper<PersistentCloneStateInfo> {
  public:
+  struct TabletData {
+    TabletId source_tablet_id;
+    TabletId target_tablet_id;
+  };
+
   explicit CloneStateInfo(std::string id);
 
   virtual const std::string& id() const override { return clone_request_id_; };
 
   void Load(const SysCloneStatePB& metadata) override;
 
+  std::vector<TabletData> GetTabletData();
+  void AddTabletData(CloneStateInfo::TabletData tablet_data);
+
+  const TxnSnapshotId& SourceSnapshotId();
+  void SetSourceSnapshotId(const TxnSnapshotId& source_snapshot_id);
+
+  const TxnSnapshotId& TargetSnapshotId();
+  void SetTargetSnapshotId(const TxnSnapshotId& target_snapshot_id);
+
+  const TxnSnapshotRestorationId& RestorationId();
+  void SetRestorationId(const TxnSnapshotRestorationId& restoration_id);
+
  private:
   friend class RefCountedThreadSafe<CloneStateInfo>;
   ~CloneStateInfo() = default;
@@ -39,6 +57,16 @@ class CloneStateInfo : public RefCountedThreadSafe<CloneStateInfo>,
   // The ID field is used in the sys_catalog table.
   const std::string clone_request_id_;
 
+  // These fields are set before the clone state is set to CREATING.
+  std::vector<TabletData> tablet_data_ GUARDED_BY(mutex_);
+  TxnSnapshotId source_snapshot_id_ GUARDED_BY(mutex_) = TxnSnapshotId::Nil();
+  TxnSnapshotId target_snapshot_id_ GUARDED_BY(mutex_) = TxnSnapshotId::Nil();
+
+  // This is set before the clone state is set to RESTORING.
+  TxnSnapshotRestorationId restoration_id_ GUARDED_BY(mutex_) = TxnSnapshotRestorationId::Nil();
+
+  std::mutex mutex_;
+
   DISALLOW_COPY_AND_ASSIGN(CloneStateInfo);
 };
 
diff --git a/src/yb/master/clone/clone_state_manager-test.cc b/src/yb/master/clone/clone_state_manager-test.cc
index fba82638b8..2417416fab 100644
--- a/src/yb/master/clone/clone_state_manager-test.cc
+++ b/src/yb/master/clone/clone_state_manager-test.cc
@@ -89,7 +89,8 @@ class CloneStateManagerTest : public YBTest {
         (const TxnSnapshotId& snapshot_id, HybridTime restore_at), (override));
     MOCK_METHOD(
         Status, ListRestorations,
-        (const TxnSnapshotId& snapshot_id, ListSnapshotRestorationsResponsePB* resp), (override));
+        (const TxnSnapshotRestorationId& restoration_id,
+        ListSnapshotRestorationsResponsePB* resp), (override));
 
     MOCK_METHOD(Result<TabletInfoPtr>, GetTabletInfo, (const TabletId& tablet_id), (override));
 
@@ -191,25 +192,33 @@ class CloneStateManagerTest : public YBTest {
     }
   }
 
-  Result<CloneStateInfoPtr> CreateCloneState(uint32_t seq_no) {
-    // NB: This does not call EXPECT_CALL Upsert because some tests expect this to fail.
-    return clone_state_manager_->CreateCloneState(
-        seq_no, source_ns_, kRestoreTime);
-  }
-
-  Result<CloneStateInfoPtr> CreateCloneStateAndStartCloning(
+  // Creates a clone state in the CLONE_SCHEMA_STARTED state from a provided
+  // ExternalTableSnapshotDataMap (instead of using import / export snapshot).
+  // NB: This does not call EXPECT_CALL(Upsert) because some tests expect this to fail.
+  Result<CloneStateInfoPtr> CreateCloneState(
       uint32_t seq_no, const ExternalTableSnapshotDataMap& table_snapshot_data) {
-    EXPECT_CALL(MockFuncs(), Upsert(_));
-    auto clone_state = VERIFY_RESULT(CreateCloneState(seq_no));
+    auto clone_state = VERIFY_RESULT(clone_state_manager_->CreateCloneState(
+        seq_no, kSourceNamespaceId, kTargetNamespaceName, kRestoreTime));
 
-    EXPECT_CALL(MockFuncs(), Upsert(_));
     RETURN_NOT_OK(clone_state_manager_->UpdateCloneStateWithSnapshotInfo(
         clone_state, kSourceSnapshotId, kTargetSnapshotId, table_snapshot_data));
-
     return clone_state;
   }
 
-  Result<CloneStateInfoPtr> CreateCloneStateAndStartCloning() {
+  Result<CloneStateInfoPtr> CreateSecondCloneState() {
+    ExternalTableSnapshotDataMap table_snapshot_data;
+    auto& table_data = table_snapshot_data[kSourceTableId];
+    table_data.table_meta = ImportSnapshotMetaResponsePB::TableMetaPB();
+    IdPairPB tablet_ids;
+    tablet_ids.set_old_id("test_source_id");
+    tablet_ids.set_new_id("test_target_id");
+    *table_data.table_meta->add_tablets_ids() = tablet_ids;
+
+    EXPECT_CALL(MockFuncs(), Upsert(_));
+    return CreateCloneState(kSeqNo + 1, table_snapshot_data);
+  }
+
+  ExternalTableSnapshotDataMap DefaultTableSnapshotData() {
     ExternalTableSnapshotDataMap table_snapshot_data;
     auto& table_data = table_snapshot_data[kSourceTableId];
     table_data.table_meta = ImportSnapshotMetaResponsePB::TableMetaPB();
@@ -219,18 +228,24 @@ class CloneStateManagerTest : public YBTest {
       tablet_ids.set_new_id(target_tablets_[i]->id());
       *table_data.table_meta->add_tablets_ids() = tablet_ids;
     }
-    return CreateCloneStateAndStartCloning(kSeqNo, table_snapshot_data);
+    return table_snapshot_data;
   }
 
-  Result<CloneStateInfoPtr> CreateSecondCloneStateAndStartCloning() {
-    ExternalTableSnapshotDataMap table_snapshot_data;
-    auto& table_data = table_snapshot_data[kSourceTableId];
-    table_data.table_meta = ImportSnapshotMetaResponsePB::TableMetaPB();
-    IdPairPB tablet_ids;
-    tablet_ids.set_old_id("test_source_id");
-    tablet_ids.set_new_id("test_target_id");
-    *table_data.table_meta->add_tablets_ids() = tablet_ids;
-    return CreateCloneStateAndStartCloning(kSeqNo + 1, table_snapshot_data);
+  // Creates a clone state and schedules clone ops to move it into the CREATING state.
+  Result<CloneStateInfoPtr> CreateCloneStateAndStartCloning() {
+    EXPECT_CALL(MockFuncs(), Upsert(_));
+    auto clone_state = VERIFY_RESULT(CreateCloneState(kSeqNo, DefaultTableSnapshotData()));
+
+    for (int i = 0; i < kNumTablets; ++i) {
+      EXPECT_CALL(MockFuncs(), GetTabletInfo(source_tablets_[i]->id()))
+          .WillOnce(Return(source_tablets_[i]));
+      EXPECT_CALL(MockFuncs(), GetTabletInfo(target_tablets_[i]->id()))
+          .WillOnce(Return(target_tablets_[i]));
+      EXPECT_CALL(MockFuncs(), ScheduleCloneTabletCall(source_tablets_[i], kEpoch, _));
+    }
+    EXPECT_CALL(MockFuncs(), Upsert(_));
+    RETURN_NOT_OK(ScheduleCloneOps(clone_state, kEpoch, {} /* not_snapshotted_tablets */));
+    return clone_state;
   }
 
   Status HandleCreatingState(const CloneStateInfoPtr& clone_state) {
@@ -271,6 +286,7 @@ class CloneStateManagerTest : public YBTest {
   const int kNumTablets = 2;
   const HybridTime kRestoreTime = HybridTime(12345);
   const YQLDatabase kDatabaseType = YQLDatabase::YQL_DATABASE_CQL;
+  const LeaderEpoch kEpoch = LeaderEpoch(123 /* term */);
 
   NamespaceInfoPtr source_ns_;
   NamespaceInfoPtr target_ns_;
@@ -281,20 +297,15 @@ class CloneStateManagerTest : public YBTest {
 };
 
 TEST_F(CloneStateManagerTest, CreateCloneState) {
-  auto clone_state = ASSERT_RESULT(CreateCloneStateAndStartCloning());
+  EXPECT_CALL(MockFuncs(), Upsert(_));
+  auto clone_state = ASSERT_RESULT(CreateCloneState(kSeqNo, DefaultTableSnapshotData()));
 
   // Check clone state persisted fields.
   SysCloneStatePB expected_pb;
-  for (int i = 0; i < kNumTablets; ++i) {
-    auto* tablet_data = expected_pb.add_tablet_data();
-    tablet_data->set_source_tablet_id(source_tablets_[i]->id());
-    tablet_data->set_target_tablet_id(target_tablets_[i]->id());
-  }
-  expected_pb.set_source_snapshot_id(kSourceSnapshotId.data(), kSourceSnapshotId.size());
-  expected_pb.set_target_snapshot_id(kTargetSnapshotId.data(), kTargetSnapshotId.size());
+  expected_pb.set_aggregate_state(SysCloneStatePB::CLONE_SCHEMA_STARTED);
   expected_pb.set_source_namespace_id(kSourceNamespaceId);
   expected_pb.set_clone_request_seq_no(kSeqNo);
-  expected_pb.set_aggregate_state(SysCloneStatePB::CREATING);
+  expected_pb.set_target_namespace_name(kTargetNamespaceName);
   expected_pb.set_restore_time(kRestoreTime.ToUint64());
   std::string diff;
   bool same = pb_util::ArePBsEqual(clone_state->LockForRead()->pb, expected_pb, &diff);
@@ -305,43 +316,34 @@ TEST_F(CloneStateManagerTest, CreateCloneState) {
       GetCloneStateFromSourceNamespace(kSourceNamespaceId)), clone_state);
 }
 
-TEST_F(CloneStateManagerTest, CreateCloneStateWhileOneIsOngoing) {
-  // It should not be possible to create a clone state while a clone is ongoing.
-  auto clone_state1 = ASSERT_RESULT(CreateCloneStateAndStartCloning());
+TEST_F(CloneStateManagerTest, CreateSecondCloneState) {
+  // It should be possible to create a clone state if and only if the previous clone is in a
+  // terminal state.
+  ASSERT_RESULT(CreateCloneStateAndStartCloning());
 
-  { // Existing clone state is CREATING.
-    auto s = CreateCloneState(kSeqNo + 1);
-    ASSERT_NOK(s);
-    ASSERT_TRUE(s.status().IsAlreadyPresent());
-  }
+  for (int i = SysCloneStatePB::State_MIN; i <= SysCloneStatePB::State_MAX; ++i) {
+    auto state = SysCloneStatePB_State(i);
+    auto current_clone_state = ASSERT_RESULT(GetCloneStateFromSourceNamespace(kSourceNamespaceId));
 
-  {
-    auto l = clone_state1->LockForWrite();
-    l.mutable_data()->pb.set_aggregate_state(SysCloneStatePB::RESTORING);
+    LOG(INFO) << "Setting previous state to " << SysCloneStatePB::State_Name(state);
+    auto l = current_clone_state->LockForWrite();
+    l.mutable_data()->pb.set_aggregate_state(state);
     l.Commit();
-    auto s = CreateCloneState(kSeqNo + 1);
-    ASSERT_NOK(s);
-    ASSERT_TRUE(s.status().IsAlreadyPresent());
-  }
 
-  {
-    auto l = clone_state1->LockForWrite();
-    l.mutable_data()->pb.set_aggregate_state(SysCloneStatePB::RESTORED);
-    l.Commit();
-    ASSERT_OK(CreateSecondCloneStateAndStartCloning());
+    if (current_clone_state->LockForRead()->pb.aggregate_state() == SysCloneStatePB::RESTORED) {
+      EXPECT_CALL(MockFuncs(), Upsert(_));
+      ASSERT_OK(CreateCloneState(i + 1, DefaultTableSnapshotData()));
+    } else {
+      auto s = CreateCloneState(i + 1, DefaultTableSnapshotData());
+      ASSERT_NOK(s);
+      ASSERT_TRUE(s.status().IsAlreadyPresent());
+    }
   }
 }
 
 TEST_F(CloneStateManagerTest, ScheduleCloneOps) {
-  for (int i = 0; i < kNumTablets; ++i) {
-    EXPECT_CALL(MockFuncs(), GetTabletInfo(source_tablets_[i]->id()))
-        .WillOnce(Return(source_tablets_[i]));
-    EXPECT_CALL(MockFuncs(), GetTabletInfo(target_tablets_[i]->id()))
-        .WillOnce(Return(target_tablets_[i]));
-  }
-
-  auto clone_state = ASSERT_RESULT(CreateCloneStateAndStartCloning());
-  LeaderEpoch epoch(123 /* term */);
+  EXPECT_CALL(MockFuncs(), Upsert(_));
+  auto clone_state = ASSERT_RESULT(CreateCloneState(kSeqNo, DefaultTableSnapshotData()));
 
   for (int i = 0; i < kNumTablets; ++i) {
     tablet::CloneTabletRequestPB expected_req;
@@ -357,10 +359,15 @@ TEST_F(CloneStateManagerTest, ScheduleCloneOps) {
     *expected_req.mutable_target_partition_schema() =
         target_table_->LockForRead()->pb.partition_schema();
 
+    EXPECT_CALL(MockFuncs(), GetTabletInfo(source_tablets_[i]->id()))
+        .WillOnce(Return(source_tablets_[i]));
+    EXPECT_CALL(MockFuncs(), GetTabletInfo(target_tablets_[i]->id()))
+        .WillOnce(Return(target_tablets_[i]));
     EXPECT_CALL(MockFuncs(), ScheduleCloneTabletCall(
-        source_tablets_[i], epoch, CloneTabletRequestPBMatcher(expected_req)));
+        source_tablets_[i], kEpoch, CloneTabletRequestPBMatcher(expected_req)));
   }
-  ASSERT_OK(ScheduleCloneOps(clone_state, epoch, {} /* not_snapshotted_tablets */));
+  EXPECT_CALL(MockFuncs(), Upsert(_));
+  ASSERT_OK(ScheduleCloneOps(clone_state, kEpoch, {} /* not_snapshotted_tablets */));
 }
 
 TEST_F(CloneStateManagerTest, HandleCreatingStateAllTabletsCreating) {
@@ -417,44 +424,14 @@ TEST_F(CloneStateManagerTest, HandleCreatingStateAllTabletsRunning) {
   // HandleCreatingState should transition aggregate state to RESTORING and should also trigger a
   // restore.
   EXPECT_CALL(MockFuncs(), Upsert(_));
-  ListSnapshotRestorationsResponsePB resp;
-  EXPECT_CALL(MockFuncs(), ListRestorations(kTargetSnapshotId, _))
-      .WillOnce(DoAll(SetArgPointee<1>(resp), Return(Status::OK())));
   EXPECT_CALL(MockFuncs(), Restore(kTargetSnapshotId, kRestoreTime))
       .WillOnce(Return(kRestorationId));
   ASSERT_OK(HandleCreatingState(clone_state));
 
   auto read_lock  = clone_state->LockForRead();
   ASSERT_EQ(read_lock->pb.aggregate_state(), SysCloneStatePB::RESTORING);
-}
-
-TEST_F(CloneStateManagerTest, HandleCreatingStateExistingRestoration) {
-  // Mark all tablets as RUNNING.
-  for (int i = 0; i < kNumTablets; ++i) {
-    auto lock = target_tablets_[i]->LockForWrite();
-    lock.mutable_data()->set_state(
-        SysTabletsEntryPB::RUNNING, Format("Marked tablet $0 as running", i));
-    lock.Commit();
-  }
-
-  auto clone_state = ASSERT_RESULT(CreateCloneStateAndStartCloning());
-
-  for (int i = 0; i < kNumTablets; ++i) {
-    EXPECT_CALL(MockFuncs(), GetTabletInfo(target_tablets_[i]->id()))
-        .WillOnce(Return(target_tablets_[i]));
-  }
-
-  // HandleCreatingState should transition aggregate state to RESTORING but not trigger a restore
-  // since one already exists.
-  EXPECT_CALL(MockFuncs(), Upsert(_));
-  ListSnapshotRestorationsResponsePB resp;
-  resp.add_restorations();
-  EXPECT_CALL(MockFuncs(), ListRestorations(kTargetSnapshotId, _))
-      .WillOnce(DoAll(SetArgPointee<1>(resp), Return(Status::OK())));
-  ASSERT_OK(HandleCreatingState(clone_state));
 
-  auto read_lock  = clone_state->LockForRead();
-  ASSERT_EQ(read_lock->pb.aggregate_state(), SysCloneStatePB::RESTORING);
+  ASSERT_EQ(clone_state->RestorationId(), kRestorationId);
 }
 
 TEST_F(CloneStateManagerTest, HandleRestoringStateIncomplete) {
@@ -463,12 +440,13 @@ TEST_F(CloneStateManagerTest, HandleRestoringStateIncomplete) {
     auto lock = clone_state->LockForWrite();
     lock.mutable_data()->pb.set_aggregate_state(SysCloneStatePB::RESTORING);
     lock.Commit();
+    clone_state->SetRestorationId(kRestorationId);
   }
 
   ListSnapshotRestorationsResponsePB resp;
   auto* restoration = resp.add_restorations();
   restoration->mutable_entry()->set_state(SysSnapshotEntryPB::RESTORING);
-  EXPECT_CALL(MockFuncs(), ListRestorations(kTargetSnapshotId, _))
+  EXPECT_CALL(MockFuncs(), ListRestorations(kRestorationId, _))
       .WillOnce(DoAll(SetArgPointee<1>(resp), Return(Status::OK())));
 
   // Should not do anything.
@@ -483,12 +461,13 @@ TEST_F(CloneStateManagerTest, HandleRestoringStateRestored) {
     auto lock = clone_state->LockForWrite();
     lock.mutable_data()->pb.set_aggregate_state(SysCloneStatePB::RESTORING);
     lock.Commit();
+    clone_state->SetRestorationId(kRestorationId);
   }
 
   ListSnapshotRestorationsResponsePB resp;
   auto* restoration = resp.add_restorations();
   restoration->mutable_entry()->set_state(SysSnapshotEntryPB::RESTORED);
-  EXPECT_CALL(MockFuncs(), ListRestorations(kTargetSnapshotId, _))
+  EXPECT_CALL(MockFuncs(), ListRestorations(kRestorationId, _))
       .WillOnce(DoAll(SetArgPointee<1>(resp), Return(Status::OK())));
   EXPECT_CALL(MockFuncs(), Upsert);
 
@@ -533,7 +512,7 @@ TEST_F(CloneStateManagerTest, LoadUsesLatestSeqNo) {
     lock.Commit();
   }
 
-  auto clone_state2 = ASSERT_RESULT(CreateSecondCloneStateAndStartCloning());
+  auto clone_state2 = ASSERT_RESULT(CreateSecondCloneState());
 
   // Should load clone_state2 since it has a higher seq_no.
   {
diff --git a/src/yb/master/clone/clone_state_manager.cc b/src/yb/master/clone/clone_state_manager.cc
index 849e07dbc1..7c5b6dbeac 100644
--- a/src/yb/master/clone/clone_state_manager.cc
+++ b/src/yb/master/clone/clone_state_manager.cc
@@ -18,10 +18,12 @@
 #include "yb/common/common_flags.h"
 #include "yb/common/common_types.pb.h"
 #include "yb/common/entity_ids_types.h"
+#include "yb/common/hybrid_time.h"
 #include "yb/common/snapshot.h"
 #include "yb/common/wire_protocol.h"
 #include "yb/gutil/macros.h"
 #include "yb/gutil/map-util.h"
+#include "yb/gutil/ref_counted.h"
 #include "yb/master/async_rpc_tasks.h"
 #include "yb/master/catalog_entity_info.pb.h"
 #include "yb/master/clone/clone_state_entity.h"
@@ -79,9 +81,10 @@ class CloneStateManagerExternalFunctions : public CloneStateManagerExternalFunct
   }
 
   Status ListRestorations(
-      const TxnSnapshotId& snapshot_id, ListSnapshotRestorationsResponsePB* resp) override {
+      const TxnSnapshotRestorationId& restoration_id, ListSnapshotRestorationsResponsePB* resp)
+      override {
     return catalog_manager_->snapshot_coordinator().ListRestorations(
-        TxnSnapshotRestorationId::Nil(), snapshot_id, resp);
+        restoration_id, TxnSnapshotId::Nil(), resp);
   }
 
   // Catalog manager.
@@ -239,48 +242,46 @@ Result<std::pair<NamespaceId, uint32_t>> CloneStateManager::CloneNamespace(
 
   auto seq_no = source_namespace->FetchAndIncrementCloneSeqNo();
 
-  // Set up persisted clone state.
-  auto clone_state = VERIFY_RESULT(CreateCloneState(seq_no, source_namespace, restore_time));
+  // Set up clone state.
+  auto clone_state = VERIFY_RESULT(
+      CreateCloneState(seq_no, source_namespace_id, target_namespace_name, restore_time));
 
   // Clone PG Schema objects first in case of PGSQL databases. Tablets cloning is initiated in the
   // callback of ClonePgSchemaObjects async task.
   if (source_namespace->database_type() == YQL_DATABASE_PGSQL) {
     RETURN_NOT_OK(ClonePgSchemaObjects(
         clone_state, source_namespace->name(), target_namespace_name, snapshot_schedule_id,
-        restore_time, epoch));
+        epoch));
   } else {
     // For YCQL, start tablets cloning directly.
     RETURN_NOT_OK(StartTabletsCloning(
-        clone_state, snapshot_schedule_id, restore_time, target_namespace_name, deadline, epoch));
+        clone_state, snapshot_schedule_id, target_namespace_name, deadline, epoch));
   }
   return make_pair(source_namespace_id, seq_no);
 }
 
 Status CloneStateManager::StartTabletsCloningYsql(
     CloneStateInfoPtr clone_state, const SnapshotScheduleId& snapshot_schedule_id,
-    const HybridTime& restore_time, const std::string& target_namespace_name,
+    const std::string& target_namespace_name,
     CoarseTimePoint deadline, const LeaderEpoch& epoch, Status pg_schema_cloning_status) {
   if (!pg_schema_cloning_status.ok()) {
     return pg_schema_cloning_status;
   }
-  // Transition the clone state from CLONE_SCHEMA_STARTED to CREATING
-  auto lock = clone_state->LockForWrite();
-  auto& pb = lock.mutable_data()->pb;
-  pb.set_aggregate_state(SysCloneStatePB::CREATING);
-  RETURN_NOT_OK(external_funcs_->Upsert(clone_state));
-  lock.Commit();
   return StartTabletsCloning(
-      clone_state, snapshot_schedule_id, restore_time, target_namespace_name, deadline, epoch);
+      clone_state, snapshot_schedule_id, target_namespace_name, deadline, epoch);
 }
 
 Status CloneStateManager::StartTabletsCloning(
-    CloneStateInfoPtr clone_state, const SnapshotScheduleId& snapshot_schedule_id,
-    const HybridTime& restore_time, const std::string& target_namespace_name,
-    CoarseTimePoint deadline, const LeaderEpoch& epoch) {
+    CloneStateInfoPtr clone_state,
+    const SnapshotScheduleId& snapshot_schedule_id,
+    const std::string& target_namespace_name,
+    CoarseTimePoint deadline,
+    const LeaderEpoch& epoch) {
   // Export snapshot info.
   auto [snapshot_info, not_snapshotted_tablets] = VERIFY_RESULT(
       external_funcs_->GenerateSnapshotInfoFromSchedule(
-          snapshot_schedule_id, restore_time, deadline));
+          snapshot_schedule_id, HybridTime(clone_state->LockForRead()->pb.restore_time()),
+          deadline));
   auto source_snapshot_id = VERIFY_RESULT(FullyDecodeTxnSnapshotId(snapshot_info.id()));
 
   // Import snapshot info.
@@ -329,19 +330,21 @@ Status CloneStateManager::StartTabletsCloning(
 }
 
 Status CloneStateManager::ClonePgSchemaObjects(
-    CloneStateInfoPtr clone_state, const std::string& source_db_name,
-    const std::string& target_db_name, const SnapshotScheduleId& snapshot_schedule_id,
-    const HybridTime& restore_time, const LeaderEpoch& epoch) {
+    CloneStateInfoPtr clone_state,
+    const std::string& source_db_name,
+    const std::string& target_db_name,
+    const SnapshotScheduleId& snapshot_schedule_id,
+    const LeaderEpoch& epoch) {
   // Pick one of the live tservers to send ysql_dump and ysqlsh requests to.
   auto ts = external_funcs_->PickTserver();
   auto ts_permanent_uuid = ts->permanent_uuid();
-  auto read_lock = clone_state->LockForRead();
-  // Deadline passed to the ClonePGSchemaTask (including rpc time and callback execution deadline)
+  // Deadline passed to the ClonePgSchemaTask (including rpc time and callback execution deadline)
   auto deadline = MonoTime::Now() + FLAGS_ysql_clone_pg_schema_rpc_timeout_ms * 1ms;
   RETURN_NOT_OK(external_funcs_->ScheduleClonePgSchemaTask(
-      ts_permanent_uuid, source_db_name, target_db_name, HybridTime(read_lock->pb.restore_time()),
+      ts_permanent_uuid, source_db_name, target_db_name,
+      HybridTime(clone_state->LockForRead()->pb.restore_time()),
       MakeDoneClonePgSchemaCallback(
-          clone_state, snapshot_schedule_id, restore_time, target_db_name, ToCoarse(deadline),
+          clone_state, snapshot_schedule_id, target_db_name, ToCoarse(deadline),
           epoch),
       deadline));
   return Status::OK();
@@ -385,76 +388,69 @@ Status CloneStateManager::LoadCloneState(const std::string& id, const SysCloneSt
 }
 
 Result<CloneStateInfoPtr> CloneStateManager::CreateCloneState(
-    uint32_t seq_no, const NamespaceInfoPtr& source_namespace,
+    uint32_t seq_no,
+    const NamespaceId& source_namespace_id,
+    const std::string& target_namespace_name,
     const HybridTime& restore_time) {
-  NamespaceId source_namespace_id = source_namespace->id();
-  CloneStateInfoPtr clone_state;
-  {
-    std::lock_guard lock(mutex_);
-    auto it = source_clone_state_map_.find(source_namespace_id);
-    if (it != source_clone_state_map_.end()) {
-      auto state = it->second->LockForRead()->pb.aggregate_state();
-      if (state != SysCloneStatePB::RESTORED) {
-        return STATUS_FORMAT(
-            AlreadyPresent,
-            "Cannot create new clone state because there is already an ongoing "
-            "clone for source namespace $0 in state $1",
-            source_namespace_id, state);
-      }
+  std::lock_guard lock(mutex_);
+  auto it = source_clone_state_map_.find(source_namespace_id);
+  if (it != source_clone_state_map_.end()) {
+    auto state = it->second->LockForRead()->pb.aggregate_state();
+    if (state != SysCloneStatePB::RESTORED) {
+      return STATUS_FORMAT(
+          AlreadyPresent,
+          "Cannot create new clone state because there is already an ongoing "
+          "clone for source namespace $0 in state $1",
+          source_namespace_id, state);
     }
-    clone_state = CloneStateInfoPtr(new CloneStateInfo(GenerateObjectId()));
-    source_clone_state_map_[source_namespace_id] = clone_state;
   }
+
+  auto clone_state = make_scoped_refptr<CloneStateInfo>(GenerateObjectId());
   clone_state->mutable_metadata()->StartMutation();
   auto* pb = &clone_state->mutable_metadata()->mutable_dirty()->pb;
-  pb->set_source_namespace_id(source_namespace_id);
+  pb->set_aggregate_state(SysCloneStatePB::CLONE_SCHEMA_STARTED);
   pb->set_clone_request_seq_no(seq_no);
+  pb->set_source_namespace_id(source_namespace_id);
   pb->set_restore_time(restore_time.ToUint64());
-  // Clone PG schema is needed for PGSQL, otherwise start directly with the next step.
-  pb->set_aggregate_state(
-      source_namespace->database_type() == YQL_DATABASE_PGSQL
-          ? SysCloneStatePB::CLONE_SCHEMA_STARTED
-          : SysCloneStatePB::CREATING);
-
+  pb->set_target_namespace_name(target_namespace_name);
   RETURN_NOT_OK(external_funcs_->Upsert(clone_state));
   clone_state->mutable_metadata()->CommitMutation();
+
+  // Add to the in-memory map.
+  source_clone_state_map_[source_namespace_id] = clone_state;
+
   return clone_state;
 }
 
 Status CloneStateManager::UpdateCloneStateWithSnapshotInfo(
-    CloneStateInfoPtr clone_state, const TxnSnapshotId& source_snapshot_id,
+    const CloneStateInfoPtr& clone_state,
+    const TxnSnapshotId& source_snapshot_id,
     const TxnSnapshotId& target_snapshot_id,
     const ExternalTableSnapshotDataMap& table_snapshot_data) {
-  clone_state->mutable_metadata()->StartMutation();
-  auto* pb = &clone_state->mutable_metadata()->mutable_dirty()->pb;
-  pb->set_source_snapshot_id(source_snapshot_id.data(), source_snapshot_id.size());
-  pb->set_target_snapshot_id(target_snapshot_id.data(), target_snapshot_id.size());
+  clone_state->SetSourceSnapshotId(source_snapshot_id);
+  clone_state->SetTargetSnapshotId(target_snapshot_id);
 
   // Add data for each tablet in this table.
-  std::unordered_map<TabletId, int> target_tablet_to_index;
   for (const auto& [_, table_snapshot_data] : table_snapshot_data) {
     for (auto& tablet : table_snapshot_data.table_meta->tablets_ids()) {
-      auto* tablet_data = pb->add_tablet_data();
-      tablet_data->set_source_tablet_id(tablet.old_id());
-      tablet_data->set_target_tablet_id(tablet.new_id());
-      target_tablet_to_index[tablet.new_id()] = pb->tablet_data_size() - 1;
+      auto tablet_data = CloneStateInfo::TabletData {
+          .source_tablet_id = tablet.old_id(),
+          .target_tablet_id = tablet.new_id()
+      };
+      clone_state->AddTabletData(std::move(tablet_data));
     }
   }
-  RETURN_NOT_OK(external_funcs_->Upsert(clone_state));
-  clone_state->mutable_metadata()->CommitMutation();
   return Status::OK();
 }
 
 Status CloneStateManager::ScheduleCloneOps(
     const CloneStateInfoPtr& clone_state, const LeaderEpoch& epoch,
     const std::unordered_set<TabletId>& not_snapshotted_tablets) {
-  auto lock = clone_state->LockForRead();
-  auto& pb = lock->pb;
-  for (auto& tablet_data : pb.tablet_data()) {
+  for (auto& tablet_data : clone_state->GetTabletData()) {
     auto source_tablet = VERIFY_RESULT(
-        external_funcs_->GetTabletInfo(tablet_data.source_tablet_id()));
+        external_funcs_->GetTabletInfo(tablet_data.source_tablet_id));
     auto target_tablet = VERIFY_RESULT(
-        external_funcs_->GetTabletInfo(tablet_data.target_tablet_id()));
+        external_funcs_->GetTabletInfo(tablet_data.target_tablet_id));
     auto source_table = source_tablet->table();
     auto target_table = target_tablet->table();
 
@@ -462,20 +458,23 @@ Status CloneStateManager::ScheduleCloneOps(
     auto source_table_lock = source_table->LockForRead();
     auto target_table_lock = target_table->LockForRead();
 
+    const auto& clone_pb_lock = clone_state->LockForRead();
     tablet::CloneTabletRequestPB req;
-    if (not_snapshotted_tablets.contains(tablet_data.source_tablet_id())) {
+    if (not_snapshotted_tablets.contains(tablet_data.source_tablet_id)) {
       RSTATUS_DCHECK(source_tablet->LockForRead()->pb.hide_hybrid_time() != 0, IllegalState,
           Format("Expected not snapshotted tablet to be in HIDDEN state. Actual: $0",
               source_table_lock->state_name()));
       req.set_clone_from_active_rocksdb(true);
     }
-    req.set_tablet_id(tablet_data.source_tablet_id());
-    req.set_target_tablet_id(tablet_data.target_tablet_id());
-    req.set_source_snapshot_id(pb.source_snapshot_id().data(), pb.source_snapshot_id().size());
-    req.set_target_snapshot_id(pb.target_snapshot_id().data(), pb.target_snapshot_id().size());
+    req.set_tablet_id(tablet_data.source_tablet_id);
+    req.set_target_tablet_id(tablet_data.target_tablet_id);
+    req.set_source_snapshot_id(
+        clone_state->SourceSnapshotId().data(), clone_state->SourceSnapshotId().size());
+    req.set_target_snapshot_id(
+        clone_state->TargetSnapshotId().data(), clone_state->TargetSnapshotId().size());
     req.set_target_table_id(target_table->id());
     req.set_target_namespace_name(target_table_lock->namespace_name());
-    req.set_clone_request_seq_no(pb.clone_request_seq_no());
+    req.set_clone_request_seq_no(clone_pb_lock->pb.clone_request_seq_no());
     req.set_target_pg_table_id(target_table_lock->pb.pg_table_id());
     if (target_table_lock->pb.has_index_info()) {
       *req.mutable_target_index_info() = target_table_lock->pb.index_info();
@@ -484,6 +483,13 @@ Status CloneStateManager::ScheduleCloneOps(
     *req.mutable_target_partition_schema() = target_table_lock->pb.partition_schema();
     RETURN_NOT_OK(external_funcs_->ScheduleCloneTabletCall(source_tablet, epoch, std::move(req)));
   }
+
+  auto lock = clone_state->LockForWrite();
+  auto& pb = lock.mutable_data()->pb;
+  pb.set_aggregate_state(SysCloneStatePB::CREATING);
+  RETURN_NOT_OK(external_funcs_->Upsert(clone_state));
+  lock.Commit();
+
   return Status::OK();
 }
 
@@ -495,12 +501,12 @@ Result<CloneStateInfoPtr> CloneStateManager::GetCloneStateFromSourceNamespace(
 
 AsyncClonePgSchema::ClonePgSchemaCallbackType CloneStateManager::MakeDoneClonePgSchemaCallback(
     CloneStateInfoPtr clone_state, const SnapshotScheduleId& snapshot_schedule_id,
-    const HybridTime& restore_time, const std::string& target_namespace_name,
+    const std::string& target_namespace_name,
     CoarseTimePoint deadline, const LeaderEpoch& epoch) {
-  return [this, clone_state, snapshot_schedule_id, restore_time, target_namespace_name, deadline,
+  return [this, clone_state, snapshot_schedule_id, target_namespace_name, deadline,
           epoch](Status pg_schema_cloning_status) {
     return StartTabletsCloningYsql(
-        clone_state, snapshot_schedule_id, restore_time, target_namespace_name, deadline, epoch,
+        clone_state, snapshot_schedule_id, target_namespace_name, deadline, epoch,
         pg_schema_cloning_status);
   };
 }
@@ -512,15 +518,14 @@ Status CloneStateManager::HandleCreatingState(const CloneStateInfoPtr& clone_sta
   }
 
   auto lock = clone_state->LockForWrite();
-
   SCHECK_EQ(lock->pb.aggregate_state(), SysCloneStatePB::CREATING, IllegalState,
       "Expected clone to be in creating state");
 
   bool all_tablets_running = true;
   auto& pb = lock.mutable_data()->pb;
-  for (auto& tablet_data : *pb.mutable_tablet_data()) {
+  for (auto& tablet_data : clone_state->GetTabletData()) {
     // Check to see if the tablet is done cloning (i.e. it is RUNNING).
-    auto tablet = VERIFY_RESULT(external_funcs_->GetTabletInfo(tablet_data.target_tablet_id()));
+    auto tablet = VERIFY_RESULT(external_funcs_->GetTabletInfo(tablet_data.target_tablet_id));
     if (!tablet->LockForRead()->is_running()) {
       all_tablets_running = false;
     }
@@ -531,17 +536,11 @@ Status CloneStateManager::HandleCreatingState(const CloneStateInfoPtr& clone_sta
   }
 
   LOG(INFO) << Format("All tablets for cloned namespace $0 with seq_no $1 are running. "
-      "Marking clone operation as restoring.",
+      "Triggering restore.",
       pb.source_namespace_id(), pb.clone_request_seq_no());
-  auto target_snapshot_id = VERIFY_RESULT(FullyDecodeTxnSnapshotId(pb.target_snapshot_id()));
-
-  // Check for an existing restoration id. This might have happened if a restoration was submitted
-  // but we crashed / failed over before we were able to persist the clone state as RESTORING.
-  ListSnapshotRestorationsResponsePB resp;
-  RETURN_NOT_OK(external_funcs_->ListRestorations(target_snapshot_id, &resp));
-  if (resp.restorations().empty()) {
-    RETURN_NOT_OK(external_funcs_->Restore(target_snapshot_id, HybridTime(pb.restore_time())));
-  }
+  auto restoration_id = VERIFY_RESULT(external_funcs_->Restore(
+      clone_state->TargetSnapshotId(), HybridTime(lock->pb.restore_time())));
+  clone_state->SetRestorationId(restoration_id);
   pb.set_aggregate_state(SysCloneStatePB::RESTORING);
 
   RETURN_NOT_OK(external_funcs_->Upsert(clone_state));
@@ -551,10 +550,12 @@ Status CloneStateManager::HandleCreatingState(const CloneStateInfoPtr& clone_sta
 
 Status CloneStateManager::HandleRestoringState(const CloneStateInfoPtr& clone_state) {
   auto lock = clone_state->LockForWrite();
-  auto target_snapshot_id = VERIFY_RESULT(FullyDecodeTxnSnapshotId(lock->pb.target_snapshot_id()));
+  SCHECK_EQ(lock->pb.aggregate_state(), SysCloneStatePB::RESTORING, IllegalState,
+      "Expected clone to be in restoring state");
 
   ListSnapshotRestorationsResponsePB resp;
-  RETURN_NOT_OK(external_funcs_->ListRestorations(target_snapshot_id, &resp));
+
+  RETURN_NOT_OK(external_funcs_->ListRestorations(clone_state->RestorationId(), &resp));
   SCHECK_EQ(resp.restorations_size(), 1, IllegalState, "Unexpected number of restorations.");
 
   if (resp.restorations(0).entry().state() != SysSnapshotEntryPB::RESTORED) {
@@ -584,8 +585,7 @@ Status CloneStateManager::Run() {
       case SysCloneStatePB::RESTORING:
         s = HandleRestoringState(clone_state);
         break;
-      case SysCloneStatePB::CLONE_SCHEMA_STARTED:
-        FALLTHROUGH_INTENDED;
+      case SysCloneStatePB::CLONE_SCHEMA_STARTED: FALLTHROUGH_INTENDED;
       case SysCloneStatePB::RESTORED:
         break;
     }
diff --git a/src/yb/master/clone/clone_state_manager.h b/src/yb/master/clone/clone_state_manager.h
index 0a0a4643e8..55880ac035 100644
--- a/src/yb/master/clone/clone_state_manager.h
+++ b/src/yb/master/clone/clone_state_manager.h
@@ -53,10 +53,12 @@ class CloneStateManager {
       const LeaderEpoch& epoch);
 
   Result<CloneStateInfoPtr> CreateCloneState(
-      uint32_t seq_no, const NamespaceInfoPtr& source_namespace, const HybridTime& restore_time);
+      uint32_t seq_no, const NamespaceId& source_namespace_id,
+      const std::string& target_namespace_name, const HybridTime& restore_time);
 
   Status UpdateCloneStateWithSnapshotInfo(
-      CloneStateInfoPtr clone_state, const TxnSnapshotId& source_snapshot_id,
+      const CloneStateInfoPtr& clone_state,
+      const TxnSnapshotId& source_snapshot_id,
       const TxnSnapshotId& target_snapshot_id,
       const ExternalTableSnapshotDataMap& table_snapshot_data);
 
@@ -77,12 +79,12 @@ class CloneStateManager {
   Status ClonePgSchemaObjects(
       CloneStateInfoPtr clone_state, const std::string& source_db_name,
       const std::string& target_db_name, const SnapshotScheduleId& snapshot_schedule_id,
-      const HybridTime& restore_time, const LeaderEpoch& epoch);
+      const LeaderEpoch& epoch);
 
-  // Transition clone state according to ClonePgSchema async task response then StartTabletsCloning.
+  // Return clone schema status if it failed, or otherwise StartTabletsCloning.
   Status StartTabletsCloningYsql(
       CloneStateInfoPtr clone_state, const SnapshotScheduleId& snapshot_schedule_id,
-      const HybridTime& restore_time, const std::string& target_namespace_name,
+      const std::string& target_namespace_name,
       CoarseTimePoint deadline, const LeaderEpoch& epoch, Status pg_schema_cloning_status);
 
   // Starts snapshot related operations for clone (mainly generate snapshotInfoPB as of
@@ -91,7 +93,7 @@ class CloneStateManager {
   // of YCQL and the second part of the clone process in case of YSQL.
   Status StartTabletsCloning(
       CloneStateInfoPtr clone_state, const SnapshotScheduleId& snapshot_schedule_id,
-      const HybridTime& restore_time, const std::string& target_namespace_name,
+      const std::string& target_namespace_name,
       CoarseTimePoint deadline, const LeaderEpoch& epoch);
 
   Status LoadCloneState(const std::string& id, const SysCloneStatePB& metadata);
@@ -104,11 +106,12 @@ class CloneStateManager {
 
   AsyncClonePgSchema::ClonePgSchemaCallbackType MakeDoneClonePgSchemaCallback(
       CloneStateInfoPtr clone_state, const SnapshotScheduleId& snapshot_schedule_id,
-      const HybridTime& restore_time, const std::string& target_namespace_name,
+      const std::string& target_namespace_name,
       CoarseTimePoint deadline, const LeaderEpoch& epoch);
 
   Status HandleCreatingState(const CloneStateInfoPtr& clone_state);
   Status HandleRestoringState(const CloneStateInfoPtr& clone_state);
+  Result<bool> IsDeleteNamespaceDone(const CloneStateInfoPtr& clone_state);
 
   std::mutex mutex_;
 
diff --git a/src/yb/master/clone/external_functions.h b/src/yb/master/clone/external_functions.h
index 2634be85f5..dccc6219cd 100644
--- a/src/yb/master/clone/external_functions.h
+++ b/src/yb/master/clone/external_functions.h
@@ -40,7 +40,8 @@ class CloneStateManagerExternalFunctionsBase {
   virtual Status ListSnapshotSchedules(ListSnapshotSchedulesResponsePB* resp) = 0;
   virtual Status DeleteSnapshot(const TxnSnapshotId& snapshot_id) = 0;
   virtual Result<TxnSnapshotRestorationId> Restore(const TxnSnapshotId&, HybridTime) = 0;
-  virtual Status ListRestorations(const TxnSnapshotId&, ListSnapshotRestorationsResponsePB*) = 0;
+  virtual Status ListRestorations(
+      const TxnSnapshotRestorationId&, ListSnapshotRestorationsResponsePB*) = 0;
 
   // Catalog manager.
   virtual Result<TabletInfoPtr> GetTabletInfo(const TabletId&) = 0;
