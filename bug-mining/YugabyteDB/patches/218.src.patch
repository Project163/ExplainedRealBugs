diff --git a/pg15_tests/test_upgrade_preflight.sh b/pg15_tests/test_upgrade_preflight.sh
index f8d96826c8..1bcafe665a 100755
--- a/pg15_tests/test_upgrade_preflight.sh
+++ b/pg15_tests/test_upgrade_preflight.sh
@@ -123,19 +123,5 @@ ysqlsh <<EOT
 DROP TABLE sql_identifier_test;
 EOT
 
-# Drop postgres database
-ysqlsh <<EOT
-DROP DATABASE postgres;
-EOT
-
-# Check failure
-grep -q "The source cluster does not have the database: \"postgres\"" \
-  <(run_preflight_checks 2>&1)
-
-# Create postgres database
-ysqlsh <<EOT
-CREATE DATABASE postgres;
-EOT
-
 # Run preflight checks again. The final check should pass.
 run_preflight_checks
diff --git a/src/postgres/src/bin/initdb/initdb.c b/src/postgres/src/bin/initdb/initdb.c
index 9c1dc84fc7..fe4dc94bf4 100644
--- a/src/postgres/src/bin/initdb/initdb.c
+++ b/src/postgres/src/bin/initdb/initdb.c
@@ -341,6 +341,19 @@ static bool IsYugaByteLocalNodeInitdb()
 	return IsEnvSet("YB_PG_LOCAL_NODE_INITDB");
 }
 
+bool
+YBIsMajorUpgradeInitDb()
+{
+	static int cached_value = -1;
+	if (cached_value == -1)
+	{
+		const char *env_var_value = getenv("YB_PG_MAJOR_UPGRADE_INITDB");
+		cached_value = env_var_value && strcmp(env_var_value, "true") == 0;
+	}
+
+	return cached_value;
+}
+
 /*
  * pclose() plus useful error reporting
  *
@@ -1998,12 +2011,17 @@ make_template0(FILE *cmdfd)
 		 * version's database OIDs. For a new installation, we use PG's expected
 		 * OID.
 		 */
-		Oid template0_oid = YBGetDatabaseOidFromEnv("template0");
-		if (OidIsValid(template0_oid))
+		if (YBIsMajorUpgradeInitDb())
+		{
+			Oid template0_oid = YBGetDatabaseOidFromEnv("template0");
+			if (!OidIsValid(template0_oid))
+				pg_fatal("missing oid for template0 database");
+
 			PG_CMD_PRINTF("CREATE DATABASE template0 IS_TEMPLATE = true"
-						  " ALLOW_CONNECTIONS = false OID = %u"
-						  " STRATEGY = file_copy;\n\n",
-						  template0_oid);
+							" ALLOW_CONNECTIONS = false OID = %u"
+							" STRATEGY = file_copy;\n\n",
+							template0_oid);
+		}
 		else
 			PG_CMD_PUTS(template0_setup[0]);
 		PG_CMD_PUTS(template0_setup[2]);
@@ -2030,58 +2048,56 @@ make_postgres(FILE *cmdfd)
 	 * OID to postgres and select the file_copy strategy.
 	 */
 	static const char *const postgres_setup[] = {
-		/* YB: Must be kept in sync with the below version using the provided OID. */
 		"CREATE DATABASE postgres OID = " CppAsString2(PostgresDbOid)
 		" STRATEGY = file_copy;\n\n",
 		"COMMENT ON DATABASE postgres IS 'default administrative connection database';\n\n",
 		NULL
 	};
 
-	/*
-	 * Just as we did for template0, and for the same reasons, set the postgres
-	 * database OID to the existing database OID for online upgrade.
-	 */
-	Oid postgres_oid = YBGetDatabaseOidFromEnv("postgres");
-	if (IsYugaByteGlobalClusterInitdb() && OidIsValid(postgres_oid))
-		PG_CMD_PRINTF("CREATE DATABASE postgres OID = %u STRATEGY = file_copy;\n\n",
-					  postgres_oid);
-	else
-		PG_CMD_PUTS(postgres_setup[0]);
-
-	for (line = &postgres_setup[1]; *line; line++)
+	for (line = postgres_setup; *line; line++)
 		PG_CMD_PUTS(*line);
 }
 
-
 /*
- * Create yugabyte database and user.
+ * Create yugabyte user and database.
  */
 static void
 make_yugabyte(FILE *cmdfd)
 {
-	const char *const *line;
-	static const char *const yugabyte_setup[] = {
-		"CREATE USER yugabyte SUPERUSER INHERIT CREATEROLE CREATEDB LOGIN REPLICATION BYPASSRLS PASSWORD 'yugabyte';\n\n",
-		/* YB: Must be kept in sync with the below version using the provided OID. */
-		"CREATE DATABASE yugabyte;\n\n",
+	char *const *line;
+	char **lines;
+	static char *yugabyte_setup[] = {
+		"CREATE USER yugabyte SUPERUSER INHERIT CREATEROLE CREATEDB LOGIN REPLICATION BYPASSRLS PASSWORD $YB_PASSWORD;\n\n",
+		"CREATE DATABASE yugabyte $YB_OID;\n\n",
 		"COMMENT ON DATABASE yugabyte IS 'default administrative connection database';\n\n",
-		NULL
-	};
+		NULL};
+	lines = yugabyte_setup;
 
-	/*
-	 * As we did for template0, set the yugabyte database OID to the existing
-	 * database OID for online upgrade. However, for a clean install, we don't
-	 * have a reserved OID and just let one be assigned.
-	 */
-	Oid yugabyte_oid = YBGetDatabaseOidFromEnv("yugabyte");
+	char oidtok[MAXPGPATH] = "";
+
+	if (YBIsMajorUpgradeInitDb())
+	{
+		/* Create without password. The restore will set the password from the old version. */
+		lines = replace_token(lines, "$YB_PASSWORD", "NULL");
 
-	PG_CMD_PUTS(yugabyte_setup[0]);
-	if (OidIsValid(yugabyte_oid))
-		PG_CMD_PRINTF("CREATE DATABASE yugabyte OID = %u;\n\n", yugabyte_oid);
+		/*
+		 * As we did for template0, set the yugabyte database OID to the
+		 * existing database OID for online upgrade. However, for a clean
+		 * install, we don't have a reserved OID and just let one be assigned.
+		 */
+		Oid yugabyte_oid = YBGetDatabaseOidFromEnv("yugabyte");
+		if (!OidIsValid(yugabyte_oid))
+			pg_fatal("missing oid for yugabyte database");
+
+		snprintf(oidtok, sizeof(oidtok), "OID = %u", yugabyte_oid);
+	}
 	else
-		PG_CMD_PUTS(yugabyte_setup[1]);
+		lines =
+			replace_token(lines, "$YB_PASSWORD", "'yugabyte'");
+
+	lines = replace_token(lines, "$YB_OID", oidtok);
 
-	for (line = &yugabyte_setup[2]; *line; line++)
+	for (line = lines; *line; line++)
 		PG_CMD_PUTS(*line);
 }
 
@@ -2093,25 +2109,11 @@ static void
 make_system_platform(FILE *cmdfd) {
 	const char *const *line;
 	static const char *const system_platform_setup[] = {
-		/* YB: Must be kept in sync with the below version using the provided OID. */
 		"CREATE DATABASE system_platform;\n\n",
 		"COMMENT ON DATABASE system_platform IS 'system database for YugaByte platform';\n\n",
-		NULL
-	};
-
-	/*
-	 * Set the system_platform database OID the same way we do for the yugabyte
-	 * database.
-	 */
-	Oid system_platform_oid = YBGetDatabaseOidFromEnv("system_platform");
+		NULL};
 
-	if (OidIsValid(system_platform_oid))
-		PG_CMD_PRINTF("CREATE DATABASE system_platform OID = %u;\n\n",
-					  system_platform_oid);
-	else
-		PG_CMD_PUTS(system_platform_setup[0]);
-
-	for (line = &system_platform_setup[1]; *line; line++)
+	for (line = system_platform_setup; *line; line++)
 		PG_CMD_PUTS(*line);
 }
 
@@ -2385,7 +2387,7 @@ setlocales(void)
 		fprintf(stderr,
 				_("In YugabyteDB, setting LC_COLLATE to %s and all other locale settings to %s "
 				  "by default. Locale support will be enhanced as part of addressing "
-			  	  "https://github.com/yugabyte/yugabyte-db/issues/1557\n"),
+			  	 	 "https://github.com/yugabyte/yugabyte-db/issues/1557\n"),
 				lc_collate, locale);
 	}
 
@@ -3118,14 +3120,23 @@ initialize_data_directory(void)
 
 	make_template0(cmdfd);
 
-	make_postgres(cmdfd);
-
-	if (IsYugaByteGlobalClusterInitdb()) {
-		/* Create the yugabyte db and user (defaults for YugaByte/ysqlsh) */
+	if (YBIsMajorUpgradeInitDb())
+	{
+		/*
+		 * pg_upgrade uses the yugabyte user and database to prepare all other
+		 * databases.
+		 */
 		make_yugabyte(cmdfd);
+	}
+	else
+	{
+		make_postgres(cmdfd);
 
-		/* Create the system_platform database used by the YugaByte platform UI */
-		make_system_platform(cmdfd);
+		if (IsYugaByteGlobalClusterInitdb())
+		{
+			make_yugabyte(cmdfd);
+			make_system_platform(cmdfd);
+		}
 	}
 
 	PG_CMD_CLOSE;
diff --git a/src/postgres/src/bin/pg_dump/pg_dumpall.c b/src/postgres/src/bin/pg_dump/pg_dumpall.c
index 82d4e14374..e30d5b205d 100644
--- a/src/postgres/src/bin/pg_dump/pg_dumpall.c
+++ b/src/postgres/src/bin/pg_dump/pg_dumpall.c
@@ -843,8 +843,8 @@ dumpRoles(PGconn *conn)
 		}
 
 		/*
-		 * In Yugabyte, there are additional roles created by initdb that emit
-		 * an error if re-created.
+		 * In Yugabyte major upgrade, there are additional roles already created
+		 * by initdb.
 		 */
 		if (IsYugabyteEnabled && binary_upgrade &&
 			strncmp(rolename, "yb_", 3) == 0)
@@ -876,20 +876,11 @@ dumpRoles(PGconn *conn)
 		if (IsYugabyteEnabled && binary_upgrade)
 		{
 			/*
-			 * In Yugabyte, the restore can be run by a different user than the
-			 * one running the dump, so create all users with an if-exists
-			 * check.
+			 * In Yugabyte major upgrade, initdb always creates the yugabyte
+			 * and postgres users.
 			 */
-			appendPQExpBuffer(buf,
-					"\\set role_exists false\n"
-					"SELECT EXISTS(SELECT 1 FROM pg_roles WHERE rolname = '%s')"
-					" AS role_exists \\gset\n"
-					"\\if :role_exists\n"
-					"    \\echo 'Role %s already exists.'\n"
-					"\\else\n"
-					"    CREATE ROLE %s;\n"
-					"\\endif\n",
-					rolename, yb_frolename, rolename);
+			if (strcmp(rolename, "yugabyte") != 0 && strcmp(rolename, "postgres") != 0)
+				appendPQExpBuffer(buf, "CREATE ROLE %s;\n", yb_frolename);
 		}
 		else if (!binary_upgrade ||
 				 strcmp(PQgetvalue(res, i, i_is_current_user), "f") == 0)
diff --git a/src/postgres/src/bin/pg_upgrade/check.c b/src/postgres/src/bin/pg_upgrade/check.c
index 7da841c825..c28851aa31 100644
--- a/src/postgres/src/bin/pg_upgrade/check.c
+++ b/src/postgres/src/bin/pg_upgrade/check.c
@@ -34,7 +34,19 @@ static void check_for_new_tablespace_dir(ClusterInfo *new_cluster);
 static void check_for_user_defined_encoding_conversions(ClusterInfo *cluster);
 static char *get_canonical_locale_name(int category, const char *locale);
 
-static void yb_check_pushdown_is_disabled(ClusterInfo *cluster);
+/* Yugabyte-specific checks */
+
+static void yb_check_pushdown_is_disabled(PGconn *old_cluster_conn);
+
+static void yb_check_system_databases_exist(PGconn *old_cluster_conn);
+
+static void yb_check_user_attributes(PGconn *old_cluster_conn,
+									 const char *user_name,
+									 const char **role_attrs);
+
+static void yb_check_yugabyte_user(PGconn *old_cluster_conn);
+
+static void yb_check_old_cluster_user(PGconn *old_cluster_conn);
 
 /*
  * fix_path_separator
@@ -178,13 +190,26 @@ check_and_dump_old_cluster(bool live_check)
 	if (!is_yugabyte_enabled() && GET_MAJOR_VERSION(old_cluster.major_version) <= 903)
 		old_9_3_check_for_line_data_type_usage(&old_cluster);
 
-	/*
-	 * Yugabyte does not support expression pushdown during major upgrades.
-	 * Only check this when we are ready to actually upgrade the cluster,
-	 * because users may want to run this check long before the upgrade.
-	 */
-	if (is_yugabyte_enabled() && !user_opts.check)
-		yb_check_pushdown_is_disabled(&old_cluster);
+	if (is_yugabyte_enabled())
+	{
+		PGconn *old_cluster_conn = connectToServer(&old_cluster, "template1");
+		/*
+		 * Yugabyte does not support expression pushdown during major upgrades.
+		 * Only check this when we are ready to actually upgrade the cluster,
+		 * because users may want to run this check long before the upgrade.
+		 */
+		if (!user_opts.check)
+		{
+			yb_check_pushdown_is_disabled(old_cluster_conn);
+			yb_check_old_cluster_user(old_cluster_conn);
+		}
+
+		yb_check_yugabyte_user(old_cluster_conn);
+		yb_check_system_databases_exist(old_cluster_conn);
+
+		PQfinish(old_cluster_conn);
+		check_ok();
+	}
 
 	/*
 	 * While not a check option, we do this now because this is the only time
@@ -1558,14 +1583,12 @@ get_canonical_locale_name(int category, const char *locale)
  *	has no other users.
  */
 static void
-yb_check_pushdown_is_disabled(ClusterInfo *cluster)
+yb_check_pushdown_is_disabled(PGconn *old_cluster_conn)
 {
-	PGresult   *res;
-	PGconn	   *conn = connectToServer(cluster, "template1");
-
+	PGresult *res;
 	prep_status("Checking expression pushdown is disabled");
 
-	res = executeQueryOrDie(conn, "SHOW yb_enable_expression_pushdown");
+	res = executeQueryOrDie(old_cluster_conn, "SHOW yb_enable_expression_pushdown");
 
 	if (strncmp(PQgetvalue(res, 0, 0), "off", 3))
 		pg_fatal("Expression pushdown (ysql_yb_enable_expression_pushdown) must "
@@ -1573,7 +1596,103 @@ yb_check_pushdown_is_disabled(ClusterInfo *cluster)
 
 	PQclear(res);
 
-	PQfinish(conn);
+	check_ok();
+}
+
+/*
+ * yb_check_system_databases_exist()
+ *
+ *	All the 3 system database should exist before upgrading
+ */
+static void
+yb_check_system_databases_exist(PGconn *old_cluster_conn)
+{
+	PGresult *res;
+	prep_status("Checking for all 3 system databases");
+
+	res = executeQueryOrDie(old_cluster_conn,
+			"VALUES ('template0'), ('template1'), ('yugabyte') EXCEPT SELECT datname FROM pg_database;");
+
+	if (PQntuples(res) != 0)
+		pg_fatal("Missing system database %s\n", PQgetvalue(res, 0, 0));
+
+	PQclear(res);
+
+	check_ok();
+}
+
+/*
+ * yb_check_user_attributes()
+ *
+ *	Make sure the user have the required attributes.
+ */
+static void
+yb_check_user_attributes(PGconn *old_cluster_conn, const char *user_name,
+						 const char **role_attrs)
+{
+	PQExpBufferData buf;
+	PGresult *res;
+	const char **role_attr;
+	bool first_attribute = true;
+
+	prep_status("Checking '%s' user attibutes", user_name);
+
+	initPQExpBuffer(&buf);
+	for (role_attr = role_attrs; *role_attr != NULL; role_attr++)
+	{
+		if (!first_attribute)
+			appendPQExpBufferStr(&buf, ", ");
+		first_attribute = false;
+		appendPQExpBufferStr(&buf, *role_attr);
+	}
+
+	res = executeQueryOrDie(old_cluster_conn,
+							"SELECT %s FROM pg_catalog.pg_roles WHERE rolname = '%s'",
+							buf.data, user_name);
+
+	if (PQntuples(res) != 1)
+		pg_fatal("The '%s' user is missing\n", user_name);
+
+	for (role_attr = role_attrs; *role_attr != NULL; role_attr++)
+	{
+		if (strcmp(PQgetvalue(res, 0, PQfnumber(res, *role_attr)), "f") == 0)
+			pg_fatal("The '%s' user is missing the '%s' attribute\n", user_name,
+					 *role_attr);
+	}
 
+	termPQExpBuffer(&buf);
+	PQclear(res);
 	check_ok();
 }
+
+/*
+ * yb_check_yugabyte_user()
+ *
+ *	Make sure yugabyte user has the required attributes.
+ */
+static void
+yb_check_yugabyte_user(PGconn *old_cluster_conn)
+{
+	static const char *role_attrs[] = {"rolsuper",		"rolinherit",
+									   "rolcreaterole", "rolcreatedb",
+									   "rolcanlogin",	"rolreplication",
+									   "rolbypassrls",	NULL};
+
+	yb_check_user_attributes(old_cluster_conn, "yugabyte", role_attrs);
+}
+
+/*
+ * yb_check_old_cluster_user()
+ *
+ *	Make sure user used to dump the old cluster has required attributes.
+ */
+static void
+yb_check_old_cluster_user(PGconn *old_cluster_conn)
+{
+	prep_status("Checking attributes of the user used to access the old "
+				"cluster");
+
+	static const char *role_attributes[] = {"rolsuper", "rolcanlogin", NULL};
+	yb_check_user_attributes(old_cluster_conn, old_cluster.yb_user,
+							 role_attributes);
+}
diff --git a/src/postgres/src/bin/pg_upgrade/pg_upgrade.c b/src/postgres/src/bin/pg_upgrade/pg_upgrade.c
index 35df9fa42e..f5670fd6b3 100644
--- a/src/postgres/src/bin/pg_upgrade/pg_upgrade.c
+++ b/src/postgres/src/bin/pg_upgrade/pg_upgrade.c
@@ -517,7 +517,7 @@ create_new_objects(void)
 				  true,
 				  true,
 				  "\"%s/pg_restore\" %s %s --exit-on-error --verbose "
-				  "--dbname postgres \"%s/%s\"",
+				  "--dbname yugabyte \"%s/%s\"",
 				  new_cluster.bindir,
 				  cluster_conn_opts(&new_cluster),
 				  create_opts,
@@ -543,15 +543,11 @@ create_new_objects(void)
 		snprintf(log_file_name, sizeof(log_file_name), DB_DUMP_LOG_FILE_MASK, old_db->db_oid);
 
 		/*
-		 * postgres database will already exist in the target installation, so
+		 * yugabyte database will already exist in the target installation, so
 		 * tell pg_restore to drop and recreate it; otherwise we would fail to
 		 * propagate its database-level properties.
 		 */
-		if (strcmp(old_db->db_name, "postgres") == 0)
-			create_opts = "--clean --create";
-		else if (strcmp(old_db->db_name, "yugabyte") == 0)
-			create_opts = "--clean --create";
-		else if (strcmp(old_db->db_name, "system_platform") == 0)
+		if (strcmp(old_db->db_name, "yugabyte") == 0)
 			create_opts = "--clean --create";
 		else
 			create_opts = "--create";
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
index a22ee323c8..e75098689d 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
@@ -11,6 +11,8 @@
 // under the License.
 //
 
+#include <regex>
+
 #include "yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h"
 
 #include "yb/util/backoff_waiter.h"
@@ -1029,16 +1031,15 @@ class Pg15UpgradeTestWithAuth : public Pg15UpgradeTest {
     Pg15UpgradeTest::SetUpOptions(opts);
   }
 
-  Status ValidateUpgradeCompatibility() override {
+  Status ValidateUpgradeCompatibility(const std::string& user_name = "yugabyte") override {
     setenv("PGPASSWORD", "yugabyte", /*overwrite=*/true);
-    return Pg15UpgradeTest:: ValidateUpgradeCompatibility();
+    return Pg15UpgradeTest::ValidateUpgradeCompatibility(user_name);
   }
 };
 
 // Make sure upgrade succeeds in non auth universes even if there is no tserver on the master node.
 TEST_F(Pg15UpgradeTest, NoTserverOnMasterNode) {
-  static const MonoDelta no_delay_between_nodes = 0s;
-  ASSERT_OK(RestartAllMastersInCurrentVersion(no_delay_between_nodes));
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
 
   auto master_tserver = ASSERT_RESULT(StopMasterLeaderTServer());
 
@@ -1046,18 +1047,16 @@ TEST_F(Pg15UpgradeTest, NoTserverOnMasterNode) {
   ASSERT_OK(master_tserver->Restart());
   ASSERT_OK(WaitForClusterToStabilize());
 
-  ASSERT_OK(RestartAllTServersInCurrentVersion(no_delay_between_nodes));
+  ASSERT_OK(RestartAllTServersInCurrentVersion(kNoDelayBetweenNodes));
   ASSERT_OK(FinalizeUpgrade());
 }
 
 // If there is no tserver on the master node make sure the upgrade fails unless the yugabyte_upgrade
 // user is created.
 TEST_F(Pg15UpgradeTestWithAuth, NoTserverOnMasterNode) {
-  static const MonoDelta no_delay_between_nodes = 0s;
-
 // Disabled the rollback step on debug builds and MacOS because it times out.
 #if !defined(__APPLE__) && defined(NDEBUG)
-  ASSERT_OK(RestartAllMastersInCurrentVersion(no_delay_between_nodes));
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
 
   {
     auto master_tserver = ASSERT_RESULT(StopMasterLeaderTServer());
@@ -1069,7 +1068,7 @@ TEST_F(Pg15UpgradeTestWithAuth, NoTserverOnMasterNode) {
 #endif
 
   // Rollback and create the upgrade user.
-  ASSERT_OK(RestartAllMastersInOldVersion(no_delay_between_nodes));
+  ASSERT_OK(RestartAllMastersInOldVersion(kNoDelayBetweenNodes));
 
   const auto password = "yugabyte";
   // Set the password in the environment variable, which will propagate it to all child processes
@@ -1079,7 +1078,7 @@ TEST_F(Pg15UpgradeTestWithAuth, NoTserverOnMasterNode) {
   ASSERT_OK(ExecuteStatement(Format(
       "CREATE USER $0 WITH SUPERUSER PASSWORD '$1'", FLAGS_ysql_major_upgrade_user, password)));
 
-  ASSERT_OK(RestartAllMastersInCurrentVersion(no_delay_between_nodes));
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
 
   auto master_tserver = ASSERT_RESULT(StopMasterLeaderTServer());
 
@@ -1087,7 +1086,7 @@ TEST_F(Pg15UpgradeTestWithAuth, NoTserverOnMasterNode) {
   ASSERT_OK(master_tserver->Restart());
   ASSERT_OK(WaitForClusterToStabilize());
 
-  ASSERT_OK(RestartAllTServersInCurrentVersion(no_delay_between_nodes));
+  ASSERT_OK(RestartAllTServersInCurrentVersion(kNoDelayBetweenNodes));
   ASSERT_OK(FinalizeUpgrade());
 }
 
@@ -1095,6 +1094,14 @@ TEST_F(Pg15UpgradeTestWithAuth, UpgradeAuthEnabledUniverse) {
   ASSERT_OK(TestUpgradeWithSimpleTable());
 }
 
+TEST_F(Pg15UpgradeTestWithAuth, NoYugabyteUserPassword) {
+  ASSERT_OK(ExecuteStatement("ALTER USER yugabyte WITH PASSWORD NULL"));
+  ASSERT_NOK_STR_CONTAINS(cluster_->ConnectToDB(), "password authentication failed");
+
+  // We should still be able to upgrade the cluster.
+  ASSERT_OK(UpgradeClusterToCurrentVersion(kNoDelayBetweenNodes));
+}
+
 TEST_F(Pg15UpgradeTest, GlobalBreakingDDL) {
   ASSERT_OK(ExecuteStatements(
     {"CREATE USER test",
@@ -1415,7 +1422,7 @@ TEST_F(Pg15UpgradeTest, CheckPushdownIsDisabled) {
   ASSERT_OK(ValidateUpgradeCompatibility());
 
   // However, when we actually run the YSQL upgrade, pg_upgrade will error if pushdown is enabled.
-  ASSERT_NOK(UpgradeClusterToMixedMode());
+  ASSERT_NOK_STR_CONTAINS(UpgradeClusterToMixedMode(), kPgUpgradeFailedError);
 }
 
 TEST_F(Pg15UpgradeSequenceTest, Sequences) {
@@ -1483,4 +1490,73 @@ TEST_F(Pg15UpgradeSequenceTest, IdentityColumn) {
     ASSERT_NO_FATALS(Add3Rows(conn, kSequencePg11, seq_val_pg11_));
   }
 }
+
+TEST_F(Pg15UpgradeTest, UsersAndRoles) {
+  auto escape_single_quote = [](const std::string& str) {
+    return std::regex_replace(str, std::regex("'"), "''");
+  };
+  auto escape_double_quote = [](const std::string& str) {
+    return std::regex_replace(str, std::regex("\""), "\"\"");
+  };
+
+  auto ts = cluster_->tablet_server(0);
+
+  // Make sure pg_upgrade --check fails if the yugabyte user is not a superuser.
+  {
+    const auto postgres_user = "postgres";
+    const auto pg_conn_settings = pgwrapper::PGConnSettings{
+        .host = ts->bind_host(),
+        .port = ts->ysql_port(),
+        .dbname = "yugabyte",
+        .user = postgres_user};
+
+    auto pg_conn = ASSERT_RESULT(pgwrapper::PGConnBuilder(pg_conn_settings).Connect());
+    ASSERT_OK(pg_conn.Execute("DROP USER yugabyte"));
+    ASSERT_NOK_STR_CONTAINS(ValidateUpgradeCompatibility(postgres_user), kPgUpgradeFailedError);
+
+    ASSERT_OK(pg_conn.Execute("CREATE USER yugabyte"));
+    ASSERT_NOK_STR_CONTAINS(ValidateUpgradeCompatibility(postgres_user), kPgUpgradeFailedError);
+
+    ASSERT_OK(pg_conn.Execute("DROP USER yugabyte"));
+    ASSERT_OK(pg_conn.Execute(
+        "CREATE USER yugabyte SUPERUSER INHERIT CREATEROLE CREATEDB LOGIN REPLICATION BYPASSRLS"));
+    ASSERT_OK(ValidateUpgradeCompatibility(postgres_user));
+  }
+
+  // Change the yugabyte password to make sure if works after the upgrade.
+  // Including quotes in password to make sure it works.
+  const auto new_yb_password = "yb_\"secure\"\"_'pass''";
+  {
+    // Escape single quotes in the sql string.
+    ASSERT_OK(ExecuteStatement(
+        Format("ALTER USER yugabyte PASSWORD '$0'", escape_single_quote(new_yb_password))));
+  }
+
+  const auto conn_settings = pgwrapper::PGConnSettings{
+      .host = ts->bind_host(),
+      .port = ts->ysql_port(),
+      .dbname = "yugabyte",
+      .user = "yugabyte",
+      .password = escape_double_quote(new_yb_password)};
+
+  auto conn = ASSERT_RESULT(pgwrapper::PGConnBuilder(conn_settings).Connect());
+
+  // Create users with special characters in their names.
+  auto special_role_names = {"user with space", "user_\"_with_\"\"_different' quotes''"};
+  for (const auto& role_name : special_role_names) {
+    // Escape double quotes in the sql string.
+    ASSERT_OK(conn.ExecuteFormat("CREATE ROLE \"$0\"", escape_double_quote(role_name)));
+  }
+
+  ASSERT_OK(UpgradeClusterToCurrentVersion(kNoDelayBetweenNodes));
+
+  conn = ASSERT_RESULT(pgwrapper::PGConnBuilder(conn_settings).Connect());
+  for (const auto& role_name : special_role_names) {
+    LOG(INFO) << "Checking role: " << role_name;
+    auto res_role_name = ASSERT_RESULT(conn.FetchRow<std::string>(Format(
+        "SELECT rolname FROM pg_roles WHERE rolname = '$0'", escape_single_quote(role_name))));
+    ASSERT_STR_EQ(role_name, res_role_name);
+  }
+}
+
 }  // namespace yb
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.cc b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.cc
index 82eb401713..09400a814c 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.cc
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.cc
@@ -41,7 +41,7 @@ void Pg15UpgradeTestBase::SetUp() {
       "RESET yb_non_ddl_txn_for_sys_tables_allowed"}));
 }
 
-Status Pg15UpgradeTestBase::ValidateUpgradeCompatibility() {
+Status Pg15UpgradeTestBase::ValidateUpgradeCompatibility(const std::string& user_name) {
   const auto tserver = cluster_->tablet_server(0);
   const auto data_path = JoinPathSegments(tserver->GetDataDirs().front(), "../../pg_data");
 
@@ -50,7 +50,7 @@ Status Pg15UpgradeTestBase::ValidateUpgradeCompatibility() {
     "--old-datadir", data_path,
     "--old-host", tserver->bind_host(),
     "--old-port", AsString(tserver->pgsql_rpc_port()),
-    "--username", "yugabyte",
+    "--username", user_name,
     "--check"
   };
 
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h
index f379feb094..e9703e238c 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h
@@ -33,9 +33,10 @@ class Pg15UpgradeTestBase : public UpgradeTestBase {
   static constexpr size_t kMixedModeTserverPg15 = 0;
   static constexpr size_t kMixedModeTserverPg11 = 1;
   static constexpr std::optional<size_t> kAnyTserver = std::nullopt;
+  static constexpr auto kPgUpgradeFailedError = "pg_upgrade' terminated with non-zero exit status";
 
   // Run pg_upgrade --check
-  virtual Status ValidateUpgradeCompatibility();
+  virtual Status ValidateUpgradeCompatibility(const std::string& user_name = "yugabyte");
 
   // Restarts all masters in the current version, runs ysql major version upgrade, and restarts
   // tserver kMixedModeTserverPg15 in the current version. Other tservers are kept in the pg11
diff --git a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
index d1d808b97c..1a88d61bc5 100644
--- a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
+++ b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
@@ -215,6 +215,8 @@ bool IsUpgradeSupported(const std::string& from_version) {
 
 }  // namespace
 
+const MonoDelta UpgradeTestBase::kNoDelayBetweenNodes = 0s;
+
 UpgradeTestBase::UpgradeTestBase(const std::string& from_version)
     : old_version_info_(CHECK_RESULT(GetBuildInfoForVersion(from_version))) {
   LOG(INFO) << "Old version: " << old_version_info_.version << ": "
diff --git a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h
index 189c440711..4cbda4babe 100644
--- a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h
+++ b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h
@@ -39,6 +39,7 @@ class UpgradeTestBase : public ExternalMiniClusterITestBase {
   void SetUp() override;
 
  protected:
+  static const MonoDelta kNoDelayBetweenNodes;
   void SetUpOptions(ExternalMiniClusterOptions& opts) override;
   Status StartClusterInOldVersion();
   Status StartClusterInOldVersion(const ExternalMiniClusterOptions& options);
diff --git a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
index adb54ba002..17cadca897 100644
--- a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
@@ -28,8 +28,6 @@ namespace yb {
 constexpr auto kExpectedDdlError =
     "YSQL DDLs, and catalog modifications are not allowed during a major YSQL upgrade";
 
-static const MonoDelta kNoDelayBetweenNodes = 0s;
-
 class YsqlMajorUpgradeDdlBlockingTest : public Pg15UpgradeTestBase {
  public:
   YsqlMajorUpgradeDdlBlockingTest() = default;
@@ -206,4 +204,51 @@ TEST_F(YsqlMajorUpgradeDdlBlockingTest, TestFailedUpgrade) {
   ASSERT_OK(RunDdlFunctions(kMixedModeTserverPg11));
 }
 
+// Make sure we can upgrade even when postgres, and system_platform databases do not exist.
+// Make sure prechecks fail if yugabyte database does not exist.
+// Make sure we cannot create or drop databases during the upgrade.
+TEST_F(YsqlMajorUpgradeDdlBlockingTest, CreateAndDropDBs) {
+  {
+    auto template1_conn = ASSERT_RESULT(cluster_->ConnectToDB("template1", std::nullopt));
+    ASSERT_OK(template1_conn.ExecuteFormat("DROP DATABASE postgres"));
+    ASSERT_OK(template1_conn.ExecuteFormat("DROP DATABASE system_platform"));
+    ASSERT_OK(template1_conn.ExecuteFormat("DROP DATABASE yugabyte"));
+
+    ASSERT_NOK_STR_CONTAINS(ValidateUpgradeCompatibility(), kPgUpgradeFailedError);
+
+    ASSERT_OK(template1_conn.ExecuteFormat("CREATE DATABASE yugabyte"));
+    ASSERT_OK(ValidateUpgradeCompatibility());
+  }
+
+  ASSERT_OK(CreateSimpleTable());
+  ASSERT_OK(ExecuteStatement("CREATE DATABASE new_db1"));
+
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
+
+  auto validate_db_ddls_fail = [this] {
+    // TODO: Enable after CreateDatabase blocking is properly implemented.
+    // ASSERT_NOK_STR_CONTAINS(
+    //     ExecuteStatement("CREATE DATABASE new_db2"),
+    //     "No new namespaces can be created during a major YSQL upgrade");
+    ASSERT_NOK_STR_CONTAINS(ExecuteStatement("DROP DATABASE new_db1"), kExpectedDdlError);
+  };
+
+  ASSERT_NO_FATALS(validate_db_ddls_fail());
+
+  ASSERT_OK(PerformYsqlMajorCatalogUpgrade());
+
+  ASSERT_NO_FATALS(validate_db_ddls_fail());
+
+  ASSERT_OK(RestartAllTServersInCurrentVersion(kNoDelayBetweenNodes));
+
+  ASSERT_NO_FATALS(validate_db_ddls_fail());
+
+  ASSERT_OK(FinalizeUpgrade());
+
+  ASSERT_OK(ExecuteStatement("CREATE DATABASE new_db2"));
+  ASSERT_OK(ExecuteStatement("DROP DATABASE new_db1"));
+
+  ASSERT_OK(InsertRowInSimpleTableAndValidate());
+}
+
 }  // namespace yb
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
index 4cdec73c4c..5d55a8cd52 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
@@ -323,23 +323,16 @@ Status YsqlInitDBAndMajorUpgradeHandler::RunMajorVersionCatalogUpgrade(const Lea
 Result<YsqlInitDBAndMajorUpgradeHandler::DbNameToOidList>
 YsqlInitDBAndMajorUpgradeHandler::GetDbNameToOidListForMajorUpgrade() {
   DbNameToOidList db_name_to_oid_list;
-  // Store DB name to OID mapping for all system databases except template1. This mapping will be
-  // passed to initdb so that the system database OIDs will match. The template1 database is
-  // special because it's created by the bootstrap phase of initdb (see file comment for initdb.c
-  // for more details). The template1 database always has OID 1.
-  {
-    std::vector<scoped_refptr<NamespaceInfo>> all_namespaces;
-    catalog_manager_.GetAllNamespaces(&all_namespaces);
-    for (const auto& ns_info : all_namespaces) {
-      if (ns_info->database_type() != YQL_DATABASE_PGSQL) {
-        continue;
-      }
-      uint32_t oid = VERIFY_RESULT(GetPgsqlDatabaseOid(ns_info->id()));
-      if (oid < kPgFirstNormalObjectId && oid != kTemplate1Oid) {
-        db_name_to_oid_list.push_back({ns_info->name(), oid});
-      }
-    }
+  // Retrieve the OID for template0 and yugabyte databases. These two and the template1 are the only
+  // databases created by initdb in major upgrade mode. template1 is always hardcoded to use oid 1
+  // and we cannot asign a different oid for it, so it is skipped.
+  for (const auto& namespace_name : {"template0", "yugabyte"}) {
+    auto namespace_id =
+        VERIFY_RESULT(catalog_manager_.GetNamespaceId(YQL_DATABASE_PGSQL, namespace_name));
+    auto oid = VERIFY_RESULT(GetPgsqlDatabaseOid(namespace_id));
+    db_name_to_oid_list.push_back({namespace_name, oid});
   }
+
   return db_name_to_oid_list;
 }
 
