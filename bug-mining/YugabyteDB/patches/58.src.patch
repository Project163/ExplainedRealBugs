diff --git a/src/yb/common/path-handler-util.cc b/src/yb/common/path-handler-util.cc
index 43155386d3..89ba8f2939 100644
--- a/src/yb/common/path-handler-util.cc
+++ b/src/yb/common/path-handler-util.cc
@@ -21,6 +21,14 @@ namespace {
 
 const char* const kSortAndFilterTableScript = R"(
 <script>
+function castIfNumber(elem) {
+ return elem.length ?
+          (elem.length > 14 || isNaN(Number(elem)) ?
+            elem.toLowerCase() :
+            Number(elem)) :
+          "~";
+}
+
 function sortTable(table_id, n) {
   var asc_symb = ' <span style="color: grey">\u25B2</span>';
   var desc_symb = ' <span style="color: grey">\u25BC</span>';
@@ -53,12 +61,8 @@ function sortTable(table_id, n) {
       var swap = false;
       var x = table.rows[i].getElementsByTagName("TD")[n];
       var y = table.rows[i + 1].getElementsByTagName("TD")[n];
-      var cmpX = x.innerHTML.length?
-        isNaN(Number(x.innerHTML))? x.innerHTML.toLowerCase():Number(x.innerHTML):
-        "~";
-      var cmpY = y.innerHTML.length?
-        isNaN(Number(y.innerHTML))?y.innerHTML.toLowerCase():Number(y.innerHTML):
-        "~";
+      var cmpX = castIfNumber(x.innerHTML);
+      var cmpY = castIfNumber(y.innerHTML);
 
       if (asc) {
         if (cmpX > cmpY) {
diff --git a/src/yb/common/path-handler-util.h b/src/yb/common/path-handler-util.h
index 8bd8321971..c15ada4db6 100644
--- a/src/yb/common/path-handler-util.h
+++ b/src/yb/common/path-handler-util.h
@@ -42,7 +42,9 @@
     const auto table_filter = table_id + "_filter"; \
     output << GenerateTableFilterBox(table_filter, table_name); \
     uint32 _header_cnt = 0; \
-    output << "<table class='table table-striped' id='" << table_name << "'>\n"; \
+    output << "<table class='table table-striped' id='" << table_name \
+           << "' style='border: solid; border-width: thin;padding: 10px 10px;border-color:  " \
+              "#a8a8a8;'>\n"; \
     output << "<tr>"; \
     BOOST_PP_SEQ_FOR_EACH( \
         INTERNAL_HTML_INTERNAL_PRINT_HEADER_FIELDS, table_name, \
diff --git a/src/yb/master/master-path-handlers.cc b/src/yb/master/master-path-handlers.cc
index 3872af10c4..699e415bd8 100644
--- a/src/yb/master/master-path-handlers.cc
+++ b/src/yb/master/master-path-handlers.cc
@@ -74,6 +74,7 @@
 #include "yb/master/ts_manager.h"
 
 #include "yb/master/xcluster/xcluster_manager_if.h"
+#include "yb/master/xcluster/xcluster_status.h"
 #include "yb/server/webserver.h"
 #include "yb/server/webui_util.h"
 
@@ -139,6 +140,25 @@ std::optional<HostPortPB> GetPublicHttpHostPort(const ServerRegistrationPB& regi
 
 std::string BoolToString(bool val) { return val ? "true" : "false"; }
 
+class AutoFieldsetScope {
+ public:
+  explicit AutoFieldsetScope(std::stringstream& output, const std::string& name) : output_(output) {
+    output_ << kFieldsetStart;
+    output << kFieldsetLegendStart << name << kFieldsetLegendEnd;
+  }
+  ~AutoFieldsetScope() { output_ << kFieldsetEnd; }
+
+ private:
+  static constexpr auto kFieldsetStart =
+      "<br><fieldset style=\"border: solid; border-width: thin;padding: 10px 10px;border-color:  "
+      "#a8a8a8;\">\n";
+  static constexpr auto kFieldsetEnd = "</fieldset>\n";
+  static constexpr auto kFieldsetLegendStart =
+      "<legend visible=\"true\" style=\"width:auto;padding: 0px 10px;\">";
+  static constexpr auto kFieldsetLegendEnd = "</legend>\n";
+
+  std::stringstream& output_;
+};
 }  // namespace
 
 using consensus::RaftPeerPB;
@@ -2810,195 +2830,134 @@ void MasterPathHandlers::HandleGetClusterConfigJSON(
   jw.Protobuf(config);
 }
 
-Status MasterPathHandlers::GetXClusterConfigs(
-    SysXClusterConfigEntryPB* xcluster_config, SysClusterConfigEntryPB* cluster_config,
-    GetReplicationStatusResponsePB* xcluster_status,
-    std::vector<SysUniverseReplicationEntryPB>* replication_infos) {
-  RETURN_NOT_OK(master_->xcluster_manager()->GetXClusterConfigEntryPB(xcluster_config));
-
-  GetReplicationStatusRequestPB req;
-  RETURN_NOT_OK(master_->catalog_manager_impl()->GetReplicationStatus(
-      &req, xcluster_status, /*rpc=*/nullptr));
-
-  *replication_infos = master_->catalog_manager_impl()->GetAllXClusterUniverseReplicationInfos();
-
-  RETURN_NOT_OK(master_->catalog_manager()->GetClusterConfig(cluster_config));
-
-  return Status::OK();
-}
-
 void MasterPathHandlers::GetXClusterJSON(std::stringstream& output, bool pretty) {
   JsonWriter jw(&output, pretty ? JsonWriter::PRETTY : JsonWriter::COMPACT);
   master_->catalog_manager()->AssertLeaderLockAcquiredForReading();
 
-  SysXClusterConfigEntryPB xcluster_config;
-  SysClusterConfigEntryPB cluster_config;
-  GetReplicationStatusResponsePB xcluster_status;
-  std::vector<SysUniverseReplicationEntryPB> replication_infos;
-  Status s =
-      GetXClusterConfigs(&xcluster_config, &cluster_config, &xcluster_status, &replication_infos);
+  jw.StartObject();
+  auto s = master_->xcluster_manager()->PopulateXClusterStatusJson(jw);
   if (!s.ok()) {
-    jw.StartObject();
     jw.String("error");
     jw.String(s.ToString());
-    jw.EndObject();
-    return;
   }
-
-  jw.StartObject();
-  jw.String("version");
-  jw.Int64(xcluster_config.version());
-  jw.String("xcluster_producer_registry");
-  jw.Protobuf(xcluster_config.xcluster_producer_registry());
-  jw.String("replication_status");
-  jw.Protobuf(xcluster_status);
-
-  jw.String("replication_infos");
-  jw.StartArray();
-  for (auto const& replication_info : replication_infos) {
-    jw.Protobuf(replication_info);
-  }
-  jw.EndArray();
-
-  jw.String("consumer_registry");
-  jw.Protobuf(cluster_config.consumer_registry());
   jw.EndObject();
+  return;
 }
 
-void MasterPathHandlers::HandleGetXClusterConfigJSON(
+void MasterPathHandlers::HandleGetXClusterJSON(
     const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
   GetXClusterJSON(resp->output, /*pretty=*/false);
 }
 
-void MasterPathHandlers::HandleGetXClusterConfig(
-    const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
-  std::stringstream& output = resp->output;
-
-  output << "<h1>xCluster state</h1>\n";
-  std::stringstream json_output;
-  GetXClusterJSON(json_output, /*pretty=*/true);
-  output << EscapeForHtmlToString(json_output.str());
-}
-
 void MasterPathHandlers::HandleXCluster(
     const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
   std::stringstream& output = resp->output;
   master_->catalog_manager()->AssertLeaderLockAcquiredForReading();
+  auto xcluster_status_result = master_->xcluster_manager()->GetXClusterStatus();
 
-  SysXClusterConfigEntryPB xcluster_config;
-  SysClusterConfigEntryPB cluster_config;
-  GetReplicationStatusResponsePB replication_status;
-  std::vector<SysUniverseReplicationEntryPB> replication_infos;
-  Status s = GetXClusterConfigs(
-      &xcluster_config, &cluster_config, &replication_status, &replication_infos);
-
-  if (!s.ok()) {
-    output << "<div class=\"alert alert-warning\">" << EscapeForHtmlToString(s.ToString())
-           << "</div>";
+  if (!xcluster_status_result.ok()) {
+    output << "<div class=\"alert alert-warning\">"
+           << EscapeForHtmlToString(xcluster_status_result.status().ToString()) << "</div>";
     return;
   }
-  const auto& consumer_registry = cluster_config.consumer_registry();
+  const auto& xcluster_status = *xcluster_status_result;
 
-  if (!xcluster_config.has_xcluster_producer_registry() &&
-      consumer_registry.producer_map_size() == 0 && replication_infos.empty()) {
+  if (!xcluster_status.IsEnabled()) {
     output << "<h3>xCluster replication is not enabled</h3 >\n";
     return;
   }
+  output << "<h1>xCluster state</h1>\n";
 
-  std::unordered_map<std::string, std::string> stream_status;
-
-  for (const auto& table_stream_status : replication_status.statuses()) {
-    if (!table_stream_status.errors_size()) {
-      continue;
-    }
-    std::stringstream errors;
-    bool first = true;
-    for (const auto& error : table_stream_status.errors()) {
-      errors << (first ? "" : ";") << error.ShortDebugString();
-      first = false;
+  uint32 outbound_group_table_id = 0;
+  if (!xcluster_status.outbound_replication_group_statuses.empty()) {
+    output << "<h3>Outbound ReplicationGroups</h3>\n";
+    for (const auto& outbound_replication_group :
+         xcluster_status.outbound_replication_group_statuses) {
+      auto group_fs = AutoFieldsetScope(
+          output, Format("Group: $0", outbound_replication_group.replication_group_id));
+
+      output << "<pre class=\"prettyprint\">"
+             << "state: " << outbound_replication_group.state;
+      if (!outbound_replication_group.target_universe_info.empty()) {
+        output << "\ntarget_universe_info: " << outbound_replication_group.target_universe_info;
+      }
+      output << "</pre>";
+
+      for (const auto& namespace_status : outbound_replication_group.namespace_statuses) {
+        auto namespace_fs =
+            AutoFieldsetScope(output, Format("Namespace: $0", namespace_status.namespace_name));
+
+        output << "<pre class=\"prettyprint\">";
+        output << "NamespaceId: " << namespace_status.namespace_id
+               << "\nstate: " << namespace_status.state << "\ninitial_bootstrap_required: "
+               << BoolToString(namespace_status.initial_bootstrap_required)
+               << "\nstatus: " << namespace_status.status;
+        output << "</pre>";
+
+        HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(
+            outbound_replication_group, outbound_group_table_id, "Table Id", "Stream Id", "State",
+            "Checkpointing", "Part of initial bootstrap");
+        outbound_group_table_id++;
+
+        for (const auto& table_status : namespace_status.table_statuses) {
+          HTML_PRINT_TABLE_ROW(
+              table_status.table_id, table_status.stream_id, table_status.state,
+              BoolToString(table_status.is_checkpointing),
+              BoolToString(table_status.is_part_of_initial_bootstrap));
+        }
+        HTML_END_TABLE;
+      }
     }
-
-    stream_status[table_stream_status.stream_id()] = errors.str();
   }
 
-  output << "<h1>xCluster state</h1>\n";
-
-  if (replication_infos.empty()) {
-    return;
+  if (!xcluster_status.outbound_table_stream_statuses.empty()) {
+    output << "<br><h3>Outbound table streams</h3>\n";
+    HTML_PRINT_TABLE_WITH_HEADER_ROW(outbound_table_streams, "Table Id", "Stream Id", "State");
+    for (const auto& table_status : xcluster_status.outbound_table_stream_statuses) {
+      HTML_PRINT_TABLE_ROW(table_status.table_id, table_status.stream_id, table_status.state);
+    }
+    HTML_END_TABLE;
   }
 
-  output << "<h3>xCluster inbound ReplicationGroups</h3>\n";
+  output << "<br><h3>Inbound ReplicationGroups</h3>\n";
   output << "<pre class=\"prettyprint\">"
-         << "XClusterRole: " << XClusterRole_Name(consumer_registry.role())
-         << "\ntransactional: " << consumer_registry.transactional() << "</pre>";
+         << "XClusterRole: " << xcluster_status.role
+         << "\ntransactional: " << BoolToString(xcluster_status.transactional) << "</pre>";
+  output << "</pre>";
 
-  for (size_t i = 0; i < replication_infos.size(); i++) {
-    const auto& replication_info = replication_infos[i];
-    auto* producer_map =
-        FindOrNull(consumer_registry.producer_map(), replication_info.replication_group_id());
+  uint32 inbound_group_table_id = 0;
+  for (const auto& inbound_replication_group : xcluster_status.inbound_replication_group_statuses) {
+    auto group_fs = AutoFieldsetScope(
+        output, Format("Group: $0", inbound_replication_group.replication_group_id));
 
-    output << "\n\n<h4>ReplicationGroup: " << replication_info.replication_group_id() << "</h4>\n";
     output << "<pre class=\"prettyprint\">"
-           << "state: " << SysUniverseReplicationEntryPB::State_Name(replication_info.state())
-           << "\ntransactional: " << BoolToString(replication_info.transactional())
-           << "\nvalidated_local_auto_flags_config_version: "
-           << replication_info.validated_local_auto_flags_config_version();
-    if (producer_map) {
-      output << "\nmaster_addrs: ";
-      bool first = true;
-      for (const auto& add : producer_map->master_addrs()) {
-        output << (first ? "" : ",") << add.ShortDebugString();
-        first = false;
-      }
-      output << "\ndisable_stream: " << BoolToString(producer_map->disable_stream());
-      output << "\ncompatible_auto_flag_config_version: "
-             << producer_map->compatible_auto_flag_config_version();
-      output << "\nvalidated_auto_flags_config_version: "
-             << producer_map->validated_auto_flags_config_version();
-    }
+           << "state: " << inbound_replication_group.state
+           << "\ndisable_stream: " << BoolToString(inbound_replication_group.disable_stream)
+           << "\ntransactional: " << BoolToString(inbound_replication_group.transactional)
+           << "\nmaster_addrs: " << inbound_replication_group.master_addrs;
+    if (!inbound_replication_group.db_scoped_info.empty()) {
+      output << "\ndb_scoped_info: " << inbound_replication_group.db_scoped_info;
+    }
+    output << "\nvalidated_local_auto_flags_config_version: "
+           << inbound_replication_group.validated_local_auto_flags_config_version
+           << "\nvalidated_remote_auto_flags_config_version: "
+           << inbound_replication_group.validated_remote_auto_flags_config_version
+           << "\ncompatible_auto_flag_config_version: "
+           << inbound_replication_group.compatible_auto_flag_config_version;
     output << "</pre>";
-    yb::ToString(1);
 
     HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(
-        inbound_replication_group, i, "Producer Table Id", "Stream Id", "Consumer Table Id",
-        "Producer Tablet Count", "Consumer Tablet Count", "Local tserver optimized",
-        "Producer schema version", "Consumer schema version", "Status");
-
-    for (int j = 0; j < replication_info.tables_size(); j++) {
-      auto& producer_table_id = replication_info.tables(j);
-      std::string status, stream_id, consumer_table_id;
-      uint32 producer_tablet_count = 0, consumer_tablet_count = 0, producer_schema_version = 0,
-             consumer_schema_version = 0;
-      bool local_tserver_optimized = false;
-      auto* stream_id_it = FindOrNull(replication_info.table_streams(), producer_table_id);
-      if (stream_id_it) {
-        stream_id = *stream_id_it;
-        auto it = FindOrNull(stream_status, stream_id);
-        status = it ? *it : "OK";
-
-        if (producer_map) {
-          auto* stream_info = FindOrNull(producer_map->stream_map(), stream_id);
-          if (stream_info) {
-            consumer_table_id = stream_info->consumer_table_id();
-            consumer_tablet_count = stream_info->consumer_producer_tablet_map_size();
-            local_tserver_optimized = stream_info->local_tserver_optimized();
-            producer_schema_version =
-                stream_info->schema_versions().current_producer_schema_version();
-            consumer_schema_version =
-                stream_info->schema_versions().current_consumer_schema_version();
-            for (const auto& [_, producer_tablets] : stream_info->consumer_producer_tablet_map()) {
-              producer_tablet_count += producer_tablets.tablets_size();
-            }
-          }
-        }
-      } else {
-        status = "Not Ready";
-      }
+        inbound_replication_group, inbound_group_table_id, "Producer Table Id", "Stream Id",
+        "Consumer Table Id", "Producer Tablet Count", "Consumer Tablet Count",
+        "Local tserver optimized", "Producer schema version", "Consumer schema version", "Status");
+    inbound_group_table_id++;
 
+    for (const auto& table_status : inbound_replication_group.table_statuses) {
       HTML_PRINT_TABLE_ROW(
-          producer_table_id, stream_id, consumer_table_id, producer_tablet_count,
-          consumer_tablet_count, BoolToString(local_tserver_optimized), producer_schema_version,
-          consumer_schema_version, status);
+          table_status.source_table_id, table_status.stream_id, table_status.target_table_id,
+          table_status.source_tablet_count, table_status.target_tablet_count,
+          BoolToString(table_status.local_tserver_optimized), table_status.source_schema_version,
+          table_status.target_schema_version, table_status.status);
     }
     HTML_END_TABLE;
   }
@@ -3250,11 +3209,7 @@ Status MasterPathHandlers::Register(Webserver* server) {
       is_styled);
 
   RegisterLeaderOrRedirect(
-      server, "/xcluster-config", "XCluster Config", &MasterPathHandlers::HandleGetXClusterConfig,
-      is_styled);
-
-  RegisterLeaderOrRedirect(
-      server, "/xcluster", "XCluster", &MasterPathHandlers::HandleXCluster, is_styled);
+      server, "/xcluster", "xCluster", &MasterPathHandlers::HandleXCluster, is_styled);
 
   RegisterLeaderOrRedirect(
       server, "/tasks", "Tasks", &MasterPathHandlers::HandleTasksPage, is_styled);
@@ -3318,8 +3273,7 @@ Status MasterPathHandlers::Register(Webserver* server) {
       &MasterPathHandlers::HandleGetClusterConfigJSON);
 
   RegisterLeaderOrRedirect(
-      server, "/api/v1/xcluster-config", "XCluster Config JSON",
-      &MasterPathHandlers::HandleGetXClusterConfigJSON);
+      server, "/api/v1/xcluster", "xCluster", &MasterPathHandlers::HandleGetXClusterJSON);
 
   return Status::OK();
 }
diff --git a/src/yb/master/master-path-handlers.h b/src/yb/master/master-path-handlers.h
index b582ecf7e6..6b10fab28f 100644
--- a/src/yb/master/master-path-handlers.h
+++ b/src/yb/master/master-path-handlers.h
@@ -261,8 +261,7 @@ class MasterPathHandlers {
                           Webserver::WebResponse* resp);
   void HandleGetClusterConfig(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
   void HandleGetClusterConfigJSON(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
-  void HandleGetXClusterConfig(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
-  void HandleGetXClusterConfigJSON(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
+  void HandleGetXClusterJSON(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
   void GetXClusterJSON(std::stringstream& output, bool pretty);
   void HandleXCluster(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
   void HandleHealthCheck(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
@@ -315,11 +314,6 @@ class MasterPathHandlers {
 
   std::string GetHttpHostPortFromServerRegistration(const ServerRegistrationPB& reg) const;
 
-  Status GetXClusterConfigs(
-      SysXClusterConfigEntryPB* xcluster_config, SysClusterConfigEntryPB* cluster_config,
-      GetReplicationStatusResponsePB* xcluster_status,
-      std::vector<SysUniverseReplicationEntryPB>* replication_infos);
-
   Master* master_;
 
   const int output_precision_;
diff --git a/src/yb/master/master.cc b/src/yb/master/master.cc
index 102be0af47..96b84f0984 100644
--- a/src/yb/master/master.cc
+++ b/src/yb/master/master.cc
@@ -323,7 +323,6 @@ void Master::DisplayGeneralInfoIcons(std::stringstream* output) {
   DisplayIconTile(output, "fa-clone", "Replica Info", "/tablet-replication");
   DisplayIconTile(output, "fa-clock-o", "TServer Clocks", "/tablet-server-clocks");
   DisplayIconTile(output, "fa-tasks", "Load Balancer", "/load-distribution");
-  DisplayIconTile(output, "fa-list-alt", "XCluster Config", "/xcluster-config");
 }
 
 Status Master::StartAsync() {
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index 9824a8a629..44c889a4c8 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -20,6 +20,7 @@
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master_cluster.pb.h"
+#include "yb/master/xcluster/xcluster_status.h"
 #include "yb/util/is_operation_done_result.h"
 #include "yb/master/xcluster/xcluster_config.h"
 
@@ -103,13 +104,27 @@ Status XClusterManager::PrepareDefaultXClusterConfig(int64_t term, bool recreate
   return xcluster_config_->PrepareDefault(term, recreate);
 }
 
-Status XClusterManager::GetXClusterConfigEntryPB(SysXClusterConfigEntryPB* config) const {
-  *config = VERIFY_RESULT(xcluster_config_->GetXClusterConfigEntryPB());
+Result<XClusterStatus> XClusterManager::GetXClusterStatus() const {
+  XClusterStatus status;
+  RETURN_NOT_OK(XClusterSourceManager::PopulateXClusterStatus(
+      status, VERIFY_RESULT(xcluster_config_->GetXClusterConfigEntryPB())));
+  RETURN_NOT_OK(XClusterTargetManager::PopulateXClusterStatus(status));
+  return status;
+}
+
+Status XClusterManager::PopulateXClusterStatusJson(JsonWriter& jw) const {
+  auto xcluster_config = VERIFY_RESULT(xcluster_config_->GetXClusterConfigEntryPB());
+  jw.String("xcluster_config");
+  jw.Protobuf(xcluster_config);
+
+  RETURN_NOT_OK(XClusterSourceManager::PopulateXClusterStatusJson(jw));
+  RETURN_NOT_OK(XClusterTargetManager::PopulateXClusterStatusJson(jw));
   return Status::OK();
 }
 
 Status XClusterManager::GetMasterXClusterConfig(GetMasterXClusterConfigResponsePB* resp) {
-  return GetXClusterConfigEntryPB(resp->mutable_xcluster_config());
+  *resp->mutable_xcluster_config() = VERIFY_RESULT(xcluster_config_->GetXClusterConfigEntryPB());
+  return Status::OK();
 }
 
 Result<uint32_t> XClusterManager::GetXClusterConfigVersion() const {
diff --git a/src/yb/master/xcluster/xcluster_manager.h b/src/yb/master/xcluster/xcluster_manager.h
index 4f4845908e..f0e75ebe56 100644
--- a/src/yb/master/xcluster/xcluster_manager.h
+++ b/src/yb/master/xcluster/xcluster_manager.h
@@ -64,7 +64,8 @@ class XClusterManager : public XClusterManagerIf,
 
   void DumpState(std::ostream* out, bool on_disk_dump = false) const;
 
-  Status GetXClusterConfigEntryPB(SysXClusterConfigEntryPB* config) const  override;
+  Result<XClusterStatus> GetXClusterStatus() const override;
+  Status PopulateXClusterStatusJson(JsonWriter& jw) const override;
 
   Status GetMasterXClusterConfig(GetMasterXClusterConfigResponsePB* resp);
 
diff --git a/src/yb/master/xcluster/xcluster_manager_if.h b/src/yb/master/xcluster/xcluster_manager_if.h
index b49b736b04..dd0ea87e42 100644
--- a/src/yb/master/xcluster/xcluster_manager_if.h
+++ b/src/yb/master/xcluster/xcluster_manager_if.h
@@ -23,6 +23,7 @@
 namespace yb {
 
 class HybridTime;
+class JsonWriter;
 
 namespace rpc {
 class RpcContext;
@@ -32,8 +33,8 @@ namespace master {
 
 class GetXClusterSafeTimeRequestPB;
 class GetXClusterSafeTimeResponsePB;
-class SysXClusterConfigEntryPB;
 struct LeaderEpoch;
+struct XClusterStatus;
 
 class XClusterManagerIf {
  public:
@@ -46,7 +47,8 @@ class XClusterManagerIf {
       const LeaderEpoch& epoch, const NamespaceId& namespace_id,
       const XClusterSafeTimeFilter& filter) = 0;
 
-  virtual Status GetXClusterConfigEntryPB(SysXClusterConfigEntryPB* config) const = 0;
+  virtual Result<XClusterStatus> GetXClusterStatus() const = 0;
+  virtual Status PopulateXClusterStatusJson(JsonWriter& jw) const = 0;
 
  protected:
   virtual ~XClusterManagerIf() = default;
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index d872677b85..007771cf61 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -18,6 +18,7 @@
 #include "yb/cdc/cdc_state_table.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master.h"
+#include "yb/master/xcluster/xcluster_status.h"
 #include "yb/util/is_operation_done_result.h"
 #include "yb/master/xcluster/add_table_to_xcluster_source_task.h"
 #include "yb/master/xcluster/xcluster_catalog_entity.h"
@@ -777,4 +778,136 @@ Result<xrepl::StreamId> XClusterSourceManager::CreateNewXClusterStreamForTable(
   return stream_id;
 }
 
+std::unordered_map<TableId, std::vector<CDCStreamInfoPtr>> XClusterSourceManager::GetAllStreams()
+    const {
+  SharedLock lock(tables_to_stream_map_mutex_);
+  return tables_to_stream_map_;
+}
+
+Status XClusterSourceManager::PopulateXClusterStatus(
+    XClusterStatus& xcluster_status, const SysXClusterConfigEntryPB& xcluster_config) const {
+  std::set<xrepl::StreamId> paused_streams;
+  if (xcluster_config.has_xcluster_producer_registry()) {
+    for (const auto& [stream_id, paused] :
+         xcluster_config.xcluster_producer_registry().paused_producer_stream_ids()) {
+      if (paused) {
+        paused_streams.insert(VERIFY_RESULT(xrepl::StreamId::FromString(stream_id)));
+      }
+    }
+  }
+
+  std::unordered_map<xrepl::StreamId, XClusterOutboundTableStreamStatus> stream_status_map;
+  for (const auto& [table_id, streams] : GetAllStreams()) {
+    for (const auto& stream : streams) {
+      XClusterOutboundTableStreamStatus table_stream_status;
+      table_stream_status.table_id = table_id;
+      table_stream_status.stream_id = stream->StreamId();
+      table_stream_status.state =
+          SysCDCStreamEntryPB::State_Name(stream->LockForRead()->pb.state());
+      if (paused_streams.contains(stream->StreamId())) {
+        table_stream_status.state += " (PAUSED)";
+      }
+      stream_status_map.emplace(stream->StreamId(), std::move(table_stream_status));
+    }
+  }
+
+  auto all_outbound_groups = GetAllOutboundGroups();
+  for (const auto& replication_info : all_outbound_groups) {
+    auto metadata_result = replication_info->GetMetadata();
+    if (!metadata_result && metadata_result.status().IsNotFound()) {
+      continue;
+    }
+    RETURN_NOT_OK(metadata_result);
+    const auto& metadata = *metadata_result;
+
+    XClusterOutboundReplicationGroupStatus group_status;
+    group_status.replication_group_id = replication_info->Id();
+    group_status.state = SysXClusterOutboundReplicationGroupEntryPB::State_Name(metadata.state());
+    group_status.target_universe_info = metadata.target_universe_info().DebugString();
+
+    for (const auto& [namespace_id, namespace_status] : metadata.namespace_infos()) {
+      XClusterOutboundReplicationGroupNamespaceStatus ns_status;
+      ns_status.namespace_id = namespace_id;
+      ns_status.namespace_name = catalog_manager_.GetNamespaceName(namespace_id);
+      ns_status.state =
+          SysXClusterOutboundReplicationGroupEntryPB::SysXClusterOutboundReplicationGroupEntryPB::
+              NamespaceInfoPB::State_Name(namespace_status.state());
+      ns_status.initial_bootstrap_required = namespace_status.initial_bootstrap_required();
+      if (namespace_status.has_error_status()) {
+        ns_status.status = namespace_status.error_status().ShortDebugString();
+      } else {
+        ns_status.status = "OK";
+      }
+
+      for (const auto& [table_id, table_info] : namespace_status.table_infos()) {
+        XClusterOutboundReplicationGroupTableStatus table_status;
+        table_status.table_id = table_id;
+        if (table_info.has_stream_id()) {
+          auto stream_id = VERIFY_RESULT(xrepl::StreamId::FromString(table_info.stream_id()));
+          auto stream_status = FindOrNull(stream_status_map, stream_id);
+          if (stream_status) {
+            SCHECK_EQ(
+                stream_status->table_id, table_id, IllegalState,
+                Format(
+                    "Expected xCluster stream $0 to belongs to table $1 but outbound replication "
+                    "group $2 has it linked to table $3",
+                    stream_id, stream_status->table_id, replication_info->Id(), table_id));
+            table_status = stream_status_map.at(stream_id);
+            stream_status_map.erase(stream_id);
+          } else {
+            table_status.table_id = table_id;
+            table_status.stream_id = stream_id;
+            table_status.state = "DELETED";
+          }
+        }
+        table_status.is_checkpointing = table_info.is_checkpointing();
+        table_status.is_part_of_initial_bootstrap = table_info.is_part_of_initial_bootstrap();
+        ns_status.table_statuses.push_back(std::move(table_status));
+      }
+      group_status.namespace_statuses.push_back(std::move(ns_status));
+    }
+    xcluster_status.outbound_replication_group_statuses.emplace_back(std::move(group_status));
+  }
+
+  for (auto& [_, stream_status] : stream_status_map) {
+    xcluster_status.outbound_table_stream_statuses.emplace_back(std::move(stream_status));
+  }
+
+  return Status::OK();
+}
+
+Status XClusterSourceManager::PopulateXClusterStatusJson(JsonWriter& jw) const {
+  auto all_outbound_groups = GetAllOutboundGroups();
+  jw.String("outbound_replication_groups");
+  jw.StartArray();
+  for (auto const& replication_info : all_outbound_groups) {
+    jw.StartObject();
+    jw.String("replication_group_id");
+    jw.String(replication_info->Id().ToString());
+    auto metadata = replication_info->GetMetadata();
+    if (metadata) {
+      jw.String("metadata");
+      jw.Protobuf(*metadata);
+    } else {
+      jw.String("error");
+      jw.String(metadata.status().ToString());
+    }
+    jw.EndObject();
+  }
+  jw.EndArray();
+
+  jw.String("outbound_streams");
+  jw.StartArray();
+  for (const auto& [table_id, streams] : GetAllStreams()) {
+    for (const auto& stream : streams) {
+      jw.String("stream_id");
+      jw.String(stream->StreamId().ToString());
+      jw.String("metadata");
+      jw.Protobuf(stream->LockForRead()->pb);
+    }
+  }
+  jw.EndArray();
+  return Status::OK();
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_source_manager.h b/src/yb/master/xcluster/xcluster_source_manager.h
index f5498f0be3..401be7c2b1 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.h
+++ b/src/yb/master/xcluster/xcluster_source_manager.h
@@ -28,6 +28,7 @@
 namespace yb {
 
 class IsOperationDoneResult;
+class JsonWriter;
 
 namespace cdc {
 class CDCStateTable;
@@ -39,6 +40,7 @@ class XClusterOutboundReplicationGroup;
 class XClusterOutboundReplicationGroupInfo;
 class XClusterOutboundReplicationGroupTaskFactory;
 struct TabletDeleteRetainerInfo;
+struct XClusterStatus;
 
 class XClusterSourceManager {
  public:
@@ -119,6 +121,11 @@ class XClusterSourceManager {
       const xcluster::ReplicationGroupId& replication_group_id,
       const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch);
 
+  Status PopulateXClusterStatus(
+      XClusterStatus& xcluster_status, const SysXClusterConfigEntryPB& xcluster_config) const;
+
+  Status PopulateXClusterStatusJson(JsonWriter& jw) const;
+
  private:
   friend class XClusterOutboundReplicationGroup;
 
@@ -169,6 +176,8 @@ class XClusterSourceManager {
 
   std::vector<CDCStreamInfoPtr> GetStreamsForTable(const TableId& table_id) const;
 
+  std::unordered_map<TableId, std::vector<CDCStreamInfoPtr>> GetAllStreams() const;
+
   Master& master_;
   CatalogManager& catalog_manager_;
   SysCatalogTable& sys_catalog_;
diff --git a/src/yb/master/xcluster/xcluster_status.h b/src/yb/master/xcluster/xcluster_status.h
new file mode 100644
index 0000000000..6f64b365c5
--- /dev/null
+++ b/src/yb/master/xcluster/xcluster_status.h
@@ -0,0 +1,96 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include "yb/cdc/xcluster_types.h"
+#include "yb/cdc/xrepl_types.h"
+#include "yb/common/entity_ids_types.h"
+
+namespace yb {
+
+namespace master {
+
+struct InboundXClusterReplicationGroupTableStatus {
+  TableId source_table_id;
+  xrepl::StreamId stream_id = xrepl::StreamId::Nil();
+  TableId target_table_id;
+  uint32 source_tablet_count = 0;
+  uint32 target_tablet_count = 0;
+  bool local_tserver_optimized = false;
+  uint32 source_schema_version = 0;
+  uint32 target_schema_version = 0;
+  std::string status;
+};
+
+struct XClusterInboundReplicationGroupStatus {
+  xcluster::ReplicationGroupId replication_group_id;
+  std::string state;
+  bool transactional = false;
+  std::string master_addrs;
+  bool disable_stream = false;
+  uint32 compatible_auto_flag_config_version = 0;
+  uint32 validated_remote_auto_flags_config_version = 0;
+  uint32 validated_local_auto_flags_config_version = 0;
+  std::string db_scoped_info;
+  std::vector<InboundXClusterReplicationGroupTableStatus> table_statuses;
+};
+
+class XClusterOutboundTableStreamStatus {
+ public:
+  TableId table_id;
+  xrepl::StreamId stream_id = xrepl::StreamId::Nil();
+  std::string state;
+};
+
+class XClusterOutboundReplicationGroupTableStatus : public XClusterOutboundTableStreamStatus {
+ public:
+  void operator=(const XClusterOutboundTableStreamStatus& other) {
+    *static_cast<XClusterOutboundTableStreamStatus*>(this) = other;
+  }
+  bool is_checkpointing = false;
+  bool is_part_of_initial_bootstrap = false;
+};
+
+struct XClusterOutboundReplicationGroupNamespaceStatus {
+  NamespaceId namespace_id;
+  NamespaceName namespace_name;
+  std::string state;
+  bool initial_bootstrap_required = false;
+  std::string status;
+  std::vector<XClusterOutboundReplicationGroupTableStatus> table_statuses;
+};
+
+struct XClusterOutboundReplicationGroupStatus {
+  xcluster::ReplicationGroupId replication_group_id;
+  std::string state;
+  std::string target_universe_info;
+  std::vector<XClusterOutboundReplicationGroupNamespaceStatus> namespace_statuses;
+};
+
+struct XClusterStatus {
+  std::string role;
+  bool transactional = false;
+
+  std::vector<XClusterOutboundReplicationGroupStatus> outbound_replication_group_statuses;
+  std::vector<XClusterOutboundTableStreamStatus> outbound_table_stream_statuses;
+  std::vector<XClusterInboundReplicationGroupStatus> inbound_replication_group_statuses;
+
+  bool IsEnabled() const {
+    return !role.empty() || !outbound_replication_group_statuses.empty() ||
+           !outbound_table_stream_statuses.empty() || !inbound_replication_group_statuses.empty();
+  }
+};
+
+}  // namespace master
+}  // namespace yb
diff --git a/src/yb/master/xcluster/xcluster_target_manager.cc b/src/yb/master/xcluster/xcluster_target_manager.cc
index f49302da84..0dd38278e7 100644
--- a/src/yb/master/xcluster/xcluster_target_manager.cc
+++ b/src/yb/master/xcluster/xcluster_target_manager.cc
@@ -22,7 +22,8 @@
 #include "yb/master/xcluster/xcluster_replication_group.h"
 #include "yb/master/xcluster/xcluster_safe_time_service.h"
 
-#include "yb/util/flags.h"
+#include "yb/master/xcluster/xcluster_status.h"
+#include "yb/util/jsonwriter.h"
 #include "yb/util/status.h"
 
 namespace yb::master {
@@ -193,4 +194,131 @@ XClusterTargetManager::GetPostTabletCreateTasks(
   return tasks;
 }
 
+template <typename PBList>
+std::string PBListAsString(const PBList& pb, const char* delim = ",") {
+  std::stringstream errors;
+  for (int i = 0; i < pb.size(); i++) {
+    errors << (i ? delim : "") << pb.Get(i).ShortDebugString();
+  }
+
+  return errors.str();
+}
+
+Status XClusterTargetManager::PopulateXClusterStatus(XClusterStatus& xcluster_status) const {
+  GetReplicationStatusResponsePB replication_status;
+  GetReplicationStatusRequestPB req;
+  RETURN_NOT_OK(catalog_manager_.GetReplicationStatus(&req, &replication_status, /*rpc=*/nullptr));
+
+  std::unordered_map<xrepl::StreamId, std::string> stream_status;
+  for (const auto& table_stream_status : replication_status.statuses()) {
+    if (!table_stream_status.errors_size()) {
+      continue;
+    }
+
+    const auto stream_id =
+        VERIFY_RESULT(xrepl::StreamId::FromString(table_stream_status.stream_id()));
+    stream_status[stream_id] = PBListAsString(table_stream_status.errors(), ";");
+    auto s = table_stream_status.ShortDebugString();
+  }
+
+  SysClusterConfigEntryPB cluster_config;
+  RETURN_NOT_OK(catalog_manager_.GetClusterConfig(&cluster_config));
+  const auto& consumer_registry = cluster_config.consumer_registry();
+  xcluster_status.role = XClusterRole_Name(consumer_registry.role());
+  xcluster_status.transactional = consumer_registry.transactional();
+
+  const auto replication_infos = catalog_manager_.GetAllXClusterUniverseReplicationInfos();
+
+  for (const auto& replication_info : replication_infos) {
+    XClusterInboundReplicationGroupStatus replication_group_status;
+    replication_group_status.replication_group_id =
+        xcluster::ReplicationGroupId(replication_info.replication_group_id());
+    replication_group_status.state =
+        SysUniverseReplicationEntryPB::State_Name(replication_info.state());
+    replication_group_status.transactional = replication_info.transactional();
+    replication_group_status.validated_local_auto_flags_config_version =
+        replication_info.validated_local_auto_flags_config_version();
+
+    for (const auto& namespace_info : replication_info.db_scoped_info().namespace_infos()) {
+      replication_group_status.db_scoped_info += Format(
+          "\n  namespace: $0\n    consumer_namespace_id: $1\n    producer_namespace_id: $2",
+          catalog_manager_.GetNamespaceName(namespace_info.consumer_namespace_id()),
+          namespace_info.consumer_namespace_id(), namespace_info.producer_namespace_id());
+    }
+
+    auto* producer_map =
+        FindOrNull(consumer_registry.producer_map(), replication_info.replication_group_id());
+    if (producer_map) {
+      replication_group_status.master_addrs = PBListAsString(producer_map->master_addrs());
+      replication_group_status.disable_stream = producer_map->disable_stream();
+      replication_group_status.compatible_auto_flag_config_version =
+          producer_map->compatible_auto_flag_config_version();
+      replication_group_status.validated_remote_auto_flags_config_version =
+          producer_map->validated_auto_flags_config_version();
+    }
+
+    for (const auto& source_table_id : replication_info.tables()) {
+      InboundXClusterReplicationGroupTableStatus table_statuses;
+      table_statuses.source_table_id = source_table_id;
+
+      auto* stream_id_it = FindOrNull(replication_info.table_streams(), source_table_id);
+      if (stream_id_it) {
+        table_statuses.stream_id = VERIFY_RESULT(xrepl::StreamId::FromString(*stream_id_it));
+        auto it = FindOrNull(stream_status, table_statuses.stream_id);
+        table_statuses.status = it ? *it : "OK";
+
+        if (producer_map) {
+          auto* stream_info =
+              FindOrNull(producer_map->stream_map(), table_statuses.stream_id.ToString());
+          if (stream_info) {
+            table_statuses.target_table_id = stream_info->consumer_table_id();
+            table_statuses.target_tablet_count = stream_info->consumer_producer_tablet_map_size();
+            table_statuses.local_tserver_optimized = stream_info->local_tserver_optimized();
+            table_statuses.source_schema_version =
+                stream_info->schema_versions().current_producer_schema_version();
+            table_statuses.target_schema_version =
+                stream_info->schema_versions().current_consumer_schema_version();
+            for (const auto& [_, producer_tablets] : stream_info->consumer_producer_tablet_map()) {
+              table_statuses.source_tablet_count += producer_tablets.tablets_size();
+            }
+          }
+        }
+      } else {
+        table_statuses.status = "Not Ready";
+      }
+
+      replication_group_status.table_statuses.push_back(std::move(table_statuses));
+    }
+
+    xcluster_status.inbound_replication_group_statuses.push_back(
+        std::move(replication_group_status));
+  }
+
+  return Status::OK();
+}
+
+Status XClusterTargetManager::PopulateXClusterStatusJson(JsonWriter& jw) const {
+  GetReplicationStatusResponsePB replication_status;
+  GetReplicationStatusRequestPB req;
+  RETURN_NOT_OK(catalog_manager_.GetReplicationStatus(&req, &replication_status, /*rpc=*/nullptr));
+
+  SysClusterConfigEntryPB cluster_config;
+  RETURN_NOT_OK(catalog_manager_.GetClusterConfig(&cluster_config));
+
+  jw.String("replication_status");
+  jw.Protobuf(replication_status);
+
+  const auto replication_infos = catalog_manager_.GetAllXClusterUniverseReplicationInfos();
+  jw.String("replication_infos");
+  jw.StartArray();
+  for (auto const& replication_info : replication_infos) {
+    jw.Protobuf(replication_info);
+  }
+  jw.EndArray();
+
+  jw.String("consumer_registry");
+  jw.Protobuf(cluster_config.consumer_registry());
+
+  return Status::OK();
+}
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_target_manager.h b/src/yb/master/xcluster/xcluster_target_manager.h
index ff8b7f43fd..22c1c3295a 100644
--- a/src/yb/master/xcluster/xcluster_target_manager.h
+++ b/src/yb/master/xcluster/xcluster_target_manager.h
@@ -18,7 +18,6 @@
 
 #include "yb/master/xcluster/master_xcluster_types.h"
 #include "yb/master/xcluster/xcluster_catalog_entity.h"
-#include "yb/rpc/rpc_fwd.h"
 #include "yb/util/status_fwd.h"
 
 namespace yb::master {
@@ -28,6 +27,7 @@ class TSHeartbeatResponsePB;
 
 class PostTabletCreateTaskBase;
 class XClusterSafeTimeService;
+struct XClusterStatus;
 
 class XClusterTargetManager {
  public:
@@ -80,6 +80,10 @@ class XClusterTargetManager {
   std::vector<std::shared_ptr<PostTabletCreateTaskBase>> GetPostTabletCreateTasks(
       const TableInfoPtr& table_info, const LeaderEpoch& epoch);
 
+  Status PopulateXClusterStatus(XClusterStatus& xcluster_status) const;
+
+  Status PopulateXClusterStatusJson(JsonWriter& jw) const;
+
  private:
   Master& master_;
   CatalogManager& catalog_manager_;
diff --git a/src/yb/server/server_base.cc b/src/yb/server/server_base.cc
index 1dd6a69490..4641fb6971 100644
--- a/src/yb/server/server_base.cc
+++ b/src/yb/server/server_base.cc
@@ -660,6 +660,7 @@ void RpcAndWebServerBase::DisplayGeneralInfoIcons(std::stringstream* output) {
   DisplayIconTile(output, "fa-hdd-o", "Drives", "/drives");
   // TLS.
   DisplayIconTile(output, "fa-lock", "TLS", "/tls");
+  DisplayIconTile(output, "fa-times", "xCluster", "/xcluster");
 }
 
 void RpcAndWebServerBase::DisplayMemoryIcons(std::stringstream* output) {
diff --git a/src/yb/tserver/tserver-path-handlers.cc b/src/yb/tserver/tserver-path-handlers.cc
index 7e2d6c06eb..24aeb38d2c 100644
--- a/src/yb/tserver/tserver-path-handlers.cc
+++ b/src/yb/tserver/tserver-path-handlers.cc
@@ -515,7 +515,7 @@ Status TabletServerPathHandlers::Register(Webserver* server) {
       std::bind(&TabletServerPathHandlers::HandleMaintenanceManagerPage, this, _1, _2),
       true /* styled */, false /* is_on_nav_bar */);
   server->RegisterPathHandler(
-      "/xcluster", "xcluster",
+      "/xcluster", "xCluster",
       std::bind(&TabletServerPathHandlers::HandleXClusterPage, this, _1, _2), true /* styled */,
       false /* is_on_nav_bar */);
 
