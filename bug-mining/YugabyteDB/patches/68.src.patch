diff --git a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
index 7bd29b3d5a..7c09ef2105 100644
--- a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
@@ -22,7 +22,7 @@
 DECLARE_bool(TEST_enable_xcluster_api_v2);
 DECLARE_uint32(cdc_wal_retention_time_secs);
 DECLARE_uint32(max_xcluster_streams_to_checkpoint_in_parallel);
-
+DECLARE_bool(TEST_block_xcluster_checkpoint_namespace_task);
 namespace yb {
 namespace master {
 
@@ -137,6 +137,14 @@ class XClusterOutboundReplicationGroupTest : public XClusterYsqlTestBase {
     return Status::OK();
   }
 
+  Status RestartMaster() {
+    auto master = VERIFY_RESULT(producer_cluster()->GetLeaderMiniMaster());
+    RETURN_NOT_OK(master->Restart());
+    catalog_manager_ = &master->catalog_manager_impl();
+    epoch_ = catalog_manager_->GetLeaderEpochInternal();
+    return Status::OK();
+  }
+
   client::XClusterClient XClusterClient() { return client::XClusterClient(*client_); }
 
   CatalogManager* catalog_manager_;
@@ -355,5 +363,46 @@ TEST_F(XClusterOutboundReplicationGroupTest, IsBootstrapRequiredTableWithDeleted
   ASSERT_FALSE(is_bootstrap_required);
 }
 
+TEST_F(XClusterOutboundReplicationGroupTest, MasterRestartDuringCheckpoint) {
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_max_xcluster_streams_to_checkpoint_in_parallel) = 1;
+  auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
+  auto table_id_2 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName2));
+
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_block_xcluster_checkpoint_namespace_task) = true;
+
+  ASSERT_OK(XClusterClient().XClusterCreateOutboundReplicationGroup(
+      kReplicationGroupId, {kNamespaceName}));
+
+  std::promise<Result<master::GetXClusterStreamsResponsePB>> promise;
+  auto future = promise.get_future();
+  ASSERT_OK(XClusterClient().GetXClusterStreams(
+      CoarseMonoClock::Now() + kDeadline, kReplicationGroupId, namespace_id_, /*table_names=*/{},
+      /*pg_schema_names=*/{}, [&promise](const auto& resp) { promise.set_value(resp); }));
+
+  ASSERT_EQ(future.wait_for(5s), std::future_status::timeout);
+
+  ASSERT_OK(RestartMaster());
+
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_block_xcluster_checkpoint_namespace_task) = false;
+
+  auto resp = ASSERT_RESULT(future.get());
+  size_t stream_count = 2;
+  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(table_id_1, table_id_2, stream_count, resp));
+
+  auto all_xcluster_streams_initial = CleanupAndGetAllXClusterStreams();
+  ASSERT_EQ(all_xcluster_streams_initial.size(), stream_count);
+
+  // TODO (#21986) : Disabled since VerifyWalRetentionOfTable fails.
+  // ASSERT_OK(
+  //     catalog_manager_->WaitForAlterTableToFinish(table_id_1, CoarseMonoClock::Now() +
+  //     kDeadline));
+  // ASSERT_OK(
+  //     catalog_manager_->WaitForAlterTableToFinish(table_id_2, CoarseMonoClock::Now() +
+  //     kDeadline));
+
+  // ASSERT_OK(VerifyWalRetentionOfTable(table_id_1));
+  // ASSERT_OK(VerifyWalRetentionOfTable(table_id_2));
+}
+
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 6580e96ffc..65a689312a 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -13572,7 +13572,7 @@ void CatalogManager::SysCatalogLoaded(SysCatalogLoadingState&& state) {
 
   snapshot_coordinator_.SysCatalogLoaded(state.epoch.leader_term);
 
-  xcluster_manager_->SysCatalogLoaded();
+  xcluster_manager_->SysCatalogLoaded(state.epoch);
   SchedulePostTabletCreationTasksForPendingTables(state.epoch);
 }
 
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index 40857e53d1..9d60a390df 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -80,8 +80,8 @@ Status XClusterManager::RunLoaders(const TabletInfos& hidden_tablets) {
   return Status::OK();
 }
 
-void XClusterManager::SysCatalogLoaded() {
-  XClusterSourceManager::SysCatalogLoaded();
+void XClusterManager::SysCatalogLoaded(const LeaderEpoch& epoch) {
+  XClusterSourceManager::SysCatalogLoaded(epoch);
   XClusterTargetManager::SysCatalogLoaded();
 }
 
diff --git a/src/yb/master/xcluster/xcluster_manager.h b/src/yb/master/xcluster/xcluster_manager.h
index 57e6eb5112..3183d78df2 100644
--- a/src/yb/master/xcluster/xcluster_manager.h
+++ b/src/yb/master/xcluster/xcluster_manager.h
@@ -60,7 +60,7 @@ class XClusterManager : public XClusterManagerIf,
 
   Status RunLoaders(const TabletInfos& hidden_tablets);
 
-  void SysCatalogLoaded();
+  void SysCatalogLoaded(const LeaderEpoch& epoch);
 
   void RunBgTasks(const LeaderEpoch& epoch) override;
 
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
index f4ce2348c0..91a2eb5eea 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
@@ -894,4 +894,28 @@ Status XClusterOutboundReplicationGroup::RemoveStreams(
   return Status::OK();
 }
 
+void XClusterOutboundReplicationGroup::StartPostLoadTasks(const LeaderEpoch& epoch) {
+  std::lock_guard mutex_lock(mutex_);
+  auto lock_result = LockForWrite();
+  if (!lock_result.ok()) {
+    LOG_WITH_PREFIX_AND_FUNC(WARNING) << "Failed to lock: " << lock_result.status();
+    return;
+  }
+
+  auto tasks = GetTasks();
+  if (!tasks.empty()) {
+    LOG_WITH_PREFIX_AND_FUNC(DFATAL) << "Tasks already in progress: " << AsString(tasks);
+    return;
+  }
+
+  std::vector<NamespaceId> namespace_ids;
+  for (const auto& [ns_id, ns_info] : lock_result->mutable_data()->pb.namespace_infos()) {
+    if (ns_info.state() == NamespaceInfoPB::CHECKPOINTING) {
+      namespace_ids.push_back(ns_id);
+    }
+  }
+
+  StartNamespaceCheckpointTasks(namespace_ids, epoch);
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.h b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
index ea87afceea..3458444ee8 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.h
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
@@ -111,6 +111,8 @@ class XClusterOutboundReplicationGroup
 
   bool HasNamespace(const NamespaceId& namespace_id) const EXCLUDES(mutex_);
 
+  void StartPostLoadTasks(const LeaderEpoch& epoch) EXCLUDES(mutex_);
+
  private:
   friend class XClusterOutboundReplicationGroupMocked;
   friend class AddTableToXClusterSourceTask;
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
index 2641bc1dee..c27d8af821 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
@@ -16,6 +16,9 @@
 #include "yb/master/catalog_manager.h"
 #include "yb/master/xcluster/xcluster_outbound_replication_group.h"
 
+DEFINE_test_flag(bool, block_xcluster_checkpoint_namespace_task, false,
+    "When enabled XClusterCheckpointNamespaceTask will be blocked");
+
 using namespace std::placeholders;
 
 namespace yb::master {
@@ -59,11 +62,19 @@ Status XClusterCheckpointNamespaceTask::FirstStep() {
 }
 
 Status XClusterCheckpointNamespaceTask::CheckpointStreams() {
-  RETURN_NOT_OK(outbound_replication_group_.CheckpointStreamsForInitialBootstrap(
+  auto status = outbound_replication_group_.CheckpointStreamsForInitialBootstrap(
       namespace_id_, epoch_,
-      std::bind(&XClusterCheckpointNamespaceTask::CheckpointStreamsCallback, this, _1)));
+      std::bind(&XClusterCheckpointNamespaceTask::CheckpointStreamsCallback, this, _1));
 
-  return Status::OK();
+  if (!status.ok() && status.IsTryAgain()) {
+    LOG_WITH_PREFIX(WARNING) << "Failed to checkpoint streams: " << status << ". Scheduling retry";
+    ScheduleNextStepWithDelay(
+        std::bind(&XClusterCheckpointNamespaceTask::CheckpointStreams, this), "CheckpointStreams",
+        GetDelayWithBackoff());
+    return Status::OK();
+  }
+
+  return status;
 }
 
 void XClusterCheckpointNamespaceTask::CheckpointStreamsCallback(
@@ -76,6 +87,14 @@ void XClusterCheckpointNamespaceTask::CheckpointStreamsCallback(
 
 Status XClusterCheckpointNamespaceTask::MarkTablesAsCheckpointed(
     XClusterCheckpointStreamsResult result) {
+  if (FLAGS_TEST_block_xcluster_checkpoint_namespace_task) {
+    ScheduleNextStepWithDelay(
+        std::bind(
+            &XClusterCheckpointNamespaceTask::MarkTablesAsCheckpointed, this, std::move(result)),
+        "CheckpointStreams", MonoDelta::FromMilliseconds(100));
+    return Status::OK();
+  }
+
   if (VERIFY_RESULT(outbound_replication_group_.MarkBootstrapTablesAsCheckpointed(
           namespace_id_, std::move(result), epoch_))) {
     // All tables have been checkpointed and the replication group is now READY.
@@ -93,4 +112,11 @@ void XClusterCheckpointNamespaceTask::TaskCompleted(const Status& status) {
   }
 }
 
+MonoDelta XClusterCheckpointNamespaceTask::GetDelayWithBackoff() {
+  const auto delay = delay_with_backoff_;
+  // Exponential delay from 100ms to 5s.
+  delay_with_backoff_ = MonoDelta::FromSeconds(std::min(5.0, delay.ToSeconds() * 1.1));
+  return delay;
+}
+
 } // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.h b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.h
index 6fa7e7c8f9..c74d83bc00 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.h
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.h
@@ -49,9 +49,11 @@ class XClusterCheckpointNamespaceTask : public MultiStepCatalogEntityTask {
   void CheckpointStreamsCallback(XClusterCheckpointStreamsResult result);
   Status MarkTablesAsCheckpointed(XClusterCheckpointStreamsResult result);
   void TaskCompleted(const Status& s) override;
+  MonoDelta GetDelayWithBackoff();
 
   const NamespaceId namespace_id_;
   XClusterOutboundReplicationGroup& outbound_replication_group_;
+  MonoDelta delay_with_backoff_ = MonoDelta::FromMilliseconds(100);
 };
 
 class XClusterOutboundReplicationGroupTaskFactory {
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index dc8ceba137..1b970432d7 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -116,7 +116,11 @@ void XClusterSourceManager::CleanupStreamFromMaps(const CDCStreamInfo& stream) {
   }
 }
 
-void XClusterSourceManager::SysCatalogLoaded() {}
+void XClusterSourceManager::SysCatalogLoaded(const LeaderEpoch& epoch) {
+  for (const auto& outbound_rg : GetAllOutboundGroups()) {
+    outbound_rg->StartPostLoadTasks(epoch);
+  }
+}
 
 void XClusterSourceManager::DumpState(std::ostream& out, bool on_disk_dump) const {
   if (!on_disk_dump) {
@@ -516,7 +520,15 @@ Status XClusterSourceManager::CheckpointStreamsToEndOfWAL(
     bootstrap_req.add_xrepl_stream_ids(stream_id.ToString());
 
     if (!ts_desc) {
-      ts_desc = VERIFY_RESULT(table_info->GetTablets().front()->GetLeader());
+      auto ts_desc_result = table_info->GetTablets().front()->GetLeader();
+      if (!ts_desc_result) {
+        // After a master failover we may not yet have the leader info, so we need to try again.
+        if (ts_desc_result.status().IsNotFound()) {
+          return STATUS(TryAgain, "Tablet leader not found", ts_desc_result.status().ToString());
+        }
+        RETURN_NOT_OK(ts_desc_result.status());
+      }
+      ts_desc = std::move(*ts_desc_result);
     }
   }
   SCHECK(ts_desc, IllegalState, "No valid tserver found to bootstrap from");
diff --git a/src/yb/master/xcluster/xcluster_source_manager.h b/src/yb/master/xcluster/xcluster_source_manager.h
index e6af3aa27a..5c465bf00f 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.h
+++ b/src/yb/master/xcluster/xcluster_source_manager.h
@@ -90,7 +90,7 @@ class XClusterSourceManager {
 
   Status RunLoaders(const TabletInfos& hidden_tablets);
 
-  void SysCatalogLoaded();
+  void SysCatalogLoaded(const LeaderEpoch& epoch);
 
   void DumpState(std::ostream& out, bool on_disk_dump) const;
 
diff --git a/src/yb/master/xrepl_catalog_manager.cc b/src/yb/master/xrepl_catalog_manager.cc
index 273a19bb34..aaa7353021 100644
--- a/src/yb/master/xrepl_catalog_manager.cc
+++ b/src/yb/master/xrepl_catalog_manager.cc
@@ -1325,18 +1325,20 @@ Status CatalogManager::SetXReplWalRetentionForTable(
                       << table_wal_retention_secs
                       << ", which is equal or higher than cdc_wal_retention_time_secs: "
                       << min_wal_retention_secs;
-    return Status::OK();
-  }
-
-  AlterTableRequestPB alter_table_req;
-  alter_table_req.mutable_table()->set_table_id(table_id);
-  alter_table_req.set_wal_retention_secs(min_wal_retention_secs);
+  } else {
+    AlterTableRequestPB alter_table_req;
+    alter_table_req.mutable_table()->set_table_id(table_id);
+    alter_table_req.set_wal_retention_secs(min_wal_retention_secs);
 
-  AlterTableResponsePB alter_table_resp;
-  RETURN_NOT_OK_PREPEND(
-      this->AlterTable(&alter_table_req, &alter_table_resp, /*rpc=*/nullptr, epoch),
-      Format("Unable to change the WAL retention time for table $0", table_id));
+    AlterTableResponsePB alter_table_resp;
+    RETURN_NOT_OK_PREPEND(
+        this->AlterTable(&alter_table_req, &alter_table_resp, /*rpc=*/nullptr, epoch),
+        Format("Unable to change the WAL retention time for table $0", table_id));
+  }
 
+  // Ideally we should WaitForAlterTableToFinish to ensure the change has propagated to all
+  // tablet peers. But since we have 15min default WAL retention and this operation completes much
+  // sooner, we skip it.
   return Status::OK();
 }
 
