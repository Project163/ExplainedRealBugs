diff --git a/src/yb/integration-tests/minicluster-snapshot-test.cc b/src/yb/integration-tests/minicluster-snapshot-test.cc
index cdec58e3a7..7e17204c5d 100644
--- a/src/yb/integration-tests/minicluster-snapshot-test.cc
+++ b/src/yb/integration-tests/minicluster-snapshot-test.cc
@@ -557,10 +557,11 @@ class PgCloneTest : public PostgresMiniClusterTest {
   virtual Status CreateProxies() {
     messenger_ = VERIFY_RESULT(rpc::MessengerBuilder("test-msgr").set_num_reactors(1).Build());
     proxy_cache_ = std::make_unique<rpc::ProxyCache>(messenger_.get());
+    auto* master = VERIFY_RESULT(mini_cluster()->GetLeaderMiniMaster());
     master_admin_proxy_ = std::make_unique<MasterAdminProxy>(
-        proxy_cache_.get(), mini_cluster()->mini_master()->bound_rpc_addr());
+        proxy_cache_.get(), master->bound_rpc_addr());
     master_backup_proxy_ = std::make_shared<MasterBackupProxy>(
-        proxy_cache_.get(), mini_cluster()->mini_master()->bound_rpc_addr());
+        proxy_cache_.get(), master->bound_rpc_addr());
     return Status::OK();
   }
 
@@ -867,10 +868,36 @@ TEST_F(PgCloneTest, YB_DISABLE_TEST_IN_SANITIZERS(PreventConnectionsUntilCloneSu
       Format("database \"$0\" is not currently accepting connections", kTargetNamespaceName1));
 }
 
+class PgCloneMultiMaster : public PgCloneTest {
+  virtual void OverrideMiniClusterOptions(MiniClusterOptions* options) override {
+    options->num_masters = 3;
+  }
+};
+
+TEST_F(PgCloneMultiMaster, YB_DISABLE_TEST_IN_SANITIZERS(CloneAfterMasterChange)) {
+  const std::tuple<int32_t, int32_t> kRow = {1, 10};
+  ASSERT_OK(source_conn_->ExecuteFormat(
+      "INSERT INTO t1 VALUES ($0, $1)", std::get<0>(kRow), std::get<1>(kRow)));
+
+  ASSERT_OK(source_conn_->ExecuteFormat(
+      "CREATE DATABASE $0 TEMPLATE $1", kTargetNamespaceName1, kSourceNamespaceName));
+  ASSERT_OK(cluster_->StepDownMasterLeader());
+  // TODO(#22925) Remove this sleep once TsDescriptors are persisted.
+  SleepFor(3s);
+  ASSERT_OK(source_conn_->ExecuteFormat(
+      "CREATE DATABASE $0 TEMPLATE $1", kTargetNamespaceName2, kSourceNamespaceName));
+
+  auto target_conn = ASSERT_RESULT(ConnectToDB(kTargetNamespaceName1));
+  auto row = ASSERT_RESULT((target_conn.FetchRow<int32_t, int32_t>("SELECT * FROM t1")));
+  ASSERT_EQ(row, kRow);
+  target_conn = ASSERT_RESULT(ConnectToDB(kTargetNamespaceName2));
+  row = ASSERT_RESULT((target_conn.FetchRow<int32_t, int32_t>("SELECT * FROM t1")));
+  ASSERT_EQ(row, kRow);
+}
+
 class PgCloneColocationTest : public PgCloneTest {
   virtual void OverrideMiniClusterOptions(MiniClusterOptions* options) override {
     options->num_masters = 3;
-    options->num_tablet_servers = 3;
   }
 
   virtual Status CreateProxies() override {
diff --git a/src/yb/master/catalog_entity_info.cc b/src/yb/master/catalog_entity_info.cc
index 66f0b8c144..4b994d65f4 100644
--- a/src/yb/master/catalog_entity_info.cc
+++ b/src/yb/master/catalog_entity_info.cc
@@ -1155,14 +1155,6 @@ string NamespaceInfo::ToString() const {
   return Substitute("$0 [id=$1]", name(), namespace_id_);
 }
 
-uint32_t NamespaceInfo::FetchAndIncrementCloneSeqNo() {
-  auto lock = LockForWrite();
-  uint32_t new_clone_request_seq_no = lock->pb.clone_request_seq_no() + 1;
-  lock.mutable_data()->pb.set_clone_request_seq_no(new_clone_request_seq_no);
-  lock.Commit();
-  return new_clone_request_seq_no;
-}
-
 // ================================================================================================
 // UDTypeInfo
 // ================================================================================================
diff --git a/src/yb/master/catalog_entity_info.h b/src/yb/master/catalog_entity_info.h
index c7c35ec950..f58530b260 100644
--- a/src/yb/master/catalog_entity_info.h
+++ b/src/yb/master/catalog_entity_info.h
@@ -868,8 +868,6 @@ class NamespaceInfo : public RefCountedThreadSafe<NamespaceInfo>,
 
   std::string ToString() const override;
 
-  uint32_t FetchAndIncrementCloneSeqNo();
-
  private:
   friend class RefCountedThreadSafe<NamespaceInfo>;
   ~NamespaceInfo() = default;
diff --git a/src/yb/master/clone/clone_state_entity.h b/src/yb/master/clone/clone_state_entity.h
index a0902af5e2..f91c886764 100644
--- a/src/yb/master/clone/clone_state_entity.h
+++ b/src/yb/master/clone/clone_state_entity.h
@@ -41,7 +41,7 @@ class CloneStateInfo : public MetadataCowWrapper<PersistentCloneStateInfo> {
   struct TabletData {
     TabletId source_tablet_id;
     TabletId target_tablet_id;
-    // The correct schema version and SysTablesEntryPB of every colocated table
+    // The correct schema version and SysTablesEntryPB of every colocated table.
     std::vector<ColocatedTableData> colocated_tables_data;
   };
 
diff --git a/src/yb/master/clone/clone_state_manager-test.cc b/src/yb/master/clone/clone_state_manager-test.cc
index 14e424cb9f..c71e1c41cd 100644
--- a/src/yb/master/clone/clone_state_manager-test.cc
+++ b/src/yb/master/clone/clone_state_manager-test.cc
@@ -118,6 +118,10 @@ class CloneStateManagerTest : public YBTest {
 
     MOCK_METHOD(
         Status, Upsert, (int64_t leader_term, const CloneStateInfoPtr& clone_state), (override));
+    MOCK_METHOD(
+        Status, Upsert,
+        (int64_t leader_term, const CloneStateInfoPtr& clone_state,
+         const NamespaceInfoPtr& source_namespace), (override));
     MOCK_METHOD(
         Status, Load,
         (const std::string& type,
@@ -141,7 +145,7 @@ class CloneStateManagerTest : public YBTest {
          UDTypeMap* type_map, ExternalTableSnapshotDataMap* tables_data,
          CoarseTimePoint deadline), (override));
 
-    MOCK_METHOD(TSDescriptorPtr, PickTserver, (), (override));
+    MOCK_METHOD(Result<TSDescriptorPtr>, PickTserver, (), (override));
   };
 
  private:
@@ -218,9 +222,9 @@ class CloneStateManagerTest : public YBTest {
   // ExternalTableSnapshotDataMap (instead of using import / export snapshot).
   // NB: This does not call EXPECT_CALL(Upsert) because some tests expect this to fail.
   Result<CloneStateInfoPtr> CreateCloneState(
-      uint32_t seq_no, const ExternalTableSnapshotDataMap& table_snapshot_data) {
+      const ExternalTableSnapshotDataMap& table_snapshot_data) {
     auto clone_state = VERIFY_RESULT(clone_state_manager_->CreateCloneState(
-        kEpoch, seq_no, kSourceNamespaceId, GetDatabaseType(), kTargetNamespaceName, kRestoreTime));
+        kEpoch, source_ns_, GetDatabaseType(), kTargetNamespaceName, kRestoreTime));
 
     RETURN_NOT_OK(clone_state_manager_->UpdateCloneStateWithSnapshotInfo(
         clone_state, kSourceSnapshotId, kTargetSnapshotId, table_snapshot_data));
@@ -236,8 +240,8 @@ class CloneStateManagerTest : public YBTest {
     tablet_ids.set_new_id("test_target_id");
     *table_data.table_meta->add_tablets_ids() = tablet_ids;
 
-    EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
-    return CreateCloneState(kSeqNo + 1, table_snapshot_data);
+    EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _, _));
+    return CreateCloneState(table_snapshot_data);
   }
 
   ExternalTableSnapshotDataMap DefaultTableSnapshotData() {
@@ -255,8 +259,8 @@ class CloneStateManagerTest : public YBTest {
 
   // Creates a clone state and schedules clone ops to move it into the CREATING state.
   Result<CloneStateInfoPtr> CreateCloneStateAndStartCloning() {
-    EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
-    auto clone_state = VERIFY_RESULT(CreateCloneState(kSeqNo, DefaultTableSnapshotData()));
+    EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _, _));
+    auto clone_state = VERIFY_RESULT(CreateCloneState(DefaultTableSnapshotData()));
 
     for (int i = 0; i < kNumTablets; ++i) {
       EXPECT_CALL(MockFuncs(), GetTabletInfo(source_tablets_[i]->id()))
@@ -326,7 +330,6 @@ class CloneStateManagerTest : public YBTest {
 
   std::unique_ptr<CloneStateManager> clone_state_manager_;
 
-  const uint32_t kSeqNo = 100;
   const NamespaceId kSourceNamespaceId = "source_namespace_id";
   const NamespaceId kTargetNamespaceId = "target_namespace_id";
   const std::string kSourceNamespaceName = "source_namespace_name";
@@ -356,14 +359,14 @@ class CloneStateManagerPgTest : public CloneStateManagerTest {
 };
 
 TEST_F(CloneStateManagerTest, CreateCloneState) {
-  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
-  auto clone_state = ASSERT_RESULT(CreateCloneState(kSeqNo, DefaultTableSnapshotData()));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _, _));
+  auto clone_state = ASSERT_RESULT(CreateCloneState(DefaultTableSnapshotData()));
 
   // Check clone state persisted fields.
   SysCloneStatePB expected_pb;
   expected_pb.set_aggregate_state(SysCloneStatePB::CLONE_SCHEMA_STARTED);
   expected_pb.set_source_namespace_id(kSourceNamespaceId);
-  expected_pb.set_clone_request_seq_no(kSeqNo);
+  expected_pb.set_clone_request_seq_no(1);
   expected_pb.set_target_namespace_name(kTargetNamespaceName);
   expected_pb.set_restore_time(kRestoreTime.ToUint64());
   std::string diff;
@@ -389,10 +392,10 @@ TEST_F(CloneStateManagerTest, CreateSecondCloneState) {
     l.Commit();
 
     if (CloneStateInfoHelpers::IsDone(current_clone_state->LockForRead()->pb)) {
-      EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
-      ASSERT_OK(CreateCloneState(i + 1, DefaultTableSnapshotData()));
+      EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _, _));
+      ASSERT_OK(CreateCloneState(DefaultTableSnapshotData()));
     } else {
-      auto s = CreateCloneState(i + 1, DefaultTableSnapshotData());
+      auto s = CreateCloneState(DefaultTableSnapshotData());
       ASSERT_NOK(s);
       ASSERT_TRUE(s.status().IsAlreadyPresent());
     }
@@ -400,8 +403,8 @@ TEST_F(CloneStateManagerTest, CreateSecondCloneState) {
 }
 
 TEST_F(CloneStateManagerTest, ScheduleCloneOps) {
-  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
-  auto clone_state = ASSERT_RESULT(CreateCloneState(kSeqNo, DefaultTableSnapshotData()));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _, _));
+  auto clone_state = ASSERT_RESULT(CreateCloneState(DefaultTableSnapshotData()));
 
   for (int i = 0; i < kNumTablets; ++i) {
     tablet::CloneTabletRequestPB expected_req;
@@ -411,7 +414,7 @@ TEST_F(CloneStateManagerTest, ScheduleCloneOps) {
     expected_req.set_target_snapshot_id(kTargetSnapshotId.data(), kTargetSnapshotId.size());
     expected_req.set_target_table_id(kTargetTableId);
     expected_req.set_target_namespace_name(kTargetNamespaceName);
-    expected_req.set_clone_request_seq_no(kSeqNo);
+    expected_req.set_clone_request_seq_no(1);
     expected_req.set_target_pg_table_id(target_table_->pg_table_id());
     *expected_req.mutable_target_schema() = target_table_->LockForRead()->schema();
     *expected_req.mutable_target_partition_schema() =
@@ -527,7 +530,7 @@ TEST_F(CloneStateManagerTest, HandleRestoringStateRestored) {
   restoration->mutable_entry()->set_state(SysSnapshotEntryPB::RESTORED);
   EXPECT_CALL(MockFuncs(), ListRestorations(kRestorationId, _))
       .WillOnce(DoAll(SetArgPointee<1>(resp), Return(Status::OK())));
-  EXPECT_CALL(MockFuncs(), Upsert);
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
 
   // Should transition the clone to the COMPLETE state.
   ASSERT_OK(HandleRestoringState(clone_state));
@@ -569,8 +572,8 @@ TEST_F_EX(CloneStateManagerTest, AbortIfFailToSchedulePgCloneSchema, CloneStateM
 }
 
 TEST_F_EX(CloneStateManagerTest, AbortInPgSchemaClone, CloneStateManagerPgTest) {
-  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
-  auto clone_state = ASSERT_RESULT(CreateCloneState(kSeqNo, DefaultTableSnapshotData()));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _, _));
+  auto clone_state = ASSERT_RESULT(CreateCloneState(DefaultTableSnapshotData()));
   auto callback = MakeDoneClonePgSchemaCallback(
       clone_state, kSnapshotScheduleId, kTargetNamespaceName,
       CoarseMonoClock::Now() + 10s /* deadline */, kEpoch);
@@ -583,8 +586,8 @@ TEST_F_EX(CloneStateManagerTest, AbortInPgSchemaClone, CloneStateManagerPgTest)
 }
 
 TEST_F_EX(CloneStateManagerTest, AbortInStartTabletsCloningPg, CloneStateManagerPgTest) {
-  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
-  auto clone_state = ASSERT_RESULT(CreateCloneState(kSeqNo, DefaultTableSnapshotData()));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _, _));
+  auto clone_state = ASSERT_RESULT(CreateCloneState(DefaultTableSnapshotData()));
   auto callback = MakeDoneClonePgSchemaCallback(
       clone_state, kSnapshotScheduleId, kTargetNamespaceName,
       CoarseMonoClock::Now() + 10s /* deadline */, kEpoch);
@@ -634,7 +637,7 @@ TEST_F(CloneStateManagerTest, Load) {
   clone_state1.set_source_namespace_id(kSourceNamespaceId);
   clone_state1.set_target_namespace_name(kTargetNamespaceName);
   clone_state1.set_restore_time(kRestoreTime.ToUint64());
-  clone_state1.set_clone_request_seq_no(kSeqNo);
+  clone_state1.set_clone_request_seq_no(100);
 
   SysCloneStatePB clone_state2;
   clone_state2.set_aggregate_state(SysCloneStatePB::ABORTED);
@@ -642,7 +645,7 @@ TEST_F(CloneStateManagerTest, Load) {
   clone_state2.set_abort_message("Test abort message");
   clone_state2.set_target_namespace_name(kTargetNamespaceName);
   clone_state2.set_restore_time(kRestoreTime.ToUint64() + 1);
-  clone_state2.set_clone_request_seq_no(kSeqNo + 1);
+  clone_state2.set_clone_request_seq_no(101);
 
   // When the loader runs, we will save the function that is normally passed to
   // sys_catalog Load in 'inserter'.
diff --git a/src/yb/master/clone/clone_state_manager.cc b/src/yb/master/clone/clone_state_manager.cc
index f16d1c0754..454fbf151b 100644
--- a/src/yb/master/clone/clone_state_manager.cc
+++ b/src/yb/master/clone/clone_state_manager.cc
@@ -156,8 +156,12 @@ class CloneStateManagerExternalFunctions : public CloneStateManagerExternalFunct
 
   // Pick tserver to execute ClonePgSchema operation
   // TODO(Yamen): modify to choose the tserver the closest to the master leader.
-  TSDescriptorPtr PickTserver() override {
-    return catalog_manager_->GetAllLiveNotBlacklistedTServers()[0];
+  Result<TSDescriptorPtr> PickTserver() override {
+    const auto& tservers = catalog_manager_->GetAllLiveNotBlacklistedTServers();
+    if (tservers.empty()) {
+      return STATUS_FORMAT(RuntimeError, "No live tservers available");
+    }
+    return tservers[0];
   }
 
   // Sys catalog.
@@ -165,6 +169,12 @@ class CloneStateManagerExternalFunctions : public CloneStateManagerExternalFunct
     return sys_catalog_->Upsert(leader_term, clone_state);
   }
 
+  Status Upsert(
+      int64_t leader_term, const CloneStateInfoPtr& clone_state,
+      const NamespaceInfoPtr& source_namespace) override {
+    return sys_catalog_->Upsert(leader_term, clone_state, source_namespace);
+  }
+
   Status Load(
       const std::string& type,
       std::function<Status(const std::string&, const SysCloneStatePB&)> inserter) override {
@@ -256,14 +266,13 @@ Result<std::pair<NamespaceId, uint32_t>> CloneStateManager::CloneNamespace(
   }
   auto source_namespace = VERIFY_RESULT(
       external_funcs_->FindNamespace(source_namespace_identifier));
-  const auto& source_namespace_id = source_namespace->id();
 
   ListSnapshotSchedulesResponsePB resp;
   RETURN_NOT_OK(external_funcs_->ListSnapshotSchedules(&resp));
   auto snapshot_schedule_id = SnapshotScheduleId::Nil();
   for (const auto& schedule : resp.schedules()) {
     auto& tables = schedule.options().filter().tables().tables();
-    if (!tables.empty() && tables[0].namespace_().id() == source_namespace_id) {
+    if (!tables.empty() && tables[0].namespace_().id() == source_namespace->id()) {
       snapshot_schedule_id = VERIFY_RESULT(FullyDecodeSnapshotScheduleId(schedule.id()));
       break;
     }
@@ -274,12 +283,10 @@ Result<std::pair<NamespaceId, uint32_t>> CloneStateManager::CloneNamespace(
         source_namespace_identifier.name());
   }
 
-  auto seq_no = source_namespace->FetchAndIncrementCloneSeqNo();
-
   // Set up clone state.
   // Past this point, we should abort the clone state if we get a non-OK status from any step.
   auto clone_state = VERIFY_RESULT(CreateCloneState(
-      epoch, seq_no, source_namespace_id, source_namespace_identifier.database_type(),
+      epoch, source_namespace, source_namespace_identifier.database_type(),
       target_namespace_name, restore_time));
 
   // Clone PG Schema objects first in case of PGSQL databases. Tablets cloning is initiated in the
@@ -298,7 +305,7 @@ Result<std::pair<NamespaceId, uint32_t>> CloneStateManager::CloneNamespace(
   if (!status.ok()) {
     RETURN_NOT_OK(MarkCloneAborted(clone_state, status.ToString()));
   }
-  return make_pair(source_namespace_id, seq_no);
+  return make_pair(source_namespace->id(), clone_state->LockForRead()->pb.clone_request_seq_no());
 }
 
 Status CloneStateManager::StartTabletsCloning(
@@ -375,7 +382,7 @@ Status CloneStateManager::ClonePgSchemaObjects(
   }
 
   // Pick one of the live tservers to send ysql_dump and ysqlsh requests to.
-  auto ts = external_funcs_->PickTserver();
+  auto ts = VERIFY_RESULT(external_funcs_->PickTserver());
   auto ts_permanent_uuid = ts->permanent_uuid();
   // Deadline passed to the ClonePgSchemaTask (including rpc time and callback execution deadline)
   auto deadline = MonoTime::Now() + FLAGS_ysql_clone_pg_schema_rpc_timeout_ms * 1ms;
@@ -413,21 +420,25 @@ Status CloneStateManager::LoadCloneState(
 
   {
     std::lock_guard lock(mutex_);
-    source_clone_state_map_[metadata.source_namespace_id()].insert(clone_state);
+    auto [_, inserted] =
+      source_clone_state_map_[metadata.source_namespace_id()].insert(clone_state);
+    if (!inserted) {
+      LOG(WARNING) << Format("Duplicate clone state found for source namespace $0 with seq_no $1",
+                             metadata.source_namespace_id(), metadata.clone_request_seq_no());
+    }
   }
   return Status::OK();
 }
 
 Result<CloneStateInfoPtr> CloneStateManager::CreateCloneState(
     const LeaderEpoch& epoch,
-    uint32_t seq_no,
-    const NamespaceId& source_namespace_id,
+    const NamespaceInfoPtr& source_namespace,
     YQLDatabase database_type,
     const std::string& target_namespace_name,
     const HybridTime& restore_time) {
   // Check if there is an ongoing clone for the source namespace.
   std::lock_guard lock(mutex_);
-  auto it = source_clone_state_map_.find(source_namespace_id);
+  auto it = source_clone_state_map_.find(source_namespace->id());
   if (it != source_clone_state_map_.end()) {
     auto latest_clone_it = it->second.rbegin();
     if (latest_clone_it != it->second.rend()) {
@@ -435,12 +446,16 @@ Result<CloneStateInfoPtr> CloneStateManager::CreateCloneState(
       if (!CloneStateInfoHelpers::IsDone(lock->pb)) {
         return STATUS_FORMAT(
             AlreadyPresent, "Cannot create new clone state because there is already an ongoing "
-            "clone for source namespace $0 in state $1", source_namespace_id,
+            "clone for source namespace $0 in state $1", source_namespace->id(),
             lock->pb.aggregate_state());
       }
     }
   }
 
+  auto namespace_lock = source_namespace->LockForWrite();
+  auto seq_no = namespace_lock->pb.clone_request_seq_no() + 1;
+  namespace_lock.mutable_data()->pb.set_clone_request_seq_no(seq_no);
+
   auto clone_state = std::make_shared<CloneStateInfo>(GenerateObjectId());
   clone_state->SetDatabaseType(database_type);
   clone_state->SetEpoch(epoch);
@@ -448,14 +463,16 @@ Result<CloneStateInfoPtr> CloneStateManager::CreateCloneState(
   auto* pb = &clone_state->mutable_metadata()->mutable_dirty()->pb;
   pb->set_aggregate_state(SysCloneStatePB::CLONE_SCHEMA_STARTED);
   pb->set_clone_request_seq_no(seq_no);
-  pb->set_source_namespace_id(source_namespace_id);
+  pb->set_source_namespace_id(source_namespace->id());
   pb->set_restore_time(restore_time.ToUint64());
   pb->set_target_namespace_name(target_namespace_name);
-  RETURN_NOT_OK(external_funcs_->Upsert(clone_state->Epoch().leader_term, clone_state));
+  RETURN_NOT_OK(external_funcs_->Upsert(
+      clone_state->Epoch().leader_term, clone_state, source_namespace));
+  namespace_lock.Commit();
   clone_state->mutable_metadata()->CommitMutation();
 
   // Add to the in-memory map.
-  source_clone_state_map_[source_namespace_id].insert(clone_state);
+  source_clone_state_map_[source_namespace->id()].insert(clone_state);
 
   return clone_state;
 }
@@ -628,7 +645,7 @@ Status CloneStateManager::EnableDbConnections(const CloneStateInfoPtr& clone_sta
     return Status::OK();
   };
 
-  auto ts = external_funcs_->PickTserver();
+  auto ts = VERIFY_RESULT(external_funcs_->PickTserver());
   auto ts_permanent_uuid = ts->permanent_uuid();
   RETURN_NOT_OK(external_funcs_->ScheduleEnableDbConnectionsTask(
       ts_permanent_uuid, clone_state->LockForRead()->pb.target_namespace_name(), callback));
diff --git a/src/yb/master/clone/clone_state_manager.h b/src/yb/master/clone/clone_state_manager.h
index 6274453572..45dcf78228 100644
--- a/src/yb/master/clone/clone_state_manager.h
+++ b/src/yb/master/clone/clone_state_manager.h
@@ -67,8 +67,7 @@ class CloneStateManager {
 
   Result<CloneStateInfoPtr> CreateCloneState(
       const LeaderEpoch& epoch,
-      uint32_t seq_no,
-      const NamespaceId& source_namespace_id,
+      const NamespaceInfoPtr& source_namespace,
       YQLDatabase database_type,
       const std::string& target_namespace_name,
       const HybridTime& restore_time);
diff --git a/src/yb/master/clone/external_functions.h b/src/yb/master/clone/external_functions.h
index a90b7dc89d..abf1bf93bc 100644
--- a/src/yb/master/clone/external_functions.h
+++ b/src/yb/master/clone/external_functions.h
@@ -80,10 +80,11 @@ class CloneStateManagerExternalFunctionsBase {
     UDTypeMap* type_map, ExternalTableSnapshotDataMap* tables_data,
     CoarseTimePoint deadline) = 0;
 
-  virtual TSDescriptorPtr PickTserver() = 0;
+  virtual Result<TSDescriptorPtr> PickTserver() = 0;
 
   // Sys catalog.
   virtual Status Upsert(int64_t leader_term, const CloneStateInfoPtr&) = 0;
+  virtual Status Upsert(int64_t leader_term, const CloneStateInfoPtr&, const NamespaceInfoPtr&) = 0;
   virtual Status Load(
       const std::string& type,
       std::function<Status(const std::string&, const SysCloneStatePB&)> inserter) = 0;
