diff --git a/src/postgres/third-party-extensions/pg_cron/Makefile b/src/postgres/third-party-extensions/pg_cron/Makefile
index cc8d3ddcbd..953eb50b06 100644
--- a/src/postgres/third-party-extensions/pg_cron/Makefile
+++ b/src/postgres/third-party-extensions/pg_cron/Makefile
@@ -16,7 +16,7 @@ ifeq ($(CC),gcc)
 else
     PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-implicit-fallthrough -Wno-unused-function -Iinclude -I$(libpq_srcdir)
 endif
-SHLIB_LINK = $(libpq) -L$(YB_BUILD_ROOT)/lib -lyb_pggate $(filter -lintl,$(LIBS))
+SHLIB_LINK = $(libpq) -L$(YB_BUILD_ROOT)/lib -lyb_pggate -lyb_pggate_util $(filter -lintl,$(LIBS))
 EXTRA_CLEAN += $(addprefix src/,*.gcno *.gcda) # clean up after profiling runs
 
 ifdef USE_PGXS
diff --git a/src/postgres/third-party-extensions/pg_cron/src/pg_cron.c b/src/postgres/third-party-extensions/pg_cron/src/pg_cron.c
index 40272b0795..c2b2543b0b 100644
--- a/src/postgres/third-party-extensions/pg_cron/src/pg_cron.c
+++ b/src/postgres/third-party-extensions/pg_cron/src/pg_cron.c
@@ -151,8 +151,11 @@ static bool jobCanceled(CronTask *task);
 static bool jobStartupTimeout(CronTask *task, TimestampTz currentTime);
 static char* pg_cron_cmdTuples(char *msg);
 static void bgw_generate_returned_message(StringInfoData *display_msg, ErrorData edata);
+
 static long YbSecondsPassed(TimestampTz startTime, TimestampTz stopTime);
 static void YbCheckLeadership(List *taskList, TimestampTz currentTime);
+static TimestampTz YbGetLastPersistedMinute(TimestampTz currentTime);
+static void YbPersistLastMinute();
 
 /* global settings */
 char *CronTableDatabaseName = "yugabyte";
@@ -171,7 +174,9 @@ static int RunningTaskCount = 0;
 static int MaxRunningTasks = 0;
 static int CronLogMinMessages = WARNING;
 static bool UseBackgroundWorkers = true;
+
 static int YbJobListRefreshSeconds = 60;
+static TimestampTz YbLastMinuteToPersist = 0;
 
 char  *cron_timezone = NULL;
 
@@ -715,6 +720,13 @@ PgCronLauncherMain(Datum arg)
 		WaitForCronTasks(taskList);
 		ManageCronTasks(taskList, currentTime);
 
+		/*
+		 * YB Note: Persist the new minute after any new job run details runs
+		 * have been persisted. This ensures that on a crash we at the least log
+		 * a failed job run.
+		 */
+		YbPersistLastMinute();
+
 		MemoryContextReset(CronLoopContext);
 	}
 
@@ -798,7 +810,16 @@ StartAllPendingRuns(List *taskList, TimestampTz currentTime)
 
 	if (lastMinute == 0)
 	{
-		lastMinute = TimestampMinuteStart(currentTime);
+		if (IsYugaByteEnabled())
+		{
+			/* Get the persisted lastMinite so that we do no miss schedules when
+			 * the cron leader changes. */
+			lastMinute = YbGetLastPersistedMinute(currentTime);
+		}
+		else
+		{
+			lastMinute = TimestampMinuteStart(currentTime);
+		}
 	}
 
 	minutesPassed = MinutesPassed(lastMinute, currentTime);
@@ -861,6 +882,9 @@ StartAllPendingRuns(List *taskList, TimestampTz currentTime)
 	if (clockProgress != CLOCK_JUMP_BACKWARD)
 	{
 		lastMinute = TimestampMinuteStart(currentTime);
+
+		Assert(YbLastMinuteToPersist == 0);
+		YbLastMinuteToPersist = lastMinute;
 	}
 }
 
@@ -1389,6 +1413,19 @@ ManageCronTask(CronTask *task, TimestampTz currentTime)
 										cronJob->database,
 										cronJob->userName,
 										cronJob->command, GetCronStatus(CRON_STATUS_STARTING));
+
+			/*
+			 * YB Note: We need to persist the job run details for all tasks and
+			 * then the lastMinute before we can start execution. This ensures
+			 * at-most-once guarantees during failures, and that an aborted
+			 * run would be logged.
+			 * This will add an extra second to the job
+			 * run time. For interval jobs such a guarantee is not needed,
+			 * and the extra second will significantly affect the jobs so
+			 * run them immediately.
+			 */
+			if (IsYugaByteEnabled() && !task->secondsInterval)
+				break;
 		}
 
 		case CRON_TASK_START:
@@ -2499,3 +2536,23 @@ YbCheckLeadership(List *taskList, TimestampTz currentTime)
 		}
 	}
 }
+
+static TimestampTz
+YbGetLastPersistedMinute(TimestampTz currentTime)
+{
+	int64_t lastMinute = 0;
+	HandleYBStatus(YBCGetCronLastMinute(&lastMinute));
+	if (lastMinute == 0)
+		lastMinute = TimestampMinuteStart(currentTime);
+
+	return lastMinute;
+}
+
+static void
+YbPersistLastMinute()
+{
+	if (ybIsLeader && YbLastMinuteToPersist != 0)
+		HandleYBStatus(YBCSetCronLastMinute(YbLastMinuteToPersist));
+
+	YbLastMinuteToPersist = 0;
+}
diff --git a/src/yb/client/CMakeLists.txt b/src/yb/client/CMakeLists.txt
index b306a8337a..6018e80ce4 100644
--- a/src/yb/client/CMakeLists.txt
+++ b/src/yb/client/CMakeLists.txt
@@ -77,6 +77,7 @@ set(CLIENT_LIBS
   tserver_proto
   tserver_service_proto
   pg_auto_analyze_service_proto
+  pg_cron_leader_service_proto
   gutil
   test_echo_service_proto
   tserver_util
diff --git a/src/yb/client/stateful_services/pg_cron_leader_service_client.h b/src/yb/client/stateful_services/pg_cron_leader_service_client.h
new file mode 100644
index 0000000000..e08fd9a45f
--- /dev/null
+++ b/src/yb/client/stateful_services/pg_cron_leader_service_client.h
@@ -0,0 +1,27 @@
+// Copyright (c) YugaByte, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include "yb/client/stateful_services/stateful_service_client_base.h"
+#include "yb/tserver/stateful_services/pg_cron_leader_service.pb.h"
+#include "yb/tserver/stateful_services/pg_cron_leader_service.proxy.h"
+
+namespace yb::client {
+
+// PgCronLeaderServiceClient(client::YBClient& yb_client);
+DEFINE_STATEFUL_SERVICE_CLIENT(PgCronLeader, PG_CRON_LEADER,
+    PgCronSetLastMinute,
+    PgCronGetLastMinute);
+
+}  // namespace yb::client
diff --git a/src/yb/common/json_util.cc b/src/yb/common/json_util.cc
index 4d5113c514..b624c6cf2b 100644
--- a/src/yb/common/json_util.cc
+++ b/src/yb/common/json_util.cc
@@ -209,21 +209,43 @@ Result<const rapidjson::Value&> GetMember(const rapidjson::Value& root, const ch
   return it->value;
 }
 
-Result<std::string_view> GetMemberAsStr(const rapidjson::Value& root, const char* name) {
+template <typename T>
+Result<T> GetMemberAsType(
+    const rapidjson::Value& root, const char* name,
+    std::function<bool(const rapidjson::Value&)> is_valid_type_func,
+    std::function<T(const rapidjson::Value&)> extract_value_func) {
   const auto& member = VERIFY_RESULT_REF(GetMember(root, name));
-  if (!member.IsString()) {
+  if (!is_valid_type_func(member)) {
     return BadTypeStatus(member);
   }
-  return std::string_view(member.GetString(), member.GetStringLength());
+  return extract_value_func(member);
+}
+
+Result<uint32_t> GetMemberAsUint(rapidjson::Value& document, const char* element_name) {
+  return GetMemberAsType<uint32_t>(
+      document, element_name, [](const auto& value) { return value.IsUint(); },
+      [](const auto& value) { return value.GetUint(); });
+}
+
+Result<uint64_t> GetMemberAsUint64(rapidjson::Document& document, const char* element_name) {
+  return GetMemberAsType<uint64_t>(
+      document, element_name, [](const auto& value) { return value.IsUint64(); },
+      [](const auto& value) { return value.GetUint64(); });
+}
+
+Result<std::string_view> GetMemberAsStr(const rapidjson::Value& root, const char* name) {
+  return GetMemberAsType<std::string_view>(
+      root, name, [](const auto& member) { return member.IsString(); },
+      [](const auto& member) {
+        return std::string_view(member.GetString(), member.GetStringLength());
+      });
 }
 
 Result<rapidjson::Value::ConstArray> GetMemberAsArray(
     const rapidjson::Value& root, const char* name) {
-  const auto& member = VERIFY_RESULT_REF(GetMember(root, name));
-  if (!member.IsArray()) {
-    return BadTypeStatus(member);
-  }
-  return member.GetArray();
+  return GetMemberAsType<rapidjson::Value::ConstArray>(
+      root, name, [](const auto& member) { return member.IsArray(); },
+      [](const auto& member) { return member.GetArray(); });
 }
 
 } // namespace yb::common
diff --git a/src/yb/common/json_util.h b/src/yb/common/json_util.h
index aba1c338f5..d5fc077911 100644
--- a/src/yb/common/json_util.h
+++ b/src/yb/common/json_util.h
@@ -51,6 +51,8 @@ void AddMember(
 Result<rapidjson::Document> ParseJson(const std::string_view& raw);
 
 Result<const rapidjson::Value&> GetMember(const rapidjson::Value& root, const char* name);
+Result<uint32_t> GetMemberAsUint(rapidjson::Value& document, const char* element_name);
+Result<uint64_t> GetMemberAsUint64(rapidjson::Document& document, const char* element_name);
 Result<std::string_view> GetMemberAsStr(const rapidjson::Value& root, const char* name);
 Result<rapidjson::Value::ConstArray> GetMemberAsArray(
     const rapidjson::Value& root, const char* name);
diff --git a/src/yb/integration-tests/pg_cron-test.cc b/src/yb/integration-tests/pg_cron-test.cc
index 3f8a4c2f99..2db954032c 100644
--- a/src/yb/integration-tests/pg_cron-test.cc
+++ b/src/yb/integration-tests/pg_cron-test.cc
@@ -13,11 +13,21 @@
 
 #include <chrono>
 
+#include "yb/client/session.h"
+#include "yb/client/table_handle.h"
+#include "yb/client/yb_op.h"
+
 #include "yb/integration-tests/external_mini_cluster.h"
 #include "yb/integration-tests/yb_mini_cluster_test_base.h"
+
 #include "yb/master/master_client.pb.h"
+
+#include "yb/tserver/stateful_services/pg_cron_leader_service.h"
 #include "yb/tserver/stateful_services/stateful_service_base.h"
+
 #include "yb/util/backoff_waiter.h"
+
+#include "yb/yql/cql/ql/util/statement_result.h"
 #include "yb/yql/pgwrapper/libpq_utils.h"
 
 using namespace std::chrono_literals;
@@ -26,7 +36,7 @@ namespace yb {
 
 constexpr auto kTableName = "tbl1";
 constexpr auto kDefaultJobName = "Job1";
-constexpr auto kobListRefreshInterval = 10;
+constexpr auto kJobListRefreshInterval = 10;
 const client::YBTableName service_table_name =
     stateful_service::GetStatefulServiceTableName(StatefulServiceKind::PG_CRON_LEADER);
 const auto kTimeout = 60s * kTimeMultiplier;
@@ -50,9 +60,9 @@ class PgCronTest : public MiniClusterTestWithClient<ExternalMiniCluster> {
     opts.extra_tserver_flags.push_back("--allowed_preview_flags_csv=enable_pg_cron");
     opts.extra_tserver_flags.push_back("--enable_pg_cron=true");
     opts.extra_tserver_flags.push_back(
-        Format("--ysql_pg_conf_csv=cron.yb_job_list_refresh_interval=$0", kobListRefreshInterval));
+        Format("--ysql_pg_conf_csv=cron.yb_job_list_refresh_interval=$0", kJobListRefreshInterval));
     opts.extra_tserver_flags.push_back(
-        Format("--pg_cron_leader_lease_sec=$0", kobListRefreshInterval));
+        Format("--pg_cron_leader_lease_sec=$0", kJobListRefreshInterval));
     opts.extra_tserver_flags.push_back("--pg_cron_leadership_refresh_sec=1");
 
     cluster_.reset(new ExternalMiniCluster(opts));
@@ -89,11 +99,13 @@ class PgCronTest : public MiniClusterTestWithClient<ExternalMiniCluster> {
     return conn->Execute("CREATE EXTENSION pg_cron");
   }
 
+  std::string GetInsertQuery() {
+    return Format("INSERT INTO $0(a, node) VALUES (1, host(inet_server_addr()))", kTableName);
+  }
+
   Result<int64_t> Schedule1SecInsertJob(
       pgwrapper::PGConn* conn = nullptr, const std::string& job_name = kDefaultJobName) {
-    auto insert_query =
-        Format("INSERT INTO $0(a, node) VALUES (1, host(inet_server_addr()))", kTableName);
-    return ScheduleJob(job_name, "1 second", insert_query, conn);
+    return ScheduleJob(job_name, "1 second", GetInsertQuery(), conn);
   }
 
   // Returns the JobId
@@ -134,6 +146,58 @@ class PgCronTest : public MiniClusterTestWithClient<ExternalMiniCluster> {
     return conn->FetchRow<pgwrapper::PGUint64>(Format("SELECT COUNT(*) FROM $0", table_name));
   }
 
+  Status WaitForDataInPgCronLeaderTable() {
+    auto table_name =
+        stateful_service::GetStatefulServiceTableName(StatefulServiceKind::PG_CRON_LEADER);
+    client::TableHandle table;
+    RETURN_NOT_OK(table.Open(table_name, client_.get()));
+    auto session = client_->NewSession(kTimeout);
+
+    return LoggedWait(
+        [&]() -> Result<bool> {
+          auto read_op = table.NewReadOp();
+          auto* read_req = read_op->mutable_request();
+          table.AddColumns(
+              {stateful_service::kPgCronIdColName, stateful_service::kPgCronDataColName}, read_req);
+
+          RETURN_NOT_OK(session->TEST_ApplyAndFlush(read_op));
+          const auto row_block = ql::RowsResult(read_op.get()).GetRowBlock();
+
+          return row_block->row_count() > 0;
+        },
+        CoarseMonoClock::Now() + kTimeout, "Waiting for data in pg cron leader table");
+  }
+
+  Result<int64_t> GetPersistedLastMinute() {
+    auto table_name =
+        stateful_service::GetStatefulServiceTableName(StatefulServiceKind::PG_CRON_LEADER);
+    client::TableHandle table;
+    RETURN_NOT_OK(table.Open(table_name, client_.get()));
+    auto session = client_->NewSession(kTimeout);
+
+    auto read_op = table.NewReadOp();
+    auto* read_req = read_op->mutable_request();
+    table.AddColumns(
+        {stateful_service::kPgCronIdColName, stateful_service::kPgCronDataColName}, read_req);
+
+    RETURN_NOT_OK(session->TEST_ApplyAndFlush(read_op));
+    const auto row_block = ql::RowsResult(read_op.get()).GetRowBlock();
+    SCHECK_EQ(row_block->row_count(), 1, IllegalState, "Unexpected row count");
+
+    const auto& row = row_block->row(0);
+    LOG(INFO) << "Read row from Pg Cron leader table: " << row.ToString();
+
+    SCHECK_EQ(row.column_count(), 2, IllegalState, "More columns than expected");
+
+    const auto& key_value = row.column(0).value();
+    SCHECK(key_value.has_int64_value(), IllegalState, key_value.ShortDebugString());
+    SCHECK_EQ(
+        key_value.int64_value(), stateful_service::kPgCronDataKey, IllegalState,
+        "Unexpected key value");
+
+    return stateful_service::PgCronLeaderService::ExtractLastMinute(row.column(1));
+  }
+
   std::unique_ptr<pgwrapper::PGConn> conn_;
   TabletId tablet_id_;
 };
@@ -146,18 +210,18 @@ TEST_F(PgCronTest, AtMostOnceTest) {
   // Wait for the job to get picked up and run for a while.
   const auto default_sleep_sec = 10;
   const auto buffer_sec = 3;
-  const auto sleep_time_sec = kobListRefreshInterval + default_sleep_sec + buffer_sec;
+  const auto sleep_time_sec = kJobListRefreshInterval + default_sleep_sec + buffer_sec;
   SleepFor(sleep_time_sec * 1s);
 
   // Stop the job.
   ASSERT_OK(UnscheduleJob(job_id));
-  SleepFor(kobListRefreshInterval * 1s);
+  SleepFor(kJobListRefreshInterval * 1s);
 
   // Make sure we inserted the correct number of rows.
   auto row_count = ASSERT_RESULT(GetRowCount());
   ASSERT_GE(row_count, default_sleep_sec);
   // Max rows is the total amount of time we slept.
-  ASSERT_LE(row_count, sleep_time_sec + kobListRefreshInterval);
+  ASSERT_LE(row_count, sleep_time_sec + kJobListRefreshInterval);
 
   // Wait a little bit longer to make sure job is not running.
   SleepFor(default_sleep_sec * 1s);
@@ -172,14 +236,12 @@ TEST_F(PgCronTest, AtMostOnceTest) {
 
 // Run a job every minute and make sure it runs at most once.
 TEST_F(PgCronTest, PerMinuteTask) {
-  auto insert_query =
-      Format("INSERT INTO $0(a, node) VALUES (1, host(inet_server_addr()))", kTableName);
-  ASSERT_OK(ScheduleJob("job1", "* * * * *", insert_query));
+  ASSERT_OK(ScheduleJob("job1", "* * * * *", GetInsertQuery()));
 
   // Wait 2 minutes.
   const auto default_sleep_min = 2;
   const auto buffer_sec = 3;
-  const auto sleep_time_sec = kobListRefreshInterval + (60 * default_sleep_min) + buffer_sec;
+  const auto sleep_time_sec = kJobListRefreshInterval + (60 * default_sleep_min) + buffer_sec;
   SleepFor(sleep_time_sec * 1s);
 
   // We should have (default_sleep_min, default_sleep_min+1) rows.
@@ -218,7 +280,8 @@ TEST_F(PgCronTest, JobOnDifferentDB) {
 
   // Wait 2 minutes.
   const auto default_sleep_min = 2;
-  const auto sleep_time = MonoDelta::FromSeconds(kobListRefreshInterval + (60 * default_sleep_min));
+  const auto sleep_time =
+      MonoDelta::FromSeconds(kJobListRefreshInterval + (60 * default_sleep_min));
   const auto start = MonoTime::Now();
 
   for (int i = 0; MonoTime::Now() - start < sleep_time; i++) {
@@ -237,16 +300,24 @@ TEST_F(PgCronTest, JobOnDifferentDB) {
 }
 
 // Make sure pg_cron can survive the crash of the leader tserver/postgres process.
-TEST_F(PgCronTest, LeaderCrash) {
+TEST_F(PgCronTest, LeaderCrash1) {
   // Schedule a 1sec job.
   const auto job_id = ASSERT_RESULT(Schedule1SecInsertJob());
 
+  ASSERT_OK(WaitForDataInPgCronLeaderTable());
+
+  // Let the job run a few times.
   // Wait for the job to get picked up and run for a while.
   const auto default_sleep_sec = 10;
   const auto kSleepBuffer = 3s;
-  const auto sleep_time = (kobListRefreshInterval + default_sleep_sec) * 1s + kSleepBuffer;
+  const auto sleep_time = (kJobListRefreshInterval + default_sleep_sec) * 1s + kSleepBuffer;
   SleepFor(sleep_time);
 
+  auto row_count1 = ASSERT_RESULT(GetRowCount());
+  ASSERT_GT(row_count1, 0);
+
+  const auto start_last_minute = ASSERT_RESULT(GetPersistedLastMinute());
+
   // Verify GetStatefulServiceLocation returns the correct location.
   auto initial_leader_idx = ASSERT_RESULT(cluster_->GetTabletLeaderIndex(tablet_id_));
   auto location =
@@ -271,29 +342,32 @@ TEST_F(PgCronTest, LeaderCrash) {
   ASSERT_NE(final_leader_idx, initial_leader_idx);
 
   // Make sure new leader is running jobs.
-  auto row_count = ASSERT_RESULT(GetRowCount());
-  SleepFor(sleep_time);
   auto row_count2 = ASSERT_RESULT(GetRowCount());
-  ASSERT_GT(row_count2, row_count);
+  // Wait for the minute to change.
+  const auto sleep_time_sec = 70;
+  SleepFor(sleep_time_sec * 1s);
+  auto row_count3 = ASSERT_RESULT(GetRowCount());
+  ASSERT_GT(row_count3, row_count2);
+  auto last_minute = ASSERT_RESULT(GetPersistedLastMinute());
+  ASSERT_GT(last_minute, start_last_minute);
 
   // Stop the job.
   ASSERT_OK(UnscheduleJob(job_id));
-  SleepFor(kobListRefreshInterval * 1s);
+  SleepFor(kJobListRefreshInterval * 1s);
 
-  // Make sure we inserted the minumum number of rows.
-  auto row_count3 = ASSERT_RESULT(GetRowCount());
-  ASSERT_GE(row_count3, 2 * default_sleep_sec);
+  // Final row count.
+  auto row_count4 = ASSERT_RESULT(GetRowCount());
 
   // Wait a little bit longer to make sure job is not running.
-  SleepFor(default_sleep_sec * 1s);
-  auto row_count4 = ASSERT_RESULT(GetRowCount());
-  ASSERT_EQ(row_count3, row_count4);
+  SleepFor(kJobListRefreshInterval * 1s);
+  auto row_count5 = ASSERT_RESULT(GetRowCount());
+  ASSERT_EQ(row_count4, row_count5);
 
   // Make it was cron that inserted all the rows inserted rows.
   auto job_run_count = ASSERT_RESULT(
       conn_->FetchRow<pgwrapper::PGUint64>("SELECT COUNT(*) FROM cron.job_run_details"));
   // May not be equal as some run might have failed midway.
-  ASSERT_LE(row_count3, job_run_count);
+  ASSERT_LE(row_count4, job_run_count);
 
   // YBMiniClusterTestBase test-end verification will fail if the cluster is up with stopped nodes.
   cluster_->Shutdown();
@@ -307,9 +381,12 @@ TEST_F(PgCronTest, GracefulLeaderMove) {
   // Wait for the job to get picked up and run for a while.
   const auto default_sleep_sec = 10;
   const auto kSleepBuffer = 3s;
-  const auto sleep_time = (kobListRefreshInterval + default_sleep_sec) * 1s + kSleepBuffer;
+  const auto sleep_time = (kJobListRefreshInterval + default_sleep_sec) * 1s + kSleepBuffer;
   SleepFor(sleep_time);
 
+  ASSERT_OK(WaitForDataInPgCronLeaderTable());
+  const auto start_last_minute = ASSERT_RESULT(GetPersistedLastMinute());
+
   ASSERT_OK(cluster_->MoveTabletLeader(tablet_id_));
   ASSERT_OK(cluster_->WaitForLoadBalancerToBecomeIdle(client_, kTimeout));
 
@@ -318,10 +395,12 @@ TEST_F(PgCronTest, GracefulLeaderMove) {
   SleepFor(sleep_time);
   auto row_count2 = ASSERT_RESULT(GetRowCount());
   ASSERT_GT(row_count2, row_count);
+  auto last_minute = ASSERT_RESULT(GetPersistedLastMinute());
+  ASSERT_GE(last_minute, start_last_minute);
 
   // Stop the job.
   ASSERT_OK(UnscheduleJob(job_id));
-  SleepFor(kobListRefreshInterval * 1s);
+  SleepFor(kJobListRefreshInterval * 1s);
 
   // Make sure we inserted the minumum number of rows.
   auto row_count3 = ASSERT_RESULT(GetRowCount());
@@ -350,7 +429,7 @@ TEST_F(PgCronTest, ChangeCronDB) {
   // Wait for the job to get picked up and run for a while.
   const auto default_sleep_sec = 10;
   const auto kSleepBuffer = 3s;
-  const auto sleep_time = (kobListRefreshInterval + default_sleep_sec) * 1s + kSleepBuffer;
+  const auto sleep_time = (kJobListRefreshInterval + default_sleep_sec) * 1s + kSleepBuffer;
   SleepFor(sleep_time);
 
   // Change the cron database with a restart.
@@ -387,4 +466,81 @@ TEST_F(PgCronTest, ChangeCronDB) {
   ASSERT_LE(new_db_row_count2, new_db_job_run_count);
 }
 
+TEST_F(PgCronTest, ValidateStoredLastMinute) {
+  // Wait till the cron leader has picked up the extension create.
+  ASSERT_OK(WaitForDataInPgCronLeaderTable());
+
+  const auto start_last_minute = ASSERT_RESULT(GetPersistedLastMinute());
+
+  const auto kSleepBuffer = 3s;
+  SleepFor(1min + kSleepBuffer);
+
+  auto last_minute1 = ASSERT_RESULT(GetPersistedLastMinute());
+  ASSERT_GT(last_minute1, start_last_minute);
+
+  ASSERT_OK(conn_->Execute("DROP EXTENSION pg_cron"));
+  SleepFor(kJobListRefreshInterval * 1s + kSleepBuffer);
+  const auto last_minute2 = ASSERT_RESULT(GetPersistedLastMinute());
+
+  // Make sure the last minute is not updated.
+  SleepFor(1min + kSleepBuffer);
+  auto last_minute3 = ASSERT_RESULT(GetPersistedLastMinute());
+  ASSERT_GT(last_minute3, last_minute2);
+
+  ASSERT_OK(CreateCronExtension());
+  SleepFor(1min + kSleepBuffer);
+  auto last_minute4 = ASSERT_RESULT(GetPersistedLastMinute());
+  ASSERT_GT(last_minute4, last_minute3);
+}
+
+// Make sure the per minute job runs every minute even if the cron leader moves.
+TEST_F(PgCronTest, PerMinuteTaskWithLeaderMove) {
+  ASSERT_OK(ScheduleJob("job1", "* * * * *", GetInsertQuery()));
+  const auto kSleepBuffer = 3s;
+  SleepFor(kJobListRefreshInterval * 1s + kSleepBuffer + 60s);
+  const auto initial_row_count = ASSERT_RESULT(GetRowCount());
+  ASSERT_GE(initial_row_count, 1);
+  ASSERT_LE(initial_row_count, 2);
+
+  ASSERT_OK(cluster_->MoveTabletLeader(tablet_id_));
+
+  // Wait 2 minutes.
+  const auto default_sleep_min = 2;
+  const auto buffer_sec = 3;
+  const auto sleep_time_sec = kJobListRefreshInterval + (60 * default_sleep_min) + buffer_sec;
+  SleepFor(sleep_time_sec * 1s);
+
+  // We should have (default_sleep_min, default_sleep_min+1) rows.
+  auto row_count = ASSERT_RESULT(GetRowCount());
+  ASSERT_GE(row_count, default_sleep_min + initial_row_count);
+  ASSERT_LE(row_count, default_sleep_min + initial_row_count + 1);
+}
+
+TEST_F(PgCronTest, FailBeforeStoringLastMinute) {
+  ASSERT_OK(WaitForDataInPgCronLeaderTable());
+
+  ASSERT_OK(cluster_->SetFlagOnTServers("TEST_pg_cron_fail_setting_last_minute", "true"));
+
+  ASSERT_OK(ScheduleJob("job1", "* * * * *", GetInsertQuery()));
+
+  SleepFor(70s);
+
+  auto succeeded_runs = ASSERT_RESULT(conn_->FetchRow<pgwrapper::PGUint64>(
+      "SELECT COUNT(*) FROM cron.job_run_details WHERE status = 'succeeded' "));
+  ASSERT_EQ(succeeded_runs, 0);
+
+  auto failed_runs = ASSERT_RESULT(conn_->FetchRow<pgwrapper::PGUint64>(
+      "SELECT COUNT(*) FROM cron.job_run_details WHERE status = 'failed' "));
+  ASSERT_GT(failed_runs, 0);
+
+  auto row_count = ASSERT_RESULT(GetRowCount());
+  ASSERT_EQ(row_count, 0);
+
+  ASSERT_OK(cluster_->SetFlagOnTServers("TEST_pg_cron_fail_setting_last_minute", "false"));
+  SleepFor(10s * kTimeMultiplier);
+
+  row_count = ASSERT_RESULT(GetRowCount());
+  ASSERT_GT(row_count, 0);
+}
+
 }  // namespace yb
diff --git a/src/yb/tserver/CMakeLists.txt b/src/yb/tserver/CMakeLists.txt
index 51f7a4c355..ba650de8eb 100644
--- a/src/yb/tserver/CMakeLists.txt
+++ b/src/yb/tserver/CMakeLists.txt
@@ -187,6 +187,24 @@ ADD_YB_LIBRARY(pg_auto_analyze_service_proto
   DEPS ${TSERVER_YRPC_LIBS}
   NONLINK_DEPS ${TSERVER_YRPC_TGTS})
 
+#########################################
+# pg_cron_leader_service_proto
+#########################################
+
+YRPC_GENERATE(
+  TSERVER_YRPC_SRCS TSERVER_YRPC_HDRS TSERVER_YRPC_TGTS
+  SOURCE_ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../..
+  BINARY_ROOT ${CMAKE_CURRENT_BINARY_DIR}/../..
+  PROTO_FILES stateful_services/pg_cron_leader_service.proto)
+set(TSERVER_YRPC_LIBS
+  yrpc
+  yb_common_proto
+  protobuf)
+ADD_YB_LIBRARY(pg_cron_leader_service_proto
+  SRCS ${TSERVER_YRPC_SRCS}
+  DEPS ${TSERVER_YRPC_LIBS}
+  NONLINK_DEPS ${TSERVER_YRPC_TGTS})
+
 #########################################
 # tserver_util
 #########################################
diff --git a/src/yb/tserver/pg_client.proto b/src/yb/tserver/pg_client.proto
index 0988a148b4..c74981548b 100644
--- a/src/yb/tserver/pg_client.proto
+++ b/src/yb/tserver/pg_client.proto
@@ -116,6 +116,12 @@ service PgClientService {
 
   rpc YCQLStatementStats(PgYCQLStatementStatsRequestPB)
       returns (PgYCQLStatementStatsResponsePB);
+
+  rpc CronSetLastMinute(PgCronSetLastMinuteRequestPB)
+      returns (PgCronSetLastMinuteResponsePB);
+
+  rpc CronGetLastMinute(PgCronGetLastMinuteRequestPB)
+  returns (PgCronGetLastMinuteResponsePB);
 }
 
 // TODO: Remove the OptionalUint32PB helper message after updating protobuf generator to allow
@@ -987,3 +993,19 @@ message PgServersMetricsResponsePB {
   AppStatusPB status = 1;
   repeated PgServerMetricsInfoPB servers_metrics = 2;
 }
+
+message PgCronSetLastMinuteRequestPB {
+  int64 last_minute = 1;
+}
+
+message PgCronSetLastMinuteResponsePB {
+  AppStatusPB status = 1;
+}
+
+message PgCronGetLastMinuteRequestPB {
+}
+
+message PgCronGetLastMinuteResponsePB {
+  int64 last_minute = 1;
+  AppStatusPB status = 2;
+}
diff --git a/src/yb/tserver/pg_client_service.cc b/src/yb/tserver/pg_client_service.cc
index 9f9ca88c75..abfabff939 100644
--- a/src/yb/tserver/pg_client_service.cc
+++ b/src/yb/tserver/pg_client_service.cc
@@ -28,6 +28,7 @@
 #include "yb/client/client.h"
 #include "yb/client/meta_cache.h"
 #include "yb/client/schema.h"
+#include "yb/client/stateful_services/pg_cron_leader_service_client.h"
 #include "yb/client/table.h"
 #include "yb/client/table_creator.h"
 #include "yb/client/table_info.h"
@@ -1774,7 +1775,33 @@ class PgClientServiceImpl::Impl {
     return Status::OK();
   }
 
-  #define PG_CLIENT_SESSION_METHOD_FORWARD(r, data, method) \
+  Status CronSetLastMinute(
+      const PgCronSetLastMinuteRequestPB& req, PgCronSetLastMinuteResponsePB* resp,
+      rpc::RpcContext* context) {
+    auto controller = std::make_shared<rpc::RpcController>();
+    controller->set_deadline(context->GetClientDeadline());
+
+    stateful_service::PgCronSetLastMinuteRequestPB stateful_service_req;
+    stateful_service_req.set_last_minute(req.last_minute());
+    RETURN_NOT_OK(client::PgCronLeaderServiceClient(client()).PgCronSetLastMinute(
+        stateful_service_req, context->GetClientDeadline()));
+
+    return Status::OK();
+  }
+
+  Status CronGetLastMinute(
+      const PgCronGetLastMinuteRequestPB& req, PgCronGetLastMinuteResponsePB* resp,
+      rpc::RpcContext* context) {
+    stateful_service::PgCronGetLastMinuteRequestPB stateful_service_req;
+    auto stateful_service_resp =
+        VERIFY_RESULT(client::PgCronLeaderServiceClient(client()).PgCronGetLastMinute(
+            stateful_service_req, context->GetClientDeadline()));
+
+    resp->set_last_minute(stateful_service_resp.last_minute());
+    return Status::OK();
+  }
+
+#define PG_CLIENT_SESSION_METHOD_FORWARD(r, data, method) \
   Status method( \
       const BOOST_PP_CAT(BOOST_PP_CAT(Pg, method), RequestPB)& req, \
       BOOST_PP_CAT(BOOST_PP_CAT(Pg, method), ResponsePB)* resp, \
diff --git a/src/yb/tserver/pg_client_service.h b/src/yb/tserver/pg_client_service.h
index a38a7618e8..fb79aea9ec 100644
--- a/src/yb/tserver/pg_client_service.h
+++ b/src/yb/tserver/pg_client_service.h
@@ -92,6 +92,8 @@ class TserverXClusterContextIf;
     (ValidatePlacement) \
     (WaitForBackendsCatalogVersion) \
     (YCQLStatementStats) \
+    (CronSetLastMinute) \
+    (CronGetLastMinute) \
     /**/
 
 // Forwards call to corresponding PgClientSession async method (see
diff --git a/src/yb/tserver/stateful_services/pg_auto_analyze_service.cc b/src/yb/tserver/stateful_services/pg_auto_analyze_service.cc
index 8f8905cf2a..fda13a8404 100644
--- a/src/yb/tserver/stateful_services/pg_auto_analyze_service.cc
+++ b/src/yb/tserver/stateful_services/pg_auto_analyze_service.cc
@@ -502,7 +502,8 @@ Result<bool> PgAutoAnalyzeService::RunPeriodicTask() {
 }
 
 Status PgAutoAnalyzeService::IncreaseMutationCountersImpl(
-    const IncreaseMutationCountersRequestPB& req, IncreaseMutationCountersResponsePB* resp) {
+    const IncreaseMutationCountersRequestPB& req, IncreaseMutationCountersResponsePB* resp,
+    rpc::RpcContext& rpc) {
   VLOG_WITH_FUNC(3) << "req=" << req.ShortDebugString();
 
   for (const auto& elem : req.table_mutation_counts()) {
diff --git a/src/yb/tserver/stateful_services/pg_cron_leader_service.cc b/src/yb/tserver/stateful_services/pg_cron_leader_service.cc
index 4b0f5eb3d4..29fe7d9953 100644
--- a/src/yb/tserver/stateful_services/pg_cron_leader_service.cc
+++ b/src/yb/tserver/stateful_services/pg_cron_leader_service.cc
@@ -12,6 +12,16 @@
 //
 
 #include "yb/tserver/stateful_services/pg_cron_leader_service.h"
+#include <rapidjson/document.h>
+
+#include "yb/client/session.h"
+#include "yb/client/yb_op.h"
+
+#include "yb/common/jsonb.h"
+#include "yb/common/json_util.h"
+#include "yb/yql/cql/ql/util/statement_result.h"
+
+using namespace std::chrono_literals;
 
 DECLARE_bool(enable_pg_cron);
 
@@ -22,6 +32,8 @@ DEFINE_RUNTIME_uint32(pg_cron_leadership_refresh_sec, 10,
     "Frequency at which the leadership is revalidated. This should be less than "
     "pg_cron_leader_lease_sec");
 
+DEFINE_test_flag(bool, pg_cron_fail_setting_last_minute, false, "Fail setting the last minute");
+
 DECLARE_uint64(max_clock_skew_usec);
 
 namespace {
@@ -45,10 +57,17 @@ DEFINE_validator(pg_cron_leadership_refresh_sec, &ValidateLeadershipRefreshSec);
 namespace yb {
 namespace stateful_service {
 
+namespace {
+constexpr uint32 kPgCronJsonVersion1 = 1;
+constexpr char kPgCronJsonVersion[] = "version";
+constexpr char kPgCronJsonLastMinute[] = "last_minute";
+}  // namespace
+
 PgCronLeaderService::PgCronLeaderService(
     std::function<void(MonoTime)> set_cron_leader_lease_fn,
+    const scoped_refptr<MetricEntity>& metric_entity,
     const std::shared_future<client::YBClient*>& client_future)
-    : StatefulServiceBase(StatefulServiceKind::PG_CRON_LEADER, client_future),
+    : StatefulRpcServiceBase(StatefulServiceKind::PG_CRON_LEADER, metric_entity, client_future),
       set_cron_leader_lease_fn_(std::move(set_cron_leader_lease_fn)) {}
 
 void PgCronLeaderService::Activate() {
@@ -129,5 +148,100 @@ void PgCronLeaderService::RefreshLeaderLease() {
   set_cron_leader_lease_fn_(lease_end);
 }
 
+Status PgCronLeaderService::SetLastMinute(int64_t last_minute, CoarseTimePoint deadline) {
+  VLOG_WITH_FUNC(1) << YB_STRUCT_TO_STRING(last_minute);
+
+  auto session = VERIFY_RESULT(GetYBSession(deadline));
+  auto* table = VERIFY_RESULT(GetServiceTable());
+
+  auto write_op = table->NewWriteOp(QLWriteRequestPB::QL_STMT_UPDATE);
+  auto* const req = write_op->mutable_request();
+  QLAddInt64HashValue(req, kPgCronDataKey);
+
+  rapidjson::Document document;
+  document.SetObject();
+  document.AddMember(kPgCronJsonVersion, kPgCronJsonVersion1, document.GetAllocator());
+  document.AddMember(kPgCronJsonLastMinute, last_minute, document.GetAllocator());
+
+  common::Jsonb jsonb;
+  RETURN_NOT_OK(jsonb.FromRapidJson(document));
+  table->AddJsonbColumnValue(req, kPgCronDataColName, jsonb.MoveSerializedJsonb());
+
+  // TODO(async_flush): https://github.com/yugabyte/yugabyte-db/issues/12173
+  RETURN_NOT_OK_PREPEND(
+      session->TEST_ApplyAndFlush(std::move(write_op)), "Failed to update pg cron leader table");
+
+  return Status::OK();
+}
+
+Result<int64_t> PgCronLeaderService::ExtractLastMinute(const QLValue& column_value) {
+  SCHECK(column_value.value().has_jsonb_value(), IllegalState, "Column missing JSON value");
+
+  common::Jsonb jsonb(column_value.value().jsonb_value());
+  rapidjson::Document document;
+  RETURN_NOT_OK(jsonb.ToRapidJson(&document));
+  const auto version = VERIFY_RESULT(common::GetMemberAsUint(document, kPgCronJsonVersion));
+  SCHECK_EQ(version, kPgCronJsonVersion1, IllegalState, "Unexpected JSONB version");
+
+  return common::GetMemberAsUint64(document, kPgCronJsonLastMinute);
+}
+
+Result<int64_t> PgCronLeaderService::GetLastMinute(CoarseTimePoint deadline) {
+  VLOG_WITH_FUNC(1);
+
+  auto session = VERIFY_RESULT(GetYBSession(deadline));
+  auto* table = VERIFY_RESULT(GetServiceTable());
+
+  auto read_op = table->NewReadOp();
+  auto* const read_req = read_op->mutable_request();
+  QLAddInt64HashValue(read_req, kPgCronDataKey);
+  table->AddColumns({kPgCronDataColName}, read_req);
+
+  // TODO(async_flush): https://github.com/yugabyte/yugabyte-db/issues/12173
+  RETURN_NOT_OK_PREPEND(
+      session->TEST_ApplyAndFlush(read_op), "Failed to read from pg cron leader table");
+
+  const auto row_block = ql::RowsResult(read_op.get()).GetRowBlock();
+  if (row_block->rows().empty()) {
+    YB_LOG_EVERY_N_SECS(INFO, 10)
+        << "Returning 0 as last time since no previous stored data was found";
+    return 0;
+  }
+
+  auto& row_schema = row_block->schema();
+  auto data_idx = row_schema.find_column(kPgCronDataColName);
+  SCHECK_EQ(row_block->rows().size(), 1, IllegalState, "Expected exactly one row");
+  const auto last_minute =
+      VERIFY_RESULT(ExtractLastMinute(row_block->rows().front().column(data_idx)));
+
+  VLOG(1) << "Retrieved last_minute: " << last_minute;
+
+  return last_minute;
+}
+
+Status PgCronLeaderService::PgCronSetLastMinuteImpl(
+    const PgCronSetLastMinuteRequestPB& req, PgCronSetLastMinuteResponsePB* resp,
+    rpc::RpcContext& rpc) {
+  VLOG_WITH_FUNC(3) << req.ShortDebugString();
+  SCHECK_GT(req.last_minute(), 0, InvalidArgument, "Invalid time");
+
+  SCHECK(
+      !FLAGS_TEST_pg_cron_fail_setting_last_minute, InternalError,
+      "Failing setting last minute for test");
+
+  return SetLastMinute(req.last_minute(), rpc.GetClientDeadline());
+}
+
+Status PgCronLeaderService::PgCronGetLastMinuteImpl(
+    const PgCronGetLastMinuteRequestPB& req, PgCronGetLastMinuteResponsePB* resp,
+    rpc::RpcContext& rpc) {
+  VLOG_WITH_FUNC(3) << req.ShortDebugString();
+
+  auto last_minute = VERIFY_RESULT(GetLastMinute(rpc.GetClientDeadline()));
+  resp->set_last_minute(last_minute);
+
+  return Status::OK();
+}
+
 }  // namespace stateful_service
 }  // namespace yb
diff --git a/src/yb/tserver/stateful_services/pg_cron_leader_service.h b/src/yb/tserver/stateful_services/pg_cron_leader_service.h
index 72bd58cc6c..13f8ba7304 100644
--- a/src/yb/tserver/stateful_services/pg_cron_leader_service.h
+++ b/src/yb/tserver/stateful_services/pg_cron_leader_service.h
@@ -16,15 +16,27 @@
 #include <shared_mutex>
 
 #include "yb/tserver/stateful_services/stateful_service_base.h"
+#include "yb/tserver/stateful_services/pg_cron_leader_service.service.h"
 
 namespace yb {
+
+class PgCronTest;
+
 namespace stateful_service {
-class PgCronLeaderService : public StatefulServiceBase {
+
+constexpr char kPgCronIdColName[] = "id";
+constexpr char kPgCronDataColName[] = "data";
+const uint64_t kPgCronDataKey = 1;
+
+class PgCronLeaderService : public StatefulRpcServiceBase<PgCronLeaderServiceIf> {
  public:
   PgCronLeaderService(
       std::function<void(MonoTime)> set_cron_leader_lease_fn,
+      const scoped_refptr<MetricEntity>& metric_entity,
       const std::shared_future<client::YBClient*>& client_future);
 
+  STATEFUL_SERVICE_IMPL_METHODS(PgCronSetLastMinute, PgCronGetLastMinute);
+
  protected:
   void Activate() override;
   void Deactivate() override;
@@ -33,8 +45,14 @@ class PgCronLeaderService : public StatefulServiceBase {
   void DrainForDeactivation() override {}
 
  private:
+  friend class ::yb::PgCronTest;
   void RefreshLeaderLease() EXCLUDES(mutex_);
 
+  Status SetLastMinute(int64_t last_minute, CoarseTimePoint deadline);
+  Result<int64_t> GetLastMinute(CoarseTimePoint deadline);
+
+  static Result<int64_t> ExtractLastMinute(const QLValue& column_value);
+
   std::function<void(MonoTime)> set_cron_leader_lease_fn_;
 
   std::shared_mutex mutex_;
diff --git a/src/yb/tserver/stateful_services/pg_cron_leader_service.proto b/src/yb/tserver/stateful_services/pg_cron_leader_service.proto
new file mode 100644
index 0000000000..e3aaf9f389
--- /dev/null
+++ b/src/yb/tserver/stateful_services/pg_cron_leader_service.proto
@@ -0,0 +1,45 @@
+// Copyright (c) YugaByte, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not
+// use this file except in compliance with the License.  You may obtain a copy
+// of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+// License for the specific language governing permissions and limitations under
+// the License.
+//
+
+syntax = "proto3";
+
+package yb.stateful_service;
+
+option java_package = "org.yb.stateful_service";
+
+import "yb/common/wire_protocol.proto";
+
+service PgCronLeaderService {
+  rpc PgCronSetLastMinute(PgCronSetLastMinuteRequestPB)
+      returns (PgCronSetLastMinuteResponsePB);
+  rpc PgCronGetLastMinute(PgCronGetLastMinuteRequestPB)
+      returns (PgCronGetLastMinuteResponsePB);
+}
+
+message PgCronSetLastMinuteRequestPB {
+  int64 last_minute = 1;
+}
+
+message PgCronSetLastMinuteResponsePB {
+  AppStatusPB error = 1;
+}
+
+message PgCronGetLastMinuteRequestPB {
+}
+
+message PgCronGetLastMinuteResponsePB {
+  int64 last_minute = 1;
+  AppStatusPB error = 2;
+}
diff --git a/src/yb/tserver/stateful_services/stateful_service_base.cc b/src/yb/tserver/stateful_services/stateful_service_base.cc
index 0457f4b70a..4776205935 100644
--- a/src/yb/tserver/stateful_services/stateful_service_base.cc
+++ b/src/yb/tserver/stateful_services/stateful_service_base.cc
@@ -375,6 +375,13 @@ Result<std::shared_ptr<client::YBSession>> StatefulServiceBase::GetYBSession(Mon
   return session;
 }
 
+Result<std::shared_ptr<client::YBSession>> StatefulServiceBase::GetYBSession(
+    CoarseTimePoint deadline) {
+  auto session = GetYBClient()->NewSession(deadline);
+  session->SetLeaderTerm(VERIFY_RESULT(GetLeaderTerm()));
+  return session;
+}
+
 Result<client::TableHandle*> StatefulServiceBase::GetServiceTable() {
   std::lock_guard l(table_handle_mutex_);
 
diff --git a/src/yb/tserver/stateful_services/stateful_service_base.h b/src/yb/tserver/stateful_services/stateful_service_base.h
index 2feeaa363f..d6fd4e15df 100644
--- a/src/yb/tserver/stateful_services/stateful_service_base.h
+++ b/src/yb/tserver/stateful_services/stateful_service_base.h
@@ -49,13 +49,13 @@ namespace stateful_service {
 #define STATEFUL_SERVICE_IMPL_METHOD_HELPER(i, data, method_name) \
   Status BOOST_PP_CAT(method_name, Impl)( \
       const BOOST_PP_CAT(method_name, RequestPB) & req, \
-      BOOST_PP_CAT(method_name, ResponsePB) * resp); \
+      BOOST_PP_CAT(method_name, ResponsePB) * resp, rpc::RpcContext & rpc); \
   void method_name( \
       const BOOST_PP_CAT(method_name, RequestPB) * req, \
-      BOOST_PP_CAT(method_name, ResponsePB) * resp, \
-      rpc::RpcContext rpc) override { \
-    HandleRpcRequestWithTermCheck( \
-        resp, &rpc, [req, resp, this]() { return BOOST_PP_CAT(method_name, Impl)(*req, resp); }); \
+      BOOST_PP_CAT(method_name, ResponsePB) * resp, rpc::RpcContext rpc) override { \
+    HandleRpcRequestWithTermCheck(resp, &rpc, [req, resp, &rpc, this]() { \
+      return BOOST_PP_CAT(method_name, Impl)(*req, resp, rpc); \
+    }); \
   }
 
 class StatefulServiceBase {
@@ -105,6 +105,7 @@ class StatefulServiceBase {
   Result<int64_t> GetLeaderTerm() EXCLUDES(service_state_mutex_);
 
   Result<std::shared_ptr<client::YBSession>> GetYBSession(MonoDelta delta);
+  Result<std::shared_ptr<client::YBSession>> GetYBSession(CoarseTimePoint deadline);
 
   Result<client::TableHandle*> GetServiceTable() EXCLUDES(table_handle_mutex_);
 
diff --git a/src/yb/tserver/stateful_services/test_echo_service.cc b/src/yb/tserver/stateful_services/test_echo_service.cc
index daf80c08f8..f9b979bfb7 100644
--- a/src/yb/tserver/stateful_services/test_echo_service.cc
+++ b/src/yb/tserver/stateful_services/test_echo_service.cc
@@ -90,7 +90,8 @@ Status TestEchoService::ReloadEchoCountFromTable() {
   return Status::OK();
 }
 
-Status TestEchoService::GetEchoImpl(const GetEchoRequestPB& req, GetEchoResponsePB* resp) {
+Status TestEchoService::GetEchoImpl(
+    const GetEchoRequestPB& req, GetEchoResponsePB* resp, rpc::RpcContext& rpc) {
   std::string echo = req.message();
 
   auto status = RecordRequestInTable(echo);
@@ -112,7 +113,7 @@ Status TestEchoService::GetEchoImpl(const GetEchoRequestPB& req, GetEchoResponse
 }
 
 Status TestEchoService::GetEchoCountImpl(
-    const GetEchoCountRequestPB& req, GetEchoCountResponsePB* resp) {
+    const GetEchoCountRequestPB& req, GetEchoCountResponsePB* resp, rpc::RpcContext& rpc) {
   resp->set_count(echo_count_);
   return Status::OK();
 }
diff --git a/src/yb/tserver/tablet_server.cc b/src/yb/tserver/tablet_server.cc
index 122e9c31f8..d7aefcac6d 100644
--- a/src/yb/tserver/tablet_server.cc
+++ b/src/yb/tserver/tablet_server.cc
@@ -239,6 +239,9 @@ DECLARE_bool(enable_pg_cron);
 
 DEFINE_test_flag(bool, enable_pg_client_mock, false, "Enable mocking of PgClient service in tests");
 
+DEFINE_NON_RUNTIME_int32(stateful_svc_default_queue_length, 50,
+    "Default RPC queue length used for stateful services.");
+
 namespace yb::tserver {
 
 namespace {
@@ -654,7 +657,8 @@ Status TabletServer::RegisterServices() {
     LOG(INFO) << "yb::tserver::stateful_service::TestEchoService created at "
               << test_echo_service.get();
     RETURN_NOT_OK(test_echo_service->Init(tablet_manager_.get()));
-    RETURN_NOT_OK(RegisterService(FLAGS_TEST_echo_svc_queue_length, std::move(test_echo_service)));
+    RETURN_NOT_OK(
+        RegisterService(FLAGS_stateful_svc_default_queue_length, std::move(test_echo_service)));
   }
 
   auto connect_to_pg = [this](const std::string& database_name) {
@@ -668,15 +672,18 @@ Status TabletServer::RegisterServices() {
   LOG(INFO) << "yb::tserver::stateful_service::PgAutoAnalyzeService created at "
             << pg_auto_analyze_service.get();
   RETURN_NOT_OK(pg_auto_analyze_service->Init(tablet_manager_.get()));
-  RETURN_NOT_OK(RegisterService(
-      FLAGS_TEST_echo_svc_queue_length, std::move(pg_auto_analyze_service)));
+  RETURN_NOT_OK(
+      RegisterService(FLAGS_stateful_svc_default_queue_length, std::move(pg_auto_analyze_service)));
 
   if (FLAGS_enable_pg_cron) {
-    pg_cron_leader_service_ = std::make_unique<stateful_service::PgCronLeaderService>(
-        std::bind(&TabletServer::SetCronLeaderLease, this, _1), client_future());
+    auto pg_cron_leader_service = std::make_unique<stateful_service::PgCronLeaderService>(
+        std::bind(&TabletServer::SetCronLeaderLease, this, _1), metric_entity(), client_future());
     LOG(INFO) << "yb::tserver::stateful_service::PgCronLeaderService created at "
-              << pg_cron_leader_service_.get();
-    RETURN_NOT_OK(pg_cron_leader_service_->Init(tablet_manager_.get()));
+              << pg_cron_leader_service.get();
+    RETURN_NOT_OK(pg_cron_leader_service->Init(tablet_manager_.get()));
+
+    RETURN_NOT_OK(RegisterService(
+        FLAGS_stateful_svc_default_queue_length, std::move(pg_cron_leader_service)));
   }
 
   return Status::OK();
@@ -714,10 +721,6 @@ void TabletServer::Shutdown() {
 
   bool expected = true;
   if (initted_.compare_exchange_strong(expected, false, std::memory_order_acq_rel)) {
-    if (pg_cron_leader_service_) {
-      pg_cron_leader_service_->Shutdown();
-    }
-
     auto xcluster_consumer = GetXClusterConsumer();
     if (xcluster_consumer) {
       xcluster_consumer->Shutdown();
diff --git a/src/yb/tserver/tablet_server.h b/src/yb/tserver/tablet_server.h
index 927a3b8783..74ae395ec7 100644
--- a/src/yb/tserver/tablet_server.h
+++ b/src/yb/tserver/tablet_server.h
@@ -541,8 +541,6 @@ class TabletServer : public DbServerBase, public TabletServerIf {
   std::atomic<yb::server::RpcAndWebServerBase*> cql_server_{nullptr};
   std::atomic<yb::server::YCQLStatementStatsProvider*> cql_stmt_provider_{nullptr};
 
-  std::unique_ptr<stateful_service::PgCronLeaderService> pg_cron_leader_service_;
-
   // Lock Manager to maintain table/object locking activity in memory.
   std::unique_ptr<tablet::TSLocalLockManager> ts_local_lock_manager_;
 
diff --git a/src/yb/yql/pggate/pg_client.cc b/src/yb/yql/pggate/pg_client.cc
index a4edd97143..a6c6e2f307 100644
--- a/src/yb/yql/pggate/pg_client.cc
+++ b/src/yb/yql/pggate/pg_client.cc
@@ -1274,6 +1274,24 @@ class PgClient::Impl : public BigDataFetcher {
     return resp;
   }
 
+  Status SetCronLastMinute(int64_t last_minute) {
+    tserver::PgCronSetLastMinuteRequestPB req;
+    req.set_last_minute(last_minute);
+    tserver::PgCronSetLastMinuteResponsePB resp;
+
+    RETURN_NOT_OK(proxy_->CronSetLastMinute(req, &resp, PrepareController()));
+    return ResponseStatus(resp);
+  }
+
+  Result<int64_t> GetCronLastMinute() {
+    tserver::PgCronGetLastMinuteRequestPB req;
+    tserver::PgCronGetLastMinuteResponsePB resp;
+
+    RETURN_NOT_OK(proxy_->CronGetLastMinute(req, &resp, PrepareController()));
+    RETURN_NOT_OK(ResponseStatus(resp));
+    return resp.last_minute();
+  }
+
  private:
   std::string LogPrefix() const {
     return Format("Session id $0: ", session_id_);
@@ -1599,6 +1617,12 @@ Result<tserver::PgServersMetricsResponsePB> PgClient::ServersMetrics() {
   return impl_->ServersMetrics();
 }
 
+Status PgClient::SetCronLastMinute(int64_t last_minute) {
+  return impl_->SetCronLastMinute(last_minute);
+}
+
+Result<int64_t> PgClient::GetCronLastMinute() { return impl_->GetCronLastMinute(); }
+
 void PerformExchangeFuture::wait() const {
   if (!value_) {
     value_ = MakePerformResult(data_.get(), data_->CompletePerform());
diff --git a/src/yb/yql/pggate/pg_client.h b/src/yb/yql/pggate/pg_client.h
index 190b33d68c..5a7a4ee395 100644
--- a/src/yb/yql/pggate/pg_client.h
+++ b/src/yb/yql/pggate/pg_client.h
@@ -249,6 +249,9 @@ class PgClient {
 
   Result<tserver::PgServersMetricsResponsePB> ServersMetrics();
 
+  Status SetCronLastMinute(int64_t last_minute);
+  Result<int64_t> GetCronLastMinute();
+
   using ActiveTransactionCallback = LWFunction<Status(
       const tserver::PgGetActiveTransactionListResponsePB_EntryPB&, bool is_last)>;
   Status EnumerateActiveTransactions(
diff --git a/src/yb/yql/pggate/pg_session.cc b/src/yb/yql/pggate/pg_session.cc
index 765f7096af..d0934fe54a 100644
--- a/src/yb/yql/pggate/pg_session.cc
+++ b/src/yb/yql/pggate/pg_session.cc
@@ -1082,4 +1082,10 @@ Result<yb::tserver::PgServersMetricsResponsePB> PgSession::ServersMetrics() {
   return pg_client_.ServersMetrics();
 }
 
+Status PgSession::SetCronLastMinute(int64_t last_minute) {
+  return pg_client_.SetCronLastMinute(last_minute);
+}
+
+Result<int64_t> PgSession::GetCronLastMinute() { return pg_client_.GetCronLastMinute(); }
+
 }  // namespace yb::pggate
diff --git a/src/yb/yql/pggate/pg_session.h b/src/yb/yql/pggate/pg_session.h
index 5cf117932f..c53e310155 100644
--- a/src/yb/yql/pggate/pg_session.h
+++ b/src/yb/yql/pggate/pg_session.h
@@ -285,6 +285,9 @@ class PgSession : public RefCountedThreadSafe<PgSession> {
 
   Result<yb::tserver::PgServersMetricsResponsePB> ServersMetrics();
 
+  Status SetCronLastMinute(int64_t last_minute);
+  Result<int64_t> GetCronLastMinute();
+
  private:
   Result<PgTableDescPtr> DoLoadTable(
       const PgObjectId& table_id, bool fail_on_cache_hit,
diff --git a/src/yb/yql/pggate/pggate.cc b/src/yb/yql/pggate/pggate.cc
index 8f50fd77d2..53a5c8920a 100644
--- a/src/yb/yql/pggate/pggate.cc
+++ b/src/yb/yql/pggate/pggate.cc
@@ -2301,6 +2301,12 @@ void PgApiImpl::ClearSessionState() {
 
 bool PgApiImpl::IsCronLeader() const { return tserver_shared_object_->IsCronLeader(); }
 
+Status PgApiImpl::SetCronLastMinute(int64_t last_minute) {
+  return pg_session_->SetCronLastMinute(last_minute);
+}
+
+Result<int64_t> PgApiImpl::GetCronLastMinute() { return pg_session_->GetCronLastMinute(); }
+
 uint64_t PgApiImpl::GetCurrentReadTimePoint() const {
   return pg_txn_manager_->GetCurrentReadTimePoint();
 }
diff --git a/src/yb/yql/pggate/pggate.h b/src/yb/yql/pggate/pggate.h
index bd31ed292c..6de09dfccc 100644
--- a/src/yb/yql/pggate/pggate.h
+++ b/src/yb/yql/pggate/pggate.h
@@ -799,6 +799,8 @@ class PgApiImpl {
   Result<tserver::PgServersMetricsResponsePB> ServersMetrics();
 
   bool IsCronLeader() const;
+  Status SetCronLastMinute(int64_t last_minute);
+  Result<int64_t> GetCronLastMinute();
 
   [[nodiscard]] uint64_t GetCurrentReadTimePoint() const;
   Status RestoreReadTimePoint(uint64_t read_time_point_handle);
diff --git a/src/yb/yql/pggate/ybc_pggate.cc b/src/yb/yql/pggate/ybc_pggate.cc
index 81591ba5d3..8eebf90579 100644
--- a/src/yb/yql/pggate/ybc_pggate.cc
+++ b/src/yb/yql/pggate/ybc_pggate.cc
@@ -2706,6 +2706,20 @@ YBCStatus YBCServersMetrics(YBCPgServerMetricsInfo** servers_metrics_info, size_
 
 bool YBCIsCronLeader() { return pgapi->IsCronLeader(); }
 
+YBCStatus YBCSetCronLastMinute(int64_t last_minute) {
+  return ToYBCStatus(pgapi->SetCronLastMinute(last_minute));
+}
+
+YBCStatus YBCGetCronLastMinute(int64_t* last_minute) {
+  const auto result = pgapi->GetCronLastMinute();
+  if (!result.ok()) {
+    return ToYBCStatus(result.status());
+  }
+  *last_minute = result.get();
+
+  return YBCStatusOK();
+}
+
 uint64_t YBCPgGetCurrentReadTimePoint() {
   return pgapi->GetCurrentReadTimePoint();
 }
diff --git a/src/yb/yql/pggate/ybc_pggate.h b/src/yb/yql/pggate/ybc_pggate.h
index b9f0cbf8e8..675d5cbd57 100644
--- a/src/yb/yql/pggate/ybc_pggate.h
+++ b/src/yb/yql/pggate/ybc_pggate.h
@@ -123,6 +123,8 @@ YBCStatus YBCFetchFromUrl(const char *url, char **buf);
 
 // Is this node acting as the pg_cron leader?
 bool YBCIsCronLeader();
+YBCStatus YBCSetCronLastMinute(int64_t last_minute);
+YBCStatus YBCGetCronLastMinute(int64_t* last_minute);
 
 //--------------------------------------------------------------------------------------------------
 // YB Bitmap Scan Operations
