diff --git a/src/yb/master/CMakeLists.txt b/src/yb/master/CMakeLists.txt
index 9fbdf44200..425335e522 100644
--- a/src/yb/master/CMakeLists.txt
+++ b/src/yb/master/CMakeLists.txt
@@ -83,6 +83,7 @@ set(MASTER_SRCS
   catalog_manager_bg_tasks.cc
   catalog_manager_ext.cc
   catalog_manager_util.cc
+  cdcsdk_manager.cc
   clone/clone_state_entity.cc
   clone/clone_state_manager.cc
   clone/clone_tasks.cc
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 47322c80dd..5d99297dce 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -100,11 +100,8 @@
 #include "yb/consensus/opid_util.h"
 #include "yb/consensus/quorum_util.h"
 
-#include "yb/docdb/doc_ql_scanspec.h"
-
 #include "yb/dockv/doc_key.h"
 #include "yb/dockv/partition.h"
-#include "yb/dockv/reader_projection.h"
 
 #include "yb/gutil/bind.h"
 #include "yb/gutil/casts.h"
@@ -125,6 +122,7 @@
 #include "yb/master/catalog_manager-internal.h"
 #include "yb/master/catalog_manager_bg_tasks.h"
 #include "yb/master/catalog_manager_util.h"
+#include "yb/master/cdcsdk_manager.h"
 #include "yb/master/clone/clone_state_manager.h"
 #include "yb/master/cluster_balance.h"
 #include "yb/master/encryption_manager.h"
@@ -155,6 +153,7 @@
 #include "yb/master/ts_descriptor.h"
 #include "yb/master/ts_manager.h"
 #include "yb/master/xcluster/xcluster_manager.h"
+
 #include "yb/master/yql_aggregates_vtable.h"
 #include "yb/master/yql_auth_resource_role_permissions_index.h"
 #include "yb/master/yql_auth_role_permissions_vtable.h"
@@ -171,6 +170,7 @@
 #include "yb/master/yql_triggers_vtable.h"
 #include "yb/master/yql_types_vtable.h"
 #include "yb/master/yql_views_vtable.h"
+
 #include "yb/master/ysql/ysql_initdb_major_upgrade_handler.h"
 #include "yb/master/ysql/ysql_manager.h"
 #include "yb/master/ysql_ddl_verification_task.h"
@@ -406,10 +406,6 @@ TAG_FLAG(txn_table_wait_min_ts_count, advanced);
 DEFINE_RUNTIME_bool(enable_ysql_tablespaces_for_placement, true,
     "If set, tablespaces will be used for placement of YSQL tables.");
 
-DEFINE_NON_RUNTIME_int32(ysql_tablespace_info_refresh_secs, 30,
-    "Frequency at which the table to tablespace information will be updated in master "
-    "from pg catalog tables. A value of -1 disables the refresh task.");
-
 // Change the default value of this flag to false once we declare Colocation GA.
 DEFINE_NON_RUNTIME_bool(ysql_legacy_colocated_database_creation, false,
             "Whether to create a legacy colocated database using pre-Colocation GA implementation");
@@ -1029,8 +1025,7 @@ CatalogManager::CatalogManager(Master* master, SysCatalogTable* sys_catalog)
       tasks_tracker_(new TasksTracker(IsUserInitiated::kFalse)),
       jobs_tracker_(new TasksTracker(IsUserInitiated::kTrue)),
       encryption_manager_(new EncryptionManager()),
-      tablespace_manager_(std::make_shared<YsqlTablespaceManager>(nullptr, nullptr)),
-      tablespace_bg_task_running_(false) {
+      tablespace_manager_(std::make_shared<YsqlTablespaceManager>(nullptr, nullptr)) {
   RWCLock::SetConflictingMutex(&mutex_);
   InitMasterFlags();
   CHECK_OK(ThreadPoolBuilder("leader-initialization")
@@ -1049,6 +1044,7 @@ CatalogManager::CatalogManager(Master* master, SysCatalogTable* sys_catalog)
   CHECK_OK(ThreadPoolBuilder("async-tasks").unlimited_threads().Build(&async_task_pool_));
 #endif
   CHECK_OK(sys_catalog_->Start(Bind(&CatalogManager::ElectedAsLeaderCb, Unretained(this))));
+  cdcsdk_manager_ = std::make_unique<CdcsdkManager>(*master_, *this, *sys_catalog_);
   xcluster_manager_ = std::make_unique<XClusterManager>(*master_, *this, *sys_catalog_);
   ysql_manager_ = std::make_unique<YsqlManager>(*master_, *this, *sys_catalog_);
 }
@@ -2227,14 +2223,12 @@ bool CatalogManager::StartShutdown() {
 
   refresh_yql_partitions_task_.StartShutdown();
 
-  refresh_ysql_tablespace_info_task_.StartShutdown();
-
   xrepl_parent_tablet_deletion_task_.StartShutdown();
 
-  refresh_ysql_pg_catalog_versions_task_.StartShutdown();
-
   xcluster_manager_->StartShutdown();
 
+  ysql_manager_->StartShutdown();
+
   if (sys_catalog_) {
     sys_catalog_->StartShutdown();
   }
@@ -2244,10 +2238,10 @@ bool CatalogManager::StartShutdown() {
 
 void CatalogManager::CompleteShutdown() {
   refresh_yql_partitions_task_.CompleteShutdown();
-  refresh_ysql_tablespace_info_task_.CompleteShutdown();
   xrepl_parent_tablet_deletion_task_.CompleteShutdown();
-  refresh_ysql_pg_catalog_versions_task_.CompleteShutdown();
+
   xcluster_manager_->CompleteShutdown();
+  ysql_manager_->CompleteShutdown();
 
   if (background_tasks_) {
     background_tasks_->Shutdown();
@@ -2657,74 +2651,6 @@ Status CatalogManager::CreateTransactionStatusTablesForTablespaces(
   return Status::OK();
 }
 
-void CatalogManager::StartTablespaceBgTaskIfStopped() {
-  if (GetAtomicFlag(&FLAGS_ysql_tablespace_info_refresh_secs) <= 0 ||
-      !GetAtomicFlag(&FLAGS_enable_ysql_tablespaces_for_placement) ||
-      GetAtomicFlag(&FLAGS_create_initial_sys_catalog_snapshot)) {
-    // The tablespace bg task is disabled. Nothing to do.
-    return;
-  }
-
-  const bool is_task_running = tablespace_bg_task_running_.exchange(true);
-  if (is_task_running) {
-    // Task already running, nothing to do.
-    return;
-  }
-
-  ScheduleRefreshTablespaceInfoTask(true /* schedule_now */);
-}
-
-void CatalogManager::ScheduleRefreshTablespaceInfoTask(const bool schedule_now) {
-  int wait_time = 0;
-
-  if (!schedule_now) {
-    wait_time = GetAtomicFlag(&FLAGS_ysql_tablespace_info_refresh_secs);
-    if (wait_time <= 0) {
-      // The tablespace refresh task has been disabled.
-      tablespace_bg_task_running_ = false;
-      return;
-    }
-  }
-
-  refresh_ysql_tablespace_info_task_.Schedule([this](const Status& status) {
-    Status s = background_tasks_thread_pool_->SubmitFunc(
-      std::bind(&CatalogManager::RefreshTablespaceInfoPeriodically, this));
-    if (!s.IsOk()) {
-      // Failed to submit task to the thread pool. Mark that the task is now
-      // no longer running.
-      LOG(WARNING) << "Failed to schedule: RefreshTablespaceInfoPeriodically";
-      tablespace_bg_task_running_ = false;
-    }
-  }, wait_time * 1s);
-}
-
-void CatalogManager::RefreshTablespaceInfoPeriodically() {
-  if (!GetAtomicFlag(&FLAGS_enable_ysql_tablespaces_for_placement)) {
-    tablespace_bg_task_running_ = false;
-    return;
-  }
-
-  LeaderEpoch epoch;
-  {
-    SCOPED_LEADER_SHARED_LOCK(l, this);
-    if (!l.IsInitializedAndIsLeader()) {
-      LOG(INFO) << "No longer the leader, so cancelling tablespace info task";
-      tablespace_bg_task_running_ = false;
-      return;
-    }
-    epoch = l.epoch();
-  }
-
-  // Refresh the tablespace info in memory.
-  Status s = DoRefreshTablespaceInfo(epoch);
-  if (!s.IsOk()) {
-    LOG(WARNING) << "Tablespace refresh task failed with error " << s.ToString();
-  }
-
-  // Schedule the next iteration of the task.
-  ScheduleRefreshTablespaceInfoTask();
-}
-
 Status CatalogManager::DoRefreshTablespaceInfo(const LeaderEpoch& epoch) {
   VLOG(2) << "Running RefreshTablespaceInfoPeriodically task";
 
@@ -5326,32 +5252,6 @@ Status CatalogManager::CreateTestEchoService(const LeaderEpoch& epoch) {
   return Status::OK();
 }
 
-Status CatalogManager::CreatePgAutoAnalyzeService(const LeaderEpoch& epoch) {
-  static bool pg_auto_analyze_service_created = false;
-  if (pg_auto_analyze_service_created || !FLAGS_enable_ysql) {
-    return Status::OK();
-  }
-
-  client::YBSchemaBuilder schema_builder;
-  schema_builder.AddColumn(kPgAutoAnalyzeTableId)->HashPrimaryKey()->Type(DataType::STRING);
-  schema_builder.AddColumn(kPgAutoAnalyzeMutations)->Type(DataType::INT64);
-  schema_builder.AddColumn(kPgAutoAnalyzeLastAnalyzeInfo)->Type(DataType::JSONB);
-  schema_builder.AddColumn(kPgAutoAnalyzeCurrentAnalyzeInfo)->Type(DataType::JSONB);
-
-  client::YBSchema yb_schema;
-  CHECK_OK(schema_builder.Build(&yb_schema));
-
-  auto s = CreateStatefulService(StatefulServiceKind::PG_AUTO_ANALYZE, yb_schema, epoch);
-  // It is possible that the table was already created. If so, there is nothing to do so we just
-  // ignore the "AlreadyPresent" error.
-  if (!s.ok() && !s.IsAlreadyPresent()) {
-    return s;
-  }
-
-  pg_auto_analyze_service_created = true;
-  return Status::OK();
-}
-
 Status CatalogManager::CreatePgCronService(const LeaderEpoch& epoch) {
   if (pg_cron_service_created_) {
     return Status::OK();
@@ -10654,16 +10554,6 @@ Status CatalogManager::UpdateMastersListInMemoryAndDisk() {
 
 Status CatalogManager::EnableBgTasks() {
   LockGuard lock(mutex_);
-  // Initialize refresh_ysql_tablespace_info_task_. This will be used to
-  // manage the background task that refreshes tablespace info. This task
-  // will be started by the CatalogManagerBgTasks below.
-  refresh_ysql_tablespace_info_task_.Bind(&master_->messenger()->scheduler());
-
-  // Initialize refresh_ysql_pg_catalog_versions_task_. This will be used to
-  // manage the background task that refreshes pg catalog versions. This task
-  // will be started by the CatalogManagerBgTasks below.
-  refresh_ysql_pg_catalog_versions_task_.Bind(&master_->messenger()->scheduler());
-
   background_tasks_.reset(new CatalogManagerBgTasks(master_));
   RETURN_NOT_OK_PREPEND(background_tasks_->Init(),
                         "Failed to initialize catalog manager background tasks");
@@ -13481,37 +13371,6 @@ void CatalogManager::SchedulePostTabletCreationTasksForPendingTables(const Leade
   }
 }
 
-void CatalogManager::StartPgCatalogVersionsBgTaskIfStopped() {
-  // In per-database catalog version mode, if heartbeat PG catalog versions
-  // cache is enabled, start a background task to periodically read the
-  // pg_yb_catalog_version table and cache the result.
-  if (FLAGS_ysql_enable_db_catalog_version_mode &&
-      FLAGS_enable_heartbeat_pg_catalog_versions_cache) {
-    const bool is_task_running = pg_catalog_versions_bg_task_running_.exchange(true);
-    if (is_task_running) {
-      // Task already running, nothing to do.
-      return;
-    }
-    ScheduleRefreshPgCatalogVersionsTask(true /* schedule_now */);
-  }
-}
-
-void CatalogManager::ScheduleRefreshPgCatalogVersionsTask(bool schedule_now) {
-  // Schedule the next refresh catalog versions task. Do it twice every
-  // tserver to master heartbeat so we have reasonably recent catalog versions
-  // used for heartbeat response.
-  auto wait_time = schedule_now ? 0 : (FLAGS_heartbeat_interval_ms / 2);
-  refresh_ysql_pg_catalog_versions_task_.Schedule([this](const Status& status) {
-    Status s = background_tasks_thread_pool_->SubmitFunc(
-        [this]() { RefreshPgCatalogVersionInfoPeriodically(); });
-    if (!s.ok()) {
-      LOG(WARNING) << "Failed to schedule: " << __func__;
-      pg_catalog_versions_bg_task_running_ = false;
-      ResetCachedCatalogVersions();
-    }
-  }, wait_time * 1ms);
-}
-
 void CatalogManager::ResetCachedCatalogVersions() {
   LockGuard lock(heartbeat_pg_catalog_versions_cache_mutex_);
   if (heartbeat_pg_catalog_versions_cache_) {
@@ -13522,23 +13381,7 @@ void CatalogManager::ResetCachedCatalogVersions() {
   heartbeat_pg_inval_messages_cache_ = DbOidVersionToMessageListMap();
 }
 
-void CatalogManager::RefreshPgCatalogVersionInfoPeriodically() {
-  DCHECK(FLAGS_ysql_enable_db_catalog_version_mode);
-  DCHECK(FLAGS_enable_heartbeat_pg_catalog_versions_cache);
-  DCHECK(pg_catalog_versions_bg_task_running_);
-
-  {
-    SCOPED_LEADER_SHARED_LOCK(l, this);
-    if (!l.IsInitializedAndIsLeader()) {
-      VLOG(2) << "No longer the leader, skipping catalog versions task";
-      pg_catalog_versions_bg_task_running_ = false;
-      ResetCachedCatalogVersions();
-      return;
-    }
-  }
-
-  // Refresh the catalog versions in memory.
-  VLOG(2) << "Running " << __func__ << " task";
+void CatalogManager::RefreshPgCatalogVersionInfo() {
   DbOidToCatalogVersionMap versions;
   Status s = GetYsqlAllDBCatalogVersionsImpl(&versions);
   bool changed = false;
@@ -13588,7 +13431,6 @@ void CatalogManager::RefreshPgCatalogVersionInfoPeriodically() {
       }
     }
   }
-  ScheduleRefreshPgCatalogVersionsTask();
 }
 
 Result<TabletDeleteRetainerInfo> CatalogManager::GetDeleteRetainerInfoForTabletDrop(
@@ -14078,4 +13920,8 @@ Status CatalogManager::GetTabletsMetadata(const GetTabletsMetadataRequestPB* req
   return Status::OK();
 }
 
+Status CatalogManager::SubmitBackgroundTask(const std::function<void()>& func) {
+  return background_tasks_thread_pool_->SubmitFunc(func);
+}
+
 } // namespace yb::master
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index 306752e61c..e8ba310a7d 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -350,8 +350,6 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
 
   Status CreateTestEchoService(const LeaderEpoch& epoch);
 
-  Status CreatePgAutoAnalyzeService(const LeaderEpoch& epoch);
-
   Status CreatePgCronService(const LeaderEpoch& epoch) EXCLUDES(mutex_);
 
   // Get the information about an in-progress create operation.
@@ -1751,6 +1749,21 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
 
   rpc::Scheduler& Scheduler() override;
 
+  // Submit a task to run on the background thread pool.
+  Status SubmitBackgroundTask(const std::function<void()>& func);
+
+
+  // Below functions are temporarily made public until they can be moved into YsqlManager.
+
+  // Helper function to refresh the tablespace info.
+  Status DoRefreshTablespaceInfo(const LeaderEpoch& epoch);
+
+  void ResetCachedCatalogVersions()
+      EXCLUDES(heartbeat_pg_catalog_versions_cache_mutex_);
+
+  // Refresh the in-memory map for YSQL pg_yb_catalog_version table.
+  void RefreshPgCatalogVersionInfo() EXCLUDES(heartbeat_pg_catalog_versions_cache_mutex_);
+
  protected:
   // TODO Get rid of these friend classes and introduce formal interface.
   friend class TableLoader;
@@ -2145,8 +2158,6 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
       const TablespaceIdToReplicationInfoMap& tablespace_info,
       const TableToTablespaceIdMap& table_to_tablespace_map, const LeaderEpoch& epoch);
 
-  void StartTablespaceBgTaskIfStopped();
-
   // Report metrics.
   void ReportMetrics();
 
@@ -2488,6 +2499,8 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
   mutable MutexType backfill_mutex_;
   std::unordered_set<TableId> pending_backfill_tables_ GUARDED_BY(backfill_mutex_);
 
+  std::unique_ptr<CdcsdkManager> cdcsdk_manager_;
+
   std::unique_ptr<XClusterManager> xcluster_manager_;
 
   std::unique_ptr<YsqlManager> ysql_manager_;
@@ -2583,17 +2596,6 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
   Result<std::shared_ptr<TableToTablespaceIdMap>> GetYsqlTableToTablespaceMap(
       const TablespaceIdToReplicationInfoMap& tablespace_info) EXCLUDES(mutex_);
 
-  // Background task that refreshes the in-memory state for YSQL tables with their associated
-  // tablespace info.
-  // Note: This function should only ever be called by StartTablespaceBgTaskIfStopped().
-  void RefreshTablespaceInfoPeriodically();
-
-  // Helper function to schedule the next iteration of the tablespace info task.
-  void ScheduleRefreshTablespaceInfoTask(const bool schedule_now = false);
-
-  // Helper function to refresh the tablespace info.
-  Status DoRefreshTablespaceInfo(const LeaderEpoch& epoch);
-
   size_t GetNumLiveTServersForPlacement(const PlacementId& placement_id);
 
   TSDescriptorVector GetAllLiveNotBlacklistedTServers() const override;
@@ -3008,15 +3010,6 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
   Status BumpVersionAndStoreClusterConfig(
       ClusterConfigInfo* cluster_config, ClusterConfigInfo::WriteLock* l);
 
-  // Background task that refreshes the in-memory map for YSQL pg_yb_catalog_version table.
-  void RefreshPgCatalogVersionInfoPeriodically()
-      EXCLUDES(heartbeat_pg_catalog_versions_cache_mutex_);
-  // Helper function to schedule the next iteration of the pg catalog versions task.
-  void ScheduleRefreshPgCatalogVersionsTask(bool schedule_now = false);
-
-  void StartPgCatalogVersionsBgTaskIfStopped();
-  void ResetCachedCatalogVersions()
-      EXCLUDES(heartbeat_pg_catalog_versions_cache_mutex_);
   Status GetYsqlAllDBCatalogVersionsImpl(DbOidToCatalogVersionMap* versions);
   Result<DbOidVersionToMessageListMap> GetYsqlCatalogInvalationMessagesImpl();
 
@@ -3103,11 +3096,6 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
   // shared_ptr and read from it.
   std::shared_ptr<YsqlTablespaceManager> tablespace_manager_ GUARDED_BY(tablespace_mutex_);
 
-  // Whether the periodic job to update tablespace info is running.
-  std::atomic<bool> tablespace_bg_task_running_;
-
-  rpc::ScheduledTaskTracker refresh_ysql_tablespace_info_task_;
-
   struct YsqlDdlTransactionState {
     // Indicates whether the transaction is committed or aborted or unknown.
     TxnState txn_state;
@@ -3226,9 +3214,6 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
   // True when the cluster is a producer of a valid replication stream.
   std::atomic<bool> cdc_enabled_{false};
 
-  std::atomic<bool> pg_catalog_versions_bg_task_running_ = {false};
-  rpc::ScheduledTaskTracker refresh_ysql_pg_catalog_versions_task_;
-
   // For per-database catalog version mode upgrade support: when the gflag
   // --ysql_enable_db_catalog_version_mode is true, whether the table
   // pg_yb_catalog_version has been upgraded to have one row per database.
diff --git a/src/yb/master/catalog_manager_bg_tasks.cc b/src/yb/master/catalog_manager_bg_tasks.cc
index 8689e1063b..712dbe8033 100644
--- a/src/yb/master/catalog_manager_bg_tasks.cc
+++ b/src/yb/master/catalog_manager_bg_tasks.cc
@@ -33,6 +33,7 @@
 
 #include <memory>
 
+#include "yb/master/cdcsdk_manager.h"
 #include "yb/master/clone/clone_state_manager.h"
 #include "yb/master/cluster_balance.h"
 #include "yb/master/master.h"
@@ -79,22 +80,11 @@ DEFINE_test_flag(bool, pause_catalog_manager_bg_loop_start, false,
 DEFINE_test_flag(bool, pause_catalog_manager_bg_loop_end, false,
                  "Pause the bg tasks thread at the end of the loop.");
 
-DEFINE_test_flag(bool, cdcsdk_skip_processing_dynamic_table_addition, false,
-                "Skip finding unprocessed tables for cdcsdk streams");
-
-DEFINE_test_flag(bool, cdcsdk_skip_processing_unqualified_tables, false,
-                 "Skip the bg task that finds and removes unprocessed unqualified tables from "
-                 "cdcsdk streams.");
-
 DECLARE_bool(enable_ysql);
 DECLARE_bool(TEST_echo_service_enabled);
-DECLARE_bool(cdcsdk_enable_dynamic_table_addition_with_table_cleanup);
-DECLARE_bool(ysql_enable_auto_analyze_infra);
 
 namespace yb::master {
 
-using TableStreamIdsMap = std::unordered_map<TableId, std::list<CDCStreamInfoPtr>>;
-
 CatalogManagerBgTasks::CatalogManagerBgTasks(Master* master)
     : closing_(false),
       pending_updates_(false),
@@ -202,17 +192,7 @@ void CatalogManagerBgTasks::RunOnceAsLeader(const LeaderEpoch& epoch) {
         catalog_manager_->CreateTestEchoService(epoch), "Failed to create Test Echo service");
   }
 
-  // Avoid creating system tables if we are in the middle of upgrade.
-  if (!catalog_manager_->ysql_manager_->IsMajorUpgradeInProgress()) {
-    WARN_NOT_OK(
-        catalog_manager_->ysql_manager_->CreateYbAdvisoryLocksTableIfNeeded(epoch),
-        "Failed to create YB advisory locks table");
-
-    if (FLAGS_ysql_enable_auto_analyze_infra)
-      WARN_NOT_OK(
-          catalog_manager_->CreatePgAutoAnalyzeService(epoch),
-          "Failed to create Auto Analyze service");
-  }
+  catalog_manager_->ysql_manager_->RunBgTasks(epoch);
 
   // Report metrics.
   catalog_manager_->ReportMetrics();
@@ -288,75 +268,6 @@ void CatalogManagerBgTasks::RunOnceAsLeader(const LeaderEpoch& epoch) {
     catalog_manager_->CleanUpDeletedTables(epoch);
   }
 
-  {
-    if (!FLAGS_TEST_cdcsdk_skip_processing_dynamic_table_addition) {
-      // Find if there have been any new tables added to any namespace with an active cdcsdk
-      // stream.
-      TableStreamIdsMap table_unprocessed_streams_map;
-      // In case of master leader restart of leadership changes, we will scan all streams for
-      // unprocessed tables, but from the second iteration onwards we will only consider the
-      // 'cdcsdk_unprocessed_tables' field of CDCStreamInfo object stored in the cdc_state_map.
-      Status s = catalog_manager_->FindCDCSDKStreamsForAddedTables(&table_unprocessed_streams_map);
-
-      if (s.ok() && !table_unprocessed_streams_map.empty()) {
-        s = catalog_manager_->ProcessNewTablesForCDCSDKStreams(
-            table_unprocessed_streams_map, epoch);
-      }
-      if (!s.ok()) {
-        YB_LOG_EVERY_N(WARNING, 10)
-            << "Encountered failure while trying to add unprocessed tables to cdc_state table: "
-            << s.ToString();
-      }
-    } else {
-      LOG(INFO) << "Skipping processing of dynamic table addition due to "
-                   "cdcsdk_skip_processing_dynamic_table_addition being true";
-    }
-  }
-
-  {
-    if (FLAGS_cdcsdk_enable_dynamic_table_addition_with_table_cleanup) {
-      // Find if there are any non eligible tables (indexes, mat views) present in cdcsdk
-      // stream that are not associated with a replication slot.
-      TableStreamIdsMap non_user_tables_to_streams_map;
-      // In case of master leader restart or leadership changes, we would have scanned all
-      // streams (without replication slot) in ACTIVE/DELETING METADATA state for non eligible
-      // tables and marked such tables for removal in
-      // namespace_to_cdcsdk_non_eligible_table_map_.
-      Status s =
-          catalog_manager_->FindCDCSDKStreamsForNonEligibleTables(&non_user_tables_to_streams_map);
-
-      if (s.ok() && !non_user_tables_to_streams_map.empty()) {
-        s = catalog_manager_->ProcessTablesToBeRemovedFromCDCSDKStreams(
-            non_user_tables_to_streams_map, /* non_eligible_table_cleanup */ true, epoch);
-      }
-      if (!s.ok()) {
-        YB_LOG_EVERY_N(WARNING, 10) << "Encountered failure while trying to remove non eligible "
-                                       "tables from cdc_state table: "
-                                    << s.ToString();
-      }
-    }
-  }
-
-  {
-    if (FLAGS_cdcsdk_enable_dynamic_table_addition_with_table_cleanup &&
-        !FLAGS_TEST_cdcsdk_skip_processing_unqualified_tables) {
-      TableStreamIdsMap tables_to_be_removed_streams_map;
-      Status s = catalog_manager_->FindCDCSDKStreamsForUnprocessedUnqualifiedTables(
-          &tables_to_be_removed_streams_map);
-
-      if (s.ok() && !tables_to_be_removed_streams_map.empty()) {
-        s = catalog_manager_->ProcessTablesToBeRemovedFromCDCSDKStreams(
-            tables_to_be_removed_streams_map, /* non_eligible_table_cleanup */ false, epoch);
-      }
-
-      if (!s.ok()) {
-        YB_LOG_EVERY_N(WARNING, 10) << "Encountered failure while trying to remove unqualified "
-                                       "tables from stream metadata & updating cdc_state table: "
-                                    << s.ToString();
-      }
-    }
-  }
-
   // Ensure the master sys catalog tablet follows the cluster's affinity specification.
   if (FLAGS_sys_catalog_respect_affinity_task) {
     Status s = catalog_manager_->SysCatalogRespectLeaderAffinity();
@@ -365,22 +276,19 @@ void CatalogManagerBgTasks::RunOnceAsLeader(const LeaderEpoch& epoch) {
     }
   }
 
-  if (FLAGS_enable_ysql) {
-    catalog_manager_->StartTablespaceBgTaskIfStopped();
-    catalog_manager_->StartPgCatalogVersionsBgTaskIfStopped();
-  }
+  // Set the universe_uuid field in the cluster config if not already set.
+  WARN_NOT_OK(
+      catalog_manager_->SetUniverseUuidIfNeeded(epoch), "Failed SetUniverseUuidIfNeeded Task");
 
   // Run background tasks related to XCluster & CDC Schema.
   catalog_manager_->RunXReplBgTasks(epoch);
 
+  catalog_manager_->cdcsdk_manager_->RunBgTasks(epoch);
+
   catalog_manager_->GetXClusterManager()->RunBgTasks(epoch);
 
   // Abort inactive YSQL BackendsCatalogVersionJob jobs.
   master_->ysql_backends_manager()->AbortInactiveJobs();
-
-  // Set the universe_uuid field in the cluster config if not already set.
-  WARN_NOT_OK(
-      catalog_manager_->SetUniverseUuidIfNeeded(epoch), "Failed SetUniverseUuidIfNeeded Task");
 }
 
 void CatalogManagerBgTasks::Run() {
diff --git a/src/yb/master/cdcsdk_manager.cc b/src/yb/master/cdcsdk_manager.cc
new file mode 100644
index 0000000000..392036ecf2
--- /dev/null
+++ b/src/yb/master/cdcsdk_manager.cc
@@ -0,0 +1,106 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/master/cdcsdk_manager.h"
+
+#include <list>
+
+#include "yb/master/catalog_entity_info.h"
+#include "yb/master/catalog_manager.h"
+
+#include "yb/util/flags/flag_tags.h"
+
+DEFINE_test_flag(bool, cdcsdk_skip_processing_dynamic_table_addition, false,
+    "Skip finding unprocessed tables for cdcsdk streams");
+
+DEFINE_test_flag(bool, cdcsdk_skip_processing_unqualified_tables, false,
+    "Skip the bg task that finds and removes unprocessed unqualified tables from "
+    "cdcsdk streams.");
+
+DECLARE_bool(cdcsdk_enable_dynamic_table_addition_with_table_cleanup);
+
+namespace yb::master {
+
+using TableStreamIdsMap = std::unordered_map<TableId, std::list<CDCStreamInfoPtr>>;
+
+CdcsdkManager::CdcsdkManager(
+    Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog)
+    : master_(master), catalog_manager_(catalog_manager), sys_catalog_(sys_catalog) {}
+
+CdcsdkManager::~CdcsdkManager() = default;
+
+void CdcsdkManager::RunBgTasks(const LeaderEpoch& epoch) {
+  if (!FLAGS_TEST_cdcsdk_skip_processing_dynamic_table_addition) {
+    // Find if there have been any new tables added to any namespace with an active cdcsdk
+    // stream.
+    TableStreamIdsMap table_unprocessed_streams_map;
+    // In case of master leader restart of leadership changes, we will scan all streams for
+    // unprocessed tables, but from the second iteration onwards we will only consider the
+    // 'cdcsdk_unprocessed_tables' field of CDCStreamInfo object stored in the cdc_state_map.
+    Status s = catalog_manager_.FindCDCSDKStreamsForAddedTables(&table_unprocessed_streams_map);
+
+    if (s.ok() && !table_unprocessed_streams_map.empty()) {
+      s = catalog_manager_.ProcessNewTablesForCDCSDKStreams(table_unprocessed_streams_map, epoch);
+    }
+    if (!s.ok()) {
+      YB_LOG_EVERY_N(WARNING, 10)
+          << "Encountered failure while trying to add unprocessed tables to cdc_state table: "
+          << s.ToString();
+    }
+  } else {
+    LOG(INFO) << "Skipping processing of dynamic table addition due to "
+                 "cdcsdk_skip_processing_dynamic_table_addition being true";
+  }
+
+  if (FLAGS_cdcsdk_enable_dynamic_table_addition_with_table_cleanup) {
+    // Find if there are any non eligible tables (indexes, mat views) present in cdcsdk
+    // stream that are not associated with a replication slot.
+    TableStreamIdsMap non_user_tables_to_streams_map;
+    // In case of master leader restart or leadership changes, we would have scanned all
+    // streams (without replication slot) in ACTIVE/DELETING METADATA state for non eligible
+    // tables and marked such tables for removal in
+    // namespace_to_cdcsdk_non_eligible_table_map_.
+    Status s =
+        catalog_manager_.FindCDCSDKStreamsForNonEligibleTables(&non_user_tables_to_streams_map);
+
+    if (s.ok() && !non_user_tables_to_streams_map.empty()) {
+      s = catalog_manager_.ProcessTablesToBeRemovedFromCDCSDKStreams(
+          non_user_tables_to_streams_map, /* non_eligible_table_cleanup */ true, epoch);
+    }
+    if (!s.ok()) {
+      YB_LOG_EVERY_N(WARNING, 10) << "Encountered failure while trying to remove non eligible "
+                                     "tables from cdc_state table: "
+                                  << s.ToString();
+    }
+  }
+
+  if (FLAGS_cdcsdk_enable_dynamic_table_addition_with_table_cleanup &&
+      !FLAGS_TEST_cdcsdk_skip_processing_unqualified_tables) {
+    TableStreamIdsMap tables_to_be_removed_streams_map;
+    Status s = catalog_manager_.FindCDCSDKStreamsForUnprocessedUnqualifiedTables(
+        &tables_to_be_removed_streams_map);
+
+    if (s.ok() && !tables_to_be_removed_streams_map.empty()) {
+      s = catalog_manager_.ProcessTablesToBeRemovedFromCDCSDKStreams(
+          tables_to_be_removed_streams_map, /* non_eligible_table_cleanup */ false, epoch);
+    }
+
+    if (!s.ok()) {
+      YB_LOG_EVERY_N(WARNING, 10) << "Encountered failure while trying to remove unqualified "
+                                     "tables from stream metadata & updating cdc_state table: "
+                                  << s.ToString();
+    }
+  }
+}
+
+}  // namespace yb::master
diff --git a/src/yb/master/cdcsdk_manager.h b/src/yb/master/cdcsdk_manager.h
new file mode 100644
index 0000000000..041f72ae49
--- /dev/null
+++ b/src/yb/master/cdcsdk_manager.h
@@ -0,0 +1,36 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include "yb/master/cdcsdk_manager_if.h"
+#include "yb/master/master_fwd.h"
+
+namespace yb::master {
+
+class CdcsdkManager : public CdcsdkManagerIf {
+ public:
+  explicit CdcsdkManager(
+      Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog);
+
+  ~CdcsdkManager() override;
+
+  void RunBgTasks(const LeaderEpoch& epoch) override;
+
+ private:
+  Master& master_;
+  CatalogManager& catalog_manager_;
+  SysCatalogTable& sys_catalog_;
+};
+
+}  // namespace yb::master
diff --git a/src/yb/master/cdcsdk_manager_if.h b/src/yb/master/cdcsdk_manager_if.h
new file mode 100644
index 0000000000..6f8f2157e2
--- /dev/null
+++ b/src/yb/master/cdcsdk_manager_if.h
@@ -0,0 +1,28 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+namespace yb::master {
+
+struct LeaderEpoch;
+
+class CdcsdkManagerIf {
+ public:
+  virtual void RunBgTasks(const LeaderEpoch& epoch) = 0;
+
+ protected:
+  virtual ~CdcsdkManagerIf() = default;
+};
+
+} // namespace yb::master
diff --git a/src/yb/master/master_fwd.h b/src/yb/master/master_fwd.h
index b02319e79c..d9871bece6 100644
--- a/src/yb/master/master_fwd.h
+++ b/src/yb/master/master_fwd.h
@@ -40,8 +40,8 @@ struct HostPortHash;
 namespace master {
 
 class TSDescriptor;
-typedef std::shared_ptr<TSDescriptor> TSDescriptorPtr;
-typedef std::vector<TSDescriptorPtr> TSDescriptorVector;
+using TSDescriptorPtr = std::shared_ptr<TSDescriptor>;
+using TSDescriptorVector = std::vector<TSDescriptorPtr>;
 
 class EncryptionManager;
 
@@ -52,6 +52,8 @@ class AsyncTryStepDown;
 class CatalogManager;
 class CatalogManagerIf;
 class CatalogManagerBgTasks;
+class CdcsdkManager;
+class CdcsdkManagerIf;
 class CloneStateManager;
 class XClusterRpcTasks;
 class ClusterConfigInfo;
diff --git a/src/yb/master/ysql/ysql_manager.cc b/src/yb/master/ysql/ysql_manager.cc
index 6d36b719c9..52f4fad3e3 100644
--- a/src/yb/master/ysql/ysql_manager.cc
+++ b/src/yb/master/ysql/ysql_manager.cc
@@ -16,14 +16,18 @@
 #include "yb/client/schema.h"
 #include "yb/client/yb_table_name.h"
 
+#include "yb/common/common_flags.h"
 #include "yb/common/schema_pbutil.h"
 
-#include "yb/master/catalog_manager.h"
 #include "yb/master/catalog_manager-internal.h"
+#include "yb/master/catalog_manager.h"
+#include "yb/master/master.h"
 #include "yb/master/master_defaults.h"
 #include "yb/master/sys_catalog.h"
 #include "yb/master/ysql/ysql_initdb_major_upgrade_handler.h"
 
+#include "yb/rpc/messenger.h"
+
 #include "yb/tserver/ysql_advisory_lock_table.h"
 
 #include "yb/util/flag_validators.h"
@@ -37,18 +41,41 @@ DEFINE_RUNTIME_bool(master_auto_run_initdb, false,
 DEFINE_NON_RUNTIME_uint32(num_advisory_locks_tablets, 1, "Number of advisory lock tablets");
 DEFINE_validator(num_advisory_locks_tablets, FLAG_GT_VALUE_VALIDATOR(0));
 
+DEFINE_NON_RUNTIME_int32(ysql_tablespace_info_refresh_secs, 30,
+    "Frequency at which the table to tablespace information will be updated in master "
+    "from pg catalog tables. A value of -1 disables the refresh task.");
+
+DECLARE_bool(enable_heartbeat_pg_catalog_versions_cache);
+DECLARE_bool(enable_ysql_tablespaces_for_placement);
+DECLARE_bool(ysql_enable_auto_analyze_infra);
+
+DECLARE_int32(heartbeat_interval_ms);
+
 namespace yb::master {
 
+using namespace std::literals;
+
 YsqlManager::YsqlManager(
     Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog)
     : master_(master),
       catalog_manager_(catalog_manager),
       sys_catalog_(sys_catalog),
-      ysql_catalog_config_(sys_catalog) {
+      ysql_catalog_config_(sys_catalog),
+      tablespace_bg_task_running_(false) {
   ysql_initdb_and_major_upgrade_helper_ = std::make_unique<YsqlInitDBAndMajorUpgradeHandler>(
       master, ysql_catalog_config_, catalog_manager, sys_catalog, *catalog_manager.AsyncTaskPool());
 }
 
+void YsqlManager::StartShutdown() {
+  refresh_ysql_pg_catalog_versions_task_.StartShutdown();
+  refresh_ysql_tablespace_info_task_.StartShutdown();
+}
+
+void YsqlManager::CompleteShutdown() {
+  refresh_ysql_pg_catalog_versions_task_.CompleteShutdown();
+  refresh_ysql_tablespace_info_task_.CompleteShutdown();
+}
+
 void YsqlManager::Clear() { ysql_catalog_config_.Reset(); }
 
 Status YsqlManager::PrepareDefaultSysConfig(const LeaderEpoch& epoch) {
@@ -302,4 +329,174 @@ Result<std::string> YsqlManager::GetPgSchemaName(
   return sys_catalog_.ReadPgNamespaceNspname(oids.database_oid, relnamespace_oid, read_time);
 }
 
+void YsqlManager::RunBgTasks(const LeaderEpoch& epoch) {
+  if (!FLAGS_enable_ysql) {
+    return;
+  }
+
+  // Avoid creating system tables if we are in the middle of upgrade.
+  if (!IsMajorUpgradeInProgress()) {
+    WARN_NOT_OK(
+        CreateYbAdvisoryLocksTableIfNeeded(epoch), "Failed to create YB advisory locks table");
+
+    if (FLAGS_ysql_enable_auto_analyze_infra)
+      WARN_NOT_OK(CreatePgAutoAnalyzeService(epoch), "Failed to create Auto Analyze service");
+  }
+
+  StartTablespaceBgTaskIfStopped();
+  StartPgCatalogVersionsBgTaskIfStopped();
+}
+
+Status YsqlManager::CreatePgAutoAnalyzeService(const LeaderEpoch& epoch) {
+  if (pg_auto_analyze_service_created_ || !FLAGS_enable_ysql) {
+    return Status::OK();
+  }
+
+  client::YBSchemaBuilder schema_builder;
+  schema_builder.AddColumn(kPgAutoAnalyzeTableId)->HashPrimaryKey()->Type(DataType::STRING);
+  schema_builder.AddColumn(kPgAutoAnalyzeMutations)->Type(DataType::INT64);
+  schema_builder.AddColumn(kPgAutoAnalyzeLastAnalyzeInfo)->Type(DataType::JSONB);
+  schema_builder.AddColumn(kPgAutoAnalyzeCurrentAnalyzeInfo)->Type(DataType::JSONB);
+
+  client::YBSchema yb_schema;
+  CHECK_OK(schema_builder.Build(&yb_schema));
+
+  auto s = catalog_manager_.CreateStatefulService(
+      StatefulServiceKind::PG_AUTO_ANALYZE, yb_schema, epoch);
+  // It is possible that the table was already created. If so, there is nothing to do so we just
+  // ignore the "AlreadyPresent" error.
+  if (!s.ok() && !s.IsAlreadyPresent()) {
+    return s;
+  }
+
+  pg_auto_analyze_service_created_ = true;
+  return Status::OK();
+}
+
+void YsqlManager::StartTablespaceBgTaskIfStopped() {
+  if (FLAGS_ysql_tablespace_info_refresh_secs <= 0 ||
+      !FLAGS_enable_ysql_tablespaces_for_placement || FLAGS_create_initial_sys_catalog_snapshot) {
+    // The tablespace bg task is disabled. Nothing to do.
+    return;
+  }
+
+  const bool is_task_running = tablespace_bg_task_running_.exchange(true);
+  if (is_task_running) {
+    // Task already running, nothing to do.
+    return;
+  }
+
+  ScheduleRefreshTablespaceInfoTask(true /* schedule_now */);
+}
+
+void YsqlManager::ScheduleRefreshTablespaceInfoTask(const bool schedule_now) {
+  int wait_time = 0;
+
+  if (!schedule_now) {
+    wait_time = FLAGS_ysql_tablespace_info_refresh_secs;
+    if (wait_time <= 0) {
+      // The tablespace refresh task has been disabled.
+      tablespace_bg_task_running_ = false;
+      return;
+    }
+  }
+
+  refresh_ysql_tablespace_info_task_.Bind(&master_.messenger()->scheduler());
+  refresh_ysql_tablespace_info_task_.Schedule(
+      [this](const Status& status) {
+        Status s =
+            catalog_manager_.SubmitBackgroundTask([this] { RefreshTablespaceInfoPeriodically(); });
+        if (!s.IsOk()) {
+          // Failed to submit task to the thread pool. Mark that the task is now
+          // no longer running.
+          LOG(WARNING) << "Failed to schedule: RefreshTablespaceInfoPeriodically";
+          tablespace_bg_task_running_ = false;
+        }
+      },
+      wait_time * 1s);
+}
+
+void YsqlManager::RefreshTablespaceInfoPeriodically() {
+  if (!FLAGS_enable_ysql_tablespaces_for_placement) {
+    tablespace_bg_task_running_ = false;
+    return;
+  }
+
+  LeaderEpoch epoch;
+  {
+    SCOPED_LEADER_SHARED_LOCK(l, &catalog_manager_);
+    if (!l.IsInitializedAndIsLeader()) {
+      LOG(INFO) << "No longer the leader, so cancelling tablespace info task";
+      tablespace_bg_task_running_ = false;
+      return;
+    }
+    epoch = l.epoch();
+  }
+
+  // Refresh the tablespace info in memory.
+  Status s = catalog_manager_.DoRefreshTablespaceInfo(epoch);
+  if (!s.IsOk()) {
+    LOG(WARNING) << "Tablespace refresh task failed with error " << s.ToString();
+  }
+
+  // Schedule the next iteration of the task.
+  ScheduleRefreshTablespaceInfoTask();
+}
+
+void YsqlManager::StartPgCatalogVersionsBgTaskIfStopped() {
+  // In per-database catalog version mode, if heartbeat PG catalog versions
+  // cache is enabled, start a background task to periodically read the
+  // pg_yb_catalog_version table and cache the result.
+  if (FLAGS_ysql_enable_db_catalog_version_mode &&
+      FLAGS_enable_heartbeat_pg_catalog_versions_cache) {
+    const bool is_task_running = pg_catalog_versions_bg_task_running_.exchange(true);
+    if (is_task_running) {
+      // Task already running, nothing to do.
+      return;
+    }
+    ScheduleRefreshPgCatalogVersionsTask(true /* schedule_now */);
+  }
+}
+
+void YsqlManager::ScheduleRefreshPgCatalogVersionsTask(bool schedule_now) {
+  // Schedule the next refresh catalog versions task. Do it twice every
+  // tserver to master heartbeat so we have reasonably recent catalog versions
+  // used for heartbeat response.
+  auto wait_time = schedule_now ? 0 : (FLAGS_heartbeat_interval_ms / 2);
+  refresh_ysql_pg_catalog_versions_task_.Bind(&master_.messenger()->scheduler());
+  refresh_ysql_pg_catalog_versions_task_.Schedule(
+      [this](const Status& status) {
+        Status s = catalog_manager_.SubmitBackgroundTask(
+            [this] { RefreshPgCatalogVersionInfoPeriodically(); });
+        if (!s.ok()) {
+          LOG(WARNING) << "Failed to schedule: RefreshPgCatalogVersionInfoPeriodically";
+          pg_catalog_versions_bg_task_running_ = false;
+          catalog_manager_.ResetCachedCatalogVersions();
+        }
+      },
+      wait_time * 1ms);
+}
+
+void YsqlManager::RefreshPgCatalogVersionInfoPeriodically() {
+  DCHECK(FLAGS_ysql_enable_db_catalog_version_mode);
+  DCHECK(FLAGS_enable_heartbeat_pg_catalog_versions_cache);
+  DCHECK(pg_catalog_versions_bg_task_running_);
+
+  {
+    SCOPED_LEADER_SHARED_LOCK(l, &catalog_manager_);
+    if (!l.IsInitializedAndIsLeader()) {
+      VLOG(2) << "No longer the leader, skipping catalog versions task";
+      pg_catalog_versions_bg_task_running_ = false;
+      catalog_manager_.ResetCachedCatalogVersions();
+      return;
+    }
+  }
+
+  // Refresh the catalog versions in memory.
+  VLOG(2) << "Running " << __func__ << " task";
+  catalog_manager_.RefreshPgCatalogVersionInfo();
+
+  ScheduleRefreshPgCatalogVersionsTask();
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/ysql/ysql_manager.h b/src/yb/master/ysql/ysql_manager.h
index c390fc32be..716d677c09 100644
--- a/src/yb/master/ysql/ysql_manager.h
+++ b/src/yb/master/ysql/ysql_manager.h
@@ -15,10 +15,11 @@
 
 #include "yb/common/read_hybrid_time.h"
 
-#include "yb/master/ysql/ysql_manager_if.h"
+#include "yb/master/master_admin.pb.h"
 #include "yb/master/ysql/ysql_catalog_config.h"
+#include "yb/master/ysql/ysql_manager_if.h"
 
-#include "yb/master/master_admin.pb.h"
+#include "yb/rpc/scheduler.h"
 
 namespace yb {
 
@@ -34,7 +35,10 @@ class YsqlManager : public YsqlManagerIf {
  public:
   YsqlManager(Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog);
 
-  virtual ~YsqlManager() = default;
+  ~YsqlManager() override = default;
+
+  void StartShutdown();
+  void CompleteShutdown();
 
   void Clear();
 
@@ -131,9 +135,31 @@ class YsqlManager : public YsqlManagerIf {
       const PgTableAllOids& oids,
       const ReadHybridTime& read_time = ReadHybridTime()) const override;
 
+  void RunBgTasks(const LeaderEpoch& epoch);
+
  private:
   Result<bool> StartRunningInitDbIfNeededInternal(const LeaderEpoch& epoch);
 
+  Status CreatePgAutoAnalyzeService(const LeaderEpoch& epoch);
+
+  void StartTablespaceBgTaskIfStopped();
+
+  // Helper function to schedule the next iteration of the tablespace info task.
+  void ScheduleRefreshTablespaceInfoTask(const bool schedule_now = false);
+
+  // Background task that refreshes the in-memory state for YSQL tables with their associated
+  // tablespace info.
+  // Note: This function should only ever be called by StartTablespaceBgTaskIfStopped().
+  void RefreshTablespaceInfoPeriodically();
+
+  void StartPgCatalogVersionsBgTaskIfStopped();
+
+  // Helper function to schedule the next iteration of the pg catalog versions task.
+  void ScheduleRefreshPgCatalogVersionsTask(bool schedule_now = false);
+
+  // Background task that refreshes the in-memory map for YSQL pg_yb_catalog_version table.
+  void RefreshPgCatalogVersionInfoPeriodically();
+
   Master& master_;
   CatalogManager& catalog_manager_;
   SysCatalogTable& sys_catalog_;
@@ -147,6 +173,16 @@ class YsqlManager : public YsqlManagerIf {
 
   bool advisory_locks_table_created_ = false;
 
+  bool pg_auto_analyze_service_created_ = false;
+
+  // Whether the periodic job to update tablespace info is running.
+  std::atomic<bool> tablespace_bg_task_running_;
+
+  rpc::ScheduledTaskTracker refresh_ysql_tablespace_info_task_;
+
+  std::atomic<bool> pg_catalog_versions_bg_task_running_ = {false};
+  rpc::ScheduledTaskTracker refresh_ysql_pg_catalog_versions_task_;
+
   DISALLOW_COPY_AND_ASSIGN(YsqlManager);
 };
 
diff --git a/src/yb/rpc/scheduler.h b/src/yb/rpc/scheduler.h
index 7b88c56724..d55a48d7f7 100644
--- a/src/yb/rpc/scheduler.h
+++ b/src/yb/rpc/scheduler.h
@@ -16,8 +16,8 @@
 #pragma once
 
 #include "yb/rpc/rpc_fwd.h"
-#include "yb/util/net/net_fwd.h"
 
+#include "yb/util/net/net_fwd.h"
 #include "yb/util/status.h"
 
 namespace yb {
@@ -121,7 +121,7 @@ class ScheduledTaskTracker {
   ScheduledTaskTracker(const std::string& name, Scheduler* scheduler);
 
   void Bind(Scheduler* scheduler) {
-    scheduler_ = scheduler;
+    scheduler_ = DCHECK_NOTNULL(scheduler);
   }
 
   template <class F>
