diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
index fd1420d9cb..656f76782d 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
@@ -375,6 +375,8 @@ Status YsqlInitDBAndMajorUpgradeHandler::PerformPgUpgrade(const LeaderEpoch& epo
   const auto pg_upgrade_data_dir =
       JoinPathSegments(master_opts.fs_opts.data_paths.front(), "pg_upgrade_data");
 
+  RETURN_NOT_OK(PgWrapper::CleanupPgData(pg_upgrade_data_dir));
+
   // Run local initdb to prepare the node for starting postgres.
   auto pg_conf = VERIFY_RESULT(pgwrapper::PgProcessConf::CreateValidateAndRunInitDb(
       FLAGS_rpc_bind_addresses, pg_upgrade_data_dir, master_.GetSharedMemoryFd()));
@@ -422,6 +424,8 @@ Status YsqlInitDBAndMajorUpgradeHandler::PerformPgUpgrade(const LeaderEpoch& epo
 
   RETURN_NOT_OK(PgWrapper::RunPgUpgrade(pg_upgrade_params));
 
+  RETURN_NOT_OK(PgWrapper::CleanupPgData(pg_upgrade_data_dir));
+
   return Status::OK();
 }
 
diff --git a/src/yb/util/env.cc b/src/yb/util/env.cc
index 6f57c03d26..6b5debe61c 100644
--- a/src/yb/util/env.cc
+++ b/src/yb/util/env.cc
@@ -166,6 +166,9 @@ Status DeleteIfExists(const std::string& path, Env* env) {
   if (env->FileExists(path)) {
     return env->DeleteFile(path);
   }
+
+  RETURN_NOT_OK(env->DeleteSymlinkIfExists(path));
+
   return Status::OK();
 }
 
@@ -328,6 +331,10 @@ Status EnvWrapper::SymlinkPath(const std::string& pointed_to, const std::string&
   return target_->SymlinkPath(pointed_to, new_symlink);
 }
 
+Status EnvWrapper::DeleteSymlinkIfExists(const std::string& path) {
+  return target_->DeleteSymlinkIfExists(path);
+}
+
 Result<std::string> EnvWrapper::ReadLink(const std::string& s) {
   return target_->ReadLink(s);
 }
diff --git a/src/yb/util/env.h b/src/yb/util/env.h
index 09d6ec956d..a2c797313b 100644
--- a/src/yb/util/env.h
+++ b/src/yb/util/env.h
@@ -307,6 +307,8 @@ class Env {
   // Symlink new_symlink to pointed_to. Unlinks new_symlink if it's already linked.
   virtual Status SymlinkPath(const std::string& pointed_to, const std::string& new_symlink) = 0;
 
+  virtual Status DeleteSymlinkIfExists(const std::string& path) = 0;
+
   // Read link's actual target
   virtual Result<std::string> ReadLink(const std::string& link) = 0;
 
@@ -723,6 +725,7 @@ class EnvWrapper : public Env {
   Result<FilesystemStats> GetFilesystemStatsBytes(const std::string& f) override;
   Status LinkFile(const std::string& s, const std::string& t) override;
   Status SymlinkPath(const std::string& pointed_to, const std::string& new_symlink) override;
+  Status DeleteSymlinkIfExists(const std::string& path) override;
   Result<std::string> ReadLink(const std::string& s) override;
   Status RenameFile(const std::string& s, const std::string& t) override;
   Status LockFile(const std::string& f, FileLock** l, bool r) override;
diff --git a/src/yb/util/env_posix.cc b/src/yb/util/env_posix.cc
index d1725ae0ae..7346ff6120 100644
--- a/src/yb/util/env_posix.cc
+++ b/src/yb/util/env_posix.cc
@@ -1165,15 +1165,21 @@ class PosixEnv : public Env {
 
   Status SymlinkPath(const std::string& pointed_to, const std::string& new_symlink) override {
     // Unlink if already linked.
-    if (unlink(new_symlink.c_str()) != 0) {
+    RETURN_NOT_OK(DeleteSymlinkIfExists(new_symlink));
+
+    if (symlink(pointed_to.c_str(), new_symlink.c_str()) != 0) {
+      return STATUS_IO_ERROR(Format("Symlink $0 => $1", new_symlink, pointed_to), errno);
+    }
+    return Status::OK();
+  }
+
+  Status DeleteSymlinkIfExists(const std::string& path) override {
+    if (unlink(path.c_str()) != 0) {
       // It's ok for the link not to exist already.
       if (errno != ENOENT) {
-        return STATUS_IO_ERROR(Format("Unlink $0", new_symlink), errno);
+        return STATUS_IO_ERROR(Format("Unlink $0", path), errno);
       }
     }
-    if (symlink(pointed_to.c_str(), new_symlink.c_str()) != 0) {
-      return STATUS_IO_ERROR(Format("Symlink $0 => $1", new_symlink, pointed_to), errno);
-    }
     return Status::OK();
   }
 
diff --git a/src/yb/yql/pgwrapper/pg_wrapper.cc b/src/yb/yql/pgwrapper/pg_wrapper.cc
index 8741f19d43..a8eb26ca83 100644
--- a/src/yb/yql/pgwrapper/pg_wrapper.cc
+++ b/src/yb/yql/pgwrapper/pg_wrapper.cc
@@ -964,10 +964,13 @@ Result<int32_t> GetPgDirectoryVersion(const string& data_dir) {
   return CheckedStoi(slc.Prefix(kVersionChars));
 }
 
+std::string MakeVersionedDataDir(const std::string& data_dir, int32_t version) {
+  return data_dir + "_" + std::to_string(version);
+}
 }  // namespace
 
 string PgWrapper::MakeVersionedDataDir(int32_t version) {
-  return conf_.data_dir + "_" + std::to_string(version);
+  return pgwrapper::MakeVersionedDataDir(conf_.data_dir, version);
 }
 
 // The data directory contains PG files for a particular PG version.
@@ -1032,6 +1035,17 @@ Status PgWrapper::InitDbLocalOnlyIfNeeded() {
   return Env::Default()->SymlinkPath(versioned_data_dir, conf_.data_dir);
 }
 
+Status PgWrapper::CleanupPgData(const std::string& data_dir) {
+  const auto current_pg_version = VERIFY_RESULT(GetCurrentPgVersion());
+  const std::string versioned_data_dir =
+      pgwrapper::MakeVersionedDataDir(data_dir, current_pg_version);
+  auto env = Env::Default();
+  RETURN_NOT_OK(DeleteIfExists(versioned_data_dir, env));
+  RETURN_NOT_OK(DeleteIfExists(data_dir, env));
+
+  return Status::OK();
+}
+
 Status PgWrapper::InitDbForYSQL(
     const string& master_addresses, const string& tmp_dir_base, int tserver_shm_fd,
     std::vector<std::pair<string, YbcPgOid>> db_to_oid, bool is_major_upgrade) {
diff --git a/src/yb/yql/pgwrapper/pg_wrapper.h b/src/yb/yql/pgwrapper/pg_wrapper.h
index fe847ed9ad..bd31165b7f 100644
--- a/src/yb/yql/pgwrapper/pg_wrapper.h
+++ b/src/yb/yql/pgwrapper/pg_wrapper.h
@@ -85,6 +85,9 @@ class PgWrapper : public ProcessWrapper {
   // version.) This function is intended to be used during tablet server initialization.
   Status InitDbLocalOnlyIfNeeded();
 
+  // Cleanup the data directory, and any associated symlinks.
+  static Status CleanupPgData(const std::string& data_dir);
+
   // Run initdb in a mode that sets up the required metadata in the YB cluster. This is done
   // only once after the cluster has started up. tmp_dir_base is used as a base directory to
   // create a temporary PostgreSQL directory that is later deleted.
