diff --git a/src/yb/consensus/log_util.cc b/src/yb/consensus/log_util.cc
index b6b0b24ad3..1436bde985 100644
--- a/src/yb/consensus/log_util.cc
+++ b/src/yb/consensus/log_util.cc
@@ -980,13 +980,18 @@ Result<std::shared_ptr<LWLogEntryBatchPB>> ReadableLogSegment::ReadEntryBatch(
   estimated_memory_needed += header.msg_length;
 
   if (read_wal_mem_tracker_) {
-    if (!read_wal_mem_tracker_->TryConsume(estimated_memory_needed)) {
-      if (obey_memory_limit) {
-        YB_LOG_EVERY_N_SECS(WARNING, 5) << "Unable to read WAL batch due to insufficient memory";
-        return STATUS(Busy, "Unable to read WAL batch due to insufficient memory");
+    if (!read_wal_mem_tracker_->has_limit()) {
+      // Avoid use of TryConsume unnecessarily to avoid bug; see #29094.
+      read_wal_mem_tracker_->Consume(estimated_memory_needed);
+    } else {
+      if (!read_wal_mem_tracker_->TryConsume(estimated_memory_needed)) {
+        if (obey_memory_limit) {
+          YB_LOG_EVERY_N_SECS(WARNING, 5) << "Unable to read WAL batch due to insufficient memory";
+          return STATUS(Busy, "Unable to read WAL batch due to insufficient memory");
+        }
+        // No pre-consumption done; we will Consume once we know the actual memory usage.
+        estimated_memory_needed = 0;
       }
-      // No pre-consumption done; we will Consume once we know the actual memory usage.
-      estimated_memory_needed = 0;
     }
   }
   RefCntBuffer buffer(header.msg_length);
diff --git a/src/yb/tserver/tablet_memory_manager.cc b/src/yb/tserver/tablet_memory_manager.cc
index 1d31bb320a..e3a53a0b04 100644
--- a/src/yb/tserver/tablet_memory_manager.cc
+++ b/src/yb/tserver/tablet_memory_manager.cc
@@ -99,7 +99,8 @@ TAG_FLAG(db_block_cache_num_shard_bits, advanced);
 DEFINE_test_flag(bool, pretend_memory_exceeded_enforce_flush, false,
                   "Always pretend memory has been exceeded to enforce background flush.");
 
-DEFINE_NON_RUNTIME_int64(read_wal_memory_bytes, 512_MB,
+// TODO(#29094): Turn back on limiting to 512 MiB once TryConsume bug is fixed.
+DEFINE_NON_RUNTIME_int64(read_wal_memory_bytes, /*512_MB*/-1,
     "Limit on amount of memory used to hold WAL records temporarily read in from disk; -1 means "
     "no limit.");
 
