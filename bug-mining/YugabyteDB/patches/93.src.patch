diff --git a/src/yb/integration-tests/master_path_handlers-itest.cc b/src/yb/integration-tests/master_path_handlers-itest.cc
index 052ac7aa60..d123cecb6b 100644
--- a/src/yb/integration-tests/master_path_handlers-itest.cc
+++ b/src/yb/integration-tests/master_path_handlers-itest.cc
@@ -51,6 +51,7 @@
 #include "yb/tools/yb-admin_client.h"
 
 #include "yb/tserver/mini_tablet_server.h"
+#include "yb/tserver/stateful_services/stateful_service_base.h"
 #include "yb/tserver/tablet_server.h"
 #include "yb/tserver/tserver_service.pb.h"
 
@@ -78,6 +79,7 @@ DECLARE_bool(enable_automatic_tablet_splitting);
 DECLARE_bool(TEST_skip_deleting_split_tablets);
 DECLARE_uint32(leaderless_tablet_alert_delay_secs);
 DECLARE_bool(TEST_assert_local_op);
+DECLARE_bool(TEST_echo_service_enabled);
 
 namespace yb {
 namespace master {
@@ -1540,5 +1542,51 @@ TEST_F(MasterPathHandlersItestExtraTS, LoadDistributionViewWithFailedTServer) {
   ASSERT_OK(GetUrl("/load-distribution", &out));
 }
 
+TEST_F(MasterPathHandlersItest, YB_DISABLE_TEST_ON_MACOS(StatefulServices)) {
+  auto client = ASSERT_RESULT(cluster_->CreateClient());
+  const auto service_name = StatefulServiceKind_Name(StatefulServiceKind::TEST_ECHO);
+
+  faststring out;
+  ASSERT_OK(GetUrl("/stateful-services", &out));
+  auto out_str = out.ToString();
+  ASSERT_STR_NOT_CONTAINS(out_str, service_name);
+
+  ASSERT_OK(GetUrl("/api/v1/stateful-services", &out));
+  {
+    JsonReader r(out.ToString());
+    ASSERT_OK(r.Init());
+    const rapidjson::Value* json_obj = nullptr;
+    ASSERT_OK(r.ExtractObject(r.root(), NULL, &json_obj));
+    ASSERT_EQ(rapidjson::kObjectType, CHECK_NOTNULL(json_obj)->GetType());
+    ASSERT_TRUE(json_obj->HasMember("stateful_services"));
+    ASSERT_EQ(rapidjson::kArrayType, (*json_obj)["stateful_services"].GetType());
+    const auto services = (*json_obj)["stateful_services"].GetArray();
+    ASSERT_EQ(services.Size(), 0);
+  }
+
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_echo_service_enabled) = true;
+  ASSERT_OK(client->WaitForCreateTableToFinish(
+      stateful_service::GetStatefulServiceTableName(StatefulServiceKind::TEST_ECHO)));
+
+  ASSERT_OK(GetUrl("/stateful-services", &out));
+  out_str = out.ToString();
+  ASSERT_STR_CONTAINS(out_str, service_name);
+
+  ASSERT_OK(GetUrl("/api/v1/stateful-services", &out));
+  {
+    JsonReader r(out.ToString());
+    ASSERT_OK(r.Init());
+    const rapidjson::Value* json_obj = nullptr;
+    ASSERT_OK(r.ExtractObject(r.root(), NULL, &json_obj));
+    ASSERT_EQ(rapidjson::kObjectType, CHECK_NOTNULL(json_obj)->GetType());
+    ASSERT_TRUE(json_obj->HasMember("stateful_services"));
+    ASSERT_EQ(rapidjson::kArrayType, (*json_obj)["stateful_services"].GetType());
+    const auto services = (*json_obj)["stateful_services"].GetArray();
+    ASSERT_EQ(services.Size(), 1);
+    ASSERT_TRUE(services.Begin()->HasMember("service_name"));
+    ASSERT_EQ(services.Begin()->FindMember("service_name")->value.GetString(), service_name);
+  }
+}
+
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 9d754fc560..1017947cbe 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -12889,5 +12889,52 @@ std::optional<UniverseUuid> CatalogManager::GetUniverseUuidIfExists() const {
   return *universe_uuid_res;
 }
 
+Result<std::vector<CatalogManager::StatefulServiceStatus>>
+CatalogManager::GetStatefulServicesStatus() const {
+  std::vector<CatalogManager::StatefulServiceStatus> result;
+  std::vector<TableInfoPtr> tables_hosting_services;
+
+  {
+    SharedLock lock(mutex_);
+    for (const auto& table_info : tables_->GetAllTables()) {
+      if (!table_info->GetHostedStatefulServices().empty()) {
+        tables_hosting_services.emplace_back(table_info);
+      }
+    }
+  }
+
+  for (const auto& table_info : tables_hosting_services) {
+    const auto services = table_info->GetHostedStatefulServices();
+    if (services.empty()) {
+      continue;
+    }
+    for (const auto& service_kind : services) {
+      CatalogManager::StatefulServiceStatus service_status;
+      RSTATUS_DCHECK(
+          StatefulServiceKind_IsValid(service_kind), IllegalState,
+          Format("Unknown service kind $0", service_kind));
+      service_status.service_name = StatefulServiceKind_Name((StatefulServiceKind)service_kind);
+
+      service_status.service_table_id = table_info->id();
+      if (!table_info->GetTablets().empty()) {
+        const auto tablet = table_info->GetTablets().front();
+        service_status.service_tablet_id = tablet->tablet_id();
+        auto leader_result = tablet->GetLeader();
+        if (leader_result.ok()) {
+          service_status.hosting_node = leader_result.get();
+        } else {
+          VLOG(1) << Format(
+              "Failed to get leader for Stateful Service $0: $1", service_status.service_name,
+              leader_result.status());
+        }
+      }
+
+      result.emplace_back(std::move(service_status));
+    }
+  }
+
+  return result;
+}
+
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index 30b5510776..b84622943b 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -328,6 +328,14 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
       const StatefulServiceKind& service_kind, const client::YBSchema& yb_schema,
       const LeaderEpoch& epoch);
 
+  struct StatefulServiceStatus {
+    std::string service_name;
+    const TSDescriptor* hosting_node = nullptr;
+    TableId service_table_id;
+    TabletId service_tablet_id;
+  };
+  Result<std::vector<StatefulServiceStatus>> GetStatefulServicesStatus() const EXCLUDES(mutex_);
+
   Status CreateTestEchoService(const LeaderEpoch& epoch);
 
   Status CreatePgAutoAnalyzeService(const LeaderEpoch& epoch);
diff --git a/src/yb/master/master-path-handlers.cc b/src/yb/master/master-path-handlers.cc
index e3f3f1ea33..de5c91f670 100644
--- a/src/yb/master/master-path-handlers.cc
+++ b/src/yb/master/master-path-handlers.cc
@@ -3280,6 +3280,71 @@ void MasterPathHandlers::HandleLoadBalancer(
   RenderLoadBalancerViewPanel(*tserver_tree_result, descs, tables, output);
 }
 
+void MasterPathHandlers::HandleStatefulServices(
+    const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
+  std::stringstream& output = resp->output;
+  master_->catalog_manager()->AssertLeaderLockAcquiredForReading();
+  auto stateful_service_result = master_->catalog_manager_impl()->GetStatefulServicesStatus();
+
+  if (!stateful_service_result.ok()) {
+    output << "<div class=\"alert alert-warning\">"
+           << EscapeForHtmlToString(stateful_service_result.status().ToString()) << "</div>";
+    return;
+  }
+
+  output << "<h1>Stateful Services</h1>\n";
+  HTML_PRINT_TABLE_WITH_HEADER_ROW(
+      stateful_services, "Service Name", "Hosting server", "Table Id", "Tablet ID");
+  for (const auto& service : *stateful_service_result) {
+    const auto& reg = service.hosting_node->GetRegistration();
+    const auto& host_port = GetHttpHostPortFromServerRegistration(reg.common());
+    const auto& cloud_info = reg.common().cloud_info();
+    const auto& host_server = Format(
+        "$0<br/>$1<br/>$2", RegistrationToHtml(reg.common(), host_port),
+        service.hosting_node->permanent_uuid(),
+        EscapeForHtmlToString(Format(
+            "$0.$1.$2", cloud_info.placement_cloud(), cloud_info.placement_region(),
+            cloud_info.placement_zone())));
+
+    HTML_PRINT_TABLE_ROW(
+        service.service_name, host_server,
+        Format("<a href=\"/table?id=$0\">$0</a>", service.service_table_id),
+        service.service_tablet_id);
+  }
+  HTML_END_TABLE;
+  HTML_ADD_SORT_AND_FILTER_TABLE_SCRIPT;
+}
+
+void MasterPathHandlers::HandleStatefulServicesJson(
+    const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
+  JsonWriter jw(&resp->output, JsonWriter::COMPACT);
+
+  master_->catalog_manager()->AssertLeaderLockAcquiredForReading();
+  jw.StartObject();
+  auto stateful_service_result = master_->catalog_manager_impl()->GetStatefulServicesStatus();
+  if (!stateful_service_result.ok()) {
+    jw.String("error");
+    jw.String(stateful_service_result.status().ToString());
+  } else {
+    jw.String("stateful_services");
+    jw.StartArray();
+    for (const auto& service : *stateful_service_result) {
+      jw.StartObject();
+      jw.String("service_name");
+      jw.String(service.service_name);
+      jw.String("hosting_server");
+      jw.String(service.hosting_node->permanent_uuid());
+      jw.String("table_id");
+      jw.String(service.service_table_id);
+      jw.String("tablet_id");
+      jw.String(service.service_tablet_id);
+      jw.EndObject();
+    }
+    jw.EndArray();
+  }
+  jw.EndObject();
+}
+
 Status MasterPathHandlers::Register(Webserver* server) {
   const bool is_styled = true;
   const bool is_on_nav_bar = true;
@@ -3332,9 +3397,10 @@ Status MasterPathHandlers::Register(Webserver* server) {
   RegisterLeaderOrRedirect(
       server, "/load-distribution", "Load balancer View", &MasterPathHandlers::HandleLoadBalancer,
       is_styled);
-  server->RegisterPathHandler(
-      "/api/v1/meta-cache", "MetaCache",
-      std::bind(&MasterPathHandlers::HandleGetMetaCacheJson, this, _1, _2), false, false);
+
+  RegisterLeaderOrRedirect(
+      server, "/stateful-services", "Stateful Services",
+      &MasterPathHandlers::HandleStatefulServices, is_styled);
 
   // JSON Endpoints
   RegisterLeaderOrRedirect(
@@ -3382,6 +3448,14 @@ Status MasterPathHandlers::Register(Webserver* server) {
   RegisterLeaderOrRedirect(
       server, "/api/v1/xcluster", "xCluster", &MasterPathHandlers::HandleGetXClusterJSON);
 
+  server->RegisterPathHandler(
+      "/api/v1/meta-cache", "MetaCache",
+      std::bind(&MasterPathHandlers::HandleGetMetaCacheJson, this, _1, _2), false, false);
+
+  RegisterLeaderOrRedirect(
+      server, "/api/v1/stateful-services", "Stateful Services",
+      &MasterPathHandlers::HandleStatefulServicesJson);
+
   return Status::OK();
 }
 
diff --git a/src/yb/master/master-path-handlers.h b/src/yb/master/master-path-handlers.h
index 08186cff2e..78e890e031 100644
--- a/src/yb/master/master-path-handlers.h
+++ b/src/yb/master/master-path-handlers.h
@@ -305,6 +305,8 @@ class MasterPathHandlers {
   void HandlePrettyLB(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
   void HandleLoadBalancer(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
   void HandleGetMetaCacheJson(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
+  void HandleStatefulServices(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
+  void HandleStatefulServicesJson(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
 
   // Calcuates number of leaders/followers per table.
   void CalculateTabletMap(TabletCountMap* tablet_map);
