diff --git a/src/postgres/src/backend/catalog/yb_catalog/yb_oid_assignment.c b/src/postgres/src/backend/catalog/yb_catalog/yb_oid_assignment.c
index 3c5fbcd38a..67ffe4b818 100644
--- a/src/postgres/src/backend/catalog/yb_catalog/yb_oid_assignment.c
+++ b/src/postgres/src/backend/catalog/yb_catalog/yb_oid_assignment.c
@@ -32,6 +32,9 @@
 static HTAB *yb_enum_label_assignment_map = NULL;
 static bool yb_enum_label_assignment_exists = false;
 
+static HTAB *yb_sequence_oid_assignment_map = NULL;
+static bool yb_sequence_oid_assignment_exists = false;
+
 /*
  * yb_enum_label_assignment_map key format is <oid>.<label>\0
  * Oid's are uint_32_t so take up at most 10 decimal digits.
@@ -111,6 +114,79 @@ YbLookupOidForEnumLabel(Oid enum_oid, const char *label)
 	return InvalidOid;
 }
 
+/*
+ * yb_sequence_oid_assignment_map key format is <schema>.<name>\0
+ * <identifier>\0 is guaranteed to fit in NAMEDATALEN characters.
+ */
+#define YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE (NAMEDATALEN + NAMEDATALEN)
+
+typedef struct YbSequenceOidAssignmentMapEntry {
+	/* encodes schema, name */
+	char		key[YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE];
+	Oid			oid;
+} YbSequenceOidAssignmentMapEntry;
+
+static void
+YbClearSequenceOidMap(void)
+{
+	HASHCTL ctl;
+
+	if (yb_sequence_oid_assignment_map != NULL)
+		hash_destroy(yb_sequence_oid_assignment_map);
+	memset(&ctl, 0, sizeof(ctl));
+	ctl.keysize = YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE;
+	ctl.entrysize = sizeof(YbSequenceOidAssignmentMapEntry);
+	yb_sequence_oid_assignment_map = hash_create("YB sequence OIDs map",
+											   /*initial size*/ 20, &ctl,
+											   HASH_ELEM | HASH_STRINGS);
+}
+
+static void
+YbCreateSequenceOidMapKey(const char *schema, const char *name, char *key_buffer)
+{
+	int written_bytes = snprintf(key_buffer,
+								 YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE,
+								 "%s.%s", schema, name);
+	if (written_bytes >= YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE)
+		elog(ERROR,
+			 "unexpectedly large schema/name in OID assignment (schema '%s', "
+			 "name '%s')",
+			 schema, name);
+}
+
+static void
+YbInsertSequenceOid(const char *schema, const char *name, Oid sequence_oid)
+{
+	char key[YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE];
+	YbCreateSequenceOidMapKey(schema, name, key);
+
+	bool found;
+	YbSequenceOidAssignmentMapEntry *entry =
+		hash_search(yb_sequence_oid_assignment_map, key, HASH_ENTER, &found);
+	if (!found)
+		entry->oid = sequence_oid;
+	else if (entry->oid != sequence_oid)
+		elog(ERROR,
+			 "attempt to provide multiple OIDs for sequence %s.%s: %u vs "
+			 "%u",
+			 schema, name, entry->oid, sequence_oid);
+}
+
+/* Returns InvalidOid on not found. */
+static Oid
+YbLookupOidForSequence(const char *schema, const char *name)
+{
+	char key[YB_SEQUENCE_OID_ASSIGNMENT_MAP_KEY_SIZE];
+	YbCreateSequenceOidMapKey(schema, name, key);
+
+	bool found;
+	YbSequenceOidAssignmentMapEntry *entry =
+		hash_search(yb_sequence_oid_assignment_map, key, HASH_FIND, &found);
+	if (found)
+		return entry->oid;
+	return InvalidOid;
+}
+
 /* Returns InvalidOid on bad input. */
 static Oid
 YbGetOidFromText(const text *input)
@@ -153,6 +229,22 @@ PG_FUNCTION_INFO_V1(yb_xcluster_set_next_oid_assignments);
  * not create all the labels mentioned in the assignment.
  *
  *
+ * Example:
+ *    SELECT pg_catalog.yb_xcluster_set_next_oid_assignments(
+ *       '{"sequence_info":['                                        ||
+ *            '{"schema":"public","name":"my_sequence","oid":16406}' ||
+ *            ']}');
+ *
+ * This indicates that the sequence named my_sequence in schema public should
+ * be assigned the OID 16406.
+ *
+ * The sequence_info key is optional; if it is present then all sequences
+ * created until the assignment is changed are expected to be covered by the
+ * assignment.  In the example this means that if the DDL attempts to create a
+ * sequence not_my_sequence then an error will occur.  It is not an error if
+ * the DDL does not create all the sequences mentioned in the assignment.
+ *
+ *
  * You can remove the current assignment if any by using
  *
  *     SELECT pg_catalog.yb_xcluster_set_next_oid_assignments('{}');
@@ -165,7 +257,6 @@ yb_xcluster_set_next_oid_assignments(PG_FUNCTION_ARGS)
 
 	YbClearEnumLabelMap();
 	yb_enum_label_assignment_exists = false;
-
 	text *enum_label_info = json_get_value(json_text, "enum_label_info");
 	if (enum_label_info != NULL)
 	{
@@ -194,6 +285,34 @@ yb_xcluster_set_next_oid_assignments(PG_FUNCTION_ARGS)
 		}
 	}
 
+	YbClearSequenceOidMap();
+	yb_sequence_oid_assignment_exists = false;
+	text *sequence_info = json_get_value(json_text, "sequence_info");
+	if (sequence_info != NULL)
+	{
+		yb_sequence_oid_assignment_exists = true;
+		int length = get_json_array_length(sequence_info);
+		for (int i = 0; i < length; i++)
+		{
+			text *sequence_info_entry = get_json_array_element(sequence_info, i);
+			char *schema = text_to_cstring(json_get_denormalized_value(sequence_info_entry,
+				"schema"));
+			char *name = text_to_cstring(json_get_denormalized_value(sequence_info_entry,
+				"name"));
+			text *oid_text = json_get_value(sequence_info_entry, "oid");
+			Oid sequence_oid = YbGetOidFromText(oid_text);
+			if (sequence_oid == InvalidOid)
+			{
+				elog(ERROR,
+					 "corrupted JSON passed to "
+					 "yb_xcluster_set_next_oid_assignments: '%s'",
+					 text_to_cstring(json_text));
+			}
+
+			YbInsertSequenceOid(schema, name, sequence_oid);
+		}
+	}
+
 	PG_RETURN_VOID();
 }
 
@@ -223,3 +342,19 @@ YbLookupOidAssignmentForEnumLabel(Oid enum_oid, const char *label)
 			 enum_oid, label);
 	return label_oid;
 }
+
+bool
+YbUsingSequenceOidAssignment(void)
+{
+	return yb_sequence_oid_assignment_exists;
+}
+
+Oid
+YbLookupOidAssignmentForSequence(const char *schema, const char *name)
+{
+	Oid sequence_oid = YbLookupOidForSequence(schema, name);
+	if (sequence_oid == InvalidOid)
+		elog(ERROR, "no OID assignment for sequence %s.%s in OID assignment",
+			 schema, name);
+	return sequence_oid;
+}
diff --git a/src/postgres/src/backend/commands/tablecmds.c b/src/postgres/src/backend/commands/tablecmds.c
index 36d8a1c8ab..0081af51c2 100644
--- a/src/postgres/src/backend/commands/tablecmds.c
+++ b/src/postgres/src/backend/commands/tablecmds.c
@@ -66,6 +66,7 @@
 #include "catalog/storage.h"
 #include "catalog/storage_xlog.h"
 #include "catalog/toasting.h"
+#include "catalog/yb_oid_assignment.h"
 #include "commands/cluster.h"
 #include "commands/comment.h"
 #include "commands/defrem.h"
@@ -1185,6 +1186,11 @@ DefineRelation(CreateStmt *stmt, char relkind, Oid ownerId,
 		}
 	}
 
+	if (relkind == RELKIND_SEQUENCE && YbUsingSequenceOidAssignment())
+	{
+		relationId = YbLookupOidAssignmentForSequence(get_namespace_name(namespaceId), relname);
+	}
+
 	/*
 	 * Create the relation.  Inherited defaults and constraints are passed in
 	 * for immediate handling --- since they don't need parsing, they can be
diff --git a/src/postgres/src/include/catalog/yb_oid_assignment.h b/src/postgres/src/include/catalog/yb_oid_assignment.h
index 492262f6e9..45a6de54a1 100644
--- a/src/postgres/src/include/catalog/yb_oid_assignment.h
+++ b/src/postgres/src/include/catalog/yb_oid_assignment.h
@@ -29,3 +29,7 @@
 extern bool YbUsingEnumLabelOidAssignment(void);
 
 extern Oid YbLookupOidAssignmentForEnumLabel(Oid enum_oid, const char *label);
+
+extern bool YbUsingSequenceOidAssignment(void);
+
+extern Oid YbLookupOidAssignmentForSequence(const char *schema, const char *name);
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/source_ddl_end_handler.c b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/source_ddl_end_handler.c
index 6b93263b8b..969b82565a 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/source_ddl_end_handler.c
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/source_ddl_end_handler.c
@@ -139,6 +139,7 @@ static List *rewritten_table_oid_list = NIL;
 	X(CMDTAG_DROP_ROUTINE) \
 	X(CMDTAG_DROP_RULE) \
 	X(CMDTAG_DROP_SCHEMA) \
+	X(CMDTAG_DROP_SEQUENCE) \
 	X(CMDTAG_DROP_SERVER) \
 	X(CMDTAG_DROP_STATISTICS) \
 	X(CMDTAG_DROP_TEXT_SEARCH_CONFIGURATION) \
@@ -167,6 +168,13 @@ typedef struct YbEnumLabelMapEntry
 	char *label_name;
 } YbEnumLabelMapEntry;
 
+typedef struct YbSequenceInfoMapEntry
+{
+	char       *schema;
+	char       *name;
+	Oid         pg_class_oid;
+} YbSequenceInfoMapEntry;
+
 void
 CheckAlterColumnTypeDDL(CollectedCommand *cmd)
 {
@@ -221,17 +229,29 @@ IsPassThroughDdlSupported(const char *command_tag_name)
 	return IsPassThroughDdlCommandSupported(command_tag);
 }
 
+static bool
+IsSequence(Oid rel_oid)
+{
+	Relation	rel = RelationIdGetRelation(rel_oid);
+	if (!rel)
+		elog(ERROR, "Could not find relation with OID %d", rel_oid);
+
+	return rel->rd_rel->relkind == RELKIND_SEQUENCE;
+}
+
 /*
  * This function handles both new relation from create table/index,
  * and also new relations as a result of table rewrites.
+ *
+ * This function does not handle sequences.
  */
 bool
 ShouldReplicateNewRelation(Oid rel_oid, List **new_rel_list)
 {
 	Relation	rel = RelationIdGetRelation(rel_oid);
-
 	if (!rel)
-		elog(ERROR, "Could not find relation with oid %d", rel_oid);
+		elog(ERROR, "Could not find relation with OID %d", rel_oid);
+
 	/* Ignore temporary tables. */
 	if (!IsYBBackedRelation(rel))
 	{
@@ -381,6 +401,25 @@ GetEnumLabels(Oid enum_oid, List **enum_label_list)
 	}
 }
 
+static void
+AddSequenceInfo(Oid pg_class_oid, char *schema, List **sequence_info_list)
+{
+	char       *name = get_rel_name(pg_class_oid);
+	if (!name)
+		elog(ERROR, "Unable to find name of sequence with pg_class OID %u",
+			 pg_class_oid);
+	if (!schema)
+		elog(ERROR, "Schema of sequence with pg_class OID %u unknown",
+			 pg_class_oid);
+
+	YbSequenceInfoMapEntry *sequence_info_entry =
+		palloc(sizeof(YbSequenceInfoMapEntry));
+	sequence_info_entry->name = name;
+	sequence_info_entry->schema = pstrdup(schema);
+	sequence_info_entry->pg_class_oid = pg_class_oid;
+	*sequence_info_list = lappend(*sequence_info_list, sequence_info_entry);
+}
+
 typedef struct YbCommandInfo
 {
 	Oid         oid;
@@ -434,6 +473,7 @@ ProcessSourceEventTriggerDDLCommands(JsonbParseState *state)
 
 	List	   *new_rel_list = NIL;
 	List       *enum_label_list = NIL;
+	List       *sequence_info_list = NIL;
 	/*
 	 * As long as there is at least one command that needs to be replicated, we
 	 * will set this to true and replicate the entire query string.
@@ -466,6 +506,26 @@ ProcessSourceEventTriggerDDLCommands(JsonbParseState *state)
 				GetEnumLabels(obj_id, &enum_label_list);
 			should_replicate_ddl |= true;
 		}
+		else if (command_tag == CMDTAG_CREATE_SEQUENCE)
+		{
+			AddSequenceInfo(obj_id, schema, &sequence_info_list);
+			should_replicate_ddl |= !is_temporary_object;
+		}
+		else if (command_tag == CMDTAG_ALTER_SEQUENCE)
+		{
+			should_replicate_ddl |= !is_temporary_object;
+		}
+		else if (command_tag == CMDTAG_ALTER_TABLE &&
+				 IsSequence(obj_id))
+		{
+			/*
+			 * This is one of:
+			 * - ALTER TABLE <sequence> OWNER TO ...
+			 * - ALTER TABLE <sequence> RENAME TO ...
+			 * - ALTER TABLE <sequence> SET SCHEMA ...
+			 */
+			should_replicate_ddl |= !is_temporary_object;
+		}
 		else if (command_tag == CMDTAG_ALTER_TABLE &&
 				 list_member_oid(rewritten_table_oid_list, obj_id))
 		{
@@ -569,6 +629,37 @@ ProcessSourceEventTriggerDDLCommands(JsonbParseState *state)
 
 		(void) pushJsonbValue(&state, WJB_END_ARRAY, NULL);
 	}
+	if (sequence_info_list)
+	{
+		/*----------
+		 * Add the sequence_info_list to the JSON output.  We use a flat array
+		 * of entries because JSON doesn't allow maps on composite values.
+		 *
+		 * If two entries have the same schema and name, then the remaining
+		 * fields are guaranteed to be the same.
+		 *----------
+		 */
+		AddJsonKey(state, "sequence_info");
+		(void) pushJsonbValue(&state, WJB_BEGIN_ARRAY, NULL);
+
+		ListCell *l;
+		foreach (l, sequence_info_list)
+		{
+			YbSequenceInfoMapEntry *entry = (YbSequenceInfoMapEntry *) lfirst(l);
+
+			(void) pushJsonbValue(&state, WJB_BEGIN_OBJECT, NULL);
+			AddStringJsonEntry(state, "schema", entry->schema);
+			AddStringJsonEntry(state, "name", entry->name);
+			AddNumericJsonEntry(state, "oid", entry->pg_class_oid);
+			(void) pushJsonbValue(&state, WJB_END_OBJECT, NULL);
+
+			pfree(entry->schema);
+			pfree(entry->name);
+			pfree(entry);
+		}
+
+		(void) pushJsonbValue(&state, WJB_END_ARRAY, NULL);
+	}
 
 	return should_replicate_ddl;
 }
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_xcluster_ddl_replication.c b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_xcluster_ddl_replication.c
index dcfe02377a..6fbd7b47db 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_xcluster_ddl_replication.c
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/yb_xcluster_ddl_replication.c
@@ -60,7 +60,14 @@ bool		TEST_AllowColocatedObjects = false;
 static bool IsInIgnoreList(EventTriggerData *trig_data);
 
 /* Per DDL Variables. */
-static bool should_replicate_ddl = false;
+
+/*
+ * This is updated as the DDL triggers run, ending up with the decision of
+ * whether or not to replicate the DDL that is currently running.
+ *
+ * Once this becomes true, it remains true for the rest of the DDL.
+ */
+static bool yb_should_replicate_ddl = false;
 
 /*
  * _PG_init gets called when the extension is loaded.
@@ -319,10 +326,10 @@ HandleSourceDDLEnd(EventTriggerData *trig_data)
 	}
 	else
 	{
-		should_replicate_ddl |= ProcessSourceEventTriggerDDLCommands(state);
+		yb_should_replicate_ddl |= ProcessSourceEventTriggerDDLCommands(state);
 	}
 
-	if (should_replicate_ddl)
+	if (yb_should_replicate_ddl)
 	{
 		/* Construct the jsonb and insert completed row into ddl_queue table. */
 		JsonbValue *jsonb_val = pushJsonbValue(&state, WJB_END_OBJECT, NULL);
@@ -384,7 +391,7 @@ HandleSourceSQLDrop(EventTriggerData *trig_data)
 
 	INIT_MEM_CONTEXT_AND_SPI_CONNECT("yb_xcluster_ddl_replication.HandleSourceSQLDrop context");
 
-	should_replicate_ddl |= ProcessSourceEventTriggerDroppedObjects();
+	yb_should_replicate_ddl |= ProcessSourceEventTriggerDroppedObjects();
 
 	CLOSE_MEM_CONTEXT_AND_SPI;
 }
@@ -411,23 +418,22 @@ HandleSourceTableRewrite(EventTriggerData *trig_data)
 void
 HandleSourceDDLStart(EventTriggerData *trig_data)
 {
-	/*
-	 * Do some initial checks here before the source query runs.
-	 * Also reset should_replicate_ddl for this new DDL.
-	 */
+	/* By default we don't replicate. */
+	yb_should_replicate_ddl = false;
 	if (EnableManualDDLReplication)
 	{
 		/*
 		 * Always replicate manual DDLs regardless of what they are.
 		 * Will show up on the target with a manual_replication field set.
 		 */
-		should_replicate_ddl = true;
+		yb_should_replicate_ddl = true;
 		return;
 	}
 
+	/*
+	 * Do some initial checks here before the source query runs.
+	 */
 	DisallowMultiStatementQueries(trig_data->tag);
-	should_replicate_ddl = false;
-
 	ClearRewrittenTableOidList();
 }
 
diff --git a/src/yb/integration-tests/xcluster/sql/create_sequence.sql b/src/yb/integration-tests/xcluster/sql/create_sequence.sql
new file mode 100644
index 0000000000..278fca5575
--- /dev/null
+++ b/src/yb/integration-tests/xcluster/sql/create_sequence.sql
@@ -0,0 +1,243 @@
+--
+-- Creating sequences
+--
+
+-- Taken from postgres/src/test/regress/sql/yb_pg_sequence.sql
+
+--
+-- CREATE SEQUENCE
+--
+
+-- sequence data types
+CREATE SEQUENCE sequence_test5 AS integer;
+CREATE SEQUENCE sequence_test6 AS smallint;
+CREATE SEQUENCE sequence_test7 AS bigint;
+CREATE SEQUENCE sequence_test8 AS integer MAXVALUE 100000;
+CREATE SEQUENCE sequence_test9 AS integer INCREMENT BY -1;
+CREATE SEQUENCE sequence_test10 AS integer MINVALUE -100000 START 1;
+CREATE SEQUENCE sequence_test11 AS smallint;
+CREATE SEQUENCE sequence_test12 AS smallint INCREMENT -1;
+CREATE SEQUENCE sequence_test13 AS smallint MINVALUE -32768;
+CREATE SEQUENCE sequence_test14 AS smallint MAXVALUE 32767 INCREMENT -1;
+
+ALTER SEQUENCE sequence_test5 AS smallint;  -- success, max will be adjusted
+ALTER SEQUENCE sequence_test8 AS smallint MAXVALUE 20000;  -- ok now
+ALTER SEQUENCE sequence_test9 AS smallint;  -- success, min will be adjusted
+ALTER SEQUENCE sequence_test10 AS smallint MINVALUE -20000;  -- ok now
+
+ALTER SEQUENCE sequence_test11 AS int;  -- max will be adjusted
+ALTER SEQUENCE sequence_test12 AS int;  -- min will be adjusted
+ALTER SEQUENCE sequence_test13 AS int;  -- min and max will be adjusted
+ALTER SEQUENCE sequence_test14 AS int;  -- min and max will be adjusted
+
+---
+--- test creation of SERIAL column
+---
+
+CREATE TABLE serialTest1 (f1 text, f2 serial);
+
+INSERT INTO serialTest1 VALUES ('foo');
+INSERT INTO serialTest1 VALUES ('bar');
+INSERT INTO serialTest1 VALUES ('force', 100);
+
+SELECT pg_get_serial_sequence('serialTest1', 'f2');
+
+-- test smallserial / bigserial
+CREATE TABLE serialTest2 (f1 text, f2 serial, f3 smallserial, f4 serial2,
+  f5 bigserial, f6 serial8);
+
+INSERT INTO serialTest2 (f1)
+  VALUES ('test_defaults');
+
+INSERT INTO serialTest2 (f1, f2, f3, f4, f5, f6)
+  VALUES ('test_max_vals', 2147483647, 32767, 32767, 9223372036854775807,
+          9223372036854775807),
+         ('test_min_vals', -2147483648, -32768, -32768, -9223372036854775808,
+          -9223372036854775808);
+
+SELECT nextval('serialTest2_f2_seq');
+SELECT nextval('serialTest2_f3_seq');
+SELECT nextval('serialTest2_f4_seq');
+SELECT nextval('serialTest2_f5_seq');
+SELECT nextval('serialTest2_f6_seq');
+
+-- basic sequence operations using both text and oid references
+CREATE SEQUENCE sequence_test;
+CREATE SEQUENCE IF NOT EXISTS sequence_test;
+
+SELECT nextval('sequence_test'::text);
+SELECT nextval('sequence_test'::regclass);
+SELECT currval('sequence_test'::text);
+SELECT currval('sequence_test'::regclass);
+SELECT setval('sequence_test'::text, 32);
+SELECT nextval('sequence_test'::regclass);
+SELECT setval('sequence_test'::text, 99, false);
+SELECT nextval('sequence_test'::regclass);
+SELECT setval('sequence_test'::regclass, 32);
+SELECT nextval('sequence_test'::text);
+SELECT setval('sequence_test'::regclass, 99, false);
+SELECT nextval('sequence_test'::text);
+DISCARD SEQUENCES;
+
+-- renaming sequences
+CREATE SEQUENCE foo_seq;
+ALTER TABLE foo_seq RENAME TO foo_seq_new;
+SELECT nextval('foo_seq_new');
+SELECT nextval('foo_seq_new');
+
+-- renaming sequences
+CREATE SEQUENCE foo_seq2;
+ALTER SEQUENCE foo_seq2 RENAME TO foo_seq2_new;
+SELECT nextval('foo_seq2_new');
+SELECT nextval('foo_seq2_new');
+
+-- renaming serial sequences
+ALTER SEQUENCE serialtest1_f2_seq RENAME TO serialtest1_f2_foo;
+INSERT INTO serialTest1 VALUES ('more');
+
+--
+-- Check dependencies of serial and ordinary sequences
+--
+CREATE TEMP SEQUENCE myseq2;
+CREATE TEMP SEQUENCE myseq3;
+CREATE TEMP TABLE t1 (
+  f1 serial,
+  f2 int DEFAULT nextval('myseq2'),
+  f3 int DEFAULT nextval('myseq3'::text)
+);
+
+-- This however will work:
+DROP SEQUENCE myseq3;
+DROP TABLE t1;
+-- Now OK:
+DROP SEQUENCE myseq2;
+
+--
+-- Alter sequence
+--
+-- TODO(#24080): deal with these test cases appropriately once we
+-- figure out which of these alters we are handling.
+--
+
+-- ALTER SEQUENCE IF EXISTS sequence_test2 RESTART WITH 24
+--   INCREMENT BY 4 MAXVALUE 36 MINVALUE 5 CYCLE;
+
+-- CREATE SEQUENCE sequence_test2 START WITH 32;
+
+-- SELECT nextval('sequence_test2');
+
+-- ALTER SEQUENCE sequence_test2 RESTART;
+-- SELECT nextval('sequence_test2');
+
+-- -- test CYCLE and NO CYCLE
+-- ALTER SEQUENCE sequence_test2 RESTART WITH 24
+--   INCREMENT BY 4 MAXVALUE 36 MINVALUE 5 CYCLE;
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');  -- cycled
+
+-- ALTER SEQUENCE sequence_test2 RESTART WITH 24
+--   NO CYCLE;
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');
+
+-- ALTER SEQUENCE sequence_test2 RESTART WITH -24 START WITH -24
+--   INCREMENT BY -4 MINVALUE -36 MAXVALUE -5 CYCLE;
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');  -- cycled
+
+-- ALTER SEQUENCE sequence_test2 RESTART WITH -24
+--   NO CYCLE;
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');
+-- SELECT nextval('sequence_test2');
+
+-- -- reset
+-- ALTER SEQUENCE IF EXISTS sequence_test2 RESTART WITH 32 START WITH 32
+--   INCREMENT BY 4 MAXVALUE 36 MINVALUE 5 CYCLE;
+
+-- SELECT setval('sequence_test2', 5);
+
+
+-- Test comments
+COMMENT ON SEQUENCE sequence_test5 IS 'will work';
+COMMENT ON SEQUENCE sequence_test5 IS NULL;
+
+-- Test lastval()
+CREATE SEQUENCE seq;
+SELECT nextval('seq');
+SELECT lastval();
+SELECT setval('seq', 99);
+SELECT lastval();
+DISCARD SEQUENCES;
+
+CREATE SEQUENCE seq2;
+SELECT nextval('seq2');
+SELECT lastval();
+
+-- unlogged sequences
+-- (more tests in src/test/recovery/)
+CREATE UNLOGGED SEQUENCE sequence_test_unlogged;
+ALTER SEQUENCE sequence_test_unlogged SET LOGGED;
+ALTER SEQUENCE sequence_test_unlogged SET UNLOGGED;
+
+-- Test sequences in read-only transactions
+CREATE TEMPORARY SEQUENCE sequence_test_temp1;
+START TRANSACTION READ ONLY;
+SELECT nextval('sequence_test_temp1');  -- ok
+ROLLBACK;
+START TRANSACTION READ ONLY;
+SELECT setval('sequence_test_temp1', 1);  -- ok
+ROLLBACK;
+
+-- cache tests
+CREATE SEQUENCE test_seq1 CACHE 10;
+SELECT nextval('test_seq1');
+SELECT nextval('test_seq1');
+SELECT nextval('test_seq1');
+
+
+-- Sequences with the same name but different schemas
+CREATE SCHEMA schema1;
+CREATE SCHEMA schema2;
+
+CREATE SEQUENCE schema1.my_sequence START WITH 1 INCREMENT BY 1;
+CREATE SEQUENCE schema2.my_sequence START WITH 10 INCREMENT BY 11;
+
+
+-- Changing sequence ownership
+CREATE SEQUENCE owned_sequence START 1;
+ALTER SEQUENCE owned_sequence OWNER TO postgres;
+CREATE SEQUENCE owned_sequence2 START 1;
+ALTER TABLE owned_sequence2 OWNER TO postgres;
+
+CREATE SEQUENCE owned_sequence3 START 1;
+CREATE TABLE owning_table (
+    name TEXT NOT NULL
+);
+ALTER SEQUENCE owned_sequence3 OWNED BY owning_table.name;
+
+
+-- Changing sequence schemas
+CREATE SEQUENCE schema1.sequence_changing_schemas START WITH 1 INCREMENT BY 1;
+ALTER SEQUENCE schema1.sequence_changing_schemas SET SCHEMA schema2;
+CREATE SEQUENCE schema1.sequence_changing_schemas2 START WITH 1 INCREMENT BY 1;
+ALTER TABLE schema1.sequence_changing_schemas2 SET SCHEMA schema2;
+
+
+-- Sequences created using a non-standard default schema
+CREATE SCHEMA IF NOT EXISTS my_schema;
+SET search_path TO my_schema;
+CREATE SEQUENCE my_sequence;  -- actually my_schema.my_sequence
+CREATE TABLE my_table (       -- actually my_schema.my_table
+    id SERIAL PRIMARY KEY,
+    name TEXT NOT NULL
+);
diff --git a/src/yb/integration-tests/xcluster/sql/drop_sequence.sql b/src/yb/integration-tests/xcluster/sql/drop_sequence.sql
new file mode 100644
index 0000000000..f0e9d7e510
--- /dev/null
+++ b/src/yb/integration-tests/xcluster/sql/drop_sequence.sql
@@ -0,0 +1,43 @@
+--
+-- Drops enums from yb/integration-tests/xcluster/sql/create_sequence.sql
+--
+
+DROP SEQUENCE sequence_test;
+-- DROP SEQUENCE sequence_test2;
+DROP SEQUENCE sequence_test5;
+DROP SEQUENCE sequence_test6;
+DROP SEQUENCE sequence_test7;
+DROP SEQUENCE sequence_test8;
+DROP SEQUENCE sequence_test9;
+DROP SEQUENCE sequence_test10;
+DROP SEQUENCE sequence_test11;
+DROP SEQUENCE sequence_test12;
+DROP SEQUENCE sequence_test13;
+DROP SEQUENCE sequence_test14;
+
+DROP SEQUENCE foo_seq_new;
+DROP SEQUENCE foo_seq2_new;
+
+DROP SEQUENCE seq;
+DROP SEQUENCE seq2;
+
+DROP SEQUENCE sequence_test_unlogged;
+
+-- Sequences should get wiped out as well:
+DROP TABLE serialTest1, serialTest2;
+
+DROP SEQUENCE test_seq1;
+
+DROP SEQUENCE schema1.my_sequence;
+DROP SEQUENCE schema2.my_sequence;
+
+DROP SEQUENCE owned_sequence;
+DROP SEQUENCE owned_sequence2;
+DROP TABLE owning_table;
+
+DROP SEQUENCE schema2.sequence_changing_schemas;
+DROP SEQUENCE schema2.sequence_changing_schemas2;
+
+SET search_path TO my_schema;
+DROP SEQUENCE my_sequence;
+DROP TABLE my_table;
diff --git a/src/yb/integration-tests/xcluster/sql/temporary_objects.sql b/src/yb/integration-tests/xcluster/sql/temporary_objects.sql
index 1394b37352..443af6f25e 100644
--- a/src/yb/integration-tests/xcluster/sql/temporary_objects.sql
+++ b/src/yb/integration-tests/xcluster/sql/temporary_objects.sql
@@ -16,9 +16,8 @@ DROP VIEW temp_view;
 DROP TABLE temp_table_for_view;
 
 -- Standalone sequences
--- Uncomment this as part of #24080
--- CREATE TEMP SEQUENCE temp_seq START 1;
--- DROP SEQUENCE temp_seq;
+CREATE TEMP SEQUENCE temp_seq START 1;
+DROP SEQUENCE temp_seq;
 
 -- Create a temp table with an temporary index
 CREATE TEMP TABLE temp_table3 (id INT, data TEXT);
@@ -28,17 +27,16 @@ DROP TABLE temp_table3;
 
 
 -- Sequences via SERIAL columns, defaults
--- Uncomment this as part of #24080
--- CREATE TEMP SEQUENCE myseq2;
--- CREATE TEMP SEQUENCE myseq3;
--- CREATE TEMP TABLE t1 (
---   f1 serial,
---   f2 int DEFAULT nextval('myseq2'),
---   f3 int DEFAULT nextval('myseq3'::text)
--- );
--- DROP SEQUENCE myseq3;
--- DROP TABLE t1;
--- DROP SEQUENCE myseq2;
+CREATE TEMP SEQUENCE myseq2;
+CREATE TEMP SEQUENCE myseq3;
+CREATE TEMP TABLE t1 (
+  f1 serial,
+  f2 int DEFAULT nextval('myseq2'),
+  f3 int DEFAULT nextval('myseq3'::text)
+);
+DROP SEQUENCE myseq3;
+DROP TABLE t1;
+DROP SEQUENCE myseq2;
 
 
 -- Create a temporary table with a column default
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc
index 14e93b1de2..ac2547b047 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc
@@ -60,6 +60,24 @@ class XClusterPgRegressDDLReplicationTest : public XClusterDDLReplicationTestBas
     return std::regex_replace(output, pattern, "\n<binary_upgrade_set_next>");
   }
 
+  void ExpectEqModuloSequenceValues(
+      const std::string& producer_dump, const std::string& consumer_dump) {
+    const std::regex pattern("\n.*SELECT pg_catalog.setval.*(?=\n)");
+
+    auto producer = std::regex_replace(producer_dump, pattern, "\n<setval>");
+    auto consumer = std::regex_replace(consumer_dump, pattern, "\n<setval>");
+
+    if (producer == consumer) {
+      return;
+    }
+
+    ADD_FAILURE()
+        << "Expected the ysql_dump's of both sides to be the same ignoring sequence states and "
+           "OIDs";
+    LOG(INFO) << "producer side dump: " << producer;
+    LOG(INFO) << "consumer side dump: " << consumer;
+  }
+
   Result<std::string> ReadEnumLabelInfo(Cluster& cluster) {
     return ReadEnumLabelInfo(cluster, namespace_name);
   }
@@ -68,10 +86,36 @@ class XClusterPgRegressDDLReplicationTest : public XClusterDDLReplicationTestBas
     auto conn = VERIFY_RESULT(cluster.ConnectToDB(database_name));
     return VERIFY_RESULT(conn.FetchAllAsString(
         "SELECT typname, enumlabel, pg_enum.oid, enumsortorder FROM pg_enum "
-        "JOIN pg_type ON pg_enum.enumtypid = pg_type.oid;",
+        "JOIN pg_type ON pg_enum.enumtypid = pg_type.oid ORDER BY typname, enumlabel ASC;",
         ", ", "\n"));
   }
 
+  Result<std::string> ReadSequenceOidInfo(Cluster& cluster) {
+    auto conn = VERIFY_RESULT(cluster.ConnectToDB(namespace_name));
+    return VERIFY_RESULT(conn.FetchAllAsString(
+        "SELECT pg_namespace.nspname, pg_class.relname, pg_class.oid "
+        "FROM pg_class "
+        "JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid "
+        "WHERE pg_class.relkind = 'S' "
+        "ORDER BY pg_namespace.nspname ASC, pg_class.relname ASC;",
+        ", ", "\n"));
+  }
+
+  void ExpectEqOidsNeedingPreservation(Cluster& consumer_cluster, Cluster& producer_cluster) {
+    // Enums pg_enum OIDs.
+    auto producer_enum_label_info = ASSERT_RESULT(ReadEnumLabelInfo(producer_cluster));
+    auto consumer_enum_label_info = ASSERT_RESULT(ReadEnumLabelInfo(consumer_cluster));
+    ASSERT_EQ(producer_enum_label_info, consumer_enum_label_info)
+        << "enum label OID information does not match";
+
+    // Sequence pg_class OIDs.
+    auto producer_sequence_info = ASSERT_RESULT(ReadSequenceOidInfo(producer_cluster));
+    auto consumer_sequence_info = ASSERT_RESULT(ReadSequenceOidInfo(consumer_cluster));
+    ASSERT_EQ(producer_sequence_info, consumer_sequence_info)
+        << "sequence OID information does not match";
+    LOG(INFO) << "Sequence pg_class OIDs on both sides are:\n" << producer_sequence_info;
+  }
+
   void ExecutePgFile(const std::string& file_path) { ExecutePgFile(file_path, namespace_name); }
 
   void ExecutePgFile(const std::string& file_path, const std::string& database_name) {
@@ -101,8 +145,8 @@ class XClusterPgRegressDDLReplicationTest : public XClusterDDLReplicationTestBas
 
     RETURN_NOT_OK(SetUpClusters());
 
-    // Perturb OIDs on consumer side to make sure we don't accidentally preserve OIDs.
-    auto conn = VERIFY_RESULT(consumer_cluster_.ConnectToDB(namespace_name));
+    // Perturb OIDs on producer side to make sure we don't accidentally preserve OIDs.
+    auto conn = VERIFY_RESULT(producer_cluster_.ConnectToDB(namespace_name));
     RETURN_NOT_OK(
         conn.Execute("CREATE TYPE gratuitous_enum AS ENUM ('red', 'orange', 'yellow', 'green', "
                      "'blue', 'purple');"));
@@ -130,7 +174,22 @@ class XClusterPgRegressDDLReplicationTest : public XClusterDDLReplicationTestBas
 
       auto producer_dump = VERIFY_RESULT(RunYSQLDump(producer_cluster_));
       auto consumer_dump = VERIFY_RESULT(RunYSQLDump(consumer_cluster_));
-      SCHECK_EQ(producer_dump, consumer_dump, IllegalState, "Ysqldumps do not match");
+
+      //
+      // Check for equivalence of the two sides in steps of increasing strictness
+      //
+
+      // First, do we just have the same objects in the two sides?
+      ExpectEqModuloSequenceValues(producer_dump, consumer_dump);
+
+      // Second, are the OIDs that we need to match the same on both sides?
+      ExpectEqOidsNeedingPreservation(producer_cluster_, consumer_cluster_);
+
+      // Finally, do the sequence states (e.g., current values) match as well?
+      SCHECK_EQ(
+          producer_dump, consumer_dump, IllegalState,
+          "Ysqldumps including sequence state do not match");
+
       // Ensure that the dump is not empty, should at least contain the extension.
       if (initial_dump.empty()) {
         initial_dump = producer_dump;
@@ -139,12 +198,6 @@ class XClusterPgRegressDDLReplicationTest : public XClusterDDLReplicationTestBas
         SCHECK_NE(
             initial_dump, producer_dump, IllegalState, "Ysqldumps after drops should not match");
       }
-
-      auto producer_enum_label_info = VERIFY_RESULT(ReadEnumLabelInfo(producer_cluster_));
-      auto consumer_enum_label_info = VERIFY_RESULT(ReadEnumLabelInfo(consumer_cluster_));
-      SCHECK_EQ(
-          producer_enum_label_info, consumer_enum_label_info, IllegalState,
-          "enum label information does not match");
     }
 
     return Status::OK();
@@ -234,4 +287,8 @@ TEST_F(XClusterPgRegressDDLReplicationTest, PgRegressCreateDropTemp) {
   ASSERT_EQ(num_replicated_ddls, "0");
 }
 
+TEST_F(XClusterPgRegressDDLReplicationTest, PgRegressCreateDropSequence) {
+  ASSERT_OK(TestPgRegress("create_sequence.sql", "drop_sequence.sql"));
+}
+
 }  // namespace yb
diff --git a/src/yb/tserver/xcluster_ddl_queue_handler.cc b/src/yb/tserver/xcluster_ddl_queue_handler.cc
index b9d256c544..96d3880797 100644
--- a/src/yb/tserver/xcluster_ddl_queue_handler.cc
+++ b/src/yb/tserver/xcluster_ddl_queue_handler.cc
@@ -78,6 +78,7 @@ const char* kDDLJsonNewRelMap = "new_rel_map";
 const char* kDDLJsonRelName = "rel_name";
 const char* kDDLJsonRelFileOid = "relfile_oid";
 const char* kDDLJsonEnumLabelInfo = "enum_label_info";
+const char* kDDLJsonSequenceInfo = "sequence_info";
 const char* kDDLJsonManualReplication = "manual_replication";
 const char* kDDLPrepStmtManualInsert = "manual_replication_insert";
 const char* kDDLPrepStmtAlreadyProcessed = "already_processed_row";
@@ -87,12 +88,15 @@ const std::unordered_set<std::string> kSupportedCommandTags {
     "CREATE TABLE",
     "CREATE INDEX",
     "CREATE TYPE",
+    "CREATE SEQUENCE",
     "DROP TABLE",
     "DROP INDEX",
     "DROP TYPE",
+    "DROP SEQUENCE",
     "ALTER TABLE",
     "ALTER INDEX",
     "ALTER TYPE",
+    "ALTER SEQUENCE",
     // Pass thru DDLs
     "CREATE ACCESS METHOD",
     "CREATE AGGREGATE",
@@ -310,6 +314,10 @@ Result<XClusterDDLQueueHandler::DDLQueryInfo> XClusterDDLQueueHandler::GetDDLQue
     writer.Key(kDDLJsonEnumLabelInfo);
     doc[kDDLJsonEnumLabelInfo].Accept(writer);
   }
+  if (HAS_MEMBER_OF_TYPE(doc, kDDLJsonSequenceInfo, IsArray)) {
+    writer.Key(kDDLJsonSequenceInfo);
+    doc[kDDLJsonSequenceInfo].Accept(writer);
+  }
   writer.EndObject();
   query_info.json_for_oid_assignment = assignment_buffer.GetString();
   return query_info;
