diff --git a/src/postgres/src/backend/bootstrap/bootstrap.c b/src/postgres/src/backend/bootstrap/bootstrap.c
index 63be15f008..86aee60f1d 100644
--- a/src/postgres/src/backend/bootstrap/bootstrap.c
+++ b/src/postgres/src/backend/bootstrap/bootstrap.c
@@ -525,11 +525,10 @@ BootstrapModeMain(void)
 		YBCCreateDatabase(TemplateDbOid,
 		                  "template1",
 		                  InvalidOid,
-		                  "template0",  
 		                  FirstBootstrapObjectId,
 		                  false /* colocated */,
 		                  NULL /* retry_on_oid_collision */,
-		                  0 /* clone_time */);
+		                  NULL /* yb_clone_info */);
 	}
 
 	/*
diff --git a/src/postgres/src/backend/commands/dbcommands.c b/src/postgres/src/backend/commands/dbcommands.c
index 384338e806..9bcdc11c61 100644
--- a/src/postgres/src/backend/commands/dbcommands.c
+++ b/src/postgres/src/backend/commands/dbcommands.c
@@ -616,6 +616,30 @@ createdb(ParseState *pstate, const CreatedbStmt *stmt)
 	 */
 	pg_database_rel = heap_open(DatabaseRelationId, RowExclusiveLock);
 
+	/*
+	 * CREATE DATABASE using templates other than template0 and template1 will 
+	 * always go through the DB clone workflow.
+	 */
+  bool is_clone = strcmp(dbtemplate, "template0") != 0 && strcmp(dbtemplate, "template1") != 0;
+  YbCloneInfo yb_clone_info = {
+    .clone_time = dbclonetime,
+    .src_db_name = dbtemplate,
+    .src_owner = is_clone ? GetUserNameFromId(src_owner, true /* noerr */) : NULL,
+    .tgt_owner = is_clone ? GetUserNameFromId(datdba, true /* noerr */) : NULL,
+  };
+  if (is_clone) {
+    if (!yb_clone_info.src_owner) {
+      ereport(ERROR,
+          (errcode(ERRCODE_UNDEFINED_OBJECT),
+          errmsg("Could not get source database owner name from oid")));
+    }
+    if (!yb_clone_info.tgt_owner) {
+      ereport(ERROR,
+          (errcode(ERRCODE_UNDEFINED_OBJECT),
+          errmsg("Could not get target database owner name from oid")));
+    }
+  }
+
 	/*
 	 * In vanilla PG, OIDs are assigned by a cluster-wide counter.
 	 * For YSQL, we allocate OIDs on a per-database level and share the
@@ -634,20 +658,18 @@ createdb(ParseState *pstate, const CreatedbStmt *stmt)
 		} while (check_db_file_conflict(dboid) || YbIsNormalDbOidReserved(dboid));
 
 		retry_on_oid_collision = false;
-		if (IsYugaByteEnabled())
-			YBCCreateDatabase(dboid, dbname, src_dboid, dbtemplate, InvalidOid, dbcolocated,
-							  &retry_on_oid_collision, dbclonetime);
+		if (IsYugaByteEnabled()) {
+			YBCCreateDatabase(dboid, dbname, src_dboid, /* next_oid */ InvalidOid,
+                dbcolocated, &retry_on_oid_collision, is_clone ? &yb_clone_info : NULL);
+    }
 	} while (retry_on_oid_collision);
 
 	/*
-	 * CREATE DATABASE using templates other than template0 and template1 will 
-	 * always go through the DB clone workflow.
 	 * A database created using the clone workflow already has an entry in
 	 * pg_database as it is created by executing ysql_dump script.
 	 * Thus, close pg_database relation and return the dboid in case of clone.
 	 */
-	if (strcmp(dbtemplate, "template0") != 0 &&
-		strcmp(dbtemplate, "template1") != 0)
+	if (is_clone)
 	{
 		heap_close(pg_database_rel, RowExclusiveLock);
 		// TODO(yamen): return the correct target dboid from the clone namespace.
diff --git a/src/postgres/src/backend/commands/ybccmds.c b/src/postgres/src/backend/commands/ybccmds.c
index 6ab2950624..bab19805eb 100644
--- a/src/postgres/src/backend/commands/ybccmds.c
+++ b/src/postgres/src/backend/commands/ybccmds.c
@@ -102,8 +102,8 @@ ColumnSortingOptions(SortByDir dir, SortByNulls nulls, bool* is_desc, bool* is_n
 /*  Database Functions. */
 
 void
-YBCCreateDatabase(Oid dboid, const char *dbname, Oid src_dboid, const char *src_dbname, Oid next_oid, bool colocated,
-				  bool *retry_on_oid_collision, int64 clone_time)
+YBCCreateDatabase(Oid dboid, const char *dbname, Oid src_dboid, Oid next_oid, bool colocated,
+				  bool *retry_on_oid_collision, YbCloneInfo *yb_clone_info)
 {
 	if (YBIsDBCatalogVersionMode())
 	{
@@ -125,10 +125,9 @@ YBCCreateDatabase(Oid dboid, const char *dbname, Oid src_dboid, const char *src_
 	HandleYBStatus(YBCPgNewCreateDatabase(dbname,
 										  dboid,
 										  src_dboid,
-										  src_dbname,
 										  next_oid,
 										  colocated,
-										  clone_time,
+										  yb_clone_info,
 										  &handle));
 
 	YBCStatus createdb_status = YBCPgExecCreateDatabase(handle);
diff --git a/src/postgres/src/include/commands/ybccmds.h b/src/postgres/src/include/commands/ybccmds.h
index ce0be94587..223549f3c4 100644
--- a/src/postgres/src/include/commands/ybccmds.h
+++ b/src/postgres/src/include/commands/ybccmds.h
@@ -37,8 +37,8 @@
 /*  Database Functions -------------------------------------------------------------------------- */
 
 extern void YBCCreateDatabase(
-	Oid dboid, const char *dbname, Oid src_dboid, const char *src_dbname, Oid next_oid,
-	bool colocated, bool *retry_on_oid_collision, int64 clone_time);
+	Oid dboid, const char *dbname, Oid src_dboid, Oid next_oid,
+	bool colocated, bool *retry_on_oid_collision, YbCloneInfo *yb_clone_info);
 
 extern void YBCDropDatabase(Oid dboid, const char *dbname);
 
diff --git a/src/yb/client/client.cc b/src/yb/client/client.cc
index 0a262ae46d..1edaf1d740 100644
--- a/src/yb/client/client.cc
+++ b/src/yb/client/client.cc
@@ -934,12 +934,12 @@ Status YBClient::CreateNamespace(const std::string& namespace_name,
                                  const TransactionMetadata* txn,
                                  const bool colocated,
                                  CoarseTimePoint deadline,
-                                 const std::optional<std::string> source_namespace_name,
-                                 std::optional<HybridTime> clone_time) {
-  // If source_namespace_name is template0 or template1 or not set, then initiate the typical create
-  // namespace request. Otherwise, initiate the clone request.
-  if (!source_namespace_name.has_value() || *source_namespace_name == "template0" ||
-      *source_namespace_name == "template1") {
+                                 std::optional<YbCloneInfo> yb_clone_info) {
+  if (yb_clone_info) {
+    RETURN_NOT_OK(CloneNamespace(
+        namespace_name, database_type ? database_type.value() : YQL_DATABASE_PGSQL,
+        *yb_clone_info));
+  } else {
     CreateNamespaceRequestPB req;
     CreateNamespaceResponsePB resp;
     req.set_name(namespace_name);
@@ -971,33 +971,32 @@ Status YBClient::CreateNamespace(const std::string& namespace_name,
     // the client can send operations without receiving a "namespace not found" error.
     RETURN_NOT_OK(data_->WaitForCreateNamespaceToFinish(
         this, namespace_name, database_type, cur_id, deadline));
-  } else {
-    RETURN_NOT_OK(CloneNamespace(
-        namespace_name, source_namespace_name.value(),
-        database_type ? database_type.value() : YQL_DATABASE_PGSQL, clone_time));
   }
   return Status::OK();
 }
 
 Status YBClient::CloneNamespace(const std::string& target_namespace_name,
-                                const std::string& source_namespace_name,
                                 const YQLDatabase& database_type,
-                                std::optional<HybridTime> clone_time) {
+                                YbCloneInfo& yb_clone_info) {
   LOG(INFO) << Format(
-      "Creating database $0 as clone of database $1", target_namespace_name, source_namespace_name);
+      "Creating database $0 as clone of database $1",
+      target_namespace_name, yb_clone_info.src_db_name);
   auto clone_deadline = ToCoarse(MonoTime::Now() + FLAGS_ysql_clone_pg_schema_rpc_timeout_ms * 1ms);
   master::CloneNamespaceRequestPB req;
   master::CloneNamespaceResponsePB resp;
   master::NamespaceIdentifierPB source_namespace;
-  source_namespace.set_name(source_namespace_name);
+  source_namespace.set_name(yb_clone_info.src_db_name);
   source_namespace.set_database_type(database_type);
   *req.mutable_source_namespace() = source_namespace;
-  if (!clone_time) {
-    // Clone as of current time
-    clone_time = HybridTime::FromMicros(VERIFY_RESULT(WallClock()->Now()).time_point);
+  if (yb_clone_info.clone_time == 0) {
+    // Clone as of current time.
+    yb_clone_info.clone_time = VERIFY_RESULT(WallClock()->Now()).time_point;
   }
-  req.set_restore_ht(clone_time->ToUint64());
+  req.set_restore_ht(HybridTime::FromMicros(yb_clone_info.clone_time).ToUint64());
   req.set_target_namespace_name(target_namespace_name);
+  req.set_pg_source_owner(yb_clone_info.src_owner);
+  req.set_pg_target_owner(yb_clone_info.tgt_owner);
+
   // Set clone_deadline to ysql_clone_pg_schema_rpc_timeout_ms to give time to clone pg schema
   // operation.
   RETURN_NOT_OK(data_->SyncLeaderMasterRpc(
diff --git a/src/yb/client/client.h b/src/yb/client/client.h
index b862b17efc..3e01b3576d 100644
--- a/src/yb/client/client.h
+++ b/src/yb/client/client.h
@@ -83,6 +83,8 @@
 #include "yb/util/strongly_typed_bool.h"
 #include "yb/util/threadpool.h"
 
+#include "yb/yql/pggate/ybc_pg_typedefs.h"
+
 template<class T> class scoped_refptr;
 
 namespace yb {
@@ -456,13 +458,11 @@ class YBClient {
                          const TransactionMetadata* txn = nullptr,
                          const bool colocated = false,
                          CoarseTimePoint deadline = CoarseTimePoint(),
-                         const std::optional<std::string> source_namespace_name = std::nullopt,
-                         std::optional<HybridTime> clone_time = std::nullopt);
+                         std::optional<YbCloneInfo> yb_clone_info = std::nullopt);
 
   Status CloneNamespace(const std::string& target_namespace_name,
-                        const std::string& source_namespace_name,
                         const YQLDatabase& database_type,
-                        std::optional<HybridTime> clone_time);
+                        YbCloneInfo& yb_clone_info);
 
   // It calls CreateNamespace(), but before it checks that the namespace has NOT been yet
   // created. So, it prevents error 'namespace already exists'.
diff --git a/src/yb/integration-tests/minicluster-snapshot-test.cc b/src/yb/integration-tests/minicluster-snapshot-test.cc
index c79280b93a..7dce7f000c 100644
--- a/src/yb/integration-tests/minicluster-snapshot-test.cc
+++ b/src/yb/integration-tests/minicluster-snapshot-test.cc
@@ -699,5 +699,21 @@ TEST_F(PgCloneTest, YB_DISABLE_TEST_IN_SANITIZERS(CloneAfterDropTable)) {
   ASSERT_EQ(row, kRows[0]);
 }
 
+TEST_F(PgCloneTest, YB_DISABLE_TEST_IN_SANITIZERS(UserIsSet)) {
+  // Test that the user is set to the user running the clone operation.
+  ASSERT_OK(source_conn_->Execute("CREATE ROLE test_user WITH LOGIN PASSWORD 'test'"));
+  ASSERT_OK(source_conn_->Execute("ALTER ROLE test_user SUPERUSER"));
+  ASSERT_OK(source_conn_->Execute("SET ROLE test_user"));
+  ASSERT_OK(source_conn_->ExecuteFormat(
+      "CREATE DATABASE $0 TEMPLATE $1", kTargetNamespaceName1, kSourceNamespaceName));
+
+  auto owner_query = Format(
+      "SELECT pg_get_userbyid(datdba) FROM pg_database WHERE datname = '$0'",
+      kTargetNamespaceName1);
+  auto owner = ASSERT_RESULT(source_conn_->FetchRows<std::string>(owner_query));
+  ASSERT_EQ(owner.size(), 1);
+  ASSERT_EQ(owner[0], "test_user");
+}
+
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/async_rpc_tasks.cc b/src/yb/master/async_rpc_tasks.cc
index af86a2b3a3..eec08d07f9 100644
--- a/src/yb/master/async_rpc_tasks.cc
+++ b/src/yb/master/async_rpc_tasks.cc
@@ -1990,11 +1990,14 @@ bool AsyncCloneTablet::SendRequest(int attempt) {
 AsyncClonePgSchema::AsyncClonePgSchema(
     Master* master, ThreadPool* callback_pool, const std::string& permanent_uuid,
     const std::string& source_db_name, const std::string& target_db_name, HybridTime restore_ht,
+    const std::string& source_owner, const std::string& target_owner,
     ClonePgSchemaCallbackType callback, MonoTime deadline)
     : RetrySpecificTSRpcTask(
           master, callback_pool, std::move(permanent_uuid), /* async_task_throttler */ nullptr),
       source_db_name_(source_db_name),
-      target_db_name(target_db_name),
+      target_db_name_(target_db_name),
+      source_owner_(source_owner),
+      target_owner_(target_owner),
       restore_ht_(restore_ht),
       callback_(callback) {
   deadline_ = deadline;  // Time out according to earliest(deadline_,
@@ -2020,7 +2023,9 @@ void AsyncClonePgSchema::HandleResponse(int attempt) {
 bool AsyncClonePgSchema::SendRequest(int attempt) {
   tserver::ClonePgSchemaRequestPB req;
   req.set_source_db_name(source_db_name_);
-  req.set_target_db_name(target_db_name);
+  req.set_target_db_name(target_db_name_);
+  req.set_source_owner(source_owner_);
+  req.set_target_owner(target_owner_);
   req.set_restore_ht(restore_ht_.ToUint64());
   ts_admin_proxy_->ClonePgSchemaAsync(req, &resp_, &rpc_, BindRpcCallback());
   VLOG_WITH_PREFIX(1) << "Sent clone tablets request to " << tablet_id();
diff --git a/src/yb/master/async_rpc_tasks.h b/src/yb/master/async_rpc_tasks.h
index dd3eab2b4a..1580d52624 100644
--- a/src/yb/master/async_rpc_tasks.h
+++ b/src/yb/master/async_rpc_tasks.h
@@ -1068,6 +1068,7 @@ class AsyncClonePgSchema : public RetrySpecificTSRpcTask {
   AsyncClonePgSchema(
       Master* master, ThreadPool* callback_pool, const std::string& permanent_uuid,
       const std::string& source_db_name, const std::string& target_db_name, HybridTime restore_time,
+      const std::string& source_owner, const std::string& target_owner,
       ClonePgSchemaCallbackType callback, MonoTime deadline);
 
   server::MonitoredTaskType type() const override {
@@ -1087,7 +1088,9 @@ class AsyncClonePgSchema : public RetrySpecificTSRpcTask {
 
  private:
   std::string source_db_name_;
-  std::string target_db_name;
+  std::string target_db_name_;
+  std::string source_owner_;
+  std::string target_owner_;
   HybridTime restore_ht_;
   tserver::ClonePgSchemaResponsePB resp_;
   ClonePgSchemaCallbackType callback_;
diff --git a/src/yb/master/clone/clone_state_manager-test.cc b/src/yb/master/clone/clone_state_manager-test.cc
index 52f95591ff..6b952a8f79 100644
--- a/src/yb/master/clone/clone_state_manager-test.cc
+++ b/src/yb/master/clone/clone_state_manager-test.cc
@@ -108,7 +108,8 @@ class CloneStateManagerTest : public YBTest {
     MOCK_METHOD(
         Status, ScheduleClonePgSchemaTask,
         (const std::string& permanent_uuid, const std::string& source_db_name,
-         const std::string& target_db_name, HybridTime restore_ht,
+         const std::string& target_db_name, const std::string& source_owner,
+         const std::string& target_owner, HybridTime restore_ht,
          AsyncClonePgSchema::ClonePgSchemaCallbackType callback, MonoTime deadline), (override));
 
     MOCK_METHOD(
@@ -296,7 +297,8 @@ class CloneStateManagerTest : public YBTest {
       CoarseTimePoint deadline,
       const LeaderEpoch& epoch) {
     return clone_state_manager_->CloneNamespace(
-        source_namespace_identifier, restore_time, target_namespace_name, deadline, epoch);
+        source_namespace_identifier, restore_time, target_namespace_name, "" /* pg_source_owner */,
+        "" /* pg_target_owner */, deadline, epoch);
   }
 
   AsyncClonePgSchema::ClonePgSchemaCallbackType MakeDoneClonePgSchemaCallback(
diff --git a/src/yb/master/clone/clone_state_manager.cc b/src/yb/master/clone/clone_state_manager.cc
index 2baaf5add9..5c14344b56 100644
--- a/src/yb/master/clone/clone_state_manager.cc
+++ b/src/yb/master/clone/clone_state_manager.cc
@@ -109,11 +109,12 @@ class CloneStateManagerExternalFunctions : public CloneStateManagerExternalFunct
 
   Status ScheduleClonePgSchemaTask(
       const TabletServerId& ts_uuid, const std::string& source_db_name,
-      const std::string& target_db_name, HybridTime restore_ht,
+      const std::string& target_db_name, const std::string& pg_source_owner,
+      const std::string& pg_target_owner, HybridTime restore_ht,
       AsyncClonePgSchema::ClonePgSchemaCallbackType callback, MonoTime deadline) override {
     auto task = std::make_shared<AsyncClonePgSchema>(
         master_, catalog_manager_->AsyncTaskPool(), ts_uuid, source_db_name,
-        target_db_name, restore_ht, callback, deadline);
+        target_db_name, restore_ht, pg_source_owner, pg_target_owner, callback, deadline);
     return catalog_manager_->ScheduleTask(task);
   }
 
@@ -212,7 +213,12 @@ Status CloneStateManager::CloneNamespace(
   LOG(INFO) << "Servicing CloneNamespace request: " << req->ShortDebugString();
   auto restore_time = HybridTime(req->restore_ht());
   auto [source_namespace_id, seq_no] = VERIFY_RESULT(CloneNamespace(
-      req->source_namespace(), restore_time, req->target_namespace_name(), rpc->GetClientDeadline(),
+      req->source_namespace(),
+      restore_time,
+      req->target_namespace_name(),
+      req->pg_source_owner(),
+      req->pg_target_owner(),
+      rpc->GetClientDeadline(),
       epoch));
   resp->set_source_namespace_id(source_namespace_id);
   resp->set_seq_no(seq_no);
@@ -223,6 +229,8 @@ Result<std::pair<NamespaceId, uint32_t>> CloneStateManager::CloneNamespace(
     const NamespaceIdentifierPB& source_namespace_identifier,
     const HybridTime& restore_time,
     const std::string& target_namespace_name,
+    const std::string& pg_source_owner,
+    const std::string& pg_target_owner,
     CoarseTimePoint deadline,
     const LeaderEpoch& epoch) {
   if (!FLAGS_enable_db_clone) {
@@ -266,8 +274,8 @@ Result<std::pair<NamespaceId, uint32_t>> CloneStateManager::CloneNamespace(
   Status status;
   if (source_namespace->database_type() == YQL_DATABASE_PGSQL) {
     status = ClonePgSchemaObjects(
-        clone_state, source_namespace->name(), target_namespace_name, snapshot_schedule_id,
-        epoch);
+        clone_state, source_namespace->name(), target_namespace_name, pg_source_owner,
+        pg_target_owner, snapshot_schedule_id, epoch);
   } else {
     // For YCQL, start tablets cloning directly.
     status = StartTabletsCloning(
@@ -342,6 +350,8 @@ Status CloneStateManager::ClonePgSchemaObjects(
     CloneStateInfoPtr clone_state,
     const std::string& source_db_name,
     const std::string& target_db_name,
+    const std::string& pg_source_owner,
+    const std::string& pg_target_owner,
     const SnapshotScheduleId& snapshot_schedule_id,
     const LeaderEpoch& epoch) {
   if (FLAGS_TEST_fail_clone_pg_schema) {
@@ -354,7 +364,7 @@ Status CloneStateManager::ClonePgSchemaObjects(
   // Deadline passed to the ClonePgSchemaTask (including rpc time and callback execution deadline)
   auto deadline = MonoTime::Now() + FLAGS_ysql_clone_pg_schema_rpc_timeout_ms * 1ms;
   RETURN_NOT_OK(external_funcs_->ScheduleClonePgSchemaTask(
-      ts_permanent_uuid, source_db_name, target_db_name,
+      ts_permanent_uuid, source_db_name, target_db_name, pg_source_owner, pg_target_owner,
       HybridTime(clone_state->LockForRead()->pb.restore_time()),
       MakeDoneClonePgSchemaCallback(
           clone_state, snapshot_schedule_id, target_db_name, ToCoarse(deadline),
diff --git a/src/yb/master/clone/clone_state_manager.h b/src/yb/master/clone/clone_state_manager.h
index b8405d7b85..59c961efb9 100644
--- a/src/yb/master/clone/clone_state_manager.h
+++ b/src/yb/master/clone/clone_state_manager.h
@@ -60,6 +60,8 @@ class CloneStateManager {
     const NamespaceIdentifierPB& source_namespace,
     const HybridTime& read_time,
     const std::string& target_namespace_name,
+    const std::string& pg_source_owner,
+    const std::string& pg_target_owner,
     CoarseTimePoint deadline,
     const LeaderEpoch& epoch);
 
@@ -75,8 +77,12 @@ class CloneStateManager {
 
   // Create PG schema objects of the clone database.
   Status ClonePgSchemaObjects(
-      CloneStateInfoPtr clone_state, const std::string& source_db_name,
-      const std::string& target_db_name, const SnapshotScheduleId& snapshot_schedule_id,
+      CloneStateInfoPtr clone_state,
+      const std::string& source_db_name,
+      const std::string& target_db_name,
+      const std::string& pg_source_owner,
+      const std::string& pg_target_owner,
+      const SnapshotScheduleId& snapshot_schedule_id,
       const LeaderEpoch& epoch);
 
   // Starts snapshot related operations for clone (mainly generate snapshotInfoPB as of
diff --git a/src/yb/master/clone/external_functions.h b/src/yb/master/clone/external_functions.h
index d1b82a6b4c..fa6fc8093d 100644
--- a/src/yb/master/clone/external_functions.h
+++ b/src/yb/master/clone/external_functions.h
@@ -52,9 +52,14 @@ class CloneStateManagerExternalFunctionsBase {
       const TabletInfoPtr&, LeaderEpoch, tablet::CloneTabletRequestPB) = 0;
 
   virtual Status ScheduleClonePgSchemaTask(
-      const std::string& permanent_uuid, const std::string& source_db_name,
-      const std::string& target_db_name, HybridTime restore_ht,
-      AsyncClonePgSchema::ClonePgSchemaCallbackType callback, MonoTime deadline) = 0;
+      const std::string& permanent_uuid,
+      const std::string& source_db_name,
+      const std::string& target_db_name,
+      const std::string& source_owner,
+      const std::string& target_owner,
+      HybridTime restore_ht,
+      AsyncClonePgSchema::ClonePgSchemaCallbackType callback,
+      MonoTime deadline) = 0;
 
   virtual Status DoCreateSnapshot(
       const CreateSnapshotRequestPB* req, CreateSnapshotResponsePB* resp,
diff --git a/src/yb/master/master_backup.proto b/src/yb/master/master_backup.proto
index 60511fb5f9..e3a38c3a25 100644
--- a/src/yb/master/master_backup.proto
+++ b/src/yb/master/master_backup.proto
@@ -277,6 +277,8 @@ message CloneNamespaceRequestPB {
   optional NamespaceIdentifierPB source_namespace = 1;
   optional fixed64 restore_ht = 2;
   optional string target_namespace_name = 3;
+  optional string pg_source_owner = 4;
+  optional string pg_target_owner = 5;
 }
 
 message CloneNamespaceResponsePB {
diff --git a/src/yb/tserver/pg_client.proto b/src/yb/tserver/pg_client.proto
index 6366cc6edd..da594418ca 100644
--- a/src/yb/tserver/pg_client.proto
+++ b/src/yb/tserver/pg_client.proto
@@ -224,6 +224,8 @@ message PgCreateDatabaseRequestPB {
   bool colocated = 7;
   fixed64 clone_time = 8;
   string source_database_name = 9;
+  string source_owner = 10;
+  string target_owner = 11;
 }
 
 message PgCreateDatabaseResponsePB {
diff --git a/src/yb/tserver/pg_client_session.cc b/src/yb/tserver/pg_client_session.cc
index a318cfc3f6..1d95d3a29b 100644
--- a/src/yb/tserver/pg_client_session.cc
+++ b/src/yb/tserver/pg_client_session.cc
@@ -635,9 +635,18 @@ Status PgClientSession::CreateTable(
 Status PgClientSession::CreateDatabase(
     const PgCreateDatabaseRequestPB& req, PgCreateDatabaseResponsePB* resp,
     rpc::RpcContext* context) {
-  std::optional<HybridTime> clone_time;
-  if (req.clone_time() != 0) {
-    clone_time = HybridTime::FromMicros(req.clone_time());
+  bool is_clone =
+      req.source_database_name() != "" &&
+      req.source_database_name() != "template0" &&
+      req.source_database_name() != "template1";
+  std::optional<YbCloneInfo> yb_clone_info = std::nullopt;
+  if (is_clone) {
+    yb_clone_info = YbCloneInfo {
+      .clone_time = req.clone_time(),
+      .src_db_name = req.source_database_name().c_str(),
+      .src_owner = req.source_owner().c_str(),
+      .tgt_owner = req.target_owner().c_str(),
+    };
   }
   return client().CreateNamespace(
       req.database_name(), YQL_DATABASE_PGSQL, "" /* creator_role_name */,
@@ -646,7 +655,7 @@ Status PgClientSession::CreateDatabase(
                                                  : "",
       req.next_oid(),
       VERIFY_RESULT(GetDdlTransactionMetadata(req.use_transaction(), context->GetClientDeadline())),
-      req.colocated(), context->GetClientDeadline(), req.source_database_name(), clone_time);
+      req.colocated(), context->GetClientDeadline(), yb_clone_info);
 }
 
 Status PgClientSession::DropDatabase(
diff --git a/src/yb/tserver/tablet_service.cc b/src/yb/tserver/tablet_service.cc
index 906ab9f93e..7cf9889856 100644
--- a/src/yb/tserver/tablet_service.cc
+++ b/src/yb/tserver/tablet_service.cc
@@ -1965,9 +1965,6 @@ void TabletServiceAdminImpl::ClonePgSchema(
 Status TabletServiceAdminImpl::DoClonePgSchema(
     const ClonePgSchemaRequestPB* req, ClonePgSchemaResponsePB* resp) {
   // Run ysql_dump to generate the schema of the clone database as of restore time.
-  auto restore_time = HybridTime(req->restore_ht());
-  std::string timestamp_flag =
-      "--read-time=" + std::to_string(restore_time.GetPhysicalValueMicros());
   HostPort local_pg_host_port;
   if (!FLAGS_TEST_mini_cluster_pg_host_port.empty()) {
     RETURN_NOT_OK(local_pg_host_port.ParseString(
@@ -1978,19 +1975,21 @@ Status TabletServiceAdminImpl::DoClonePgSchema(
   const std::string& target_db_name = req->target_db_name();
   std::string unix_domain_socket = PgDeriveSocketDir(local_pg_host_port);
   HostPort local_hostport(unix_domain_socket, local_pg_host_port.port());
+
   YsqlDumpRunner ysql_dump_runner =
       VERIFY_RESULT(YsqlDumpRunner::GetYsqlDumpRunner(local_hostport));
-  std::string dump_output =
-      VERIFY_RESULT(ysql_dump_runner.DumpSchemaAsOfTime(req->source_db_name(), restore_time));
-  std::string modified_dump_script =
-      ysql_dump_runner.ModifyDBNameInScript(dump_output, target_db_name);
-  // Write the modified dump output to a file in order to execute it using ysqlsh
+  std::string dump_output = VERIFY_RESULT(ysql_dump_runner.RunAndModifyForClone(
+      req->source_db_name(), target_db_name, req->source_owner(), req->target_owner(),
+      HybridTime(req->restore_ht())));
+  VLOG(2) << "Dump output: " << dump_output;
+
+  // Write the dump output to a file in order to execute it using ysqlsh.
   std::unique_ptr<WritableFile> dump_output_file;
   std::string tmp_file_name;
   RETURN_NOT_OK(Env::Default()->NewTempWritableFile(
       WritableFileOptions(), target_db_name + "_ysql_dump_XXXXXX", &tmp_file_name,
       &dump_output_file));
-  RETURN_NOT_OK(dump_output_file->Append(modified_dump_script));
+  RETURN_NOT_OK(dump_output_file->Append(dump_output));
   RETURN_NOT_OK(dump_output_file->Close());
   auto scope_exit = ScopeExit([tmp_file_name] {
     if (Env::Default()->FileExists(tmp_file_name)) {
@@ -1999,7 +1998,8 @@ Status TabletServiceAdminImpl::DoClonePgSchema(
           Format("Failed to delete ysql_dump_file $0 as a cloning cleanup.", tmp_file_name));
     }
   });
-  // Execute the sql script to generate the PG database
+
+  // Execute the sql script to generate the PG database.
   YsqlshRunner ysqlsh_runner =
       VERIFY_RESULT(YsqlshRunner::GetYsqlshRunner(HostPort::FromPB(local_hostport)));
   Result<std::string> ysqlsh_output = VERIFY_RESULT(ysqlsh_runner.ExecuteSqlScript(tmp_file_name));
diff --git a/src/yb/tserver/tserver_admin.proto b/src/yb/tserver/tserver_admin.proto
index fba812a284..8e88347dc3 100644
--- a/src/yb/tserver/tserver_admin.proto
+++ b/src/yb/tserver/tserver_admin.proto
@@ -350,6 +350,8 @@ message ClonePgSchemaRequestPB {
   optional bytes source_db_name = 1;
   optional bytes target_db_name = 2;
   optional fixed64 restore_ht = 3;
+  optional bytes source_owner = 4;
+  optional bytes target_owner = 5;
 }
 
 message ClonePgSchemaResponsePB{
diff --git a/src/yb/util/ysql_binary_runner.cc b/src/yb/util/ysql_binary_runner.cc
index c20c7f080b..44430504a6 100644
--- a/src/yb/util/ysql_binary_runner.cc
+++ b/src/yb/util/ysql_binary_runner.cc
@@ -52,6 +52,25 @@ Result<std::string> YsqlDumpRunner::DumpSchemaAsOfTime(
   return Run(args);
 }
 
+Result<std::string> YsqlDumpRunner::RunAndModifyForClone(
+    const std::string& source_db_name, const std::string& target_db_name,
+    const std::string& source_owner, const std::string& target_owner,
+    const HybridTime& restore_time) {
+  const auto dump_output = VERIFY_RESULT(DumpSchemaAsOfTime(source_db_name, restore_time));
+
+  // Used to set the owner of the created database.
+  const boost::regex source_owner_re = boost::regex("OWNER TO " + source_owner);
+  const std::string alter_owner = "OWNER TO " + target_owner;
+
+  std::istringstream input_script_stream(dump_output);
+  std::string line;
+  std::stringstream modified_dump;
+  while (std::getline(input_script_stream, line)) {
+    modified_dump << ModifyLine(line, target_db_name, source_owner_re, alter_owner) << std::endl;
+  }
+  return modified_dump.str();
+}
+
 namespace {
 const boost::regex QUOTED_DATABASE_RE("^(.*)\\s+DATABASE\\s+\"(.+)\"\\s+(.*)$");
 const boost::regex UNQUOTED_DATABASE_RE("(^.*)\\s+DATABASE\\s+(\\S+)\\s+(.*)$");
@@ -60,43 +79,29 @@ const boost::regex UNQUOTED_CONNECT_RE("^\\\\connect\\s+(\\S+)$");
 const boost::regex TABLESPACE_RE("^\\s*SET\\s+default_tablespace\\s*=.*$");
 }  // namespace
 
-std::string YsqlDumpRunner::Replace(
-    std::string& line, const std::string& new_db, bool unset_tablespaces) {
+std::string YsqlDumpRunner::ModifyLine(
+    const std::string& line, const std::string& new_db, const boost::regex& owner_regex,
+    const std::string& alter_owner) {
+  std::string modified_line = boost::regex_replace(line, owner_regex, alter_owner);
   std::vector<std::string> values;
-  if (boost::regex_split(std::back_inserter(values), line, QUOTED_DATABASE_RE)) {
+  if (boost::regex_split(std::back_inserter(values), modified_line, QUOTED_DATABASE_RE)) {
     return values[0] + " DATABASE \"" + new_db + "\" " + values[2];
   }
   values.clear();
-  if (boost::regex_split(std::back_inserter(values), line, UNQUOTED_DATABASE_RE)) {
+  if (boost::regex_split(std::back_inserter(values), modified_line, UNQUOTED_DATABASE_RE)) {
     return values[0] + " DATABASE \"" + new_db + "\" " + values[2];
   }
   values.clear();
-  if (boost::regex_split(std::back_inserter(values), line, QUOTED_CONNECT_RE)) {
+  if (boost::regex_split(std::back_inserter(values), modified_line, QUOTED_CONNECT_RE)) {
     std::string s = boost::replace_all_copy(new_db, "'", "\\'");
     return "\\connect -reuse-previous=on \"dbname='" + s + "'\"";
   }
   values.clear();
-  if (boost::regex_split(std::back_inserter(values), line, UNQUOTED_CONNECT_RE)) {
+  if (boost::regex_split(std::back_inserter(values), modified_line, UNQUOTED_CONNECT_RE)) {
     std::string s = boost::replace_all_copy(new_db, "'", "\\'");
     return "\\connect -reuse-previous=on \"dbname='" + s + "'\"";
   }
-  values.clear();
-  if (unset_tablespaces && boost::regex_match(line.begin(), line.end(), TABLESPACE_RE)) {
-    return "SET default_tablespace = '';";
-  }
-  return line;
-}
-
-std::string YsqlDumpRunner::ModifyDBNameInScript(
-    const std::string& sql_dump_script, const std::string& new_db_name, bool unset_tablespaces) {
-  std::istringstream input_script_stream(sql_dump_script);
-  std::string line;
-  std::string modified_output_script;
-  while (std::getline(input_script_stream, line)) {
-    line = Replace(line, new_db_name, unset_tablespaces);
-    modified_output_script += line + "\n";
-  }
-  return modified_output_script;
+  return modified_line;
 }
 
 // ============================================================================
diff --git a/src/yb/util/ysql_binary_runner.h b/src/yb/util/ysql_binary_runner.h
index 5cefda7d93..60196512d5 100644
--- a/src/yb/util/ysql_binary_runner.h
+++ b/src/yb/util/ysql_binary_runner.h
@@ -42,18 +42,22 @@ class YsqlDumpRunner : public YsqlBinaryRunner {
     std::string tool_path = VERIFY_RESULT(path_utils::GetPgToolPath("ysql_dump"));
     return YsqlDumpRunner(tool_path, pg_host_port);
   }
+
   Result<std::string> DumpSchemaAsOfTime(
       const std::string& db_name, const HybridTime& restore_time);
-  // Change the database name to new_db_name inside sql_dump_script. The change happens in place.
-  std::string ModifyDBNameInScript(
-      const std::string& sql_dump_script, const std::string& new_db_name,
-      bool unset_tablespaces = true);
+
+  Result<std::string> RunAndModifyForClone(
+    const std::string& source_db_name, const std::string& target_db_name,
+    const std::string& source_owner, const std::string& target_owner,
+    const HybridTime& restore_time);
 
  private:
   YsqlDumpRunner(std::string tool_path, HostPort pg_host_port)
       : YsqlBinaryRunner(tool_path, pg_host_port) {}
-  // Utility methods used for replacing the DB name in the dump output (Used for cloning)
-  std::string Replace(std::string& src, const std::string& new_db, bool unset_tablespaces);
+
+  std::string ModifyLine(
+      const std::string& line, const std::string& new_db, const boost::regex& source_owner_re,
+      const std::string& alter_owner);
 };
 
 class YsqlshRunner : public YsqlBinaryRunner {
diff --git a/src/yb/yql/pggate/pg_ddl.cc b/src/yb/yql/pggate/pg_ddl.cc
index ef2e9e78e0..c63241ec7d 100644
--- a/src/yb/yql/pggate/pg_ddl.cc
+++ b/src/yb/yql/pggate/pg_ddl.cc
@@ -73,18 +73,21 @@ PgCreateDatabase::PgCreateDatabase(PgSession::ScopedRefPtr pg_session,
                                    const char *database_name,
                                    const PgOid database_oid,
                                    const PgOid source_database_oid,
-                                   const char* source_database_name,
                                    const PgOid next_oid,
-                                   const int64_t clone_time,
+                                   YbCloneInfo *yb_clone_info,
                                    const bool colocated)
     : PgDdl(std::move(pg_session)) {
   req_.set_database_name(database_name);
   req_.set_database_oid(database_oid);
   req_.set_source_database_oid(source_database_oid);
-  req_.set_source_database_name(source_database_name);
   req_.set_next_oid(next_oid);
   req_.set_colocated(colocated);
-  req_.set_clone_time(clone_time);
+  if (yb_clone_info) {
+    req_.set_source_database_name(yb_clone_info->src_db_name);
+    req_.set_clone_time(yb_clone_info->clone_time);
+    req_.set_source_owner(yb_clone_info->src_owner);
+    req_.set_target_owner(yb_clone_info->tgt_owner);
+  }
 }
 
 PgCreateDatabase::~PgCreateDatabase() {
diff --git a/src/yb/yql/pggate/pg_ddl.h b/src/yb/yql/pggate/pg_ddl.h
index 930a3125b0..3da538e9a0 100644
--- a/src/yb/yql/pggate/pg_ddl.h
+++ b/src/yb/yql/pggate/pg_ddl.h
@@ -40,9 +40,8 @@ class PgCreateDatabase : public PgDdl {
                    const char *database_name,
                    PgOid database_oid,
                    PgOid source_database_oid,
-                   const char* source_database_name,
                    PgOid next_oid,
-                   const int64_t clone_time,
+                   YbCloneInfo *yb_clone_info,
                    const bool colocated);
   virtual ~PgCreateDatabase();
 
diff --git a/src/yb/yql/pggate/pggate.cc b/src/yb/yql/pggate/pggate.cc
index 63f6a88195..05aa6a479a 100644
--- a/src/yb/yql/pggate/pggate.cc
+++ b/src/yb/yql/pggate/pggate.cc
@@ -751,11 +751,10 @@ Status PgApiImpl::IsDatabaseColocated(const PgOid database_oid, bool *colocated,
 
 Status PgApiImpl::NewCreateDatabase(
     const char* database_name, const PgOid database_oid, const PgOid source_database_oid,
-    const char* source_database_name, const PgOid next_oid, const bool colocated,
-    const int64_t clone_time, PgStatement** handle) {
+    const PgOid next_oid, const bool colocated, YbCloneInfo *yb_clone_info, PgStatement** handle) {
   auto stmt = std::make_unique<PgCreateDatabase>(
-      pg_session_, database_name, database_oid, source_database_oid, source_database_name, next_oid,
-      clone_time, colocated);
+      pg_session_, database_name, database_oid, source_database_oid, next_oid,
+      yb_clone_info, colocated);
   if (pg_txn_manager_->IsDdlMode()) {
     stmt->UseTransaction();
   }
diff --git a/src/yb/yql/pggate/pggate.h b/src/yb/yql/pggate/pggate.h
index 765030b028..195b9fee3c 100644
--- a/src/yb/yql/pggate/pggate.h
+++ b/src/yb/yql/pggate/pggate.h
@@ -241,10 +241,9 @@ class PgApiImpl {
   Status NewCreateDatabase(const char *database_name,
                            PgOid database_oid,
                            PgOid source_database_oid,
-                           const char *source_database_name,
                            PgOid next_oid,
                            const bool colocated,
-                           const int64_t clone_time,
+                           YbCloneInfo *yb_clone_info,
                            PgStatement **handle);
   Status ExecCreateDatabase(PgStatement *handle);
 
diff --git a/src/yb/yql/pggate/test/pggate_test.cc b/src/yb/yql/pggate/test/pggate_test.cc
index feb9dd54f1..b35e90ad55 100644
--- a/src/yb/yql/pggate/test/pggate_test.cc
+++ b/src/yb/yql/pggate/test/pggate_test.cc
@@ -218,8 +218,7 @@ void PggateTest::CreateDB(const string& db_name, const YBCPgOid db_oid) {
   YBCPgStatement pg_stmt;
   CHECK_YBC_STATUS(YBCPgNewCreateDatabase(
       db_name.c_str(), db_oid, 0 /* source_database_oid */,
-      kDefaultTemplateDatabaseName /* source_database_name */, 0 /* next_oid */,
-      false /* colocated */, 0 /* clone_time*/, &pg_stmt));
+      0 /* next_oid */, false /* colocated */, NULL /* yb_clone_info */, &pg_stmt));
   CHECK_YBC_STATUS(YBCPgExecCreateDatabase(pg_stmt));
 }
 
diff --git a/src/yb/yql/pggate/test/pggate_test_catalog.cc b/src/yb/yql/pggate/test/pggate_test_catalog.cc
index 4c227530ed..1690bad16e 100644
--- a/src/yb/yql/pggate/test/pggate_test_catalog.cc
+++ b/src/yb/yql/pggate/test/pggate_test_catalog.cc
@@ -449,8 +449,8 @@ TEST_F(PggateTestCatalog, TestCopydb) {
   // COPYDB ----------------------------------------------------------------------------------------
   LOG(INFO) << "Create another database from default database";
   CHECK_YBC_STATUS(YBCPgNewCreateDatabase(
-      copy_db_name, copy_db_oid, kDefaultDatabaseOid, kDefaultTemplateDatabaseName,
-      kInvalidOid /* next_oid */, false /* colocated */, 0 /* clone_time*/, &pg_stmt));
+      copy_db_name, copy_db_oid, kDefaultDatabaseOid,
+      kInvalidOid /* next_oid */, false /* colocated */, NULL /* yb_clone_info */, &pg_stmt));
   CHECK_YBC_STATUS(YBCPgExecCreateDatabase(pg_stmt));
   // Fresh state of cache must be read after new DB creation.
   YBCPgResetCatalogReadTime();
@@ -500,8 +500,8 @@ TEST_F(PggateTestCatalog, TestReserveOids) {
   YBCPgStatement pg_stmt;
 
   CHECK_YBC_STATUS(YBCPgNewCreateDatabase(
-      db_name, db_oid, kInvalidOid /* source_database_oid */, kDefaultTemplateDatabaseName,
-      100 /* next_oid */, false /* colocated */, 0 /* clone_time*/, &pg_stmt));
+      db_name, db_oid, kInvalidOid /* source_database_oid */,
+      100 /* next_oid */, false /* colocated */, NULL /* yb_clone_info */, &pg_stmt));
   CHECK_YBC_STATUS(YBCPgExecCreateDatabase(pg_stmt));
   pg_stmt = nullptr;
 
diff --git a/src/yb/yql/pggate/ybc_pg_typedefs.h b/src/yb/yql/pggate/ybc_pg_typedefs.h
index 1bfc91fd7d..e381c9263c 100644
--- a/src/yb/yql/pggate/ybc_pg_typedefs.h
+++ b/src/yb/yql/pggate/ybc_pg_typedefs.h
@@ -783,6 +783,14 @@ typedef enum PgYbrowidMode {
 // kPgSequencesDataTableOid (defined in entity_ids.h).
 static const YBCPgOid kYBCPgSequencesDataDatabaseOid = 65535;
 
+typedef struct YbCloneInfo {
+  // The clone time in microseconds since the unix epoch (not a hybrid time).
+  uint64_t clone_time;
+  const char* src_db_name;
+  const char* src_owner;
+  const char* tgt_owner;
+} YbCloneInfo;
+
 #ifdef __cplusplus
 }  // extern "C"
 #endif  // __cplusplus
diff --git a/src/yb/yql/pggate/ybc_pggate.cc b/src/yb/yql/pggate/ybc_pggate.cc
index daec1e3946..b82e7345c2 100644
--- a/src/yb/yql/pggate/ybc_pggate.cc
+++ b/src/yb/yql/pggate/ybc_pggate.cc
@@ -748,11 +748,11 @@ YBCStatus YBCPgIsDatabaseColocated(const YBCPgOid database_oid, bool *colocated,
 
 YBCStatus YBCPgNewCreateDatabase(
     const char* database_name, const YBCPgOid database_oid, const YBCPgOid source_database_oid,
-    const char* source_database_name, const YBCPgOid next_oid, const bool colocated,
-    const int64_t clone_time, YBCPgStatement* handle) {
+    const YBCPgOid next_oid, const bool colocated, YbCloneInfo *yb_clone_info,
+    YBCPgStatement* handle) {
   return ToYBCStatus(pgapi->NewCreateDatabase(
-      database_name, database_oid, source_database_oid, source_database_name, next_oid, colocated,
-      clone_time, handle));
+      database_name, database_oid, source_database_oid, next_oid, colocated,
+      yb_clone_info, handle));
 }
 
 YBCStatus YBCPgExecCreateDatabase(YBCPgStatement handle) {
diff --git a/src/yb/yql/pggate/ybc_pggate.h b/src/yb/yql/pggate/ybc_pggate.h
index e8d4a4e1b4..96815788a2 100644
--- a/src/yb/yql/pggate/ybc_pggate.h
+++ b/src/yb/yql/pggate/ybc_pggate.h
@@ -224,10 +224,9 @@ YBCStatus YBCPgNewDropDBSequences(const YBCPgOid database_oid,
 YBCStatus YBCPgNewCreateDatabase(const char *database_name,
                                  YBCPgOid database_oid,
                                  YBCPgOid source_database_oid,
-                                 const char *source_database_name,
                                  YBCPgOid next_oid,
                                  const bool colocated,
-                                 const int64_t clone_time,
+                                 YbCloneInfo *yb_clone_info,
                                  YBCPgStatement *handle);
 YBCStatus YBCPgExecCreateDatabase(YBCPgStatement handle);
 
