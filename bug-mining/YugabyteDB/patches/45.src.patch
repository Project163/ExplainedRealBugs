diff --git a/src/yb/tserver/tablet_server.cc b/src/yb/tserver/tablet_server.cc
index 29125d8b1f..07320be6ce 100644
--- a/src/yb/tserver/tablet_server.cc
+++ b/src/yb/tserver/tablet_server.cc
@@ -232,6 +232,9 @@ DEFINE_NON_RUNTIME_uint32(ysql_conn_mgr_port, yb::pgwrapper::PgProcessConf::kDef
     "Ysql Connection Manager port to which clients will connect. This must be different from the "
     "postgres port set via pgsql_proxy_bind_address. Default is 5433.");
 
+DEFINE_NON_RUNTIME_bool(start_pgsql_proxy, false,
+            "Whether to run a PostgreSQL server as a child process of the tablet server");
+
 namespace yb::tserver {
 
 namespace {
@@ -268,6 +271,15 @@ void PostgresAndYsqlConnMgrPortValidator() {
 REGISTER_CALLBACK(ysql_conn_mgr_port, "PostgresAndYsqlConnMgrPortValidator",
     &PostgresAndYsqlConnMgrPortValidator);
 
+void ValidateEnableYsqlConnMgr() {
+  if (FLAGS_enable_ysql_conn_mgr && !(FLAGS_start_pgsql_proxy || FLAGS_enable_ysql)) {
+    LOG(FATAL) << "Cannot start Ysql Connection Manager (YSQL is not enabled)";
+    return;
+  }
+  return;
+}
+
+REGISTER_CALLBACK(enable_ysql_conn_mgr, "ValidateEnableYsqlConnMgr", &ValidateEnableYsqlConnMgr);
 
 class CDCServiceContextImpl : public cdc::CDCServiceContext {
  public:
diff --git a/src/yb/tserver/tablet_server_main_impl.cc b/src/yb/tserver/tablet_server_main_impl.cc
index 2f13cd3ef6..37f461deab 100644
--- a/src/yb/tserver/tablet_server_main_impl.cc
+++ b/src/yb/tserver/tablet_server_main_impl.cc
@@ -103,9 +103,6 @@ DEFINE_NON_RUNTIME_string(cql_proxy_broadcast_rpc_address, "",
               "RPC address to broadcast to other nodes. This is the broadcast_address used in the"
                   " system.local table");
 
-DEFINE_NON_RUNTIME_bool(start_pgsql_proxy, false,
-            "Whether to run a PostgreSQL server as a child process of the tablet server");
-
 DECLARE_string(rpc_bind_addresses);
 DECLARE_bool(callhome_enabled);
 DECLARE_int32(webserver_port);
@@ -131,6 +128,7 @@ DECLARE_string(ysql_pg_conf);
 DECLARE_string(metric_node_name);
 DECLARE_bool(enable_ysql_conn_mgr);
 DECLARE_bool(enable_ysql);
+DECLARE_bool(start_pgsql_proxy);
 DECLARE_bool(enable_ysql_conn_mgr_stats);
 DECLARE_uint32(ysql_conn_mgr_port);
 DECLARE_bool(ysql_conn_mgr_use_unix_conn);
diff --git a/src/yb/util/flags.h b/src/yb/util/flags.h
index 641bc9a463..0845b22602 100644
--- a/src/yb/util/flags.h
+++ b/src/yb/util/flags.h
@@ -45,6 +45,8 @@
 #undef DEFINE_validator
 #endif
 #define DEFINE_validator(name, validator) \
+  static_assert( \
+      sizeof(_DEFINE_FLAG_IN_FILE(name)), "validator must be DEFINED in the same file as the flag"); \
   static const bool BOOST_PP_CAT(name, _validator_registered) __attribute__((unused)) = \
       google::RegisterFlagValidator(&BOOST_PP_CAT(FLAGS_, name), (validator))
 
diff --git a/src/yb/util/flags/flag_tags.h b/src/yb/util/flags/flag_tags.h
index 5f81119b86..12b6dec5ad 100644
--- a/src/yb/util/flags/flag_tags.h
+++ b/src/yb/util/flags/flag_tags.h
@@ -224,6 +224,12 @@ class FlagTagger {
 
 } // namespace yb
 
+#define _DEFINE_FLAG_IN_FILE(name) BOOST_PP_CAT(name, _DefinedInFile)
+
+#define _DEFINE_flag(type, name, default_value, description) \
+  using _DEFINE_FLAG_IN_FILE(name) = bool; \
+  DEFINE_##type(name, default_value, description)
+
 #define DEFINE_test_flag(type, name, default_value, description) \
   BOOST_PP_CAT(DEFINE_, type)(TEST_##name, default_value, description " (For testing only!)"); \
   TAG_FLAG(BOOST_PP_CAT(TEST_, name), unsafe); \
@@ -231,54 +237,54 @@ class FlagTagger {
 
 // Runtime flags.
 #define DEFINE_RUNTIME_bool(name, default_value, description) \
-  DEFINE_bool(name, default_value, description); \
+  _DEFINE_flag(bool, name, default_value, description); \
   _TAG_FLAG_RUNTIME(name)
 
 #define DEFINE_RUNTIME_uint32(name, default_value, description) \
-  DEFINE_uint32(name, default_value, description); \
+  _DEFINE_flag(uint32, name, default_value, description); \
   _TAG_FLAG_RUNTIME(name)
 
 #define DEFINE_RUNTIME_int32(name, default_value, description) \
-  DEFINE_int32(name, default_value, description); \
+  _DEFINE_flag(int32, name, default_value, description); \
   _TAG_FLAG_RUNTIME(name)
 
 #define DEFINE_RUNTIME_int64(name, default_value, description) \
-  DEFINE_int64(name, default_value, description); \
+  _DEFINE_flag(int64, name, default_value, description); \
   _TAG_FLAG_RUNTIME(name)
 
 #define DEFINE_RUNTIME_uint64(name, default_value, description) \
-  DEFINE_uint64(name, default_value, description); \
+  _DEFINE_flag(uint64, name, default_value, description); \
   _TAG_FLAG_RUNTIME(name)
 
 #define DEFINE_RUNTIME_double(name, default_value, description) \
-  DEFINE_double(name, default_value, description); \
+  _DEFINE_flag(double, name, default_value, description); \
   _TAG_FLAG_RUNTIME(name)
 
 #define DEFINE_RUNTIME_string(name, default_value, description) \
-  DEFINE_string(name, default_value, description); \
+  _DEFINE_flag(string, name, default_value, description); \
   _TAG_FLAG_RUNTIME(name)
 
 // Non Runtime flags.
 #define DEFINE_NON_RUNTIME_bool(name, default_value, description) \
-  DEFINE_bool(name, default_value, description)
+  _DEFINE_flag(bool, name, default_value, description)
 
 #define DEFINE_NON_RUNTIME_uint32(name, default_value, description) \
-  DEFINE_uint32(name, default_value, description)
+  _DEFINE_flag(uint32, name, default_value, description)
 
 #define DEFINE_NON_RUNTIME_int32(name, default_value, description) \
-  DEFINE_int32(name, default_value, description)
+  _DEFINE_flag(int32, name, default_value, description)
 
 #define DEFINE_NON_RUNTIME_int64(name, default_value, description) \
-  DEFINE_int64(name, default_value, description)
+  _DEFINE_flag(int64, name, default_value, description)
 
 #define DEFINE_NON_RUNTIME_uint64(name, default_value, description) \
-  DEFINE_uint64(name, default_value, description)
+  _DEFINE_flag(uint64, name, default_value, description)
 
 #define DEFINE_NON_RUNTIME_double(name, default_value, description) \
-  DEFINE_double(name, default_value, description)
+  _DEFINE_flag(double, name, default_value, description)
 
 #define DEFINE_NON_RUNTIME_string(name, default_value, description) \
-  DEFINE_string(name, default_value, description)
+  _DEFINE_flag(string, name, default_value, description)
 
 // Runtime preview flags.
 #define PREVIEW_FLAG_DESCRIPTION(description, name) \
@@ -376,22 +382,22 @@ class FlagTagger {
 // Unknown flags. !!Not to be used!!
 // Older flags need to be reviewed in order to determine if they are runtime or non-runtime.
 #define DEFINE_UNKNOWN_bool(name, default_value, description) \
-  DEFINE_bool(name, default_value, description)
+  _DEFINE_flag(bool, name, default_value, description)
 
 #define DEFINE_UNKNOWN_uint32(name, default_value, description) \
-  DEFINE_uint32(name, default_value, description)
+  _DEFINE_flag(uint32, name, default_value, description)
 
 #define DEFINE_UNKNOWN_int32(name, default_value, description) \
-  DEFINE_int32(name, default_value, description)
+  _DEFINE_flag(int32, name, default_value, description)
 
 #define DEFINE_UNKNOWN_int64(name, default_value, description) \
-  DEFINE_int64(name, default_value, description);
+  _DEFINE_flag(int64, name, default_value, description)
 
 #define DEFINE_UNKNOWN_uint64(name, default_value, description) \
-  DEFINE_uint64(name, default_value, description)
+  _DEFINE_flag(uint64, name, default_value, description)
 
 #define DEFINE_UNKNOWN_double(name, default_value, description) \
-  DEFINE_double(name, default_value, description)
+  _DEFINE_flag(double, name, default_value, description)
 
 #define DEFINE_UNKNOWN_string(name, default_value, description) \
-  DEFINE_string(name, default_value, description)
+  _DEFINE_flag(string, name, default_value, description)
diff --git a/src/yb/util/flags/flags-test.cc b/src/yb/util/flags/flags-test.cc
index baee1ba067..4f008ff2a2 100644
--- a/src/yb/util/flags/flags-test.cc
+++ b/src/yb/util/flags/flags-test.cc
@@ -61,23 +61,22 @@ TEST_F(FlagsTest, TestVmodule) {
 
   // Set to invalid value
   string old_value, output_msg;
-  auto res = SetFlag("vmodule", "BadValue", SetFlagForce::kFalse, &old_value, &output_msg);
-  ASSERT_EQ(res, SetFlagResult::BAD_VALUE);
+  ASSERT_DEATH(
+      SetFlag("vmodule", "BadValue", SetFlagForce::kFalse, &old_value, &output_msg),
+      "'BadValue' is not valid");
 
-  res = SetFlag("vmodule", "files=", SetFlagForce::kFalse, &old_value, &output_msg);
-  ASSERT_EQ(res, SetFlagResult::BAD_VALUE);
+  ASSERT_DEATH(
+      SetFlag("vmodule", "files=", SetFlagForce::kFalse, &old_value, &output_msg),
+      "'files=' is not valid");
 
-  res =
-      SetFlag("vmodule", "biggerThanInt=2147483648", SetFlagForce::kFalse, &old_value, &output_msg);
-  ASSERT_EQ(res, SetFlagResult::BAD_VALUE);
-
-  res = SetFlag("vmodule", "files=-1b", SetFlagForce::kFalse, &old_value, &output_msg);
-  ASSERT_EQ(res, SetFlagResult::BAD_VALUE);
+  ASSERT_DEATH(
+      SetFlag("vmodule", "biggerThanInt=2147483648", SetFlagForce::kFalse, &old_value, &output_msg),
+      "'2147483648' is not a valid integer number");
 
   ASSERT_EQ(FLAGS_vmodule, expected_old);
   ASSERT_FALSE(VLOG_IS_ON(1));
 
-  res = SetFlag("vmodule", "", SetFlagForce::kFalse, &old_value, &output_msg);
+  auto res = SetFlag("vmodule", "", SetFlagForce::kFalse, &old_value, &output_msg);
   ASSERT_EQ(res, SetFlagResult::SUCCESS);
   ASSERT_EQ(old_value, expected_old);
   ASSERT_EQ(FLAGS_vmodule, "");
diff --git a/src/yb/util/flags/flags.cc b/src/yb/util/flags/flags.cc
index 17f67480f7..6a1809dce6 100644
--- a/src/yb/util/flags/flags.cc
+++ b/src/yb/util/flags/flags.cc
@@ -35,6 +35,7 @@
 #include <vector>
 #include <boost/algorithm/string/replace.hpp>
 #include "yb/gutil/map-util.h"
+#include "yb/gutil/once.h"
 #include "yb/gutil/strings/split.h"
 #include "yb/util/flags/flag_tags.h"
 
@@ -184,12 +185,6 @@ DECLARE_string(vmodule);
 TAG_FLAG(vmodule, stable);
 _TAG_FLAG_RUNTIME(vmodule);
 TAG_FLAG(vmodule, advanced);
-namespace yb {
-bool ValidateVmodule(const char* flag_name, const string& new_value);
-void UpdateVmodule();
-}  // namespace yb
-DEFINE_validator(vmodule, &yb::ValidateVmodule);
-REGISTER_CALLBACK(vmodule, "UpdateVmodule", &yb::UpdateVmodule);
 
 DECLARE_bool(symbolize_stacktrace);
 TAG_FLAG(symbolize_stacktrace, stable);
@@ -448,113 +443,34 @@ bool IsPreviewFlagAllowed(const CommandLineFlagInfo& flag_info, const string& ne
   return true;
 }
 
-}  // anonymous namespace
-
-void ParseCommandLineFlags(int* argc, char*** argv, bool remove_flags) {
-  {
-    std::vector<google::CommandLineFlagInfo> flag_infos;
-    google::GetAllFlags(&flag_infos);
-
-    // gFlags have one hard-coded static default value in all programs that include the file
-    // where it was defined. Programs that need custom defaults set the flag at runtime before the
-    // call to ParseCommandLineFlags. So the current value is technically the default value used
-    // by this program.
-    SetFlagDefaultsToCurrent(flag_infos);
-
-    google::ParseCommandLineNonHelpFlags(argc, argv, remove_flags);
-
-    // Ensure all preview flags overridden are in allow list before invoking any callbacks.
-    string err_msg;
-    if (!ValidateAllPreviewFlags(&err_msg, FLAGS_allowed_preview_flags_csv)) {
-      LOG(FATAL) << err_msg;
-      return;
-    }
-
-    InvokeAllCallbacks(flag_infos);
-
-    // flag_infos is no longer valid as default and current values have changed.
-  }
-
-  if (FLAGS_TEST_promote_all_auto_flags) {
-    PromoteAllAutoFlags();
-  }
-
-  if (FLAGS_helpxml) {
-    DumpFlagsXMLAndExit(OnlyDisplayDefaultFlagValue::kFalse);
-  } else if (FLAGS_dump_flags_xml) {
-    DumpFlagsXMLAndExit(OnlyDisplayDefaultFlagValue::kTrue);
-  } else if (FLAGS_help_auto_flag_json) {
-    DumpAutoFlagsJSONAndExit();
-  } else if (FLAGS_dump_metrics_json) {
-    std::stringstream s;
-    JsonWriter w(&s, JsonWriter::PRETTY);
-    WriteRegistryAsJson(&w);
-    std::cout << s.str() << std::endl;
-    exit(0);
-  } else if (FLAGS_version) {
-    ShowVersionAndExit();
-  } else {
-    google::HandleCommandLineHelpFlags();
-  }
-
-  // Disallow relative path for tmp_dir.
-  if (!FLAGS_tmp_dir.starts_with('/')) {
-    LOG(FATAL) << "tmp_dir must be an absolute path, found value to be " << FLAGS_tmp_dir;
-  }
-
-}
-
-bool RefreshFlagsFile(const std::string& filename) {
-  // prog_name is a placeholder that isn't really used by ReadFromFlags.
-  // TODO: Find a better way to refresh flags from the file, ReadFromFlagsFile is going to be
-  // deprecated.
-  const char* prog_name = "yb";
-  if (!google::ReadFromFlagsFile(filename, prog_name, false /* errors_are_fatal */)) {
-    return false;
-  }
-
-  if (FLAGS_TEST_promote_all_auto_flags) {
-    PromoteAllAutoFlags();
-  }
-
-  return true;
-}
-
 // Validates that the requested updates to vmodule can be made.
-bool ValidateVmodule(const char* flag_name, const string& new_value) {
-  auto requested_settings = strings::Split(new_value, ",");
+void ValidateVmodule() {
+  auto requested_settings = strings::Split(FLAGS_vmodule, ",");
   for (const auto& module_value : requested_settings) {
     if (module_value.empty()) {
       continue;
     }
     vector<string> kv = strings::Split(module_value, "=");
     if (kv.size() != 2 || kv[0].empty() || kv[1].empty()) {
-      LOG(ERROR) << Format(
+      LOG(FATAL) << Format(
           "'$0' is not valid. vmodule should be a comma list of <module_pattern>=<logging_level>",
           module_value);
-      return false;
     }
 
     char* end;
     errno = 0;
     const int64 value = strtol(kv[1].c_str(), &end, 10);
     if (*end != '\0' || errno == ERANGE || value > INT_MAX || value < INT_MIN) {
-      LOG(ERROR) << Format(
+      LOG(FATAL) << Format(
           "'$0' is not a valid integer number. Cannot update vmodule setting for module '$1'",
           kv[1], kv[0]);
-      return false;
     }
   }
-
-  return true;
 }
 
-namespace {
-std::mutex vmodule_mtx;
-vector<std::pair<string, int>> vmodule_values GUARDED_BY(vmodule_mtx);
-}  // namespace
+void ValidateAndUpdateVmodule() {
+  ValidateVmodule();
 
-void UpdateVmodule() {
   // glog behavior: The first time VLOG is invoked for a file it tries to find a matching pattern in
   // vmodule list. If found it links to that pattern for the rest of the program lifetime. If not
   // found it uses the default logging level from FLAGS_v and gets added to a list of files that
@@ -566,6 +482,9 @@ void UpdateVmodule() {
   // the order of modules the same as it would have been if it was only set once. Ex: If vmodule is
   // set to "ab=1,a=1" and then changed to "b=2,ab=3" then we will set it to "ab=3,a=0,b=2" and the
   // behavior will be identical to if it was set to this value from the start.
+
+  static std::mutex vmodule_mtx;
+  static vector<std::pair<string, int>> vmodule_values GUARDED_BY(vmodule_mtx);
   std::lock_guard l(vmodule_mtx);
   // Set everything to 0
   for (auto& module_value : vmodule_values) {
@@ -610,6 +529,83 @@ void UpdateVmodule() {
   }
 }
 
+}  // anonymous namespace
+
+void ParseCommandLineFlags(int* argc, char*** argv, bool remove_flags) {
+  static GoogleOnceType once_register_vmodule_callback = GOOGLE_ONCE_INIT;
+  GoogleOnceInit(&once_register_vmodule_callback, []() {
+    flags_callback_internal::RegisterGlobalFlagUpdateCallback(
+        &FLAGS_vmodule, "ValidateAndUpdateVmodule", &ValidateAndUpdateVmodule);
+  });
+
+  {
+    std::vector<google::CommandLineFlagInfo> flag_infos;
+    google::GetAllFlags(&flag_infos);
+
+    // gFlags have one hard-coded static default value in all programs that include the file
+    // where it was defined. Programs that need custom defaults set the flag at runtime before the
+    // call to ParseCommandLineFlags. So the current value is technically the default value used
+    // by this program.
+    SetFlagDefaultsToCurrent(flag_infos);
+
+    google::ParseCommandLineNonHelpFlags(argc, argv, remove_flags);
+
+    // Ensure all preview flags overridden are in allow list before invoking any callbacks.
+    string err_msg;
+    if (!ValidateAllPreviewFlags(&err_msg, FLAGS_allowed_preview_flags_csv)) {
+      LOG(FATAL) << err_msg;
+      return;
+    }
+
+    InvokeAllCallbacks(flag_infos);
+
+    // flag_infos is no longer valid as default and current values have changed.
+  }
+
+  if (FLAGS_TEST_promote_all_auto_flags) {
+    PromoteAllAutoFlags();
+  }
+
+  if (FLAGS_helpxml) {
+    DumpFlagsXMLAndExit(OnlyDisplayDefaultFlagValue::kFalse);
+  } else if (FLAGS_dump_flags_xml) {
+    DumpFlagsXMLAndExit(OnlyDisplayDefaultFlagValue::kTrue);
+  } else if (FLAGS_help_auto_flag_json) {
+    DumpAutoFlagsJSONAndExit();
+  } else if (FLAGS_dump_metrics_json) {
+    std::stringstream s;
+    JsonWriter w(&s, JsonWriter::PRETTY);
+    WriteRegistryAsJson(&w);
+    std::cout << s.str() << std::endl;
+    exit(0);
+  } else if (FLAGS_version) {
+    ShowVersionAndExit();
+  } else {
+    google::HandleCommandLineHelpFlags();
+  }
+
+  // Disallow relative path for tmp_dir.
+  if (!FLAGS_tmp_dir.starts_with('/')) {
+    LOG(FATAL) << "tmp_dir must be an absolute path, found value to be " << FLAGS_tmp_dir;
+  }
+}
+
+bool RefreshFlagsFile(const std::string& filename) {
+  // prog_name is a placeholder that isn't really used by ReadFromFlags.
+  // TODO: Find a better way to refresh flags from the file, ReadFromFlagsFile is going to be
+  // deprecated.
+  const char* prog_name = "yb";
+  if (!google::ReadFromFlagsFile(filename, prog_name, false /* errors_are_fatal */)) {
+    return false;
+  }
+
+  if (FLAGS_TEST_promote_all_auto_flags) {
+    PromoteAllAutoFlags();
+  }
+
+  return true;
+}
+
 namespace flags_internal {
 string SetFlagInternal(
     const void* flag_ptr, const char* flag_name, const string& new_value,
diff --git a/src/yb/util/flags/flags_callback.h b/src/yb/util/flags/flags_callback.h
index 61a5ec7509..23ac580024 100644
--- a/src/yb/util/flags/flags_callback.h
+++ b/src/yb/util/flags/flags_callback.h
@@ -60,6 +60,8 @@ Result<FlagCallbackRegistration> RegisterFlagUpdateCallback(
 // Note: This macro should be used in the same file that DEFINEs the flag. Using it any other file
 // can result in segfault due to indeterminate order of static initialization.
 #define REGISTER_CALLBACK(flag_name, descriptive_name, callback) \
+  static_assert( \
+      sizeof(_DEFINE_FLAG_IN_FILE(flag_name)), "callback must be DEFINED in the same file as the flag"); \
   namespace { \
   static const std::shared_ptr<yb::FlagCallbackInfo> BOOST_PP_CAT( \
       flag_name, _global_callback_registered) \
diff --git a/src/yb/yql/ysql_conn_mgr_wrapper/ysql_conn_mgr_wrapper.cc b/src/yb/yql/ysql_conn_mgr_wrapper/ysql_conn_mgr_wrapper.cc
index 4ad75f5fb4..84951017be 100644
--- a/src/yb/yql/ysql_conn_mgr_wrapper/ysql_conn_mgr_wrapper.cc
+++ b/src/yb/yql/ysql_conn_mgr_wrapper/ysql_conn_mgr_wrapper.cc
@@ -22,9 +22,6 @@
 #include "yb/yql/pgwrapper/pg_wrapper.h"
 #include "yb/yql/ysql_conn_mgr_wrapper/ysql_conn_mgr_stats.h"
 
-DECLARE_bool(enable_ysql);
-DECLARE_bool(start_pgsql_proxy);
-DECLARE_bool(enable_ysql_conn_mgr);
 DECLARE_bool(enable_ysql_conn_mgr_stats);
 DECLARE_int32(ysql_max_connections);
 DECLARE_string(ysql_conn_mgr_warmup_db);
@@ -76,14 +73,6 @@ DEFINE_NON_RUNTIME_bool(ysql_conn_mgr_use_unix_conn, true,
 
 namespace {
 
-void ValidateEnableYsqlConnMgr() {
-  if (FLAGS_enable_ysql_conn_mgr && !(FLAGS_start_pgsql_proxy || FLAGS_enable_ysql)) {
-    LOG(FATAL) << "Cannot start Ysql Connection Manager (YSQL is not enabled)";
-    return;
-  }
-  return;
-}
-
 bool ValidateMaxClientConn(const char* flagname, uint32_t value) {
   if (value < 1) {
     LOG(ERROR) << flagname << "(" << value << ") can not be less than 1";
@@ -94,8 +83,6 @@ bool ValidateMaxClientConn(const char* flagname, uint32_t value) {
 
 } // namespace
 
-REGISTER_CALLBACK(enable_ysql_conn_mgr, "ValidateEnableYsqlConnMgr",
-        &ValidateEnableYsqlConnMgr);
 DEFINE_validator(ysql_conn_mgr_max_client_connections, &ValidateMaxClientConn);
 
 namespace yb {
