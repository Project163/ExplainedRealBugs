diff --git a/src/yb/util/flags/flag_tags.h b/src/yb/util/flags/flag_tags.h
index 12b6dec5ad..514ac52221 100644
--- a/src/yb/util/flags/flag_tags.h
+++ b/src/yb/util/flags/flag_tags.h
@@ -164,7 +164,8 @@ YB_DEFINE_ENUM(
     (kAuto)
     (kPg)
     (kDeprecated)
-    (kPreview));
+    (kPreview)
+    (kHasNewInstallValue));
 
 #define FLAG_TAG_stable ::yb::FlagTag::kStable
 #define FLAG_TAG_evolving ::yb::FlagTag::kEvolving
@@ -222,8 +223,26 @@ class FlagTagger {
 
 } // namespace flag_tags_internal
 
+namespace flags_internal {
+bool RegisterFlagNewInstallValue(const std::string& flag_name, const std::string& value);
+}  // namespace flags_internal
+
 } // namespace yb
 
+#define DEFINE_NEW_INSTALL_VALUE(flag_name, flag_value) \
+  COMPILE_ASSERT(sizeof(BOOST_PP_CAT(FLAGS_, flag_name)), flag_does_not_exist); \
+  static_assert( \
+      std::is_trivially_assignable< \
+          decltype(BOOST_PP_CAT(FLAGS_, flag_name))&, decltype(flag_value)>::value, \
+      "Value cannot be assigned to flag"); \
+  _TAG_FLAG(flag_name, ::yb::FlagTag::kHasNewInstallValue, hasNewInstallValue); \
+  namespace { \
+  auto BOOST_PP_CAT(_flag_new_install_value_, flag_name) = \
+      yb::flags_internal::RegisterFlagNewInstallValue( \
+          BOOST_PP_STRINGIZE(flag_name), BOOST_PP_STRINGIZE(flag_value)); \
+  } \
+  static_assert(true, "semi-colon required after this macro")
+
 #define _DEFINE_FLAG_IN_FILE(name) BOOST_PP_CAT(name, _DefinedInFile)
 
 #define _DEFINE_flag(type, name, default_value, description) \
diff --git a/src/yb/util/flags/flags-test.cc b/src/yb/util/flags/flags-test.cc
index 1a63d80a84..22ae98bd2c 100644
--- a/src/yb/util/flags/flags-test.cc
+++ b/src/yb/util/flags/flags-test.cc
@@ -31,6 +31,8 @@ bool ValidateTestFlag(const char* flag_name, const int32 new_val) {
   return false;
 }
 DEFINE_validator(flagstest_testflag, &ValidateTestFlag);
+DEFINE_NEW_INSTALL_VALUE(flagstest_testflag, 50);
+
 DECLARE_string(vmodule);
 
 DECLARE_string(allowed_preview_flags_csv);
@@ -308,4 +310,17 @@ TEST_F(FlagsTest, ValidateFlagValue) {
       flags_internal::ValidateFlagValue("allowed_preview_flags_csv", ""), kPreviewFlagMissingError);
 }
 
+namespace flags_internal {
+std::optional<std::string> GetFlagNewInstallValue(const std::string& flag_name);
+}  // namespace flags_internal
+
+TEST_F(FlagsTest, NewInstallValue) {
+  auto new_install_value = flags_internal::GetFlagNewInstallValue("flagstest_testflag");
+  ASSERT_TRUE(new_install_value.has_value());
+  ASSERT_EQ(*new_install_value, "50");
+
+  new_install_value = flags_internal::GetFlagNewInstallValue("flagstest_secret_flag");
+  ASSERT_FALSE(new_install_value.has_value());
+}
+
 } // namespace yb
diff --git a/src/yb/util/flags/flags.cc b/src/yb/util/flags/flags.cc
index 70a4782d4e..4b583ae8b3 100644
--- a/src/yb/util/flags/flags.cc
+++ b/src/yb/util/flags/flags.cc
@@ -278,6 +278,7 @@ string GetStaticProgramName() {
 // Forward declarations.
 namespace flags_internal {
 Status ValidateFlagValue(const CommandLineFlagInfo& flag_info, const std::string& value);
+std::optional<std::string> GetFlagNewInstallValue(const std::string& flag_name);
 }  // namespace flags_internal
 
 namespace {
@@ -342,6 +343,11 @@ static string DescribeOneFlagInXML(
     AppendXMLTag("current", flag.current_value, &r);
   }
 
+  auto new_install_value = flags_internal::GetFlagNewInstallValue(flag.name);
+  if (new_install_value) {
+    AppendXMLTag("new_install_default", *new_install_value, &r);
+  }
+
   AppendXMLTag("type", flag.type, &r);
   AppendXMLTag("tags", JoinStrings(tags_str, ","), &r);
   r += "</flag>";
@@ -450,7 +456,7 @@ void InvokeAllCallbacks(const std::vector<google::CommandLineFlagInfo>& flag_inf
 bool IsPreviewFlagUpdateAllowed(
     const CommandLineFlagInfo& flag_info, const unordered_set<FlagTag>& tags,
     const std::string& new_value, const std::string& allowed_preview_flags, std::string* err_msg) {
-  if (!ContainsKey(tags, FlagTag::kPreview) || new_value == flag_info.default_value) {
+  if (!tags.contains(FlagTag::kPreview) || new_value == flag_info.default_value) {
     return true;
   }
 
@@ -739,7 +745,7 @@ void WarnFlagDeprecated(const std::string& flagname, const std::string& date_mm_
 static const std::string kMaskedFlagValue = "***";
 
 bool IsFlagSensitive(const unordered_set<FlagTag>& tags) {
-  return ContainsKey(tags, FlagTag::kSensitive_info);
+  return tags.contains(FlagTag::kSensitive_info);
 }
 
 bool IsFlagSensitive(const std::string& flag_name) {
@@ -815,7 +821,7 @@ SetFlagResult SetFlag(
   // Validate that the flag is runtime-changeable.
   unordered_set<FlagTag> tags;
   GetFlagTags(flag_name, &tags);
-  if (!ContainsKey(tags, FlagTag::kRuntime)) {
+  if (!tags.contains(FlagTag::kRuntime)) {
     if (force) {
       LOG(WARNING) << "Forcing change of non-runtime-safe flag " << flag_name;
     } else {
@@ -857,6 +863,42 @@ SetFlagResult SetFlag(
 
   return SetFlagResult::SUCCESS;
 }
+
+std::unordered_map<std::string, std::string>& GetFlagNewInstallValueMap() {
+  static std::unordered_map<std::string, std::string> flag_new_install_value_map;
+  return flag_new_install_value_map;
+}
+
+std::optional<std::string> GetFlagNewInstallValue(const std::string& flag_name) {
+  auto& flag_new_install_value_map = GetFlagNewInstallValueMap();
+  auto it = FindOrNull(flag_new_install_value_map, flag_name);
+  if (it) {
+    return *it;
+  }
+  return std::nullopt;
+}
+
+bool RegisterFlagNewInstallValue(const std::string& flag_name, const std::string& value) {
+  auto& flag_new_install_value_map = flags_internal::GetFlagNewInstallValueMap();
+  CHECK(!flag_new_install_value_map.contains(flag_name))
+      << "Flag " << flag_name
+      << " already has a new install value: " << flag_new_install_value_map[flag_name];
+
+  std::unordered_set<FlagTag> tags;
+  GetFlagTags(flag_name, &tags);
+  CHECK(!tags.contains(FlagTag::kAuto)) << "AutoFlags cannot have a new install value";
+  CHECK(!tags.contains(FlagTag::kPreview)) << "Preview flags cannot have a new install value";
+  CHECK(!tags.contains(FlagTag::kHidden)) << "Hidden flags cannot have a new install value";
+  CHECK(!tags.contains(FlagTag::kDeprecated)) << "Deprecated flags cannot have a new install value";
+
+  CHECK_OK_PREPEND(
+      ValidateFlagValue(flag_name, value),
+      Format("Invalid New install value '$0' for flag '$1'", value, flag_name));
+
+  flag_new_install_value_map[flag_name] = value;
+  return true;
+}
+
 }  // namespace flags_internal
 
 bool ValidatePercentageFlag(const char* flag_name, int value) {
