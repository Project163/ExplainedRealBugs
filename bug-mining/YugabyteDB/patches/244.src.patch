diff --git a/pg15_tests/common_upgrade.sh b/pg15_tests/common_upgrade.sh
deleted file mode 100644
index bbfd17fde2..0000000000
--- a/pg15_tests/common_upgrade.sh
+++ /dev/null
@@ -1,172 +0,0 @@
-# This file is sourced by each upgrade test. It contains shared code, such as
-# functions and variables.
-
-# Upgrade tests use a 3-node cluster and need to reference the second and third nodes.
-pghost2=127.0.0.$((ip_start + 1))
-pghost3=127.0.0.$((ip_start + 2))
-
-# TEST_always_return_consensus_info_for_succeeded_rpc=false is needed to upgrade a release build to
-# debug.
-common_pg15_flags="TEST_always_return_consensus_info_for_succeeded_rpc=false"
-# yb_enable_expression_pushdown=false is needed because the expression pushdown rewriter is not yet
-# implemented.
-common_tserver_flags='"ysql_pg_conf_csv=yb_enable_expression_pushdown=false"'
-
-# Downloads, runs, and pushds the directory for pg11.
-# Sets $pg11path to the pg11 directory.
-run_and_pushd_pg11() {
-  prefix="/tmp"
-  ybversion_pg11="2024.2.1.0"
-  ybbuild="b116"
-  ybhash="ef5232e8f428fba9d52c6cc2002d46ffd79ab999"
-  if [[ $OSTYPE = linux* ]]; then
-    arch="release-clang17-centos-x86_64"
-    tarbin="tar"
-  fi
-  if [[ $OSTYPE = darwin* ]]; then
-    arch="release-clang-darwin-arm64"
-    tarbin="gtar"
-  fi
-  ybfilename_pg11="yugabyte-$ybversion_pg11-$ybbuild-$arch.tar.gz"
-  ybfilename_pg11_web="yugabyte-$ybversion_pg11-$ybhash-$arch.tar.gz"
-
-  if [ ! -f "$prefix"/"$ybfilename_pg11" ]; then
-    curl "https://s3.us-west-2.amazonaws.com/uploads.dev.yugabyte.com/local-provider-test/$ybversion_pg11-$ybbuild/$ybfilename_pg11_web" \
-      -o "$prefix"/"$ybfilename_pg11"
-  fi
-
-  "$tarbin" xzf "$prefix"/"$ybfilename_pg11" --skip-old-files -C "$prefix"
-
-  if [[ $OSTYPE = linux* ]]; then
-    "$prefix/yugabyte-$ybversion_pg11/bin/post_install.sh"
-  fi
-
-  pg11path="$prefix/yugabyte-$ybversion_pg11"
-  pushd "$pg11path"
-  yb_ctl_destroy_create --rf=3 --tserver_flags="$common_tserver_flags"
-}
-
-upgrade_masters() {
-  for i in {1..3}; do
-    yb_ctl restart_node $i --master \
-      --master_flags="master_join_existing_universe=true,$common_pg15_flags"
-  done
-}
-
-run_ysql_catalog_upgrade() {
-  echo run_ysql_catalog_upgrade starting at $(date +"%r")
-  build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 --timeout_ms=300000 \
-    upgrade_ysql_major_version_catalog
-  echo run_ysql_catalog_upgrade finished at $(date +"%r")
-}
-
-# Restarts the masters in a mode that's aware of the PG11 to PG15 upgrade process, then runs ysql
-# major upgrade to populate the pg15 catalog.
-# Must be run while the current directory is a pg15 directory, typically the directory for the
-# source code being built.
-upgrade_masters_run_ysql_catalog_upgrade() {
-  upgrade_masters
-  run_ysql_catalog_upgrade
-}
-
-# Restart node 2 using PG15 binaries.
-# Due to historic reasons we first restart the 2nd node instead of the 1st.
-restart_node_2_in_pg15() {
-  yb_ctl restart_node 2 --tserver_flags="$common_tserver_flags,$common_pg15_flags"
-}
-
-run_preflight_checks() {
-  build/latest/postgres/bin/pg_upgrade --old-datadir "$data_dir/node-1/disk-1/pg_data" \
-    --old-host "$PGHOST" --old-port 5433 --username "yugabyte" --check
-}
-
-finalize_upgrade() {
-  build/latest/bin/yb-admin --init_master_addrs=127.0.0.200:7100 --timeout_ms=300000 \
-    finalize_upgrade
-}
-
-verify_simple_table_mixed_cluster() {
-  # Insert from PG15
-  diff <(ysqlsh 2 <<EOT | sed 's/ *$//'
-SHOW server_version_num;
-INSERT INTO t VALUES (15);
-SELECT * FROM t ORDER BY a;
-EOT
-) - <<EOT
- server_version_num
---------------------
- 150002
-(1 row)
-
-INSERT 0 1
- a
-----
-  1
-  2
- 15
-(3 rows)
-
-EOT
-
-  # Insert from PG11, and note the PG15 insertion is visible
-  diff <(ysqlsh <<EOT | sed 's/ *$//'
-SHOW server_version_num;
-INSERT INTO t VALUES (11);
-SELECT * FROM t ORDER BY a;
-EOT
-) - <<EOT
- server_version_num
---------------------
- 110002
-(1 row)
-
-INSERT 0 1
- a
-----
-  1
-  2
- 11
- 15
-(4 rows)
-
-EOT
-}
-
-verify_simple_table_after_finalize() {
-  diff <(ysqlsh <<EOT | sed 's/ *$//'
-SHOW server_version_num;
-SELECT * FROM t ORDER BY a;
-CREATE INDEX ON t (a);
-EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM t WHERE a = 11;
-SELECT COUNT(*) FROM t WHERE a = 11;
-EOT
-) - <<EOT
- server_version_num
---------------------
- 150002
-(1 row)
-
- a
-----
-  1
-  2
- 11
- 15
-(4 rows)
-
-CREATE INDEX
-                QUERY PLAN
-------------------------------------------
- Finalize Aggregate
-   ->  Index Only Scan using t_a_idx on t
-         Index Cond: (a = 11)
-         Partial Aggregate: true
-(4 rows)
-
- count
--------
-     1
-(1 row)
-
-EOT
-}
diff --git a/pg15_tests/test_upgrade.sh b/pg15_tests/test_upgrade.sh
deleted file mode 100755
index 4cff985a05..0000000000
--- a/pg15_tests/test_upgrade.sh
+++ /dev/null
@@ -1,138 +0,0 @@
-#!/usr/bin/env bash
-source "${BASH_SOURCE[0]%/*}"/common.sh
-source "${BASH_SOURCE[0]%/*}"/common_upgrade.sh
-
-run_and_pushd_pg11
-
-# Store PG DB OIDs for later comparison
-bin/yb-admin --master_addresses=$PGHOST:7100,$pghost2:7100,$pghost3:7100 list_namespaces \
-  | grep 30008 | sort -k2 | awk '{print $1 " " $2}' > $data_dir/pg11_dbs.txt
-
-# Create pre-existing PG11 table
-ysqlsh <<EOT
-SHOW server_version;
-CREATE TABLE t (h int, r TEXT, v1 BIGINT, v2 VARCHAR, v3 JSONB, v4 int[], PRIMARY KEY (h, r));
-INSERT INTO t VALUES (1, 'a', 5000000000, 'abc', '{"a" : 3.5}', '{1, 2, 3}'),
-(1, 'b', -5000000000, 'def', '{"b" : 5}', '{1, 1, 2, 3}'),
-(2, 'a', 5000000000, 'ghi', '{"c" : 30}', '{1, 4, 9}');
-SELECT * FROM t;
-EOT
-
-popd
-
-# Run preflight checks before upgrading yb-masters.
-run_preflight_checks
-upgrade_masters_run_ysql_catalog_upgrade
-
-# Ensure that the PG15 initdb didn't create or modify namespace entries on the YB master.
-diff $data_dir/pg11_dbs.txt <(build/latest/bin/yb-admin \
-  --master_addresses=$PGHOST:7100,$pghost2:7100,$pghost3:7100 list_namespaces | grep 30008 \
-  | sort -k2 | awk '{print $1 " " $2}')
-
-restart_node_2_in_pg15
-
-# Demonstrate simultaneous access for DMLs before the upgrade has been finalized. (DDLs are not
-# allowed, and rollback to PG11 is still possible.)
-
-# Insert from PG15
-diff <(ysqlsh 2 <<EOT | sed 's/ *$//'
-SHOW server_version_num;
-INSERT INTO t VALUES (15, 'fifteen', cosh(0), '15', '{"num" : 15}', '{15}');
-SELECT * FROM t ORDER BY h,r;
-EOT
-) - <<EOT
- server_version_num
---------------------
- 150002
-(1 row)
-
-INSERT 0 1
- h  |    r    |     v1      | v2  |     v3      |    v4
-----+---------+-------------+-----+-------------+-----------
-  1 | a       |  5000000000 | abc | {"a": 3.5}  | {1,2,3}
-  1 | b       | -5000000000 | def | {"b": 5}    | {1,1,2,3}
-  2 | a       |  5000000000 | ghi | {"c": 30}   | {1,4,9}
- 15 | fifteen |           1 | 15  | {"num": 15} | {15}
-(4 rows)
-
-EOT
-# Insert from PG11, and note the PG15 insertion is visible
-diff <(ysqlsh <<EOT | sed 's/ *$//'
-SHOW server_version_num;
-INSERT INTO t VALUES (11, 'eleven', 11, '11', '{"num": 11}', '{11}');
-SELECT * FROM t ORDER BY h,r;
-EOT
-) - <<EOT
- server_version_num
---------------------
- 110002
-(1 row)
-
-INSERT 0 1
- h  |    r    |     v1      | v2  |     v3      |    v4
-----+---------+-------------+-----+-------------+-----------
-  1 | a       |  5000000000 | abc | {"a": 3.5}  | {1,2,3}
-  1 | b       | -5000000000 | def | {"b": 5}    | {1,1,2,3}
-  2 | a       |  5000000000 | ghi | {"c": 30}   | {1,4,9}
- 11 | eleven  |          11 | 11  | {"num": 11} | {11}
- 15 | fifteen |           1 | 15  | {"num": 15} | {15}
-(5 rows)
-
-EOT
-
-# Finalize the upgrade to re-enable pushdown and DDLs.
-finalize_upgrade
-# Upgrade is complete. After the restart, demonstrate that DDLs work.
-yb_ctl restart
-
-diff <(ysqlsh <<EOT | sed 's/ *$//'
-SHOW server_version_num;
-SELECT * FROM t ORDER BY h,r;
-CREATE INDEX ON t (v1);
-EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM t WHERE v1 = 11;
-SELECT COUNT(*) FROM t WHERE v1 = 11;
-CREATE DATABASE userdb;
-\connect userdb
-CREATE TABLE t (a int);
-INSERT INTO t VALUES (1);
-SELECT * FROM t;
-EOT
-) - <<EOT
- server_version_num
---------------------
- 150002
-(1 row)
-
- h  |    r    |     v1      | v2  |     v3      |    v4
-----+---------+-------------+-----+-------------+-----------
-  1 | a       |  5000000000 | abc | {"a": 3.5}  | {1,2,3}
-  1 | b       | -5000000000 | def | {"b": 5}    | {1,1,2,3}
-  2 | a       |  5000000000 | ghi | {"c": 30}   | {1,4,9}
- 11 | eleven  |          11 | 11  | {"num": 11} | {11}
- 15 | fifteen |           1 | 15  | {"num": 15} | {15}
-(5 rows)
-
-CREATE INDEX
-                QUERY PLAN
--------------------------------------------
- Finalize Aggregate
-   ->  Index Only Scan using t_v1_idx on t
-         Index Cond: (v1 = 11)
-         Partial Aggregate: true
-(4 rows)
-
- count
--------
-     1
-(1 row)
-
-CREATE DATABASE
-You are now connected to database "userdb" as user "yugabyte".
-CREATE TABLE
-INSERT 0 1
- a
----
- 1
-(1 row)
-
-EOT
diff --git a/pg15_tests/test_upgrade_dropped_col.sh b/pg15_tests/test_upgrade_dropped_col.sh
deleted file mode 100755
index 798b103e93..0000000000
--- a/pg15_tests/test_upgrade_dropped_col.sh
+++ /dev/null
@@ -1,127 +0,0 @@
-#!/usr/bin/env bash
-source "${BASH_SOURCE[0]%/*}"/common.sh
-source "${BASH_SOURCE[0]%/*}"/common_upgrade.sh
-
-run_and_pushd_pg11
-
-# Create pre-existing PG11 table
-ysqlsh <<EOT
-CREATE TABLE t (a int, b int, c int);
-INSERT INTO t VALUES (10, 20, 30), (100, 200, 300);
-ALTER TABLE t DROP COLUMN b;
-ALTER TABLE t ADD COLUMN d int;
-ALTER TABLE t ADD COLUMN e text DEFAULT 'foo';
-INSERT INTO t VALUES (1000, 3000, 4000);
-SELECT attname, attnum FROM pg_attribute WHERE attrelid = 't'::pg_catalog.regclass AND attnum >= 0;
-
-CREATE TABLE t2 (a2 int, b2 int, c2 int, d2 int, PRIMARY KEY(d2 HASH, a2 ASC));
-ALTER TABLE t2 DROP COLUMN b2;
-INSERT INTO t2 VALUES (2, 2000, 1);
-SELECT attname, attnum FROM pg_attribute WHERE attrelid = 't2'::pg_catalog.regclass AND attnum >= 0;
-EOT
-
-popd
-upgrade_masters_run_ysql_catalog_upgrade
-
-restart_node_2_in_pg15
-
-# Demonstrate simultaneous access for DMLs involving the dropped and added columns, before the
-# upgrade has been finalized.
-
-# Insert from PG15
-diff <(ysqlsh 2 <<EOT | sed 's/ *$//'
-SHOW server_version_num;
-INSERT INTO t VALUES (15, 150, 1500);
-SELECT * FROM t ORDER BY c;
-SELECT attname, attnum FROM pg_attribute WHERE attrelid = 't'::pg_catalog.regclass AND attnum >= 0;
-
-SELECT * FROM t2;
-SELECT attname, attnum FROM pg_attribute WHERE attrelid = 't2'::pg_catalog.regclass AND attnum >= 0;
-EOT
-) - <<EOT
- server_version_num
---------------------
- 150002
-(1 row)
-
-INSERT 0 1
-  a   |  c   |  d   |  e
-------+------+------+-----
-   10 |   30 |      | foo
-   15 |  150 | 1500 | foo
-  100 |  300 |      | foo
- 1000 | 3000 | 4000 | foo
-(4 rows)
-
-           attname            | attnum
-------------------------------+--------
- a                            |      1
- ........pg.dropped.2........ |      2
- c                            |      3
- d                            |      4
- e                            |      5
-(5 rows)
-
- a2 |  c2  | d2
-----+------+----
-  2 | 2000 |  1
-(1 row)
-
-           attname            | attnum
-------------------------------+--------
- a2                           |      1
- ........pg.dropped.2........ |      2
- c2                           |      3
- d2                           |      4
-(4 rows)
-
-EOT
-# Insert from PG11, and note the PG15 insertion is visible
-diff <(ysqlsh <<EOT | sed 's/ *$//'
-SHOW server_version_num;
-INSERT INTO t VALUES (11, 110, 1100);
-SELECT * FROM t ORDER BY c;
-SELECT attname, attnum FROM pg_attribute WHERE attrelid = 't'::pg_catalog.regclass AND attnum >= 0;
-
-SELECT * FROM t2;
-SELECT attname, attnum FROM pg_attribute WHERE attrelid = 't2'::pg_catalog.regclass AND attnum >= 0;
-EOT
-) - <<EOT
- server_version_num
---------------------
- 110002
-(1 row)
-
-INSERT 0 1
-  a   |  c   |  d   |  e
-------+------+------+-----
-   10 |   30 |      | foo
-   11 |  110 | 1100 | foo
-   15 |  150 | 1500 | foo
-  100 |  300 |      | foo
- 1000 | 3000 | 4000 | foo
-(5 rows)
-
-           attname            | attnum
-------------------------------+--------
- a                            |      1
- ........pg.dropped.2........ |      2
- c                            |      3
- d                            |      4
- e                            |      5
-(5 rows)
-
- a2 |  c2  | d2
-----+------+----
-  2 | 2000 |  1
-(1 row)
-
-           attname            | attnum
-------------------------------+--------
- a2                           |      1
- ........pg.dropped.2........ |      2
- c2                           |      3
- d2                           |      4
-(4 rows)
-
-EOT
diff --git a/pg15_tests/test_upgrade_globals.sh b/pg15_tests/test_upgrade_globals.sh
deleted file mode 100755
index 6d7da8f91c..0000000000
--- a/pg15_tests/test_upgrade_globals.sh
+++ /dev/null
@@ -1,163 +0,0 @@
-#!/usr/bin/env bash
-source "${BASH_SOURCE[0]%/*}"/common.sh
-source "${BASH_SOURCE[0]%/*}"/common_upgrade.sh
-
-run_and_pushd_pg11
-
-# Create pre-existing PG11 cluster with various global objects
-ysqlsh <<EOT
-SHOW server_version;
--- Roles
-CREATE ROLE alice LOGIN;
-CREATE ROLE bob LOGIN;
-
--- Role membership
-CREATE ROLE carol IN ROLE alice LOGIN;
-
-\c yugabyte alice
-CREATE TABLE t (a int);
-
--- Tablespace
-\c yugabyte yugabyte
-CREATE TABLESPACE ts LOCATION '/invalid';
-CREATE TABLE t2 (b int) TABLESPACE ts;
-EOT
-
-popd
-upgrade_masters_run_ysql_catalog_upgrade
-restart_node_2_in_pg15
-
-# Check that from pg15, we can connect as alice, bob, and carol. alice can see her own table. carol
-# can also see it, with her role membership in role alice. bob cannot see alice's table.
-# Also check that table t2 is in the correct tablespace.
-diff <(ysqlsh 2 -v "ON_ERROR_STOP=0" <<EOT | sed 's/ *$//'
-SHOW server_version_num;
-\c yugabyte alice
-SELECT * FROM t;
-\c yugabyte bob
-SELECT * FROM t;
-\c yugabyte carol
-SELECT * FROM t;
-\c yugabyte yugabyte
-SELECT * FROM t2;
-SELECT ts.spcname
-  FROM pg_tablespace ts
-  INNER JOIN pg_class c ON ts.oid = c.reltablespace
-  WHERE c.oid='t2'::regclass;
-EOT
-) - <<EOT
- server_version_num
---------------------
- 150002
-(1 row)
-
-You are now connected to database "yugabyte" as user "alice".
- a
----
-(0 rows)
-
-You are now connected to database "yugabyte" as user "bob".
-ERROR:  permission denied for table t
-You are now connected to database "yugabyte" as user "carol".
- a
----
-(0 rows)
-
-You are now connected to database "yugabyte" as user "yugabyte".
- b
----
-(0 rows)
-
- spcname
----------
- ts
-(1 row)
-
-EOT
-
-# Check the same from pg11 in mixed mode
-diff <(ysqlsh -v "ON_ERROR_STOP=0" <<EOT | sed 's/ *$//'
-SHOW server_version_num;
-\c yugabyte alice
-SELECT * FROM t;
-\c yugabyte bob
-SELECT * FROM t;
-\c yugabyte carol
-SELECT * FROM t;
-\c yugabyte yugabyte
-SELECT * FROM t2;
-SELECT ts.spcname
-  FROM pg_tablespace ts
-  INNER JOIN pg_class c ON ts.oid = c.reltablespace
-  WHERE c.oid='t2'::regclass;
-EOT
-) - <<EOT
- server_version_num
---------------------
- 110002
-(1 row)
-
-You are now connected to database "yugabyte" as user "alice".
- a
----
-(0 rows)
-
-You are now connected to database "yugabyte" as user "bob".
-ERROR:  permission denied for table t
-You are now connected to database "yugabyte" as user "carol".
- a
----
-(0 rows)
-
-You are now connected to database "yugabyte" as user "yugabyte".
- b
----
-(0 rows)
-
- spcname
----------
- ts
-(1 row)
-
-EOT
-
-# Upgrade is complete. After the restart, check the same conditions.
-yb_ctl restart
-diff <(ysqlsh -v "ON_ERROR_STOP=0" <<EOT | sed 's/ *$//'
-\c yugabyte alice
-SELECT * FROM t;
-\c yugabyte bob
-SELECT * FROM t;
-\c yugabyte carol
-SELECT * FROM t;
-\c yugabyte yugabyte
-SELECT * FROM t2;
-SELECT ts.spcname
-  FROM pg_tablespace ts
-  INNER JOIN pg_class c ON ts.oid = c.reltablespace
-  WHERE c.oid='t2'::regclass;
-EOT
-) - <<EOT
-You are now connected to database "yugabyte" as user "alice".
- a
----
-(0 rows)
-
-You are now connected to database "yugabyte" as user "bob".
-ERROR:  permission denied for table t
-You are now connected to database "yugabyte" as user "carol".
- a
----
-(0 rows)
-
-You are now connected to database "yugabyte" as user "yugabyte".
- b
----
-(0 rows)
-
- spcname
----------
- ts
-(1 row)
-
-EOT
diff --git a/pg15_tests/test_upgrade_preflight.sh b/pg15_tests/test_upgrade_preflight.sh
deleted file mode 100755
index 1bcafe665a..0000000000
--- a/pg15_tests/test_upgrade_preflight.sh
+++ /dev/null
@@ -1,127 +0,0 @@
-#!/usr/bin/env bash
-source "${BASH_SOURCE[0]%/*}"/common.sh
-source "${BASH_SOURCE[0]%/*}"/common_upgrade.sh
-
-run_and_pushd_pg11
-popd
-
-# Run preflight checks. The check should pass by default.
-run_preflight_checks
-
-# Disallow connections on the 'postgres' database
-ysqlsh <<EOT
-ALTER DATABASE postgres WITH allow_connections FALSE;
-EOT
-
-# Check failure
-grep -q "All non-template0 databases must allow connections" \
-  <(run_preflight_checks 2>&1)
-
-# Re-enable connections on the 'postgres' database
-ysqlsh <<EOT
-ALTER DATABASE postgres WITH allow_connections TRUE;
-EOT
-
-# Create table using pg_authid (a system-defined composite type)
-ysqlsh <<EOT
-CREATE TABLE system_composite_test (id int primary key, authid pg_authid);
-INSERT INTO system_composite_test VALUES (1, null);
-EOT
-
-# Check failure
-grep -q "Your installation contains system-defined composite type(s) in user tables." \
-  <(run_preflight_checks 2>&1)
-
-# Drop table using pg_authid
-ysqlsh <<EOT
-DROP TABLE system_composite_test;
-EOT
-
-# Use regproc in a table
-ysqlsh <<EOT
-CREATE TABLE reg_check (id int primary key, reg_field regproc);
-INSERT INTO reg_check VALUES (1, 1);
-SELECT * from reg_check;
-EOT
-
-# Check failure
-grep -q "Your installation contains one of the reg\*" \
-  <(run_preflight_checks 2>&1)
-
-# Drop table with regproc
-ysqlsh <<EOT
-DROP TABLE reg_check;
-EOT
-
-# Create a postfix operator
-ysqlsh << 'EOT'
-CREATE FUNCTION ident(integer)
-RETURNS integer
-AS $$
-BEGIN
-    RETURN $1;
-END;
-$$ LANGUAGE plpgsql;
-
-CREATE OPERATOR !!! (
-    LEFTARG = integer,
-    PROCEDURE = ident
-);
-EOT
-
-# Check failure
-grep -q "Your installation contains user-defined postfix operators" \
-  <(run_preflight_checks 2>&1)
-
-# Drop the postfix operator
-ysqlsh <<EOT
-DROP FUNCTION ident(integer) CASCADE;
-EOT
-
-# Use anyarray/anyelement in polymorphic function
-ysqlsh <<EOT
-CREATE AGGREGATE array_accum (ANYELEMENT)
-(
-    sfunc = array_append,
-    stype = ANYARRAY,
-    initcond = '{}'
-);
-
-CREATE TABLE polymorph_table (
-    id SERIAL PRIMARY KEY,
-    data TEXT
-);
-
-INSERT INTO polymorph_table (data) VALUES
-    ('apple'), ('banana'), ('cherry'), ('orange');
-
-SELECT array_accum(data) AS data_array FROM polymorph_table;
-EOT
-
-# Check failure
-grep -qE "Checking for incompatible polymorphic functions\s+fatal" \
-  <(run_preflight_checks 2>&1)
-
-# Drop polymorph_table
-ysqlsh <<EOT
-DROP TABLE polymorph_table;
-DROP AGGREGATE array_accum (ANYELEMENT);
-EOT
-
-# Create table using sql_identifier
-ysqlsh <<EOT
-CREATE TABLE sql_identifier_test (id int primary key, d information_schema.sql_identifier);
-INSERT INTO sql_identifier_test VALUES (1, 'test');
-EOT
-
-# Check failure
-grep -q "Your installation contains the \"sql_identifier\"" \
-  <(run_preflight_checks 2>&1)
-
-# Drop table using sql_identifier
-ysqlsh <<EOT
-DROP TABLE sql_identifier_test;
-EOT
-
-# Run preflight checks again. The final check should pass.
-run_preflight_checks
diff --git a/src/postgres/src/bin/pg_upgrade/check.c b/src/postgres/src/bin/pg_upgrade/check.c
index d9878374bc..b01c343089 100644
--- a/src/postgres/src/bin/pg_upgrade/check.c
+++ b/src/postgres/src/bin/pg_upgrade/check.c
@@ -118,14 +118,15 @@ check_and_dump_old_cluster(bool live_check)
 		yb_check_system_databases_exist(old_cluster_conn);
 
 		PQfinish(old_cluster_conn);
-		check_ok();
 	}
 
 	/* Extract a list of databases and tables from the old cluster */
 	get_db_and_rel_infos(&old_cluster);
 
 	/* Enable these checks and other functions to initialize new node */
-	init_tablespaces();
+	if (!is_yugabyte_enabled())
+		/* Yugabyte does not support tablespace directories */
+		init_tablespaces();
 
 	get_loadable_libraries();
 
@@ -133,7 +134,9 @@ check_and_dump_old_cluster(bool live_check)
 	/*
 	 * Check for various failure cases
 	 */
-	check_is_install_user(&old_cluster);
+	if (!is_yugabyte_enabled())
+		/* In Yugabyte this is handled by yb_check_yugabyte_user */
+		check_is_install_user(&old_cluster);
 	check_proper_datallowconn(&old_cluster);
 	if (!is_yugabyte_enabled())
 		/* Yugabyte does not support prepared transactions, see #1125 */
@@ -141,7 +144,9 @@ check_and_dump_old_cluster(bool live_check)
 	check_for_composite_data_type_usage(&old_cluster);
 	check_for_reg_data_type_usage(&old_cluster);
 
-	check_for_isn_and_int8_passing_mismatch(&old_cluster);
+	if (!is_yugabyte_enabled())
+		/* YB: See comment above call to check_cluster_compatibility */
+		check_for_isn_and_int8_passing_mismatch(&old_cluster);
 
 	/*
 	 * PG 14 changed the function signature of encoding conversion functions.
@@ -173,8 +178,9 @@ check_and_dump_old_cluster(bool live_check)
 	/*
 	 * Pre-PG 12 allowed tables to be declared WITH OIDS, which is not
 	 * supported anymore. Verify there are none, iff applicable.
+	 * In Yugabyte, this was not allowed.
 	 */
-	if (GET_MAJOR_VERSION(old_cluster.major_version) <= 1100)
+	if (!is_yugabyte_enabled() && GET_MAJOR_VERSION(old_cluster.major_version) <= 1100)
 		check_for_tables_with_oids(&old_cluster);
 
 	/*
@@ -209,6 +215,9 @@ check_and_dump_old_cluster(bool live_check)
 	if (!is_yugabyte_enabled() && GET_MAJOR_VERSION(old_cluster.major_version) <= 903)
 		old_9_3_check_for_line_data_type_usage(&old_cluster);
 
+	if (yb_has_check_fatal)
+		pg_fatal("\n");
+
 	/*
 	 * While not a check option, we do this now because this is the only time
 	 * the old server is running.
@@ -229,9 +238,7 @@ check_new_cluster(void)
 	check_new_cluster_is_empty();
 	check_databases_are_compatible();
 
-	if (!is_yugabyte_enabled())
-		/* YB: would fail with ERROR:  LOAD not supported yet. */
-		check_loadable_libraries();
+	check_loadable_libraries();
 
 	switch (user_opts.transfer_mode)
 	{
@@ -706,14 +713,6 @@ create_script_for_old_cluster_deletion(char **deletion_script_file_name)
 static void
 check_is_install_user(ClusterInfo *cluster)
 {
-	if (is_yugabyte_enabled())
-		/*
-		 * YB: Since there are a few different yugabyte users that might run the
-		 * upgrade, we disable this check rather than trying to modify it to
-		 * work for every possible YB case.
-		 */
-		return;
-
 	PGresult   *res;
 	PGconn	   *conn = connectToServer(cluster, "template1");
 
@@ -824,7 +823,7 @@ check_proper_datallowconn(ClusterInfo *cluster)
 					pg_fatal("could not open file \"%s\": %s\n",
 							 output_path, strerror(errno));
 
-				fprintf(script, "%s\n", datname);
+				yb_fprintf_and_log(script, "%s\n", datname);
 			}
 		}
 	}
@@ -838,13 +837,14 @@ check_proper_datallowconn(ClusterInfo *cluster)
 
 	if (found)
 	{
-		pg_log(PG_REPORT, "fatal\n");
-		pg_fatal("All non-template0 databases must allow connections, i.e. their\n"
+		if (!is_yugabyte_enabled())
+			pg_log(PG_REPORT, "fatal\n");
+		yb_fatal("All non-template0 databases must allow connections, i.e. their\n"
 				 "pg_database.datallowconn must be true.  Your installation contains\n"
 				 "non-template0 databases with their pg_database.datallowconn set to\n"
 				 "false.  Consider allowing connection for all non-template0 databases\n"
 				 "or drop the databases which do not allow connections.  A list of\n"
-				 "databases with the problem is in the file:\n"
+				 "databases with the problem is printed above and in the file:\n"
 				 "    %s\n\n", output_path);
 	}
 	else
@@ -1044,10 +1044,10 @@ check_for_user_defined_postfix_ops(ClusterInfo *cluster)
 						 output_path, strerror(errno));
 			if (!db_used)
 			{
-				fprintf(script, "In database: %s\n", active_db->db_name);
+				yb_fprintf_and_log(script, "In database: %s\n", active_db->db_name);
 				db_used = true;
 			}
-			fprintf(script, "  (oid=%s) %s.%s (%s.%s, NONE)\n",
+			yb_fprintf_and_log(script, "  (oid=%s) %s.%s (%s.%s, NONE)\n",
 					PQgetvalue(res, rowno, i_oproid),
 					PQgetvalue(res, rowno, i_oprnsp),
 					PQgetvalue(res, rowno, i_oprname),
@@ -1065,11 +1065,12 @@ check_for_user_defined_postfix_ops(ClusterInfo *cluster)
 
 	if (found)
 	{
-		pg_log(PG_REPORT, "fatal\n");
-		pg_fatal("Your installation contains user-defined postfix operators, which are not\n"
+		if (!is_yugabyte_enabled())
+			pg_log(PG_REPORT, "fatal\n");
+		yb_fatal("Your installation contains user-defined postfix operators, which are not\n"
 				 "supported anymore.  Consider dropping the postfix operators and replacing\n"
 				 "them with prefix operators or function calls.\n"
-				 "A list of user-defined postfix operators is in the file:\n"
+				 "A list of user-defined postfix operators is printed above and in the file:\n"
 				 "    %s\n\n", output_path);
 	}
 	else
@@ -1175,11 +1176,11 @@ check_for_incompatible_polymorphics(ClusterInfo *cluster)
 						 output_path, strerror(errno));
 			if (!db_used)
 			{
-				fprintf(script, "In database: %s\n", active_db->db_name);
+				yb_fprintf_and_log(script, "In database: %s\n", active_db->db_name);
 				db_used = true;
 			}
 
-			fprintf(script, "  %s: %s\n",
+			yb_fprintf_and_log(script, "  %s: %s\n",
 					PQgetvalue(res, rowno, i_objkind),
 					PQgetvalue(res, rowno, i_objname));
 		}
@@ -1191,13 +1192,14 @@ check_for_incompatible_polymorphics(ClusterInfo *cluster)
 	if (script)
 	{
 		fclose(script);
-		pg_log(PG_REPORT, "fatal\n");
-		pg_fatal("Your installation contains user-defined objects that refer to internal\n"
+		if (!is_yugabyte_enabled())
+			pg_log(PG_REPORT, "fatal\n");
+		yb_fatal("Your installation contains user-defined objects that refer to internal\n"
 				 "polymorphic functions with arguments of type \"anyarray\" or \"anyelement\".\n"
 				 "These user-defined objects must be dropped before upgrading and restored\n"
 				 "afterwards, changing them to refer to the new corresponding functions with\n"
 				 "arguments of type \"anycompatiblearray\" and \"anycompatible\".\n"
-				 "A list of the problematic objects is in the file:\n"
+				 "A list of the problematic objects is printed above and in the file:\n"
 				 "    %s\n\n", output_path);
 	}
 	else
@@ -1331,12 +1333,13 @@ check_for_composite_data_type_usage(ClusterInfo *cluster)
 
 	if (found)
 	{
-		pg_log(PG_REPORT, "fatal\n");
-		pg_fatal("Your installation contains system-defined composite type(s) in user tables.\n"
+		if (!is_yugabyte_enabled())
+			pg_log(PG_REPORT, "fatal\n");
+		yb_fatal("Your installation contains system-defined composite type(s) in user tables.\n"
 				 "These type OIDs are not stable across PostgreSQL versions,\n"
 				 "so this cluster cannot currently be upgraded.  You can\n"
 				 "drop the problem columns and restart the upgrade.\n"
-				 "A list of the problem columns is in the file:\n"
+				 "A list of the problem columns is printed above and in the file:\n"
 				 "    %s\n\n", output_path);
 	}
 	else
@@ -1392,12 +1395,13 @@ check_for_reg_data_type_usage(ClusterInfo *cluster)
 
 	if (found)
 	{
-		pg_log(PG_REPORT, "fatal\n");
-		pg_fatal("Your installation contains one of the reg* data types in user tables.\n"
+		if (!is_yugabyte_enabled())
+			pg_log(PG_REPORT, "fatal\n");
+		yb_fatal("Your installation contains one of the reg* data types in user tables.\n"
 				 "These data types reference system OIDs that are not preserved by\n"
 				 "pg_upgrade, so this cluster cannot currently be upgraded.  You can\n"
 				 "drop the problem columns and restart the upgrade.\n"
-				 "A list of the problem columns is in the file:\n"
+				 "A list of the problem columns is printed above and in the file:\n"
 				 "    %s\n\n", output_path);
 	}
 	else
@@ -1652,8 +1656,6 @@ yb_check_user_attributes(PGconn *old_cluster_conn, const char *user_name,
 	const char **role_attr;
 	bool		first_attribute = true;
 
-	prep_status("Checking '%s' user attributes", user_name);
-
 	initPQExpBuffer(&buf);
 	for (role_attr = role_attrs; *role_attr != NULL; role_attr++)
 	{
@@ -1679,7 +1681,6 @@ yb_check_user_attributes(PGconn *old_cluster_conn, const char *user_name,
 
 	termPQExpBuffer(&buf);
 	PQclear(res);
-	check_ok();
 }
 
 /*
@@ -1701,7 +1702,9 @@ yb_check_yugabyte_user(PGconn *old_cluster_conn)
 		NULL,
 	};
 
+	prep_status("Checking attributes of the 'yugabyte' user");
 	yb_check_user_attributes(old_cluster_conn, "yugabyte", role_attrs);
+	check_ok();
 }
 
 /*
@@ -1712,11 +1715,14 @@ yb_check_yugabyte_user(PGconn *old_cluster_conn)
 static void
 yb_check_old_cluster_user(PGconn *old_cluster_conn)
 {
-	prep_status("Checking attributes of the user used to access the old "
-				"cluster");
-
 	static const char *role_attributes[] = {"rolsuper", "rolcanlogin", NULL};
 
+	/* yugabyte user is checked in yb_check_yugabyte_user */
+	if (strcmp(old_cluster.yb_user, "yugabyte") == 0)
+		return;
+
+	prep_status("Checking attributes of the '%s' user", old_cluster.yb_user);
 	yb_check_user_attributes(old_cluster_conn, old_cluster.yb_user,
 							 role_attributes);
+	check_ok();
 }
diff --git a/src/postgres/src/bin/pg_upgrade/pg_upgrade.c b/src/postgres/src/bin/pg_upgrade/pg_upgrade.c
index 50cc63b469..6c4cf47e90 100644
--- a/src/postgres/src/bin/pg_upgrade/pg_upgrade.c
+++ b/src/postgres/src/bin/pg_upgrade/pg_upgrade.c
@@ -167,7 +167,7 @@ main(int argc, char **argv)
 	/*
 	 * YB: If this is run as a preflight check, the new cluster is not yet started.
 	 */
-	if (!is_yugabyte_enabled() || !user_opts.check)
+	if (!is_yugabyte_enabled())
 		check_new_cluster();
 
 	report_clusters_compatible();
diff --git a/src/postgres/src/bin/pg_upgrade/pg_upgrade.h b/src/postgres/src/bin/pg_upgrade/pg_upgrade.h
index 20decfb1f5..b46627756d 100644
--- a/src/postgres/src/bin/pg_upgrade/pg_upgrade.h
+++ b/src/postgres/src/bin/pg_upgrade/pg_upgrade.h
@@ -333,6 +333,7 @@ extern ClusterInfo old_cluster,
 			new_cluster;
 extern OSInfo os_info;
 
+extern bool yb_has_check_fatal;
 
 /* check.c */
 
@@ -444,8 +445,9 @@ void		prep_status(const char *fmt,...) pg_attribute_printf(1, 2);
 void		prep_status_progress(const char *fmt,...) pg_attribute_printf(1, 2);
 unsigned int str2uint(const char *str);
 
-bool		is_yugabyte_enabled();
-
+extern bool is_yugabyte_enabled();
+extern int 	yb_fprintf_and_log(FILE *stream, const char *fmt, ...);
+extern void yb_fatal(const char *fmt, ...);
 
 /* version.c */
 
diff --git a/src/postgres/src/bin/pg_upgrade/util.c b/src/postgres/src/bin/pg_upgrade/util.c
index e4fbdb6eba..a502bdfb69 100644
--- a/src/postgres/src/bin/pg_upgrade/util.c
+++ b/src/postgres/src/bin/pg_upgrade/util.c
@@ -18,6 +18,8 @@ LogOpts		log_opts;
 
 static void pg_log_v(eLogType type, const char *fmt, va_list ap) pg_attribute_printf(2, 0);
 
+bool yb_current_check_failed = false;
+bool yb_has_check_fatal = false;
 
 /*
  * report_status()
@@ -119,6 +121,8 @@ prep_status(const char *fmt,...)
 	va_list		args;
 	char		message[MAX_STRING];
 
+	yb_current_check_failed = false;
+
 	va_start(args, fmt);
 	vsnprintf(message, sizeof(message), fmt, args);
 	va_end(args);
@@ -332,3 +336,40 @@ is_yugabyte_enabled()
 {
 	return true;
 }
+
+int
+yb_fprintf_and_log(FILE *stream, const char *fmt, ...)
+{
+	int len;
+	va_list args;
+
+	if (!yb_current_check_failed)
+	{
+		pg_log(PG_REPORT, "%s\n\n", "fatal");
+		yb_current_check_failed = true;
+	}
+
+	va_start(args, fmt);
+	pg_log_v(PG_REPORT, fmt, args);
+	va_end(args);
+
+	va_start(args, fmt);
+	len = pg_vfprintf(stream, fmt, args);
+	va_end(args);
+
+	return len;
+}
+
+void
+yb_fatal(const char *fmt, ...)
+{
+	va_list args;
+
+	pg_log(PG_REPORT, "\n");
+
+	va_start(args, fmt);
+	pg_log_v(user_opts.check ? PG_REPORT : PG_FATAL, fmt, args);
+	va_end(args);
+
+	yb_has_check_fatal = true;
+}
diff --git a/src/postgres/src/bin/pg_upgrade/version.c b/src/postgres/src/bin/pg_upgrade/version.c
index 20c61072a4..c20d4b6512 100644
--- a/src/postgres/src/bin/pg_upgrade/version.c
+++ b/src/postgres/src/bin/pg_upgrade/version.c
@@ -117,10 +117,10 @@ check_for_data_types_usage(ClusterInfo *cluster,
 						 strerror(errno));
 			if (!db_used)
 			{
-				fprintf(script, "In database: %s\n", active_db->db_name);
+				yb_fprintf_and_log(script, "In database: %s\n", active_db->db_name);
 				db_used = true;
 			}
-			fprintf(script, "  %s.%s.%s\n",
+			yb_fprintf_and_log(script, "  %s.%s.%s\n",
 					PQgetvalue(res, rowno, i_nspname),
 					PQgetvalue(res, rowno, i_relname),
 					PQgetvalue(res, rowno, i_attname));
@@ -375,12 +375,13 @@ old_11_check_for_sql_identifier_data_type_usage(ClusterInfo *cluster)
 	if (check_for_data_type_usage(cluster, "information_schema.sql_identifier",
 								  output_path))
 	{
-		pg_log(PG_REPORT, "fatal\n");
-		pg_fatal("Your installation contains the \"sql_identifier\" data type in user tables.\n"
+		if (!is_yugabyte_enabled())
+			pg_log(PG_REPORT, "fatal\n");
+		yb_fatal("Your installation contains the \"sql_identifier\" data type in user tables.\n"
 				 "The on-disk format for this data type has changed, so this\n"
 				 "cluster cannot currently be upgraded.  You can\n"
 				 "drop the problem columns and restart the upgrade.\n"
-				 "A list of the problem columns is in the file:\n"
+				 "A list of the problem columns is printed above and in the file:\n"
 				 "    %s\n\n", output_path);
 	}
 	else
diff --git a/src/yb/integration-tests/CMakeLists.txt b/src/yb/integration-tests/CMakeLists.txt
index 5ab2c4bc43..fe61a0c5e7 100644
--- a/src/yb/integration-tests/CMakeLists.txt
+++ b/src/yb/integration-tests/CMakeLists.txt
@@ -276,6 +276,7 @@ ADD_YB_TEST(upgrade-tests/ycql_only_upgrade-test)
 ADD_YB_TEST(upgrade-tests/ysql_major_upgrade_rpcs-test)
 ADD_YB_TEST(upgrade-tests/ysql_major_upgrade_ddl_blocking-test)
 ADD_YB_TEST(upgrade-tests/ysql_major_upgrade_matview-test)
+ADD_YB_TEST(upgrade-tests/ysql_major_upgrade_check-test)
 
 set(YB_TEST_LINK_LIBS_SAVED ${YB_TEST_LINK_LIBS})
 set(YB_TEST_LINK_LIBS ${YB_TEST_LINK_LIBS} cassandra)
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
index 74e3da9034..c5d427b763 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
@@ -11,8 +11,6 @@
 // under the License.
 //
 
-#include <regex>
-
 #include "yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h"
 
 #include "yb/util/backoff_waiter.h"
@@ -113,11 +111,6 @@ TEST_F(Pg15UpgradeTest, CheckVersion) {
 
   ysql_catalog_config = ASSERT_RESULT(DumpYsqlCatalogConfig());
   ASSERT_STR_CONTAINS(ysql_catalog_config, "catalog_version: 15");
-
-  // Running validation on the upgraded cluster should fail since its already on the higher version.
-  ASSERT_OK(ValidateUpgradeCompatibilityFailure(
-      "This version of the utility can only be used for checking YSQL version 11. The cluster is "
-      "currently on YSQL version 15"));
 }
 
 TEST_F(Pg15UpgradeTest, SimpleTableUpgrade) { ASSERT_OK(TestUpgradeWithSimpleTable()); }
@@ -1297,10 +1290,7 @@ class Pg15UpgradeSequenceTest : public Pg15UpgradeTest {
   Pg15UpgradeSequenceTest() = default;
 
   void SetUp() override {
-    Pg15UpgradeTest::SetUp();
-    if (Test::IsSkipped()) {
-      return;
-    }
+    TEST_SETUP_SUPER(Pg15UpgradeTest);
 
     ASSERT_OK(cluster_->AddAndSetExtraFlag("ysql_sequence_cache_minval", "1"));
     // As documented in the daemon->AddExtraFlag call, a restart is required to apply the flag.
@@ -1441,23 +1431,6 @@ TEST_F(Pg15UpgradeTest, YbGinIndex) {
   }
 }
 
-TEST_F(Pg15UpgradeTest, CheckUpgradeCompatibilityGuc) {
-  // Whether or not yb_major_version_upgrade_compatibility is enabled, pg_upgrade --check will not
-  // error.
-  ASSERT_OK(cluster_->AddAndSetExtraFlag("ysql_yb_major_version_upgrade_compatibility", "11"));
-  ASSERT_OK(ValidateUpgradeCompatibility());
-
-  ASSERT_OK(cluster_->AddAndSetExtraFlag("ysql_yb_major_version_upgrade_compatibility", "0"));
-  ASSERT_OK(ValidateUpgradeCompatibility());
-
-  // However, when we actually run the YSQL upgrade, pg_upgrade will error since now
-  // ysql_yb_major_version_upgrade_compatibility is not set.
-  auto log_waiter =
-      cluster_->GetMasterLogWaiter("yb_major_version_upgrade_compatibility must be set to 11");
-  ASSERT_NOK_STR_CONTAINS(UpgradeClusterToMixedMode(), kPgUpgradeFailedError);
-  ASSERT_TRUE(log_waiter.IsEventOccurred());
-}
-
 TEST_F(Pg15UpgradeSequenceTest, Sequences) {
   ASSERT_OK(ExecuteStatement(Format("CREATE SEQUENCE $0", kSequencePg11)));
 
@@ -1524,74 +1497,103 @@ TEST_F(Pg15UpgradeSequenceTest, IdentityColumn) {
   }
 }
 
-TEST_F(Pg15UpgradeTest, UsersAndRoles) {
-  auto escape_single_quote = [](const std::string& str) {
-    return std::regex_replace(str, std::regex("'"), "''");
-  };
-  auto escape_double_quote = [](const std::string& str) {
-    return std::regex_replace(str, std::regex("\""), "\"\"");
+TEST_F(Pg15UpgradeTest, BasicTablespace) {
+  const auto tablespace_name = "ts1";
+  const auto table_name = "tbl1";
+  {
+    auto conn = ASSERT_RESULT(cluster_->ConnectToDB());
+    ASSERT_OK(conn.ExecuteFormat("CREATE TABLESPACE $0 LOCATION '/invalid'", tablespace_name));
+    ASSERT_OK(
+        conn.ExecuteFormat("CREATE TABLE $0 (a int) TABLESPACE $1", table_name, tablespace_name));
+  }
+  const auto check_tablespace = [&]() -> Status {
+    auto conn = VERIFY_RESULT(cluster_->ConnectToDB());
+    auto tblspace_name_result = VERIFY_RESULT(conn.FetchRow<std::string>(Format(
+        "SELECT spcname FROM pg_tablespace ts "
+        "INNER JOIN pg_class pg_c ON pg_c.reltablespace = ts.oid "
+        "WHERE pg_c.relname = '$0'",
+        table_name)));
+    SCHECK_EQ(tblspace_name_result, tablespace_name, IllegalState, "Tablespace name mismatch");
+
+    return Status::OK();
   };
 
-  auto ts = cluster_->tablet_server(0);
+  ASSERT_OK(check_tablespace());
 
-  // Make sure pg_upgrade --check fails if the yugabyte user is not a superuser.
-  {
-    const auto postgres_user = "postgres";
-    const auto pg_conn_settings = pgwrapper::PGConnSettings{
-        .host = ts->bind_host(),
-        .port = ts->ysql_port(),
-        .dbname = "yugabyte",
-        .user = postgres_user};
-
-    auto pg_conn = ASSERT_RESULT(pgwrapper::PGConnBuilder(pg_conn_settings).Connect());
-    ASSERT_OK(pg_conn.Execute("DROP USER yugabyte"));
-    ASSERT_OK(ValidateUpgradeCompatibilityFailure("The 'yugabyte' user is missing", postgres_user));
-
-    ASSERT_OK(pg_conn.Execute("CREATE USER yugabyte"));
-
-    ASSERT_OK(ValidateUpgradeCompatibilityFailure(
-        "The 'yugabyte' user is missing the 'rolsuper' attribute", postgres_user));
-
-    ASSERT_OK(pg_conn.Execute("DROP USER yugabyte"));
-    ASSERT_OK(pg_conn.Execute(
-        "CREATE USER yugabyte SUPERUSER INHERIT CREATEROLE CREATEDB LOGIN REPLICATION BYPASSRLS"));
-    ASSERT_OK(ValidateUpgradeCompatibility(postgres_user));
-  }
+  ASSERT_OK(UpgradeClusterToCurrentVersion(kNoDelayBetweenNodes));
+
+  ASSERT_OK(check_tablespace());
+}
+
+TEST_F(Pg15UpgradeTest, DroppedColumnTest) {
+  const auto insert_stmt = "INSERT INTO t VALUES ($0)";
+  const auto kT1SelectStmt = "SELECT * FROM t ORDER BY a";
+  const auto kT2SelectStmt = "SELECT * FROM t2 ORDER BY a2";
+  std::string t1_expected_rows = "1, 3, NULL, foo; 11, 13, NULL, foo; 21, 23, 24, foo";
+  size_t next_row = 30;
+  const auto kT2ExpectedRows = "2, 2000, 1";
 
-  // Change the yugabyte password to make sure if works after the upgrade.
-  // Including quotes in password to make sure it works.
-  const auto new_yb_password = "yb_\"secure\"\"_'pass''";
   {
-    // Escape single quotes in the sql string.
-    ASSERT_OK(ExecuteStatement(
-        Format("ALTER USER yugabyte PASSWORD '$0'", escape_single_quote(new_yb_password))));
+    auto conn = ASSERT_RESULT(cluster_->ConnectToDB());
+    ASSERT_OK(conn.Execute("CREATE TABLE t (a int, b int, c int)"));
+    ASSERT_OK(conn.ExecuteFormat(insert_stmt, "1, 2, 3"));
+    ASSERT_OK(conn.ExecuteFormat(insert_stmt, "11, 12, 13"));
+    ASSERT_OK(conn.Execute("ALTER TABLE t DROP COLUMN b"));
+    ASSERT_OK(conn.Execute("ALTER TABLE t ADD COLUMN d int"));
+    ASSERT_OK(conn.Execute("ALTER TABLE t ADD COLUMN e text DEFAULT 'foo'"));
+    ASSERT_OK(conn.ExecuteFormat(insert_stmt, "21, 23, 24"));
+
+    auto result = ASSERT_RESULT(conn.FetchAllAsString(kT1SelectStmt));
+    ASSERT_EQ(result, t1_expected_rows);
+
+    ASSERT_OK(conn.Execute(
+        "CREATE TABLE t2 (a2 int, b2 int, c2 int, d2 int, PRIMARY KEY(d2 HASH, a2 ASC))"));
+    ASSERT_OK(conn.Execute("ALTER TABLE t2 DROP COLUMN b2"));
+    ASSERT_OK(conn.Execute("INSERT INTO t2 VALUES (2, 2000, 1)"));
   }
 
-  const auto conn_settings = pgwrapper::PGConnSettings{
-      .host = ts->bind_host(),
-      .port = ts->ysql_port(),
-      .dbname = "yugabyte",
-      .user = "yugabyte",
-      .password = escape_double_quote(new_yb_password)};
+  auto run_validations = [&](std::optional<size_t> ts_id = std::nullopt) -> Status {
+    const auto kT1ExpectedCols = "a, 1; ........pg.dropped.2........, 2; c, 3; d, 4; e, 5";
+    const auto kT2ExpectedCols = "a2, 1; ........pg.dropped.2........, 2; c2, 3; d2, 4";
 
-  auto conn = ASSERT_RESULT(pgwrapper::PGConnBuilder(conn_settings).Connect());
+    auto conn = VERIFY_RESULT(CreateConnToTs(ts_id));
+    auto result = VERIFY_RESULT(
+        conn.FetchAllAsString("SELECT attname, attnum FROM pg_attribute WHERE attrelid = "
+                              "'t'::pg_catalog.regclass AND attnum >= 0 ORDER BY attnum"));
+    SCHECK_EQ(result, kT1ExpectedCols, IllegalState, "t1 validation failed");
 
-  // Create users with special characters in their names.
-  auto special_role_names = {"user with space", "user_\"_with_\"\"_different' quotes''"};
-  for (const auto& role_name : special_role_names) {
-    // Escape double quotes in the sql string.
-    ASSERT_OK(conn.ExecuteFormat("CREATE ROLE \"$0\"", escape_double_quote(role_name)));
-  }
+    result = VERIFY_RESULT(
+        conn.FetchAllAsString("SELECT attname, attnum FROM pg_attribute WHERE attrelid = "
+                              "'t2'::pg_catalog.regclass AND attnum >= 0"));
+    SCHECK_EQ(result, kT2ExpectedCols, IllegalState, "t2 validation failed");
 
-  ASSERT_OK(UpgradeClusterToCurrentVersion(kNoDelayBetweenNodes));
+    result = VERIFY_RESULT(conn.FetchAllAsString(kT2SelectStmt));
+    SCHECK_EQ(result, kT2ExpectedRows, IllegalState, "Mismatch in t2 rows");
 
-  conn = ASSERT_RESULT(pgwrapper::PGConnBuilder(conn_settings).Connect());
-  for (const auto& role_name : special_role_names) {
-    LOG(INFO) << "Checking role: " << role_name;
-    auto res_role_name = ASSERT_RESULT(conn.FetchRow<std::string>(Format(
-        "SELECT rolname FROM pg_roles WHERE rolname = '$0'", escape_single_quote(role_name))));
-    ASSERT_STR_EQ(role_name, res_role_name);
-  }
+    result = VERIFY_RESULT(conn.FetchAllAsString(kT1SelectStmt));
+    SCHECK_EQ(result, t1_expected_rows, IllegalState, "Mismatch in t1 rows");
+
+    const auto next_value = Format("$0, $1, $2", next_row + 1, next_row + 3, next_row + 4);
+    next_row += 10;
+    RETURN_NOT_OK(conn.ExecuteFormat(insert_stmt, next_value));
+    t1_expected_rows += Format("; $0, foo", next_value);
+
+    result = VERIFY_RESULT(conn.FetchAllAsString(kT1SelectStmt));
+    SCHECK_EQ(result, t1_expected_rows, IllegalState, "Mismatch in t1 rows after insert");
+
+    return Status::OK();
+  };
+
+  ASSERT_OK(run_validations());
+
+  ASSERT_OK(UpgradeClusterToMixedMode());
+
+  ASSERT_OK(run_validations(kMixedModeTserverPg11));
+  ASSERT_OK(run_validations(kMixedModeTserverPg15));
+
+  ASSERT_OK(FinalizeUpgradeFromMixedMode());
+
+  ASSERT_OK(run_validations());
 }
 
 }  // namespace yb
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.cc b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.cc
index 6efaf4e908..68bf8dd738 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.cc
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.cc
@@ -28,10 +28,8 @@ using namespace std::chrono_literals;
 namespace yb {
 
 void Pg15UpgradeTestBase::SetUp() {
-  UpgradeTestBase::SetUp();
-  if (Test::IsSkipped()) {
-    return;
-  }
+  TEST_SETUP_SUPER(UpgradeTestBase);
+
   CHECK_OK_PREPEND(StartClusterInOldVersion(), "Failed to start cluster in old version");
   CHECK(IsYsqlMajorVersionUpgrade());
   CHECK_GT(cluster_->num_tablet_servers(), 1);
@@ -61,22 +59,33 @@ Status Pg15UpgradeTestBase::ValidateUpgradeCompatibility(const std::string& user
 }
 
 Status Pg15UpgradeTestBase::ValidateUpgradeCompatibilityFailure(
-    const std::string& expected_error, const std::string& user_name) {
-  auto log_waiter = StringWaiterLogSink(expected_error);
-  auto status = ValidateUpgradeCompatibility(user_name);
-  if (status.ok()) {
-    return STATUS_FORMAT(
-        IllegalState, "Expected pg_upgrade to fail with error: $0", expected_error);
+    const std::vector<std::string>& expected_errors, const std::string& user_name) {
+  std::vector<std::unique_ptr<StringWaiterLogSink>> log_waiters;
+  for (const auto& expected_error : expected_errors) {
+    log_waiters.emplace_back(std::make_unique<StringWaiterLogSink>(expected_error));
   }
+  auto status = ValidateUpgradeCompatibility(user_name);
+  SCHECK(
+      !status.ok(), IllegalState,
+      Format("Expected pg_upgrade to fail with error(s): $0", ToString(expected_errors)));
   SCHECK(
       status.message().Contains(kPgUpgradeFailedError), IllegalState, "Unexpected status: $0",
       status);
-  SCHECK_FORMAT(
-      log_waiter.IsEventOccurred(), IllegalState, "Expected pg_upgrade to fail with error: $0",
-      expected_error);
+
+  for (size_t i = 0; i < expected_errors.size(); ++i) {
+    SCHECK_FORMAT(
+        log_waiters[i]->IsEventOccurred(), IllegalState,
+        "Expected pg_upgrade to fail with error: $0", expected_errors[i]);
+  }
+
   return Status::OK();
 }
 
+Status Pg15UpgradeTestBase::ValidateUpgradeCompatibilityFailure(
+    const std::string& expected_error, const std::string& user_name) {
+  return ValidateUpgradeCompatibilityFailure(std::vector<std::string>{expected_error}, user_name);
+}
+
 Status Pg15UpgradeTestBase::UpgradeClusterToMixedMode() {
   RETURN_NOT_OK(ValidateUpgradeCompatibility());
 
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h
index 7564fc938f..5c65e8d502 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h
@@ -39,6 +39,9 @@ class Pg15UpgradeTestBase : public UpgradeTestBase {
   virtual Status ValidateUpgradeCompatibility(const std::string& user_name = "yugabyte");
   Status ValidateUpgradeCompatibilityFailure(
       const std::string& expected_error, const std::string& user_name = "yugabyte");
+  Status ValidateUpgradeCompatibilityFailure(
+      const std::vector<std::string>& expected_errors, const std::string& user_name = "yugabyte");
+  // Same as above but accepts {error1,error2}
 
   // Restarts all masters in the current version, runs ysql major version upgrade, and restarts
   // tserver kMixedModeTserverPg15 in the current version. Other tservers are kept in the pg11
diff --git a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_check-test.cc b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_check-test.cc
new file mode 100644
index 0000000000..d42f1770b7
--- /dev/null
+++ b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_check-test.cc
@@ -0,0 +1,258 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include <regex>
+
+#include "yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h"
+#include "yb/yql/pgwrapper/libpq_utils.h"
+
+namespace yb {
+
+struct UpgradeIncompatibilityCheck {
+  std::initializer_list<std::string> setup_stmts;
+  std::initializer_list<std::string> expected_errors;
+  std::initializer_list<std::string> teardown_stmts;
+};
+
+using YsqlMajorUpgradeCheckTest = Pg15UpgradeTestBase;
+
+static const std::initializer_list<UpgradeIncompatibilityCheck> kCheckList{
+    {// check_proper_datallowconn
+     .setup_stmts = {"ALTER DATABASE postgres WITH allow_connections FALSE"},
+     .expected_errors = {"postgres", "All non-template0 databases must allow connections"},
+     .teardown_stmts = {"ALTER DATABASE postgres WITH allow_connections TRUE"}},
+
+    {// check_for_composite_data_type_usage
+     .setup_stmts = {"CREATE TABLE system_composite_test (id int primary key, authid pg_authid)"},
+     .expected_errors =
+         {"public.system_composite_test.authid",
+          "Your installation contains system-defined composite type(s) in user tables"},
+     .teardown_stmts = {"DROP TABLE system_composite_test"}},
+
+    {// check_for_reg_data_type_usage
+     .setup_stmts = {"CREATE TABLE reg_check (a int, b regproc)"},
+     .expected_errors =
+         {"public.reg_check.b",
+          "Your installation contains one of the reg* data types in user tables"},
+     .teardown_stmts = {"DROP TABLE reg_check"}},
+
+    {// check_for_user_defined_postfix_ops
+     .setup_stmts =
+         {"CREATE FUNCTION ident(integer) "
+          "RETURNS integer "
+          "AS $$ "
+          "BEGIN "
+          "    RETURN $1; "
+          "END; "
+          "$$ LANGUAGE plpgsql",
+          "CREATE OPERATOR !!! (LEFTARG = integer, PROCEDURE = ident)"},
+     .expected_errors =
+         {"public.!!! (pg_catalog.int4, NONE)",
+          "Your installation contains user-defined postfix operators"},
+     .teardown_stmts = {"DROP FUNCTION ident(integer) CASCADE"}},
+
+    {// check_for_incompatible_polymorphics
+     .setup_stmts = {"CREATE AGGREGATE array_accum (ANYELEMENT)(sfunc = array_append, stype = "
+                     "ANYARRAY, initcond = '{}')"},
+     .expected_errors =
+         {"aggregate: public.array_accum(anyelement)",
+          "Your installation contains user-defined objects that refer to internal",
+          "polymorphic functions with arguments of type \"anyarray\" or \"anyelement\""},
+     .teardown_stmts = {"DROP AGGREGATE array_accum (ANYELEMENT);"}},
+
+    {// old_11_check_for_sql_identifier_data_type_usage
+     .setup_stmts = {"CREATE TABLE sql_identifier_test (id int primary key, d "
+                     "information_schema.sql_identifier)"},
+     .expected_errors =
+         {"public.sql_identifier_test.d",
+          "Your installation contains the \"sql_identifier\" data type"},
+     .teardown_stmts = {"DROP TABLE sql_identifier_test"}}};
+
+// The following checks are not used in YugabyteDB:
+// check_for_prepared_transactions
+// check_for_isn_and_int8_passing_mismatch
+// check_for_user_defined_encoding_conversions
+// check_for_tables_with_oids
+// old_9_6_check_for_unknown_data_type_usage, old_9_6_invalidate_hash_indexes
+// check_for_pg_role_prefix
+// check_for_jsonb_9_4_usage
+// old_9_3_check_for_line_data_type_usage
+
+TEST_F(YsqlMajorUpgradeCheckTest, PgUpgradeChecks) {
+  auto conn = ASSERT_RESULT(cluster_->ConnectToDB());
+
+  // Run each check in isolation.
+  for (const auto& check : kCheckList) {
+    for (const auto& setup_stmt : check.setup_stmts) {
+      ASSERT_OK(conn.Execute(setup_stmt));
+    }
+
+    ASSERT_OK(ValidateUpgradeCompatibilityFailure(std::vector<std::string>(check.expected_errors)));
+
+    // Make sure we can recover from the error.
+    for (const auto& teardown_stmt : check.teardown_stmts) {
+      ASSERT_OK(conn.Execute(teardown_stmt));
+    }
+
+    ASSERT_OK(ValidateUpgradeCompatibility());
+  }
+
+  // Setup all failures at once.
+  std::vector<std::string> all_errors;
+  for (const auto& check : kCheckList) {
+    for (const auto& setup_stmt : check.setup_stmts) {
+      ASSERT_OK(conn.Execute(setup_stmt));
+    }
+
+    all_errors.insert(all_errors.end(), check.expected_errors.begin(), check.expected_errors.end());
+  }
+
+  // Everything should have failed.
+  ASSERT_OK(ValidateUpgradeCompatibilityFailure(all_errors));
+
+  for (const auto& check : kCheckList) {
+    for (const auto& teardown_stmt : check.teardown_stmts) {
+      ASSERT_OK(conn.Execute(teardown_stmt));
+    }
+  }
+
+  ASSERT_OK(ValidateUpgradeCompatibility());
+
+  ASSERT_OK(UpgradeClusterToCurrentVersion(kNoDelayBetweenNodes));
+
+  // Running validation on the upgraded cluster should fail since its already on the higher version.
+  ASSERT_OK(ValidateUpgradeCompatibilityFailure(
+      "This version of the utility can only be used for checking YSQL version 11. The cluster is "
+      "currently on YSQL version 15"));
+}
+
+TEST_F(YsqlMajorUpgradeCheckTest, CheckUpgradeCompatibilityGuc) {
+  // Whether or not yb_major_version_upgrade_compatibility is enabled, pg_upgrade --check will not
+  // error.
+  ASSERT_OK(cluster_->AddAndSetExtraFlag("ysql_yb_major_version_upgrade_compatibility", "11"));
+  ASSERT_OK(ValidateUpgradeCompatibility());
+
+  ASSERT_OK(cluster_->AddAndSetExtraFlag("ysql_yb_major_version_upgrade_compatibility", "0"));
+  ASSERT_OK(ValidateUpgradeCompatibility());
+
+  // However, when we actually run the YSQL upgrade, pg_upgrade will error since now
+  // ysql_yb_major_version_upgrade_compatibility is not set.
+  auto log_waiter =
+      cluster_->GetMasterLogWaiter("yb_major_version_upgrade_compatibility must be set to 11");
+  ASSERT_NOK_STR_CONTAINS(UpgradeClusterToMixedMode(), kPgUpgradeFailedError);
+  ASSERT_TRUE(log_waiter.IsEventOccurred());
+}
+
+TEST_F(YsqlMajorUpgradeCheckTest, UsersAndRoles) {
+  auto escape_single_quote = [](const std::string& str) {
+    return std::regex_replace(str, std::regex("'"), "''");
+  };
+  auto escape_double_quote = [](const std::string& str) {
+    return std::regex_replace(str, std::regex("\""), "\"\"");
+  };
+
+  auto ts = cluster_->tablet_server(0);
+
+  // Make sure pg_upgrade --check fails if the yugabyte user is not a superuser.
+  {
+    const auto postgres_user = "postgres";
+    const auto pg_conn_settings = pgwrapper::PGConnSettings{
+        .host = ts->bind_host(),
+        .port = ts->ysql_port(),
+        .dbname = "yugabyte",
+        .user = postgres_user};
+
+    auto pg_conn = ASSERT_RESULT(pgwrapper::PGConnBuilder(pg_conn_settings).Connect());
+    ASSERT_OK(pg_conn.Execute("DROP USER yugabyte"));
+    ASSERT_OK(ValidateUpgradeCompatibilityFailure("The 'yugabyte' user is missing", postgres_user));
+
+    ASSERT_OK(pg_conn.Execute("CREATE USER yugabyte"));
+
+    ASSERT_OK(ValidateUpgradeCompatibilityFailure(
+        "The 'yugabyte' user is missing the 'rolsuper' attribute", postgres_user));
+
+    ASSERT_OK(pg_conn.Execute("DROP USER yugabyte"));
+    ASSERT_OK(pg_conn.Execute(
+        "CREATE USER yugabyte SUPERUSER INHERIT CREATEROLE CREATEDB LOGIN REPLICATION BYPASSRLS"));
+    ASSERT_OK(ValidateUpgradeCompatibility(postgres_user));
+  }
+
+  // Change the yugabyte password to make sure if works after the upgrade.
+  // Including quotes in password to make sure it works.
+  const auto new_yb_password = "yb_\"secure\"\"_'pass''";
+  {
+    // Escape single quotes in the sql string.
+    ASSERT_OK(ExecuteStatement(
+        Format("ALTER USER yugabyte PASSWORD '$0'", escape_single_quote(new_yb_password))));
+  }
+
+  const auto conn_settings = pgwrapper::PGConnSettings{
+      .host = ts->bind_host(),
+      .port = ts->ysql_port(),
+      .dbname = "yugabyte",
+      .user = "yugabyte",
+      .password = escape_double_quote(new_yb_password)};
+
+  auto conn = ASSERT_RESULT(pgwrapper::PGConnBuilder(conn_settings).Connect());
+
+  // Create users with special characters in their names.
+  auto special_role_names = {"user with space", "user_\"_with_\"\"_different' quotes''"};
+  for (const auto& role_name : special_role_names) {
+    // Escape double quotes in the sql string.
+    ASSERT_OK(conn.ExecuteFormat("CREATE ROLE \"$0\"", escape_double_quote(role_name)));
+  }
+
+  // Create roles alice and bob, and role carol with membership in alice. Make sure table created by
+  // alice can be accessed by alice and carol but not bob.
+  ASSERT_OK(conn.Execute("CREATE ROLE alice LOGIN"));
+  ASSERT_OK(conn.Execute("CREATE ROLE bob LOGIN"));
+  ASSERT_OK(conn.Execute("CREATE ROLE carol IN ROLE alice LOGIN"));
+
+  ASSERT_OK(conn.Execute("SET ROLE alice"));
+  ASSERT_OK(conn.Execute("CREATE TABLE t_alice (a int)"));
+  ASSERT_OK(conn.Execute("INSERT INTO t_alice VALUES (1)"));
+  ASSERT_OK(conn.Execute("RESET ROLE"));
+
+  auto check_roles = [&](pgwrapper::PGConn& conn) {
+    auto get_table_count = [&conn]() {
+      return conn.FetchRow<pgwrapper::PGUint64>("SELECT COUNT(*) FROM t_alice");
+    };
+    ASSERT_OK(conn.Execute("SET ROLE alice"));
+    auto count = ASSERT_RESULT(get_table_count());
+    ASSERT_EQ(count, 1);
+
+    ASSERT_OK(conn.Execute("SET ROLE bob"));
+    ASSERT_NOK_STR_CONTAINS(get_table_count(), "ERROR:  permission denied for table t_alice");
+
+    ASSERT_OK(conn.Execute("SET ROLE carol"));
+    count = ASSERT_RESULT(get_table_count());
+    ASSERT_EQ(count, 1);
+
+    ASSERT_OK(conn.Execute("RESET ROLE"));
+  };
+
+  ASSERT_NO_FATALS(check_roles(conn));
+
+  ASSERT_OK(UpgradeClusterToCurrentVersion(kNoDelayBetweenNodes));
+
+  conn = ASSERT_RESULT(pgwrapper::PGConnBuilder(conn_settings).Connect());
+  for (const auto& role_name : special_role_names) {
+    LOG(INFO) << "Checking role: " << role_name;
+    auto res_role_name = ASSERT_RESULT(conn.FetchRow<std::string>(Format(
+        "SELECT rolname FROM pg_roles WHERE rolname = '$0'", escape_single_quote(role_name))));
+    ASSERT_STR_EQ(role_name, res_role_name);
+  }
+
+  ASSERT_NO_FATALS(check_roles(conn));
+}
+}  // namespace yb
diff --git a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
index 2991c51d1e..ab57b49081 100644
--- a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
@@ -33,10 +33,7 @@ class YsqlMajorUpgradeDdlBlockingTest : public Pg15UpgradeTestBase {
   YsqlMajorUpgradeDdlBlockingTest() = default;
 
   void SetUp() override {
-    Pg15UpgradeTestBase::SetUp();
-    if (Test::IsSkipped()) {
-      return;
-    }
+    TEST_SETUP_SUPER(Pg15UpgradeTestBase);
 
     auto conn = ASSERT_RESULT(CreateConnToTs(std::nullopt));
     ASSERT_OK(conn.ExecuteFormat("CREATE TABLE $0(a int)", kCommentTable));
diff --git a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_matview-test.cc b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_matview-test.cc
index c0e6a6ccb6..bca59e7c50 100644
--- a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_matview-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_matview-test.cc
@@ -24,10 +24,7 @@ static constexpr auto kIndexedMatViewName = "mv2";
 class YsqlMajorUpgradeMatviewTest : public Pg15UpgradeTestBase {
  public:
   void SetUp() override {
-    Pg15UpgradeTestBase::SetUp();
-    if (Test::IsSkipped()) {
-      return;
-    }
+    TEST_SETUP_SUPER(Pg15UpgradeTestBase);
 
     auto conn = ASSERT_RESULT(CreateConnToTs(std::nullopt));
     ASSERT_OK(conn.ExecuteFormat("CREATE TABLE $0(a int, b int)", kTableName));
diff --git a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_rpcs-test.cc b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_rpcs-test.cc
index 071cffa816..7a0b21edaa 100644
--- a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_rpcs-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_rpcs-test.cc
@@ -28,10 +28,7 @@ class YsqlMajorUpgradeRpcsTest : public Pg15UpgradeTestBase {
   YsqlMajorUpgradeRpcsTest() = default;
 
   void SetUp() override {
-    Pg15UpgradeTestBase::SetUp();
-    if (Test::IsSkipped()) {
-      return;
-    }
+    TEST_SETUP_SUPER(Pg15UpgradeTestBase);
 
     CHECK_OK(CreateSimpleTable());
   }
diff --git a/src/yb/util/test_util.h b/src/yb/util/test_util.h
index ebc95e4c14..696e2d34d6 100644
--- a/src/yb/util/test_util.h
+++ b/src/yb/util/test_util.h
@@ -55,6 +55,15 @@
   NO_PENDING_FATALS(); \
 } while (0)
 
+// Invokes super setup, and returns if the test was marked as skipped.
+#define TEST_SETUP_SUPER(super) \
+  do { \
+    super::SetUp(); \
+    if (Test::IsSkipped()) { \
+      return; \
+    } \
+  } while (false)
+
 namespace yb {
 
 class CurlGlobalInitializer;
