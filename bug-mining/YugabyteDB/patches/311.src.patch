diff --git a/src/yb/client/client_fwd.h b/src/yb/client/client_fwd.h
index 6341ff525d..b864aad143 100644
--- a/src/yb/client/client_fwd.h
+++ b/src/yb/client/client_fwd.h
@@ -118,7 +118,6 @@ enum class YBTableType;
 
 YB_DEFINE_ENUM(GrantRevokeStatementType, (GRANT)(REVOKE));
 YB_STRONGLY_TYPED_BOOL(ForceConsistentRead);
-YB_STRONGLY_TYPED_BOOL(ForceGlobalTransaction);
 YB_STRONGLY_TYPED_BOOL(Initial);
 YB_STRONGLY_TYPED_BOOL(UseCache);
 YB_STRONGLY_TYPED_BOOL(ForceCreateTransaction);
diff --git a/src/yb/client/transaction.cc b/src/yb/client/transaction.cc
index b81f7e9190..ade097081e 100644
--- a/src/yb/client/transaction.cc
+++ b/src/yb/client/transaction.cc
@@ -229,7 +229,7 @@ const SubTransactionMetadata& YBSubTransaction::get() const { return sub_txn_; }
 
 class YBTransaction::Impl final : public internal::TxnBatcherIf {
  public:
-  Impl(TransactionManager* manager, YBTransaction* transaction, TransactionLocality locality)
+  Impl(TransactionManager* manager, YBTransaction* transaction, TransactionFullLocality locality)
       : trace_(Trace::MaybeGetNewTrace()),
         wait_state_(ash::WaitStateInfo::CurrentWaitState()),
         manager_(manager),
@@ -691,19 +691,44 @@ class YBTransaction::Impl final : public internal::TxnBatcherIf {
 
   internal::InFlightOp* FindOpWithLocalityViolation(
       internal::InFlightOpsGroupsWithMetadata* ops_info) REQUIRES(mutex_) {
-    if (metadata_.locality != TransactionLocality::LOCAL) {
+    if (metadata_.locality.IsGlobal()) {
       return nullptr;
     }
     for (auto& group : ops_info->groups) {
       auto& first_op = *group.begin;
-      auto tablet = first_op.tablet;
-      if (!tablet->IsLocalRegion()) {
-        return &first_op;
+      switch (metadata_.locality.locality) {
+        case TransactionLocality::REGION_LOCAL:
+          if (!first_op.tablet->IsLocalRegion()) {
+            return &first_op;
+          }
+          break;
+        case TransactionLocality::TABLESPACE_LOCAL:
+          if (auto tablespace_oid = GetOpTablespaceOid(first_op);
+              !tablespace_oid || metadata_.locality.tablespace_oid != *tablespace_oid) {
+            return &first_op;
+          }
+          break;
+        default:
+          LOG(DFATAL) << "Unexpected locality: " << metadata_.locality;
+          return nullptr;
       }
     }
     return nullptr;
   }
 
+  std::optional<PgTablespaceOid> GetOpTablespaceOid(internal::InFlightOp& op) {
+    auto* yb_op = op.yb_op.get();
+    switch (yb_op->type()) {
+      case YBOperation::Type::PGSQL_READ:
+        return down_cast<YBPgsqlReadOp*>(yb_op)->request().tablespace_oid();
+      case YBOperation::Type::PGSQL_WRITE:
+        return down_cast<YBPgsqlWriteOp*>(yb_op)->request().tablespace_oid();
+      default:
+        LOG(DFATAL) << "Unexpected op type: " << yb_op->type();
+        return std::nullopt;
+    }
+  }
+
   Result<bool> StartPromotionToGlobalIfNecessary(
       internal::InFlightOpsGroupsWithMetadata* ops_info) REQUIRES(mutex_) {
     auto op = FindOpWithLocalityViolation(ops_info);
@@ -734,7 +759,7 @@ class YBTransaction::Impl final : public internal::TxnBatcherIf {
   Status EnsureGlobal(const CoarseTimePoint& deadline) EXCLUDES(mutex_) {
     {
       UniqueLock lock(mutex_);
-      if (metadata_.locality == TransactionLocality::GLOBAL) {
+      if (metadata_.locality.IsGlobal()) {
         return Status::OK();
       }
       RETURN_NOT_OK(StartPromotionToGlobal());
@@ -744,7 +769,7 @@ class YBTransaction::Impl final : public internal::TxnBatcherIf {
   }
 
   Status StartPromotionToGlobal() REQUIRES(mutex_) {
-    if (metadata_.locality == TransactionLocality::GLOBAL) {
+    if (metadata_.locality.IsGlobal()) {
       return STATUS(IllegalState, "Global transactions cannot be promoted");
     }
 
@@ -754,7 +779,7 @@ class YBTransaction::Impl final : public internal::TxnBatcherIf {
       LOG_WITH_PREFIX(DFATAL) << "Attempting to promote transaction not in running state";
     }
     ready_ = false;
-    metadata_.locality = TransactionLocality::GLOBAL;
+    metadata_.locality = TransactionFullLocality::Global();
 
     transaction_status_move_tablets_.reserve(tablets_.size());
     transaction_status_move_handles_.reserve(tablets_.size());
@@ -2585,7 +2610,7 @@ CoarseTimePoint AdjustDeadline(CoarseTimePoint deadline) {
   return deadline;
 }
 
-YBTransaction::YBTransaction(TransactionManager* manager, TransactionLocality locality)
+YBTransaction::YBTransaction(TransactionManager* manager, TransactionFullLocality locality)
     : impl_(new Impl(manager, this, locality)) {
 }
 
diff --git a/src/yb/client/transaction.h b/src/yb/client/transaction.h
index e2df2fd913..3c12122228 100644
--- a/src/yb/client/transaction.h
+++ b/src/yb/client/transaction.h
@@ -28,6 +28,7 @@
 
 #include "yb/client/client_fwd.h"
 #include "yb/client/in_flight_op.h"
+#include "yb/common/pg_types.h"
 
 #include "yb/util/status_callback.h"
 #include "yb/util/status_fwd.h"
@@ -85,7 +86,7 @@ class YBTransaction : public std::enable_shared_from_this<YBTransaction> {
 
  public:
   explicit YBTransaction(TransactionManager* manager,
-                         TransactionLocality locality = TransactionLocality::GLOBAL);
+                         TransactionFullLocality locality = TransactionFullLocality::Global());
 
   // Trick to allow std::make_shared with this ctor only from methods of this class.
   YBTransaction(TransactionManager* manager, const TransactionMetadata& metadata, PrivateOnlyTag);
diff --git a/src/yb/client/transaction_manager.cc b/src/yb/client/transaction_manager.cc
index ad3d30f462..0b00a2db19 100644
--- a/src/yb/client/transaction_manager.cc
+++ b/src/yb/client/transaction_manager.cc
@@ -17,6 +17,8 @@
 
 #include "yb/ash/wait_state.h"
 
+#include "yb/common/transaction.h"
+
 #include "yb/client/client.h"
 #include "yb/client/meta_cache.h"
 #include "yb/client/table.h"
@@ -62,12 +64,12 @@ class TransactionTableState {
   }
 
   void InvokeCallback(const PickStatusTabletCallback& callback,
-                      TransactionLocality locality) EXCLUDES(mutex_) {
+                      TransactionFullLocality locality) EXCLUDES(mutex_) {
     SharedLock<yb::RWMutex> lock(mutex_);
     const auto& tablets = PickTabletList(locality);
     if (tablets.empty()) {
       callback(STATUS_FORMAT(
-          IllegalState, "No $0 transaction tablets found", TransactionLocality_Name(locality)));
+          IllegalState, "No $0 transaction tablets found", locality));
       return;
     }
     if (PickStatusTabletId(tablets, callback)) {
@@ -96,6 +98,11 @@ class TransactionTableState {
     return has_region_local_tablets_.load();
   }
 
+  bool HasAnyTransactionLocalStatusTablets(PgTablespaceOid tablespace_oid) {
+    SharedLock lock(mutex_);
+    return tablets_.tablespaces.contains(tablespace_oid);
+  }
+
   uint64_t GetStatusTabletsVersion() EXCLUDES(mutex_) {
     std::lock_guard lock(mutex_);
     return status_tablets_version_;
@@ -132,18 +139,28 @@ class TransactionTableState {
     return true;
   }
 
-  const std::vector<TabletId>& PickTabletList(TransactionLocality locality)
+  const std::vector<TabletId>& PickTabletList(TransactionFullLocality locality)
       REQUIRES_SHARED(mutex_) {
-    if (tablets_.region_local_tablets.empty()) {
-      return tablets_.global_tablets;
-    }
-    switch (locality) {
+    switch (locality.locality) {
       case TransactionLocality::GLOBAL:
         return tablets_.global_tablets;
-      case TransactionLocality::LOCAL:
+      case TransactionLocality::REGION_LOCAL:
+        if (tablets_.region_local_tablets.empty()) {
+          YB_LOG_EVERY_N_SECS(WARNING, 1) << "No region-local status tablets found";
+          return tablets_.global_tablets;
+        }
         return tablets_.region_local_tablets;
+      case TransactionLocality::TABLESPACE_LOCAL: {
+        auto itr = tablets_.tablespaces.find(locality.tablespace_oid);
+        if (itr == tablets_.tablespaces.end() || itr->second.tablets.empty()) {
+          YB_LOG_EVERY_N_SECS(WARNING, 1)
+              << "No status tablets found for tablespace " << locality.tablespace_oid;
+          return tablets_.global_tablets;
+        }
+        return itr->second.tablets;
+      }
     }
-    FATAL_INVALID_ENUM_VALUE(TransactionLocality, locality);
+    FATAL_INVALID_ENUM_VALUE(TransactionLocality, locality.locality);
   }
 
   LocalTabletFilter local_tablet_filter_;
@@ -185,7 +202,7 @@ class LoadStatusTabletsTask {
                         TransactionTableState* table_state,
                         uint64_t version,
                         PickStatusTabletCallback callback = PickStatusTabletCallback(),
-                        TransactionLocality locality = TransactionLocality::GLOBAL)
+                        TransactionFullLocality locality = TransactionFullLocality::Global())
       : client_(client), table_state_(table_state), version_(version), callback_(callback),
         locality_(locality) {
   }
@@ -226,14 +243,14 @@ class LoadStatusTabletsTask {
   TransactionTableState* table_state_;
   uint64_t version_;
   PickStatusTabletCallback callback_;
-  TransactionLocality locality_;
+  TransactionFullLocality locality_;
 };
 
 class InvokeCallbackTask {
  public:
   InvokeCallbackTask(TransactionTableState* table_state,
                      PickStatusTabletCallback callback,
-                     TransactionLocality locality)
+                     TransactionFullLocality locality)
       : table_state_(table_state), callback_(std::move(callback)), locality_(locality) {
   }
 
@@ -251,7 +268,7 @@ class InvokeCallbackTask {
  private:
   TransactionTableState* table_state_;
   PickStatusTabletCallback callback_;
-  TransactionLocality locality_;
+  TransactionFullLocality locality_;
 };
 } // namespace
 
@@ -302,7 +319,8 @@ class TransactionManager::Impl {
     }
   }
 
-  void PickStatusTablet(PickStatusTabletCallback callback, TransactionLocality locality) {
+  void PickStatusTablet(
+      PickStatusTabletCallback callback, TransactionFullLocality locality) {
     if (table_state_.IsInitialized()) {
       if (ThreadRestrictions::IsWaitAllowed()) {
         table_state_.InvokeCallback(callback, locality);
@@ -363,6 +381,10 @@ class TransactionManager::Impl {
     return table_state_.HasAnyRegionLocalStatusTablets();
   }
 
+  bool TablespaceLocalTransactionsPossible(PgTablespaceOid tablespace_oid) {
+    return table_state_.HasAnyTransactionLocalStatusTablets(tablespace_oid);
+  }
+
   uint64_t GetLoadedStatusTabletsVersion() {
     return table_state_.GetStatusTabletsVersion();
   }
@@ -400,7 +422,7 @@ void TransactionManager::UpdateTransactionTablesVersion(
 }
 
 void TransactionManager::PickStatusTablet(
-    PickStatusTabletCallback callback, TransactionLocality locality) {
+    PickStatusTabletCallback callback, TransactionFullLocality locality) {
   impl_->PickStatusTablet(std::move(callback), locality);
 }
 
@@ -432,6 +454,10 @@ bool TransactionManager::RegionLocalTransactionsPossible() {
   return impl_->RegionLocalTransactionsPossible();
 }
 
+bool TransactionManager::TablespaceLocalTransactionsPossible(PgTablespaceOid tablespace_oid) {
+  return impl_->TablespaceLocalTransactionsPossible(tablespace_oid);
+}
+
 uint64_t TransactionManager::GetLoadedStatusTabletsVersion() {
   return impl_->GetLoadedStatusTabletsVersion();
 }
diff --git a/src/yb/client/transaction_manager.h b/src/yb/client/transaction_manager.h
index e26c72d537..2b011c2d1e 100644
--- a/src/yb/client/transaction_manager.h
+++ b/src/yb/client/transaction_manager.h
@@ -17,11 +17,13 @@
 
 #include <functional>
 #include <memory>
+#include <optional>
 
 #include "yb/client/client_fwd.h"
 
 #include "yb/common/clock.h"
 #include "yb/common/hybrid_time.h"
+#include "yb/common/pg_types.h"
 #include "yb/common/transaction.pb.h"
 
 #include "yb/rpc/rpc_fwd.h"
@@ -48,7 +50,8 @@ class TransactionManager {
       uint64_t version,
       UpdateTransactionTablesVersionCallback callback = UpdateTransactionTablesVersionCallback());
 
-  void PickStatusTablet(PickStatusTabletCallback callback, TransactionLocality locality);
+  void PickStatusTablet(
+      PickStatusTabletCallback callback, TransactionFullLocality locality);
 
   rpc::Rpcs& rpcs();
   YBClient* client() const;
@@ -61,6 +64,8 @@ class TransactionManager {
 
   bool RegionLocalTransactionsPossible();
 
+  bool TablespaceLocalTransactionsPossible(PgTablespaceOid tablespace_oid);
+
   uint64_t GetLoadedStatusTabletsVersion();
 
   void Shutdown();
diff --git a/src/yb/client/transaction_pool.cc b/src/yb/client/transaction_pool.cc
index ef5120a8e5..6a04baacba 100644
--- a/src/yb/client/transaction_pool.cc
+++ b/src/yb/client/transaction_pool.cc
@@ -30,6 +30,7 @@
 #include "yb/util/callsite_profiling.h"
 #include "yb/util/metrics.h"
 #include "yb/util/result.h"
+#include "yb/util/rw_mutex.h"
 #include "yb/util/trace.h"
 
 using namespace std::literals;
@@ -78,7 +79,7 @@ class SingleLocalityPool {
  public:
   SingleLocalityPool(TransactionManager* manager,
                      MetricEntity* metric_entity,
-                     TransactionLocality locality)
+                     TransactionFullLocality locality)
       : manager_(*manager), locality_(locality) {
     if (metric_entity) {
       cache_stats_ = METRIC_transaction_pool_cache.Instantiate(metric_entity);
@@ -263,7 +264,7 @@ class SingleLocalityPool {
   };
 
   TransactionManager& manager_;
-  TransactionLocality locality_;
+  TransactionFullLocality locality_;
   scoped_refptr<EventStats> cache_stats_;
   scoped_refptr<Counter> cache_hits_;
   scoped_refptr<Counter> cache_queries_;
@@ -285,25 +286,27 @@ class TransactionPool::Impl {
  public:
   Impl(TransactionManager* manager, MetricEntity* metric_entity)
       : manager_(manager),
-        global_pool_(manager, metric_entity, TransactionLocality::GLOBAL),
-        local_pool_(manager, metric_entity, TransactionLocality::LOCAL) {
+        metric_entity_(metric_entity),
+        global_pool_(manager, metric_entity, TransactionFullLocality::Global()),
+        region_local_pool_(manager, metric_entity, TransactionFullLocality::RegionLocal()) {
   }
 
   ~Impl() = default;
 
   void Shutdown() {
     global_pool_.Shutdown();
-    local_pool_.Shutdown();
+    region_local_pool_.Shutdown();
+
+    std::lock_guard lock(mutex_);
+    for (auto& pool : tablespace_local_pools_ | std::views::values) {
+      pool.Shutdown();
+    }
   }
 
   YBTransactionPtr Take(
-      ForceGlobalTransaction force_global_transaction, CoarseTimePoint deadline,
+      TransactionFullLocality locality, CoarseTimePoint deadline,
       ForceCreateTransaction force_create_txn = ForceCreateTransaction::kFalse) EXCLUDES(mutex_) {
-    const auto is_global = force_global_transaction ||
-                           FLAGS_force_global_transactions ||
-                           !manager_->RegionLocalTransactionsPossible();
-    auto transaction =
-        (is_global ? &global_pool_ : &local_pool_)->Take(deadline, force_create_txn);
+    auto transaction = PickPool(locality).Take(deadline, force_create_txn);
     if (FLAGS_TEST_track_last_transaction) {
       std::lock_guard lock(mutex_);
       last_transaction_ = transaction;
@@ -316,12 +319,37 @@ class TransactionPool::Impl {
     std::lock_guard lock(mutex_);
     return last_transaction_;
   }
+
  private:
+  SingleLocalityPool& PickPool(TransactionFullLocality locality) EXCLUDES(mutex_) {
+    if (FLAGS_force_global_transactions) {
+      return global_pool_;
+    }
+    switch (locality.locality) {
+      case TransactionLocality::GLOBAL:
+        return global_pool_;
+      case TransactionLocality::REGION_LOCAL:
+        return manager_->RegionLocalTransactionsPossible() ? region_local_pool_ : global_pool_;
+      case TransactionLocality::TABLESPACE_LOCAL:
+        if (manager_->TablespaceLocalTransactionsPossible(locality.tablespace_oid)) {
+          SharedLock lock(mutex_);
+          return tablespace_local_pools_.try_emplace(
+              locality.tablespace_oid, manager_, metric_entity_, locality).first->second;
+        }
+        return global_pool_;
+    }
+    FATAL_INVALID_ENUM_VALUE(TransactionLocality, locality.locality);
+  }
+
+  RWMutex mutex_;
+
   TransactionManager* manager_;
+  MetricEntity* metric_entity_;
   SingleLocalityPool global_pool_;
-  SingleLocalityPool local_pool_;
+  SingleLocalityPool region_local_pool_;
+  std::unordered_map<PgTablespaceOid, SingleLocalityPool>
+      tablespace_local_pools_ GUARDED_BY(mutex_);
 
-  std::mutex mutex_;
   YBTransactionPtr last_transaction_ GUARDED_BY(mutex_);
 };
 
@@ -337,14 +365,14 @@ void TransactionPool::Shutdown() {
 }
 
 YBTransactionPtr TransactionPool::Take(
-    ForceGlobalTransaction force_global_transaction, CoarseTimePoint deadline,
+    TransactionFullLocality locality, CoarseTimePoint deadline,
     ForceCreateTransaction force_create_txn) {
-  return impl_->Take(force_global_transaction, deadline, force_create_txn);
+  return impl_->Take(locality, deadline, force_create_txn);
 }
 
 Result<YBTransactionPtr> TransactionPool::TakeAndInit(
     IsolationLevel isolation, CoarseTimePoint deadline, const ReadHybridTime& read_time) {
-  auto result = impl_->Take(ForceGlobalTransaction::kTrue, deadline);
+  auto result = impl_->Take(TransactionFullLocality::Global(), deadline);
   RETURN_NOT_OK(result->Init(isolation, read_time));
   return result;
 }
@@ -353,10 +381,7 @@ Result<YBTransactionPtr> TransactionPool::TakeRestarted(
     const YBTransactionPtr& source, CoarseTimePoint deadline) {
   const auto &metadata = source->GetMetadata(deadline).get();
   RETURN_NOT_OK(metadata);
-  const auto force_global =
-      metadata->locality == TransactionLocality::GLOBAL ? ForceGlobalTransaction::kTrue
-                                                        : ForceGlobalTransaction::kFalse;
-  auto result = impl_->Take(force_global, deadline);
+  auto result = impl_->Take(metadata->locality, deadline);
   RETURN_NOT_OK(source->FillRestartedTransaction(result));
   return result;
 }
diff --git a/src/yb/client/transaction_pool.h b/src/yb/client/transaction_pool.h
index 8ff672db12..4911004d34 100644
--- a/src/yb/client/transaction_pool.h
+++ b/src/yb/client/transaction_pool.h
@@ -45,7 +45,7 @@ class TransactionPool {
   // Ready means that transaction is registered at status tablet and intents could be written
   // immediately.
   YBTransactionPtr Take(
-      ForceGlobalTransaction force_global_transaction, CoarseTimePoint deadline,
+      TransactionFullLocality locality, CoarseTimePoint deadline,
       ForceCreateTransaction force_create_txn = ForceCreateTransaction::kFalse);
 
   // Takes and initializes a transaction from the pool. See Take for details.
diff --git a/src/yb/common/common.proto b/src/yb/common/common.proto
index 549d431263..7097c68865 100644
--- a/src/yb/common/common.proto
+++ b/src/yb/common/common.proto
@@ -452,6 +452,9 @@ message TransactionMetadataPB {
   // for backwards compatability.
   optional TransactionLocality locality = 7;
 
+  // Stores tablespace oid for TABLESPACE_LOCAL locality.
+  optional uint32 locality_tablespace_oid = 10;
+
   // Reserved for deprecated xcluster field external_transaction.
   reserved 8;
 }
diff --git a/src/yb/common/common_fwd.h b/src/yb/common/common_fwd.h
index 140dd04669..bb44c707cb 100644
--- a/src/yb/common/common_fwd.h
+++ b/src/yb/common/common_fwd.h
@@ -51,6 +51,7 @@ struct DeletedColumn;
 struct OpId;
 struct PgObjectId;
 struct ReadHybridTime;
+struct TransactionFullLocality;
 struct TransactionMetadata;
 struct TransactionOperationContext;
 struct TransactionStatusResult;
diff --git a/src/yb/common/pg_types.h b/src/yb/common/pg_types.h
index ed0e08d301..a036d59a5a 100644
--- a/src/yb/common/pg_types.h
+++ b/src/yb/common/pg_types.h
@@ -26,6 +26,8 @@ using PgOid = uint32_t;
 static constexpr PgOid kPgInvalidOid = 0;
 static constexpr PgOid kPgByteArrayOid = 17;
 
+using PgTablespaceOid = PgOid;
+
 // A struct to identify a Postgres object by oid and the database oid it belongs to.
 struct PgObjectId {
   PgOid database_oid = kPgInvalidOid;
diff --git a/src/yb/common/transaction.cc b/src/yb/common/transaction.cc
index 2e910127d9..b367018ca4 100644
--- a/src/yb/common/transaction.cc
+++ b/src/yb/common/transaction.cc
@@ -53,6 +53,17 @@ TransactionStatusResult::TransactionStatusResult(
     TabletId status_tablet_) : status(status_), status_time(status_time_),
       aborted_subtxn_set(aborted_subtxn_set_), status_tablet(status_tablet_) {}
 
+
+bool operator==(const TransactionFullLocality& lhs, const TransactionFullLocality& rhs) {
+  return lhs.locality == rhs.locality &&
+      (lhs.locality != TransactionLocality::TABLESPACE_LOCAL ||
+       lhs.tablespace_oid == rhs.tablespace_oid);
+}
+
+std::ostream& operator<<(std::ostream& out, const TransactionFullLocality& locality) {
+  return out << locality.ToString();
+}
+
 namespace {
 
 void DupStatusTablet(const TabletId& tablet_id, TransactionMetadataPB* out) {
@@ -70,11 +81,30 @@ void DoToPB(const TransactionMetadata& source, PB* dest) {
   DupStatusTablet(source.status_tablet, dest);
   dest->set_priority(source.priority);
   dest->set_start_hybrid_time(source.start_time.ToUint64());
-  dest->set_locality(source.locality);
+  dest->set_locality(source.locality.locality);
+  if (source.locality.locality == TransactionLocality::TABLESPACE_LOCAL) {
+    dest->set_locality_tablespace_oid(source.locality.tablespace_oid);
+  }
 }
 
 } // namespace
 
+std::string TransactionFullLocality::ToString() const {
+  if (locality == TransactionLocality::TABLESPACE_LOCAL) {
+    return Format("$0(tablespace_oid: $1)", TransactionLocality_Name(locality), tablespace_oid);
+  } else {
+    return TransactionLocality_Name(locality);
+  }
+}
+
+std::string TransactionMetadata::ToString() const {
+  return Format(
+      "{ transaction_id: $0 isolation: $1 status_tablet: $2 priority: $3 start_time: $4"
+      " locality: $5 old_status_tablet: $6}",
+      transaction_id, IsolationLevel_Name(isolation), status_tablet, priority, start_time,
+      locality.ToString(), old_status_tablet);
+}
+
 template <class PB>
 Result<TransactionMetadata> TransactionMetadata::DoFromPB(const PB& source) {
   TransactionMetadata result;
@@ -90,9 +120,13 @@ Result<TransactionMetadata> TransactionMetadata::DoFromPB(const PB& source) {
   }
 
   if (source.has_locality()) {
-    result.locality = source.locality();
+    result.locality.locality = source.locality();
+    if (result.locality.locality == TransactionLocality::TABLESPACE_LOCAL) {
+      DCHECK(source.has_locality_tablespace_oid());
+      result.locality.tablespace_oid = source.locality_tablespace_oid();
+    }
   } else {
-    result.locality = TransactionLocality::GLOBAL;
+    result.locality = TransactionFullLocality::Global();
   }
   return result;
 }
diff --git a/src/yb/common/transaction.h b/src/yb/common/transaction.h
index 4ea208ea17..fdc6e6186c 100644
--- a/src/yb/common/transaction.h
+++ b/src/yb/common/transaction.h
@@ -26,12 +26,14 @@
 
 #include <boost/container/small_vector.hpp>
 #include <boost/functional/hash/hash.hpp>
+#include <boost/optional/optional.hpp>
 
 #include "yb/common/common_fwd.h"
 #include "yb/common/transaction.pb.h"
 #include "yb/common/entity_ids_types.h"
 #include "yb/common/hybrid_time.h"
 #include "yb/common/opid.h"
+#include "yb/common/pg_types.h"
 
 #include "yb/util/enums.h"
 #include "yb/util/status_fwd.h"
@@ -220,7 +222,7 @@ class TransactionStatusManager {
   virtual HybridTime LocalCommitTime(const TransactionId& id) = 0;
 
   // If this tablet is aware that this transaction has committed, returns the TransactionLocalState
-  // for the transaction. Otherwise, returns std::nullopt.
+  // for the transaction. Otherwise, returns boost::none.
   virtual std::optional<TransactionLocalState> LocalTxnData(const TransactionId& id) = 0;
 
   // Fetches status of specified transaction at specified time from transaction coordinator.
@@ -380,6 +382,37 @@ inline std::ostream& operator<<(std::ostream& out, const TransactionOperationCon
   return out;
 }
 
+struct TransactionFullLocality {
+  // Indicates whether this transaction is a region/tablespace local transaction or a global
+  // transaction.
+  TransactionLocality locality = TransactionLocality::GLOBAL;
+
+  // Tablespace oid if this transaction is a tablespace-local transaction.
+  PgTablespaceOid tablespace_oid = 0;
+
+  constexpr bool IsGlobal() const {
+    return locality == TransactionLocality::GLOBAL;
+  }
+
+  static constexpr TransactionFullLocality Global() {
+    return { .locality = TransactionLocality::GLOBAL, .tablespace_oid = 0 };
+  }
+
+  static constexpr TransactionFullLocality RegionLocal() {
+    return { .locality = TransactionLocality::REGION_LOCAL, .tablespace_oid = 0 };
+  }
+
+  static constexpr TransactionFullLocality TablespaceLocal(PgTablespaceOid tablespace_oid) {
+    return { .locality = TransactionLocality::TABLESPACE_LOCAL, .tablespace_oid = tablespace_oid };
+  }
+
+  std::string ToString() const;
+};
+
+bool operator==(const TransactionFullLocality& lhs, const TransactionFullLocality& rhs);
+
+std::ostream& operator<<(std::ostream& out, const TransactionFullLocality& locality);
+
 struct TransactionMetadata {
   TransactionId transaction_id = TransactionId::Nil();
   IsolationLevel isolation = IsolationLevel::NON_TRANSACTIONAL;
@@ -396,8 +429,7 @@ struct TransactionMetadata {
   // Matches the txn start time tracked by postgres.
   int64_t pg_txn_start_us = 0;
 
-  // Indicates whether this transaction is a local transaction or global transaction.
-  TransactionLocality locality = TransactionLocality::GLOBAL;
+  TransactionFullLocality locality = TransactionFullLocality::Global();
 
   // Former transaction status tablet that the transaction was using prior to a move.
   TabletId old_status_tablet;
@@ -411,13 +443,7 @@ struct TransactionMetadata {
   void TransactionIdToPB(LWTransactionMetadataPB* dest) const;
   void TransactionIdToPB(TransactionMetadataPB* dest) const;
 
-  std::string ToString() const {
-    return Format(
-        "{ transaction_id: $0 isolation: $1 status_tablet: $2 priority: $3 start_time: $4"
-        " locality: $5 old_status_tablet: $6}",
-        transaction_id, IsolationLevel_Name(isolation), status_tablet, priority, start_time,
-        TransactionLocality_Name(locality), old_status_tablet);
-  }
+  std::string ToString() const;
 
  private:
   template <class PB>
diff --git a/src/yb/common/transaction.proto b/src/yb/common/transaction.proto
index c4a4b585bd..0d2d0bea83 100644
--- a/src/yb/common/transaction.proto
+++ b/src/yb/common/transaction.proto
@@ -51,7 +51,8 @@ enum TransactionStatus {
 
 enum TransactionLocality {
   GLOBAL = 1;
-  LOCAL = 2;
+  REGION_LOCAL = 2;
+  TABLESPACE_LOCAL = 3;
 }
 
 // This enum matches enum RowMarkType defined in src/include/nodes/plannodes.h.
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index fdfeb84e63..a9d83131ae 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -601,8 +601,9 @@ DEFINE_test_flag(int32, system_table_num_tablets, -1,
     "Number of tablets to use when creating the system tables. "
     "If -1, the number of tablets will follow the value provided in the CreateTable request.");
 
-DEFINE_test_flag(bool, enable_tablespace_based_transaction_placement, false,
-                 "Enable support for tablespace-based transaction locality.");
+DEFINE_RUNTIME_AUTO_bool(enable_tablespace_based_transaction_placement, kLocalPersisted,
+                         false, true,
+                         "Enable support for tablespace-based transaction locality.");
 
 DECLARE_bool(enable_pg_cron);
 DECLARE_bool(enable_truncate_cdcsdk_table);
@@ -5147,7 +5148,7 @@ Status CatalogManager::GetPlacementLocalTransactionStatusTablets(
     return Status::OK();
   }
   SharedLock lock(mutex_);
-  const bool add_tablespace_tablets = FLAGS_TEST_enable_tablespace_based_transaction_placement;
+  const bool add_tablespace_tablets = FLAGS_enable_tablespace_based_transaction_placement;
   for (const auto& [tablespace_oid, tablespace_info] : local_tables.tablespaces) {
     if (tablespace_info.tables.empty()) {
       continue;
@@ -13940,19 +13941,33 @@ Status CatalogManager::RegisterFlagCallbacks() {
   if (!flag_callbacks_.empty()) {
     return Status::OK();
   }
-  LOG(INFO) << this << ": register";
   flag_callbacks_.emplace_back(VERIFY_RESULT(RegisterFlagUpdateCallback(
-      &FLAGS_TEST_enable_tablespace_based_transaction_placement,
+      &FLAGS_enable_tablespace_based_transaction_placement,
       Format(
           "CatalogManager($0): Increment transaction tables version when "
           "enable_tablespace_based_transaction_placement enabled.",
           static_cast<void*>(this)),
       [this] {
-        auto status = IncrementTransactionTablesVersion();
+        if (!transaction_tables_config_.get()) {
+          // This happens if callback is called during startup. Safe to just skip since in this
+          // case the autoflag wasn't promoted -- it was already set from the start.
+          return;
+        }
+        Status status = background_tasks_thread_pool_->SubmitFunc(
+            [this] {
+              auto status = IncrementTransactionTablesVersion();
+              if (!status.ok()) {
+                LOG(DFATAL)
+                    << "Failed to increment transaction tables version, tablespace-based "
+                       "transaction placement may not be available until next increment or "
+                       "restart: " << status;
+              }
+            });
         if (!status.ok()) {
           LOG(DFATAL)
-              << "Failed to increment transaction tables version, tablespace-based transaction "
-                 "placement may be available until next increment or restart: " << status;
+              << "Failed to schedule task to increment transaction tables version, "
+                 "tablespace-based transaction placement may not be available until next increment "
+                 "or restart: " << status;
         }
       })));
   return Status::OK();
diff --git a/src/yb/tablet/running_transaction.cc b/src/yb/tablet/running_transaction.cc
index a504f5f60b..07d1a8918d 100644
--- a/src/yb/tablet/running_transaction.cc
+++ b/src/yb/tablet/running_transaction.cc
@@ -662,7 +662,7 @@ const TabletId& RunningTransaction::status_tablet() const {
 void RunningTransaction::UpdateTransactionStatusLocation(const TabletId& new_status_tablet) {
   metadata_.old_status_tablet = std::move(metadata_.status_tablet);
   metadata_.status_tablet = new_status_tablet;
-  metadata_.locality = TransactionLocality::GLOBAL;
+  metadata_.locality = TransactionFullLocality::Global();
 }
 
 void RunningTransaction::UpdateAbortCheckHT(HybridTime now, UpdateAbortCheckHTMode mode) {
diff --git a/src/yb/tserver/pg_client.proto b/src/yb/tserver/pg_client.proto
index 7734576200..88b27f19f8 100644
--- a/src/yb/tserver/pg_client.proto
+++ b/src/yb/tserver/pg_client.proto
@@ -755,7 +755,6 @@ message PgPerformOptionsPB {
   ReadTimeManipulation read_time_manipulation = 10;
   ReadHybridTimePB read_time = 11;
   bool use_catalog_session = 12;
-  bool force_global_transaction = 13;
   string namespace_id = 14;
   bool use_xcluster_database_consistency = 15;
   uint32 active_sub_transaction_id = 16;
@@ -767,6 +766,9 @@ message PgPerformOptionsPB {
 
   reserved 23; // ASH metadata is now passed in RequestHeader PB
 
+  bool force_global_transaction = 13;
+  bool is_all_region_local = 28;
+
   // When set,
   // - Sets the read time locally.
   // - Clamps the read uncertainty window.
diff --git a/src/yb/tserver/pg_client_service.cc b/src/yb/tserver/pg_client_service.cc
index f89bd1690e..a20b843e8f 100644
--- a/src/yb/tserver/pg_client_service.cc
+++ b/src/yb/tserver/pg_client_service.cc
@@ -291,7 +291,7 @@ class LockablePgClientSession {
 
 using TransactionBuilder = std::function<
     client::YBTransactionPtr(
-        TxnAssignment* dest, IsDDL, client::ForceGlobalTransaction, CoarseTimePoint,
+        TxnAssignment* dest, IsDDL, TransactionFullLocality, CoarseTimePoint,
         client::ForceCreateTransaction)>;
 
 class SessionInfo {
@@ -2602,10 +2602,10 @@ class PgClientServiceImpl::Impl : public SessionProvider {
   }
 
   [[nodiscard]] client::YBTransactionPtr BuildTransaction(
-      TxnAssignment* dest, IsDDL is_ddl, client::ForceGlobalTransaction force_global,
+      TxnAssignment* dest, IsDDL is_ddl, TransactionFullLocality locality,
       CoarseTimePoint deadline, client::ForceCreateTransaction force_create_txn) {
     auto watcher = std::make_shared<client::YBTransactionPtr>(
-        transaction_pool_provider_().Take(force_global, deadline, force_create_txn));
+        transaction_pool_provider_().Take(locality, deadline, force_create_txn));
     dest->Assign(watcher, is_ddl);
     auto* txn = &**watcher;
     return {std::move(watcher), txn};
diff --git a/src/yb/tserver/pg_client_session.cc b/src/yb/tserver/pg_client_session.cc
index 8d2f9f0b0c..2f35a911d3 100644
--- a/src/yb/tserver/pg_client_session.cc
+++ b/src/yb/tserver/pg_client_session.cc
@@ -106,6 +106,9 @@ DEFINE_RUNTIME_bool(ysql_ddl_transaction_wait_for_ddl_verification, true,
                     "If set, DDL transactions will wait for DDL verification to complete before "
                     "returning to the client. ");
 
+DEFINE_RUNTIME_bool(use_tablespace_based_transaction_placement, false,
+                    "Use tablespace-local locality will be used instead of region-local locality.");
+
 DEFINE_RUNTIME_uint64(big_shared_memory_segment_session_expiration_time_ms, 5000,
     "Time to release unused allocated big memory segment from session to pool.");
 
@@ -1174,7 +1177,9 @@ class TransactionProvider {
     client::internal::InFlightOpsGroupsWithMetadata ops_info;
     if (!next_plain_) {
       VLOG_WITH_FUNC(1) << "requesting new transaction";
-      auto txn = Build(deadline, {});
+      // TODO(#28317): We should figure out the correct locality and use it here. With table-level
+      // locks, this will prevent transactions from being started as global or tablespace-local(X).
+      auto txn = Build(TransactionFullLocality::RegionLocal(), deadline, {});
       // Don't execute txn->GetMetadata() here since the transaction is not iniatialized with
       // its full metadata yet, like isolation level.
       Synchronizer synchronizer;
@@ -1213,13 +1218,13 @@ class TransactionProvider {
  private:
   struct BuildStrategy {
     bool is_ddl = false;
-    bool force_global = false;
     bool force_create = false;
   };
 
-  client::YBTransactionPtr Build(CoarseTimePoint deadline, const BuildStrategy& strategy) {
+  client::YBTransactionPtr Build(
+      TransactionFullLocality locality, CoarseTimePoint deadline, const BuildStrategy& strategy) {
     return builder_(
-        IsDDL{strategy.is_ddl}, client::ForceGlobalTransaction{strategy.force_global}, deadline,
+        IsDDL{strategy.is_ddl}, locality, deadline,
         client::ForceCreateTransaction{strategy.force_create});
   }
 
@@ -1231,19 +1236,16 @@ class TransactionProvider {
     //
     // Advisory locks table is not placement local, hence we need a global transaction for tagging
     // the requested session advisory locks.
-    return Build(deadline, {.force_global = true, .force_create = true});
+    return Build(TransactionFullLocality::Global(), deadline, {.force_create = true});
   }
 
   client::YBTransactionPtr TakeForDdl(CoarseTimePoint deadline) {
-    return Build(deadline, {.is_ddl = true, .force_global = true});
+    return Build(TransactionFullLocality::Global(), deadline, {.is_ddl = true});
   }
 
-  using TakeForPlainRT = std::pair<client::YBTransactionPtr, EnsureGlobal>;
-  TakeForPlainRT TakeForPlain(
-      client::ForceGlobalTransaction force_global, CoarseTimePoint deadline) {
-    return next_plain_
-        ? TakeForPlainRT{std::exchange(next_plain_, {}), EnsureGlobal{force_global}}
-        : TakeForPlainRT{Build(deadline, {.force_global = force_global}), EnsureGlobal::kFalse};
+  client::YBTransactionPtr TakeForPlain(
+      TransactionFullLocality locality, CoarseTimePoint deadline) {
+    return next_plain_ ? std::exchange(next_plain_, {}) : Build(locality, deadline, {});
   }
 
   const PgClientSession::TransactionBuilder builder_;
@@ -1981,7 +1983,7 @@ class PgClientSession::Impl {
         return Status::OK();
       }
       txn = transaction_provider_.Take<PgClientSessionKind::kPlain>(
-          client::ForceGlobalTransaction::kFalse, deadline).first;
+          TransactionFullLocality::RegionLocal(), deadline);
       VLOG_WITH_PREFIX_AND_FUNC(1) << "Consuming re-usable kPlain txn " << txn->id();
     }
 
@@ -2832,8 +2834,10 @@ class PgClientSession::Impl {
 
     const auto in_txn_limit = GetInTxnLimit(options, clock().get());
     VLOG_WITH_PREFIX(5) << "using in_txn_limit_ht: " << in_txn_limit;
+
+    TransactionFullLocality locality = GetTargetTransactionLocality(data->req);
     auto setup_session_result = VERIFY_RESULT(SetupSession(
-        data->req.options(), deadline, in_txn_limit));
+        data->req.options(), deadline, in_txn_limit, locality));
     auto* session = setup_session_result.session_data.session.get();
     auto& transaction = setup_session_result.session_data.transaction;
 
@@ -3010,7 +3014,8 @@ class PgClientSession::Impl {
   }
 
   Result<SetupSessionResult> SetupSession(
-      const PgPerformOptionsPB& options, CoarseTimePoint deadline, HybridTime in_txn_limit = {}) {
+      const PgPerformOptionsPB& options, CoarseTimePoint deadline, HybridTime in_txn_limit = {},
+      TransactionFullLocality locality = TransactionFullLocality::RegionLocal()) {
     const auto txn_serial_no = options.txn_serial_no();
     const auto read_time_serial_no = options.read_time_serial_no();
     auto kind = PgClientSessionKind::kPlain;
@@ -3037,7 +3042,7 @@ class PgClientSession::Impl {
           read_time_serial_no_ = read_time_serial_no;
         }
       }
-      RETURN_NOT_OK(BeginTransactionIfNecessary(options, deadline));
+      RETURN_NOT_OK(BeginTransactionIfNecessary(options, deadline, locality));
     }
 
     auto& session_data = GetSessionData(kind);
@@ -3154,15 +3159,17 @@ class PgClientSession::Impl {
   }
 
   Status BeginTransactionIfNecessary(
-      const PgPerformOptionsPB& options, CoarseTimePoint deadline) {
-    RETURN_NOT_OK(DoBeginTransactionIfNecessary(options, deadline));
+      const PgPerformOptionsPB& options, CoarseTimePoint deadline,
+      TransactionFullLocality locality) {
+    RETURN_NOT_OK(DoBeginTransactionIfNecessary(options, deadline, locality));
     const auto& data = GetSessionData(PgClientSessionKind::kPlain);
     data.session->SetForceConsistentRead(client::ForceConsistentRead(!data.transaction));
     return Status::OK();
   }
 
   Status DoBeginTransactionIfNecessary(
-      const PgPerformOptionsPB& options, CoarseTimePoint deadline) {
+      const PgPerformOptionsPB& options, CoarseTimePoint deadline,
+      TransactionFullLocality locality) {
     const auto isolation = static_cast<IsolationLevel>(options.isolation());
 
     auto priority = options.priority();
@@ -3208,12 +3215,13 @@ class PgClientSession::Impl {
                  : Status::OK();
     }
 
-    const client::ForceGlobalTransaction force_global_transaction{
+    const bool global_required =
         options.force_global_transaction() ||
-        (options.ddl_mode() && options.ddl_use_regular_transaction_block())};
-    TransactionProvider::EnsureGlobal ensure_global{false};
-    std::tie(txn, ensure_global) = transaction_provider_.Take<kSessionKind>(
-      force_global_transaction, deadline);
+        (options.ddl_mode() && options.ddl_use_regular_transaction_block());
+    if (global_required) {
+      locality = TransactionFullLocality::Global();
+    }
+    txn = transaction_provider_.Take<kSessionKind>(locality, deadline);
     txn->SetLogPrefixTag(kTxnLogPrefixTag, id_);
     RETURN_NOT_OK(txn->SetPgTxnStart(options.pg_txn_start_us()));
     auto* read_point = session->read_point();
@@ -3231,7 +3239,7 @@ class PgClientSession::Impl {
                           << ", new read time";
       RETURN_NOT_OK(txn->Init(isolation));
     }
-    if (ensure_global) {
+    if (global_required) {
       RETURN_NOT_OK(txn->EnsureGlobal(deadline));
     }
 
@@ -3259,7 +3267,8 @@ class PgClientSession::Impl {
                         << options.ShortDebugString();
     const auto in_txn_limit = GetInTxnLimit(options, clock().get());
     VLOG_WITH_PREFIX(5) << "using in_txn_limit_ht: " << in_txn_limit;
-    RETURN_NOT_OK(SetupSession(options, deadline, in_txn_limit));
+    RETURN_NOT_OK(SetupSession(
+        options, deadline, in_txn_limit, TransactionFullLocality::Global()));
     return Status::OK();
   }
 
@@ -3631,6 +3640,27 @@ class PgClientSession::Impl {
     }
   }
 
+  TransactionFullLocality GetTargetTransactionLocality(const PgPerformRequestPB& request) const {
+    if (!FLAGS_use_tablespace_based_transaction_placement) {
+      return request.options().is_all_region_local()
+          ? TransactionFullLocality::RegionLocal() : TransactionFullLocality::Global();
+    }
+
+    PgTablespaceOid tablespace_oid = kInvalidOid;
+    for (const auto& op : request.ops()) {
+      PgTablespaceOid oid =
+          op.has_write() ? op.write().tablespace_oid() : op.read().tablespace_oid();
+      if (tablespace_oid == kInvalidOid) {
+        tablespace_oid = oid;
+      } else if (tablespace_oid != oid) {
+        return TransactionFullLocality::Global();
+      }
+    }
+    return tablespace_oid == kInvalidOid
+        ? TransactionFullLocality::Global()
+        : TransactionFullLocality::TablespaceLocal(tablespace_oid);
+  }
+
   client::YBClient& client_;
   const PgClientSessionContext& context_;
   const std::weak_ptr<PgClientSession> shared_this_;
diff --git a/src/yb/tserver/pg_client_session.h b/src/yb/tserver/pg_client_session.h
index b6570044aa..5dc806b825 100644
--- a/src/yb/tserver/pg_client_session.h
+++ b/src/yb/tserver/pg_client_session.h
@@ -106,7 +106,7 @@ class PgClientSession final {
 
  public:
   using TransactionBuilder = std::function<client::YBTransactionPtr(
-      IsDDL, client::ForceGlobalTransaction, CoarseTimePoint, client::ForceCreateTransaction)>;
+      IsDDL, TransactionFullLocality, CoarseTimePoint, client::ForceCreateTransaction)>;
 
   PgClientSession(
       TransactionBuilder&& transaction_builder, SharedThisSource shared_this_source,
diff --git a/src/yb/util/hash_util.h b/src/yb/util/hash_util.h
index 38c6d52713..c112d0c714 100644
--- a/src/yb/util/hash_util.h
+++ b/src/yb/util/hash_util.h
@@ -100,11 +100,11 @@ class HashUtil {
     boost::hash_combine(_seed, obj_name.elem);
 
 #define YB_STRUCT_HASHER(...) \
-    ([] (const auto& _obj) { \
+    ([] (const auto& _struct) { \
       size_t _seed = 0; \
       BOOST_PP_SEQ_FOR_EACH( \
           YB_STRUCT_HASH_VALUE_HELPER, \
-          _obj, \
+          _struct, \
           BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__)) \
       return _seed; \
     })
diff --git a/src/yb/yql/cql/ql/util/ql_env.cc b/src/yb/yql/cql/ql/util/ql_env.cc
index a562ed224c..b156735e7e 100644
--- a/src/yb/yql/cql/ql/util/ql_env.cc
+++ b/src/yb/yql/cql/ql/util/ql_env.cc
@@ -111,7 +111,9 @@ Result<YBTransactionPtr> QLEnv::NewTransaction(const YBTransactionPtr& transacti
     }
   }
   auto result = transaction_pool_->Take(
-      client::ForceGlobalTransaction(!FLAGS_ycql_use_local_transaction_tables), deadline);
+      FLAGS_ycql_use_local_transaction_tables
+          ? TransactionFullLocality::RegionLocal() : TransactionFullLocality::Global(),
+      deadline);
   RETURN_NOT_OK(result->Init(isolation_level));
   return result;
 }
diff --git a/src/yb/yql/pggate/pg_session.cc b/src/yb/yql/pggate/pg_session.cc
index ec88620de4..a4ebc2fa2f 100644
--- a/src/yb/yql/pggate/pg_session.cc
+++ b/src/yb/yql/pggate/pg_session.cc
@@ -930,11 +930,10 @@ Result<PerformFuture> PgSession::Perform(BufferableOperations&& ops, PerformOpti
     }
   }
 
-  options.set_force_global_transaction(
-      yb_force_global_transaction ||
-      std::any_of(
+  options.set_force_global_transaction(yb_force_global_transaction);
+  options.set_is_all_region_local(std::all_of(
           ops.operations().begin(), ops.operations().end(),
-          [](const auto& op) { return !op->is_region_local(); }));
+          [](const auto& op) { return op->is_region_local(); }));
 
   // For DDLs, ysql_upgrades and PGCatalog accesses, we always use the default read-time
   // and effectively skip xcluster_database_consistency which enables reads as of xcluster safetime.
diff --git a/src/yb/yql/pgwrapper/geo_transactions-test.cc b/src/yb/yql/pgwrapper/geo_transactions-test.cc
index cf4ebd3f4b..5b3f2e59a4 100644
--- a/src/yb/yql/pgwrapper/geo_transactions-test.cc
+++ b/src/yb/yql/pgwrapper/geo_transactions-test.cc
@@ -27,8 +27,9 @@ using std::string;
 DECLARE_int32(master_ts_rpc_timeout_ms);
 DECLARE_bool(auto_create_local_transaction_tables);
 DECLARE_bool(auto_promote_nonlocal_transactions_to_global);
-DECLARE_bool(TEST_enable_tablespace_based_transaction_placement);
+DECLARE_bool(enable_tablespace_based_transaction_placement);
 DECLARE_bool(force_global_transactions);
+DECLARE_bool(use_tablespace_based_transaction_placement);
 DECLARE_bool(transaction_tables_use_preferred_zones);
 
 using namespace std::literals;
@@ -83,10 +84,15 @@ class GeoTransactionsTest : public GeoTransactionsTestBase {
     }
   }
 
-  void CheckSuccess(int to_region, SetGlobalTransactionsGFlag set_global_transactions_gflag,
-                   SetGlobalTransactionSessionVar session_var, InsertToLocalFirst local_first,
-                   ExpectedLocality expected) {
-    auto expected_status_tablets = ASSERT_RESULT(GetStatusTablets(to_region, expected));
+  std::string GetTableName(int region) {
+    return Format("$0$1_1", kTablePrefix, region);
+  }
+
+  void CheckSuccess(auto&& tablespace_or_region, std::optional<std::string_view> local_table,
+                    std::string_view target_table,
+                    SetGlobalTransactionsGFlag set_global_transactions_gflag,
+                    SetGlobalTransactionSessionVar session_var, ExpectedLocality expected) {
+    auto expected_status_tablets = ASSERT_RESULT(GetStatusTablets(tablespace_or_region, expected));
     if (expected != ExpectedLocality::kNoCheck) {
       ASSERT_FALSE(expected_status_tablets.empty());
     }
@@ -94,13 +100,18 @@ class GeoTransactionsTest : public GeoTransactionsTestBase {
         (set_global_transactions_gflag == SetGlobalTransactionsGFlag::kTrue);
 
     auto conn = ASSERT_RESULT(Connect());
+    auto insert_value = NextInsertValue();
     ASSERT_OK(conn.ExecuteFormat("SET force_global_transaction = $0", ToString(session_var)));
     ASSERT_OK(conn.StartTransaction(IsolationLevel::SERIALIZABLE_ISOLATION));
-    if (local_first) {
+    if (local_table) {
       ASSERT_OK(conn.ExecuteFormat(
-          "INSERT INTO $0$1_1(value) VALUES (0)", kTablePrefix, kLocalRegion));
+          "INSERT INTO $0(value) VALUES ($1)", *local_table, insert_value));
+      if (*local_table == target_table) {
+        insert_value = NextInsertValue();
+      }
     }
-    ASSERT_OK(conn.ExecuteFormat("INSERT INTO $0$1_1(value) VALUES (0)", kTablePrefix, to_region));
+    ASSERT_OK(conn.ExecuteFormat(
+        "INSERT INTO $0(value) VALUES ($1)", target_table, insert_value));
     ASSERT_OK(conn.CommitTransaction());
 
     if (expected != ExpectedLocality::kNoCheck) {
@@ -113,10 +124,10 @@ class GeoTransactionsTest : public GeoTransactionsTestBase {
     }
 
     ASSERT_OK(conn.StartTransaction(IsolationLevel::SERIALIZABLE_ISOLATION));
-    if (local_first) {
-      ASSERT_OK(conn.FetchFormat("SELECT * FROM $0$1_1", kTablePrefix, kLocalRegion));
+    if (local_table) {
+      ASSERT_OK(conn.FetchFormat("SELECT * FROM $0", *local_table));
     }
-    ASSERT_OK(conn.FetchFormat("SELECT * FROM $0$1_1", kTablePrefix, to_region));
+    ASSERT_OK(conn.FetchFormat("SELECT * FROM $0", target_table));
     ASSERT_OK(conn.CommitTransaction());
 
     if (expected != ExpectedLocality::kNoCheck) {
@@ -129,50 +140,70 @@ class GeoTransactionsTest : public GeoTransactionsTestBase {
     }
 
     ASSERT_OK(conn.StartTransaction(IsolationLevel::READ_COMMITTED));
-    if (local_first) {
-      ASSERT_OK(conn.FetchFormat("SELECT * FROM $0$1_1", kTablePrefix, kLocalRegion));
+    if (local_table) {
+      ASSERT_OK(conn.FetchFormat("SELECT * FROM $0", *local_table));
     }
-    ASSERT_OK(conn.FetchFormat("SELECT * FROM $0$1_1", kTablePrefix, to_region));
+    ASSERT_OK(conn.FetchFormat("SELECT * FROM $0", target_table));
     ASSERT_OK(conn.CommitTransaction());
   }
 
-  void CheckAbort(int to_region, SetGlobalTransactionsGFlag set_global_transactions_gflag,
-                  SetGlobalTransactionSessionVar session_var, InsertToLocalFirst local_first,
-                  size_t num_aborts) {
+  void CheckSuccess(int to_region, SetGlobalTransactionsGFlag set_global_transactions_gflag,
+                    SetGlobalTransactionSessionVar session_var, InsertToLocalFirst local_first,
+                    ExpectedLocality expected) {
+    CheckSuccess(
+        to_region, local_first ? std::make_optional(GetTableName(kLocalRegion)) : std::nullopt,
+        GetTableName(to_region), set_global_transactions_gflag, session_var, expected);
+  }
+
+  void CheckAbort(std::optional<std::string_view> local_table, std::string_view target_table,
+                  SetGlobalTransactionsGFlag set_global_transactions_gflag,
+                  SetGlobalTransactionSessionVar session_var, size_t num_aborts) {
     ANNOTATE_UNPROTECTED_WRITE(FLAGS_force_global_transactions) = set_global_transactions_gflag;
 
     auto conn = ASSERT_RESULT(Connect());
     ASSERT_OK(conn.ExecuteFormat("SET force_global_transaction = $0", ToString(session_var)));
     for (size_t i = 0; i < num_aborts; ++i) {
       ASSERT_OK(conn.StartTransaction(IsolationLevel::SERIALIZABLE_ISOLATION));
-      if (local_first) {
+      auto insert_value = NextInsertValue();
+      if (local_table) {
         ASSERT_OK(conn.ExecuteFormat(
-            "INSERT INTO $0$1_1(value) VALUES (0)", kTablePrefix, kLocalRegion));
+            "INSERT INTO $0(value) VALUES ($1)", *local_table, insert_value));
+        if (*local_table == target_table) {
+          insert_value = NextInsertValue();
+        }
       }
       ASSERT_NOK(conn.ExecuteFormat(
-          "INSERT INTO $0$1_1(value) VALUES (0)", kTablePrefix, to_region));
+          "INSERT INTO $0(value) VALUES ($1)", target_table, insert_value));
       ASSERT_OK(conn.RollbackTransaction());
     }
 
     for (size_t i = 0; i < num_aborts; ++i) {
       ASSERT_OK(conn.StartTransaction(IsolationLevel::SERIALIZABLE_ISOLATION));
-      if (local_first) {
-        ASSERT_OK(conn.FetchFormat("SELECT * FROM $0$1_1", kTablePrefix, kLocalRegion));
+      if (local_table) {
+        ASSERT_OK(conn.FetchFormat("SELECT * FROM $0", *local_table));
       }
-      ASSERT_NOK(conn.FetchFormat("SELECT * FROM $0$1_1", kTablePrefix, to_region));
+      ASSERT_NOK(conn.FetchFormat("SELECT * FROM $0", target_table));
       ASSERT_OK(conn.RollbackTransaction());
     }
 
     for (size_t i = 0; i < num_aborts; ++i) {
       ASSERT_OK(conn.StartTransaction(IsolationLevel::READ_COMMITTED));
-      if (local_first) {
-        ASSERT_OK(conn.FetchFormat("SELECT * FROM $0$1_1", kTablePrefix, kLocalRegion));
+      if (local_table) {
+        ASSERT_OK(conn.FetchFormat("SELECT * FROM $0", *local_table));
       }
-      ASSERT_OK(conn.FetchFormat("SELECT * FROM $0$1_1", kTablePrefix, to_region));
+      ASSERT_OK(conn.FetchFormat("SELECT * FROM $0", target_table));
       ASSERT_OK(conn.CommitTransaction());
     }
   }
 
+  void CheckAbort(int to_region, SetGlobalTransactionsGFlag set_global_transactions_gflag,
+                  SetGlobalTransactionSessionVar session_var, InsertToLocalFirst local_first,
+                  size_t num_aborts) {
+    CheckAbort(
+        local_first ? std::make_optional(GetTableName(kLocalRegion)) : std::nullopt,
+        GetTableName(to_region), set_global_transactions_gflag, session_var, num_aborts);
+  }
+
   // Get the leader replica count and total replica count of a group of tablets belongs to a table
   // on a tserver.
   Result<std::pair<size_t, size_t>> GetTServerReplicaCount(
@@ -238,6 +269,12 @@ class GeoTransactionsTest : public GeoTransactionsTestBase {
     }
     return true;
   }
+
+  uint64_t NextInsertValue() {
+    return next_insert_value_++;
+  }
+
+  uint64_t next_insert_value_ = 0;
 };
 
 TEST_F(GeoTransactionsTest, YB_DISABLE_TEST_IN_TSAN(TestTransactionTabletSelection)) {
@@ -824,7 +861,7 @@ TEST_F(GeoTransactionsTest, YB_DISABLE_TEST_IN_TSAN(TestAlterTableSetTablespaceM
 
 class GeoTransactionsTablespaceBasedSelectionCandidatesTest : public GeoTransactionsTest {
   void SetUp() override {
-    ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_enable_tablespace_based_transaction_placement) = false;
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_enable_tablespace_based_transaction_placement) = false;
     GeoTransactionsTest::SetUp();
   }
 };
@@ -856,7 +893,7 @@ TEST_F(GeoTransactionsTablespaceBasedSelectionCandidatesTest, TestCandidates) {
   }
 
   auto version = GetCurrentVersion();
-  ASSERT_OK(SET_FLAG(TEST_enable_tablespace_based_transaction_placement, true));
+  ASSERT_OK(SET_FLAG(enable_tablespace_based_transaction_placement, true));
   WaitForStatusTabletsVersion(version + 1);
 
   {
@@ -873,6 +910,314 @@ TEST_F(GeoTransactionsTablespaceBasedSelectionCandidatesTest, TestCandidates) {
   }
 }
 
+class GeoTransactionsTablespaceLocalityTest : public GeoTransactionsTest {
+ public:
+  constexpr static auto kTablespace1 = "tablespace_multi_region1";
+  constexpr static auto kTablespace2 = "tablespace_multi_region2";
+  constexpr static auto kTableName = "table_multi_region";
+  constexpr static auto kTableNameFK = "table_multi_region_fk";
+
+  void SetUp() override {
+    GeoTransactionsTest::SetUp();
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_auto_create_local_transaction_tables) = true;
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_use_tablespace_based_transaction_placement) = true;
+  }
+
+  void SetupTablespaces() override {
+    GeoTransactionsTest::SetupTablespaces();
+
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_force_global_transactions) = true;
+    auto conn = ASSERT_RESULT(Connect());
+    ASSERT_OK(conn.ExecuteFormat(R"#(
+        CREATE TABLESPACE $0 WITH (replica_placement='{
+          "num_replicas": 2,
+          "placement_blocks": [
+            {
+              "cloud": "cloud0",
+              "region": "rack1",
+              "zone": "zone",
+              "min_num_replicas": 1
+            },
+            {
+              "cloud": "cloud0",
+              "region": "rack2",
+              "zone": "zone",
+              "min_num_replicas": 1
+            }
+          ]
+        }')
+    )#", kTablespace1));
+    ASSERT_OK(conn.ExecuteFormat(R"#(
+        CREATE TABLESPACE $0 WITH (replica_placement='{
+          "num_replicas": 2,
+          "placement_blocks": [
+            {
+              "cloud": "cloud0",
+              "region": "rack1",
+              "zone": "zone",
+              "min_num_replicas": 1
+            },
+            {
+              "cloud": "cloud0",
+              "region": "rack3",
+              "zone": "zone",
+              "min_num_replicas": 1
+            }
+          ]
+        }')
+    )#", kTablespace2));
+  }
+
+  void SetupTables(size_t tables_per_region) override {
+    GeoTransactionsTest::SetupTables(tables_per_region);
+
+    auto version = GetCurrentVersion();
+    auto conn = ASSERT_RESULT(Connect());
+    ASSERT_OK(conn.ExecuteFormat(R"#(
+        CREATE TABLE $1(value int PRIMARY KEY, other_value int)
+        TABLESPACE $0
+    )#", kTablespace1, kTableName));
+    ASSERT_OK(conn.ExecuteFormat(R"#(
+        CREATE TABLE $1(value int REFERENCES $2(value))
+        TABLESPACE $0
+    )#", kTablespace1, kTableNameFK, kTableName));
+    WaitForStatusTabletsVersion(version + 1);
+
+    // Dummy table to create transaction tables.
+    ASSERT_OK(conn.ExecuteFormat(R"#(
+        CREATE TABLE __$0_dummy_table(value int)
+        TABLESPACE $0
+    )#", kTablespace2));
+    WaitForStatusTabletsVersion(version + 2);
+    WaitForLoadBalanceCompletion();
+  }
+};
+
+TEST_F(GeoTransactionsTablespaceLocalityTest, TestSimple) {
+  constexpr int kTablesPerRegion = 1;
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_auto_promote_nonlocal_transactions_to_global) = false;
+  SetupTablesAndTablespaces(kTablesPerRegion);
+
+  std::string external_table = GetTableName(kOtherRegion);
+
+  CheckSuccess(
+      kTablespace1, kTableName, kTableName,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kLocal);
+  CheckSuccess(
+      kTablespace1, std::nullopt, external_table,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckAbort(
+      kTableName, external_table,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kFalse,
+      1 /* num_aborts */);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableName,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, external_table,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableName,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, external_table,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableName,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, external_table,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_auto_promote_nonlocal_transactions_to_global) = true;
+
+  // Promotion now allowed. We do not check the status tablet for the promoted case in this test,
+  // because the transaction object we have access to here is from the original take request sent
+  // to the tserver, which is normally discarded and thus not kept up to date.
+  CheckSuccess(
+      kTablespace1, kTableName, kTableName,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kLocal);
+  CheckSuccess(
+      kTablespace1, kTableName, external_table,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kNoCheck);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableName,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, external_table,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableName,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, external_table,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableName,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, external_table,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+}
+
+TEST_F(GeoTransactionsTablespaceLocalityTest, TestFK) {
+  constexpr int kTablesPerRegion = 1;
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_auto_promote_nonlocal_transactions_to_global) = false;
+  SetupTablesAndTablespaces(kTablesPerRegion);
+
+  std::string external_table = GetTableName(kOtherRegion);
+
+  CheckSuccess(
+      kTablespace1, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kLocal);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_auto_promote_nonlocal_transactions_to_global) = true;
+
+  // Promotion now allowed. We do not check the status tablet for the promoted case in this test,
+  // because the transaction object we have access to here is from the original take request sent
+  // to the tserver, which is normally discarded and thus not kept up to date.
+  CheckSuccess(
+      kTablespace1, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kLocal);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+}
+
+TEST_F(GeoTransactionsTablespaceLocalityTest, TestAlterSetTablespace) {
+  constexpr int kTablesPerRegion = 1;
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_auto_promote_nonlocal_transactions_to_global) = false;
+  SetupTablesAndTablespaces(kTablesPerRegion);
+
+  std::string external_table = GetTableName(kOtherRegion);
+
+  CheckSuccess(
+      kTablespace1, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kLocal);
+  CheckSuccess(
+      kTablespace1, std::nullopt, external_table,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckAbort(
+      kTableName, external_table,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kFalse,
+      1 /* num_aborts */);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, external_table,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, external_table,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace1, kTableName, external_table,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+
+  {
+    auto conn = ASSERT_RESULT(Connect());
+    ASSERT_OK(conn.ExecuteFormat(
+        "ALTER TABLE $0 SET TABLESPACE $1", kTableName, kTablespace2));
+    ASSERT_OK(conn.ExecuteFormat(
+        "ALTER TABLE $0 SET TABLESPACE $1", kTableNameFK, kTablespace2));
+  }
+  WaitForLoadBalanceCompletion();
+
+  CheckSuccess(
+      kTablespace2, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kLocal);
+  CheckSuccess(
+      kTablespace2, std::nullopt, external_table,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckAbort(
+      kTableName, external_table,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kFalse,
+      1 /* num_aborts */);
+  CheckSuccess(
+      kTablespace2, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace2, kTableName, external_table,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kFalse,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace2, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace2, kTableName, external_table,
+      SetGlobalTransactionsGFlag::kFalse, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace2, kTableName, kTableNameFK,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+  CheckSuccess(
+      kTablespace2, kTableName, external_table,
+      SetGlobalTransactionsGFlag::kTrue, SetGlobalTransactionSessionVar::kTrue,
+      ExpectedLocality::kGlobal);
+}
+
 class GeoTransactionsWildcardTest : public GeoTransactionsTest {
  protected:
   void SetupTablespaces() override {
diff --git a/src/yb/yql/pgwrapper/geo_transactions_test_base.cc b/src/yb/yql/pgwrapper/geo_transactions_test_base.cc
index 401800ba75..e3f1fe1988 100644
--- a/src/yb/yql/pgwrapper/geo_transactions_test_base.cc
+++ b/src/yb/yql/pgwrapper/geo_transactions_test_base.cc
@@ -334,30 +334,29 @@ bool GeoTransactionsTestBase::AllTabletLeaderInZone(
   return true;
 }
 
-Result<uint32_t> GeoTransactionsTestBase::GetTablespaceOidForRegion(int region) const {
+Result<PgTablespaceOid> GeoTransactionsTestBase::GetTablespaceOid(
+    std::string_view tablespace) const {
   auto conn = EXPECT_RESULT(Connect());
-  return EXPECT_RESULT(conn.FetchRow<pgwrapper::PGOid>(strings::Substitute(
-      "SELECT oid FROM pg_catalog.pg_tablespace WHERE spcname = 'tablespace$0'", region)));
+  LOG(INFO) << tablespace;
+  return EXPECT_RESULT(conn.FetchRow<pgwrapper::PGOid>(Format(
+      "SELECT oid FROM pg_catalog.pg_tablespace WHERE spcname = '$0'", tablespace)));
 }
 
-Result<std::vector<TabletId>> GeoTransactionsTestBase::GetStatusTablets(
-    int region, ExpectedLocality locality) {
+Result<PgTablespaceOid> GeoTransactionsTestBase::GetTablespaceOidForRegion(int region) const {
+  return GetTablespaceOid("tablespace"s + std::to_string(region));
+}
 
+Result<std::vector<TabletId>> GeoTransactionsTestBase::GetStatusTabletsWithTableName(
+    const std::string& local_txn_table, ExpectedLocality locality) {
   YBTableName table_name;
   if (locality == ExpectedLocality::kNoCheck) {
     return std::vector<TabletId>();
   } else if (locality == ExpectedLocality::kGlobal) {
     table_name = YBTableName(
         YQL_DATABASE_CQL, master::kSystemNamespaceName, kGlobalTransactionsTableName);
-  } else if (ANNOTATE_UNPROTECTED_READ(FLAGS_auto_create_local_transaction_tables)) {
-    auto tablespace_oid = EXPECT_RESULT(GetTablespaceOidForRegion(region));
-    table_name = YBTableName(
-        YQL_DATABASE_CQL, master::kSystemNamespaceName,
-        yb::Format("transactions_$0", tablespace_oid));
   } else {
     table_name = YBTableName(
-        YQL_DATABASE_CQL, master::kSystemNamespaceName,
-        yb::Format("transactions_region$0", region));
+        YQL_DATABASE_CQL, master::kSystemNamespaceName, local_txn_table);
   }
   std::vector<TabletId> tablet_uuids;
   RETURN_NOT_OK(client_->GetTablets(
@@ -365,5 +364,21 @@ Result<std::vector<TabletId>> GeoTransactionsTestBase::GetStatusTablets(
   return tablet_uuids;
 }
 
+Result<std::vector<TabletId>> GeoTransactionsTestBase::GetStatusTablets(
+    std::string_view tablespace, ExpectedLocality locality) {
+  auto tablespace_oid = EXPECT_RESULT(GetTablespaceOid(tablespace));
+  return GetStatusTabletsWithTableName(Format("transactions_$0", tablespace_oid), locality);
+}
+
+Result<std::vector<TabletId>> GeoTransactionsTestBase::GetStatusTablets(
+    int region, ExpectedLocality locality) {
+  if (ANNOTATE_UNPROTECTED_READ(FLAGS_auto_create_local_transaction_tables)) {
+    auto tablespace_oid = EXPECT_RESULT(GetTablespaceOidForRegion(region));
+    return GetStatusTabletsWithTableName(Format("transactions_$0", tablespace_oid), locality);
+  } else {
+    return GetStatusTabletsWithTableName(Format("transactions_region$0", region), locality);
+  }
+}
+
 } // namespace client
 } // namespace yb
diff --git a/src/yb/yql/pgwrapper/geo_transactions_test_base.h b/src/yb/yql/pgwrapper/geo_transactions_test_base.h
index bfe7014481..c0d0a7ebb4 100644
--- a/src/yb/yql/pgwrapper/geo_transactions_test_base.h
+++ b/src/yb/yql/pgwrapper/geo_transactions_test_base.h
@@ -88,7 +88,13 @@ class GeoTransactionsTestBase : public pgwrapper::PgMiniTestBase {
 
   void ValidateAllTabletLeaderInZone(std::vector<TabletId> tablet_uuids, int region);
   bool AllTabletLeaderInZone(std::vector<TabletId> tablet_uuids, int region);
-  Result<uint32_t> GetTablespaceOidForRegion(int region) const;
+
+  Result<PgTablespaceOid> GetTablespaceOid(std::string_view tablespace) const;
+  Result<PgTablespaceOid> GetTablespaceOidForRegion(int region) const;
+  Result<std::vector<TabletId>> GetStatusTabletsWithTableName(
+      const std::string& local_txn_table, ExpectedLocality expected);
+  Result<std::vector<TabletId>> GetStatusTablets(
+      std::string_view tablespace, ExpectedLocality locality);
   Result<std::vector<TabletId>> GetStatusTablets(int region, ExpectedLocality locality);
 
   TransactionManager* transaction_manager_;
