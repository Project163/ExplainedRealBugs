diff --git a/src/yb/cdc/cdc_service.cc b/src/yb/cdc/cdc_service.cc
index 274f26b5bc..9085f6df9b 100644
--- a/src/yb/cdc/cdc_service.cc
+++ b/src/yb/cdc/cdc_service.cc
@@ -26,27 +26,24 @@
 #include "yb/cdc/cdc_error.h"
 #include "yb/cdc/cdc_producer.h"
 #include "yb/cdc/cdc_service.pb.h"
-#include "yb/cdc/cdc_util.h"
-#include "yb/cdc/xcluster_rpc.h"
 #include "yb/cdc/cdc_service.proxy.h"
 #include "yb/cdc/cdc_service_context.h"
 #include "yb/cdc/cdc_state_table.h"
 #include "yb/cdc/cdc_types.h"
+#include "yb/cdc/cdc_util.h"
 #include "yb/cdc/cdcsdk_virtual_wal.h"
 #include "yb/cdc/xcluster_producer_bootstrap.h"
+#include "yb/cdc/xcluster_rpc.h"
 #include "yb/cdc/xrepl_stream_metadata.h"
 #include "yb/cdc/xrepl_stream_stats.h"
 
 #include "yb/client/client.h"
 #include "yb/client/meta_cache.h"
 #include "yb/client/schema.h"
-#include "yb/client/table.h"
 #include "yb/client/table_handle.h"
 #include "yb/client/yb_table_name.h"
 
 #include "yb/common/colocated_util.h"
-#include "yb/common/pg_system_attr.h"
-#include "yb/common/schema.h"
 #include "yb/common/wire_protocol.h"
 #include "yb/common/xcluster_util.h"
 
@@ -266,8 +263,7 @@ METRIC_DEFINE_entity(cdcsdk);
 using namespace std::literals;
 using namespace std::placeholders;
 
-namespace yb {
-namespace cdc {
+namespace yb::cdc {
 
 using client::internal::RemoteTabletServer;
 using rpc::RpcContext;
@@ -369,6 +365,7 @@ template <typename T>
 Result<std::shared_ptr<T>> GetOrCreateXreplTabletMetrics(
     const tablet::TabletPeer& tablet_peer, const xrepl::StreamId& stream_id,
     CDCRequestSource source_type, MetricRegistry* metric_registry,
+    std::function<Status(MetricEntity::AttributeMap&)> adjust_attributes_func,
     CreateMetricsEntityIfNotFound create,
     const std::optional<std::string>& slot_name = std::nullopt) {
   const auto tablet_id = tablet_peer.tablet_id();
@@ -389,6 +386,7 @@ Result<std::shared_ptr<T>> GetOrCreateXreplTabletMetrics(
         attrs["slot_name"] = slot_name.value();
       }
     }
+    RETURN_NOT_OK(adjust_attributes_func(attrs));
 
     const std::string metric_id = Format("$0:$1", stream_id, tablet_id);
 
@@ -471,8 +469,10 @@ class CDCServiceImpl::Impl {
     if (!tablet_checkpoints_.count(producer_tablet)) {
       tablet_checkpoints_.emplace(TabletCheckpointInfo{
           .producer_tablet_info = producer_tablet,
-          .cdc_state_checkpoint = {op_id, time, active_time},
-          .sent_checkpoint = {op_id, time, active_time},
+          .cdc_state_checkpoint =
+              {.op_id = op_id, .last_update_time = time, .last_active_time = active_time},
+          .sent_checkpoint =
+              {.op_id = op_id, .last_update_time = time, .last_active_time = active_time},
           .mem_tracker = nullptr});
     }
   }
@@ -663,7 +663,7 @@ class CDCServiceImpl::Impl {
     std::lock_guard l(mutex_);
 
     for (const auto& tablet : tablets) {
-      TabletStreamInfo producer_info{info.stream_id, tablet};
+      TabletStreamInfo producer_info{.stream_id = info.stream_id, .tablet_id = tablet};
       tablet_checkpoints_.emplace(TabletCheckpointInfo{
           .producer_tablet_info = producer_info,
           .cdc_state_checkpoint =
@@ -694,7 +694,8 @@ class CDCServiceImpl::Impl {
       std::lock_guard l(mutex_);
       for (const auto& tablet : tablets) {
         // Add every tablet in the stream.
-        TabletStreamInfo producer_info{info.stream_id, tablet.tablet_id()};
+        TabletStreamInfo producer_info{
+            .stream_id = info.stream_id, .tablet_id = tablet.tablet_id()};
         tablet_checkpoints_.emplace(TabletCheckpointInfo{
             .producer_tablet_info = producer_info,
             .cdc_state_checkpoint =
@@ -1392,7 +1393,8 @@ void CDCServiceImpl::GetTabletListToPollForCDC(
     }
 
     for (const auto& child_tablet_id : child_tablet_ids) {
-      TabletStreamInfo cur_child_tablet = {req_stream_id, child_tablet_id};
+      TabletStreamInfo cur_child_tablet = {
+          .stream_id = req_stream_id, .tablet_id = child_tablet_id};
 
       auto tablet_checkpoint_pair_pb = resp->add_tablet_checkpoint_pairs();
       tablet_checkpoint_pair_pb->mutable_tablet_locations()->CopyFrom(
@@ -1576,7 +1578,7 @@ void CDCServiceImpl::GetChanges(
   CoarseTimePoint deadline = GetDeadline(context, client());
 
   // Check that requested tablet_id is part of the CDC stream.
-  TabletStreamInfo producer_tablet = {stream_id, req->tablet_id()};
+  TabletStreamInfo producer_tablet = {.stream_id = stream_id, .tablet_id = req->tablet_id()};
 
   auto status = CheckTabletValidForStream(producer_tablet);
   if (!status.ok()) {
@@ -2264,7 +2266,8 @@ void CDCServiceImpl::UpdateMetrics() {
 
     // Keep track of all tablets in cdc_state and their last_replication time. This is done to help
     // fill any empty split tablets later, as well as determine what metrics can be cleaned up.
-    TabletStreamInfo tablet_info = {entry.key.stream_id, entry.key.tablet_id};
+    TabletStreamInfo tablet_info = {
+        .stream_id = entry.key.stream_id, .tablet_id = entry.key.tablet_id};
     cdc_state_tablets_to_last_replication_time.emplace(tablet_info, entry.last_replication_time);
 
     auto tablet_peer = context_->LookupTablet(entry.key.tablet_id);
@@ -2387,9 +2390,13 @@ void CDCServiceImpl::UpdateMetrics() {
               // This is a child tablet which has not yet been polled yet, so it still has an empty
               // last_replication_time in cdc_state. In order to update metrics, we will use its
               // parent's last_replication_time.
-              TabletStreamInfo parent_info = {entry.key.stream_id, parent_tablet_id};
+              TabletStreamInfo parent_info = {
+                  .stream_id = entry.key.stream_id, .tablet_id = parent_tablet_id};
               empty_children_tablets.insert(
-                  {tablet_info, {parent_info, last_replicated_micros, tablet_metric}});
+                  {tablet_info,
+                   {.parent_tablet_info = parent_info,
+                    .last_replication_time = last_replicated_micros,
+                    .tablet_metric = tablet_metric}});
               continue;
             }
           }
@@ -2637,7 +2644,7 @@ void CDCServiceImpl::ProcessEntryForCdcsdk(
   }
 
   // Check that requested tablet_id is part of the CDC stream.
-  TabletStreamInfo producer_tablet = {stream_id, tablet_id};
+  TabletStreamInfo producer_tablet = {.stream_id = stream_id, .tablet_id = tablet_id};
 
   // Check stream associated with the tablet is active or not.
   // Don't consider those inactive stream for the min_checkpoint calculation.
@@ -3758,7 +3765,7 @@ void CDCServiceImpl::GetCheckpoint(
 
   auto req_stream_id = RPC_VERIFY_STRING_TO_STREAM_ID(req->stream_id());
   // Check that requested tablet_id is part of the CDC stream.
-  TabletStreamInfo producer_tablet = {req_stream_id, req->tablet_id()};
+  TabletStreamInfo producer_tablet = {.stream_id = req_stream_id, .tablet_id = req->tablet_id()};
   auto s = CheckTabletValidForStream(producer_tablet);
   RPC_STATUS_RETURN_ERROR(s, resp->mutable_error(), CDCErrorPB::INVALID_REQUEST, context);
 
@@ -4602,15 +4609,48 @@ Status CDCServiceImpl::UpdateSnapshotDone(
 Result<std::shared_ptr<xrepl::XClusterTabletMetrics>> CDCServiceImpl::GetXClusterTabletMetrics(
     const tablet::TabletPeer& tablet_peer, const xrepl::StreamId& stream_id,
     CreateMetricsEntityIfNotFound create) {
-  return GetOrCreateXreplTabletMetrics<xrepl::XClusterTabletMetrics>(
-      tablet_peer, stream_id, XCLUSTER, metric_registry_, create);
+  auto adjust_attributes_func = [this,
+                                 &stream_id](MetricEntity::AttributeMap& attributes) -> Status {
+    if (attributes["table_id"] != kPgSequencesDataTableId) {
+      return Status::OK();
+    }
+
+    // Note that the below code runs only once per sequences_data
+    // stream (per TServer restart), of which there is one per
+    // replication group x database pair; this makes the call below to
+    // Master affordable.
+    //
+    // For streams for table sequences_data, we need to get the table
+    // ID and namespace from the stream's table ID, which will be a
+    // sequences_data alias.
+    auto stream_metadata =
+        VERIFY_RESULT(GetStream(stream_id, RefreshStreamMapOption::kIfInitiatedState));
+    SCHECK(stream_metadata, NotFound, "xCluster stream $0 not found", stream_id);
+    std::vector<TableId> table_ids = stream_metadata->GetTableIds();
+    SCHECK_EQ(
+        table_ids.size(), 1, IllegalState,
+        Format("xCluster stream $0 has the wrong number of tables", stream_id));
+    const auto& table_id = table_ids[0];
+    attributes["table_id"] = table_id;
+    const auto namespace_id = VERIFY_RESULT(xcluster::GetReplicationNamespaceBelongsTo(table_id));
+    master::GetNamespaceInfoResponsePB namespace_info_resp;
+    RETURN_NOT_OK(client()->GetNamespaceInfo(
+        namespace_id, /*namespace_name=*/"", YQL_DATABASE_PGSQL, &namespace_info_resp));
+    attributes["namespace_name"] = namespace_info_resp.namespace_().name();
+    return Status::OK();
+  };
+
+  auto result = GetOrCreateXreplTabletMetrics<xrepl::XClusterTabletMetrics>(
+      tablet_peer, stream_id, XCLUSTER, metric_registry_, adjust_attributes_func, create);
+  return result;
 }
 
 Result<std::shared_ptr<xrepl::CDCSDKTabletMetrics>> CDCServiceImpl::GetCDCSDKTabletMetrics(
     const tablet::TabletPeer& tablet_peer, const xrepl::StreamId& stream_id,
     CreateMetricsEntityIfNotFound create, const std::optional<std::string>& slot_name) {
+  auto adjust_attributes_func = [](MetricEntity::AttributeMap&) { return Status::OK(); };
   return GetOrCreateXreplTabletMetrics<xrepl::CDCSDKTabletMetrics>(
-      tablet_peer, stream_id, CDCSDK, metric_registry_, create, slot_name);
+      tablet_peer, stream_id, CDCSDK, metric_registry_, adjust_attributes_func, create, slot_name);
 }
 
 void CDCServiceImpl::RemoveXReplTabletMetrics(
@@ -4708,13 +4748,13 @@ void CDCServiceImpl::IsBootstrapRequired(
         tablet_peer && tablet_peer->IsLeaderAndReady(),
         STATUS(LeaderNotReadyToServe, "Not ready to serve"), resp->mutable_error(),
         CDCErrorPB::LEADER_NOT_READY, context);
-    std::shared_ptr<xrepl::XClusterTabletMetrics> tablet_metric = NULL;
+    std::shared_ptr<xrepl::XClusterTabletMetrics> tablet_metric = nullptr;
 
     OpId op_id = OpId::Invalid();
     if (req->has_stream_id() && !req->stream_id().empty()) {
       auto stream_id = RPC_VERIFY_STRING_TO_STREAM_ID(req->stream_id());
       // Check that requested tablet_id is part of the CDC stream.
-      TabletStreamInfo producer_tablet = {stream_id, tablet_id};
+      TabletStreamInfo producer_tablet = {.stream_id = stream_id, .tablet_id = tablet_id};
       RPC_STATUS_RETURN_ERROR(
           CheckTabletValidForStream(producer_tablet), resp->mutable_error(),
           CDCErrorPB::INVALID_REQUEST, context);
@@ -4745,7 +4785,7 @@ void CDCServiceImpl::IsBootstrapRequired(
     if (tablet_metric) {
       // TODO: Computing this on producer side is expensive. Replace this producer side metric with
       // consumer side APIs or metrics.
-      tablet_metric->is_bootstrap_required->set_value(is_bootstrap_required ? 1 : 0);
+      tablet_metric->is_bootstrap_required->set_value(is_bootstrap_required ? true : false);
     }
   }
   context.RespondSuccess();
@@ -4787,7 +4827,6 @@ Status CDCServiceImpl::UpdateChildrenTabletsOnSplitOpForCDCSDK(const TabletStrea
 Status CDCServiceImpl::UpdateChildrenTabletsOnSplitOpForXCluster(
     const TabletStreamInfo& producer_tablet, const consensus::ReplicateMsg& split_op_msg) {
   const auto& split_req = split_op_msg.split_request();
-  const auto parent_tablet = split_req.tablet_id();
   const vector<string> children_tablets = {split_req.new_tablet1_id(), split_req.new_tablet2_id()};
 
   // First check if the children tablet entries exist yet in cdc_state.
@@ -4867,7 +4906,7 @@ void CDCServiceImpl::CheckReplicationDrain(
         continue;
       }
 
-      TabletStreamInfo producer_tablet = {stream_id, tablet_id};
+      TabletStreamInfo producer_tablet = {.stream_id = stream_id, .tablet_id = tablet_id};
       auto s = CheckTabletValidForStream(producer_tablet);
       if (!s.ok()) {
         LOG_WITH_FUNC(WARNING) << "Tablet not valid for stream: " << s << ". Skipping.";
@@ -5438,5 +5477,4 @@ void CDCServiceImpl::LogGetChangesLagForCDCSDK(
           << getchanges_call_lag.ToPrettyString()
           << ", Commit time lag: " << commit_time_lag.ToPrettyString();
 }
-}  // namespace cdc
-}  // namespace yb
+} // namespace yb::cdc
diff --git a/src/yb/docdb/docdb-test.h b/src/yb/docdb/docdb-test.h
index 484e8b85e3..fef751efc4 100644
--- a/src/yb/docdb/docdb-test.h
+++ b/src/yb/docdb/docdb-test.h
@@ -17,11 +17,10 @@
 
 #include "yb/common/ql_value.h"
 
-#include "yb/docdb/docdb_rocksdb_util.h"
-#include "yb/docdb/docdb_test_base.h"
 #include "yb/docdb/doc_reader.h"
 #include "yb/docdb/doc_reader_redis.h"
-#include "yb/docdb/shared_lock_manager.h"
+#include "yb/docdb/docdb_rocksdb_util.h"
+#include "yb/docdb/docdb_test_base.h"
 
 #include "yb/dockv/doc_key.h"
 
@@ -47,8 +46,7 @@ DECLARE_int32(max_nexts_to_avoid_seek);
 
 #define ASSERT_DOC_DB_DEBUG_DUMP_STR_EQ(str) ASSERT_NO_FATALS(AssertDocDbDebugDumpStrEq(str))
 
-namespace yb {
-namespace docdb {
+namespace yb::docdb {
 
 using dockv::DocKey;
 using dockv::DocPath;
@@ -97,8 +95,7 @@ class DocDBTest : public DocDBTestBase {
     SeedRandom();
   }
 
-  ~DocDBTest() override {
-  }
+  ~DocDBTest() override = default;
 
   Schema CreateSchema() override {
     return Schema();
@@ -588,7 +585,7 @@ void Append(const char* a, const char* b, faststring* out) {
 }
 
 void PushBack(const faststring& value, std::vector<std::string>* out) {
-  out->emplace_back(value.c_str(), value.size());
+  out->emplace_back(value.char_data(), value.size());
 }
 
 void Append(const char* a, const char* b, boost::container::small_vector_base<char>* out) {
@@ -662,5 +659,4 @@ Result<bool> DocDBTableLocksConflictMatrixTest::ObjectLocksConflict(
   return false;
 }
 
-}  // namespace docdb
-}  // namespace yb
+} // namespace yb::docdb
diff --git a/src/yb/integration-tests/master_path_handlers-itest.cc b/src/yb/integration-tests/master_path_handlers-itest.cc
index 2f29cc1b52..debf53d26d 100644
--- a/src/yb/integration-tests/master_path_handlers-itest.cc
+++ b/src/yb/integration-tests/master_path_handlers-itest.cc
@@ -28,7 +28,6 @@
 #include "yb/client/yb_table_name.h"
 
 #include "yb/common/common_types.pb.h"
-#include "yb/consensus/consensus_types.pb.h"
 #include "yb/dockv/partition.h"
 
 #include "yb/gutil/dynamic_annotations.h"
@@ -39,13 +38,11 @@
 
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/catalog_manager_if.h"
-#include "yb/master/master_cluster.proxy.h"
 #include "yb/master/master-path-handlers.h"
+#include "yb/master/master_cluster.proxy.h"
 #include "yb/master/master_fwd.h"
 #include "yb/master/mini_master.h"
 
-#include "yb/master/tasks_tracker.h"
-
 #include "yb/rpc/messenger.h"
 
 #include "yb/server/webui_util.h"
@@ -56,7 +53,6 @@
 #include "yb/tserver/mini_tablet_server.h"
 #include "yb/tserver/stateful_services/stateful_service_base.h"
 #include "yb/tserver/tablet_server.h"
-#include "yb/tserver/tserver_service.pb.h"
 
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/curl_util.h"
@@ -88,8 +84,7 @@ DECLARE_int32(load_balancer_initial_delay_secs);
 DECLARE_bool(TEST_pause_rbs_before_download_wal);
 DECLARE_int32(TEST_sleep_before_reporting_lb_ui_ms);
 
-namespace yb {
-namespace master {
+namespace yb::master {
 
 using std::string;
 using std::vector;
@@ -384,7 +379,7 @@ TEST_F(MasterPathHandlersItest, TestTabletReplicationEndpoint) {
   JsonReader r(result.ToString());
   ASSERT_OK(r.Init());
   const rapidjson::Value* json_obj = nullptr;
-  EXPECT_OK(r.ExtractObject(r.root(), NULL, &json_obj));
+  EXPECT_OK(r.ExtractObject(r.root(), nullptr, &json_obj));
   EXPECT_EQ(rapidjson::kObjectType, CHECK_NOTNULL(json_obj)->GetType());
   EXPECT_TRUE(json_obj->HasMember("leaderless_tablets"));
   EXPECT_EQ(rapidjson::kArrayType, (*json_obj)["leaderless_tablets"].GetType());
@@ -546,7 +541,7 @@ TEST_F(MasterPathHandlersItest, TestTableJsonEndpointValidTableId) {
   JsonReader r(result.ToString());
   ASSERT_OK(r.Init());
   const rapidjson::Value* json_obj = nullptr;
-  EXPECT_OK(r.ExtractObject(r.root(), NULL, &json_obj));
+  EXPECT_OK(r.ExtractObject(r.root(), nullptr, &json_obj));
   EXPECT_EQ(rapidjson::kObjectType, CHECK_NOTNULL(json_obj)->GetType());
   verifyBasicTestTableAttributes(json_obj, table, 0);
   verifyTestTableReplicationInfo(r, json_obj, "zone");
@@ -578,7 +573,7 @@ TEST_F(MasterPathHandlersItest, TestTableJsonEndpointValidTableName) {
   JsonReader r(result.ToString());
   ASSERT_OK(r.Init());
   const rapidjson::Value* json_obj = nullptr;
-  EXPECT_OK(r.ExtractObject(r.root(), NULL, &json_obj));
+  EXPECT_OK(r.ExtractObject(r.root(), nullptr, &json_obj));
   EXPECT_EQ(rapidjson::kObjectType, CHECK_NOTNULL(json_obj)->GetType());
   verifyBasicTestTableAttributes(json_obj, table, 1);
   verifyTestTableReplicationInfo(r, json_obj, "anotherzone");
@@ -596,7 +591,7 @@ TEST_F(MasterPathHandlersItest, TestTableJsonEndpointInvalidTableId) {
   JsonReader r(result.ToString());
   ASSERT_OK(r.Init());
   const rapidjson::Value* json_obj = nullptr;
-  EXPECT_OK(r.ExtractObject(r.root(), NULL, &json_obj));
+  EXPECT_OK(r.ExtractObject(r.root(), nullptr, &json_obj));
   EXPECT_EQ(rapidjson::kObjectType, CHECK_NOTNULL(json_obj)->GetType());
   EXPECT_TRUE(json_obj->HasMember("error"));
   EXPECT_EQ(strcmp("Table not found!", (*json_obj)["error"].GetString()), 0);
@@ -612,7 +607,7 @@ TEST_F(MasterPathHandlersItest, TestTableJsonEndpointNoArgs) {
   JsonReader r(result.ToString());
   ASSERT_OK(r.Init());
   const rapidjson::Value* json_obj = nullptr;
-  EXPECT_OK(r.ExtractObject(r.root(), NULL, &json_obj));
+  EXPECT_OK(r.ExtractObject(r.root(), nullptr, &json_obj));
   EXPECT_EQ(rapidjson::kObjectType, CHECK_NOTNULL(json_obj)->GetType());
   EXPECT_TRUE(json_obj->HasMember("error"));
   EXPECT_EQ(strncmp("Missing", (*json_obj)["error"].GetString(), strlen("Missing")), 0);
@@ -627,7 +622,7 @@ TEST_F(MasterPathHandlersItest, TestTablesJsonEndpoint) {
   JsonReader r(result.ToString());
   ASSERT_OK(r.Init());
   const rapidjson::Value* json_obj = nullptr;
-  EXPECT_OK(r.ExtractObject(r.root(), NULL, &json_obj));
+  EXPECT_OK(r.ExtractObject(r.root(), nullptr, &json_obj));
   EXPECT_EQ(rapidjson::kObjectType, CHECK_NOTNULL(json_obj)->GetType());
 
   // Should have one user table, index should be empty array, system should have many tables.
@@ -675,7 +670,7 @@ TEST_F(MasterPathHandlersItest, TestMemTrackersJsonEndpoint) {
   JsonReader r(result.ToString());
   ASSERT_OK(r.Init());
   const rapidjson::Value* json_obj = nullptr;
-  EXPECT_OK(r.ExtractObject(r.root(), NULL, &json_obj));
+  EXPECT_OK(r.ExtractObject(r.root(), nullptr, &json_obj));
   EXPECT_EQ(rapidjson::kObjectType, CHECK_NOTNULL(json_obj)->GetType());
 
   // Verify that fields are correct
@@ -964,7 +959,7 @@ class MasterPathHandlersUnderReplicationItest : public MasterPathHandlersExterna
     JsonReader r(result.ToString());
     RETURN_NOT_OK(r.Init());
     const rapidjson::Value* json_obj = nullptr;
-    RETURN_NOT_OK(r.ExtractObject(r.root(), NULL, &json_obj));
+    RETURN_NOT_OK(r.ExtractObject(r.root(), nullptr, &json_obj));
     const rapidjson::Value::ConstArray tablets_json =
         (*json_obj)["underreplicated_tablets"].GetArray();
     if (placements.empty()) {
@@ -1270,8 +1265,8 @@ class MasterPathHandlersExternalLeaderlessITest : public MasterPathHandlersExter
   static constexpr int kTserverHeartbeatMetricsIntervalMs = 1000;
 };
 
-typedef MasterPathHandlersExternalLeaderlessITest<3> MasterPathHandlersLeaderlessRF3ITest;
-typedef MasterPathHandlersExternalLeaderlessITest<1> MasterPathHandlersLeaderlessRF1ITest;
+using MasterPathHandlersLeaderlessRF3ITest = MasterPathHandlersExternalLeaderlessITest<3>;
+using MasterPathHandlersLeaderlessRF1ITest = MasterPathHandlersExternalLeaderlessITest<1>;
 
 TEST_F(MasterPathHandlersLeaderlessRF3ITest, TestLeaderlessTabletEndpoint) {
   ASSERT_OK(cluster_->SetFlagOnMasters("leaderless_tablet_alert_delay_secs", "5"));
@@ -1544,7 +1539,7 @@ TEST_F(MasterPathHandlersItest, TestVarzAutoFlag) {
   JsonReader r(result.ToString());
   ASSERT_OK(r.Init());
   const rapidjson::Value* json_obj = nullptr;
-  ASSERT_OK(r.ExtractObject(r.root(), NULL, &json_obj));
+  ASSERT_OK(r.ExtractObject(r.root(), nullptr, &json_obj));
   ASSERT_EQ(rapidjson::kObjectType, CHECK_NOTNULL(json_obj)->GetType());
   ASSERT_TRUE(json_obj->HasMember("flags"));
   ASSERT_EQ(rapidjson::kArrayType, (*json_obj)["flags"].GetType());
@@ -1615,7 +1610,7 @@ TEST_F(MasterPathHandlersItest, TestMetaCache) {
   JsonReader json_reader(result.ToString());
   ASSERT_OK(json_reader.Init());
   const rapidjson::Value* json_object = nullptr;
-  EXPECT_OK(json_reader.ExtractObject(json_reader.root(), NULL, &json_object));
+  EXPECT_OK(json_reader.ExtractObject(json_reader.root(), nullptr, &json_object));
   EXPECT_EQ(rapidjson::kObjectType, CHECK_NOTNULL(json_object)->GetType());
   VerifyMetaCacheObjectIsValid(json_object, json_reader);
 }
@@ -1645,7 +1640,7 @@ TEST_F(MasterPathHandlersItestExtraTS, LoadDistributionViewWithFailedTServer) {
         RETURN_NOT_OK(
             EasyCurl().FetchURL(Format("$0/dump-entities", master_http_url_), &response_body));
         rapidjson::Document result;
-        if (result.Parse(response_body.c_str(), response_body.length()).HasParseError()) {
+        if (result.Parse(response_body.char_data(), response_body.length()).HasParseError()) {
           return STATUS_FORMAT(
               IllegalState, "Failed to parse dump-entities output: $0", response_body.ToString());
         }
@@ -1859,7 +1854,7 @@ TEST_F(MasterPathHandlersItest, StatefulServices) {
     JsonReader r(out.ToString());
     ASSERT_OK(r.Init());
     const rapidjson::Value* json_obj = nullptr;
-    ASSERT_OK(r.ExtractObject(r.root(), NULL, &json_obj));
+    ASSERT_OK(r.ExtractObject(r.root(), nullptr, &json_obj));
     ASSERT_EQ(rapidjson::kObjectType, CHECK_NOTNULL(json_obj)->GetType());
     ASSERT_TRUE(json_obj->HasMember("stateful_services"));
     ASSERT_EQ(rapidjson::kArrayType, (*json_obj)["stateful_services"].GetType());
@@ -1880,7 +1875,7 @@ TEST_F(MasterPathHandlersItest, StatefulServices) {
     JsonReader r(out.ToString());
     ASSERT_OK(r.Init());
     const rapidjson::Value* json_obj = nullptr;
-    ASSERT_OK(r.ExtractObject(r.root(), NULL, &json_obj));
+    ASSERT_OK(r.ExtractObject(r.root(), nullptr, &json_obj));
     ASSERT_EQ(rapidjson::kObjectType, CHECK_NOTNULL(json_obj)->GetType());
     ASSERT_TRUE(json_obj->HasMember("stateful_services"));
     ASSERT_EQ(rapidjson::kArrayType, (*json_obj)["stateful_services"].GetType());
@@ -1905,5 +1900,4 @@ TEST_F(MasterPathHandlersItest, HeapProfile) {
 #endif
 }
 
-}  // namespace master
-}  // namespace yb
+} // namespace yb::master
diff --git a/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc b/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
index 2675b93013..0d4b6a1804 100644
--- a/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
@@ -11,6 +11,7 @@
 // under the License.
 //
 
+#include <gmock/gmock.h>
 
 #include "yb/client/xcluster_client.h"
 #include "yb/client/yb_table_name.h"
@@ -18,7 +19,7 @@
 #include "yb/common/xcluster_util.h"
 #include "yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h"
 #include "yb/integration-tests/xcluster/xcluster_test_utils.h"
-#include "yb/util/flags.h"
+#include "yb/tserver/mini_tablet_server.h"
 #include "yb/util/logging_test_util.h"
 
 DECLARE_bool(TEST_simulate_EnsureSequenceUpdatesAreInWal_failure);
@@ -155,6 +156,52 @@ TEST_F(XClusterAutomaticModeTest, StraightforwardSequenceReplication) {
   ASSERT_OK(VerifySequencesSameOnBothSides(namespace1));
 }
 
+TEST_F(XClusterAutomaticModeTest, SequenceMetricsUseAliases) {
+  // Setup simple automatic replication with sequences so there will
+  // be metrics for sequences_data.
+  ASSERT_OK(SetUpClusters(/*use_different_database_oids=*/false,  namespace_name));
+  ASSERT_OK(SetUpSequences(&producer_cluster_,  namespace_name));
+  ASSERT_OK(SetUpSequences(&consumer_cluster_,  namespace_name));
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces({ namespace_name}));
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+  ASSERT_OK(BumpSequences(&producer_cluster_,  namespace_name));
+  ASSERT_OK(WaitForSequencesReplicationDrain({ namespace_name}));
+  auto namespace_id =
+      ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(),  namespace_name));
+
+  // Fetch Prometheus metrics from producer.
+  std::string addr =
+     ToString(producer_cluster_.mini_cluster_->mini_tablet_server(0)->bound_http_addr());
+  EasyCurl c;
+  faststring buf;
+  ASSERT_OK(c.FetchURL(Format("http://$0/prometheus-metrics", addr), &buf));
+
+  // Check each metric.
+  int xcluster_metric_count = 0;
+  std::string buffer = buf.ToString() + '\n';
+  std::string::size_type start = 0;
+  std::string::size_type end = 0;
+  for (start = 0; (end = buffer.find('\n', start)) != std::string::npos; start = end + 1) {
+    std::string line = buffer.substr(start, end - start);
+    // We only care about xCluster metrics for sequences_data.
+    if (line.find("metric_type=\"xcluster") == std::string::npos) {
+      continue;
+    }
+    if (line.find("sequences_data") == std::string::npos) {
+      continue;
+    }
+
+    xcluster_metric_count++;
+    using ::testing::HasSubstr;
+    EXPECT_THAT(line, HasSubstr(Format("namespace_name=\"$0\"",  namespace_name)));
+    EXPECT_THAT(line, HasSubstr("table_name=\"sequences_data\""));
+    EXPECT_THAT(
+        line, HasSubstr(Format(
+                  "table_id=\"$0\"", xcluster::GetSequencesDataAliasForNamespace(namespace_id))));
+  }
+  EXPECT_GT(xcluster_metric_count, 0);
+}
+
 TEST_F(XClusterAutomaticModeTest, SequenceReplicationWithFiltering) {
   // Unpacked is a harder test case for this code.  With unpacked rows, a single update to a
   // sequence will generate multiple RocksDB key value pairs.  This is harder for the xCluster code
diff --git a/src/yb/util/faststring.h b/src/yb/util/faststring.h
index e3baca065d..689236cf30 100644
--- a/src/yb/util/faststring.h
+++ b/src/yb/util/faststring.h
@@ -184,7 +184,10 @@ class faststring {
 
   // Return a pointer to the data in this string. Note that this pointer
   // may be invalidated by any later non-const operation.
-  const char *c_str() const {
+  //
+  // WARNING: This used to be called c_str(), but does not meet the specification of that method:
+  // this method does not return a null-terminated string!  Accordingly it has been renamed.
+  const char *char_data() const {
     return reinterpret_cast<const char *>(data());
   }
 
diff --git a/src/yb/yql/pgwrapper/pg_catalog_perf-test.cc b/src/yb/yql/pgwrapper/pg_catalog_perf-test.cc
index d49f3aaef5..64772179fb 100644
--- a/src/yb/yql/pgwrapper/pg_catalog_perf-test.cc
+++ b/src/yb/yql/pgwrapper/pg_catalog_perf-test.cc
@@ -16,10 +16,8 @@
 #include <string>
 #include <string_view>
 #include <thread>
-#include <unordered_map>
 
 #include "yb/common/json_util.h"
-#include "yb/common/ysql_operation_lease.h"
 
 #include "yb/master/master.h"
 #include "yb/master/mini_master.h"
@@ -32,7 +30,6 @@
 #include "yb/tserver/mini_tablet_server.h"
 
 #include "yb/util/backoff_waiter.h"
-#include "yb/util/flags.h"
 #include "yb/util/metrics.h"
 #include "yb/util/result.h"
 #include "yb/util/status.h"
@@ -388,7 +385,7 @@ class ClientConnectionsCountFetcher {
           return curl_.FetchURL(url_, &buf).ok();
         },
         5s, "Requesting /rpcz", initial_delay_));
-    const auto doc = VERIFY_RESULT(ParseJson(std::string_view(buf.c_str(), buf.size())));
+    const auto doc = VERIFY_RESULT(ParseJson(std::string_view(buf.char_data(), buf.size())));
     size_t result = 0;
     for (const auto& conn : VERIFY_RESULT(GetMemberAsArray(doc, "connections"))) {
       if (VERIFY_RESULT(GetMemberAsStr(conn, "backend_type")) == "client backend") {
