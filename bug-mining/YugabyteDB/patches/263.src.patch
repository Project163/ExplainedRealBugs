diff --git a/src/yb/cdc/xcluster_producer_bootstrap.cc b/src/yb/cdc/xcluster_producer_bootstrap.cc
index d3395fcc3e..64c8d8e64b 100644
--- a/src/yb/cdc/xcluster_producer_bootstrap.cc
+++ b/src/yb/cdc/xcluster_producer_bootstrap.cc
@@ -123,6 +123,7 @@ Status XClusterProducerBootstrap::RunBootstrapProducer() {
   RETURN_NOT_OK(UpdateCdcStateTableWithCheckpoints());
 
   if (req_.check_if_bootstrap_required()) {
+    LOG_WITH_FUNC(INFO) << "Checking if bootstrap is required.";
     resp_->set_bootstrap_required(VERIFY_RESULT(IsBootstrapRequired()));
   }
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
index 64d1ec90c2..c54b13737e 100644
--- a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
@@ -476,7 +476,9 @@ class XClusterDBScopedTestWithTwoDBs : public XClusterDBScopedTest {
 // Testing adding and removing namespaces to replication.
 void XClusterDBScopedTestWithTwoDBs::TestAddRemoveNamespace() {
   ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CheckpointReplicationGroup(kReplicationGroupId, /*require_no_bootstrap_needed=*/false));
+  // Bootstrap here would have no effect because the database is empty so we skip it even if
+  // CheckpointReplicationGroup said it was required.
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   auto source_xcluster_client = client::XClusterClient(*producer_client());
@@ -487,7 +489,8 @@ void XClusterDBScopedTestWithTwoDBs::TestAddRemoveNamespace() {
 
   auto bootstrap_required =
       ASSERT_RESULT(IsXClusterBootstrapRequired(kReplicationGroupId, source_namespace2_id_));
-  ASSERT_FALSE(bootstrap_required);
+  ASSERT_EQ(bootstrap_required, UseAutomaticMode());
+  // Bootstrap here would have no effect because the database is empty so we skip it for the test.
 
   // Validate streams on source.
   auto streams = ASSERT_RESULT(GetAllXClusterStreams(source_namespace2_id_));
@@ -788,133 +791,134 @@ TEST_F(XClusterDBScopedTest, DeleteWhenSourceIsDown) {
   ASSERT_NOK_STR_CONTAINS(GetAllXClusterStreams(source_namespace_id), "Not found");
 }
 
-  // Validate that we can only have one inbound replication group per database.
-  TEST_F(XClusterDBScopedTest, MultipleInboundReplications) {
-    ASSERT_OK(SetUpClusters());
-    ASSERT_OK(CheckpointReplicationGroup());
-    ASSERT_OK(CreateReplicationFromCheckpoint());
+// Validate that we can only have one inbound replication group per database.
+TEST_F(XClusterDBScopedTest, MultipleInboundReplications) {
+  ASSERT_OK(SetUpClusters());
+  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CreateReplicationFromCheckpoint());
 
-    auto group2 = xcluster::ReplicationGroupId("group2");
+  auto group2 = xcluster::ReplicationGroupId("group2");
 
-    ASSERT_OK(CheckpointReplicationGroup(group2));
-    ASSERT_NOK_STR_CONTAINS(
-        CreateReplicationFromCheckpoint(/*target_master_addresses=*/"", group2),
-        "already included in replication group");
-  }
+  ASSERT_OK(CheckpointReplicationGroup(group2));
+  ASSERT_NOK_STR_CONTAINS(
+      CreateReplicationFromCheckpoint(/*target_master_addresses=*/"", group2),
+      "already included in replication group");
+}
 
-  TEST_F_EX(XClusterDBScopedTest, TestYbAdmin, XClusterDBScopedTestWithTwoDBsAutomaticDDLMode) {
-    ASSERT_OK(SetUpClusters());
-
-    // Create replication with 1 db.
-    auto result = ASSERT_RESULT(CallAdmin(
-        producer_cluster(), "create_xcluster_checkpoint", kReplicationGroupId, namespace_name,
-        "automatic_ddl_mode"));
-    ASSERT_STR_CONTAINS(result, "Bootstrap is not required");
-
-    result = ASSERT_RESULT(CallAdmin(
-        producer_cluster(), "is_xcluster_bootstrap_required", kReplicationGroupId, namespace_name));
-    ASSERT_STR_CONTAINS(result, "Bootstrap is not required");
-
-    const auto target_master_address = consumer_cluster()->GetMasterAddresses();
-    ASSERT_OK(CallAdmin(
-        producer_cluster(), "setup_xcluster_replication", kReplicationGroupId,
-        target_master_address));
-
-    // The extension should exist on both sides with all the tables.
-    ASSERT_OK(VerifyDDLExtensionTablesCreation(namespace_name));
-
-    result =
-        ASSERT_RESULT(CallAdmin(producer_cluster(), "list_xcluster_outbound_replication_groups"));
-    ASSERT_STR_CONTAINS(result, kReplicationGroupId.ToString());
-    const auto source_namespace_id = producer_table_->name().namespace_id();
-    result = ASSERT_RESULT(CallAdmin(
-        producer_cluster(), "list_xcluster_outbound_replication_groups", source_namespace_id));
-    ASSERT_STR_CONTAINS(result, kReplicationGroupId.ToString());
-    result = ASSERT_RESULT(CallAdmin(
-        producer_cluster(), "get_xcluster_outbound_replication_group_info",
-        kReplicationGroupId.ToString()));
-    ASSERT_STR_CONTAINS(result, source_namespace_id);
-    ASSERT_STR_CONTAINS(result, producer_table_->id());
-    ASSERT_STR_NOT_CONTAINS(result, source_namespace2_id_);
-    ASSERT_STR_NOT_CONTAINS(result, source_namespace2_table_->id());
-
-    // Test target side commands.
-    const auto target_namespace_id = consumer_table_->name().namespace_id();
-    result = ASSERT_RESULT(CallAdmin(consumer_cluster(), "list_universe_replications", "na"));
-    ASSERT_STR_NOT_CONTAINS(result, kReplicationGroupId.ToString());
-    result = ASSERT_RESULT(
-        CallAdmin(consumer_cluster(), "list_universe_replications", target_namespace2_id_));
-    ASSERT_STR_NOT_CONTAINS(result, kReplicationGroupId.ToString());
-    result = ASSERT_RESULT(
-        CallAdmin(consumer_cluster(), "list_universe_replications", target_namespace_id));
-    ASSERT_STR_CONTAINS(result, kReplicationGroupId.ToString());
-    result = ASSERT_RESULT(CallAdmin(
-        consumer_cluster(), "get_universe_replication_info", kReplicationGroupId.ToString()));
-    ASSERT_STR_CONTAINS(result, xcluster::ShortReplicationType(XCLUSTER_YSQL_DB_SCOPED));
-    ASSERT_STR_CONTAINS(result, namespace_name);
-    ASSERT_STR_CONTAINS(result, target_namespace_id);
-    ASSERT_STR_CONTAINS(result, source_namespace_id);
-    ASSERT_STR_NOT_CONTAINS(result, target_namespace2_id_);
+TEST_F_EX(XClusterDBScopedTest, TestYbAdmin, XClusterDBScopedTestWithTwoDBsAutomaticDDLMode) {
+  ASSERT_OK(SetUpClusters());
 
-    ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
+  // Create replication with 1 db.
+  auto result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "create_xcluster_checkpoint", kReplicationGroupId, namespace_name,
+      "automatic_ddl_mode"));
+  ASSERT_STR_CONTAINS(result, "Bootstrap is required");
 
-    ASSERT_OK(InsertRowsInProducer(0, 10));
-    ASSERT_OK(VerifyWrittenRecords());
-
-    // Add second db to replication.
-    result = ASSERT_RESULT(CallAdmin(
-        producer_cluster(), "add_namespace_to_xcluster_checkpoint", kReplicationGroupId,
-        namespace_name2_));
-    ASSERT_STR_CONTAINS(result, "Bootstrap is not required");
-
-    ASSERT_OK(CallAdmin(
-        producer_cluster(), "add_namespace_to_xcluster_replication", kReplicationGroupId,
-        namespace_name2_, target_master_address));
-
-    result = ASSERT_RESULT(CallAdmin(
-        producer_cluster(), "get_xcluster_outbound_replication_group_info",
-        kReplicationGroupId.ToString()));
-    ASSERT_STR_CONTAINS(result, namespace_name);
-    ASSERT_STR_CONTAINS(result, producer_table_->id());
-    ASSERT_STR_CONTAINS(result, namespace_name2_);
-    ASSERT_STR_CONTAINS(result, source_namespace2_table_->id());
-
-    // Remove database from both sides with one command.
-    ASSERT_OK(CallAdmin(
-        producer_cluster(), "remove_namespace_from_xcluster_replication", kReplicationGroupId,
-        namespace_name2_, target_master_address));
-
-    // Remove database from replication from each cluster individually.
-    ASSERT_OK(CallAdmin(
-        producer_cluster(), "add_namespace_to_xcluster_checkpoint", kReplicationGroupId,
-        namespace_name2_));
-    ASSERT_OK(CallAdmin(
-        producer_cluster(), "add_namespace_to_xcluster_replication", kReplicationGroupId,
-        namespace_name2_, target_master_address));
-    ASSERT_OK(CallAdmin(
-        consumer_cluster(), "alter_universe_replication", kReplicationGroupId, "remove_namespace",
-        namespace_name2_));
-    ASSERT_OK(CallAdmin(
-        producer_cluster(), "remove_namespace_from_xcluster_replication", kReplicationGroupId,
-        namespace_name2_));
-
-    // Drop replication on both sides.
-    ASSERT_OK(CallAdmin(
-        producer_cluster(), "drop_xcluster_replication", kReplicationGroupId,
-        target_master_address));
-
-    master::GetUniverseReplicationResponsePB resp;
-    ASSERT_NOK_STR_CONTAINS(
-        VerifyUniverseReplication(&resp), "Could not find xCluster replication group");
-
-    ASSERT_NOK_STR_CONTAINS(GetAllXClusterStreams(source_namespace_id), "Not found");
-    ASSERT_OK(VerifyDDLExtensionTablesDeletion(namespace_name));
-
-    result = ASSERT_RESULT(CallAdmin(
-        producer_cluster(), "create_xcluster_checkpoint", kReplicationGroupId, namespace_name,
-        "automatic_ddl_mode"));
-    ASSERT_STR_CONTAINS(result, "Bootstrap is required");
-  }
+  result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "is_xcluster_bootstrap_required", kReplicationGroupId, namespace_name));
+  ASSERT_STR_CONTAINS(result, "Bootstrap is required");
+  // Bootstrap here would have no effect because the database is empty so we skip it for the test.
+
+  const auto target_master_address = consumer_cluster()->GetMasterAddresses();
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "setup_xcluster_replication", kReplicationGroupId,
+      target_master_address));
+
+  // The extension should exist on both sides with all the tables.
+  ASSERT_OK(VerifyDDLExtensionTablesCreation(namespace_name));
+
+  result =
+      ASSERT_RESULT(CallAdmin(producer_cluster(), "list_xcluster_outbound_replication_groups"));
+  ASSERT_STR_CONTAINS(result, kReplicationGroupId.ToString());
+  const auto source_namespace_id = producer_table_->name().namespace_id();
+  result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "list_xcluster_outbound_replication_groups", source_namespace_id));
+  ASSERT_STR_CONTAINS(result, kReplicationGroupId.ToString());
+  result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "get_xcluster_outbound_replication_group_info",
+      kReplicationGroupId.ToString()));
+  ASSERT_STR_CONTAINS(result, source_namespace_id);
+  ASSERT_STR_CONTAINS(result, producer_table_->id());
+  ASSERT_STR_NOT_CONTAINS(result, source_namespace2_id_);
+  ASSERT_STR_NOT_CONTAINS(result, source_namespace2_table_->id());
+
+  // Test target side commands.
+  const auto target_namespace_id = consumer_table_->name().namespace_id();
+  result = ASSERT_RESULT(CallAdmin(consumer_cluster(), "list_universe_replications", "na"));
+  ASSERT_STR_NOT_CONTAINS(result, kReplicationGroupId.ToString());
+  result = ASSERT_RESULT(
+      CallAdmin(consumer_cluster(), "list_universe_replications", target_namespace2_id_));
+  ASSERT_STR_NOT_CONTAINS(result, kReplicationGroupId.ToString());
+  result = ASSERT_RESULT(
+      CallAdmin(consumer_cluster(), "list_universe_replications", target_namespace_id));
+  ASSERT_STR_CONTAINS(result, kReplicationGroupId.ToString());
+  result = ASSERT_RESULT(CallAdmin(
+      consumer_cluster(), "get_universe_replication_info", kReplicationGroupId.ToString()));
+  ASSERT_STR_CONTAINS(result, xcluster::ShortReplicationType(XCLUSTER_YSQL_DB_SCOPED));
+  ASSERT_STR_CONTAINS(result, namespace_name);
+  ASSERT_STR_CONTAINS(result, target_namespace_id);
+  ASSERT_STR_CONTAINS(result, source_namespace_id);
+  ASSERT_STR_NOT_CONTAINS(result, target_namespace2_id_);
+
+  ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
+
+  ASSERT_OK(InsertRowsInProducer(0, 10));
+  ASSERT_OK(VerifyWrittenRecords());
+
+  // Add second db to replication.
+  result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "add_namespace_to_xcluster_checkpoint", kReplicationGroupId,
+      namespace_name2_));
+  ASSERT_STR_CONTAINS(result, "Bootstrap is required");
+  // Bootstrap here would have no effect because the database is empty so we skip it for the test.
+
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "add_namespace_to_xcluster_replication", kReplicationGroupId,
+      namespace_name2_, target_master_address));
+
+  result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "get_xcluster_outbound_replication_group_info",
+      kReplicationGroupId.ToString()));
+  ASSERT_STR_CONTAINS(result, namespace_name);
+  ASSERT_STR_CONTAINS(result, producer_table_->id());
+  ASSERT_STR_CONTAINS(result, namespace_name2_);
+  ASSERT_STR_CONTAINS(result, source_namespace2_table_->id());
+
+  // Remove database from both sides with one command.
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "remove_namespace_from_xcluster_replication", kReplicationGroupId,
+      namespace_name2_, target_master_address));
+
+  // Remove database from replication from each cluster individually.
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "add_namespace_to_xcluster_checkpoint", kReplicationGroupId,
+      namespace_name2_));
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "add_namespace_to_xcluster_replication", kReplicationGroupId,
+      namespace_name2_, target_master_address));
+  ASSERT_OK(CallAdmin(
+      consumer_cluster(), "alter_universe_replication", kReplicationGroupId, "remove_namespace",
+      namespace_name2_));
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "remove_namespace_from_xcluster_replication", kReplicationGroupId,
+      namespace_name2_));
+
+  // Drop replication on both sides.
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "drop_xcluster_replication", kReplicationGroupId, target_master_address));
+
+  master::GetUniverseReplicationResponsePB resp;
+  ASSERT_NOK_STR_CONTAINS(
+      VerifyUniverseReplication(&resp), "Could not find xCluster replication group");
+
+  ASSERT_NOK_STR_CONTAINS(GetAllXClusterStreams(source_namespace_id), "Not found");
+  ASSERT_OK(VerifyDDLExtensionTablesDeletion(namespace_name));
+
+  result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "create_xcluster_checkpoint", kReplicationGroupId, namespace_name,
+      "automatic_ddl_mode"));
+  ASSERT_STR_CONTAINS(result, "Bootstrap is required");
+}
 
 // Make sure we can setup replication with hidden tables.
 TEST_F(XClusterDBScopedTest, CreateReplicationWithHiddenTables) {
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
index 7667b528f8..23fd1b3a7d 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
@@ -41,6 +41,18 @@ const MonoDelta kTimeout = 60s * kTimeMultiplier;
 
 class XClusterDDLReplicationTest : public XClusterDDLReplicationTestBase {
  public:
+  Status SetUpClustersAndCheckpointReplicationGroup(
+      bool is_colocated = false, bool start_yb_controller_servers = false) {
+    RETURN_NOT_OK(SetUpClusters(is_colocated, start_yb_controller_servers));
+    RETURN_NOT_OK(
+        CheckpointReplicationGroup(kReplicationGroupId, /*require_no_bootstrap_needed=*/false));
+    // Bootstrap here would have no effect because the database is empty so we skip it for the test.
+    return Status::OK();
+  }
+
+  // Precondition: a bootstrap is not actually needed.
+  // For example, the two databases might both be completely empty.
+  // This is not the same as whether or not IsXClusterBootstrapRequired will return false.
   Status AddDatabaseToReplication(
       const NamespaceId& source_db_id, const NamespaceId& target_db_id) {
     auto source_xcluster_client = client::XClusterClient(*producer_client());
@@ -48,7 +60,8 @@ class XClusterDDLReplicationTest : public XClusterDDLReplicationTestBase {
         kReplicationGroupId, source_db_id));
     auto bootstrap_required =
         VERIFY_RESULT(IsXClusterBootstrapRequired(kReplicationGroupId, source_db_id));
-    SCHECK(!bootstrap_required, IllegalState, "Bootstrap should not be required");
+    SCHECK(
+        bootstrap_required, IllegalState, "Bootstrap should always be required for Automatic mode");
 
     return AddNamespaceToXClusterReplication(source_db_id, target_db_id);
   }
@@ -56,8 +69,7 @@ class XClusterDDLReplicationTest : public XClusterDDLReplicationTestBase {
 
 // In automatic mode, sequences_data should have been created on both universe.
 TEST_F(XClusterDDLReplicationTest, CheckSequenceDataTable) {
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   ASSERT_OK(RunOnBothClusters([&](Cluster* cluster) -> Status {
@@ -70,8 +82,7 @@ TEST_F(XClusterDDLReplicationTest, CheckSequenceDataTable) {
 }
 
 TEST_F(XClusterDDLReplicationTest, BasicSetupAlterTeardown) {
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   auto source_xcluster_client = client::XClusterClient(*producer_client());
@@ -84,6 +95,7 @@ TEST_F(XClusterDDLReplicationTest, BasicSetupAlterTeardown) {
   const auto namespace_name2 = namespace_name + "2";
   auto [source_db2_id, target_db2_id] =
       ASSERT_RESULT(CreateDatabaseOnBothClusters(namespace_name2));
+  // AddDatabaseToReplication precondition met because databases are empty
   ASSERT_OK(AddDatabaseToReplication(source_db2_id, target_db2_id));
   ASSERT_OK(VerifyDDLExtensionTablesCreation(namespace_name2));
 
@@ -95,6 +107,7 @@ TEST_F(XClusterDDLReplicationTest, BasicSetupAlterTeardown) {
   ASSERT_OK(VerifyDDLExtensionTablesCreation(namespace_name));
 
   // Add the second database to replication again to test dropping everything.
+  // AddDatabaseToReplication precondition met because databases are empty
   ASSERT_OK(AddDatabaseToReplication(source_db2_id, target_db2_id));
   ASSERT_OK(VerifyDDLExtensionTablesCreation(namespace_name2));
 
@@ -107,8 +120,7 @@ TEST_F(XClusterDDLReplicationTest, BasicSetupAlterTeardown) {
 }
 
 TEST_F(XClusterDDLReplicationTest, YB_DISABLE_TEST_ON_MACOS(SurviveRestarts)) {
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   {
@@ -132,10 +144,10 @@ TEST_F(XClusterDDLReplicationTest, YB_DISABLE_TEST_ON_MACOS(SurviveRestarts)) {
 
 TEST_F(XClusterDDLReplicationTest, TestExtensionDeletionWithMultipleReplicationGroups) {
   const xcluster::ReplicationGroupId kReplicationGroupId2("ReplicationGroup2");
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(VerifyDDLExtensionTablesCreation(namespace_name, /*only_source=*/true));
-  ASSERT_OK(CheckpointReplicationGroup(kReplicationGroupId2));
+  ASSERT_OK(
+      CheckpointReplicationGroup(kReplicationGroupId2, /*require_no_bootstrap_needed=*/false));
   ASSERT_OK(VerifyDDLExtensionTablesCreation(namespace_name, /*only_source=*/true));
 
   auto source_xcluster_client = client::XClusterClient(*producer_client());
@@ -150,9 +162,7 @@ TEST_F(XClusterDDLReplicationTest, TestExtensionDeletionWithMultipleReplicationG
 
 TEST_F(XClusterDDLReplicationTest, DisableSplitting) {
   // Ensure that splitting of xCluster DDL Replication tables is disabled on both sides.
-  ASSERT_OK(SetUpClusters());
-
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   for (auto* cluster : {&producer_cluster_, &consumer_cluster_}) {
@@ -172,9 +182,13 @@ TEST_F(XClusterDDLReplicationTest, DisableSplitting) {
 }
 
 TEST_F(XClusterDDLReplicationTest, DDLReplicationTablesNotColocated) {
+  if (!UseYbController()) {
+    GTEST_SKIP() << "This test does not work with yb_backup.py";
+  }
+
   // Ensure that xCluster DDL Replication system tables are not colocated.
 
-  ASSERT_OK(SetUpClusters(/* is_colocated */ true));
+  ASSERT_OK(SetUpClusters(/*is_colocated=*/true, /*start_yb_controller_servers=*/true));
   // Create a colocated table so that we can run xCluster setup.
   ASSERT_OK(RunOnBothClusters([&](Cluster* cluster) -> Status {
     RETURN_NOT_OK(CreateYsqlTable(
@@ -182,7 +196,9 @@ TEST_F(XClusterDDLReplicationTest, DDLReplicationTablesNotColocated) {
     return Status::OK();
   }));
 
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces({namespace_name}));
+  ASSERT_OK(BackupFromProducer());
+  ASSERT_OK(RestoreToConsumer());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   for (auto* cluster : {&producer_cluster_, &consumer_cluster_}) {
@@ -214,6 +230,22 @@ TEST_F(XClusterDDLReplicationTest, Bootstrapping) {
   ASSERT_OK(CreateReplicationFromCheckpoint());
 }
 
+TEST_F(XClusterDDLReplicationTest, BootstrappingEmptyTable) {
+  if (!UseYbController()) {
+    GTEST_SKIP() << "This test does not work with yb_backup.py";
+  }
+
+  ASSERT_OK(SetUpClusters(/*is_colocated=*/false, /*start_yb_controller_servers=*/true));
+  auto producer_table_name = ASSERT_RESULT(CreateYsqlTable(
+      /*idx=*/1, /*num_tablets=*/3, &producer_cluster_));
+
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces({namespace_name}));
+  auto namespace_id = ASSERT_RESULT(GetNamespaceId(producer_client(), namespace_name));
+  auto bootstrap_required =
+      ASSERT_RESULT(IsXClusterBootstrapRequired(kReplicationGroupId, namespace_id));
+  EXPECT_EQ(bootstrap_required, true);
+}
+
 // TODO(Julien): As part of #24888, undisable this or make this a test that this correctly fails
 // with an error.
 TEST_F(XClusterDDLReplicationTest, YB_DISABLE_TEST(BootstrappingWithNoTables)) {
@@ -230,8 +262,7 @@ TEST_F(XClusterDDLReplicationTest, YB_DISABLE_TEST(BootstrappingWithNoTables)) {
 }
 
 TEST_F(XClusterDDLReplicationTest, CreateTable) {
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   // Create a simple table.
@@ -298,7 +329,8 @@ TEST_F(XClusterDDLReplicationTest, CreateTableWithEnum) {
     ASSERT_OK(conn.Execute("DROP TYPE gratuitous_enum;"));
   }
 
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CheckpointReplicationGroup(kReplicationGroupId, /*require_no_bootstrap_needed=*/false));
+  // Bootstrap here would have no effect because the database is empty so we skip it for the test.
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   std::string expected;
@@ -328,8 +360,7 @@ TEST_F(XClusterDDLReplicationTest, CreateTableWithEnum) {
 }
 
 TEST_F(XClusterDDLReplicationTest, BlockMultistatementQuery) {
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   // Have to do this through ysqlsh -c since that sends the whole
@@ -368,8 +399,7 @@ TEST_F(XClusterDDLReplicationTest, BlockMultistatementQuery) {
 }
 
 TEST_F(XClusterDDLReplicationTest, CreateIndex) {
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   const std::string kBaseTableName = "base_table";
@@ -430,8 +460,7 @@ TEST_F(XClusterDDLReplicationTest, ExactlyOnceReplication) {
   // Test that DDLs are only replicated exactly once.
   const int kNumTablets = 3;
 
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   // Fail next DDL query and continue to process it.
@@ -467,8 +496,7 @@ TEST_F(XClusterDDLReplicationTest, ExactlyOnceReplication) {
 }
 
 TEST_F(XClusterDDLReplicationTest, DDLsWithinTransaction) {
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   auto p_conn = ASSERT_RESULT(producer_cluster_.ConnectToDB(namespace_name));
@@ -492,8 +520,7 @@ TEST_F(XClusterDDLReplicationTest, DDLsWithinTransaction) {
 }
 
 TEST_F(XClusterDDLReplicationTest, PauseTargetOnRepeatedFailures) {
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   auto p_conn = ASSERT_RESULT(producer_cluster_.ConnectToDB(namespace_name));
@@ -536,8 +563,7 @@ TEST_F(XClusterDDLReplicationTest, DuplicateTableNames) {
   const int kNumTablets = 3;
   const int kNumRowsTable1 = 10;
   const int kNumRowsTable2 = 3 * kNumRowsTable1;
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   // Pause replication.
@@ -579,8 +605,7 @@ TEST_F(XClusterDDLReplicationTest, RepeatedCreateAndDropTable) {
   // Test when a table is created and dropped multiple times.
   // Decrease number of iterations for slower build types.
   const int kNumIterations = (IsSanitizer() || kIsMac) ? 3 : 10;
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   // Pause replication.
@@ -613,8 +638,7 @@ TEST_F(XClusterDDLReplicationTest, AddRenamedTable) {
   // Test that when a table is renamed, the new table is correctly linked to the source table.
   const std::string kTableNewName = "renamed_table";
 
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   // Pause replication.
@@ -662,8 +686,7 @@ TEST_F(XClusterDDLReplicationTest, AddRenamedTable) {
 }
 
 TEST_F(XClusterDDLReplicationTest, CreateColocatedTables) {
-  ASSERT_OK(SetUpClusters(/*is_colocated=*/true));
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup(/*is_colocated=*/true));
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
@@ -702,8 +725,7 @@ TEST_F(XClusterDDLReplicationTest, CreateColocatedTables) {
 }
 
 TEST_F(XClusterDDLReplicationTest, CreateColocatedIndexes) {
-  ASSERT_OK(SetUpClusters(/*is_colocated=*/true));
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup(/*is_colocated=*/true));
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
@@ -752,8 +774,7 @@ TEST_F(XClusterDDLReplicationTest, CreateColocatedIndexes) {
 }
 
 TEST_F(XClusterDDLReplicationTest, CreateColocatedTableWithPause) {
-  ASSERT_OK(SetUpClusters(/*is_colocated=*/true));
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup(/*is_colocated=*/true));
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
@@ -808,8 +829,7 @@ TEST_F(XClusterDDLReplicationTest, CreateColocatedTableWithPause) {
 }
 
 TEST_F(XClusterDDLReplicationTest, CreateColocatedTableWithSourceFailures) {
-  ASSERT_OK(SetUpClusters(/*is_colocated=*/true));
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup(/*is_colocated=*/true));
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
@@ -857,8 +877,7 @@ TEST_F(XClusterDDLReplicationTest, CreateColocatedTableWithSourceFailures) {
 }
 
 TEST_F(XClusterDDLReplicationTest, CreateColocatedTableWithTargetFailures) {
-  ASSERT_OK(SetUpClusters(/*is_colocated=*/true));
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup(/*is_colocated=*/true));
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
@@ -909,8 +928,7 @@ TEST_F(XClusterDDLReplicationTest, CreateColocatedTableWithTargetFailures) {
 
 // Test is disabled until #25926 is fixed.
 TEST_F(XClusterDDLReplicationTest, YB_DISABLE_TEST(ColocatedHistoricalSchemasWithCompactions)) {
-  ASSERT_OK(SetUpClusters(/*is_colocated=*/true));
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup(/*is_colocated=*/true));
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
@@ -958,8 +976,7 @@ TEST_F(XClusterDDLReplicationTest, YB_DISABLE_TEST(ColocatedHistoricalSchemasWit
 
 TEST_F(XClusterDDLReplicationTest, AlterExistingColocatedTable) {
   // Test alters on a table that is already part of replication.
-  ASSERT_OK(SetUpClusters(/*is_colocated=*/true));
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup(/*is_colocated=*/true));
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   auto producer_conn = ASSERT_RESULT(producer_cluster_.ConnectToDB(namespace_name));
@@ -979,8 +996,7 @@ TEST_F(XClusterDDLReplicationTest, AlterExistingColocatedTable) {
 }
 
 TEST_F(XClusterDDLReplicationTest, ExtraOidAllocationsOnTarget) {
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
   google::SetVLOGLevel("catalog_manager*", 1);
   google::SetVLOGLevel("pg_client_service*", 1);
@@ -1029,9 +1045,8 @@ class XClusterDDLReplicationSwitchoverTest : public XClusterDDLReplicationTest {
 };
 
 TEST_F(XClusterDDLReplicationSwitchoverTest, SwitchoverWithWorkload) {
-  ASSERT_OK(SetUpClusters());
   // Set up replication from A to B.
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   ASSERT_OK(ValidateReplicationRole(*cluster_A_, "source"));
@@ -1107,9 +1122,8 @@ TEST_F(XClusterDDLReplicationSwitchoverTest, SwitchoverWithWorkload) {
 }
 
 TEST_F(XClusterDDLReplicationSwitchoverTest, SwitchoverWithPendingDDL) {
-  ASSERT_OK(SetUpClusters());
   // Set up replication from A to B.
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   ASSERT_OK(ValidateReplicationRole(*cluster_A_, "source"));
@@ -1233,9 +1247,8 @@ TEST_F(XClusterDDLReplicationSwitchoverTest, SwitchoverBumpsAboveUsedOids) {
   // Limit how many OIDs we cache at a time so cache flushing doesn't consume too many OIDs.
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_ysql_oid_cache_prefetch_size) = 1;
 
-  ASSERT_OK(SetUpClusters());
   // Set up replication from A to B.
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   // Log information about OID reservations; search logs for (case insensitive) "reserve".
@@ -1309,8 +1322,7 @@ class XClusterDDLReplicationAddDropColumnTest : public XClusterDDLReplicationTes
   void SetUp() override {
     YB_SKIP_TEST_IN_TSAN();
     XClusterDDLReplicationTest::SetUp();
-    ASSERT_OK(SetUpClusters());
-    ASSERT_OK(CheckpointReplicationGroup());
+    ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
     ASSERT_OK(CreateReplicationFromCheckpoint());
     producer_conn_ = std::make_unique<pgwrapper::PGConn>(
         ASSERT_RESULT(producer_cluster_.ConnectToDB(namespace_name)));
@@ -1479,8 +1491,7 @@ TEST_F(XClusterDDLReplicationAddDropColumnTest, AddDropColumns) {
 // Make sure we can create Colocated db and table on both clusters that is not affected by an the
 // replication of a different database.
 TEST_F(XClusterDDLReplicationTest, CreateNonXClusterColocatedDb) {
-  ASSERT_OK(SetUpClusters());
-  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   const auto kColocatedDB = "colocated_db";
@@ -1503,8 +1514,7 @@ class XClusterDDLReplicationTableRewriteTest : public XClusterDDLReplicationTest
   void SetUp() override {
     YB_SKIP_TEST_IN_TSAN();
     XClusterDDLReplicationTest::SetUp();
-    ASSERT_OK(SetUpClusters());
-    ASSERT_OK(CheckpointReplicationGroup());
+    ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
     ASSERT_OK(CreateReplicationFromCheckpoint());
 
     producer_conn_ = std::make_unique<pgwrapper::PGConn>(
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc
index 6c395b737a..05e0ea0170 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc
@@ -155,7 +155,9 @@ class XClusterPgRegressDDLReplicationTest : public XClusterDDLReplicationTestBas
     RETURN_NOT_OK(conn.Execute("DROP TYPE gratuitous_enum;"));
 
     // Setup xCluster.
-    RETURN_NOT_OK(CheckpointReplicationGroup());
+    RETURN_NOT_OK(
+        CheckpointReplicationGroup(kReplicationGroupId, /*require_no_bootstrap_needed=*/false));
+    // Bootstrap here would have no effect because the database is empty so we skip it for the test.
     RETURN_NOT_OK(CreateReplicationFromCheckpoint());
 
     // Some of the scripts do take a long time to run so setting this timeout high.
diff --git a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
index e68e57e6b0..ae7730027f 100644
--- a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
@@ -30,8 +30,7 @@ DECLARE_uint32(cdc_wal_retention_time_secs);
 DECLARE_uint32(max_xcluster_streams_to_checkpoint_in_parallel);
 DECLARE_bool(TEST_block_xcluster_checkpoint_namespace_task);
 
-namespace yb {
-namespace master {
+namespace yb::master {
 
 const auto kDeadline = MonoDelta::FromSeconds(30);
 const NamespaceName kNamespaceName = "db1";
@@ -41,7 +40,7 @@ const TableName kTableName1 = "table1", kTableName2 = "table2";
 
 class XClusterOutboundReplicationGroupTest : public XClusterYsqlTestBase {
  public:
-  XClusterOutboundReplicationGroupTest() {}
+  XClusterOutboundReplicationGroupTest() = default;
   void SetUp() override {
     XClusterYsqlTestBase::SetUp();
     MiniClusterOptions opts;
@@ -122,7 +121,7 @@ class XClusterOutboundReplicationGroupTest : public XClusterYsqlTestBase {
       const TableId& table_id1, const TableId& table_id2, size_t all_xcluster_streams_count,
       const master::GetXClusterStreamsResponsePB& resp, bool all_tables_included = true,
       const PgSchemaName& table2_schema_name = kPgSchemaName) {
-    ASSERT_FALSE(resp.initial_bootstrap_required());
+    ASSERT_EQ(resp.initial_bootstrap_required(), UseAutomaticMode());
     ASSERT_EQ(resp.table_infos_size(), 2 + (all_tables_included ? OverheadStreamsCount() : 0));
 
     auto all_xcluster_streams = CleanupAndGetAllXClusterStreams();
@@ -762,5 +761,4 @@ TEST_P(XClusterOutboundReplicationGroupParameterized, TestGetStreamByTableId) {
       "Table bad_table_id not found");
 }
 
-}  // namespace master
-}  // namespace yb
+} // namespace yb::master
diff --git a/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc b/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
index 23f44f5d54..1a25ab615c 100644
--- a/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
@@ -449,7 +449,9 @@ class XClusterSequenceDDLOrdering : public XClusterDDLReplicationTestBase {
  public:
   Status SetUpClustersAndReplication() {
     RETURN_NOT_OK(SetUpClusters());
-    RETURN_NOT_OK(CheckpointReplicationGroup());
+    RETURN_NOT_OK(
+        CheckpointReplicationGroup(kReplicationGroupId, /*require_no_bootstrap_needed=*/false));
+    // Bootstrap here would have no effect because the database is empty so we skip it for the test.
     RETURN_NOT_OK(CreateReplicationFromCheckpoint());
     ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_docdb_log_write_batches) = true;
     return Status::OK();
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
index fc9f3d4024..c7d40551a0 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
@@ -161,7 +161,7 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
     }
   }
 
-  void SetUp() {
+  void SetUp() override {
     YBTest::SetUp();
     LOG(INFO) << "Test uses automatic mode: " << UseAutomaticMode();
     ANNOTATE_UNPROTECTED_WRITE(FLAGS_xcluster_enable_ddl_replication) = UseAutomaticMode();
@@ -413,7 +413,7 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
   void VerifyNamespaceCheckpointInfo(
       const TableId& table_id1, const TableId& table_id2, const NamespaceCheckpointInfo& ns_info,
       bool all_tables_included = true, const PgSchemaName& table2_schema_name = kPgSchemaName) {
-    EXPECT_FALSE(ns_info.initial_bootstrap_required);
+    EXPECT_EQ(ns_info.initial_bootstrap_required, UseAutomaticMode());
     ASSERT_EQ(ns_info.table_infos.size(), 2 + (all_tables_included ? OverheadStreamsCount() : 0));
     std::set<TableId> table_ids;
     for (const auto& table_info : ns_info.table_infos) {
@@ -714,8 +714,8 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddTableDuringCheckpoint) {
   auto* sync_point_instance = yb::SyncPoint::GetInstance();
 
   SyncPoint::GetInstance()->LoadDependency(
-      {{"TESTAddTableDuringCheckpoint::TableCreated",
-        "XClusterOutboundReplicationGroup::CreateStreamsForInitialBootstrap"}});
+      {{.predecessor = "TESTAddTableDuringCheckpoint::TableCreated",
+        .successor = "XClusterOutboundReplicationGroup::CreateStreamsForInitialBootstrap"}});
   sync_point_instance->EnableProcessing();
 
   ASSERT_OK(CreateTable(kNamespaceId, kTableId1, kTableName1, kPgSchemaName));
@@ -742,8 +742,8 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, DropTableDuringCheckpoint) {
   auto* sync_point_instance = yb::SyncPoint::GetInstance();
 
   SyncPoint::GetInstance()->LoadDependency(
-      {{"TESTAddTableDuringCheckpoint::TableCreated",
-        "XClusterOutboundReplicationGroup::CreateStreamsForInitialBootstrap"}});
+      {{.predecessor = "TESTAddTableDuringCheckpoint::TableCreated",
+        .successor = "XClusterOutboundReplicationGroup::CreateStreamsForInitialBootstrap"}});
   sync_point_instance->EnableProcessing();
 
   ASSERT_OK(CreateTable(kNamespaceId, kTableId1, kTableName1, kPgSchemaName));
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
index 89ca766289..eb5ac64a61 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
@@ -191,19 +191,26 @@ Status XClusterOutboundReplicationGroup::CheckpointStreamsForInitialBootstrap(
     std::function<void(XClusterCheckpointStreamsResult)> completion_cb) {
   std::vector<std::pair<TableId, xrepl::StreamId>> table_streams;
   std::vector<TableId> table_ids;
-  bool check_if_bootstrap_required = true;
-
+  bool check_if_bootstrap_required;
   {
     std::lock_guard mutex_l(mutex_);
     auto l = VERIFY_RESULT(LockForWrite());
 
-    auto* ns_info = VERIFY_RESULT(GetNamespaceInfo(namespace_id));
+    const auto* ns_info = VERIFY_RESULT(GetNamespaceInfo(namespace_id));
     SCHECK_EQ(
         ns_info->state(), NamespaceInfoPB::CHECKPOINTING, IllegalState,
         "Namespace in unexpected state");
 
-    // We only have to check only if bootstrap is not currently required.
-    check_if_bootstrap_required = !ns_info->initial_bootstrap_required();
+    if (automatic_ddl_mode_) {
+      // Bootstrap is always required for automatic mode, so no need to perform an expensive check.
+      // (In automatic mode we need OIDs to match for things like enums so the semi-automatic check
+      // of "are there any tables with data?" is insufficient to determine if a bootstrap is needed;
+      // accordingly we decided to just always require bootstrap for automatic mode.)
+      check_if_bootstrap_required = false;
+    } else {
+      // We have to check only if bootstrap is not currently required.
+      check_if_bootstrap_required = !ns_info->initial_bootstrap_required();
+    }
 
     for (const auto& [table_id, table_info] : ns_info->table_infos()) {
       if (!TableNeedsInitialCheckpoint(table_info)) {
@@ -222,12 +229,14 @@ Status XClusterOutboundReplicationGroup::CheckpointStreamsForInitialBootstrap(
     }
   }
 
-  auto callback = [table_ids, user_cb = std::move(completion_cb)](Result<bool> result) {
+  auto callback = [table_ids, user_cb = std::move(completion_cb),
+                   automatic_ddl_mode = automatic_ddl_mode_](Result<bool> result) {
     if (!result.ok()) {
       user_cb(result.status());
       return;
     }
-    user_cb(std::make_pair(std::move(table_ids), *result));
+    // Bootstrap is always required in automatic mode.
+    user_cb(std::make_pair(std::move(table_ids), automatic_ddl_mode || *result));
   };
 
   if (!table_ids.empty()) {
@@ -238,7 +247,7 @@ Status XClusterOutboundReplicationGroup::CheckpointStreamsForInitialBootstrap(
         table_streams, StreamCheckpointLocation::kCurrentEndOfWAL, epoch,
         check_if_bootstrap_required, std::move(callback)));
   } else {
-    callback(false);  // Bootstrap not required if we dont have any tables.
+    callback(false);  // Bootstrap not required if we don't have any tables.
     // When MarkBootstrapTablesAsCheckpointed handles this empty table result it will mark the
     // namespace as READY.
     // So, after all tables have been checkpointed this function and
