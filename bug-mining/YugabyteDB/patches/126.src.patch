diff --git a/python/yugabyte/yb_dist_tests.py b/python/yugabyte/yb_dist_tests.py
index 33c14656c5..acc95ccf34 100644
--- a/python/yugabyte/yb_dist_tests.py
+++ b/python/yugabyte/yb_dist_tests.py
@@ -186,6 +186,8 @@ ARCHIVED_PATHS_IN_BUILD_DIR = [
     'share',
     'test_certs',
     'auto_flags.json',
+    'master_flags.xml',
+    'tserver_flags.xml',
     'version_metadata.json',
     'linuxbrew_path.txt',
     'thirdparty_path.txt',
diff --git a/src/yb/integration-tests/master_path_handlers-itest.cc b/src/yb/integration-tests/master_path_handlers-itest.cc
index 93b13e7e2b..ab670fc0b5 100644
--- a/src/yb/integration-tests/master_path_handlers-itest.cc
+++ b/src/yb/integration-tests/master_path_handlers-itest.cc
@@ -1379,8 +1379,8 @@ TEST_F(MasterPathHandlersItest, TestVarzAutoFlag) {
   static const auto kUnExpectedFlag = "TEST_assert_local_op";
 
   // Test the HTML endpoint.
-  static const auto kAutoFlagsStart = "<h2>Auto Flags</h2>";
-  static const auto kAutoFlagsEnd = "<h2>Default Flags</h2>";
+  static const auto kAutoFlagsStart = ">Auto Flags<";
+  static const auto kAutoFlagsEnd = ">Default Flags<";
   faststring result;
   ASSERT_OK(GetUrl("/varz", &result));
   auto result_str = result.ToString();
diff --git a/src/yb/integration-tests/tserver_path_handlers-itest.cc b/src/yb/integration-tests/tserver_path_handlers-itest.cc
index 67af63a409..ca71bb5eba 100644
--- a/src/yb/integration-tests/tserver_path_handlers-itest.cc
+++ b/src/yb/integration-tests/tserver_path_handlers-itest.cc
@@ -104,8 +104,8 @@ TEST_F(TServerPathHandlersItest, TestVarzAutoFlag) {
   static const auto kUnExpectedAutoFlag = "use_parent_table_id_field";
 
   // Test the HTML endpoint.
-  static const auto kAutoFlagsStart = "<h2>Auto Flags</h2>";
-  static const auto kAutoFlagsEnd = "<h2>Default Flags</h2>";
+  static const auto kAutoFlagsStart = ">Auto Flags<";
+  static const auto kAutoFlagsEnd = ">Default Flags<";
 
   auto result = ASSERT_RESULT(FetchURL("/varz"));
 
@@ -121,6 +121,12 @@ TEST_F(TServerPathHandlersItest, TestVarzAutoFlag) {
   auto it_unexpected_flag = result.find(kUnExpectedAutoFlag);
   ASSERT_GT(it_unexpected_flag, it_auto_flags_end);
 
+  // We should not have any hidden flags in the UI. TEST flags are always marked hidden.
+  ASSERT_STR_NOT_CONTAINS(result, "TEST_override_transaction_priority");
+
+  // We should not have any master flags in the tserver.
+  ASSERT_STR_NOT_CONTAINS(result, "master_yb_client_default_timeout_ms");
+
   // Test the JSON API endpoint.
   result = ASSERT_RESULT(FetchURL("/api/v1/varz"));
 
diff --git a/src/yb/master/master.cc b/src/yb/master/master.cc
index d745ac8450..58a4b30752 100644
--- a/src/yb/master/master.cc
+++ b/src/yb/master/master.cc
@@ -224,7 +224,7 @@ Status Master::Init() {
   return Status::OK();
 }
 
-Status Master::InitAutoFlags(rpc::Messenger* messenger) {
+Status Master::InitFlags(rpc::Messenger* messenger) {
   // Will we be in shell mode if we dont have a sys catalog yet?
   bool is_shell_mode_if_new =
       FLAGS_master_join_existing_universe || !opts().AreMasterAddressesProvided();
@@ -236,13 +236,17 @@ Status Master::InitAutoFlags(rpc::Messenger* messenger) {
       } /* has_sys_catalog_func */,
       is_shell_mode_if_new));
 
-  return RpcAndWebServerBase::InitAutoFlags(messenger);
+  return RpcAndWebServerBase::InitFlags(messenger);
 }
 
 Result<std::unordered_set<std::string>> Master::GetAvailableAutoFlagsForServer() const {
   return auto_flags_manager_->GetAvailableAutoFlagsForServer();
 }
 
+Result<std::unordered_set<std::string>> Master::GetFlagsForServer() const {
+  return yb::GetFlagNamesFromXmlFile("master_flags.xml");
+}
+
 Status Master::InitAutoFlagsFromMasterLeader(const HostPort& leader_address) {
   SCHECK(
       opts().IsShellMode(), IllegalState,
diff --git a/src/yb/master/master.h b/src/yb/master/master.h
index fde24f5f2e..ae5dd21a01 100644
--- a/src/yb/master/master.h
+++ b/src/yb/master/master.h
@@ -86,7 +86,7 @@ class Master : public tserver::DbServerBase {
   explicit Master(const MasterOptions& opts);
   virtual ~Master();
 
-  virtual Status InitAutoFlags(rpc::Messenger* messenger) override;
+  virtual Status InitFlags(rpc::Messenger* messenger) override;
   Status InitAutoFlagsFromMasterLeader(const HostPort& leader_address);
   Status Init() override;
   Status Start() override;
@@ -227,6 +227,8 @@ class Master : public tserver::DbServerBase {
 
   Result<std::unordered_set<std::string>> GetAvailableAutoFlagsForServer() const override;
 
+  Result<std::unordered_set<std::string>> GetFlagsForServer() const override;
+
  private:
   friend class MasterTest;
 
diff --git a/src/yb/server/default-path-handlers.cc b/src/yb/server/default-path-handlers.cc
index f0ed3d3e53..03be072b5a 100644
--- a/src/yb/server/default-path-handlers.cc
+++ b/src/yb/server/default-path-handlers.cc
@@ -232,41 +232,43 @@ YB_DEFINE_ENUM(FlagType, (kInvalid)(kNodeInfo)(kCustom)(kAuto)(kDefault));
 struct FlagInfo {
   string name;
   string value;
-  FlagType type;
 };
 
-void ConvertFlagsToJson(const vector<FlagInfo>& flag_infos, std::stringstream* output) {
+void ConvertFlagsToJson(
+    const std::unordered_map<FlagType, std::vector<FlagInfo>>& flag_infos,
+    std::stringstream* output) {
   JsonWriter jw(output, JsonWriter::COMPACT);
   jw.StartObject();
   jw.String("flags");
   jw.StartArray();
 
-  for (const auto& flag_info : flag_infos) {
-    jw.StartObject();
-    jw.String("name");
-    jw.String(flag_info.name);
-    jw.String("value");
-    jw.String(flag_info.value);
-    jw.String("type");
-    // Remove the prefix 'k' from the type name
-    jw.String(ToString(flag_info.type).substr(1));
-    jw.EndObject();
+  for (const auto& [type, flags] : flag_infos) {
+    for (const auto& flag : flags) {
+      jw.StartObject();
+      jw.String("name");
+      jw.String(flag.name);
+      jw.String("value");
+      jw.String(flag.value);
+      jw.String("type");
+      // Remove the prefix 'k' from the type name
+      jw.String(ToString(type).substr(1));
+      jw.EndObject();
+    }
   }
 
   jw.EndArray();
   jw.EndObject();
 }
 
-vector<FlagInfo> GetFlagInfos(
-    const Webserver::WebRequest& req, Webserver* webserver, bool skip_default_test_flags) {
+std::unordered_map<FlagType, std::vector<FlagInfo>> GetFlagInfos(
+    const Webserver::WebRequest& req, Webserver* webserver) {
   const std::set<string> node_info_flags{
       "log_filename",    "rpc_bind_addresses", "webserver_interface", "webserver_port",
       "placement_cloud", "placement_region",   "placement_zone"};
 
   const auto flags = GetAllFlags(req);
 
-  vector<FlagInfo> flag_infos;
-  flag_infos.reserve(flags.size());
+  std::unordered_map<FlagType, std::vector<FlagInfo>> flag_infos;
 
   for (const auto& flag : flags) {
     std::unordered_set<FlagTag> flag_tags;
@@ -274,38 +276,32 @@ vector<FlagInfo> GetFlagInfos(
 
     FlagInfo flag_info;
     flag_info.name = flag.name;
-    flag_info.type = FlagType::kDefault;
 
     if (PREDICT_FALSE(ContainsKey(flag_tags, FlagTag::kSensitive_info))) {
       flag_info.value = "****";
-    } else {
+    } else if (!ContainsKey(flag_tags, FlagTag::kDeprecated)) {
+      // Do not get values of deprecated flags.
       flag_info.value = flag.current_value;
     }
 
+    auto type = FlagType::kDefault;
     if (node_info_flags.contains(flag.name)) {
-      flag_info.type = FlagType::kNodeInfo;
+      type = FlagType::kNodeInfo;
     } else if (flag.current_value != flag.default_value) {
-      flag_info.type = FlagType::kCustom;
+      type = FlagType::kCustom;
     } else if (flag_tags.contains(FlagTag::kAuto) && webserver->ContainsAutoFlag(flag_info.name)) {
-      flag_info.type = FlagType::kAuto;
+      type = FlagType::kAuto;
     }
 
-    if (skip_default_test_flags && flag_info.type == FlagType::kDefault &&
-        flag_tags.contains(FlagTag::kHidden) && flag_info.name.starts_with("TEST_")) {
-      // Skip Default TEST flags.
-      continue;
-    }
-
-    flag_infos.push_back(std::move(flag_info));
+    flag_infos[type].push_back(std::move(flag_info));
   }
 
   // Sort by type, name ascending
-  std::sort(flag_infos.begin(), flag_infos.end(), [](const FlagInfo& lhs, const FlagInfo& rhs) {
-    if (lhs.type == rhs.type) {
+  for (auto& [_, flags] : flag_infos) {
+    std::sort(flags.begin(), flags.end(), [](const FlagInfo& lhs, const FlagInfo& rhs) {
       return ToLowerCase(lhs.name) < ToLowerCase(rhs.name);
-    }
-    return to_underlying(lhs.type) < to_underlying(rhs.type);
-  });
+    });
+  }
 
   return flag_infos;
 }
@@ -314,7 +310,7 @@ vector<FlagInfo> GetFlagInfos(
 // JSON format.
 static void GetFlagsJsonHandler(
     const Webserver::WebRequest& req, Webserver::WebResponse* resp, Webserver* webserver) {
-  const auto flag_infos = GetFlagInfos(req, webserver, /*skip_default_test_flags=*/false);
+  const auto flag_infos = GetFlagInfos(req, webserver);
   ConvertFlagsToJson(std::move(flag_infos), &resp->output);
 }
 
@@ -323,40 +319,52 @@ static void GetFlagsJsonHandler(
 static void FlagsHandler(
     const Webserver::WebRequest& req, Webserver::WebResponse* resp, Webserver* webserver) {
   std::stringstream& output = resp->output;
-  auto flag_infos = GetFlagInfos(req, webserver, /*skip_default_test_flags=*/true);
+  auto flag_infos = GetFlagInfos(req, webserver);
   if (req.parsed_args.find("raw") != req.parsed_args.end()) {
-    for (const auto& flag_info : flag_infos) {
-      output << "--" << flag_info.name << "=" << flag_info.value << endl;
+    for (const auto& [_, flags] : flag_infos) {
+      for (const auto& flag : flags) {
+        output << "--" << flag.name << "=" << flag.value << endl;
+      }
     }
     return;
   }
 
   Tags tags(false /* as_text */);
 
-  // List is sorted by type. Convert to HTML table for each type.
-  FlagType previous_type = FlagType::kInvalid;
-  bool first_table = true;
-  for (auto& flag_info : flag_infos) {
-    if (previous_type != flag_info.type) {
-      if (!first_table) {
-        output << tags.end_table;
-      }
-      first_table = false;
+  HtmlPrintHelper html_print_helper(output);
+  for (const auto& type : FlagTypeList()) {
+    auto field_set = html_print_helper.CreateFieldset(ToString(type).substr(1) + " Flags");
 
-      previous_type = flag_info.type;
+    if (!ContainsKey(flag_infos, type)) {
+      continue;
+    }
 
-      string type_str = ToString(flag_info.type).substr(1);
-      output << tags.header << type_str << " Flags" << tags.end_header;
-      output << tags.table << tags.row << tags.table_header << "Name" << tags.end_table_header
-             << tags.table_header << "Value" << tags.end_table_header << tags.end_row;
+    std::vector<std::string> column_names = {"Name", "Value"};
+    if (type == FlagType::kAuto) {
+      column_names.push_back("State");
     }
+    auto html_table = html_print_helper.CreateTablePrinter(ToString(type), column_names);
+    for (auto& flag : flag_infos.at(type)) {
+      if (type == FlagType::kDefault && !webserver->ContainsFlag(flag.name)) {
+        // Ignore default flags that are not relevant to this process.
+        continue;
+      }
 
-    output << tags.row << tags.cell << flag_info.name << tags.end_cell;
-    output << tags.cell << EscapeForHtmlToString(flag_info.value) << tags.end_cell << tags.end_row;
-  }
+      if (type == FlagType::kAuto) {
+        auto* auto_flag_desc = CHECK_NOTNULL(GetAutoFlagDescription(flag.name));
+        gflags::CommandLineFlagInfo flag_info;
+        if (!gflags::GetCommandLineFlagInfo(flag.name.c_str(), &flag_info)) {
+          LOG(DFATAL) << "Undefined flag " << flag.name;
+          return;
+        }
+        const auto is_promoted = IsFlagPromoted(flag_info, *auto_flag_desc);
 
-  if (!first_table) {
-    output << tags.end_table;
+        html_table.AddRow(flag.name, flag.value, (is_promoted ? "PROMOTED" : "NOT PROMOTED"));
+      } else {
+        html_table.AddRow(flag.name, flag.value);
+      }
+    }
+    html_table.Print();
   }
 }
 
diff --git a/src/yb/server/server_base.cc b/src/yb/server/server_base.cc
index 0fc61c67f9..67537723ea 100644
--- a/src/yb/server/server_base.cc
+++ b/src/yb/server/server_base.cc
@@ -293,7 +293,7 @@ Status RpcServerBase::SetupMessengerBuilder(rpc::MessengerBuilder* builder) {
   return Status::OK();
 }
 
-Status RpcServerBase::InitAutoFlags(rpc::Messenger* messenger) { return Status::OK(); }
+Status RpcServerBase::InitFlags(rpc::Messenger* messenger) { return Status::OK(); }
 
 Status RpcServerBase::Init() {
   CHECK(!initialized_);
@@ -327,7 +327,7 @@ Status RpcServerBase::Init() {
     messenger_->TEST_SetOutboundIpBase(VERIFY_RESULT(HostToAddress(host_ports[0].host())));
   }
 
-  RETURN_NOT_OK(InitAutoFlags(messenger_.get()));
+  RETURN_NOT_OK(InitFlags(messenger_.get()));
 
   RETURN_NOT_OK(rpc_server_->Init(messenger_.get()));
   RETURN_NOT_OK(rpc_server_->Bind());
@@ -547,16 +547,20 @@ Status RpcAndWebServerBase::Init() {
   return Status::OK();
 }
 
-Status RpcAndWebServerBase::InitAutoFlags(rpc::Messenger* messenger) {
-  auto process_auto_flags_result = GetAvailableAutoFlagsForServer();
-  if (!process_auto_flags_result) {
-    LOG(WARNING) << "Unable to get the AutoFlags for this process: "
-                 << process_auto_flags_result.status();
-  } else {
-    web_server_->SetAutoFlags(std::move(*process_auto_flags_result));
+Status RpcAndWebServerBase::InitFlags(rpc::Messenger* messenger) {
+  {
+    auto process_flags =
+        VERIFY_RESULT_PREPEND(GetFlagsForServer(), "Unable to get the flags for this process");
+    web_server_->SetFlags(std::move(process_flags));
+  }
+
+  {
+    auto process_auto_flags = VERIFY_RESULT_PREPEND(
+        GetAvailableAutoFlagsForServer(), "Unable to get the AutoFlags for this process");
+    web_server_->SetAutoFlags(std::move(process_auto_flags));
   }
 
-  return RpcServerBase::InitAutoFlags(messenger);
+  return RpcServerBase::InitFlags(messenger);
 }
 
 void RpcAndWebServerBase::GetStatusPB(ServerStatusPB* status) const {
diff --git a/src/yb/server/server_base.h b/src/yb/server/server_base.h
index e25036063f..ebfcb46ed1 100644
--- a/src/yb/server/server_base.h
+++ b/src/yb/server/server_base.h
@@ -118,7 +118,7 @@ class RpcServerBase {
                 const scoped_refptr<Clock>& clock = nullptr);
   virtual ~RpcServerBase();
 
-  virtual Status InitAutoFlags(rpc::Messenger* messenger);
+  virtual Status InitFlags(rpc::Messenger* messenger);
   virtual Status Init();
   virtual Status Start();
 
@@ -215,7 +215,7 @@ class RpcAndWebServerBase : public RpcServerBase {
                               const std::string caption, const std::string url);
 
   Status Init() override;
-  Status InitAutoFlags(rpc::Messenger* messenger) override;
+  Status InitFlags(rpc::Messenger* messenger) override;
   Status Start() override;
   void Shutdown() override;
 
@@ -223,11 +223,16 @@ class RpcAndWebServerBase : public RpcServerBase {
   std::unique_ptr<Webserver> web_server_;
 
  protected:
-  // Returns all the AutoFlags associated with this process both promoted, and non-promoted ones.
+  // Returns all the AutoFlags associated with this process.
   virtual Result<std::unordered_set<std::string>> GetAvailableAutoFlagsForServer() const {
     return std::unordered_set<std::string>();
   }
 
+  // Returns all the flags associated with this process.
+  virtual Result<std::unordered_set<std::string>> GetFlagsForServer() const {
+    return std::unordered_set<std::string>();
+  }
+
  private:
   void GenerateInstanceID();
   std::string GetEasterEggMessage() const;
diff --git a/src/yb/server/webserver.cc b/src/yb/server/webserver.cc
index d30d2635de..a3b53263a6 100644
--- a/src/yb/server/webserver.cc
+++ b/src/yb/server/webserver.cc
@@ -149,9 +149,13 @@ class Webserver::Impl {
 
   bool IsSecure() const;
 
-  void SetAutoFlags(std::unordered_set<std::string>&& flags);
+  void SetAutoFlags(std::unordered_set<std::string>&& flags) EXCLUDES(flags_mutex_);
 
-  bool ContainsAutoFlag(const std::string& flag) const;
+  bool ContainsAutoFlag(const std::string& flag) const EXCLUDES(flags_mutex_);
+
+  void SetFlags(std::unordered_set<std::string>&& flags) EXCLUDES(flags_mutex_);
+
+  bool ContainsFlag(const std::string& flag) const EXCLUDES(flags_mutex_);
 
  private:
   // Container class for a list of path handler callbacks for a single URL.
@@ -257,11 +261,12 @@ class Webserver::Impl {
   // Variable to notify handlers to stop serving requests.
   std::atomic<bool> stop_initiated = false;
 
-  mutable std::mutex auto_flags_mutex_;
-  // The AutoFlags that are associated with this particular server. In LTO builds we use the same
-  // process for both yb-master and yb-tserver, so the process may have more AutoFlags than this
-  // server needs. This is used to filter out the AutoFlags that are shown in the varz path.
-  std::unordered_set<std::string> auto_flags_;
+  mutable std::mutex flags_mutex_;
+  // The flags that are associated with this particular server. In LTO builds we use the same
+  // process for both yb-master and yb-tserver, so the running process may have more flags than
+  // this server needs. This is used to filter out the flags that are shown in the varz UI.
+  std::unordered_set<std::string> auto_flags_ GUARDED_BY(flags_mutex_);
+  std::unordered_set<std::string> process_flags_ GUARDED_BY(flags_mutex_);
 };
 
 Webserver::Impl::Impl(const WebserverOptions& opts, const std::string& server_name)
@@ -301,15 +306,25 @@ bool Webserver::Impl::IsSecure() const {
 }
 
 void Webserver::Impl::SetAutoFlags(std::unordered_set<std::string>&& flags) {
-  std::lock_guard l(auto_flags_mutex_);
+  std::lock_guard l(flags_mutex_);
   auto_flags_ = std::move(flags);
 }
 
 bool Webserver::Impl::ContainsAutoFlag(const std::string& flag) const {
-  std::lock_guard l(auto_flags_mutex_);
+  std::lock_guard l(flags_mutex_);
   return auto_flags_.contains(flag);
 }
 
+void Webserver::Impl::SetFlags(std::unordered_set<std::string>&& flags) {
+  std::lock_guard l(flags_mutex_);
+  process_flags_ = std::move(flags);
+}
+
+bool Webserver::Impl::ContainsFlag(const std::string& flag) const {
+  std::lock_guard l(flags_mutex_);
+  return process_flags_.contains(flag);
+}
+
 Status Webserver::Impl::BuildListenSpec(string* spec) const {
   std::vector<Endpoint> endpoints;
   RETURN_NOT_OK(ParseAddressList(http_address_, 80, &endpoints));
@@ -880,4 +895,10 @@ void Webserver::SetAutoFlags(std::unordered_set<std::string>&& flags) {
 bool Webserver::ContainsAutoFlag(const std::string& flag) const {
   return impl_->ContainsAutoFlag(flag);
 }
+
+void Webserver::SetFlags(std::unordered_set<std::string>&& flags) {
+  impl_->SetFlags(std::move(flags));
+}
+
+bool Webserver::ContainsFlag(const std::string& flag) const { return impl_->ContainsFlag(flag); }
 } // namespace yb
diff --git a/src/yb/server/webserver.h b/src/yb/server/webserver.h
index 1fcfe856d7..77881cc6e9 100644
--- a/src/yb/server/webserver.h
+++ b/src/yb/server/webserver.h
@@ -98,6 +98,10 @@ class Webserver : public WebCallbackRegistry {
 
   bool ContainsAutoFlag(const std::string& flag) const;
 
+  void SetFlags(std::unordered_set<std::string>&& flags);
+
+  bool ContainsFlag(const std::string& flag) const;
+
  private:
   class Impl;
   std::unique_ptr<Impl> impl_;
diff --git a/src/yb/tserver/tablet_server.cc b/src/yb/tserver/tablet_server.cc
index 454820dccb..2662b31164 100644
--- a/src/yb/tserver/tablet_server.cc
+++ b/src/yb/tserver/tablet_server.cc
@@ -522,10 +522,10 @@ Status TabletServer::Init() {
   return Status::OK();
 }
 
-Status TabletServer::InitAutoFlags(rpc::Messenger* messenger) {
+Status TabletServer::InitFlags(rpc::Messenger* messenger) {
   RETURN_NOT_OK(auto_flags_manager_->Init(messenger, *opts_.GetMasterAddresses()));
 
-  return RpcAndWebServerBase::InitAutoFlags(messenger);
+  return RpcAndWebServerBase::InitFlags(messenger);
 }
 
 Result<std::unordered_set<std::string>> TabletServer::GetAvailableAutoFlagsForServer() const {
@@ -536,6 +536,10 @@ uint32_t TabletServer::GetAutoFlagConfigVersion() const {
   return auto_flags_manager_->GetConfigVersion();
 }
 
+Result<std::unordered_set<std::string>> TabletServer::GetFlagsForServer() const {
+  return yb::GetFlagNamesFromXmlFile("tserver_flags.xml");
+}
+
 void TabletServer::HandleMasterHeartbeatResponse(
     HybridTime heartbeat_sent_time, std::optional<AutoFlagsConfigPB> new_config) {
   auto_flags_manager_->HandleMasterHeartbeatResponse(heartbeat_sent_time, std::move(new_config));
diff --git a/src/yb/tserver/tablet_server.h b/src/yb/tserver/tablet_server.h
index f05a385208..78698ff745 100644
--- a/src/yb/tserver/tablet_server.h
+++ b/src/yb/tserver/tablet_server.h
@@ -123,7 +123,7 @@ class TabletServer : public DbServerBase, public TabletServerIf {
   // complete by calling WaitInited().
   Status Init() override;
 
-  virtual Status InitAutoFlags(rpc::Messenger* messenger) override;
+  virtual Status InitFlags(rpc::Messenger* messenger) override;
 
   virtual bool ShouldExportLocalCalls() override {
     return true;
@@ -397,6 +397,8 @@ class TabletServer : public DbServerBase, public TabletServerIf {
 
   Result<std::unordered_set<std::string>> GetAvailableAutoFlagsForServer() const override;
 
+  Result<std::unordered_set<std::string>> GetFlagsForServer() const override;
+
   void SetCronLeaderLease(MonoTime cron_leader_lease_end);
 
   std::atomic<bool> initted_{false};
diff --git a/src/yb/util/flags.h b/src/yb/util/flags.h
index ec558ddac0..a823316a1c 100644
--- a/src/yb/util/flags.h
+++ b/src/yb/util/flags.h
@@ -191,6 +191,8 @@ class FlagValidatorSink : public google::LogSink {
 
 FlagValidatorSink& GetFlagValidatorSink();
 
+Result<std::unordered_set<std::string>> GetFlagNamesFromXmlFile(const std::string& flag_file_name);
+
 // Log error message to the error log and the flag validator sink, which will ensure it is sent
 // back to the user. Also masks any sensitive values.
 #define LOG_FLAG_VALIDATION_ERROR(flag_name, value) \
diff --git a/src/yb/util/flags/flags.cc b/src/yb/util/flags/flags.cc
index f93f81c35d..70a4782d4e 100644
--- a/src/yb/util/flags/flags.cc
+++ b/src/yb/util/flags/flags.cc
@@ -30,6 +30,8 @@
 // under the License.
 //
 
+#include <fstream>
+#include <regex>
 #include <string>
 #include <unordered_set>
 #include <vector>
@@ -37,6 +39,7 @@
 #include "yb/gutil/map-util.h"
 #include "yb/gutil/once.h"
 #include "yb/gutil/strings/split.h"
+#include "yb/util/env_util.h"
 #include "yb/util/flags/flag_tags.h"
 
 #if YB_GPERFTOOLS_TCMALLOC
@@ -897,4 +900,26 @@ bool RecordFlagForDelayedValidation(const std::string& flag_name) {
   return true;
 }
 
+// Read the flags xml file and return the list of flag names.
+Result<std::unordered_set<std::string>> GetFlagNamesFromXmlFile(const std::string& flag_file_name) {
+  std::unordered_set<std::string> flag_names;
+
+  string build_path = yb::env_util::GetRootDir("bin");
+
+  auto full_path = JoinPathSegments(build_path, flag_file_name);
+  std::ifstream xml_file(full_path, std::ios_base::in);
+  SCHECK(xml_file, IOError, Format("Could not open XML file $0: $1", full_path, strerror(errno)));
+
+  static std::regex re(R"#(<name>(.*?)</name>)#");
+  std::string line;
+  while (std::getline(xml_file, line)) {
+    std::smatch match;
+    if (std::regex_search(line, match, re)) {
+      flag_names.insert(match.str(1));
+    }
+  }
+
+  return flag_names;
+}
+
 } // namespace yb
