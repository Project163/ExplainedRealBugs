diff --git a/src/yb/cdc/cdc_service.cc b/src/yb/cdc/cdc_service.cc
index 483cbdcbad..6c630a9451 100644
--- a/src/yb/cdc/cdc_service.cc
+++ b/src/yb/cdc/cdc_service.cc
@@ -254,32 +254,6 @@ METRIC_DEFINE_entity(cdcsdk);
       xrepl::StreamId::FromString(stream_id_str), resp->mutable_error(), \
       CDCErrorPB::INVALID_REQUEST, context)
 
-// TODO(22655): Remove the below macro once YB_LOG_EVERY_N_SECS_OR_VLOG() is fixed.
-#define YB_CDC_LOG_EVERY_N_SECS_OR_VLOG(oss, n_secs, verbose_level) \
-  do { \
-    if (VLOG_IS_ON(verbose_level)) { \
-      switch (verbose_level) { \
-        case 1: \
-          VLOG(1) << (oss).str(); \
-          break; \
-        case 2: \
-          VLOG(2) << (oss).str(); \
-          break; \
-        case 3: \
-          VLOG(3) << (oss).str(); \
-          break; \
-        case 4: \
-          VLOG(4) << (oss).str(); \
-          break; \
-        default: \
-          LOG(INFO) << (oss).str(); \
-          break; \
-      } \
-    } else { \
-      YB_LOG_EVERY_N_SECS(INFO, n_secs) << (oss).str(); \
-    } \
-  } while (0)
-
 using namespace std::literals;
 using namespace std::placeholders;
 
@@ -4859,9 +4833,8 @@ void CDCServiceImpl::GetConsistentChanges(
     return;
   }
 
-  std::ostringstream oss;
-  oss << "Received GetConsistentChanges request: " << req->ShortDebugString();
-  YB_CDC_LOG_EVERY_N_SECS_OR_VLOG(oss, 300, 1);
+  YB_LOG_EVERY_N_SECS_OR_VLOG(INFO, 300, 1)
+      << "Received GetConsistentChanges request: " << req->ShortDebugString();
 
   RPC_CHECK_AND_RETURN_ERROR(
       req->has_session_id(),
@@ -4998,9 +4971,8 @@ void CDCServiceImpl::UpdateAndPersistLSN(
     return;
   }
 
-  std::ostringstream oss;
-  oss << "Received UpdateAndPersistLSN request: " << req->ShortDebugString();
-  YB_CDC_LOG_EVERY_N_SECS_OR_VLOG(oss, 300, 1);
+  YB_LOG_EVERY_N_SECS_OR_VLOG(INFO, 300, 1)
+      << "Received UpdateAndPersistLSN request: " << req->ShortDebugString();
 
   RPC_CHECK_AND_RETURN_ERROR(
       req->has_session_id(),
@@ -5049,10 +5021,9 @@ void CDCServiceImpl::UpdateAndPersistLSN(
 
   resp->set_restart_lsn(*res);
 
-  oss.clear();
-  oss << "Succesfully persisted LSN values for stream_id: " << stream_id
+  YB_LOG_EVERY_N_SECS_OR_VLOG(INFO, 300, 1)
+      << "Successfully persisted LSN values for stream_id: " << stream_id
       << ", confirmed_flush_lsn = " << confirmed_flush_lsn << ", restart_lsn = " << *res;
-  YB_CDC_LOG_EVERY_N_SECS_OR_VLOG(oss, 300, 1);
 
   context.RespondSuccess();
 }
diff --git a/src/yb/integration-tests/CMakeLists.txt b/src/yb/integration-tests/CMakeLists.txt
index 47e9129f87..5538132900 100644
--- a/src/yb/integration-tests/CMakeLists.txt
+++ b/src/yb/integration-tests/CMakeLists.txt
@@ -181,7 +181,6 @@ ADD_YB_TEST(are_leaders_on_preferred_only-itest)
 ADD_YB_TEST(compaction-test)
 ADD_YB_TEST(clone-tablet-itest)
 ADD_YB_TEST(compressed_stream-test)
-ADD_YB_TEST(logging-test)
 ADD_YB_TEST(tablet_health_manager-itest)
 ADD_YB_TEST(master_replication-itest)
 ADD_YB_TEST(master_sysnamespace-itest)
diff --git a/src/yb/util/CMakeLists.txt b/src/yb/util/CMakeLists.txt
index cf11a1e44b..c705a1c612 100644
--- a/src/yb/util/CMakeLists.txt
+++ b/src/yb/util/CMakeLists.txt
@@ -368,6 +368,7 @@ ADD_YB_TEST(jsonreader-test)
 ADD_YB_TEST(jwt_util-test)
 ADD_YB_TEST(jwtcpp_util-test)
 ADD_YB_TEST(lockfree-test)
+ADD_YB_TEST(logging-test)
 ADD_YB_TEST(lru_cache-test)
 ADD_YB_TEST(map-util-test)
 ADD_YB_TEST(memcmpable_varint-test LABELS no_tsan)
diff --git a/src/yb/integration-tests/logging-test.cc b/src/yb/util/logging-test.cc
similarity index 64%
rename from src/yb/integration-tests/logging-test.cc
rename to src/yb/util/logging-test.cc
index 5e14ba8d94..9dd0178be0 100644
--- a/src/yb/integration-tests/logging-test.cc
+++ b/src/yb/util/logging-test.cc
@@ -47,11 +47,6 @@ DECLARE_string(vmodule);
 using std::string;
 using std::vector;
 
-// LoggingTest is not actually an integration test, but we put it here, so it will be linked with
-// all libraries used for YB cluster processes, because static object initialization in thse
-// libraries could cause logging issues.
-// For example: https://github.com/yugabyte/yugabyte-db/issues/3176
-
 namespace yb {
 
 // Test the YB_LOG_EVERY_N_SECS(...) macro.
@@ -69,8 +64,8 @@ TEST(LoggingTest, TestThrottledLogging) {
 
   // The first log line shouldn't have a suppression count.
   EXPECT_THAT(msgs[0], testing::ContainsRegex("test$"));
-  // The second one should have suppressed at least three digits worth of log messages.
-  EXPECT_THAT(msgs[1], testing::ContainsRegex("\\[suppressed [0-9]{3,} similar messages\\]"));
+  // The second one should have suppressed at least two digits worth of log messages.
+  EXPECT_THAT(msgs[1], testing::ContainsRegex("\\[suppressed [0-9]{2,} similar messages\\]"));
 
   // Just compilation check.
   YB_LOG_EVERY_N_SECS(INFO, 1) << "test" << THROTTLE_MSG;
@@ -104,4 +99,48 @@ TEST(LoggingTest, VModule) {
   EXPECT_THAT(msgs[1], testing::HasSubstr("vlog3: "));
 }
 
-} // namespace yb
+// Test the YB_LOG_EVERY_N_SECS_OR_VLOG(...) macro when vlog is off.
+TEST(LoggingTest, TestThrottledOrVlogWithoutVlog) {
+  StringVectorSink sink;
+  ScopedRegisterSink srs(&sink);
+
+  // Log 5000 messages over a period of 5 seconds.
+  for (int i = 0; i < 5000; i++) {
+    YB_LOG_EVERY_N_SECS_OR_VLOG(INFO, 1, 1) << "test" << THROTTLE_MSG;
+    SleepFor(MonoDelta::FromMilliseconds(1));
+  }
+  const vector<string>& msgs = sink.logged_msgs();
+  ASSERT_GE(msgs.size(), 2);
+  ASSERT_LT(msgs.size(), 50);
+
+  // The first log line shouldn't have a suppression count.
+  EXPECT_THAT(msgs[0], testing::ContainsRegex("] test$"));
+  // The second one should have suppressed at least two digits worth of log messages.
+  EXPECT_THAT(
+      msgs[1], testing::ContainsRegex("\\] test [suppressed [0-9]{2,} similar messages\\]$"));
+
+  // Just compilation check.
+  YB_LOG_EVERY_N_SECS_OR_VLOG(INFO, 1, 2) << "test" << THROTTLE_MSG;
+  YB_LOG_EVERY_N_SECS_OR_VLOG(INFO, 1, 3) << "test" << THROTTLE_MSG;
+}
+
+// Test the YB_LOG_EVERY_N_SECS_OR_VLOG(...) macro when vlog is on.
+TEST(LoggingTest, TestThrottledOrVlogWithVlog) {
+  google::SetVLOGLevel("logging-test", 1);
+
+  StringVectorSink sink;
+  ScopedRegisterSink srs(&sink);
+
+  // Log 2000 messages over a period of 2 seconds.
+  for (int i = 0; i < 2000; i++) {
+    YB_LOG_EVERY_N_SECS_OR_VLOG(INFO, 1, 1) << "test" << THROTTLE_MSG;
+    SleepFor(MonoDelta::FromMilliseconds(1));
+  }
+  const vector<string>& msgs = sink.logged_msgs();
+  ASSERT_EQ(msgs.size(), 2000);
+
+  // The first log line shouldn't have a suppression count.
+  EXPECT_THAT(msgs[0], testing::ContainsRegex("] vlog1: test$"));
+}
+
+}  // namespace yb
diff --git a/src/yb/util/logging.h b/src/yb/util/logging.h
index eadfc7dfd1..faf07fa97f 100644
--- a/src/yb/util/logging.h
+++ b/src/yb/util/logging.h
@@ -92,10 +92,13 @@
 
 // Logs every n secs unless VLOG is on at a level higher than verboselevel (in which case it logs
 // every time).
+// If verboselevel is -1 then VLOG is not used.
 #define YB_LOG_EVERY_N_SECS_OR_VLOG(severity, n_secs, verboselevel) \
   static yb::logging_internal::LogThrottler BOOST_PP_CAT(LOG_THROTTLER_, __LINE__); \
-  if (int num = BOOST_PP_CAT(LOG_THROTTLER_, __LINE__).ShouldLog(n_secs, verboselevel) ; num >= 0) \
-    BOOST_PP_CAT(GOOGLE_LOG_, severity)(num).stream()
+  if (int should_vlog = (verboselevel > -1 && VLOG_IS_ON(verboselevel)), cnt = 0; \
+      should_vlog || (cnt = BOOST_PP_CAT(LOG_THROTTLER_, __LINE__).ShouldLog(n_secs)) >= 0) \
+  BOOST_PP_CAT(GOOGLE_LOG_, severity)(cnt).stream() \
+      << (should_vlog ? VERBOSITY_LEVEL_STR(verboselevel) : "")
 
 // Logs a message throttled to appear at most once every 'n_secs' seconds to
 // the given severity.
@@ -278,17 +281,16 @@ class LogThrottler {
   }
 
   // Returns the number of suppressed messages if it should log, otherwise -1.
-  // Always logs if the vlog level is greater than or equal to always_log_vlog_level.
-  int ShouldLog(int n_secs, int verboselevel = -1) {
+  int ShouldLog(int n_secs) {
     MicrosecondsInt64 ts = GetMonoTimeMicros();
-    if (ts - last_ts_ >= n_secs * 1e6 ||
-        (verboselevel > -1 && VLOG_IS_ON(verboselevel))) {
+    if (ts - last_ts_ >= n_secs * 1e6) {
       last_ts_ = ts;
       return base::subtle::NoBarrier_AtomicExchange(&num_suppressed_, 0);
     }
     base::subtle::NoBarrier_AtomicIncrement(&num_suppressed_, 1);
     return -1;
   }
+
  private:
   Atomic32 num_suppressed_ = 0;
   uint64_t last_ts_ = 0;
