diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_index-test.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_index-test.cc
index a50f765b6b..78842c68ff 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_index-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_index-test.cc
@@ -31,6 +31,7 @@ DECLARE_bool(TEST_disable_apply_committed_transactions);
 DECLARE_bool(TEST_xcluster_fail_table_create_during_bootstrap);
 DECLARE_int32(TEST_user_ddl_operation_timeout_sec);
 DECLARE_bool(TEST_enable_xcluster_api_v2);
+DECLARE_bool(TEST_fail_universe_replication_merge);
 
 using std::string;
 using namespace std::chrono_literals;
@@ -301,7 +302,8 @@ TEST_F(XClusterYsqlIndexTest, CreateIndexWithWorkload) {
 
 TEST_F(XClusterYsqlIndexTest, FailedCreateIndex) {
   // Create index on consumer before producer should fail.
-  ASSERT_QUERY_FAIL(CreateIndex(*consumer_conn_), "not found");
+  ASSERT_QUERY_FAIL(
+      CreateIndex(*consumer_conn_), "Failed to bootstrap table on the source universe");
 
   ASSERT_OK(CreateIndex(*producer_conn_));
 
@@ -319,6 +321,15 @@ TEST_F(XClusterYsqlIndexTest, FailedCreateIndex) {
       CreateIndex(*consumer_conn_), "FLAGS_TEST_xcluster_fail_table_create_during_bootstrap");
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_fail_table_create_during_bootstrap) = false;
 
+  // Failure when adding table to the replication group
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_fail_universe_replication_merge) = true;
+  ASSERT_QUERY_FAIL(CreateIndex(*consumer_conn_), "TEST_fail_universe_replication_merge");
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_fail_universe_replication_merge) = false;
+
+  for (int i = 0; i < 20; row_count_++, i++) {
+    ASSERT_OK(producer_conn_->ExecuteFormat(kInsertStmtFormat, row_count_));
+  }
+
   ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
   ASSERT_OK(ValidateRows());
 
diff --git a/src/yb/master/xcluster/add_table_to_xcluster_target_task.cc b/src/yb/master/xcluster/add_table_to_xcluster_target_task.cc
index ccd6d8bb24..e7648228b0 100644
--- a/src/yb/master/xcluster/add_table_to_xcluster_target_task.cc
+++ b/src/yb/master/xcluster/add_table_to_xcluster_target_task.cc
@@ -13,6 +13,7 @@
 
 #include "yb/master/xcluster/add_table_to_xcluster_target_task.h"
 
+#include "yb/cdc/xcluster_util.h"
 #include "yb/client/xcluster_client.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/util/is_operation_done_result.h"
@@ -168,8 +169,8 @@ Status AddTableToXClusterTargetTask::AddTableToReplicationGroup(
 }
 
 Status AddTableToXClusterTargetTask::WaitForSetupUniverseReplicationToFinish() {
-  auto operation_result = VERIFY_RESULT(
-      IsSetupUniverseReplicationDone(universe_->ReplicationGroupId(), catalog_manager_));
+  auto operation_result = VERIFY_RESULT(IsSetupUniverseReplicationDone(
+      xcluster::GetAlterReplicationGroupId(universe_->ReplicationGroupId()), catalog_manager_));
 
   if (!operation_result.done()) {
     VLOG_WITH_PREFIX(2) << "Waiting for setup universe replication to finish";
diff --git a/src/yb/master/xrepl_catalog_manager.cc b/src/yb/master/xrepl_catalog_manager.cc
index 86378ccea6..fe96ce1cf2 100644
--- a/src/yb/master/xrepl_catalog_manager.cc
+++ b/src/yb/master/xrepl_catalog_manager.cc
@@ -132,6 +132,9 @@ DEFINE_RUNTIME_bool(enable_backfilling_cdc_stream_with_replication_slot, false,
     "Intended to be used for making CDC streams created before replication slot support work with"
     " the replication slot commands.");
 
+DEFINE_test_flag(bool, fail_universe_replication_merge, false, "Causes MergeUniverseReplication to "
+    "fail with an error.");
+
 DECLARE_bool(xcluster_wait_on_ddl_alter);
 DECLARE_int32(master_rpc_timeout_ms);
 DECLARE_bool(ysql_yb_enable_replication_commands);
@@ -4296,6 +4299,12 @@ void CatalogManager::MergeUniverseReplication(
   // Merge back into primary command now that setup is a success.
   LOG(INFO) << "Merging CDC universe: " << universe->id() << " into " << original_id;
 
+  if (FLAGS_TEST_fail_universe_replication_merge) {
+    MarkUniverseReplicationFailed(
+        universe, STATUS(IllegalState, "TEST_fail_universe_replication_merge"));
+    return;
+  }
+
   scoped_refptr<UniverseReplicationInfo> original_universe;
   {
     SharedLock lock(mutex_);
