diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
index c30a02f874..11f80de9a7 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
@@ -40,6 +40,7 @@
 DECLARE_uint32(ysql_oid_cache_prefetch_size);
 DECLARE_uint32(xcluster_consistent_wal_safe_time_frequency_ms);
 DECLARE_int32(xcluster_ddl_queue_max_retries_per_ddl);
+DECLARE_int32(ysql_sequence_cache_minval);
 
 DECLARE_bool(TEST_xcluster_ddl_queue_handler_fail_at_end);
 DECLARE_bool(TEST_xcluster_ddl_queue_handler_fail_at_start);
@@ -1398,6 +1399,78 @@ TEST_F(XClusterDDLReplicationSwitchoverTest, SwitchoverWithPendingDDL) {
   ASSERT_EQ(a_result, b_result);
 }
 
+TEST_F(XClusterDDLReplicationSwitchoverTest, SwitchoverWithPendingSequenceBump) {
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_ysql_sequence_cache_minval) = 1;
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_docdb_log_write_batches) = true;
+
+  const int kInitialSequenceValue = 7777700;
+
+  // Set up replication from A to B.
+  ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+
+  // Create a sequence on A, let its creation replicate then bump it
+  // 10 times but do not let the bumps replicate via pausing
+  // replication.
+  {
+    auto conn_A = ASSERT_RESULT(cluster_A_->ConnectToDB(namespace_name));
+    ASSERT_OK(
+        conn_A.ExecuteFormat("CREATE SEQUENCE my_sequence START WITH $0;", kInitialSequenceValue));
+    ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
+
+    ASSERT_OK(ToggleUniverseReplication(
+        consumer_cluster(), consumer_client(), kReplicationGroupId, /*is_enabled=*/false));
+
+    // Consume 10 sequence values, bumping last_value to kInitialSequenceValue+9 on producer.
+    for (int i = 0; i < 10; i++) {
+      ASSERT_OK(conn_A.FetchRowAsString("SELECT pg_catalog.nextval('my_sequence');"));
+    }
+  }
+
+  // Switch the replication direction unpausing the replication and
+  // letting the bumps through in the middle.
+  {
+    LOG(INFO) << "===== Beginning switchover: checkpoint B";
+    SetReplicationDirection(ReplicationDirection::BToA);
+    ASSERT_OK(CheckpointReplicationGroup(
+        kBackwardsReplicationGroupId, /*require_no_bootstrap_needed=*/false));
+
+    LOG(INFO) << "===== Switchover: set up replication from B to A";
+    SetReplicationDirection(ReplicationDirection::BToA);
+    ASSERT_OK(CreateReplicationFromCheckpoint(
+        cluster_A_->mini_cluster_->GetMasterAddresses(), kBackwardsReplicationGroupId));
+
+    LOG(INFO) << "===== Resuming replication from A to B";
+    SetReplicationDirection(ReplicationDirection::AToB);
+    ASSERT_OK(ToggleUniverseReplication(
+        consumer_cluster(), consumer_client(), kReplicationGroupId, /*is_enabled=*/true));
+
+    LOG(INFO) << "===== Continuing switchover: drop replication from A to B";
+    SetReplicationDirection(ReplicationDirection::AToB);
+    ASSERT_OK(DeleteOutboundReplicationGroup());
+
+    LOG(INFO) << "===== Finishing switchover: wait for B to no longer be in readonly mode";
+    SetReplicationDirection(ReplicationDirection::BToA);
+    ASSERT_OK(WaitForReadOnlyModeOnAllTServers(
+        ASSERT_RESULT(GetNamespaceId(producer_client())), /*is_read_only=*/false, cluster_B_));
+
+    LOG(INFO) << "===== Switchover done";
+  }
+
+  // Finally verify that the bumps were not lost.
+  ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
+  {
+    auto conn_A = ASSERT_RESULT(cluster_A_->ConnectToDB(namespace_name));
+    auto final = ASSERT_RESULT(conn_A.FetchRow<int64_t>("SELECT last_value FROM my_sequence;"));
+    EXPECT_EQ(final, kInitialSequenceValue + 9);
+  }
+  {
+    auto conn_B = ASSERT_RESULT(cluster_B_->ConnectToDB(namespace_name));
+    auto final = ASSERT_RESULT(conn_B.FetchRow<int64_t>("SELECT last_value FROM my_sequence;"));
+    EXPECT_EQ(final, kInitialSequenceValue + 9);
+  }
+}
+
 TEST_F(XClusterDDLReplicationSwitchoverTest, SwitchoverBumpsAboveUsedOids) {
   // To understand this test, it helps to picture the result of A->B replication before we do a
   // switchover.  The following is an example of the OID spaces of A and B for one database after A
diff --git a/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc b/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
index 42882ae6d5..54ee943eca 100644
--- a/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
@@ -432,6 +432,45 @@ TEST_F(XClusterAutomaticModeTest, SequenceReplicationBootstrappingWith2Databases
   ASSERT_OK(VerifySequencesSameOnBothSides(namespace2));
 }
 
+TEST_F(XClusterAutomaticModeTest, SequenceReplicationBootstrappingAddingNamespace) {
+  if (!UseYbController()) {
+    GTEST_SKIP() << "This test does not work with yb_backup.py";
+  }
+
+  const std::string namespace1{"yugabyte"};
+  const std::string namespace2{"yugabyte2"};
+  ASSERT_OK(SetUpClusters(
+      /*use_different_database_oids=*/false, namespace1, namespace2,
+      /*start_yb_controller_servers=*/true));
+
+  // Start replication with one database.
+  ASSERT_OK(SetUpSequences(&producer_cluster_, namespace1));
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces({namespace1}));
+  ASSERT_OK(BackupFromProducer({namespace1}));
+  ASSERT_OK(BumpSequences(&producer_cluster_, namespace1));
+  ASSERT_OK(RestoreToConsumer({namespace1}));
+  ASSERT_OK(CreateReplicationFromCheckpoint({}, kReplicationGroupId, {namespace1}));
+  ASSERT_OK(VerifySequencesSameOnBothSides(namespace1));
+
+  // Add a second database to the existing replication, bumping
+  // sequences in the middle of the backup/restore step.
+  ASSERT_OK(SetUpSequences(&producer_cluster_, namespace2));
+  auto source_xcluster_client = client::XClusterClient(*producer_client());
+  auto source_db_id = ASSERT_RESULT(GetNamespaceId(producer_client(), namespace2));
+  ASSERT_OK(source_xcluster_client.AddNamespaceToOutboundReplicationGroup(
+      kReplicationGroupId, source_db_id));
+  // Wait for checkpointing to finish.
+  ASSERT_RESULT(IsXClusterBootstrapRequired(kReplicationGroupId, source_db_id));
+  ASSERT_OK(BackupFromProducer({namespace2}));
+  ASSERT_OK(BumpSequences(&producer_cluster_, namespace2));
+  ASSERT_OK(RestoreToConsumer({namespace2}));
+  // Note that RestoreToConsumer re-creates the namespace so we can't get the ID before now.
+  auto target_db_id = ASSERT_RESULT(GetNamespaceId(consumer_client(), namespace2));
+  ASSERT_OK(AddNamespaceToXClusterReplication(source_db_id, target_db_id));
+
+  ASSERT_OK(VerifySequencesSameOnBothSides(namespace2));
+}
+
 TEST_F(XClusterAutomaticModeTest, SequenceReplicationEnsureWalsFails) {
   if (!UseYbController()) {
     GTEST_SKIP() << "This test does not work with yb_backup.py";
diff --git a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
index 6ebd96bc86..5dd3fa65e9 100644
--- a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
+++ b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
@@ -269,15 +269,14 @@ Status XClusterInboundReplicationGroupSetupTask::FirstStep() {
   }
 
   ScheduleNextStep(
-      std::bind(
-          &XClusterInboundReplicationGroupSetupTask::SetupDDLReplicationExtension,
-          shared_from(this)),
+      [self = shared_from(this)] { return self->SetupDDLReplicationExtension(); },
       "SetupDDLReplicationExtension");
 
   return Status::OK();
 }
 
 Status XClusterInboundReplicationGroupSetupTask::SetupDDLReplicationExtension() {
+  bool need_to_bootstrap_sequences_data = false;
   if (data_.automatic_ddl_mode) {
     for (const auto& namespace_id : data_.target_namespace_ids) {
       auto namespace_name = VERIFY_RESULT(catalog_manager_.FindNamespaceById(namespace_id))->name();
@@ -299,18 +298,21 @@ Status XClusterInboundReplicationGroupSetupTask::SetupDDLReplicationExtension()
           catalog_manager_, namespace_id, XClusterDDLReplicationRole::kTarget,
           sync.AsStdStatusCallback()));
       RETURN_NOT_OK_PREPEND(sync.Wait(), "Failed to setup xCluster DDL replication extension");
+
+      if (!is_switchover) {
+        // ALTERs to add/remove a table, and remove namespace do not reach this function.
+        need_to_bootstrap_sequences_data = true;
+      }
     }
   }
 
-  if (data_.automatic_ddl_mode && !is_alter_replication_) {
+  if (need_to_bootstrap_sequences_data) {
     ScheduleNextStep(
-        std::bind(
-            &XClusterInboundReplicationGroupSetupTask::BootstrapSequencesData, shared_from(this)),
+        [self = shared_from(this)] { return self->BootstrapSequencesData(); },
         "BootstrapSequencesData");
   } else {
     ScheduleNextStep(
-        std::bind(&XClusterInboundReplicationGroupSetupTask::CreateTableTasks, shared_from(this)),
-        "CreateTableTasks");
+        [self = shared_from(this)] { return self->CreateTableTasks(); }, "CreateTableTasks");
   }
   return Status::OK();
 }
@@ -325,8 +327,7 @@ Status XClusterInboundReplicationGroupSetupTask::BootstrapSequencesData() {
       data_.replication_group_id, data_.source_namespace_ids, deadline));
 
   ScheduleNextStep(
-      std::bind(&XClusterInboundReplicationGroupSetupTask::CreateTableTasks, shared_from(this)),
-      "CreateTableTasks");
+      [self = shared_from(this)] { return self->CreateTableTasks(); }, "CreateTableTasks");
   return Status::OK();
 }
 
@@ -378,9 +379,7 @@ void XClusterInboundReplicationGroupSetupTask::TableTaskCompletionCallback(
   }
 
   ScheduleNextStep(
-      std::bind(
-          &XClusterInboundReplicationGroupSetupTask::SetupReplicationAfterProcessingAllTables,
-          shared_from(this)),
+      [self = shared_from(this)] { return self->SetupReplicationAfterProcessingAllTables(); },
       "Process replication group after tables validated");
 }
 
