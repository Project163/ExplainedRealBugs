diff --git a/src/yb/master/CMakeLists.txt b/src/yb/master/CMakeLists.txt
index 24573b7945..b9cda11fc8 100644
--- a/src/yb/master/CMakeLists.txt
+++ b/src/yb/master/CMakeLists.txt
@@ -138,6 +138,8 @@ set(MASTER_SRCS
   xcluster/xcluster_outbound_replication_group.cc
   xcluster/xcluster_replication_group.cc
   xcluster/xcluster_safe_time_service.cc
+  xcluster/xcluster_source_manager.cc
+  xcluster/xcluster_target_manager.cc
   xrepl_catalog_manager.cc
   yql_aggregates_vtable.cc
   yql_auth_resource_role_permissions_index.cc
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index bd454f271a..8f58b98f3f 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -1037,7 +1037,7 @@ CatalogManager::CatalogManager(Master* master)
       master_, master_->metric_registry(),
       Bind(&CatalogManager::ElectedAsLeaderCb, Unretained(this))));
 
-  xcluster_manager_ = std::make_unique<XClusterManager>(master_, this, sys_catalog_.get());
+  xcluster_manager_ = std::make_unique<XClusterManager>(*master_, *this, *sys_catalog_.get());
 }
 
 CatalogManager::~CatalogManager() {
diff --git a/src/yb/master/sys_catalog.h b/src/yb/master/sys_catalog.h
index d61c8dae35..b19d8ff0ca 100644
--- a/src/yb/master/sys_catalog.h
+++ b/src/yb/master/sys_catalog.h
@@ -212,6 +212,22 @@ class SysCatalogTable {
 
   Status Visit(VisitorBase* visitor);
 
+  template <template <class> class Loader, typename CatalogEntityWrapper>
+  Status Load(const std::string& type, CatalogEntityWrapper& catalog_entity_wrapper) {
+    Loader<CatalogEntityWrapper> loader(catalog_entity_wrapper);
+    RETURN_NOT_OK_PREPEND(Visit(&loader), "Failed while visiting " + type + " in sys catalog");
+    return Status::OK();
+  }
+
+  template <typename Loader, typename CatalogEntityPB>
+  Status Load(
+      const std::string& type, std::function<Status(const std::string&, const CatalogEntityPB&)>
+                                   catalog_entity_inserter_func) {
+    Loader loader(catalog_entity_inserter_func);
+    RETURN_NOT_OK_PREPEND(Visit(&loader), "Failed while visiting " + type + " in sys catalog");
+    return Status::OK();
+  }
+
   typedef std::function<Status(const ReadHybridTime&, HybridTime*)> ReadRestartFn;
   Status ReadWithRestarts(
       const ReadRestartFn& fn,
diff --git a/src/yb/master/xcluster/master_xcluster_types.h b/src/yb/master/xcluster/master_xcluster_types.h
index 8d6c40d7d0..52d7d50e0d 100644
--- a/src/yb/master/xcluster/master_xcluster_types.h
+++ b/src/yb/master/xcluster/master_xcluster_types.h
@@ -18,6 +18,9 @@
 
 namespace yb::master {
 
+// Map[NamespaceId]:xClusterSafeTime
+typedef std::unordered_map<NamespaceId, HybridTime> XClusterNamespaceToSafeTimeMap;
+
 struct NamespaceCheckpointInfo {
   bool initial_bootstrap_required = false;
   struct TableInfo {
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index 5d641bafe2..1ff17a9e2b 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -18,256 +18,78 @@
 #include "yb/common/hybrid_time.h"
 
 #include "yb/master/catalog_entity_info.h"
+#include "yb/master/catalog_manager.h"
 #include "yb/master/master_cluster.pb.h"
-#include "yb/master/ts_descriptor.h"
-#include "yb/master/master.h"
-#include "yb/master/post_tablet_create_task_base.h"
-#include "yb/master/xcluster/add_table_to_xcluster_target_task.h"
 #include "yb/master/xcluster/xcluster_config.h"
-#include "yb/master/xcluster/xcluster_safe_time_service.h"
 
 #include "yb/rpc/rpc_context.h"
 
 #include "yb/util/logging.h"
 #include "yb/util/result.h"
 
-#include "yb/cdc/cdc_service.proxy.h"
-
-DEFINE_RUNTIME_bool(disable_auto_add_index_to_xcluster, false,
-    "Disables the automatic addition of indexes to transactional xCluster replication.");
-
 DEFINE_test_flag(bool, enable_xcluster_api_v2, false, "Allow the usage of new xCluster APIs");
 
-using namespace std::placeholders;
-
 #define LOG_FUNC_AND_RPC \
   LOG_WITH_FUNC(INFO) << req->ShortDebugString() << ", from: " << RequestorString(rpc)
 
 namespace yb::master {
 
 XClusterManager::XClusterManager(
-    Master* master, CatalogManager* catalog_manager, SysCatalogTable* sys_catalog)
-    : master_(master), catalog_manager_(catalog_manager), sys_catalog_(sys_catalog) {
-  xcluster_config_ = std::make_unique<XClusterConfig>(sys_catalog_);
+    Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog)
+    : XClusterSourceManager(master, catalog_manager, sys_catalog),
+      XClusterTargetManager(master, catalog_manager, sys_catalog),
+      master_(master),
+      catalog_manager_(catalog_manager),
+      sys_catalog_(sys_catalog) {
+  xcluster_config_ = std::make_unique<XClusterConfig>(&sys_catalog_);
 }
 
 XClusterManager::~XClusterManager() {}
 
-void XClusterManager::Shutdown() {
-  if (xcluster_safe_time_service_) {
-    xcluster_safe_time_service_->Shutdown();
-  }
-}
+void XClusterManager::Shutdown() { XClusterTargetManager::Shutdown(); }
 
 Status XClusterManager::Init() {
-  DCHECK(!xcluster_safe_time_service_);
-  xcluster_safe_time_service_ = std::make_unique<XClusterSafeTimeService>(
-      master_, catalog_manager_, master_->metric_registry());
-  RETURN_NOT_OK(xcluster_safe_time_service_->Init());
+  RETURN_NOT_OK(XClusterTargetManager::Init());
 
   return Status::OK();
 }
 
 void XClusterManager::Clear() {
   xcluster_config_->ClearState();
-  xcluster_safe_time_info_.Clear();
-  {
-    std::lock_guard l(outbound_replication_group_map_mutex_);
-    outbound_replication_group_map_.clear();
-  }
+  XClusterSourceManager::Clear();
+  XClusterTargetManager::Clear();
 }
 
 Status XClusterManager::RunLoaders() {
   Clear();
 
-  RETURN_NOT_OK(Load<XClusterConfigLoader>("xcluster configuration", *xcluster_config_));
-  RETURN_NOT_OK(Load<XClusterSafeTimeLoader>("XCluster safe time", xcluster_safe_time_info_));
+  RETURN_NOT_OK(
+      sys_catalog_.Load<XClusterConfigLoader>("xcluster configuration", *xcluster_config_));
 
-  RETURN_NOT_OK(Load<XClusterOutboundReplicationGroupLoader>(
-      "XCluster outbound replication groups",
-      std::function<Status(const std::string&, const SysXClusterOutboundReplicationGroupEntryPB&)>(
-          std::bind(&XClusterManager::InsertOutboundReplicationGroup, this, _1, _2))));
+  RETURN_NOT_OK(XClusterSourceManager::RunLoaders());
+  RETURN_NOT_OK(XClusterTargetManager::RunLoaders());
 
   return Status::OK();
 }
 
-Status XClusterManager::InsertOutboundReplicationGroup(
-    const std::string& replication_group_id,
-    const SysXClusterOutboundReplicationGroupEntryPB& metadata) {
-  xcluster::ReplicationGroupId rg_id(replication_group_id);
-  std::lock_guard l(outbound_replication_group_map_mutex_);
-
-  SCHECK(
-      !outbound_replication_group_map_.contains(rg_id), IllegalState,
-      "Duplicate xClusterOutboundReplicationGroup: $0", replication_group_id);
-
-  auto outbound_replication_group = InitOutboundReplicationGroup(rg_id, metadata);
-
-  outbound_replication_group_map_.emplace(
-      replication_group_id, std::move(outbound_replication_group));
-
-  return Status::OK();
-}
-
-XClusterOutboundReplicationGroup XClusterManager::InitOutboundReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id,
-    const SysXClusterOutboundReplicationGroupEntryPB& metadata) {
-  XClusterOutboundReplicationGroup::HelperFunctions helper_functions = {
-      .get_namespace_id_func =
-          [catalog_manager = catalog_manager_](
-              YQLDatabase db_type, const NamespaceName& namespace_name) {
-            return catalog_manager->GetNamespaceId(db_type, namespace_name);
-          },
-      .get_tables_func =
-          [this](const NamespaceId& namespace_id) { return GetTablesToReplicate(namespace_id); },
-      .bootstrap_tables_func =
-          [this](const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline)
-          -> Result<std::vector<xrepl::StreamId>> {
-        return BootstrapTables(table_infos, deadline);
-      },
-      .delete_cdc_stream_func = [catalog_manager = catalog_manager_](
-                                    const DeleteCDCStreamRequestPB& req,
-                                    const LeaderEpoch& epoch) -> Result<DeleteCDCStreamResponsePB> {
-        DeleteCDCStreamResponsePB resp;
-        RETURN_NOT_OK(catalog_manager->DeleteCDCStream(&req, &resp, nullptr));
-        return resp;
-      },
-      .upsert_to_sys_catalog_func =
-          [sys_catalog = sys_catalog_](
-              const LeaderEpoch& epoch, XClusterOutboundReplicationGroupInfo* info) {
-            return sys_catalog->Upsert(epoch.leader_term, info);
-          },
-      .delete_from_sys_catalog_func =
-          [sys_catalog = sys_catalog_](
-              const LeaderEpoch& epoch, XClusterOutboundReplicationGroupInfo* info) {
-            return sys_catalog->Delete(epoch.leader_term, info);
-          },
-  };
-
-  return XClusterOutboundReplicationGroup(
-      replication_group_id, metadata, std::move(helper_functions));
-}
-
-Result<XClusterOutboundReplicationGroup*> XClusterManager::GetOutboundReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id) {
-  return const_cast<XClusterOutboundReplicationGroup*>(VERIFY_RESULT(
-      const_cast<const XClusterManager*>(this)->GetOutboundReplicationGroup(replication_group_id)));
-}
-
-Result<const XClusterOutboundReplicationGroup*> XClusterManager::GetOutboundReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id) const {
-  auto outbound_replication_group =
-      FindOrNull(outbound_replication_group_map_, replication_group_id);
-  SCHECK(
-      outbound_replication_group, NotFound,
-      Format("xClusterOutboundReplicationGroup $0 not found", replication_group_id));
-  return outbound_replication_group;
-}
-
-template <template <class> class Loader, typename CatalogEntityWrapper>
-Status XClusterManager::Load(const std::string& key, CatalogEntityWrapper& catalog_entity_wrapper) {
-  Loader<CatalogEntityWrapper> loader(catalog_entity_wrapper);
-  LOG_WITH_FUNC(INFO) << __func__ << ": Loading " << key << " into memory.";
-  RETURN_NOT_OK_PREPEND(
-      sys_catalog_->Visit(&loader), "Failed while visiting " + key + " in sys catalog");
-  return Status::OK();
-}
-
-template <typename Loader, typename CatalogEntityPB>
-Status XClusterManager::Load(
-    const std::string& key, std::function<Status(const std::string&, const CatalogEntityPB&)>
-                                catalog_entity_inserter_func) {
-  Loader loader(catalog_entity_inserter_func);
-  LOG_WITH_FUNC(INFO) << __func__ << ": Loading " << key << " into memory.";
-  RETURN_NOT_OK_PREPEND(
-      sys_catalog_->Visit(&loader), "Failed while visiting " + key + " in sys catalog");
-  return Status::OK();
-}
-
 void XClusterManager::SysCatalogLoaded() {
-  xcluster_safe_time_service_->ScheduleTaskIfNeeded();
+  XClusterSourceManager::SysCatalogLoaded();
+  XClusterTargetManager::SysCatalogLoaded();
 }
 
 void XClusterManager::DumpState(std::ostream* out, bool on_disk_dump) const {
   if (on_disk_dump) {
-    auto l = xcluster_safe_time_info_.LockForRead();
-    if (!l->pb.safe_time_map().empty()) {
-      *out << "XCluster Safe Time: " << l->pb.ShortDebugString() << "\n";
-    }
-
     xcluster_config_->DumpState(out);
   }
+  XClusterSourceManager::DumpState(*out, on_disk_dump);
+  XClusterTargetManager::DumpState(*out, on_disk_dump);
 }
 
-Result<XClusterNamespaceToSafeTimeMap> XClusterManager::GetXClusterNamespaceToSafeTimeMap() const {
-  XClusterNamespaceToSafeTimeMap result;
-  auto l = xcluster_safe_time_info_.LockForRead();
-
-  for (auto& [namespace_id, hybrid_time] : l->pb.safe_time_map()) {
-    result[namespace_id] = HybridTime(hybrid_time);
-  }
-  return result;
-}
-
-Status XClusterManager::SetXClusterNamespaceToSafeTimeMap(
-    const int64_t leader_term, const XClusterNamespaceToSafeTimeMap& safe_time_map) {
-  auto l = xcluster_safe_time_info_.LockForWrite();
-  auto& safe_time_map_pb = *l.mutable_data()->pb.mutable_safe_time_map();
-  safe_time_map_pb.clear();
-  for (auto& [namespace_id, hybrid_time] : safe_time_map) {
-    safe_time_map_pb[namespace_id] = hybrid_time.ToUint64();
-  }
-
-  RETURN_NOT_OK_PREPEND(
-      sys_catalog_->Upsert(leader_term, &xcluster_safe_time_info_),
-      "Updating XCluster safe time in sys-catalog");
-
-  l.Commit();
-
-  return Status::OK();
-}
-
-Result<HybridTime> XClusterManager::GetXClusterSafeTime(const NamespaceId& namespace_id) const {
-  auto l = xcluster_safe_time_info_.LockForRead();
-  SCHECK(
-      l->pb.safe_time_map().count(namespace_id), NotFound,
-      "XCluster safe time not found for namespace $0", namespace_id);
-
-  return HybridTime(l->pb.safe_time_map().at(namespace_id));
-}
-
-void XClusterManager::CreateXClusterSafeTimeTableAndStartService() {
-  WARN_NOT_OK(
-      xcluster_safe_time_service_->CreateXClusterSafeTimeTableIfNotFound(),
-      "Creation of XClusterSafeTime table failed");
-
-  xcluster_safe_time_service_->ScheduleTaskIfNeeded();
-}
-
-Status XClusterManager::GetXClusterSafeTime(
-    const GetXClusterSafeTimeRequestPB* req, GetXClusterSafeTimeResponsePB* resp,
-    rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
-  RETURN_NOT_OK_SET_CODE(
-      xcluster_safe_time_service_->GetXClusterSafeTimeInfoFromMap(epoch, resp),
-      MasterError(MasterErrorPB::INTERNAL_ERROR));
-
-  // Also fill out the namespace_name for each entry.
-  if (resp->namespace_safe_times_size()) {
-    for (auto& safe_time_info : *resp->mutable_namespace_safe_times()) {
-      const auto namespace_info = VERIFY_RESULT_OR_SET_CODE(
-          catalog_manager_->FindNamespaceById(safe_time_info.namespace_id()),
-          MasterError(MasterErrorPB::INTERNAL_ERROR));
-
-      safe_time_info.set_namespace_name(namespace_info->name());
-    }
-  }
-
-  return Status::OK();
-}
+Status XClusterManager::FillHeartbeatResponse(
+    const TSHeartbeatRequestPB& req, TSHeartbeatResponsePB* resp) const {
+  RETURN_NOT_OK(XClusterTargetManager::FillHeartbeatResponse(req, resp));
 
-Result<XClusterNamespaceToSafeTimeMap> XClusterManager::RefreshAndGetXClusterNamespaceToSafeTimeMap(
-    const LeaderEpoch& epoch) {
-  return xcluster_safe_time_service_->RefreshAndGetXClusterNamespaceToSafeTimeMap(epoch);
+  return xcluster_config_->FillHeartbeatResponse(req, resp);
 }
 
 Status XClusterManager::PrepareDefaultXClusterConfig(int64_t term, bool recreate) {
@@ -287,18 +109,6 @@ Result<uint32_t> XClusterManager::GetXClusterConfigVersion() const {
   return xcluster_config_->GetVersion();
 }
 
-Status XClusterManager::FillHeartbeatResponse(
-    const TSHeartbeatRequestPB& req, TSHeartbeatResponsePB* resp) const {
-  {
-    auto l = xcluster_safe_time_info_.LockForRead();
-    if (!l->pb.safe_time_map().empty()) {
-      *resp->mutable_xcluster_namespace_to_safe_time() = l->pb.safe_time_map();
-    }
-  }
-
-  return xcluster_config_->FillHeartbeatResponse(req, resp);
-}
-
 Status XClusterManager::RemoveStreamFromXClusterProducerConfig(
     const LeaderEpoch& epoch, const std::vector<CDCStreamInfo*>& streams) {
   return xcluster_config_->RemoveStreams(epoch, streams);
@@ -316,7 +126,7 @@ Status XClusterManager::PauseResumeXClusterProducerStreams(
     LOG(INFO) << action << " replication for all XCluster streams.";
   }
 
-  auto xrepl_stream_ids = catalog_manager_->GetAllXreplStreamIds();
+  auto xrepl_stream_ids = catalog_manager_.GetAllXreplStreamIds();
   std::vector<xrepl::StreamId> streams_to_change;
 
   if (req->stream_ids().empty()) {
@@ -336,6 +146,31 @@ Status XClusterManager::PauseResumeXClusterProducerStreams(
   return xcluster_config_->PauseResumeXClusterProducerStreams(epoch, streams_to_change, paused);
 }
 
+Result<XClusterNamespaceToSafeTimeMap> XClusterManager::GetXClusterNamespaceToSafeTimeMap() const {
+  return XClusterTargetManager::GetXClusterNamespaceToSafeTimeMap();
+}
+
+Status XClusterManager::SetXClusterNamespaceToSafeTimeMap(
+    const int64_t leader_term, const XClusterNamespaceToSafeTimeMap& safe_time_map) {
+  return XClusterTargetManager::SetXClusterNamespaceToSafeTimeMap(leader_term, safe_time_map);
+}
+
+Status XClusterManager::GetXClusterSafeTime(
+    const GetXClusterSafeTimeRequestPB* req, GetXClusterSafeTimeResponsePB* resp,
+    rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
+  LOG_FUNC_AND_RPC;
+  return XClusterTargetManager::GetXClusterSafeTime(resp, epoch);
+}
+
+Result<HybridTime> XClusterManager::GetXClusterSafeTime(const NamespaceId& namespace_id) const {
+  return XClusterTargetManager::GetXClusterSafeTime(namespace_id);
+}
+
+Result<XClusterNamespaceToSafeTimeMap> XClusterManager::RefreshAndGetXClusterNamespaceToSafeTimeMap(
+    const LeaderEpoch& epoch) {
+  return XClusterTargetManager::RefreshAndGetXClusterNamespaceToSafeTimeMap(epoch);
+}
+
 Status XClusterManager::XClusterCreateOutboundReplicationGroup(
     const XClusterCreateOutboundReplicationGroupRequestPB* req,
     XClusterCreateOutboundReplicationGroupResponsePB* resp, rpc::RpcContext* rpc,
@@ -349,28 +184,14 @@ Status XClusterManager::XClusterCreateOutboundReplicationGroup(
       "Replication group id cannot be empty");
   SCHECK(req->namespace_names_size() > 0, InvalidArgument, "Namespace names must be specified");
 
-  auto replication_group_id = xcluster::ReplicationGroupId(req->replication_group_id());
-
-  std::lock_guard l(outbound_replication_group_map_mutex_);
-  SCHECK(
-      !outbound_replication_group_map_.contains(replication_group_id), IllegalState,
-      "xClusterOutboundReplicationGroup $0 already exists", replication_group_id);
-
   std::vector<NamespaceName> namespace_names;
   for (const auto& namespace_name : req->namespace_names()) {
     namespace_names.emplace_back(namespace_name);
   }
 
-  SysXClusterOutboundReplicationGroupEntryPB metadata;  // Empty metadata.
-  auto outbound_replication_group = InitOutboundReplicationGroup(replication_group_id, metadata);
-
-  // This will persist the group to SysCatalog.
-  auto namespace_ids = VERIFY_RESULT(
-      outbound_replication_group.AddNamespaces(epoch, namespace_names, rpc->GetClientDeadline()));
-
-  outbound_replication_group_map_.emplace(
-      replication_group_id, std::move(outbound_replication_group));
-
+  auto namespace_ids = VERIFY_RESULT(CreateOutboundReplicationGroup(
+      xcluster::ReplicationGroupId(req->replication_group_id()), namespace_names, epoch,
+      rpc->GetClientDeadline()));
   for (const auto& namespace_id : namespace_ids) {
     *resp->add_namespace_ids() = namespace_id;
   }
@@ -385,13 +206,9 @@ Status XClusterManager::XClusterAddNamespaceToOutboundReplicationGroup(
   LOG_FUNC_AND_RPC;
   SCHECK(req->has_namespace_name(), InvalidArgument, "Namespace name must be specified");
 
-  auto replication_group_id = xcluster::ReplicationGroupId(req->replication_group_id());
-  std::lock_guard l(outbound_replication_group_map_mutex_);
-  auto outbound_replication_group =
-      VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
-
-  auto namespace_id = VERIFY_RESULT(outbound_replication_group->AddNamespace(
-      epoch, req->namespace_name(), rpc->GetClientDeadline()));
+  auto namespace_id = VERIFY_RESULT(AddNamespaceToOutboundReplicationGroup(
+      xcluster::ReplicationGroupId(req->replication_group_id()), req->namespace_name(), epoch,
+      rpc->GetClientDeadline()));
 
   resp->set_namespace_id(namespace_id);
   return Status::OK();
@@ -404,13 +221,8 @@ Status XClusterManager::XClusterRemoveNamespaceFromOutboundReplicationGroup(
   LOG_FUNC_AND_RPC;
   SCHECK(req->has_namespace_id(), InvalidArgument, "Namespace id must be specified");
 
-  auto replication_group_id = xcluster::ReplicationGroupId(req->replication_group_id());
-
-  std::lock_guard l(outbound_replication_group_map_mutex_);
-  auto outbound_replication_group =
-      VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
-
-  return outbound_replication_group->RemoveNamespace(epoch, req->namespace_id());
+  return RemoveNamespaceFromOutboundReplicationGroup(
+      xcluster::ReplicationGroupId(req->replication_group_id()), req->namespace_id(), epoch);
 }
 
 Status XClusterManager::XClusterDeleteOutboundReplicationGroup(
@@ -419,18 +231,8 @@ Status XClusterManager::XClusterDeleteOutboundReplicationGroup(
     const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
 
-  auto replication_group_id = xcluster::ReplicationGroupId(req->replication_group_id());
-
-  std::lock_guard l(outbound_replication_group_map_mutex_);
-  auto outbound_replication_group =
-      VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
-
-  // This will remove the group from SysCatalog.
-  RETURN_NOT_OK(outbound_replication_group->Delete(epoch));
-
-  outbound_replication_group_map_.erase(replication_group_id);
-
-  return Status::OK();
+  return DeleteOutboundReplicationGroup(
+      xcluster::ReplicationGroupId(req->replication_group_id()), epoch);
 }
 
 Status XClusterManager::IsXClusterBootstrapRequired(
@@ -438,14 +240,8 @@ Status XClusterManager::IsXClusterBootstrapRequired(
     rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
   SCHECK(req->has_namespace_id(), InvalidArgument, "Namespace id must be specified");
 
-  auto replication_group_id = xcluster::ReplicationGroupId(req->replication_group_id());
-
-  SharedLock l(outbound_replication_group_map_mutex_);
-  auto outbound_replication_group = VERIFY_RESULT(
-      const_cast<const XClusterManager*>(this)->GetOutboundReplicationGroup(replication_group_id));
-
-  auto bootstrap_required =
-      VERIFY_RESULT(outbound_replication_group->IsBootstrapRequired(req->namespace_id()));
+  auto bootstrap_required = VERIFY_RESULT(IsBootstrapRequired(
+      xcluster::ReplicationGroupId(req->replication_group_id()), req->namespace_id()));
 
   if (!bootstrap_required.has_value()) {
     resp->set_not_ready(true);
@@ -461,19 +257,14 @@ Status XClusterManager::GetXClusterStreams(
     const GetXClusterStreamsRequestPB* req, GetXClusterStreamsResponsePB* resp,
     rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
   SCHECK(req->has_namespace_id(), InvalidArgument, "Namespace id must be specified");
-  auto replication_group_id = xcluster::ReplicationGroupId(req->replication_group_id());
-
-  SharedLock l(outbound_replication_group_map_mutex_);
-  auto outbound_replication_group = VERIFY_RESULT(
-      const_cast<const XClusterManager*>(this)->GetOutboundReplicationGroup(replication_group_id));
 
   std::vector<std::pair<TableName, PgSchemaName>> table_names;
   for (const auto& table_name : req->table_infos()) {
     table_names.emplace_back(table_name.table_name(), table_name.pg_schema_name());
   }
 
-  auto ns_info = VERIFY_RESULT(
-      outbound_replication_group->GetNamespaceCheckpointInfo(req->namespace_id(), table_names));
+  auto ns_info = VERIFY_RESULT(XClusterSourceManager::GetXClusterStreams(
+      xcluster::ReplicationGroupId(req->replication_group_id()), req->namespace_id(), table_names));
 
   if (!ns_info.has_value()) {
     resp->set_not_ready(true);
@@ -492,172 +283,18 @@ Status XClusterManager::GetXClusterStreams(
   return Status::OK();
 }
 
-namespace {
-// Should the table be part of xCluster replication?
-bool ShouldReplicateTable(const TableInfoPtr& table) {
-  if (table->GetTableType() != PGSQL_TABLE_TYPE || table->is_system()) {
-    // Limited to ysql databases.
-    // System tables are not replicated. DDLs statements will be replicated and executed on the
-    // target universe to handle catalog changes.
-    return false;
-  }
-
-  if (table->is_matview()) {
-    // Materialized views need not be replicated, since they are not modified. Every time the view
-    // is refreshed, new tablets are created. The same refresh can just run on the target universe.
-    return false;
-  }
-
-  if (table->IsColocatedUserTable()) {
-    // Only the colocated parent table needs to be replicated.
-    return false;
-  }
-
-  return true;
-}
-
-}  // namespace
-
-Result<std::vector<TableInfoPtr>> XClusterManager::GetTablesToReplicate(
-    const NamespaceId& namespace_id) {
-  auto table_infos = VERIFY_RESULT(catalog_manager_->GetTableInfosForNamespace(namespace_id));
-  EraseIf([](const TableInfoPtr& table) { return !ShouldReplicateTable(table); }, &table_infos);
-  return table_infos;
-}
-
-Result<std::vector<xrepl::StreamId>> XClusterManager::BootstrapTables(
-    const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline) {
-  cdc::BootstrapProducerRequestPB bootstrap_req;
-  master::TSDescriptor* ts = nullptr;
-  for (const auto& table_info : table_infos) {
-    bootstrap_req.add_table_ids(table_info->id());
-
-    if (!ts) {
-      ts = VERIFY_RESULT(table_info->GetTablets().front()->GetLeader());
-    }
-  }
-  SCHECK(ts, IllegalState, "No valid tserver found to bootstrap from");
-
-  std::shared_ptr<cdc::CDCServiceProxy> proxy;
-  RETURN_NOT_OK(ts->GetProxy(&proxy));
-
-  cdc::BootstrapProducerResponsePB bootstrap_resp;
-  rpc::RpcController bootstrap_rpc;
-  bootstrap_rpc.set_deadline(deadline);
-
-  // TODO(Hari): DB-9416 Make this async and atomic with upsert of the outbound replication group.
-  RETURN_NOT_OK(proxy->BootstrapProducer(bootstrap_req, &bootstrap_resp, &bootstrap_rpc));
-  if (bootstrap_resp.has_error()) {
-    RETURN_NOT_OK(StatusFromPB(bootstrap_resp.error().status()));
-  }
-
-  SCHECK_EQ(
-      table_infos.size(), bootstrap_resp.cdc_bootstrap_ids_size(), IllegalState,
-      "Number of tables to bootstrap and number of bootstrap ids do not match");
-
-  std::vector<xrepl::StreamId> stream_ids;
-  for (const auto& bootstrap_id : bootstrap_resp.cdc_bootstrap_ids()) {
-    stream_ids.emplace_back(VERIFY_RESULT(xrepl::StreamId::FromString(bootstrap_id)));
-  }
-  return stream_ids;
-}
-
-bool XClusterManager::ShouldAddTableToXClusterTarget(const TableInfo& table) const {
-  if (FLAGS_disable_auto_add_index_to_xcluster) {
-    return false;
-  }
-
-  const auto& pb = table.metadata().dirty().pb;
-
-  // Only user created YSQL Indexes should be automatically added to xCluster replication.
-  // For Colocated tables, this function will return false since it is only called on the parent
-  // colocated table, which cannot be an index.
-  if (pb.colocated() || pb.table_type() != PGSQL_TABLE_TYPE || !IsIndex(pb) ||
-      !catalog_manager_->IsUserCreatedTable(table)) {
-    return false;
-  }
-
-  auto indexed_table_stream_ids =
-      catalog_manager_->GetXClusterConsumerStreamIdsForTable(table.id());
-  if (!indexed_table_stream_ids.empty()) {
-    VLOG(1) << "Index " << table.ToString() << " is already part of xcluster replication "
-            << yb::ToString(indexed_table_stream_ids);
-    return false;
-  }
-
-  auto indexed_table = catalog_manager_->GetTableInfo(GetIndexedTableId(pb));
-  if (!indexed_table) {
-    LOG(WARNING) << "Indexed table for " << table.id() << " not found";
-    return false;
-  }
-
-  auto stream_ids = catalog_manager_->GetXClusterConsumerStreamIdsForTable(indexed_table->id());
-  if (stream_ids.empty()) {
-    return false;
-  }
-
-  if (stream_ids.size() > 1) {
-    LOG(WARNING) << "Skipping adding index " << table.ToString()
-                 << " to xCluster replication as the base table" << indexed_table->ToString()
-                 << " is part of multiple replication streams " << yb::ToString(stream_ids);
-    return false;
-  }
-
-  const auto& replication_group_id = stream_ids.begin()->first;
-  auto cluster_config = catalog_manager_->ClusterConfig();
+std::vector<std::shared_ptr<PostTabletCreateTaskBase>> XClusterManager::GetPostTabletCreateTasks(
+    const TableInfoPtr& table_info, const LeaderEpoch& epoch) {
+  std::vector<std::shared_ptr<PostTabletCreateTaskBase>> result;
   {
-    auto l = cluster_config->LockForRead();
-    const auto& consumer_registry = l.data().pb.consumer_registry();
-    // Only add if we are in a transactional replication with STANDBY mode.
-    if (consumer_registry.role() != cdc::XClusterRole::STANDBY ||
-        !consumer_registry.transactional()) {
-      return false;
-    }
-
-    auto producer_entry =
-        FindOrNull(consumer_registry.producer_map(), replication_group_id.ToString());
-    if (producer_entry) {
-      // Check if the table is already part of replication.
-      // This is needed despite the check for GetXClusterConsumerStreamIdsForTable as the in-memory
-      // list is not atomically updated.
-      for (auto& stream_info : producer_entry->stream_map()) {
-        if (stream_info.second.consumer_table_id() == table.id()) {
-          VLOG(1) << "Index " << table.ToString() << " is already part of xcluster replication "
-                  << stream_info.first;
-          return false;
-        }
-      }
-    }
+    auto tasks = XClusterSourceManager::GetPostTabletCreateTasks(table_info, epoch);
+    MoveCollection(&tasks, &result);
   }
-
-  scoped_refptr<UniverseReplicationInfo> universe;
   {
-    auto universe = catalog_manager_->GetUniverseReplication(replication_group_id);
-    if (universe == nullptr) {
-      LOG(WARNING) << "Skip adding index " << table.ToString()
-                   << " to xCluster replication as the universe " << replication_group_id
-                   << " was not found";
-      return false;
-    }
-
-    if (universe->LockForRead()->is_deleted_or_failed()) {
-      LOG(WARNING) << "Skip adding index " << table.ToString()
-                   << " to xCluster replication as the universe " << replication_group_id
-                   << " is in a deleted or failed state";
-      return false;
-    }
-  }
-
-  return true;
-}
-
-std::vector<std::shared_ptr<PostTabletCreateTaskBase>> XClusterManager::GetPostTabletCreateTasks(
-    const TableInfoPtr& table_info, const LeaderEpoch& epoch) {
-  if (!ShouldAddTableToXClusterTarget(*table_info)) {
-    return {};
+    auto tasks = XClusterTargetManager::GetPostTabletCreateTasks(table_info, epoch);
+    MoveCollection(&tasks, &result);
   }
 
-  return {std::make_shared<AddTableToXClusterTargetTask>(
-      *catalog_manager_, *master_->messenger(), table_info, epoch)};
+  return result;
 }
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_manager.h b/src/yb/master/xcluster/xcluster_manager.h
index e76dbf4aee..95f8124dcd 100644
--- a/src/yb/master/xcluster/xcluster_manager.h
+++ b/src/yb/master/xcluster/xcluster_manager.h
@@ -23,6 +23,8 @@
 #include "yb/master/xcluster/xcluster_catalog_entity.h"
 #include "yb/master/xcluster/xcluster_manager_if.h"
 #include "yb/master/xcluster/xcluster_outbound_replication_group.h"
+#include "yb/master/xcluster/xcluster_source_manager.h"
+#include "yb/master/xcluster/xcluster_target_manager.h"
 
 namespace yb {
 
@@ -41,10 +43,12 @@ struct SysCatalogLoadingState;
 // The XClusterManager class is responsible for managing all yb-master related control logic of
 // XCluster. All XCluster related RPCs and APIs are handled by this class.
 // TODO(#19714): Move XCluster related code from CatalogManager to this class.
-class XClusterManager : public XClusterManagerIf {
+class XClusterManager : public XClusterManagerIf,
+                        public XClusterSourceManager,
+                        public XClusterTargetManager {
  public:
   explicit XClusterManager(
-      Master* master, CatalogManager* catalog_manager, SysCatalogTable* sys_catalog);
+      Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog);
 
   ~XClusterManager();
 
@@ -60,15 +64,13 @@ class XClusterManager : public XClusterManagerIf {
 
   void DumpState(std::ostream* out, bool on_disk_dump = false) const;
 
-  Status GetXClusterConfigEntryPB(SysXClusterConfigEntryPB* config) const EXCLUDES(mutex_) override;
+  Status GetXClusterConfigEntryPB(SysXClusterConfigEntryPB* config) const  override;
 
-  Status GetMasterXClusterConfig(GetMasterXClusterConfigResponsePB* resp) EXCLUDES(mutex_);
+  Status GetMasterXClusterConfig(GetMasterXClusterConfigResponsePB* resp);
 
   Result<uint32_t> GetXClusterConfigVersion() const;
 
-  void CreateXClusterSafeTimeTableAndStartService();
-
-  Status PrepareDefaultXClusterConfig(int64_t term, bool recreate) EXCLUDES(mutex_);
+  Status PrepareDefaultXClusterConfig(int64_t term, bool recreate);
 
   Status FillHeartbeatResponse(const TSHeartbeatRequestPB& req, TSHeartbeatResponsePB* resp) const;
 
@@ -89,17 +91,9 @@ class XClusterManager : public XClusterManagerIf {
       const GetXClusterSafeTimeRequestPB* req, GetXClusterSafeTimeResponsePB* resp,
       rpc::RpcContext* rpc, const LeaderEpoch& epoch);
   Result<HybridTime> GetXClusterSafeTime(const NamespaceId& namespace_id) const override;
-
   Result<XClusterNamespaceToSafeTimeMap> RefreshAndGetXClusterNamespaceToSafeTimeMap(
       const LeaderEpoch& epoch) override;
 
-  std::vector<std::shared_ptr<PostTabletCreateTaskBase>> GetPostTabletCreateTasks(
-      const TableInfoPtr& table_info, const LeaderEpoch& epoch);
-
-  XClusterSafeTimeService* TEST_xcluster_safe_time_service() {
-    return xcluster_safe_time_service_.get();
-  }
-
   // OutboundReplicationGroup RPCs.
   Status XClusterCreateOutboundReplicationGroup(
       const XClusterCreateOutboundReplicationGroupRequestPB* req,
@@ -124,56 +118,15 @@ class XClusterManager : public XClusterManagerIf {
       const GetXClusterStreamsRequestPB* req, GetXClusterStreamsResponsePB* resp,
       rpc::RpcContext* rpc, const LeaderEpoch& epoch);
 
- private:
-  template <template <class> class Loader, typename CatalogEntityWrapper>
-  Status Load(const std::string& key, CatalogEntityWrapper& catalog_entity_wrapper);
-
-  template <typename Loader, typename CatalogEntityPB>
-  Status Load(
-      const std::string& key, std::function<Status(const std::string&, const CatalogEntityPB&)>
-                                  catalog_entity_inserter_func);
-
-  Status InsertOutboundReplicationGroup(
-      const std::string& replication_group_id,
-      const SysXClusterOutboundReplicationGroupEntryPB& metadata)
-      EXCLUDES(outbound_replication_group_map_mutex_);
-
-  XClusterOutboundReplicationGroup InitOutboundReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id,
-      const SysXClusterOutboundReplicationGroupEntryPB& metadata);
-
-  Result<XClusterOutboundReplicationGroup*> GetOutboundReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id)
-      REQUIRES(outbound_replication_group_map_mutex_);
-
-  Result<const XClusterOutboundReplicationGroup*> GetOutboundReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id) const
-      REQUIRES_SHARED(outbound_replication_group_map_mutex_);
-
-  Result<std::vector<TableInfoPtr>> GetTablesToReplicate(const NamespaceId& namespace_id);
-
-  Result<std::vector<xrepl::StreamId>> BootstrapTables(
-      const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline);
-
-  bool ShouldAddTableToXClusterTarget(const TableInfo& table_info) const;
-
-  Master* const master_;
-  CatalogManager* const catalog_manager_;
-  SysCatalogTable* const sys_catalog_;
+  std::vector<std::shared_ptr<PostTabletCreateTaskBase>> GetPostTabletCreateTasks(
+      const TableInfoPtr& table_info, const LeaderEpoch& epoch);
 
-  mutable std::shared_mutex mutex_;
+ private:
+  Master& master_;
+  CatalogManager& catalog_manager_;
+  SysCatalogTable& sys_catalog_;
 
   std::unique_ptr<XClusterConfig> xcluster_config_;
-
-  std::unique_ptr<XClusterSafeTimeService> xcluster_safe_time_service_;
-
-  // The Catalog Entity is stored outside of XClusterSafeTimeService, since we may want to move the
-  // service out of master at a later time.
-  XClusterSafeTimeInfo xcluster_safe_time_info_;
-
-  mutable std::shared_mutex outbound_replication_group_map_mutex_;
-  std::map<xcluster::ReplicationGroupId, XClusterOutboundReplicationGroup>
-      outbound_replication_group_map_ GUARDED_BY(outbound_replication_group_map_mutex_);
 };
 
 }  // namespace master
diff --git a/src/yb/master/xcluster/xcluster_manager_if.h b/src/yb/master/xcluster/xcluster_manager_if.h
index 9ccaf8b88a..27683e19bc 100644
--- a/src/yb/master/xcluster/xcluster_manager_if.h
+++ b/src/yb/master/xcluster/xcluster_manager_if.h
@@ -16,6 +16,8 @@
 #include <memory>
 
 #include "yb/master/master_fwd.h"
+#include "yb/master/xcluster/master_xcluster_types.h"
+
 #include "yb/util/status_fwd.h"
 
 namespace yb {
@@ -33,9 +35,6 @@ class GetXClusterSafeTimeResponsePB;
 class SysXClusterConfigEntryPB;
 struct LeaderEpoch;
 
-// Map[NamespaceId]:xClusterSafeTime
-typedef std::unordered_map<NamespaceId, HybridTime> XClusterNamespaceToSafeTimeMap;
-
 class XClusterManagerIf {
  public:
   virtual Result<HybridTime> GetXClusterSafeTime(const NamespaceId& namespace_id) const = 0;
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
index 892242e321..ba7848750a 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
@@ -38,6 +38,11 @@ XClusterOutboundReplicationGroup::XClusterOutboundReplicationGroup(
   outbound_rg_info_->Load(outbound_replication_group_pb);
 }
 
+SysXClusterOutboundReplicationGroupEntryPB XClusterOutboundReplicationGroup::GetMetadata() const {
+  auto l = outbound_rg_info_->LockForRead();
+  return l->pb;
+}
+
 Status XClusterOutboundReplicationGroup::Upsert(
     XClusterOutboundReplicationGroupInfo::WriteLock& l, const LeaderEpoch& epoch) {
   auto status = helper_functions_.upsert_to_sys_catalog_func(epoch, outbound_rg_info_.get());
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.h b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
index 55fe102cad..a2930896df 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.h
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
@@ -49,6 +49,8 @@ class XClusterOutboundReplicationGroup {
   std::string ToString() const { return Format("xClusterOutboundReplicationGroup $0", Id()); }
   std::string LogPrefix() const { return ToString(); }
 
+  SysXClusterOutboundReplicationGroupEntryPB GetMetadata() const;
+
   Result<std::vector<NamespaceId>> AddNamespaces(
       const LeaderEpoch& epoch, const std::vector<NamespaceName>& namespace_names,
       CoarseTimePoint deadline);
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
new file mode 100644
index 0000000000..55fe518333
--- /dev/null
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -0,0 +1,292 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/master/xcluster/xcluster_source_manager.h"
+
+#include "yb/cdc/cdc_service.proxy.h"
+#include "yb/master/catalog_manager.h"
+#include "yb/master/xcluster/xcluster_catalog_entity.h"
+
+#include "yb/rpc/rpc_context.h"
+
+using namespace std::placeholders;
+
+namespace yb::master {
+
+namespace {
+// Should the table be part of xCluster replication?
+bool ShouldReplicateTable(const TableInfoPtr& table) {
+  if (table->GetTableType() != PGSQL_TABLE_TYPE || table->is_system()) {
+    // Limited to ysql databases.
+    // System tables are not replicated. DDLs statements will be replicated and executed on the
+    // target universe to handle catalog changes.
+    return false;
+  }
+
+  if (table->is_matview()) {
+    // Materialized views need not be replicated, since they are not modified. Every time the view
+    // is refreshed, new tablets are created. The same refresh can just run on the target universe.
+    return false;
+  }
+
+  if (table->IsColocatedUserTable()) {
+    // Only the colocated parent table needs to be replicated.
+    return false;
+  }
+
+  return true;
+}
+
+}  // namespace
+
+XClusterSourceManager::XClusterSourceManager(
+    Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog)
+    : master_(master), catalog_manager_(catalog_manager), sys_catalog_(sys_catalog) {}
+
+XClusterSourceManager::~XClusterSourceManager() {}
+
+void XClusterSourceManager::Clear() {
+  std::lock_guard l(outbound_replication_group_map_mutex_);
+  outbound_replication_group_map_.clear();
+}
+
+Status XClusterSourceManager::RunLoaders() {
+  RETURN_NOT_OK(sys_catalog_.Load<XClusterOutboundReplicationGroupLoader>(
+      "XCluster outbound replication groups",
+      std::function<Status(const std::string&, const SysXClusterOutboundReplicationGroupEntryPB&)>(
+          std::bind(&XClusterSourceManager::InsertOutboundReplicationGroup, this, _1, _2))));
+
+  return Status::OK();
+}
+
+void XClusterSourceManager::SysCatalogLoaded() {}
+
+void XClusterSourceManager::DumpState(std::ostream& out, bool on_disk_dump) const {
+  if (!on_disk_dump) {
+    return;
+  }
+
+  std::lock_guard l(outbound_replication_group_map_mutex_);
+  if (outbound_replication_group_map_.empty()) {
+    return;
+  }
+  out << "XClusterOutboundReplicationGroups:\n";
+
+  for (const auto& [replication_group_id, outbound_rg] : outbound_replication_group_map_) {
+    out << "  ReplicationGroupId: " << replication_group_id
+        << "\n  metadata: " << outbound_rg.GetMetadata().ShortDebugString() << "\n";
+  }
+}
+
+Status XClusterSourceManager::InsertOutboundReplicationGroup(
+    const std::string& replication_group_id,
+    const SysXClusterOutboundReplicationGroupEntryPB& metadata) {
+  xcluster::ReplicationGroupId rg_id(replication_group_id);
+  std::lock_guard l(outbound_replication_group_map_mutex_);
+
+  SCHECK(
+      !outbound_replication_group_map_.contains(rg_id), IllegalState,
+      "Duplicate xClusterOutboundReplicationGroup: $0", replication_group_id);
+
+  auto outbound_replication_group = InitOutboundReplicationGroup(rg_id, metadata);
+
+  outbound_replication_group_map_.emplace(
+      replication_group_id, std::move(outbound_replication_group));
+
+  return Status::OK();
+}
+
+XClusterOutboundReplicationGroup XClusterSourceManager::InitOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const SysXClusterOutboundReplicationGroupEntryPB& metadata) {
+  XClusterOutboundReplicationGroup::HelperFunctions helper_functions = {
+      .get_namespace_id_func =
+          [&catalog_manager = catalog_manager_](
+              YQLDatabase db_type, const NamespaceName& namespace_name) {
+            return catalog_manager.GetNamespaceId(db_type, namespace_name);
+          },
+      .get_tables_func =
+          [this](const NamespaceId& namespace_id) { return GetTablesToReplicate(namespace_id); },
+      .bootstrap_tables_func =
+          [this](const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline)
+          -> Result<std::vector<xrepl::StreamId>> {
+        return BootstrapTables(table_infos, deadline);
+      },
+      .delete_cdc_stream_func = [&catalog_manager = catalog_manager_](
+                                    const DeleteCDCStreamRequestPB& req,
+                                    const LeaderEpoch& epoch) -> Result<DeleteCDCStreamResponsePB> {
+        DeleteCDCStreamResponsePB resp;
+        RETURN_NOT_OK(catalog_manager.DeleteCDCStream(&req, &resp, nullptr));
+        return resp;
+      },
+      .upsert_to_sys_catalog_func =
+          [&sys_catalog = sys_catalog_](
+              const LeaderEpoch& epoch, XClusterOutboundReplicationGroupInfo* info) {
+            return sys_catalog.Upsert(epoch.leader_term, info);
+          },
+      .delete_from_sys_catalog_func =
+          [&sys_catalog = sys_catalog_](
+              const LeaderEpoch& epoch, XClusterOutboundReplicationGroupInfo* info) {
+            return sys_catalog.Delete(epoch.leader_term, info);
+          },
+  };
+
+  return XClusterOutboundReplicationGroup(
+      replication_group_id, metadata, std::move(helper_functions));
+}
+
+Result<XClusterOutboundReplicationGroup*> XClusterSourceManager::GetOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id) {
+  return const_cast<XClusterOutboundReplicationGroup*>(
+      VERIFY_RESULT(const_cast<const XClusterSourceManager*>(this)->GetOutboundReplicationGroup(
+          replication_group_id)));
+}
+
+Result<const XClusterOutboundReplicationGroup*> XClusterSourceManager::GetOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id) const {
+  auto outbound_replication_group =
+      FindOrNull(outbound_replication_group_map_, replication_group_id);
+  SCHECK(
+      outbound_replication_group, NotFound,
+      Format("xClusterOutboundReplicationGroup $0 not found", replication_group_id));
+  return outbound_replication_group;
+}
+
+Result<std::vector<TableInfoPtr>> XClusterSourceManager::GetTablesToReplicate(
+    const NamespaceId& namespace_id) {
+  auto table_infos = VERIFY_RESULT(catalog_manager_.GetTableInfosForNamespace(namespace_id));
+  EraseIf([](const TableInfoPtr& table) { return !ShouldReplicateTable(table); }, &table_infos);
+  return table_infos;
+}
+
+Result<std::vector<xrepl::StreamId>> XClusterSourceManager::BootstrapTables(
+    const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline) {
+  cdc::BootstrapProducerRequestPB bootstrap_req;
+  master::TSDescriptor* ts = nullptr;
+  for (const auto& table_info : table_infos) {
+    bootstrap_req.add_table_ids(table_info->id());
+
+    if (!ts) {
+      ts = VERIFY_RESULT(table_info->GetTablets().front()->GetLeader());
+    }
+  }
+  SCHECK(ts, IllegalState, "No valid tserver found to bootstrap from");
+
+  std::shared_ptr<cdc::CDCServiceProxy> proxy;
+  RETURN_NOT_OK(ts->GetProxy(&proxy));
+
+  cdc::BootstrapProducerResponsePB bootstrap_resp;
+  rpc::RpcController bootstrap_rpc;
+  bootstrap_rpc.set_deadline(deadline);
+
+  // TODO(Hari): DB-9416 Make this async and atomic with upsert of the outbound replication group.
+  RETURN_NOT_OK(proxy->BootstrapProducer(bootstrap_req, &bootstrap_resp, &bootstrap_rpc));
+  if (bootstrap_resp.has_error()) {
+    RETURN_NOT_OK(StatusFromPB(bootstrap_resp.error().status()));
+  }
+
+  SCHECK_EQ(
+      table_infos.size(), bootstrap_resp.cdc_bootstrap_ids_size(), IllegalState,
+      "Number of tables to bootstrap and number of bootstrap ids do not match");
+
+  std::vector<xrepl::StreamId> stream_ids;
+  for (const auto& bootstrap_id : bootstrap_resp.cdc_bootstrap_ids()) {
+    stream_ids.emplace_back(VERIFY_RESULT(xrepl::StreamId::FromString(bootstrap_id)));
+  }
+  return stream_ids;
+}
+
+std::vector<std::shared_ptr<PostTabletCreateTaskBase>>
+XClusterSourceManager::GetPostTabletCreateTasks(
+    const TableInfoPtr& table_info, const LeaderEpoch& epoch) {
+  return {};
+}
+
+Result<std::vector<NamespaceId>> XClusterSourceManager::CreateOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::vector<NamespaceName>& namespace_names, const LeaderEpoch& epoch,
+    CoarseTimePoint deadline) {
+  std::lock_guard l(outbound_replication_group_map_mutex_);
+  SCHECK(
+      !outbound_replication_group_map_.contains(replication_group_id), IllegalState,
+      "xClusterOutboundReplicationGroup $0 already exists", replication_group_id);
+
+  SysXClusterOutboundReplicationGroupEntryPB metadata;  // Empty metadata.
+  auto outbound_replication_group = InitOutboundReplicationGroup(replication_group_id, metadata);
+
+  // This will persist the group to SysCatalog.
+  auto namespace_ids =
+      VERIFY_RESULT(outbound_replication_group.AddNamespaces(epoch, namespace_names, deadline));
+
+  outbound_replication_group_map_.emplace(
+      replication_group_id, std::move(outbound_replication_group));
+
+  return namespace_ids;
+}
+
+Result<NamespaceId> XClusterSourceManager::AddNamespaceToOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id, const NamespaceName& namespace_name,
+    const LeaderEpoch& epoch, CoarseTimePoint deadline) {
+  std::lock_guard l(outbound_replication_group_map_mutex_);
+  auto outbound_replication_group =
+      VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
+
+  return outbound_replication_group->AddNamespace(epoch, namespace_name, deadline);
+}
+
+Status XClusterSourceManager::RemoveNamespaceFromOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
+    const LeaderEpoch& epoch) {
+  std::lock_guard l(outbound_replication_group_map_mutex_);
+  auto outbound_replication_group =
+      VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
+
+  return outbound_replication_group->RemoveNamespace(epoch, namespace_id);
+}
+
+Status XClusterSourceManager::DeleteOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id, const LeaderEpoch& epoch) {
+  std::lock_guard l(outbound_replication_group_map_mutex_);
+  auto outbound_replication_group =
+      VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
+
+  // This will remove the group from SysCatalog.
+  RETURN_NOT_OK(outbound_replication_group->Delete(epoch));
+
+  outbound_replication_group_map_.erase(replication_group_id);
+
+  return Status::OK();
+}
+
+Result<std::optional<bool>> XClusterSourceManager::IsBootstrapRequired(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const NamespaceId& namespace_id) const {
+  SharedLock l(outbound_replication_group_map_mutex_);
+  auto outbound_replication_group =
+      VERIFY_RESULT(const_cast<const XClusterSourceManager*>(this)->GetOutboundReplicationGroup(
+          replication_group_id));
+
+  return outbound_replication_group->IsBootstrapRequired(namespace_id);
+}
+
+Result<std::optional<NamespaceCheckpointInfo>> XClusterSourceManager::GetXClusterStreams(
+    const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
+    std::vector<std::pair<TableName, PgSchemaName>> opt_table_names) const {
+  SharedLock l(outbound_replication_group_map_mutex_);
+  auto outbound_replication_group =
+      VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
+
+  return outbound_replication_group->GetNamespaceCheckpointInfo(namespace_id, opt_table_names);
+}
+
+}  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_source_manager.h b/src/yb/master/xcluster/xcluster_source_manager.h
new file mode 100644
index 0000000000..8993500dab
--- /dev/null
+++ b/src/yb/master/xcluster/xcluster_source_manager.h
@@ -0,0 +1,115 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include <shared_mutex>
+
+#include "yb/cdc/xcluster_types.h"
+
+#include "yb/gutil/thread_annotations.h"
+
+#include "yb/master/xcluster/master_xcluster_types.h"
+#include "yb/master/xcluster/xcluster_outbound_replication_group.h"
+
+namespace yb {
+
+namespace cdc {
+class CDCStateTable;
+}  // namespace cdc
+
+namespace master {
+class CatalogManager;
+class Master;
+class PostTabletCreateTaskBase;
+class SysCatalogTable;
+
+class XClusterSourceManager {
+ public:
+ protected:
+  explicit XClusterSourceManager(
+      Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog);
+
+  ~XClusterSourceManager();
+
+  void Clear();
+
+  Status RunLoaders();
+
+  void SysCatalogLoaded();
+
+  void DumpState(std::ostream& out, bool on_disk_dump) const;
+
+  std::vector<std::shared_ptr<PostTabletCreateTaskBase>> GetPostTabletCreateTasks(
+      const TableInfoPtr& table_info, const LeaderEpoch& epoch);
+
+  Result<std::vector<NamespaceId>> CreateOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::vector<NamespaceName>& namespace_names, const LeaderEpoch& epoch,
+      CoarseTimePoint deadline);
+
+  Result<NamespaceId> AddNamespaceToOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id, const NamespaceName& namespace_name,
+      const LeaderEpoch& epoch, CoarseTimePoint deadline);
+
+  Status RemoveNamespaceFromOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
+      const LeaderEpoch& epoch);
+
+  Status DeleteOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id, const LeaderEpoch& epoch);
+
+  Result<std::optional<bool>> IsBootstrapRequired(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const NamespaceId& namespace_id) const;
+
+  Result<std::optional<NamespaceCheckpointInfo>> GetXClusterStreams(
+      const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
+      std::vector<std::pair<TableName, PgSchemaName>> opt_table_names) const;
+
+ private:
+  Status InsertOutboundReplicationGroup(
+      const std::string& replication_group_id,
+      const SysXClusterOutboundReplicationGroupEntryPB& metadata)
+      EXCLUDES(outbound_replication_group_map_mutex_);
+
+  XClusterOutboundReplicationGroup InitOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const SysXClusterOutboundReplicationGroupEntryPB& metadata);
+
+  Result<XClusterOutboundReplicationGroup*> GetOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id)
+      REQUIRES(outbound_replication_group_map_mutex_);
+
+  Result<const XClusterOutboundReplicationGroup*> GetOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id) const
+      REQUIRES_SHARED(outbound_replication_group_map_mutex_);
+
+  Result<std::vector<TableInfoPtr>> GetTablesToReplicate(const NamespaceId& namespace_id);
+
+  Result<std::vector<xrepl::StreamId>> BootstrapTables(
+      const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline);
+
+  Master& master_;
+  CatalogManager& catalog_manager_;
+  SysCatalogTable& sys_catalog_;
+
+  mutable std::shared_mutex outbound_replication_group_map_mutex_;
+  std::map<xcluster::ReplicationGroupId, XClusterOutboundReplicationGroup>
+      outbound_replication_group_map_ GUARDED_BY(outbound_replication_group_map_mutex_);
+
+  DISALLOW_COPY_AND_ASSIGN(XClusterSourceManager);
+};
+
+}  // namespace master
+}  // namespace yb
diff --git a/src/yb/master/xcluster/xcluster_target_manager.cc b/src/yb/master/xcluster/xcluster_target_manager.cc
new file mode 100644
index 0000000000..9ca7e0e907
--- /dev/null
+++ b/src/yb/master/xcluster/xcluster_target_manager.cc
@@ -0,0 +1,259 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/master/xcluster/xcluster_target_manager.h"
+
+#include "yb/master/catalog_entity_info.pb.h"
+#include "yb/master/catalog_entity_info.h"
+#include "yb/master/catalog_manager.h"
+#include "yb/master/catalog_manager_util.h"
+#include "yb/master/master.h"
+#include "yb/master/xcluster/add_table_to_xcluster_target_task.h"
+#include "yb/master/xcluster/xcluster_safe_time_service.h"
+
+#include "yb/util/flags.h"
+#include "yb/util/status.h"
+
+DEFINE_RUNTIME_bool(
+    disable_auto_add_index_to_xcluster, false,
+    "Disables the automatic addition of indexes to transactional xCluster replication.");
+
+namespace yb::master {
+
+XClusterTargetManager::XClusterTargetManager(
+    Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog)
+    : master_(master), catalog_manager_(catalog_manager), sys_catalog_(sys_catalog) {}
+
+XClusterTargetManager::~XClusterTargetManager() {}
+
+void XClusterTargetManager::Shutdown() {
+  if (xcluster_safe_time_service_) {
+    xcluster_safe_time_service_->Shutdown();
+  }
+}
+
+Status XClusterTargetManager::Init() {
+  DCHECK(!xcluster_safe_time_service_);
+  xcluster_safe_time_service_ = std::make_unique<XClusterSafeTimeService>(
+      &master_, &catalog_manager_, master_.metric_registry());
+  RETURN_NOT_OK(xcluster_safe_time_service_->Init());
+
+  return Status::OK();
+}
+
+void XClusterTargetManager::Clear() { xcluster_safe_time_info_.Clear(); }
+
+Status XClusterTargetManager::RunLoaders() {
+  RETURN_NOT_OK(
+      sys_catalog_.Load<XClusterSafeTimeLoader>("XCluster safe time", xcluster_safe_time_info_));
+  return Status::OK();
+}
+
+void XClusterTargetManager::SysCatalogLoaded() {
+  xcluster_safe_time_service_->ScheduleTaskIfNeeded();
+}
+
+void XClusterTargetManager::DumpState(std::ostream& out, bool on_disk_dump) const {
+  if (!on_disk_dump) {
+    return;
+  }
+
+  auto l = xcluster_safe_time_info_.LockForRead();
+  if (l->pb.safe_time_map().empty()) {
+    return;
+  }
+  out << "XCluster Safe Time: " << l->pb.ShortDebugString() << "\n";
+}
+
+void XClusterTargetManager::CreateXClusterSafeTimeTableAndStartService() {
+  WARN_NOT_OK(
+      xcluster_safe_time_service_->CreateXClusterSafeTimeTableIfNotFound(),
+      "Creation of XClusterSafeTime table failed");
+
+  xcluster_safe_time_service_->ScheduleTaskIfNeeded();
+}
+
+Status XClusterTargetManager::GetXClusterSafeTime(
+    GetXClusterSafeTimeResponsePB* resp, const LeaderEpoch& epoch) {
+  RETURN_NOT_OK_SET_CODE(
+      xcluster_safe_time_service_->GetXClusterSafeTimeInfoFromMap(epoch, resp),
+      MasterError(MasterErrorPB::INTERNAL_ERROR));
+
+  // Also fill out the namespace_name for each entry.
+  if (resp->namespace_safe_times_size()) {
+    for (auto& safe_time_info : *resp->mutable_namespace_safe_times()) {
+      const auto namespace_info = VERIFY_RESULT_OR_SET_CODE(
+          catalog_manager_.FindNamespaceById(safe_time_info.namespace_id()),
+          MasterError(MasterErrorPB::INTERNAL_ERROR));
+
+      safe_time_info.set_namespace_name(namespace_info->name());
+    }
+  }
+
+  return Status::OK();
+}
+
+Result<HybridTime> XClusterTargetManager::GetXClusterSafeTime(
+    const NamespaceId& namespace_id) const {
+  auto l = xcluster_safe_time_info_.LockForRead();
+  SCHECK(
+      l->pb.safe_time_map().count(namespace_id), NotFound,
+      "XCluster safe time not found for namespace $0", namespace_id);
+
+  return HybridTime(l->pb.safe_time_map().at(namespace_id));
+}
+
+Result<XClusterNamespaceToSafeTimeMap> XClusterTargetManager::GetXClusterNamespaceToSafeTimeMap()
+    const {
+  XClusterNamespaceToSafeTimeMap result;
+  auto l = xcluster_safe_time_info_.LockForRead();
+
+  for (auto& [namespace_id, hybrid_time] : l->pb.safe_time_map()) {
+    result[namespace_id] = HybridTime(hybrid_time);
+  }
+  return result;
+}
+
+Result<XClusterNamespaceToSafeTimeMap>
+XClusterTargetManager::RefreshAndGetXClusterNamespaceToSafeTimeMap(const LeaderEpoch& epoch) {
+  return xcluster_safe_time_service_->RefreshAndGetXClusterNamespaceToSafeTimeMap(epoch);
+}
+
+Status XClusterTargetManager::SetXClusterNamespaceToSafeTimeMap(
+    const int64_t leader_term, const XClusterNamespaceToSafeTimeMap& safe_time_map) {
+  auto l = xcluster_safe_time_info_.LockForWrite();
+  auto& safe_time_map_pb = *l.mutable_data()->pb.mutable_safe_time_map();
+  safe_time_map_pb.clear();
+  for (auto& [namespace_id, hybrid_time] : safe_time_map) {
+    safe_time_map_pb[namespace_id] = hybrid_time.ToUint64();
+  }
+
+  RETURN_NOT_OK_PREPEND(
+      sys_catalog_.Upsert(leader_term, &xcluster_safe_time_info_),
+      "Updating XCluster safe time in sys-catalog");
+
+  l.Commit();
+
+  return Status::OK();
+}
+
+Status XClusterTargetManager::FillHeartbeatResponse(
+    const TSHeartbeatRequestPB& req, TSHeartbeatResponsePB* resp) const {
+  auto l = xcluster_safe_time_info_.LockForRead();
+  if (!l->pb.safe_time_map().empty()) {
+    *resp->mutable_xcluster_namespace_to_safe_time() = l->pb.safe_time_map();
+  }
+
+  return Status::OK();
+}
+
+bool XClusterTargetManager::ShouldAddTableToXClusterTarget(const TableInfo& table) const {
+  if (FLAGS_disable_auto_add_index_to_xcluster) {
+    return false;
+  }
+
+  const auto& pb = table.metadata().dirty().pb;
+
+  // Only user created YSQL Indexes should be automatically added to xCluster replication.
+  // For Colocated tables, this function will return false since it is only called on the parent
+  // colocated table, which cannot be an index.
+  if (pb.colocated() || pb.table_type() != PGSQL_TABLE_TYPE || !IsIndex(pb) ||
+      !catalog_manager_.IsUserCreatedTable(table)) {
+    return false;
+  }
+
+  auto indexed_table_stream_ids = catalog_manager_.GetXClusterConsumerStreamIdsForTable(table.id());
+  if (!indexed_table_stream_ids.empty()) {
+    VLOG(1) << "Index " << table.ToString() << " is already part of xcluster replication "
+            << yb::ToString(indexed_table_stream_ids);
+    return false;
+  }
+
+  auto indexed_table = catalog_manager_.GetTableInfo(GetIndexedTableId(pb));
+  if (!indexed_table) {
+    LOG(WARNING) << "Indexed table for " << table.id() << " not found";
+    return false;
+  }
+
+  auto stream_ids = catalog_manager_.GetXClusterConsumerStreamIdsForTable(indexed_table->id());
+  if (stream_ids.empty()) {
+    return false;
+  }
+
+  if (stream_ids.size() > 1) {
+    LOG(WARNING) << "Skipping adding index " << table.ToString()
+                 << " to xCluster replication as the base table" << indexed_table->ToString()
+                 << " is part of multiple replication streams " << yb::ToString(stream_ids);
+    return false;
+  }
+
+  const auto& replication_group_id = stream_ids.begin()->first;
+  auto cluster_config = catalog_manager_.ClusterConfig();
+  {
+    auto l = cluster_config->LockForRead();
+    const auto& consumer_registry = l.data().pb.consumer_registry();
+    // Only add if we are in a transactional replication with STANDBY mode.
+    if (consumer_registry.role() != cdc::XClusterRole::STANDBY ||
+        !consumer_registry.transactional()) {
+      return false;
+    }
+
+    auto producer_entry =
+        FindOrNull(consumer_registry.producer_map(), replication_group_id.ToString());
+    if (producer_entry) {
+      // Check if the table is already part of replication.
+      // This is needed despite the check for GetXClusterConsumerStreamIdsForTable as the in-memory
+      // list is not atomically updated.
+      for (auto& stream_info : producer_entry->stream_map()) {
+        if (stream_info.second.consumer_table_id() == table.id()) {
+          VLOG(1) << "Index " << table.ToString() << " is already part of xcluster replication "
+                  << stream_info.first;
+          return false;
+        }
+      }
+    }
+  }
+
+  scoped_refptr<UniverseReplicationInfo> universe;
+  {
+    auto universe = catalog_manager_.GetUniverseReplication(replication_group_id);
+    if (universe == nullptr) {
+      LOG(WARNING) << "Skip adding index " << table.ToString()
+                   << " to xCluster replication as the universe " << replication_group_id
+                   << " was not found";
+      return false;
+    }
+
+    if (universe->LockForRead()->is_deleted_or_failed()) {
+      LOG(WARNING) << "Skip adding index " << table.ToString()
+                   << " to xCluster replication as the universe " << replication_group_id
+                   << " is in a deleted or failed state";
+      return false;
+    }
+  }
+
+  return true;
+}
+
+std::vector<std::shared_ptr<PostTabletCreateTaskBase>>
+XClusterTargetManager::GetPostTabletCreateTasks(
+    const TableInfoPtr& table_info, const LeaderEpoch& epoch) {
+  if (!ShouldAddTableToXClusterTarget(*table_info)) {
+    return {};
+  }
+
+  return {std::make_shared<AddTableToXClusterTargetTask>(
+      catalog_manager_, *master_.messenger(), table_info, epoch)};
+}
+
+}  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_target_manager.h b/src/yb/master/xcluster/xcluster_target_manager.h
new file mode 100644
index 0000000000..bbfb35676a
--- /dev/null
+++ b/src/yb/master/xcluster/xcluster_target_manager.h
@@ -0,0 +1,92 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include "yb/master/leader_epoch.h"
+#include "yb/master/master_fwd.h"
+
+#include "yb/master/xcluster/master_xcluster_types.h"
+#include "yb/master/xcluster/xcluster_catalog_entity.h"
+#include "yb/rpc/rpc_fwd.h"
+#include "yb/util/status_fwd.h"
+
+namespace yb::master {
+
+class TSHeartbeatRequestPB;
+class TSHeartbeatResponsePB;
+
+class PostTabletCreateTaskBase;
+class XClusterSafeTimeService;
+
+class XClusterTargetManager {
+ public:
+  // XCluster Safe Time.
+  void CreateXClusterSafeTimeTableAndStartService();
+
+  Result<XClusterNamespaceToSafeTimeMap> GetXClusterNamespaceToSafeTimeMap() const;
+
+  Status SetXClusterNamespaceToSafeTimeMap(
+      const int64_t leader_term, const XClusterNamespaceToSafeTimeMap& safe_time_map);
+
+  Status GetXClusterSafeTime(GetXClusterSafeTimeResponsePB* resp, const LeaderEpoch& epoch);
+
+  Result<HybridTime> GetXClusterSafeTime(const NamespaceId& namespace_id) const;
+
+  Result<XClusterNamespaceToSafeTimeMap> RefreshAndGetXClusterNamespaceToSafeTimeMap(
+      const LeaderEpoch& epoch);
+
+  XClusterSafeTimeService* TEST_xcluster_safe_time_service() {
+    return xcluster_safe_time_service_.get();
+  }
+
+ protected:
+  explicit XClusterTargetManager(
+      Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog);
+
+  ~XClusterTargetManager();
+
+  void Shutdown();
+
+  Status Init();
+
+  void Clear();
+
+  Status RunLoaders();
+
+  void SysCatalogLoaded();
+
+  void DumpState(std::ostream& out, bool on_disk_dump) const;
+
+  Status FillHeartbeatResponse(const TSHeartbeatRequestPB& req, TSHeartbeatResponsePB* resp) const;
+
+  bool ShouldAddTableToXClusterTarget(const TableInfo& table_info) const;
+
+  std::vector<std::shared_ptr<PostTabletCreateTaskBase>> GetPostTabletCreateTasks(
+      const TableInfoPtr& table_info, const LeaderEpoch& epoch);
+
+ private:
+  Master& master_;
+  CatalogManager& catalog_manager_;
+  SysCatalogTable& sys_catalog_;
+
+  std::unique_ptr<XClusterSafeTimeService> xcluster_safe_time_service_;
+
+  // The Catalog Entity is stored outside of XClusterSafeTimeService, since we may want to move the
+  // service out of master at a later time.
+  XClusterSafeTimeInfo xcluster_safe_time_info_;
+
+  DISALLOW_COPY_AND_ASSIGN(XClusterTargetManager);
+};
+
+}  // namespace yb::master
