diff --git a/src/yb/common/common_flags.cc b/src/yb/common/common_flags.cc
index eab2f977c7..5cbffdd6ed 100644
--- a/src/yb/common/common_flags.cc
+++ b/src/yb/common/common_flags.cc
@@ -146,36 +146,33 @@ namespace {
 
 constexpr const auto kMinRpcThrottleThresholdBytes = 16;
 
-void RpcThrottleThresholdBytesValidator() {
-  if (FLAGS_rpc_throttle_threshold_bytes <= 0) {
-    return;
+bool RpcThrottleThresholdBytesValidator(const char* flag_name, int64 value) {
+  if (value <= 0) {
+    return true;
   }
 
-  if (FLAGS_rpc_throttle_threshold_bytes < kMinRpcThrottleThresholdBytes) {
-    LOG(FATAL) << "Flag validation failed. rpc_throttle_threshold_bytes (value: "
-               << FLAGS_rpc_throttle_threshold_bytes << ") must be at least "
-               << kMinRpcThrottleThresholdBytes;
+  if (value < kMinRpcThrottleThresholdBytes) {
+    LOG_FLAG_VALIDATION_ERROR(flag_name, value)
+        << "Must be at least " << kMinRpcThrottleThresholdBytes;
+    return false;
   }
 
-  if (yb::std_util::cmp_greater_equal(
-          FLAGS_rpc_throttle_threshold_bytes, FLAGS_consensus_max_batch_size_bytes)) {
-    LOG(FATAL) << "Flag validation failed. rpc_throttle_threshold_bytes (value: "
-               << FLAGS_rpc_throttle_threshold_bytes
-               << ") must be less than consensus_max_batch_size_bytes "
-               << "(value: " << FLAGS_consensus_max_batch_size_bytes << ")";
+  // This validation depends on the value of other flag(s): consensus_max_batch_size_bytes.
+  DELAY_FLAG_VALIDATION_ON_STARTUP(flag_name);
+
+  if (yb::std_util::cmp_greater_equal(value, FLAGS_consensus_max_batch_size_bytes)) {
+    LOG_FLAG_VALIDATION_ERROR(flag_name, value)
+        << "Must be less than consensus_max_batch_size_bytes "
+        << "(value: " << FLAGS_consensus_max_batch_size_bytes << ")";
+    return false;
   }
+
+  return true;
 }
 
 }  // namespace
 
-// Normally we would have used DEFINE_validator. But this validation depends on the value of another
-// flag (consensus_max_batch_size_bytes). On process startup flag validations are run as each flag
-// gets parsed from the command line parameter. So this would impose a restriction on the user to
-// pass the flags in a particular obscure order via command line. YBA has no guarantees on the order
-// it uses as well. So, instead we use a Callback with LOG(FATAL) since at startup Callbacks are run
-// after all the flags have been parsed.
-REGISTER_CALLBACK(rpc_throttle_threshold_bytes, "RpcThrottleThresholdBytesValidator",
-    &RpcThrottleThresholdBytesValidator);
+DEFINE_validator(rpc_throttle_threshold_bytes, &RpcThrottleThresholdBytesValidator);
 
 DEFINE_RUNTIME_AUTO_bool(enable_xcluster_auto_flag_validation, kLocalPersisted, false, true,
     "Enables validation of AutoFlags between the xcluster universes");
diff --git a/src/yb/tserver/stateful_services/pg_cron_leader_service.cc b/src/yb/tserver/stateful_services/pg_cron_leader_service.cc
index 4b75303c5a..4b0f5eb3d4 100644
--- a/src/yb/tserver/stateful_services/pg_cron_leader_service.cc
+++ b/src/yb/tserver/stateful_services/pg_cron_leader_service.cc
@@ -25,17 +25,22 @@ DEFINE_RUNTIME_uint32(pg_cron_leadership_refresh_sec, 10,
 DECLARE_uint64(max_clock_skew_usec);
 
 namespace {
-void ValidateLeadershipRefreshSec() {
-  LOG_IF(FATAL, FLAGS_pg_cron_leadership_refresh_sec >= FLAGS_pg_cron_leader_lease_sec)
-      << "Invalid value " << FLAGS_pg_cron_leadership_refresh_sec
-      << " for 'pg_cron_leadership_refresh_sec'. Value should be less than "
-         "pg_cron_leader_lease_sec "
-      << FLAGS_pg_cron_leader_lease_sec;
+bool ValidateLeadershipRefreshSec(const char* flag_name, uint32 value) {
+  // This validation depends on the value of other flag(s): pg_cron_leader_lease_sec.
+  DELAY_FLAG_VALIDATION_ON_STARTUP(flag_name);
+
+  if (value >= FLAGS_pg_cron_leader_lease_sec) {
+    LOG_FLAG_VALIDATION_ERROR(flag_name, value)
+        << "Must be less than pg_cron_leader_lease_sec " << FLAGS_pg_cron_leader_lease_sec;
+    return false;
+  }
+
+  return true;
 }
+
 }  // namespace
 
-REGISTER_CALLBACK(pg_cron_leadership_refresh_sec, "pg_cron_leadership_refresh_sec",
-    ValidateLeadershipRefreshSec)
+DEFINE_validator(pg_cron_leadership_refresh_sec, &ValidateLeadershipRefreshSec);
 
 namespace yb {
 namespace stateful_service {
diff --git a/src/yb/tserver/tablet_server.cc b/src/yb/tserver/tablet_server.cc
index c5c3ccd5d4..8c3ee63793 100644
--- a/src/yb/tserver/tablet_server.cc
+++ b/src/yb/tserver/tablet_server.cc
@@ -244,40 +244,48 @@ uint16_t GetPostgresPort() {
   return postgres_address.port();
 }
 
-void PostgresAndYsqlConnMgrPortValidator() {
+bool PostgresAndYsqlConnMgrPortValidator(const char* flag_name, uint32 value) {
+  // This validation depends on the value of other flag(s): enable_ysql_conn_mgr,
+  // pgsql_proxy_bind_address.
+  DELAY_FLAG_VALIDATION_ON_STARTUP(flag_name);
+
   if (!FLAGS_enable_ysql_conn_mgr) {
-    return;
+    return true;
   }
   const auto pg_port = GetPostgresPort();
-  if (FLAGS_ysql_conn_mgr_port == pg_port) {
+  if (value == pg_port) {
     if (pg_port != pgwrapper::PgProcessConf::kDefaultPort) {
-      LOG(FATAL) << "Postgres port (pgsql_proxy_bind_address: " << pg_port
-                 << ") and Ysql Connection Manager port (ysql_conn_mgr_port:"
-                 << FLAGS_ysql_conn_mgr_port << ") cannot be the same.";
+      LOG_FLAG_VALIDATION_ERROR(flag_name, value)
+          << "Must be different from the Postgres port pgsql_proxy_bind_address (" << pg_port
+          << ")";
+      return false;
     } else {
       // Ignore. t-server will resolve the conflict in SetProxyAddresses.
     }
   }
+
+  return true;
 }
 
-// Normally we would have used DEFINE_validator. But this validation depends on the value of another
-// flag (pgsql_proxy_bind_address). On process startup flag validations are run as each flag
-// gets parsed from the command line parameter. So this would impose a restriction on the user to
-// pass the flags in a particular obscure order via command line. YBA has no guarantees on the order
-// it uses as well. So, instead we use a Callback with LOG(FATAL) since at startup Callbacks are run
-// after all the flags have been parsed.
-REGISTER_CALLBACK(ysql_conn_mgr_port, "PostgresAndYsqlConnMgrPortValidator",
-    &PostgresAndYsqlConnMgrPortValidator);
+DEFINE_validator(ysql_conn_mgr_port, &PostgresAndYsqlConnMgrPortValidator);
 
-void ValidateEnableYsqlConnMgr() {
-  if (FLAGS_enable_ysql_conn_mgr && !(FLAGS_start_pgsql_proxy || FLAGS_enable_ysql)) {
-    LOG(FATAL) << "Cannot start Ysql Connection Manager (YSQL is not enabled)";
-    return;
+bool ValidateEnableYsqlConnMgr(const char* flag_name, bool value) {
+  if (!value) {
+    return true;
+  }
+
+  // This validation depends on the value of other flag(s): start_pgsql_proxy, enable_ysql.
+  DELAY_FLAG_VALIDATION_ON_STARTUP(flag_name);
+
+  if (!FLAGS_start_pgsql_proxy && !FLAGS_enable_ysql) {
+    LOG_FLAG_VALIDATION_ERROR(flag_name, value)
+        << "YSQL must be enabled to start the YSQL connection manager.";
+    return false;
   }
-  return;
+  return true;
 }
 
-REGISTER_CALLBACK(enable_ysql_conn_mgr, "ValidateEnableYsqlConnMgr", &ValidateEnableYsqlConnMgr);
+DEFINE_validator(enable_ysql_conn_mgr, &ValidateEnableYsqlConnMgr);
 
 class CDCServiceContextImpl : public cdc::CDCServiceContext {
  public:
diff --git a/src/yb/util/flags.h b/src/yb/util/flags.h
index 35e92ee3a9..ef89ceeb78 100644
--- a/src/yb/util/flags.h
+++ b/src/yb/util/flags.h
@@ -170,4 +170,18 @@ FlagValidatorSink& GetFlagValidatorSink();
   LOG_TO_SINK(&yb::GetFlagValidatorSink(), ERROR) \
       << "Invalid value '" << value << "' for flag '" << flag_name << "': "
 
+// Returns true if the flag was recorded for delayed validation, and the validation can be skipped.
+bool RecordFlagForDelayedValidation(const std::string& flag_name);
+
+// Some flag validation may depend on the value of another flag. Flags are parsed, validated and set
+// in order they are passed in via the command line, or flags file. In order to not impose a
+// restriction on the user to pass the flags in a particular obscure order, this macro delays
+// the validation until all flags have been set.
+#define DELAY_FLAG_VALIDATION_ON_STARTUP(flag_name) \
+  do { \
+    if (yb::RecordFlagForDelayedValidation(flag_name)) { \
+      return true; \
+    } \
+  } while (false)
+
 } // namespace yb
diff --git a/src/yb/util/flags/flags.cc b/src/yb/util/flags/flags.cc
index 722353c4ff..3226da4a43 100644
--- a/src/yb/util/flags/flags.cc
+++ b/src/yb/util/flags/flags.cc
@@ -353,6 +353,50 @@ struct sort_flags_by_name {
     return a.size() < b.size();
   }
 };
+
+std::vector<std::string>& FlagsWithDelayedValidation() {
+  static std::vector<std::string> flags;
+  return flags;
+}
+
+bool& CommandLineFlagsParsed() {
+  static bool parsed = false;
+  return parsed;
+}
+
+// Check if the flag can be set to the new value. Does not actually set the flag.
+Status ValidateFlagValue(const std::string& flag_name, const std::string& value) {
+  auto flag_info = google::GetCommandLineFlagInfoOrDie(flag_name.c_str());
+
+  // Clear previous errors if any.
+  GetFlagValidatorSink().GetMessagesAndClear();
+
+  std::string error_msg;
+  if (google::ValidateCommandLineOption(
+          flag_name.c_str(), flag_info.current_value.c_str(), &error_msg)) {
+    return Status::OK();
+  }
+
+  auto validation_msgs = GetFlagValidatorSink().GetMessagesAndClear();
+
+  return STATUS_FORMAT(
+      InvalidArgument, "$0 : $1", error_msg,
+      validation_msgs.empty() ? "Bad value" : JoinStrings(validation_msgs, ";"));
+}
+
+Status ValidateFlagsRequiringDelayedValidation() {
+  CommandLineFlagsParsed() = true;
+
+  for (const auto& flag_name : FlagsWithDelayedValidation()) {
+    auto flag_info = google::GetCommandLineFlagInfoOrDie(flag_name.c_str());
+    // Flag was already set without any validation. Check if the current value is valid.
+    RETURN_NOT_OK(ValidateFlagValue(flag_name, flag_info.current_value));
+  }
+  FlagsWithDelayedValidation().clear();
+
+  return Status::OK();
+}
+
 }  // namespace
 
 void DumpFlagsXMLAndExit(OnlyDisplayDefaultFlagValue only_display_default_values) {
@@ -553,6 +597,9 @@ void ParseCommandLineFlags(int* argc, char*** argv, bool remove_flags) {
 
     google::ParseCommandLineNonHelpFlags(argc, argv, remove_flags);
 
+    // Run validation that were previously ignored due to DELAY_FLAG_VALIDATION_ON_STARTUP.
+    CHECK_OK(ValidateFlagsRequiringDelayedValidation());
+
     // Ensure all preview flags overridden are in allow list before invoking any callbacks.
     string err_msg;
     if (!ValidateAllPreviewFlags(&err_msg, FLAGS_allowed_preview_flags_csv)) {
@@ -776,4 +823,12 @@ FlagValidatorSink& GetFlagValidatorSink() {
   return sink;
 }
 
+bool RecordFlagForDelayedValidation(const std::string& flag_name) {
+  if (CommandLineFlagsParsed()) {
+    return false;
+  }
+  FlagsWithDelayedValidation().emplace_back(flag_name);
+  return true;
+}
+
 } // namespace yb
