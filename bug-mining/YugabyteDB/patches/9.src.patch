diff --git a/src/yb/integration-tests/xcluster/xcluster_consistency-test.cc b/src/yb/integration-tests/xcluster/xcluster_consistency-test.cc
index 223d492836..fb9cf12e86 100644
--- a/src/yb/integration-tests/xcluster/xcluster_consistency-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_consistency-test.cc
@@ -238,7 +238,7 @@ class XClusterConsistencyTest : public XClusterYsqlTestBase {
   Result<uint64_t> GetXClusterSafeTimeLagFromMetrics(const NamespaceId& namespace_id) {
     auto& cm = VERIFY_RESULT(consumer_cluster()->GetLeaderMiniMaster())->catalog_manager();
     const auto metrics =
-        cm.GetXClusterManager()->TEST_xcluster_safe_time_service()->TEST_GetMetricsForNamespace(
+        cm.GetXClusterManagerImpl()->TEST_xcluster_safe_time_service()->TEST_GetMetricsForNamespace(
             namespace_id);
     const auto safe_time_lag = metrics->consumer_safe_time_lag->value();
     const auto safe_time_skew = metrics->consumer_safe_time_skew->value();
diff --git a/src/yb/master/CMakeLists.txt b/src/yb/master/CMakeLists.txt
index daf18935db..abf91dbca4 100644
--- a/src/yb/master/CMakeLists.txt
+++ b/src/yb/master/CMakeLists.txt
@@ -128,6 +128,7 @@ set(MASTER_SRCS
   universe_key_registry_service.cc
   util/yql_vtable_helpers.cc
   xcluster/add_table_to_xcluster_task.cc
+  xcluster/xcluster_catalog_entity.cc
   xcluster/xcluster_config.cc
   xcluster/xcluster_consumer_metrics.cc
   xcluster/xcluster_safe_time_service.cc
diff --git a/src/yb/master/backfill_index.cc b/src/yb/master/backfill_index.cc
index f1abdd517b..eb31f24ce4 100644
--- a/src/yb/master/backfill_index.cc
+++ b/src/yb/master/backfill_index.cc
@@ -56,6 +56,7 @@
 #include "yb/master/master_error.h"
 #include "yb/master/master_ddl.pb.h"
 #include "yb/master/sys_catalog.h"
+#include "yb/master/xcluster/xcluster_manager_if.h"
 
 #include "yb/tablet/tablet.h"
 #include "yb/tablet/tablet_metadata.h"
@@ -774,7 +775,7 @@ Status BackfillTable::LaunchComputeSafeTimeForRead() {
   RSTATUS_DCHECK(!timestamp_chosen(), IllegalState, "Backfill timestamp already set");
 
   if (master_->catalog_manager_impl()->IsTableXClusterConsumer(*indexed_table_)) {
-    auto res = master_->catalog_manager_impl()->GetXClusterSafeTime(indexed_table_->namespace_id());
+    auto res = master_->xcluster_manager()->GetXClusterSafeTime(indexed_table_->namespace_id());
     if (res.ok()) {
       SCHECK(!res->is_special(), InvalidArgument, "Invalid xCluster safe time for namespace ",
              indexed_table_->namespace_id());
diff --git a/src/yb/master/catalog_entity_base.h b/src/yb/master/catalog_entity_base.h
new file mode 100644
index 0000000000..683e6e38ea
--- /dev/null
+++ b/src/yb/master/catalog_entity_base.h
@@ -0,0 +1,101 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include "yb/master/master_types.pb.h"
+#include "yb/util/cow_object.h"
+
+namespace yb::master {
+
+// This class is a base wrapper around the protos that get serialized in the data column of the
+// sys_catalog. Subclasses of this will provide convenience getter/setter methods around the
+// protos and instances of these will be wrapped around CowObjects and locks for access and
+// modifications.
+template <class DataEntryPB, SysRowEntryType entry_type>
+struct Persistent {
+  // Type declaration to be used in templated read/write methods. We are using typename
+  // Class::data_type in templated methods for figuring out the type we need.
+  typedef DataEntryPB data_type;
+
+  // Subclasses of this need to provide a valid value of the entry type through
+  // the template class argument.
+  static SysRowEntryType type() { return entry_type; }
+
+  // The proto that is persisted in the sys_catalog.
+  DataEntryPB pb;
+};
+
+// This class is a base wrapper around accessors for the persistent proto data, through CowObject.
+// The locks are taken on subclasses of this class, around the object returned from metadata().
+template <class PersistentDataEntryPB>
+class MetadataCowWrapper {
+ public:
+  // Type declaration for use in the Lock classes.
+  typedef PersistentDataEntryPB CowState;
+  typedef CowWriteLock<CowState> WriteLock;
+  typedef CowReadLock<CowState> ReadLock;
+
+  // This method should return the id to be written into the sys_catalog id column.
+  virtual const std::string& id() const = 0;
+
+  // Pretty printing.
+  virtual std::string ToString() const {
+    return Format("Object type = $0 (id = $1)", PersistentDataEntryPB::type(), id());
+  }
+
+  // Access the persistent metadata. Typically you should use
+  // MetadataLock to gain access to this data.
+  const CowObject<PersistentDataEntryPB>& metadata() const { return metadata_; }
+  CowObject<PersistentDataEntryPB>* mutable_metadata() { return &metadata_; }
+
+  ReadLock LockForRead() const { return ReadLock(&metadata()); }
+
+  WriteLock LockForWrite() { return WriteLock(mutable_metadata()); }
+
+  const auto& old_pb() const { return metadata_.state().pb; }
+
+  const auto& new_pb() const { return metadata_.dirty().pb; }
+
+  static auto type() { return CowState::type(); }
+
+  virtual void Load(const decltype(PersistentDataEntryPB::pb)& metadata) {
+    VLOG_WITH_FUNC(2) << "Loading " << type() << " data: " << metadata.DebugString();
+
+    auto l = LockForWrite();
+    l.mutable_data()->pb.CopyFrom(metadata);
+    l.Commit();
+  }
+
+  virtual void Clear() {
+    auto l = LockForWrite();
+    l.mutable_data()->pb.Clear();
+    l.Commit();
+  }
+
+ protected:
+  virtual ~MetadataCowWrapper() = default;
+  CowObject<PersistentDataEntryPB> metadata_;
+};
+
+// Singleton PersistentDataEntry which does not use the ID field.
+template <class PersistentDataEntryPB>
+class SingletonMetadataCowWrapper : public MetadataCowWrapper<PersistentDataEntryPB> {
+ public:
+  const std::string& id() const override {
+    static const std::string fake_id;
+    return fake_id;
+  }
+};
+
+}  // namespace yb::master
diff --git a/src/yb/master/catalog_entity_info.cc b/src/yb/master/catalog_entity_info.cc
index 5d79c6839b..fbe37f1fce 100644
--- a/src/yb/master/catalog_entity_info.cc
+++ b/src/yb/master/catalog_entity_info.cc
@@ -1246,12 +1246,6 @@ std::string DdlLogEntry::id() const {
   return DocHybridTime(HybridTime(pb_.time()), kMaxWriteId).EncodedInDocDbFormat();
 }
 
-void XClusterSafeTimeInfo::Clear() {
-  auto l = LockForWrite();
-  l.mutable_data()->pb.Clear();
-  l.Commit();
-}
-
 // ================================================================================================
 // CDCStreamInfo
 // ================================================================================================
diff --git a/src/yb/master/catalog_entity_info.h b/src/yb/master/catalog_entity_info.h
index 9bdc4dc751..b2717d5f8c 100644
--- a/src/yb/master/catalog_entity_info.h
+++ b/src/yb/master/catalog_entity_info.h
@@ -40,6 +40,7 @@
 
 #include "yb/cdc/cdc_types.h"
 #include "yb/common/entity_ids.h"
+#include "yb/master/catalog_entity_base.h"
 #include "yb/master/leader_epoch.h"
 #include "yb/master/master_backup.pb.h"
 #include "yb/qlexpr/index.h"
@@ -180,73 +181,6 @@ struct TabletReplica {
   std::string ToString() const;
 };
 
-// This class is a base wrapper around the protos that get serialized in the data column of the
-// sys_catalog. Subclasses of this will provide convenience getter/setter methods around the
-// protos and instances of these will be wrapped around CowObjects and locks for access and
-// modifications.
-template <class DataEntryPB, SysRowEntryType entry_type>
-struct Persistent {
-  // Type declaration to be used in templated read/write methods. We are using typename
-  // Class::data_type in templated methods for figuring out the type we need.
-  typedef DataEntryPB data_type;
-
-  // Subclasses of this need to provide a valid value of the entry type through
-  // the template class argument.
-  static SysRowEntryType type() { return entry_type; }
-
-  // The proto that is persisted in the sys_catalog.
-  DataEntryPB pb;
-};
-
-// This class is a base wrapper around accessors for the persistent proto data, through CowObject.
-// The locks are taken on subclasses of this class, around the object returned from metadata().
-template <class PersistentDataEntryPB>
-class MetadataCowWrapper {
- public:
-  // Type declaration for use in the Lock classes.
-  typedef PersistentDataEntryPB CowState;
-  typedef CowWriteLock<CowState> WriteLock;
-  typedef CowReadLock<CowState> ReadLock;
-
-  // This method should return the id to be written into the sys_catalog id column.
-  virtual const std::string& id() const = 0;
-
-  // Pretty printing.
-  virtual std::string ToString() const {
-    return Format(
-        "Object type = $0 (id = $1)", PersistentDataEntryPB::type(), id());
-  }
-
-  // Access the persistent metadata. Typically you should use
-  // MetadataLock to gain access to this data.
-  const CowObject<PersistentDataEntryPB>& metadata() const { return metadata_; }
-  CowObject<PersistentDataEntryPB>* mutable_metadata() { return &metadata_; }
-
-  ReadLock LockForRead() const {
-    return ReadLock(&metadata());
-  }
-
-  WriteLock LockForWrite() {
-    return WriteLock(mutable_metadata());
-  }
-
-  const auto& old_pb() const {
-    return metadata_.state().pb;
-  }
-
-  const auto& new_pb() const {
-    return metadata_.dirty().pb;
-  }
-
-  static auto type() {
-    return CowState::type();
-  }
-
- protected:
-  virtual ~MetadataCowWrapper() = default;
-  CowObject<PersistentDataEntryPB> metadata_;
-};
-
 // The data related to a tablet which is persisted on disk.
 // This portion of TabletInfo is managed via CowObject.
 // It wraps the underlying protobuf to add useful accessors.
@@ -1006,36 +940,7 @@ struct PersistentClusterConfigInfo : public Persistent<SysClusterConfigEntryPB,
 
 // This is the in memory representation of the cluster config information serialized proto data,
 // using metadata() for CowObject access.
-class ClusterConfigInfo : public MetadataCowWrapper<PersistentClusterConfigInfo> {
- public:
-  ClusterConfigInfo() {}
-  ~ClusterConfigInfo() = default;
-
-  virtual const std::string& id() const override { return fake_id_; }
-
- private:
-  // We do not use the ID field in the sys_catalog table.
-  const std::string fake_id_;
-};
-
-// This wraps around the proto containing xcluster cluster level config information. It will be used
-// for CowObject managed access.
-struct PersistentXClusterConfigInfo
-    : public Persistent<SysXClusterConfigEntryPB, SysRowEntryType::XCLUSTER_CONFIG> {};
-
-// This is the in memory representation of the xcluster config information serialized proto
-// data, using metadata() for CowObject access.
-class XClusterConfigInfo : public MetadataCowWrapper<PersistentXClusterConfigInfo> {
- public:
-  XClusterConfigInfo() {}
-  ~XClusterConfigInfo() = default;
-
-  virtual const std::string& id() const override { return fake_id_; }
-
- private:
-  // We do not use the ID field in the sys_catalog table.
-  const std::string fake_id_;
-};
+class ClusterConfigInfo : public SingletonMetadataCowWrapper<PersistentClusterConfigInfo> {};
 
 struct PersistentRedisConfigInfo
     : public Persistent<SysRedisConfigEntryPB, SysRowEntryType::REDIS_CONFIG> {};
@@ -1184,23 +1089,6 @@ struct SplitTabletIds {
   }
 };
 
-struct PersistentXClusterSafeTimeInfo
-    : public Persistent<XClusterSafeTimePB, SysRowEntryType::XCLUSTER_SAFE_TIME> {};
-
-class XClusterSafeTimeInfo : public MetadataCowWrapper<PersistentXClusterSafeTimeInfo> {
- public:
-  XClusterSafeTimeInfo() {}
-  ~XClusterSafeTimeInfo() = default;
-
-  virtual const std::string& id() const override { return fake_id_; }
-
-  void Clear();
-
- private:
-  // This is a singleton, so We do not use the ID field.
-  const std::string fake_id_;
-};
-
 // This wraps around the proto containing CDC stream information. It will be used for
 // CowObject managed access.
 struct PersistentCDCStreamInfo : public Persistent<
diff --git a/src/yb/master/catalog_loaders.cc b/src/yb/master/catalog_loaders.cc
index 6f64e33a0b..d9ead4b48f 100644
--- a/src/yb/master/catalog_loaders.cc
+++ b/src/yb/master/catalog_loaders.cc
@@ -36,7 +36,6 @@
 #include "yb/common/constants.h"
 #include "yb/master/async_rpc_tasks.h"
 #include "yb/master/master_util.h"
-#include "yb/master/xcluster/xcluster_manager.h"
 #include "yb/master/ysql_tablegroup_manager.h"
 #include "yb/master/ysql_transaction_ddl.h"
 
@@ -574,17 +573,6 @@ Status ClusterConfigLoader::Visit(
   return Status::OK();
 }
 
-////////////////////////////////////////////////////////////
-// XCluster Config Loader
-////////////////////////////////////////////////////////////
-
-Status XClusterConfigLoader::Visit(
-    const std::string& unused_id, const SysXClusterConfigEntryPB& metadata) {
-  catalog_manager_->GetXClusterManager()->LoadXClusterConfig(metadata);
-
-  return Status::OK();
-}
-
 ////////////////////////////////////////////////////////////
 // Redis Config Loader
 ////////////////////////////////////////////////////////////
@@ -653,23 +641,5 @@ Status SysConfigLoader::Visit(const string& config_type, const SysConfigEntryPB&
   return Status::OK();
 }
 
-////////////////////////////////////////////////////////////
-// XClusterSafeTime Loader
-////////////////////////////////////////////////////////////
-
-Status XClusterSafeTimeLoader::Visit(
-    const std::string& unused_id, const XClusterSafeTimePB& metadata) {
-  // Debug confirm that there is no xcluster_safe_time_info_ set. This also ensures that this does
-  // not visit multiple rows.
-  auto l = catalog_manager_->xcluster_safe_time_info_.LockForWrite();
-  DCHECK(l->pb.safe_time_map().empty()) << "Already have XCluster Safe Time data!";
-
-  VLOG_WITH_FUNC(2) << "Loading XCluster Safe Time data: " << metadata.DebugString();
-  l.mutable_data()->pb.CopyFrom(metadata);
-  l.Commit();
-
-  return Status::OK();
-}
-
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/catalog_loaders.h b/src/yb/master/catalog_loaders.h
index ca52bb575a..56252708fe 100644
--- a/src/yb/master/catalog_loaders.h
+++ b/src/yb/master/catalog_loaders.h
@@ -106,14 +106,11 @@ DECLARE_LOADER_CLASS(Tablet,        TabletId,    SysTabletsEntryPB,       catalo
 DECLARE_LOADER_CLASS(Namespace,     NamespaceId, SysNamespaceEntryPB,     catalog_manager_->mutex_);
 DECLARE_LOADER_CLASS(UDType,        UDTypeId,    SysUDTypeEntryPB,        catalog_manager_->mutex_);
 DECLARE_LOADER_CLASS(ClusterConfig, std::string, SysClusterConfigEntryPB, catalog_manager_->mutex_);
-DECLARE_LOADER_CLASS(
-    XClusterConfig, std::string, SysXClusterConfigEntryPB, catalog_manager_->mutex_);
 DECLARE_LOADER_CLASS(RedisConfig,   std::string, SysRedisConfigEntryPB,   catalog_manager_->mutex_);
 DECLARE_LOADER_CLASS(Role,       RoleName,    SysRoleEntryPB,
     catalog_manager_->permissions_manager()->mutex());
 DECLARE_LOADER_CLASS(SysConfig,     std::string, SysConfigEntryPB,
     catalog_manager_->permissions_manager()->mutex());
-DECLARE_LOADER_CLASS(XClusterSafeTime, std::string, XClusterSafeTimePB, catalog_manager_->mutex_);
 
 #undef DECLARE_LOADER_CLASS
 
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 09fdbe8758..9945f0e6a2 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -1066,6 +1066,10 @@ Status CatalogManager::Init() {
   return Status::OK();
 }
 
+XClusterManagerIf* CatalogManager::GetXClusterManager() {
+  return xcluster_manager_.get();
+}
+
 Status CatalogManager::ElectedAsLeaderCb() {
   time_elected_leader_.store(MonoTime::Now());
   return leader_initialization_pool_->SubmitClosure(
@@ -1432,8 +1436,6 @@ Status CatalogManager::RunLoaders(SysCatalogLoadingState* state) {
 
   ClearXReplState();
 
-  xcluster_safe_time_info_.Clear();
-
   std::vector<std::shared_ptr<TSDescriptor>> descs;
   master_->ts_manager()->GetAllDescriptors(&descs);
   for (const auto& ts_desc : descs) {
@@ -1457,8 +1459,6 @@ Status CatalogManager::RunLoaders(SysCatalogLoadingState* state) {
   RETURN_NOT_OK(Load<UDTypeLoader>("user-defined types", state));
   RETURN_NOT_OK(Load<ClusterConfigLoader>("cluster configuration", state));
   RETURN_NOT_OK(Load<RedisConfigLoader>("Redis config", state));
-  RETURN_NOT_OK(Load<XClusterSafeTimeLoader>("XCluster safe time", state));
-  RETURN_NOT_OK(Load<XClusterConfigLoader>("xcluster configuration", state));
 
   if (!transaction_tables_config_) {
     RETURN_NOT_OK(InitializeTransactionTablesConfig(state->epoch.leader_term));
@@ -1476,6 +1476,8 @@ Status CatalogManager::RunLoaders(SysCatalogLoadingState* state) {
   RETURN_NOT_OK(LoadUniverseReplication());
   RETURN_NOT_OK(LoadUniverseReplicationBootstrap());
 
+  RETURN_NOT_OK(xcluster_manager_->RunLoaders());
+
   return Status::OK();
 }
 
@@ -12058,14 +12060,9 @@ void CatalogManager::DumpState(std::ostream* out, bool on_disk_dump) const {
       auto l = cluster_config->LockForRead();
       *out << "Cluster config: " << l->pb.ShortDebugString() << "\n";
     }
-
-    {
-      auto l = xcluster_safe_time_info_.LockForRead();
-      if (!l->pb.safe_time_map().empty()) {
-        *out << "XCluster Safe Time: " << l->pb.ShortDebugString() << "\n";
-      }
-    }
   }
+
+  xcluster_manager_->DumpState(out, on_disk_dump);
 }
 
 Status CatalogManager::PeerStateDump(const vector<RaftPeerPB>& peers,
@@ -13090,49 +13087,6 @@ Result<std::optional<cdc::ConsumerRegistryPB>> CatalogManager::GetConsumerRegist
   return std::nullopt;
 }
 
-Result<XClusterNamespaceToSafeTimeMap> CatalogManager::GetXClusterNamespaceToSafeTimeMap() {
-  google::protobuf::Map<std::string, google::protobuf::uint64> map_pb;
-
-  {
-    auto l = xcluster_safe_time_info_.LockForRead();
-    map_pb = l->pb.safe_time_map();
-  }
-
-  XClusterNamespaceToSafeTimeMap result;
-  for (auto& entry : map_pb) {
-    result[entry.first] = HybridTime(entry.second);
-  }
-  return result;
-}
-
-Result<HybridTime> CatalogManager::GetXClusterSafeTime(const NamespaceId& namespace_id) const {
-  auto l = xcluster_safe_time_info_.LockForRead();
-  SCHECK(
-      l->pb.safe_time_map().count(namespace_id), NotFound,
-      "XCluster safe time not found for namspace $0", namespace_id);
-
-  return HybridTime(l->pb.safe_time_map().at(namespace_id));
-}
-
-Status CatalogManager::SetXClusterNamespaceToSafeTimeMap(
-    const int64_t leader_term, const XClusterNamespaceToSafeTimeMap& safe_time_map) {
-  google::protobuf::Map<std::string, google::protobuf::uint64> map_pb;
-  for (auto& entry : safe_time_map) {
-    map_pb[entry.first] = entry.second.ToUint64();
-  }
-
-  auto l = xcluster_safe_time_info_.LockForWrite();
-  *l.mutable_data()->pb.mutable_safe_time_map() = std::move(map_pb);
-
-  RETURN_NOT_OK_PREPEND(
-      sys_catalog_->Upsert(leader_term, &xcluster_safe_time_info_),
-      "Updating XCluster safe time in sys-catalog");
-
-  l.Commit();
-
-  return Status::OK();
-}
-
 AsyncTaskThrottlerBase* CatalogManager::GetDeleteReplicaTaskThrottler(
     const string& ts_uuid) {
 
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index 9e9acb05d0..a6340c659f 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -57,7 +57,6 @@
 #include "yb/gutil/strings/substitute.h"
 #include "yb/gutil/thread_annotations.h"
 
-#include "yb/master/catalog_entity_info.h"
 #include "yb/master/catalog_manager_if.h"
 #include "yb/master/catalog_manager_util.h"
 #include "yb/master/cdc_split_driver.h"
@@ -144,7 +143,6 @@ namespace master {
 struct DeferredAssignmentActions;
 struct SysCatalogLoadingState;
 struct KeyRange;
-class XClusterManager;
 
 using PlacementId = std::string;
 
@@ -159,9 +157,6 @@ typedef std::unordered_map<TableId, boost::optional<TablespaceId>> TableToTables
 
 typedef std::unordered_map<TableId, std::vector<scoped_refptr<TabletInfo>>> TableToTabletInfos;
 
-// Map[NamespaceId]:xClusterSafeTime
-typedef std::unordered_map<NamespaceId, HybridTime> XClusterNamespaceToSafeTimeMap;
-
 typedef std::unordered_map<TableId, xrepl::StreamId> TableBootstrapIdsMap;
 
 constexpr int32_t kInvalidClusterConfigVersion = 0;
@@ -681,7 +676,8 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
 
   TabletSplitManager* tablet_split_manager() override { return &tablet_split_manager_; }
 
-  XClusterManager* GetXClusterManager() override { return xcluster_manager_.get(); }
+  XClusterManagerIf* GetXClusterManager() override;
+  XClusterManager* GetXClusterManagerImpl() override { return xcluster_manager_.get(); }
 
   // Dump all of the current state about tables and tablets to the
   // given output stream. This is verbose, meant for debugging.
@@ -1118,10 +1114,6 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
       const scoped_refptr<TableInfo>& table) REQUIRES_SHARED(mutex_);
 
   Result<std::optional<cdc::ConsumerRegistryPB>> GetConsumerRegistry();
-  Result<XClusterNamespaceToSafeTimeMap> GetXClusterNamespaceToSafeTimeMap();
-  Result<HybridTime> GetXClusterSafeTime(const NamespaceId& namespace_id) const;
-  Status SetXClusterNamespaceToSafeTimeMap(
-      const int64_t leader_term, const XClusterNamespaceToSafeTimeMap& safe_time_map);
 
   Status SubmitToSysCatalog(std::unique_ptr<tablet::Operation> operation);
 
@@ -1477,13 +1469,11 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
   friend class RoleLoader;
   friend class RedisConfigLoader;
   friend class SysConfigLoader;
-  friend class XClusterSafeTimeLoader;
   friend class ::yb::master::ScopedLeaderSharedLock;
   friend class PermissionsManager;
   friend class MultiStageAlterTable;
   friend class BackfillTable;
   friend class BackfillTablet;
-  friend class XClusterConfigLoader;
   friend class YsqlBackendsManager;
   friend class BackendsCatalogVersionJob;
   friend class AddTableToXClusterTask;
@@ -2314,9 +2304,6 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
 
   std::unique_ptr<XClusterManager> xcluster_manager_;
 
-  // XCluster Safe Time information.
-  XClusterSafeTimeInfo xcluster_safe_time_info_;
-
   void StartElectionIfReady(
       const consensus::ConsensusStatePB& cstate, const LeaderEpoch& epoch, TabletInfo* tablet);
 
diff --git a/src/yb/master/catalog_manager_if.h b/src/yb/master/catalog_manager_if.h
index 710b822e46..181155fd04 100644
--- a/src/yb/master/catalog_manager_if.h
+++ b/src/yb/master/catalog_manager_if.h
@@ -278,7 +278,9 @@ class CatalogManagerIf {
 
   virtual TabletSplitManager* tablet_split_manager() = 0;
 
-  virtual XClusterManager* GetXClusterManager() = 0;
+  virtual XClusterManagerIf* GetXClusterManager() = 0;
+
+  virtual XClusterManager* GetXClusterManagerImpl() = 0;
 
   virtual std::shared_ptr<tablet::TabletPeer> tablet_peer() const = 0;
 
diff --git a/src/yb/master/master-path-handlers.cc b/src/yb/master/master-path-handlers.cc
index 8ded2ae5d0..666da3a3a9 100644
--- a/src/yb/master/master-path-handlers.cc
+++ b/src/yb/master/master-path-handlers.cc
@@ -72,7 +72,7 @@
 #include "yb/master/ts_descriptor.h"
 #include "yb/master/ts_manager.h"
 
-#include "yb/master/xcluster/xcluster_manager.h"
+#include "yb/master/xcluster/xcluster_manager_if.h"
 #include "yb/server/webserver.h"
 #include "yb/server/webui_util.h"
 
@@ -2852,8 +2852,7 @@ void MasterPathHandlers::HandleGetClusterConfigJSON(
 
 Status MasterPathHandlers::GetClusterAndXClusterConfigStatus(
     SysXClusterConfigEntryPB* xcluster_config, SysClusterConfigEntryPB* cluster_config) {
-  RETURN_NOT_OK(
-      master_->catalog_manager()->GetXClusterManager()->GetXClusterConfigEntryPB(xcluster_config));
+  RETURN_NOT_OK(master_->xcluster_manager()->GetXClusterConfigEntryPB(xcluster_config));
   return master_->catalog_manager()->GetClusterConfig(cluster_config);
 }
 
diff --git a/src/yb/master/master.cc b/src/yb/master/master.cc
index 7f03afdeb7..ce368fc59f 100644
--- a/src/yb/master/master.cc
+++ b/src/yb/master/master.cc
@@ -607,6 +607,14 @@ CatalogManagerIf* Master::catalog_manager() const {
   return catalog_manager_.get();
 }
 
+XClusterManagerIf* Master::xcluster_manager() const {
+  return catalog_manager_->GetXClusterManager();
+}
+
+XClusterManager* Master::xcluster_manager_impl() const {
+  return catalog_manager_->GetXClusterManagerImpl();
+}
+
 SysCatalogTable& Master::sys_catalog() const {
   return *catalog_manager_->sys_catalog();
 }
diff --git a/src/yb/master/master.h b/src/yb/master/master.h
index b2e8213c4f..34d1147302 100644
--- a/src/yb/master/master.h
+++ b/src/yb/master/master.h
@@ -105,6 +105,10 @@ class Master : public tserver::DbServerBase {
 
   CatalogManager* catalog_manager_impl() const { return catalog_manager_.get(); }
 
+  XClusterManagerIf* xcluster_manager() const;
+
+  XClusterManager* xcluster_manager_impl() const;
+
   FlushManager* flush_manager() const { return flush_manager_.get(); }
 
   TestAsyncRpcManager* test_async_rpc_manager() const { return test_async_rpc_manager_.get(); }
diff --git a/src/yb/master/master_fwd.h b/src/yb/master/master_fwd.h
index 82f7cbcb35..3bc72ca5ba 100644
--- a/src/yb/master/master_fwd.h
+++ b/src/yb/master/master_fwd.h
@@ -85,6 +85,7 @@ class TSDescriptor;
 class TSManager;
 class UDTypeInfo;
 class XClusterManager;
+class XClusterManagerIf;
 class YQLPartitionsVTable;
 class YQLVirtualTable;
 class YsqlBackendsManager;
diff --git a/src/yb/master/master_service_base.cc b/src/yb/master/master_service_base.cc
index acbf14836d..2a99d0025b 100644
--- a/src/yb/master/master_service_base.cc
+++ b/src/yb/master/master_service_base.cc
@@ -42,7 +42,7 @@ EncryptionManager* MasterServiceBase::handler(EncryptionManager*) {
 }
 
 XClusterManager* MasterServiceBase::handler(XClusterManager*) {
-  return server_->catalog_manager()->GetXClusterManager();
+  return server_->xcluster_manager_impl();
 }
 
 TestAsyncRpcManager* MasterServiceBase::handler(TestAsyncRpcManager*) {
diff --git a/src/yb/master/xcluster/add_table_to_xcluster_task.cc b/src/yb/master/xcluster/add_table_to_xcluster_task.cc
index 2936f67e97..05528a9e8a 100644
--- a/src/yb/master/xcluster/add_table_to_xcluster_task.cc
+++ b/src/yb/master/xcluster/add_table_to_xcluster_task.cc
@@ -14,7 +14,7 @@
 #include "yb/master/xcluster/add_table_to_xcluster_task.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master.h"
-#include "yb/master/xcluster/xcluster_manager.h"
+#include "yb/master/xcluster/xcluster_manager_if.h"
 #include "yb/master/xcluster/xcluster_safe_time_service.h"
 #include "yb/rpc/messenger.h"
 #include "yb/util/source_location.h"
@@ -176,9 +176,8 @@ void AddTableToXClusterTask::RefreshAndGetXClusterSafeTime() {
   // replication.
   auto namespace_id = table_info_->namespace_id();
   auto initial_safe_time = VERIFY_RESULT_AND_FAIL_TASK(
-      catalog_manager_->GetXClusterManager()
-          ->xcluster_safe_time_service_->RefreshAndGetXClusterNamespaceToSafeTimeMap(
-              catalog_manager_->GetLeaderEpochInternal()));
+      catalog_manager_->GetXClusterManager()->RefreshAndGetXClusterNamespaceToSafeTimeMap(
+          catalog_manager_->GetLeaderEpochInternal()));
   if (!initial_safe_time.contains(namespace_id)) {
     // Namespace is no longer part of any xCluster replication.
     CompleteTableCreation();
@@ -196,7 +195,7 @@ void AddTableToXClusterTask::RefreshAndGetXClusterSafeTime() {
 void AddTableToXClusterTask::WaitForXClusterSafeTimeCaughtUp() {
   if (initial_xcluster_safe_time_.is_valid()) {
     auto ht = VERIFY_RESULT_AND_FAIL_TASK(
-        catalog_manager_->GetXClusterSafeTime(table_info_->namespace_id()));
+        catalog_manager_->GetXClusterManager()->GetXClusterSafeTime(table_info_->namespace_id()));
 
     auto caught_up = ht > initial_xcluster_safe_time_;
     if (!caught_up) {
diff --git a/src/yb/master/xcluster/xcluster_catalog_entity.cc b/src/yb/master/xcluster/xcluster_catalog_entity.cc
new file mode 100644
index 0000000000..00036f91c8
--- /dev/null
+++ b/src/yb/master/xcluster/xcluster_catalog_entity.cc
@@ -0,0 +1,25 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/master/xcluster/xcluster_catalog_entity.h"
+
+namespace yb::master {
+
+void XClusterSafeTimeInfo::Load(const XClusterSafeTimePB& metadata) {
+  // Debug confirm that there is no xcluster_safe_time_info_ set. This also ensures that this does
+  // not visit multiple rows.
+  DCHECK(LockForRead()->pb.safe_time_map().empty()) << "Already have XCluster Safe Time data!";
+
+  MetadataCowWrapper<PersistentXClusterSafeTimeInfo>::Load(metadata);
+}
+}  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_catalog_entity.h b/src/yb/master/xcluster/xcluster_catalog_entity.h
new file mode 100644
index 0000000000..a974f3f348
--- /dev/null
+++ b/src/yb/master/xcluster/xcluster_catalog_entity.h
@@ -0,0 +1,56 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include <string>
+#include "yb/master/catalog_entity_info.pb.h"
+#include "yb/master/catalog_entity_base.h"
+#include "yb/master/sys_catalog.h"
+
+#define DECLARE_LOADER_CLASS(name, key_type, entry_pb_name) \
+  template <typename CatalogEntityWrapper> \
+  class BOOST_PP_CAT(name, Loader) \
+      : public Visitor<BOOST_PP_CAT(BOOST_PP_CAT(Persistent, name), Info)> { \
+   public: \
+    explicit BOOST_PP_CAT(name, Loader)(CatalogEntityWrapper& catalog_entity_wrapper) \
+        : catalog_entity_wrapper_(catalog_entity_wrapper) {} \
+   private: \
+    Status Visit(const key_type& key, const entry_pb_name& metadata) override { \
+      catalog_entity_wrapper_.Load(metadata); \
+      return Status::OK(); \
+    } \
+    CatalogEntityWrapper& catalog_entity_wrapper_; \
+    DISALLOW_COPY_AND_ASSIGN(BOOST_PP_CAT(name, Loader)); \
+  };
+
+namespace yb::master {
+
+struct PersistentXClusterConfigInfo
+    : public Persistent<SysXClusterConfigEntryPB, SysRowEntryType::XCLUSTER_CONFIG> {};
+
+class XClusterConfigInfo : public SingletonMetadataCowWrapper<PersistentXClusterConfigInfo> {};
+
+DECLARE_LOADER_CLASS(XClusterConfig, std::string, SysXClusterConfigEntryPB);
+
+struct PersistentXClusterSafeTimeInfo
+    : public Persistent<XClusterSafeTimePB, SysRowEntryType::XCLUSTER_SAFE_TIME> {};
+
+class XClusterSafeTimeInfo : public SingletonMetadataCowWrapper<PersistentXClusterSafeTimeInfo> {
+ public:
+  void Load(const XClusterSafeTimePB& metadata) override;
+};
+
+DECLARE_LOADER_CLASS(XClusterSafeTime, std::string, XClusterSafeTimePB);
+
+}  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_config.cc b/src/yb/master/xcluster/xcluster_config.cc
index 1dfa9004ca..89908c88b1 100644
--- a/src/yb/master/xcluster/xcluster_config.cc
+++ b/src/yb/master/xcluster/xcluster_config.cc
@@ -13,11 +13,14 @@
 
 #include "yb/master/xcluster/xcluster_config.h"
 
+// TODO: Remove once CDCStreamInfo has moved to xcluster_catalog_entity.h.
 #include "yb/master/catalog_entity_info.h"
+
 #include "yb/master/catalog_entity_info.pb.h"
 #include "yb/master/catalog_manager-internal.h"
 #include "yb/master/master_heartbeat.pb.h"
 #include "yb/master/sys_catalog.h"
+#include "yb/master/xcluster/xcluster_catalog_entity.h"
 
 namespace yb::master {
 
@@ -32,12 +35,8 @@ void XClusterConfig::Load(const SysXClusterConfigEntryPB& metadata) {
   std::lock_guard mutex_lock(mutex_);
   DCHECK(!xcluster_config_info_) << "Already have xCluster config data!";
 
-  auto config = std::make_shared<XClusterConfigInfo>();
-  auto l = config->LockForWrite();
-  l.mutable_data()->pb.CopyFrom(metadata);
-  l.Commit();
-
-  xcluster_config_info_ = std::move(config);
+  xcluster_config_info_ = std::make_unique<XClusterConfigInfo>();
+  xcluster_config_info_->Load(metadata);
 }
 
 Status XClusterConfig::PrepareDefault(int64_t term, bool re_create) {
@@ -47,14 +46,13 @@ Status XClusterConfig::PrepareDefault(int64_t term, bool re_create) {
     LOG(INFO) << "Cluster configuration has already been set up, skipping re-initialization.";
     return Status::OK();
   }
-  xcluster_config_info_.reset();
 
   // Create default.
   SysXClusterConfigEntryPB config;
   config.set_version(0);
 
   // Create in memory object.
-  xcluster_config_info_ = std::make_shared<XClusterConfigInfo>();
+  xcluster_config_info_ = std::make_unique<XClusterConfigInfo>();
 
   // Prepare write.
   auto l = xcluster_config_info_->LockForWrite();
@@ -73,6 +71,16 @@ Result<uint32_t> XClusterConfig::GetVersion() const {
   return xcluster_config_info_->LockForRead()->pb.version();
 }
 
+void XClusterConfig::DumpState(std::ostream* out) const {
+  SharedLock mutex_lock(mutex_);
+  if (!xcluster_config_info_) {
+    return;
+  }
+
+  auto l = xcluster_config_info_->LockForRead();
+  *out << "XCluster Config: " << l->pb.ShortDebugString() << "\n";
+}
+
 Result<SysXClusterConfigEntryPB> XClusterConfig::GetXClusterConfigEntryPB() const {
   SharedLock mutex_lock(mutex_);
   SCHECK(xcluster_config_info_, IllegalState, "XCluster config is not initialized");
diff --git a/src/yb/master/xcluster/xcluster_config.h b/src/yb/master/xcluster/xcluster_config.h
index cd433c27ac..e1131079a7 100644
--- a/src/yb/master/xcluster/xcluster_config.h
+++ b/src/yb/master/xcluster/xcluster_config.h
@@ -47,6 +47,8 @@ class XClusterConfig {
 
   Result<uint32_t> GetVersion() const EXCLUDES(mutex_);
 
+  void DumpState(std::ostream* out) const EXCLUDES(mutex_);
+
   Result<SysXClusterConfigEntryPB> GetXClusterConfigEntryPB() const EXCLUDES(mutex_);
 
   Status FillHeartbeatResponse(const TSHeartbeatRequestPB& req, TSHeartbeatResponsePB* resp) const
@@ -66,7 +68,7 @@ class XClusterConfig {
 
   mutable std::shared_mutex mutex_;
 
-  std::shared_ptr<XClusterConfigInfo> xcluster_config_info_ GUARDED_BY(mutex_);
+  std::unique_ptr<XClusterConfigInfo> xcluster_config_info_ GUARDED_BY(mutex_);
 };
 
 }  // namespace master
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index 76029e0097..f2ae20712a 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -15,16 +15,17 @@
 
 #include <string>
 
+#include "yb/common/hybrid_time.h"
 #include "yb/consensus/consensus_util.h"
-#include "yb/master/catalog_entity_info.h"
-#include "yb/master/catalog_manager-internal.h"
-#include "yb/master/catalog_manager.h"
+
 #include "yb/master/master.h"
 #include "yb/master/master_cluster.pb.h"
 #include "yb/master/xcluster/xcluster_config.h"
 #include "yb/master/xcluster/xcluster_safe_time_service.h"
+
 #include "yb/rpc/rpc_context.h"
 #include "yb/tablet/tablet_peer.h"
+
 #include "yb/util/logging.h"
 #include "yb/util/result.h"
 
@@ -44,8 +45,6 @@ void XClusterManager::Shutdown() {
   }
 }
 
-void XClusterManager::ClearState() { xcluster_config_->ClearState(); }
-
 Status XClusterManager::Init() {
   DCHECK(!xcluster_safe_time_service_);
   xcluster_safe_time_service_ = std::make_unique<XClusterSafeTimeService>(
@@ -55,45 +54,112 @@ Status XClusterManager::Init() {
   return Status::OK();
 }
 
-void XClusterManager::LoadXClusterConfig(const SysXClusterConfigEntryPB& metadata) {
-  xcluster_config_->Load(metadata);
+Status XClusterManager::RunLoaders() {
+  xcluster_config_->ClearState();
+  xcluster_safe_time_info_.Clear();
+
+  RETURN_NOT_OK(Load<XClusterConfigLoader>("XCluster safe time", *xcluster_config_));
+  RETURN_NOT_OK(Load<XClusterSafeTimeLoader>("xcluster configuration", xcluster_safe_time_info_));
+
+  return Status::OK();
+}
+
+template <template <class> class Loader, typename CatalogEntityWrapper>
+Status XClusterManager::Load(
+    const std::string& title, CatalogEntityWrapper& catalog_entity_wrapper) {
+  Loader<CatalogEntityWrapper> loader(catalog_entity_wrapper);
+  LOG_WITH_FUNC(INFO) << __func__ << ": Loading " << title << " into memory.";
+  RETURN_NOT_OK_PREPEND(
+      sys_catalog_->Visit(&loader), "Failed while visiting " + title + " in sys catalog");
+  return Status::OK();
 }
 
 void XClusterManager::SysCatalogLoaded(const SysCatalogLoadingState& state) {
   xcluster_safe_time_service_->ScheduleTaskIfNeeded();
 }
 
-void XClusterManager::CreateXClusterSafeTimeTableAndStartService() {
-  auto status = xcluster_safe_time_service_->CreateXClusterSafeTimeTableIfNotFound();
-  if (!status.ok()) {
-    LOG(WARNING) << "Creation of XClusterSafeTime table failed :" << status;
+void XClusterManager::DumpState(std::ostream* out, bool on_disk_dump) const {
+  if (on_disk_dump) {
+    auto l = xcluster_safe_time_info_.LockForRead();
+    if (!l->pb.safe_time_map().empty()) {
+      *out << "XCluster Safe Time: " << l->pb.ShortDebugString() << "\n";
+    }
+
+    xcluster_config_->DumpState(out);
+  }
+}
+
+Result<XClusterNamespaceToSafeTimeMap> XClusterManager::GetXClusterNamespaceToSafeTimeMap() const {
+  XClusterNamespaceToSafeTimeMap result;
+  auto l = xcluster_safe_time_info_.LockForRead();
+
+  for (auto& [namespace_id, hybrid_time] : l->pb.safe_time_map()) {
+    result[namespace_id] = HybridTime(hybrid_time);
+  }
+  return result;
+}
+
+Status XClusterManager::SetXClusterNamespaceToSafeTimeMap(
+    const int64_t leader_term, const XClusterNamespaceToSafeTimeMap& safe_time_map) {
+  auto l = xcluster_safe_time_info_.LockForWrite();
+  auto& safe_time_map_pb = *l.mutable_data()->pb.mutable_safe_time_map();
+  safe_time_map_pb.clear();
+  for (auto& [namespace_id, hybrid_time] : safe_time_map) {
+    safe_time_map_pb[namespace_id] = hybrid_time.ToUint64();
   }
 
+  RETURN_NOT_OK_PREPEND(
+      sys_catalog_->Upsert(leader_term, &xcluster_safe_time_info_),
+      "Updating XCluster safe time in sys-catalog");
+
+  l.Commit();
+
+  return Status::OK();
+}
+
+Result<HybridTime> XClusterManager::GetXClusterSafeTime(const NamespaceId& namespace_id) const {
+  auto l = xcluster_safe_time_info_.LockForRead();
+  SCHECK(
+      l->pb.safe_time_map().count(namespace_id), NotFound,
+      "XCluster safe time not found for namespace $0", namespace_id);
+
+  return HybridTime(l->pb.safe_time_map().at(namespace_id));
+}
+
+void XClusterManager::CreateXClusterSafeTimeTableAndStartService() {
+  WARN_NOT_OK(
+      xcluster_safe_time_service_->CreateXClusterSafeTimeTableIfNotFound(),
+      "Creation of XClusterSafeTime table failed");
+
   xcluster_safe_time_service_->ScheduleTaskIfNeeded();
 }
 
 Status XClusterManager::GetXClusterSafeTime(
     const GetXClusterSafeTimeRequestPB* req, GetXClusterSafeTimeResponsePB* resp,
     rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
-  const auto status = xcluster_safe_time_service_->GetXClusterSafeTimeInfoFromMap(epoch, resp);
-  if (!status.ok()) {
-    return SetupError(resp->mutable_error(), MasterErrorPB::INTERNAL_ERROR, status);
-  }
+  RETURN_NOT_OK_SET_CODE(
+      xcluster_safe_time_service_->GetXClusterSafeTimeInfoFromMap(epoch, resp),
+      MasterError(MasterErrorPB::INTERNAL_ERROR));
 
   // Also fill out the namespace_name for each entry.
   if (resp->namespace_safe_times_size()) {
     for (auto& safe_time_info : *resp->mutable_namespace_safe_times()) {
-      const auto result = catalog_manager_->FindNamespaceById(safe_time_info.namespace_id());
-      if (!result) {
-        return SetupError(resp->mutable_error(), MasterErrorPB::INTERNAL_ERROR, result.status());
-      }
-      safe_time_info.set_namespace_name(result.get()->name());
+      const auto namespace_info = VERIFY_RESULT_OR_SET_CODE(
+          catalog_manager_->FindNamespaceById(safe_time_info.namespace_id()),
+          MasterError(MasterErrorPB::INTERNAL_ERROR));
+
+      safe_time_info.set_namespace_name(namespace_info->name());
     }
   }
 
   return Status::OK();
 }
 
+Result<XClusterNamespaceToSafeTimeMap> XClusterManager::RefreshAndGetXClusterNamespaceToSafeTimeMap(
+    const LeaderEpoch& epoch) {
+  return xcluster_safe_time_service_->RefreshAndGetXClusterNamespaceToSafeTimeMap(epoch);
+}
+
 Status XClusterManager::PrepareDefaultXClusterConfig(int64_t term, bool recreate) {
   return xcluster_config_->PrepareDefault(term, recreate);
 }
@@ -113,6 +179,13 @@ Result<uint32_t> XClusterManager::GetXClusterConfigVersion() const {
 
 Status XClusterManager::FillHeartbeatResponse(
     const TSHeartbeatRequestPB& req, TSHeartbeatResponsePB* resp) const {
+  {
+    auto l = xcluster_safe_time_info_.LockForRead();
+    if (!l->pb.safe_time_map().empty()) {
+      *resp->mutable_xcluster_namespace_to_safe_time() = l->pb.safe_time_map();
+    }
+  }
+
   return xcluster_config_->FillHeartbeatResponse(req, resp);
 }
 
diff --git a/src/yb/master/xcluster/xcluster_manager.h b/src/yb/master/xcluster/xcluster_manager.h
index bf10dc9655..f75252449d 100644
--- a/src/yb/master/xcluster/xcluster_manager.h
+++ b/src/yb/master/xcluster/xcluster_manager.h
@@ -17,40 +17,29 @@
 #include <shared_mutex>
 #include <vector>
 
+#include "yb/common/entity_ids_types.h"
 #include "yb/gutil/thread_annotations.h"
-#include "yb/master/leader_epoch.h"
-#include "yb/util/status_fwd.h"
 
-namespace yb {
-
-namespace rpc {
+#include "yb/master/xcluster/xcluster_catalog_entity.h"
+#include "yb/master/xcluster/xcluster_manager_if.h"
 
-class RpcContext;
-
-}  // namespace rpc
+namespace yb {
 
 namespace master {
-
-class CatalogManager;
-class Master;
-class SysCatalogTable;
-class XClusterConfig;
-class XClusterSafeTimeService;
 class CDCStreamInfo;
-class GetXClusterSafeTimeRequestPB;
-class GetXClusterSafeTimeResponsePB;
-class SysXClusterConfigEntryPB;
-class TSHeartbeatRequestPB;
-class TSHeartbeatResponsePB;
 class GetMasterXClusterConfigResponsePB;
 class PauseResumeXClusterProducerStreamsRequestPB;
 class PauseResumeXClusterProducerStreamsResponsePB;
+class TSHeartbeatRequestPB;
+class TSHeartbeatResponsePB;
+class XClusterConfig;
+class XClusterSafeTimeService;
 struct SysCatalogLoadingState;
 
 // The XClusterManager class is responsible for managing all yb-master related control logic of
 // XCluster. All XCluster related RPCs and APIs are handled by this class.
-// TODO(#19353): Move XCluster related code from CatalogManager to this class.
-class XClusterManager {
+// TODO(#19714): Move XCluster related code from CatalogManager to this class.
+class XClusterManager : public XClusterManagerIf {
  public:
   explicit XClusterManager(
       Master* master, CatalogManager* catalog_manager, SysCatalogTable* sys_catalog);
@@ -61,21 +50,13 @@ class XClusterManager {
 
   void Shutdown();
 
-  void ClearState();
-
-  void LoadXClusterConfig(const SysXClusterConfigEntryPB& metadata);
+  Status RunLoaders();
 
   void SysCatalogLoaded(const SysCatalogLoadingState& state);
 
-  XClusterSafeTimeService* TEST_xcluster_safe_time_service() {
-    return xcluster_safe_time_service_.get();
-  }
-
-  Status GetXClusterSafeTime(
-      const GetXClusterSafeTimeRequestPB* req, GetXClusterSafeTimeResponsePB* resp,
-      rpc::RpcContext* rpc, const LeaderEpoch& epoch);
+  void DumpState(std::ostream* out, bool on_disk_dump = false) const;
 
-  Status GetXClusterConfigEntryPB(SysXClusterConfigEntryPB* config) const EXCLUDES(mutex_);
+  Status GetXClusterConfigEntryPB(SysXClusterConfigEntryPB* config) const EXCLUDES(mutex_) override;
 
   Status GetMasterXClusterConfig(GetMasterXClusterConfigResponsePB* resp) EXCLUDES(mutex_);
 
@@ -96,8 +77,25 @@ class XClusterManager {
       PauseResumeXClusterProducerStreamsResponsePB* resp, rpc::RpcContext* rpc,
       const LeaderEpoch& epoch);
 
+  // XCluster Safe Time.
+  Result<XClusterNamespaceToSafeTimeMap> GetXClusterNamespaceToSafeTimeMap() const override;
+  Status SetXClusterNamespaceToSafeTimeMap(
+      const int64_t leader_term, const XClusterNamespaceToSafeTimeMap& safe_time_map) override;
+  Status GetXClusterSafeTime(
+      const GetXClusterSafeTimeRequestPB* req, GetXClusterSafeTimeResponsePB* resp,
+      rpc::RpcContext* rpc, const LeaderEpoch& epoch);
+  Result<HybridTime> GetXClusterSafeTime(const NamespaceId& namespace_id) const override;
+
+  Result<XClusterNamespaceToSafeTimeMap> RefreshAndGetXClusterNamespaceToSafeTimeMap(
+      const LeaderEpoch& epoch) override;
+
+  XClusterSafeTimeService* TEST_xcluster_safe_time_service() {
+    return xcluster_safe_time_service_.get();
+  }
+
  private:
-  friend class AddTableToXClusterTask;
+  template <template <class> class Loader, typename CatalogEntityWrapper>
+  Status Load(const std::string& title, CatalogEntityWrapper& catalog_entity_wrapper);
 
   Master* const master_;
   CatalogManager* const catalog_manager_;
@@ -108,6 +106,10 @@ class XClusterManager {
   std::unique_ptr<XClusterConfig> xcluster_config_;
 
   std::unique_ptr<XClusterSafeTimeService> xcluster_safe_time_service_;
+
+  // The Catalog Entity is stored outside of XClusterSafeTimeService, since we may want to move the
+  // service out of master at a later time.
+  XClusterSafeTimeInfo xcluster_safe_time_info_;
 };
 
 }  // namespace master
diff --git a/src/yb/master/xcluster/xcluster_manager_if.h b/src/yb/master/xcluster/xcluster_manager_if.h
new file mode 100644
index 0000000000..9ccaf8b88a
--- /dev/null
+++ b/src/yb/master/xcluster/xcluster_manager_if.h
@@ -0,0 +1,55 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include <memory>
+
+#include "yb/master/master_fwd.h"
+#include "yb/util/status_fwd.h"
+
+namespace yb {
+
+class HybridTime;
+
+namespace rpc {
+class RpcContext;
+}  // namespace rpc
+
+namespace master {
+
+class GetXClusterSafeTimeRequestPB;
+class GetXClusterSafeTimeResponsePB;
+class SysXClusterConfigEntryPB;
+struct LeaderEpoch;
+
+// Map[NamespaceId]:xClusterSafeTime
+typedef std::unordered_map<NamespaceId, HybridTime> XClusterNamespaceToSafeTimeMap;
+
+class XClusterManagerIf {
+ public:
+  virtual Result<HybridTime> GetXClusterSafeTime(const NamespaceId& namespace_id) const = 0;
+  virtual Result<XClusterNamespaceToSafeTimeMap> RefreshAndGetXClusterNamespaceToSafeTimeMap(
+      const LeaderEpoch& epoch) = 0;
+  virtual Result<XClusterNamespaceToSafeTimeMap> GetXClusterNamespaceToSafeTimeMap() const = 0;
+  virtual Status SetXClusterNamespaceToSafeTimeMap(
+      const int64_t leader_term, const XClusterNamespaceToSafeTimeMap& safe_time_map) = 0;
+
+  virtual Status GetXClusterConfigEntryPB(SysXClusterConfigEntryPB* config) const = 0;
+
+ protected:
+  virtual ~XClusterManagerIf() = default;
+};
+
+}  // namespace master
+}  // namespace yb
diff --git a/src/yb/master/xcluster/xcluster_safe_time_service.cc b/src/yb/master/xcluster/xcluster_safe_time_service.cc
index 2ce5a7bf3a..1283fe6720 100644
--- a/src/yb/master/xcluster/xcluster_safe_time_service.cc
+++ b/src/yb/master/xcluster/xcluster_safe_time_service.cc
@@ -25,6 +25,7 @@
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master_ddl.pb.h"
 #include "yb/master/master.h"
+#include "yb/master/xcluster/xcluster_manager_if.h"
 #include "yb/master/xcluster/xcluster_safe_time_service.h"
 
 #include "yb/util/atomic.h"
@@ -601,7 +602,7 @@ Result<bool> XClusterSafeTimeService::CreateTableRequired() {
 
 Result<XClusterNamespaceToSafeTimeMap>
 XClusterSafeTimeService::GetXClusterNamespaceToSafeTimeMap() {
-  return catalog_manager_->GetXClusterNamespaceToSafeTimeMap();
+  return master_->xcluster_manager()->GetXClusterNamespaceToSafeTimeMap();
 }
 
 Status XClusterSafeTimeService::SetXClusterSafeTime(
@@ -613,7 +614,8 @@ Status XClusterSafeTimeService::SetXClusterSafeTime(
     }
   }
 
-  return catalog_manager_->SetXClusterNamespaceToSafeTimeMap(leader_term, new_safe_time_map);
+  return master_->xcluster_manager()->SetXClusterNamespaceToSafeTimeMap(
+      leader_term, new_safe_time_map);
 }
 
 Status XClusterSafeTimeService::CleanupEntriesFromTable(
diff --git a/src/yb/master/xcluster/xcluster_safe_time_service.h b/src/yb/master/xcluster/xcluster_safe_time_service.h
index 08f090350f..9e0968b6ed 100644
--- a/src/yb/master/xcluster/xcluster_safe_time_service.h
+++ b/src/yb/master/xcluster/xcluster_safe_time_service.h
@@ -37,6 +37,7 @@
 #include "yb/common/hybrid_time.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/xcluster/xcluster_consumer_metrics.h"
+#include "yb/master/xcluster/xcluster_manager_if.h"
 #include "yb/rpc/scheduler.h"
 #include "yb/util/threadpool.h"
 #include "yb/gutil/thread_annotations.h"
diff --git a/src/yb/master/xrepl_catalog_manager.cc b/src/yb/master/xrepl_catalog_manager.cc
index 1ffd1bb4b7..0f588d1913 100644
--- a/src/yb/master/xrepl_catalog_manager.cc
+++ b/src/yb/master/xrepl_catalog_manager.cc
@@ -42,7 +42,6 @@
 #include "yb/master/master_util.h"
 #include "yb/master/scoped_leader_shared_lock-internal.h"
 #include "yb/master/snapshot_transfer_manager.h"
-#include "yb/master/sys_catalog-internal.h"
 #include "yb/master/xcluster/xcluster_safe_time_service.h"
 #include "yb/master/ysql_tablegroup_manager.h"
 
@@ -286,7 +285,6 @@ void CatalogManager::ClearXReplState() {
   // Clear CDC stream map.
   cdc_stream_map_.clear();
 
-  xcluster_manager_->ClearState();
   xcluster_producer_tables_to_stream_map_.clear();
 
   // Clear CDCSDK stream map.
@@ -6429,11 +6427,6 @@ Status CatalogManager::FillHeartbeatResponseCDC(
     resp->set_xcluster_enabled_on_producer(true);
   }
   if (cluster_config.has_consumer_registry()) {
-    {
-      auto l = xcluster_safe_time_info_.LockForRead();
-      *resp->mutable_xcluster_namespace_to_safe_time() = l->pb.safe_time_map();
-    }
-
     if (req->cluster_config_version() < cluster_config.version()) {
       const auto& consumer_registry = cluster_config.consumer_registry();
       resp->set_cluster_config_version(cluster_config.version());
