diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 5d645aeb20..e0dfe59c79 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -1492,7 +1492,7 @@ Status CatalogManager::RunLoaders(SysCatalogLoadingState* state) {
   RETURN_NOT_OK(LoadUniverseReplicationBootstrap());
 
   RETURN_NOT_OK(xcluster_manager_->RunLoaders(hidden_tablets_));
-  RETURN_NOT_OK(clone_state_manager_->ClearAndRunLoaders());
+  RETURN_NOT_OK(clone_state_manager_->ClearAndRunLoaders(state->epoch));
 
   return Status::OK();
 }
diff --git a/src/yb/master/clone/clone_state_entity.cc b/src/yb/master/clone/clone_state_entity.cc
index 946025c16f..fe5ea7713c 100644
--- a/src/yb/master/clone/clone_state_entity.cc
+++ b/src/yb/master/clone/clone_state_entity.cc
@@ -38,6 +38,16 @@ void CloneStateInfo::AddTabletData(TabletData tablet_data) {
   tablet_data_.push_back(std::move(tablet_data));
 }
 
+LeaderEpoch CloneStateInfo::Epoch() {
+  std::lock_guard l(mutex_);
+  return epoch_;
+}
+
+void CloneStateInfo::SetEpoch(const LeaderEpoch& epoch) {
+  std::lock_guard l(mutex_);
+  epoch_ = epoch;
+}
+
 YQLDatabase CloneStateInfo::DatabaseType() {
   std::lock_guard l(mutex_);
   return database_type_;
diff --git a/src/yb/master/clone/clone_state_entity.h b/src/yb/master/clone/clone_state_entity.h
index 7388d43367..c78833d381 100644
--- a/src/yb/master/clone/clone_state_entity.h
+++ b/src/yb/master/clone/clone_state_entity.h
@@ -21,9 +21,11 @@
 
 namespace yb::master {
 
-struct PersistentCloneStateInfo :
-    public Persistent<SysCloneStatePB, SysRowEntryType::CLONE_STATE> {
-  bool IsDone() const {
+struct PersistentCloneStateInfo : public Persistent<SysCloneStatePB, SysRowEntryType::CLONE_STATE>
+  {};
+
+struct CloneStateInfoHelpers {
+  static bool IsDone(const SysCloneStatePB& pb) {
     return pb.aggregate_state() == SysCloneStatePB::COMPLETE ||
            pb.aggregate_state() == SysCloneStatePB::ABORTED;
   }
@@ -48,6 +50,9 @@ class CloneStateInfo : public MetadataCowWrapper<PersistentCloneStateInfo> {
   YQLDatabase DatabaseType();
   void SetDatabaseType(YQLDatabase database_type);
 
+  LeaderEpoch Epoch();
+  void SetEpoch(const LeaderEpoch& epoch);
+
   const TxnSnapshotId& SourceSnapshotId();
   void SetSourceSnapshotId(const TxnSnapshotId& source_snapshot_id);
 
@@ -61,6 +66,7 @@ class CloneStateInfo : public MetadataCowWrapper<PersistentCloneStateInfo> {
   // The ID field is used in the sys_catalog table.
   const std::string clone_request_id_;
 
+  LeaderEpoch epoch_ GUARDED_BY(mutex_);
   YQLDatabase database_type_ GUARDED_BY(mutex_);
 
   // These fields are set before the clone state is set to CREATING.
diff --git a/src/yb/master/clone/clone_state_manager-test.cc b/src/yb/master/clone/clone_state_manager-test.cc
index da6feee284..30eb97f9e3 100644
--- a/src/yb/master/clone/clone_state_manager-test.cc
+++ b/src/yb/master/clone/clone_state_manager-test.cc
@@ -117,7 +117,7 @@ class CloneStateManagerTest : public YBTest {
          AsyncEnableDbConns::EnableDbConnsCallbackType callback), (override));
 
     MOCK_METHOD(
-        Status, Upsert, (const CloneStateInfoPtr& clone_state), (override));
+        Status, Upsert, (int64_t leader_term, const CloneStateInfoPtr& clone_state), (override));
     MOCK_METHOD(
         Status, Load,
         (const std::string& type,
@@ -220,7 +220,7 @@ class CloneStateManagerTest : public YBTest {
   Result<CloneStateInfoPtr> CreateCloneState(
       uint32_t seq_no, const ExternalTableSnapshotDataMap& table_snapshot_data) {
     auto clone_state = VERIFY_RESULT(clone_state_manager_->CreateCloneState(
-        seq_no, kSourceNamespaceId, GetDatabaseType(), kTargetNamespaceName, kRestoreTime));
+        kEpoch, seq_no, kSourceNamespaceId, GetDatabaseType(), kTargetNamespaceName, kRestoreTime));
 
     RETURN_NOT_OK(clone_state_manager_->UpdateCloneStateWithSnapshotInfo(
         clone_state, kSourceSnapshotId, kTargetSnapshotId, table_snapshot_data));
@@ -236,7 +236,7 @@ class CloneStateManagerTest : public YBTest {
     tablet_ids.set_new_id("test_target_id");
     *table_data.table_meta->add_tablets_ids() = tablet_ids;
 
-    EXPECT_CALL(MockFuncs(), Upsert(_));
+    EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
     return CreateCloneState(kSeqNo + 1, table_snapshot_data);
   }
 
@@ -255,7 +255,7 @@ class CloneStateManagerTest : public YBTest {
 
   // Creates a clone state and schedules clone ops to move it into the CREATING state.
   Result<CloneStateInfoPtr> CreateCloneStateAndStartCloning() {
-    EXPECT_CALL(MockFuncs(), Upsert(_));
+    EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
     auto clone_state = VERIFY_RESULT(CreateCloneState(kSeqNo, DefaultTableSnapshotData()));
 
     for (int i = 0; i < kNumTablets; ++i) {
@@ -265,8 +265,8 @@ class CloneStateManagerTest : public YBTest {
           .WillOnce(Return(target_tablets_[i]));
       EXPECT_CALL(MockFuncs(), ScheduleCloneTabletCall(source_tablets_[i], kEpoch, _));
     }
-    EXPECT_CALL(MockFuncs(), Upsert(_));
-    RETURN_NOT_OK(ScheduleCloneOps(clone_state, kEpoch, {} /* not_snapshotted_tablets */));
+    EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
+    RETURN_NOT_OK(ScheduleCloneOps(clone_state, {} /* not_snapshotted_tablets */));
     return clone_state;
   }
 
@@ -290,9 +290,9 @@ class CloneStateManagerTest : public YBTest {
   }
 
   Status ScheduleCloneOps(
-      const CloneStateInfoPtr& clone_state, const LeaderEpoch& epoch,
+      const CloneStateInfoPtr& clone_state,
       const std::unordered_set<TabletId>& not_snapshotted_tablets) {
-    return clone_state_manager_->ScheduleCloneOps(clone_state, epoch, not_snapshotted_tablets);
+    return clone_state_manager_->ScheduleCloneOps(clone_state, not_snapshotted_tablets);
   }
   Result<std::pair<NamespaceId, uint32_t>> CloneNamespace(
       const NamespaceIdentifierPB& source_namespace_identifier,
@@ -310,7 +310,7 @@ class CloneStateManagerTest : public YBTest {
       const std::string& target_namespace_name,
       CoarseTimePoint deadline, const LeaderEpoch& epoch) {
     return clone_state_manager_->MakeDoneClonePgSchemaCallback(
-      clone_state, snapshot_schedule_id, target_namespace_name, deadline, epoch);
+      clone_state, snapshot_schedule_id, target_namespace_name, deadline);
   }
 
   void AssertCloneIsAborted() {
@@ -356,7 +356,7 @@ class CloneStateManagerPgTest : public CloneStateManagerTest {
 };
 
 TEST_F(CloneStateManagerTest, CreateCloneState) {
-  EXPECT_CALL(MockFuncs(), Upsert(_));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
   auto clone_state = ASSERT_RESULT(CreateCloneState(kSeqNo, DefaultTableSnapshotData()));
 
   // Check clone state persisted fields.
@@ -388,8 +388,8 @@ TEST_F(CloneStateManagerTest, CreateSecondCloneState) {
     l.mutable_data()->pb.set_aggregate_state(state);
     l.Commit();
 
-    if (current_clone_state->LockForRead()->IsDone()) {
-      EXPECT_CALL(MockFuncs(), Upsert(_));
+    if (CloneStateInfoHelpers::IsDone(current_clone_state->LockForRead()->pb)) {
+      EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
       ASSERT_OK(CreateCloneState(i + 1, DefaultTableSnapshotData()));
     } else {
       auto s = CreateCloneState(i + 1, DefaultTableSnapshotData());
@@ -400,7 +400,7 @@ TEST_F(CloneStateManagerTest, CreateSecondCloneState) {
 }
 
 TEST_F(CloneStateManagerTest, ScheduleCloneOps) {
-  EXPECT_CALL(MockFuncs(), Upsert(_));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
   auto clone_state = ASSERT_RESULT(CreateCloneState(kSeqNo, DefaultTableSnapshotData()));
 
   for (int i = 0; i < kNumTablets; ++i) {
@@ -424,8 +424,8 @@ TEST_F(CloneStateManagerTest, ScheduleCloneOps) {
     EXPECT_CALL(MockFuncs(), ScheduleCloneTabletCall(
         source_tablets_[i], kEpoch, CloneTabletRequestPBMatcher(expected_req)));
   }
-  EXPECT_CALL(MockFuncs(), Upsert(_));
-  ASSERT_OK(ScheduleCloneOps(clone_state, kEpoch, {} /* not_snapshotted_tablets */));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
+  ASSERT_OK(ScheduleCloneOps(clone_state, {} /* not_snapshotted_tablets */));
 }
 
 TEST_F(CloneStateManagerTest, HandleCreatingStateAllTabletsCreating) {
@@ -481,7 +481,7 @@ TEST_F(CloneStateManagerTest, HandleCreatingStateAllTabletsRunning) {
 
   // HandleCreatingState should transition aggregate state to RESTORING and should also trigger a
   // restore.
-  EXPECT_CALL(MockFuncs(), Upsert(_));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
   EXPECT_CALL(MockFuncs(), Restore(kTargetSnapshotId, kRestoreTime))
       .WillOnce(Return(kRestorationId));
   ASSERT_OK(HandleCreatingState(clone_state));
@@ -539,7 +539,7 @@ TEST_F(CloneStateManagerTest, AbortInStartTabletsCloning) {
   EXPECT_CALL(MockFuncs(), FindNamespace).WillOnce(Return(source_ns_));
   EXPECT_CALL(MockFuncs(), ListSnapshotSchedules)
       .WillOnce(DoAll(SetArgPointee<0>(DefaultListSnapshotSchedules()), Return(Status::OK())));
-  EXPECT_CALL(MockFuncs(), Upsert(_)).WillRepeatedly(Return(Status::OK()));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _)).WillRepeatedly(Return(Status::OK()));
   EXPECT_CALL(MockFuncs(), GenerateSnapshotInfoFromScheduleForClone).WillOnce(Return(
       STATUS_FORMAT(IllegalState, "Fail GenerateSnapshotInfoFromScheduleForClone for test")));
 
@@ -556,7 +556,7 @@ TEST_F_EX(CloneStateManagerTest, AbortIfFailToSchedulePgCloneSchema, CloneStateM
       .WillOnce(DoAll(SetArgPointee<0>(DefaultListSnapshotSchedules()), Return(Status::OK())));
   TSDescriptorPtr dummy_ts_desc = std::make_shared<TSDescriptor>("ts0" /* perm_id*/);
   EXPECT_CALL(MockFuncs(), PickTserver).WillOnce(Return(dummy_ts_desc));
-  EXPECT_CALL(MockFuncs(), Upsert(_)).WillRepeatedly(Return(Status::OK()));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _)).WillRepeatedly(Return(Status::OK()));
   EXPECT_CALL(MockFuncs(), ScheduleClonePgSchemaTask).WillOnce(Return(
       STATUS_FORMAT(IllegalState, "Fail ScheduleClonePgSchemaTask for test")));
 
@@ -568,21 +568,21 @@ TEST_F_EX(CloneStateManagerTest, AbortIfFailToSchedulePgCloneSchema, CloneStateM
 }
 
 TEST_F_EX(CloneStateManagerTest, AbortInPgSchemaClone, CloneStateManagerPgTest) {
-  EXPECT_CALL(MockFuncs(), Upsert(_));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
   auto clone_state = ASSERT_RESULT(CreateCloneState(kSeqNo, DefaultTableSnapshotData()));
   auto callback = MakeDoneClonePgSchemaCallback(
       clone_state, kSnapshotScheduleId, kTargetNamespaceName,
       CoarseMonoClock::Now() + 10s /* deadline */, kEpoch);
 
   // We expect an upsert when aborting the clone.
-  EXPECT_CALL(MockFuncs(), Upsert(_));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
   ASSERT_OK(callback(STATUS_FORMAT(IllegalState, "Fail pg schema clone for test")));
 
   AssertCloneIsAborted();
 }
 
 TEST_F_EX(CloneStateManagerTest, AbortInStartTabletsCloningPg, CloneStateManagerPgTest) {
-  EXPECT_CALL(MockFuncs(), Upsert(_));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
   auto clone_state = ASSERT_RESULT(CreateCloneState(kSeqNo, DefaultTableSnapshotData()));
   auto callback = MakeDoneClonePgSchemaCallback(
       clone_state, kSnapshotScheduleId, kTargetNamespaceName,
@@ -591,7 +591,7 @@ TEST_F_EX(CloneStateManagerTest, AbortInStartTabletsCloningPg, CloneStateManager
   // We expect an upsert when aborting the clone.
   EXPECT_CALL(MockFuncs(), GenerateSnapshotInfoFromScheduleForClone).WillOnce(Return(
       STATUS_FORMAT(IllegalState, "Fail GenerateSnapshotInfoFromScheduleForClone for test")));
-  EXPECT_CALL(MockFuncs(), Upsert(_));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
   ASSERT_OK(callback(Status::OK() /* pg_schema_cloning_status */));
 
   AssertCloneIsAborted();
@@ -603,7 +603,7 @@ TEST_F(CloneStateManagerTest, AbortInCreatingState) {
   // We expect an upsert when aborting the clone.
   EXPECT_CALL(MockFuncs(), GetTabletInfo(_))
       .WillOnce(Return(STATUS_FORMAT(IllegalState, "Fail GetTabletInfo for test")));
-  EXPECT_CALL(MockFuncs(), Upsert(_));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
   ASSERT_OK(clone_state_manager_->Run());
 
   AssertCloneIsAborted();
@@ -620,7 +620,7 @@ TEST_F(CloneStateManagerTest, AbortInRestoringState) {
   // We expect an upsert when aborting the clone.
   EXPECT_CALL(MockFuncs(), ListRestorations(_, _))
       .WillOnce(Return(STATUS_FORMAT(IllegalState, "Fail ListRestorations for test")));
-  EXPECT_CALL(MockFuncs(), Upsert(_));
+  EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
   ASSERT_OK(clone_state_manager_->Run());
 
   AssertCloneIsAborted();
@@ -648,7 +648,7 @@ TEST_F(CloneStateManagerTest, Load) {
   std::function<Status(const std::string&, const SysCloneStatePB&)> inserter;
   EXPECT_CALL(MockFuncs(), Load)
       .WillRepeatedly(DoAll(SaveArg<1>(&inserter), Return(Status::OK())));
-  ASSERT_OK(clone_state_manager_->ClearAndRunLoaders());
+  ASSERT_OK(clone_state_manager_->ClearAndRunLoaders(kEpoch));
 
   // Run the inserter to actually load the data. Load them in reverse order to test that the
   // clone state map ordering works.
@@ -695,11 +695,11 @@ TEST_F(CloneStateManagerTest, AbortIncompleteCloneOnLoad) {
     std::function<Status(const std::string&, const SysCloneStatePB&)> inserter;
     EXPECT_CALL(MockFuncs(), Load)
         .WillOnce(DoAll(SaveArg<1>(&inserter), Return(Status::OK())));
-    ASSERT_OK(clone_state_manager_->ClearAndRunLoaders());
+    ASSERT_OK(clone_state_manager_->ClearAndRunLoaders(kEpoch));
 
     // Run the inserter to load the clone state.
-    if (!orig_lock->IsDone()) {
-      EXPECT_CALL(MockFuncs(), Upsert(_));
+    if (!CloneStateInfoHelpers::IsDone(orig_lock->pb)) {
+      EXPECT_CALL(MockFuncs(), Upsert(kEpoch.leader_term, _));
     }
     ASSERT_OK(inserter(clone_state->id(), orig_lock->pb));
     auto loaded_clone_state = GetLatestCloneState();
diff --git a/src/yb/master/clone/clone_state_manager.cc b/src/yb/master/clone/clone_state_manager.cc
index 997bf6cac1..097f79a19c 100644
--- a/src/yb/master/clone/clone_state_manager.cc
+++ b/src/yb/master/clone/clone_state_manager.cc
@@ -158,8 +158,8 @@ class CloneStateManagerExternalFunctions : public CloneStateManagerExternalFunct
   }
 
   // Sys catalog.
-  Status Upsert(const CloneStateInfoPtr& clone_state) override {
-    return sys_catalog_->Upsert(catalog_manager_->leader_ready_term(), clone_state);
+  Status Upsert(int64_t leader_term, const CloneStateInfoPtr& clone_state) override {
+    return sys_catalog_->Upsert(leader_term, clone_state);
   }
 
   Status Load(
@@ -276,7 +276,7 @@ Result<std::pair<NamespaceId, uint32_t>> CloneStateManager::CloneNamespace(
   // Set up clone state.
   // Past this point, we should abort the clone state if we get a non-OK status from any step.
   auto clone_state = VERIFY_RESULT(CreateCloneState(
-      seq_no, source_namespace_id, source_namespace_identifier.database_type(),
+      epoch, seq_no, source_namespace_id, source_namespace_identifier.database_type(),
       target_namespace_name, restore_time));
 
   // Clone PG Schema objects first in case of PGSQL databases. Tablets cloning is initiated in the
@@ -285,11 +285,11 @@ Result<std::pair<NamespaceId, uint32_t>> CloneStateManager::CloneNamespace(
   if (source_namespace->database_type() == YQL_DATABASE_PGSQL) {
     status = ClonePgSchemaObjects(
         clone_state, source_namespace->name(), target_namespace_name, pg_source_owner,
-        pg_target_owner, snapshot_schedule_id, epoch);
+        pg_target_owner, snapshot_schedule_id);
   } else {
     // For YCQL, start tablets cloning directly.
     status = StartTabletsCloning(
-        clone_state, snapshot_schedule_id, target_namespace_name, deadline, epoch);
+        clone_state, snapshot_schedule_id, target_namespace_name, deadline);
   }
 
   if (!status.ok()) {
@@ -302,8 +302,7 @@ Status CloneStateManager::StartTabletsCloning(
     CloneStateInfoPtr clone_state,
     const SnapshotScheduleId& snapshot_schedule_id,
     const std::string& target_namespace_name,
-    CoarseTimePoint deadline,
-    const LeaderEpoch& epoch) {
+    CoarseTimePoint deadline) {
   if (FLAGS_TEST_fail_clone_tablets) {
     return STATUS_FORMAT(RuntimeError, "Failing clone due to test flag fail_clone_tablets");
   }
@@ -320,8 +319,8 @@ Status CloneStateManager::StartTabletsCloning(
   UDTypeMap type_map;
   ExternalTableSnapshotDataMap tables_data;
   RETURN_NOT_OK(external_funcs_->DoImportSnapshotMeta(
-      snapshot_info, epoch, target_namespace_name, &namespace_map, &type_map, &tables_data,
-      deadline));
+      snapshot_info, clone_state->Epoch(), target_namespace_name, &namespace_map, &type_map,
+      &tables_data, deadline));
   if (namespace_map.size() != 1) {
     return STATUS_FORMAT(IllegalState, "Expected 1 namespace, got $0", namespace_map.size());
   }
@@ -345,7 +344,7 @@ Status CloneStateManager::StartTabletsCloning(
   create_snapshot_req.set_transaction_aware(true);
   create_snapshot_req.set_imported(true);
   RETURN_NOT_OK(external_funcs_->DoCreateSnapshot(
-      &create_snapshot_req, &create_snapshot_resp, deadline, epoch));
+      &create_snapshot_req, &create_snapshot_resp, deadline, clone_state->Epoch()));
   if (create_snapshot_resp.has_error()) {
     return StatusFromPB(create_snapshot_resp.error().status());
   }
@@ -356,7 +355,7 @@ Status CloneStateManager::StartTabletsCloning(
   RETURN_NOT_OK(UpdateCloneStateWithSnapshotInfo(
       clone_state, source_snapshot_id, target_snapshot_id, tables_data));
 
-  RETURN_NOT_OK(ScheduleCloneOps(clone_state, epoch, not_snapshotted_tablets));
+  RETURN_NOT_OK(ScheduleCloneOps(clone_state, not_snapshotted_tablets));
   return Status::OK();
 }
 
@@ -366,8 +365,7 @@ Status CloneStateManager::ClonePgSchemaObjects(
     const std::string& target_db_name,
     const std::string& pg_source_owner,
     const std::string& pg_target_owner,
-    const SnapshotScheduleId& snapshot_schedule_id,
-    const LeaderEpoch& epoch) {
+    const SnapshotScheduleId& snapshot_schedule_id) {
   if (FLAGS_TEST_fail_clone_pg_schema) {
     return STATUS_FORMAT(RuntimeError, "Failing clone due to test flag fail_clone_pg_schema");
   }
@@ -381,13 +379,12 @@ Status CloneStateManager::ClonePgSchemaObjects(
       ts_permanent_uuid, source_db_name, target_db_name, pg_source_owner, pg_target_owner,
       HybridTime(clone_state->LockForRead()->pb.restore_time()),
       MakeDoneClonePgSchemaCallback(
-          clone_state, snapshot_schedule_id, target_db_name, ToCoarse(deadline),
-          epoch),
+          clone_state, snapshot_schedule_id, target_db_name, ToCoarse(deadline)),
       deadline));
   return Status::OK();
 }
 
-Status CloneStateManager::ClearAndRunLoaders() {
+Status CloneStateManager::ClearAndRunLoaders(const LeaderEpoch& epoch) {
   {
     std::lock_guard l(mutex_);
     source_clone_state_map_.clear();
@@ -395,37 +392,30 @@ Status CloneStateManager::ClearAndRunLoaders() {
   RETURN_NOT_OK(external_funcs_->Load(
       "Clone states",
       std::function<Status(const std::string&, const SysCloneStatePB&)>(
-          std::bind(&CloneStateManager::LoadCloneState, this, _1, _2))));
+          std::bind(&CloneStateManager::LoadCloneState, this, epoch, _1, _2))));
 
   return Status::OK();
 }
 
-Status CloneStateManager::LoadCloneState(const std::string& id, const SysCloneStatePB& metadata) {
+Status CloneStateManager::LoadCloneState(
+    const LeaderEpoch& epoch, const std::string& id, const SysCloneStatePB& metadata) {
   auto clone_state = std::make_shared<CloneStateInfo>(id);
   clone_state->Load(metadata);
 
-  std::string source_namespace_id;
-  bool is_done;
-  {
-    // Release the read lock before calling MarkCloneAborted to avoid deadlock.
-    auto read_lock = clone_state->LockForRead();
-    source_namespace_id = read_lock->pb.source_namespace_id();
-    is_done = read_lock->IsDone();
-  }
-
   // Abort the clone if it was not in a terminal state.
-  if (!is_done) {
-    RETURN_NOT_OK(MarkCloneAborted(clone_state, "aborted by master failover"));
+  if (!CloneStateInfoHelpers::IsDone(metadata)) {
+    RETURN_NOT_OK(MarkCloneAborted(clone_state, "aborted by master failover", epoch.leader_term));
   }
 
   {
     std::lock_guard lock(mutex_);
-    source_clone_state_map_[source_namespace_id].insert(clone_state);
+    source_clone_state_map_[metadata.source_namespace_id()].insert(clone_state);
   }
   return Status::OK();
 }
 
 Result<CloneStateInfoPtr> CloneStateManager::CreateCloneState(
+    const LeaderEpoch& epoch,
     uint32_t seq_no,
     const NamespaceId& source_namespace_id,
     YQLDatabase database_type,
@@ -438,7 +428,7 @@ Result<CloneStateInfoPtr> CloneStateManager::CreateCloneState(
     auto latest_clone_it = it->second.rbegin();
     if (latest_clone_it != it->second.rend()) {
       auto lock = (*latest_clone_it)->LockForRead();
-      if (!lock->IsDone()) {
+      if (!CloneStateInfoHelpers::IsDone(lock->pb)) {
         return STATUS_FORMAT(
             AlreadyPresent, "Cannot create new clone state because there is already an ongoing "
             "clone for source namespace $0 in state $1", source_namespace_id,
@@ -449,6 +439,7 @@ Result<CloneStateInfoPtr> CloneStateManager::CreateCloneState(
 
   auto clone_state = std::make_shared<CloneStateInfo>(GenerateObjectId());
   clone_state->SetDatabaseType(database_type);
+  clone_state->SetEpoch(epoch);
   clone_state->mutable_metadata()->StartMutation();
   auto* pb = &clone_state->mutable_metadata()->mutable_dirty()->pb;
   pb->set_aggregate_state(SysCloneStatePB::CLONE_SCHEMA_STARTED);
@@ -456,7 +447,7 @@ Result<CloneStateInfoPtr> CloneStateManager::CreateCloneState(
   pb->set_source_namespace_id(source_namespace_id);
   pb->set_restore_time(restore_time.ToUint64());
   pb->set_target_namespace_name(target_namespace_name);
-  RETURN_NOT_OK(external_funcs_->Upsert(clone_state));
+  RETURN_NOT_OK(external_funcs_->Upsert(clone_state->Epoch().leader_term, clone_state));
   clone_state->mutable_metadata()->CommitMutation();
 
   // Add to the in-memory map.
@@ -487,7 +478,7 @@ Status CloneStateManager::UpdateCloneStateWithSnapshotInfo(
 }
 
 Status CloneStateManager::ScheduleCloneOps(
-    const CloneStateInfoPtr& clone_state, const LeaderEpoch& epoch,
+    const CloneStateInfoPtr& clone_state,
     const std::unordered_set<TabletId>& not_snapshotted_tablets) {
   for (auto& tablet_data : clone_state->GetTabletData()) {
     auto source_tablet = VERIFY_RESULT(
@@ -524,13 +515,14 @@ Status CloneStateManager::ScheduleCloneOps(
     }
     *req.mutable_target_schema() = target_table_lock->pb.schema();
     *req.mutable_target_partition_schema() = target_table_lock->pb.partition_schema();
-    RETURN_NOT_OK(external_funcs_->ScheduleCloneTabletCall(source_tablet, epoch, std::move(req)));
+    RETURN_NOT_OK(external_funcs_->ScheduleCloneTabletCall(
+        source_tablet, clone_state->Epoch(), std::move(req)));
   }
 
   auto lock = clone_state->LockForWrite();
   auto& pb = lock.mutable_data()->pb;
   pb.set_aggregate_state(SysCloneStatePB::CREATING);
-  RETURN_NOT_OK(external_funcs_->Upsert(clone_state));
+  RETURN_NOT_OK(external_funcs_->Upsert(clone_state->Epoch().leader_term, clone_state));
   lock.Commit();
 
   return Status::OK();
@@ -539,13 +531,13 @@ Status CloneStateManager::ScheduleCloneOps(
 AsyncClonePgSchema::ClonePgSchemaCallbackType CloneStateManager::MakeDoneClonePgSchemaCallback(
     CloneStateInfoPtr clone_state, const SnapshotScheduleId& snapshot_schedule_id,
     const std::string& target_namespace_name,
-    CoarseTimePoint deadline, const LeaderEpoch& epoch) {
-  return [this, clone_state, snapshot_schedule_id, target_namespace_name, deadline,
-          epoch](const Status& pg_schema_cloning_status) -> Status {
+    CoarseTimePoint deadline) {
+  return [this, clone_state, snapshot_schedule_id, target_namespace_name, deadline]
+      (const Status& pg_schema_cloning_status) -> Status {
     auto status = pg_schema_cloning_status;
     if (status.ok()) {
       status = StartTabletsCloning(
-          clone_state, snapshot_schedule_id, target_namespace_name, deadline, epoch);
+          clone_state, snapshot_schedule_id, target_namespace_name, deadline);
     }
     if (!status.ok()) {
       RETURN_NOT_OK(MarkCloneAborted(clone_state, status.ToString()));
@@ -581,7 +573,7 @@ Status CloneStateManager::HandleCreatingState(const CloneStateInfoPtr& clone_sta
   clone_state->SetRestorationId(restoration_id);
   pb.set_aggregate_state(SysCloneStatePB::RESTORING);
 
-  RETURN_NOT_OK(external_funcs_->Upsert(clone_state));
+  RETURN_NOT_OK(external_funcs_->Upsert(clone_state->Epoch().leader_term, clone_state));
   lock.Commit();
   return Status::OK();
 }
@@ -595,7 +587,7 @@ Status CloneStateManager::EnableDbConnections(const CloneStateInfoPtr& clone_sta
       SCHECK_EQ(lock->pb.aggregate_state(), SysCloneStatePB::RESTORED, IllegalState,
           "Expected clone to be in restored state");
       lock.mutable_data()->pb.set_aggregate_state(SysCloneStatePB::COMPLETE);
-      auto status = external_funcs_->Upsert(clone_state);
+      auto status = external_funcs_->Upsert(clone_state->Epoch().leader_term, clone_state);
       if (status.ok()) {
         lock.Commit();
       }
@@ -629,12 +621,12 @@ Status CloneStateManager::HandleRestoringState(const CloneStateInfoPtr& clone_st
 
   if (clone_state->DatabaseType() == YQL_DATABASE_PGSQL) {
     lock.mutable_data()->pb.set_aggregate_state(SysCloneStatePB::RESTORED);
-    RETURN_NOT_OK(external_funcs_->Upsert(clone_state));
+    RETURN_NOT_OK(external_funcs_->Upsert(clone_state->Epoch().leader_term, clone_state));
     lock.Commit();
     return EnableDbConnections(clone_state);
   } else {
     lock.mutable_data()->pb.set_aggregate_state(SysCloneStatePB::COMPLETE);
-    RETURN_NOT_OK(external_funcs_->Upsert(clone_state));
+    RETURN_NOT_OK(external_funcs_->Upsert(clone_state->Epoch().leader_term, clone_state));
     lock.Commit();
     return Status::OK();
   }
@@ -642,6 +634,11 @@ Status CloneStateManager::HandleRestoringState(const CloneStateInfoPtr& clone_st
 
 Status CloneStateManager::MarkCloneAborted(
     const CloneStateInfoPtr& clone_state, const std::string& abort_reason) {
+  return MarkCloneAborted(clone_state, abort_reason, clone_state->Epoch().leader_term);
+}
+
+Status CloneStateManager::MarkCloneAborted(
+    const CloneStateInfoPtr& clone_state, const std::string& abort_reason, int64_t leader_term) {
   auto lock = clone_state->LockForWrite();
   LOG(INFO) << Format(
       "Aborted clone for source namespace $0 because: $1.\n"
@@ -650,7 +647,7 @@ Status CloneStateManager::MarkCloneAborted(
       lock->pb.target_namespace_name(), lock->pb.restore_time());
   lock.mutable_data()->pb.set_abort_message(abort_reason);
   lock.mutable_data()->pb.set_aggregate_state(SysCloneStatePB::ABORTED);
-  RETURN_NOT_OK(external_funcs_->Upsert(clone_state));
+  RETURN_NOT_OK(external_funcs_->Upsert(leader_term, clone_state));
   lock.Commit();
   return Status::OK();
 }
diff --git a/src/yb/master/clone/clone_state_manager.h b/src/yb/master/clone/clone_state_manager.h
index 3cd03fc899..6274453572 100644
--- a/src/yb/master/clone/clone_state_manager.h
+++ b/src/yb/master/clone/clone_state_manager.h
@@ -50,7 +50,7 @@ class CloneStateManager {
       rpc::RpcContext* rpc,
       const LeaderEpoch& epoch);
 
-  Status ClearAndRunLoaders();
+  Status ClearAndRunLoaders(const LeaderEpoch& epoch);
 
  private:
   explicit CloneStateManager(
@@ -66,8 +66,12 @@ class CloneStateManager {
     const LeaderEpoch& epoch);
 
   Result<CloneStateInfoPtr> CreateCloneState(
-      uint32_t seq_no, const NamespaceId& source_namespace_id, YQLDatabase database_type,
-      const std::string& target_namespace_name, const HybridTime& restore_time);
+      const LeaderEpoch& epoch,
+      uint32_t seq_no,
+      const NamespaceId& source_namespace_id,
+      YQLDatabase database_type,
+      const std::string& target_namespace_name,
+      const HybridTime& restore_time);
 
   Status UpdateCloneStateWithSnapshotInfo(
       const CloneStateInfoPtr& clone_state,
@@ -82,28 +86,30 @@ class CloneStateManager {
       const std::string& target_db_name,
       const std::string& pg_source_owner,
       const std::string& pg_target_owner,
-      const SnapshotScheduleId& snapshot_schedule_id,
-      const LeaderEpoch& epoch);
+      const SnapshotScheduleId& snapshot_schedule_id);
 
   // Starts snapshot related operations for clone (mainly generate snapshotInfoPB as of
   // restore_time and then import it and create a new snapshot for target_namespace). Then it
   // schedules async clone tasks for every tablet. The function is the whole clone process in case
   // of YCQL and the second part of the clone process in case of YSQL.
   Status StartTabletsCloning(
-      CloneStateInfoPtr clone_state, const SnapshotScheduleId& snapshot_schedule_id,
+      CloneStateInfoPtr clone_state,
+      const SnapshotScheduleId& snapshot_schedule_id,
       const std::string& target_namespace_name,
-      CoarseTimePoint deadline, const LeaderEpoch& epoch);
+      CoarseTimePoint deadline);
 
-  Status LoadCloneState(const std::string& id, const SysCloneStatePB& metadata);
+  Status LoadCloneState(
+      const LeaderEpoch& epoch, const std::string& id, const SysCloneStatePB& metadata);
 
   Status ScheduleCloneOps(
-      const CloneStateInfoPtr& clone_state, const LeaderEpoch& epoch,
+      const CloneStateInfoPtr& clone_state,
       const std::unordered_set<TabletId>& not_snapshotted_tablets);
 
   AsyncClonePgSchema::ClonePgSchemaCallbackType MakeDoneClonePgSchemaCallback(
-      CloneStateInfoPtr clone_state, const SnapshotScheduleId& snapshot_schedule_id,
+      CloneStateInfoPtr clone_state,
+      const SnapshotScheduleId& snapshot_schedule_id,
       const std::string& target_namespace_name,
-      CoarseTimePoint deadline, const LeaderEpoch& epoch);
+      CoarseTimePoint deadline);
 
   Status EnableDbConnections(const CloneStateInfoPtr& clone_state);
 
@@ -113,6 +119,9 @@ class CloneStateManager {
 
   // Mark state as aborting and set a descriptive message for debugging purposes.
   Status MarkCloneAborted(const CloneStateInfoPtr& clone_state, const std::string& abort_reason);
+  // The loading code uses this overload to abort a clone after a master leader change.
+  Status MarkCloneAborted(
+      const CloneStateInfoPtr& clone_state, const std::string& abort_reason, int64_t leader_term);
 
   std::mutex mutex_;
 
diff --git a/src/yb/master/clone/external_functions.h b/src/yb/master/clone/external_functions.h
index cfa753175c..a90b7dc89d 100644
--- a/src/yb/master/clone/external_functions.h
+++ b/src/yb/master/clone/external_functions.h
@@ -83,7 +83,7 @@ class CloneStateManagerExternalFunctionsBase {
   virtual TSDescriptorPtr PickTserver() = 0;
 
   // Sys catalog.
-  virtual Status Upsert(const CloneStateInfoPtr&) = 0;
+  virtual Status Upsert(int64_t leader_term, const CloneStateInfoPtr&) = 0;
   virtual Status Load(
       const std::string& type,
       std::function<Status(const std::string&, const SysCloneStatePB&)> inserter) = 0;
