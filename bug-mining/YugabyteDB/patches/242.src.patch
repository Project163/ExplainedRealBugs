diff --git a/src/yb/integration-tests/CMakeLists.txt b/src/yb/integration-tests/CMakeLists.txt
index 7e0f1149c0..0f46f73005 100644
--- a/src/yb/integration-tests/CMakeLists.txt
+++ b/src/yb/integration-tests/CMakeLists.txt
@@ -270,6 +270,7 @@ ADD_YB_TEST(upgrade-tests/basic_upgrade-test)
 ADD_YB_TEST(upgrade-tests/replication_info_upgrade-test)
 ADD_YB_TEST(upgrade-tests/pg15_upgrade-test)
 ADD_YB_TEST(upgrade-tests/pg15_upgrade_pgregress-test)
+ADD_YB_TEST(upgrade-tests/ycql_only_upgrade-test)
 ADD_YB_TEST(upgrade-tests/ysql_major_upgrade_rpcs-test)
 ADD_YB_TEST(upgrade-tests/ysql_major_upgrade_ddl_blocking-test)
 ADD_YB_TEST(upgrade-tests/ysql_major_upgrade_matview-test)
diff --git a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
index 0ce225608f..23fc39d2e3 100644
--- a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
+++ b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
@@ -311,16 +311,18 @@ Status UpgradeTestBase::StartClusterInOldVersion(const ExternalMiniClusterOption
   current_version_tserver_bin_path_ = cluster_->GetTServerBinaryPath();
   cluster_->SetDaemonBinPath(old_version_bin_path_);
 
-  server::GetStatusRequestPB req;
-  server::GetStatusResponsePB resp;
-  rpc::RpcController rpc;
-  rpc.set_timeout(kRpcTimeout);
-  RETURN_NOT_OK(
-      cluster_->GetLeaderMasterProxy<server::GenericServiceProxy>().GetStatus(req, &resp, &rpc));
-  LOG(INFO) << "From version: " << resp.status().version_info().DebugString();
+  if (cluster_->opts_.enable_ysql) {
+    server::GetStatusRequestPB req;
+    server::GetStatusResponsePB resp;
+    rpc::RpcController rpc;
+    rpc.set_timeout(kRpcTimeout);
+    RETURN_NOT_OK(
+        cluster_->GetLeaderMasterProxy<server::GenericServiceProxy>().GetStatus(req, &resp, &rpc));
+    LOG(INFO) << "From version: " << resp.status().version_info().DebugString();
 
-  is_ysql_major_version_upgrade_ = resp.status().version_info().ysql_major_version() !=
-                                   current_version_info_.ysql_major_version();
+    is_ysql_major_version_upgrade_ = resp.status().version_info().ysql_major_version() !=
+                                     current_version_info_.ysql_major_version();
+  }
 
   if (IsYsqlMajorVersionUpgrade()) {
     RETURN_NOT_OK(
@@ -521,6 +523,10 @@ Status UpgradeTestBase::FinalizeYsqlMajorCatalogUpgrade() {
 }
 
 Status UpgradeTestBase::PerformYsqlUpgrade() {
+  if (!cluster_->opts_.enable_ysql) {
+    return Status::OK();
+  }
+
   LOG(INFO) << "Running ysql upgrade";
 
   tserver::UpgradeYsqlRequestPB req;
diff --git a/src/yb/integration-tests/upgrade-tests/ycql_only_upgrade-test.cc b/src/yb/integration-tests/upgrade-tests/ycql_only_upgrade-test.cc
new file mode 100644
index 0000000000..553602b945
--- /dev/null
+++ b/src/yb/integration-tests/upgrade-tests/ycql_only_upgrade-test.cc
@@ -0,0 +1,116 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/integration-tests/upgrade-tests/upgrade_test_base.h"
+
+#include "yb/client/schema.h"
+#include "yb/client/yb_table_name.h"
+#include "yb/client/client-test-util.h"
+#include "yb/client/session.h"
+#include "yb/client/table.h"
+#include "yb/client/table_creator.h"
+#include "yb/client/table_handle.h"
+#include "yb/client/yb_op.h"
+
+namespace yb {
+
+const MonoDelta kRpcTimeout = 5s * kTimeMultiplier;
+
+// Test upgrade and rollback with a simple workload with updates and selects.
+class YcqlOnlyUpgradeTest : public UpgradeTestBase {
+ public:
+  YcqlOnlyUpgradeTest() : UpgradeTestBase(kBuild_2_25_0_0) {}
+
+  void SetUp() override {
+    UpgradeTestBase::SetUp();
+    if (Test::IsSkipped()) {
+      return;
+    }
+
+    ASSERT_OK(StartClusterInOldVersion());
+    ASSERT_OK(CreateTable());
+    ASSERT_OK(InsertRowsAndValidate());
+  }
+
+  void SetUpOptions(ExternalMiniClusterOptions& opts) override {
+    UpgradeTestBase::SetUpOptions(opts);
+    opts.enable_ysql = false;
+  }
+
+  Status CreateTable() {
+    client::YBSchema schema;
+    client::YBSchemaBuilder b;
+    b.AddColumn("c0")->Type(DataType::INT32)->NotNull()->HashPrimaryKey();
+    RETURN_NOT_OK(b.Build(&schema));
+
+    client::YBTableName table_name(YQL_DATABASE_CQL, "namespace_name", "table_name");
+    RETURN_NOT_OK(client_->CreateNamespaceIfNotExists(
+        table_name.namespace_name(), table_name.namespace_type()));
+
+    // Add a table, make sure it reports itself.
+    std::unique_ptr<client::YBTableCreator> table_creator(client_->NewTableCreator());
+    RETURN_NOT_OK(table_creator->table_name(table_name)
+                      .schema(&schema)
+                      .table_type(client::YBTableType::YQL_TABLE_TYPE)
+                      .num_tablets(1)
+                      .Create());
+
+    RETURN_NOT_OK(table_.Open(table_name, client_.get()));
+
+    return Status::OK();
+  }
+
+  Status InsertRows() {
+    auto session = client_->NewSession(kRpcTimeout);
+    std::vector<client::YBOperationPtr> ops;
+
+    for (auto i = 0; i < 10; i++) {
+      auto op = table_.NewInsertOp();
+      int32_t key = row_count_++;
+      QLAddInt32HashValue(op->mutable_request(), key);
+      ops.push_back(std::move(op));
+    }
+
+    return session->TEST_ApplyAndFlush(ops);
+  }
+
+  Status ValidateRows() {
+    SCHECK_EQ(client::CountTableRows(table_), row_count_, IllegalState, "Row count mismatch");
+    return Status::OK();
+  }
+
+  Status InsertRowsAndValidate() {
+    RETURN_NOT_OK(InsertRows());
+    return ValidateRows();
+  }
+
+  client::TableHandle table_;
+  int32 row_count_ = 0;
+};
+
+TEST_F(YcqlOnlyUpgradeTest, TestUpgrade) {
+  ASSERT_OK(UpgradeClusterToCurrentVersion());
+  ASSERT_OK(InsertRowsAndValidate());
+
+  ASSERT_NOK_STR_CONTAINS(StartYsqlMajorCatalogUpgrade(), "YSQL is not enabled");
+}
+
+TEST_F(YcqlOnlyUpgradeTest, TestRollback) {
+  ASSERT_OK(UpgradeClusterToCurrentVersion(/*delay_between_nodes=*/3s, /*auto_finalize=*/false));
+  ASSERT_OK(InsertRowsAndValidate());
+
+  ASSERT_OK(RollbackClusterToOldVersion());
+  ASSERT_OK(InsertRowsAndValidate());
+}
+
+}  // namespace yb
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
index 14d1223bc8..fd1420d9cb 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
@@ -30,6 +30,7 @@
 
 #include "yb/yql/pgwrapper/pg_wrapper.h"
 
+DECLARE_bool(enable_ysql);
 DECLARE_string(tmp_dir);
 DECLARE_bool(master_join_existing_universe);
 DECLARE_string(rpc_bind_addresses);
@@ -54,6 +55,8 @@ DEFINE_test_flag(bool, ysql_fail_cleanup_previous_version_catalog, false,
 
 using yb::pgwrapper::PgWrapper;
 
+#define SCHECK_YSQL_ENABLED SCHECK(FLAGS_enable_ysql, IllegalState, "YSQL is not enabled")
+
 namespace yb::master {
 
 namespace {
@@ -76,6 +79,10 @@ YsqlInitDBAndMajorUpgradeHandler::YsqlInitDBAndMajorUpgradeHandler(
       thread_pool_(thread_pool) {}
 
 void YsqlInitDBAndMajorUpgradeHandler::Load(scoped_refptr<SysConfigInfo> config) {
+  if (!FLAGS_enable_ysql) {
+    return;
+  }
+
   auto& ysql_catalog_config = config->mutable_metadata()->mutable_dirty()->pb.ysql_catalog_config();
   if (ysql_catalog_config.has_ysql_major_catalog_upgrade_info()) {
     const auto persisted_version =
@@ -139,6 +146,8 @@ Status YsqlInitDBAndMajorUpgradeHandler::StartNewClusterGlobalInitDB(const Leade
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::StartYsqlMajorCatalogUpgrade(const LeaderEpoch& epoch) {
+  SCHECK_YSQL_ENABLED;
+
   RETURN_NOT_OK(
       TransitionMajorCatalogUpgradeState(YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB, epoch));
 
@@ -162,6 +171,8 @@ IsOperationDoneResult YsqlInitDBAndMajorUpgradeHandler::IsYsqlMajorCatalogUpgrad
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::FinalizeYsqlMajorCatalogUpgrade(const LeaderEpoch& epoch) {
+  SCHECK_YSQL_ENABLED;
+
   RETURN_NOT_OK_PREPEND(
       master_.ts_manager()->ValidateAllTserverVersions(ValidateVersionInfoOp::kVersionEQ),
       "Cannot finalize YSQL major catalog upgrade before all yb-tservers have been upgraded to the "
@@ -171,6 +182,8 @@ Status YsqlInitDBAndMajorUpgradeHandler::FinalizeYsqlMajorCatalogUpgrade(const L
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::RollbackYsqlMajorCatalogVersion(const LeaderEpoch& epoch) {
+  SCHECK_YSQL_ENABLED;
+
   RETURN_NOT_OK_PREPEND(
       master_.ts_manager()->ValidateAllTserverVersions(ValidateVersionInfoOp::kYsqlMajorVersionLT),
       "Cannot rollback YSQL major catalog while yb-tservers are running on a newer YSQL major "
@@ -194,6 +207,10 @@ Status YsqlInitDBAndMajorUpgradeHandler::RollbackYsqlMajorCatalogVersion(const L
 
 Result<YsqlMajorCatalogUpgradeState>
 YsqlInitDBAndMajorUpgradeHandler::GetYsqlMajorCatalogUpgradeState() const {
+  if (!FLAGS_enable_ysql) {
+    return YSQL_MAJOR_CATALOG_UPGRADE_DONE;
+  }
+
   const auto state = ysql_catalog_config_.GetMajorCatalogUpgradeState();
   switch (state) {
     case YsqlMajorCatalogUpgradeInfoPB::INVALID:
@@ -649,6 +666,10 @@ Status YsqlInitDBAndMajorUpgradeHandler::CleanupPreviousYsqlMajorCatalog(const L
 
 Status YsqlInitDBAndMajorUpgradeHandler::ValidateTServerVersion(
     const VersionInfoPB& ts_version) const {
+  if (!FLAGS_enable_ysql) {
+    return Status::OK();
+  }
+
   // Dev note: Returning a bad status will cause the yb-tserver to FATAL.
   const auto current_major_version = VersionInfo::YsqlMajorVersion();
 
