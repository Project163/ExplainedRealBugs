diff --git a/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc b/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
index 0d4b6a1804..a22389a102 100644
--- a/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
@@ -17,9 +17,16 @@
 #include "yb/client/yb_table_name.h"
 #include "yb/common/entity_ids_types.h"
 #include "yb/common/xcluster_util.h"
+
 #include "yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h"
 #include "yb/integration-tests/xcluster/xcluster_test_utils.h"
+
+#include "yb/master/catalog_manager.h"
+#include "yb/master/xcluster/xcluster_manager.h"
+#include "yb/master/xcluster/xcluster_status.h"
+
 #include "yb/tserver/mini_tablet_server.h"
+
 #include "yb/util/logging_test_util.h"
 
 DECLARE_bool(TEST_simulate_EnsureSequenceUpdatesAreInWal_failure);
@@ -202,6 +209,35 @@ TEST_F(XClusterAutomaticModeTest, SequenceMetricsUseAliases) {
   EXPECT_GT(xcluster_metric_count, 0);
 }
 
+TEST_F(XClusterAutomaticModeTest, GetXClusterStatusHasCorrectNamespace) {
+  // Setup simple automatic replication with sequences so there will
+  // be xCluster status for a sequences_data stream.
+  ASSERT_OK(SetUpClusters(/*use_different_database_oids=*/false,  namespace_name));
+  ASSERT_OK(SetUpSequences(&producer_cluster_,  namespace_name));
+  ASSERT_OK(SetUpSequences(&consumer_cluster_,  namespace_name));
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces({ namespace_name}));
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+  ASSERT_OK(BumpSequences(&producer_cluster_,  namespace_name));
+  ASSERT_OK(WaitForSequencesReplicationDrain({ namespace_name}));
+
+  auto& catalog_manager =
+      ASSERT_RESULT(consumer_cluster_.mini_cluster_->GetLeaderMiniMaster())->catalog_manager_impl();
+  auto* xcluster_manager = catalog_manager.GetXClusterManagerImpl();
+  const auto xcluster_status = ASSERT_RESULT(xcluster_manager->GetXClusterStatus());
+  const auto& inbound_replication_group_statuses =
+      xcluster_status.inbound_replication_group_statuses;
+  for (const auto& inbound_replication_group_status : inbound_replication_group_statuses) {
+    const auto table_statuses_by_namespace =
+        inbound_replication_group_status.table_statuses_by_namespace;
+    for (const auto& [inbound_namespace_name, _inbound_xcluster_replication_group_stable_status] :
+         table_statuses_by_namespace) {
+      // Every inbound replication group status should be for namespace namespace_name; this
+      // includes the sequences_data stream status.
+      EXPECT_EQ(inbound_namespace_name, namespace_name);
+    }
+  }
+}
+
 TEST_F(XClusterAutomaticModeTest, SequenceReplicationWithFiltering) {
   // Unpacked is a harder test case for this code.  With unpacked rows, a single update to a
   // sequence will generate multiple RocksDB key value pairs.  This is harder for the xCluster code
diff --git a/src/yb/master/xcluster/xcluster_target_manager.cc b/src/yb/master/xcluster/xcluster_target_manager.cc
index c320e40638..39d1e05b19 100644
--- a/src/yb/master/xcluster/xcluster_target_manager.cc
+++ b/src/yb/master/xcluster/xcluster_target_manager.cc
@@ -13,6 +13,8 @@
 
 #include "yb/master/xcluster/xcluster_target_manager.h"
 
+#include <algorithm>
+
 #include "yb/client/client.h"
 #include "yb/client/xcluster_client.h"
 
@@ -508,14 +510,23 @@ Result<XClusterInboundReplicationGroupStatus> XClusterTargetManager::GetUniverse
         if (stream_info) {
           table_status.target_table_id = stream_info->consumer_table_id();
 
-          auto stripped_target_table_id =
-              xcluster::StripSequencesDataAliasIfPresent(table_status.target_table_id);
+          const auto& unstripped_target_table_id = table_status.target_table_id;
+          const auto stripped_target_table_id =
+              xcluster::StripSequencesDataAliasIfPresent(unstripped_target_table_id);
           auto table_info_res = catalog_manager_.GetTableById(stripped_target_table_id);
           if (table_info_res) {
             const auto& table_info = table_info_res.get();
             namespace_name = table_info->namespace_name();
             table_status.full_table_name = GetFullTableName(*table_info);
           }
+          if (xcluster::IsSequencesDataAlias(unstripped_target_table_id)) {
+            auto namespace_id = VERIFY_RESULT(
+                xcluster::GetReplicationNamespaceBelongsTo(unstripped_target_table_id));
+            namespace_name = catalog_manager_.GetNamespaceName(namespace_id);
+            RSTATUS_DCHECK(
+                !namespace_name.empty(), NotFound,
+                "Namespace ID $0 from sequences_data alias not found", namespace_id);
+          }
 
           table_status.target_tablet_count = stream_info->consumer_producer_tablet_map_size();
           table_status.local_tserver_optimized = stream_info->local_tserver_optimized();
@@ -1004,9 +1015,8 @@ Result<TableId> XClusterTargetManager::GetTableIdForStreamId(
     const xrepl::StreamId& stream_id) const {
   SharedLock l(table_stream_ids_map_mutex_);
 
-  auto iter = std::find_if(
-      table_stream_ids_map_.begin(), table_stream_ids_map_.end(),
-      [&replication_group_id, &stream_id](auto& id_map) {
+  auto iter = std::ranges::find_if(
+      table_stream_ids_map_, [&replication_group_id, &stream_id](auto& id_map) {
         return ContainsKeyValuePair(id_map.second, replication_group_id, stream_id);
       });
   SCHECK(
