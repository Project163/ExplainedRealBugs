diff --git a/src/yb/integration-tests/xcluster/xcluster-test.cc b/src/yb/integration-tests/xcluster/xcluster-test.cc
index 53bbe0754a..86ccfa8765 100644
--- a/src/yb/integration-tests/xcluster/xcluster-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster-test.cc
@@ -17,67 +17,73 @@
 #include <utility>
 #include <chrono>
 #include <boost/assign.hpp>
-#include "yb/cdc/xrepl_stream_metadata.h"
-#include "yb/integration-tests/cluster_itest_util.h"
-#include "yb/master/master_cluster.proxy.h"
-#include "yb/util/flags.h"
 #include <gtest/gtest.h>
 
-#include "yb/common/ql_value.h"
-#include "yb/common/schema.h"
-#include "yb/common/transaction.h"
-#include "yb/common/wire_protocol.h"
-
 #include "yb/cdc/cdc_service.h"
 #include "yb/cdc/cdc_service.pb.h"
 #include "yb/cdc/cdc_service.proxy.h"
 #include "yb/cdc/cdc_state_table.h"
-#include "yb/client/client.h"
+#include "yb/cdc/xrepl_stream_metadata.h"
+
 #include "yb/client/client-test-util.h"
 #include "yb/client/meta_cache.h"
 #include "yb/client/schema.h"
 #include "yb/client/session.h"
-#include "yb/client/table.h"
 #include "yb/client/table_alterer.h"
 #include "yb/client/table_creator.h"
 #include "yb/client/table_handle.h"
-#include "yb/client/transaction.h"
+#include "yb/client/table.h"
 #include "yb/client/transaction_rpc.h"
+#include "yb/client/transaction.h"
 #include "yb/client/yb_op.h"
+
+#include "yb/common/ql_value.h"
+#include "yb/common/schema.h"
+#include "yb/common/transaction.h"
+#include "yb/common/wire_protocol.h"
+
 #include "yb/consensus/log.h"
 
 #include "yb/gutil/stl_util.h"
 #include "yb/gutil/strings/join.h"
 #include "yb/gutil/strings/substitute.h"
+
 #include "yb/integration-tests/cdc_test_util.h"
+#include "yb/integration-tests/cluster_itest_util.h"
 #include "yb/integration-tests/mini_cluster.h"
-#include "yb/integration-tests/xcluster/xcluster_test_base.h"
+#include "yb/integration-tests/xcluster/xcluster_ycql_test_base.h"
 #include "yb/integration-tests/yb_mini_cluster_test_base.h"
+
 #include "yb/master/catalog_manager_if.h"
+#include "yb/master/master_backup.pb.h"
+#include "yb/master/master_cluster.proxy.h"
 #include "yb/master/master_defaults.h"
-#include "yb/master/mini_master.h"
 #include "yb/master/master_replication.proxy.h"
-
-#include "yb/master/master_backup.pb.h"
+#include "yb/master/mini_master.h"
 #include "yb/master/xcluster_consumer_registry_service.h"
+
 #include "yb/rpc/rpc_controller.h"
+
 #include "yb/server/hybrid_clock.h"
-#include "yb/tablet/tablet.h"
+
 #include "yb/tablet/tablet_peer.h"
-#include "yb/tserver/xcluster_consumer.h"
-#include "yb/tserver/xcluster_poller.h"
+#include "yb/tablet/tablet.h"
+
 #include "yb/tserver/mini_tablet_server.h"
 #include "yb/tserver/tablet_server.h"
 #include "yb/tserver/ts_tablet_manager.h"
 #include "yb/tserver/tserver_service.pb.h"
+#include "yb/tserver/xcluster_consumer.h"
+#include "yb/tserver/xcluster_poller.h"
 
 #include "yb/util/atomic.h"
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/faststring.h"
+#include "yb/util/flags.h"
 #include "yb/util/metrics.h"
 #include "yb/util/random.h"
-#include "yb/util/status.h"
 #include "yb/util/status_log.h"
+#include "yb/util/status.h"
 #include "yb/util/stopwatch.h"
 
 using std::string;
@@ -125,7 +131,6 @@ DECLARE_int32(tserver_heartbeat_metrics_interval_ms);
 DECLARE_bool(use_client_to_server_encryption);
 DECLARE_bool(use_node_to_node_encryption);
 DECLARE_bool(xcluster_wait_on_ddl_alter);
-DECLARE_int32(yb_num_shards_per_tserver);
 DECLARE_bool(TEST_xcluster_disable_delete_old_pollers);
 DECLARE_bool(enable_log_retention_by_op_idx);
 DECLARE_bool(TEST_xcluster_disable_poller_term_check);
@@ -158,8 +163,18 @@ struct XClusterTestParams {
   bool transactional_table;  // For XCluster + CQL only. All YSQL tables are transactional.
 };
 
-class XClusterTestNoParam : public XClusterTestBase {
+class XClusterTestNoParam : public XClusterYcqlTestBase {
  public:
+  virtual Status SetUpWithParams(
+      const std::vector<uint32_t>& num_consumer_tablets,
+      const std::vector<uint32_t>& num_producer_tablets, uint32_t replication_factor,
+      uint32_t num_masters = 1, uint32_t num_tservers = 1) override {
+    return XClusterYcqlTestBase::SetUpWithParams(
+        num_consumer_tablets, num_producer_tablets, replication_factor, num_masters, num_tservers);
+  }
+
+  virtual Status SetUpWithParams() override { return XClusterYcqlTestBase::SetUpWithParams(); }
+
   Status SetUpWithParams(
       const std::vector<uint32_t>& num_tablets_per_table, uint32_t replication_factor) {
     return SetUpWithParams(
@@ -167,72 +182,7 @@ class XClusterTestNoParam : public XClusterTestBase {
         1 /* num_tservers */);
   }
 
-  Status SetUpWithParams(
-      const std::vector<uint32_t>& num_consumer_tablets,
-      const std::vector<uint32_t>& num_producer_tablets, uint32_t replication_factor,
-      uint32_t num_masters = 1, uint32_t num_tservers = 1) {
-    ANNOTATE_UNPROTECTED_WRITE(FLAGS_enable_ysql) = false;
-    ANNOTATE_UNPROTECTED_WRITE(FLAGS_transaction_table_num_tablets) = 1;
-    XClusterTestBase::SetUp();
-    ANNOTATE_UNPROTECTED_WRITE(FLAGS_yb_num_shards_per_tserver) = 1;
-    bool transactional_table = GetTestParam().transactional_table;
-    num_tservers = std::max(num_tservers, replication_factor);
-
-    MiniClusterOptions opts;
-    opts.num_tablet_servers = num_tservers;
-    opts.num_masters = num_masters;
-    opts.transaction_table_num_tablets = FLAGS_transaction_table_num_tablets;
-    RETURN_NOT_OK(InitClusters(opts));
-
-    RETURN_NOT_OK(clock_->Init());
-    producer_cluster_.txn_mgr_.emplace(producer_client(), clock_, client::LocalTabletFilter());
-    consumer_cluster_.txn_mgr_.emplace(consumer_client(), clock_, client::LocalTabletFilter());
-
-    YBSchemaBuilder b;
-    b.AddColumn("c0")->Type(DataType::INT32)->NotNull()->HashPrimaryKey();
-
-    // Create transactional table.
-    TableProperties table_properties;
-    table_properties.SetTransactional(transactional_table);
-    b.SetTableProperties(table_properties);
-    RETURN_NOT_OK(b.Build(&schema_));
-
-    YBSchema consumer_schema;
-    table_properties.SetDefaultTimeToLive(0);
-    b.SetTableProperties(table_properties);
-    RETURN_NOT_OK(b.Build(&consumer_schema));
-
-    if (num_consumer_tablets.size() != num_producer_tablets.size()) {
-      return STATUS(
-          IllegalState, Format(
-                            "Num consumer tables: $0 num producer tables: $1 must be equal.",
-                            num_consumer_tablets.size(), num_producer_tablets.size()));
-    }
-
-    RETURN_NOT_OK(RunOnBothClusters([&](Cluster* cluster) -> Status {
-      const auto* num_tablets = &num_producer_tablets;
-      const auto* schema = &schema_;
-      if (cluster == &consumer_cluster_) {
-        num_tablets = &num_consumer_tablets;
-        schema = &consumer_schema;
-      }
-      for (uint32_t i = 0; i < num_tablets->size(); i++) {
-        auto table_name =
-            VERIFY_RESULT(CreateTable(i, num_tablets->at(i), cluster->client_.get(), *schema));
-
-        std::shared_ptr<client::YBTable> table;
-        RETURN_NOT_OK(cluster->client_->OpenTable(table_name, &table));
-        cluster->tables_.emplace_back(std::move(table));
-      }
-      return Status::OK();
-    }));
-
-    return PostSetUp();
-  }
-
-  virtual XClusterTestParams GetTestParam() {
-    return XClusterTestParams(false /* transactional_table */);
-  }
+  virtual bool UseTransactionalTables() override { return false; }
 
   Result<YBTableName> CreateTable(
       YBClient* client, const std::string& namespace_name, const std::string& table_name,
@@ -787,15 +737,12 @@ class XClusterTestNoParam : public XClusterTestBase {
     }
     return s;
   }
-
-  server::ClockPtr clock_{new server::HybridClock()};
-  YBSchema schema_;
 };
 
 class XClusterTest : public XClusterTestNoParam,
                      public testing::WithParamInterface<XClusterTestParams> {
  public:
-  XClusterTestParams GetTestParam() override { return GetParam(); }
+  virtual bool UseTransactionalTables() override { return GetParam().transactional_table; }
 };
 
 INSTANTIATE_TEST_CASE_P(
@@ -1632,9 +1579,7 @@ TEST_P(XClusterTest, ApplyOperations) {
 }
 
 class XClusterTestTransactionalOnly : public XClusterTestNoParam {
-  XClusterTestParams GetTestParam() override {
-    return XClusterTestParams(true /* transactional_table */);
-  }
+  virtual bool UseTransactionalTables() override { return true; }
 };
 
 TEST_F(XClusterTestTransactionalOnly, SetupUniverseReplicationWithTLSEncryption) {
diff --git a/src/yb/integration-tests/xcluster/xcluster_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_test_base.cc
index 09a70897c8..144bbeaa94 100644
--- a/src/yb/integration-tests/xcluster/xcluster_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_test_base.cc
@@ -98,19 +98,23 @@ Status XClusterTestBase::InitClusters(const MiniClusterOptions& opts) {
 
   producer_cluster_.mini_cluster_ = std::make_unique<MiniCluster>(producer_opts);
 
+  RETURN_NOT_OK(PreProducerCreate());
   {
     TEST_SetThreadPrefixScoped prefix_se("P");
     RETURN_NOT_OK(producer_cluster()->StartAsync());
   }
+  RETURN_NOT_OK(PostProducerCreate());
 
   auto consumer_opts = opts;
   consumer_opts.cluster_id = "consumer";
   consumer_cluster_.mini_cluster_ = std::make_unique<MiniCluster>(consumer_opts);
 
+  RETURN_NOT_OK(PreConsumerCreate());
   {
     TEST_SetThreadPrefixScoped prefix_se("C");
     RETURN_NOT_OK(consumer_cluster()->StartAsync());
   }
+  RETURN_NOT_OK(PostConsumerCreate());
 
   RETURN_NOT_OK(RunOnBothClusters([](Cluster* cluster) {
     RETURN_NOT_OK(cluster->mini_cluster_->WaitForAllTabletServers());
@@ -259,6 +263,10 @@ Status XClusterTestBase::SetupReverseUniverseReplication(
       producer_tables);
 }
 
+Status XClusterTestBase::SetupUniverseReplication() {
+  return SetupUniverseReplication(producer_tables_);
+}
+
 Status XClusterTestBase::SetupUniverseReplication(
     MiniCluster* producer_cluster, MiniCluster* consumer_cluster, YBClient* consumer_client,
     const cdc::ReplicationGroupId& replication_group_id,
diff --git a/src/yb/integration-tests/xcluster/xcluster_test_base.h b/src/yb/integration-tests/xcluster/xcluster_test_base.h
index 46762d2df1..990882aa23 100644
--- a/src/yb/integration-tests/xcluster/xcluster_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_test_base.h
@@ -21,6 +21,7 @@
 #include "yb/cdc/cdc_types.h"
 
 #include "yb/client/transaction_manager.h"
+#include "yb/client/client.h"
 
 #include "yb/integration-tests/cdc_test_util.h"
 #include "yb/integration-tests/mini_cluster.h"
@@ -67,7 +68,7 @@ class XClusterTestBase : public YBTest {
   class Cluster {
    public:
     std::unique_ptr<MiniCluster> mini_cluster_;
-    std::unique_ptr<YBClient> client_;
+    std::unique_ptr<client::YBClient> client_;
     std::unique_ptr<yb::pgwrapper::PgSupervisor> pg_supervisor_;
     HostPort pg_host_port_;
     boost::optional<client::TransactionManager> txn_mgr_;
@@ -123,7 +124,7 @@ class XClusterTestBase : public YBTest {
     propagation_timeout_ = MonoDelta::FromSeconds(30 * kTimeMultiplier);
   }
 
-  Status PostSetUp();
+  virtual Status PostSetUp();
 
   Result<std::unique_ptr<Cluster>> CreateCluster(
       const std::string& cluster_id, const std::string& cluster_short_name,
@@ -131,6 +132,11 @@ class XClusterTestBase : public YBTest {
 
   virtual Status InitClusters(const MiniClusterOptions& opts);
 
+  virtual Status PreProducerCreate() { return Status::OK(); }
+  virtual Status PostProducerCreate() { return Status::OK(); }
+  virtual Status PreConsumerCreate() { return Status::OK(); }
+  virtual Status PostConsumerCreate() { return Status::OK(); }
+
   void TearDown() override;
 
   Status RunOnBothClusters(std::function<Status(MiniCluster*)> run_on_cluster);
@@ -148,6 +154,7 @@ class XClusterTestBase : public YBTest {
       uint32_t num_tablets, const client::YBSchema* schema);
 
   virtual Status SetupUniverseReplication(const std::vector<std::string>& producer_table_ids);
+  virtual Status SetupUniverseReplication();
 
   virtual Status SetupUniverseReplication(
       const std::vector<std::shared_ptr<client::YBTable>>& producer_tables,
diff --git a/src/yb/integration-tests/xcluster/xcluster_topologies-test.cc b/src/yb/integration-tests/xcluster/xcluster_topologies-test.cc
index 626e495ce6..4568629ada 100644
--- a/src/yb/integration-tests/xcluster/xcluster_topologies-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_topologies-test.cc
@@ -120,23 +120,30 @@ class XClusterTopologiesTest : public XClusterYcqlTestBase {
         Format(
             "Num consumer tables: $0 num producer tables: $1 must be equal.",
             num_consumer_tablets.size(), num_producer_tablets.size()));
-    std::vector<YBTableName> tables;
     for (uint32_t i = 0; i < num_consumer_tablets.size(); i++) {
-      RETURN_NOT_OK(CreateTable(i, num_producer_tablets[i], producer_client(), &tables));
+      auto table_name = VERIFY_RESULT(CreateTable(i, num_producer_tablets[i], producer_client()));
 
       std::shared_ptr<client::YBTable> producer_table;
-      RETURN_NOT_OK(producer_client()->OpenTable(tables[i * 2], &producer_table));
+      RETURN_NOT_OK(producer_client()->OpenTable(table_name, &producer_table));
       producer_tables_[producer_cluster()->GetClusterId()].push_back(producer_table);
 
-      RETURN_NOT_OK(
-          CreateTable(i, num_consumer_tablets[i], consumer_client(), consumer_schema, &tables));
+      table_name = VERIFY_RESULT(
+          CreateTable(i, num_consumer_tablets[i], consumer_client(), consumer_schema));
       std::shared_ptr<client::YBTable> consumer_table;
-      RETURN_NOT_OK(consumer_client()->OpenTable(tables[(i * 2) + 1], &consumer_table));
+      RETURN_NOT_OK(consumer_client()->OpenTable(table_name, &consumer_table));
       consumer_tables_.push_back(consumer_table);
     }
     return Status::OK();
   }
 
+  Status SetUpWithParams(
+      const std::vector<uint32_t>& num_consumer_tablets,
+      const std::vector<uint32_t>& num_producer_tablets, uint32_t replication_factor,
+      uint32_t num_masters, uint32_t num_tservers) override {
+    return STATUS(NotSupported, "Not supported");
+  }
+  Status SetUpWithParams() override { return STATUS(NotSupported, "Not supported"); }
+
   Status SetUpWithParams(
       const std::vector<uint32_t>& num_consumer_tablets,
       const std::vector<uint32_t>& num_producer_tablets, uint32_t replication_factor,
diff --git a/src/yb/integration-tests/xcluster/xcluster_ycql_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ycql_test_base.cc
index a66e96e2c9..7cac3ecc12 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ycql_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ycql_test_base.cc
@@ -62,13 +62,86 @@ using namespace std::literals;
 DECLARE_bool(enable_ysql);
 DECLARE_int32(transaction_table_num_tablets);
 DECLARE_int32(cdc_max_apply_batch_num_records);
+DECLARE_int32(yb_num_shards_per_tserver);
 
 namespace yb {
 
 using OK = Status::OK;
 using client::YBTableName;
 
-void XClusterYcqlTestBase::SetUp() { XClusterTestBase::SetUp(); }
+Status XClusterYcqlTestBase::SetUpWithParams(
+    const std::vector<uint32_t>& num_consumer_tablets,
+    const std::vector<uint32_t>& num_producer_tablets, uint32_t replication_factor,
+    uint32_t num_masters, uint32_t num_tservers) {
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_enable_ysql) = false;
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_transaction_table_num_tablets) = 1;
+  XClusterTestBase::SetUp();
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_yb_num_shards_per_tserver) = 1;
+  num_tservers = std::max(num_tservers, replication_factor);
+
+  MiniClusterOptions opts;
+  opts.num_tablet_servers = num_tservers;
+  opts.num_masters = num_masters;
+  opts.transaction_table_num_tablets = FLAGS_transaction_table_num_tablets;
+  RETURN_NOT_OK(InitClusters(opts));
+
+  RETURN_NOT_OK(clock_->Init());
+  producer_cluster_.txn_mgr_.emplace(producer_client(), clock_, client::LocalTabletFilter());
+  consumer_cluster_.txn_mgr_.emplace(consumer_client(), clock_, client::LocalTabletFilter());
+
+  RETURN_NOT_OK(BuildSchemaAndCreateTables(num_consumer_tablets, num_producer_tablets));
+
+  return PostSetUp();
+}
+
+Status XClusterYcqlTestBase::BuildSchemaAndCreateTables(
+    const std::vector<uint32_t>& num_consumer_tablets,
+    const std::vector<uint32_t>& num_producer_tablets) {
+  client::YBSchemaBuilder b;
+  b.AddColumn("c0")->Type(DataType::INT32)->NotNull()->HashPrimaryKey();
+
+  TableProperties table_properties;
+  table_properties.SetTransactional(UseTransactionalTables());
+  b.SetTableProperties(table_properties);
+  RETURN_NOT_OK(b.Build(&schema_));
+
+  client::YBSchema consumer_schema;
+  table_properties.SetDefaultTimeToLive(0);
+  b.SetTableProperties(table_properties);
+  RETURN_NOT_OK(b.Build(&consumer_schema));
+
+  if (num_consumer_tablets.size() != num_producer_tablets.size()) {
+    return STATUS(
+        IllegalState, Format(
+                          "Num consumer tables: $0 num producer tables: $1 must be equal.",
+                          num_consumer_tablets.size(), num_producer_tablets.size()));
+  }
+
+  RETURN_NOT_OK(RunOnBothClusters([&](Cluster* cluster) -> Status {
+    const auto* num_tablets = &num_producer_tablets;
+    const auto* schema = &schema_;
+    if (cluster == &consumer_cluster_) {
+      num_tablets = &num_consumer_tablets;
+      schema = &consumer_schema;
+    }
+    for (uint32_t i = 0; i < num_tablets->size(); i++) {
+      auto table_name =
+          VERIFY_RESULT(CreateTable(i, num_tablets->at(i), cluster->client_.get(), *schema));
+
+      std::shared_ptr<client::YBTable> table;
+      RETURN_NOT_OK(cluster->client_->OpenTable(table_name, &table));
+      cluster->tables_.emplace_back(std::move(table));
+    }
+    return Status::OK();
+  }));
+
+  return Status::OK();
+}
+
+Status XClusterYcqlTestBase::SetUpWithParams() {
+  // Start with 1 master, 1 tserver, 1 table and 1 tablet.
+  return SetUpWithParams({1}, {1}, 1);
+}
 
 Result<YBTableName> XClusterYcqlTestBase::CreateTable(
     YBClient* client, const std::string& namespace_name, const std::string& table_name,
@@ -76,21 +149,15 @@ Result<YBTableName> XClusterYcqlTestBase::CreateTable(
   return XClusterTestBase::CreateTable(client, namespace_name, table_name, num_tablets, &schema_);
 }
 
-Status XClusterYcqlTestBase::CreateTable(
-    uint32_t idx, uint32_t num_tablets, YBClient* client, std::vector<YBTableName>* tables) {
-  auto table =
-      VERIFY_RESULT(CreateTable(client, namespace_name, Format("test_table_$0", idx), num_tablets));
-  tables->push_back(table);
-  return Status::OK();
+Result<YBTableName> XClusterYcqlTestBase::CreateTable(
+    uint32_t idx, uint32_t num_tablets, YBClient* client) {
+  return CreateTable(idx, num_tablets, client, schema_);
 }
 
-Status XClusterYcqlTestBase::CreateTable(
-    uint32_t idx, uint32_t num_tablets, YBClient* client, client::YBSchema schema,
-    std::vector<YBTableName>* tables) {
-  auto table = VERIFY_RESULT(XClusterTestBase::CreateTable(
-      client, namespace_name, Format("test_table_$0", idx), num_tablets, &schema));
-  tables->push_back(table);
-  return Status::OK();
+Result<YBTableName> XClusterYcqlTestBase::CreateTable(
+    uint32_t idx, uint32_t num_tablets, YBClient* client, const client::YBSchema& schema) {
+  return XClusterTestBase::CreateTable(
+      client, namespace_name, Format("test_table_$0", idx), num_tablets, &schema);
 }
 
 void XClusterYcqlTestBase::WriteWorkload(
diff --git a/src/yb/integration-tests/xcluster/xcluster_ycql_test_base.h b/src/yb/integration-tests/xcluster/xcluster_ycql_test_base.h
index 19b8353227..b353a8eb5e 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ycql_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_ycql_test_base.h
@@ -28,27 +28,24 @@ constexpr int kWaitForRowCountTimeout = 5 * kTimeMultiplier;
 
 class XClusterYcqlTestBase : public XClusterTestBase {
  public:
-  void SetUp() override;
+  virtual ~XClusterYcqlTestBase() = default;
 
-  Result<YBTables> SetUpWithParams(
+  virtual Status SetUpWithParams(
       const std::vector<uint32_t>& num_consumer_tablets,
-      const std::vector<uint32_t>& num_producer_tablets,
-      uint32_t replication_factor,
-      uint32_t num_consumers = 1,
-      uint32_t num_masters = 1,
-      uint32_t num_tservers = 1);
+      const std::vector<uint32_t>& num_producer_tablets, uint32_t replication_factor,
+      uint32_t num_masters = 1, uint32_t num_tservers = 1);
+
+  virtual Status SetUpWithParams();
 
   Result<client::YBTableName> CreateTable(
-      YBClient* client, const std::string& namespace_name, const std::string& table_name,
+      client::YBClient* client, const std::string& namespace_name, const std::string& table_name,
       uint32_t num_tablets);
 
-  Status CreateTable(
-      uint32_t idx, uint32_t num_tablets, YBClient* client,
-      std::vector<client::YBTableName>* tables);
+  Result<client::YBTableName> CreateTable(
+      uint32_t idx, uint32_t num_tablets, client::YBClient* client);
 
-  Status CreateTable(
-      uint32_t idx, uint32_t num_tablets, YBClient* client, client::YBSchema schema,
-      std::vector<client::YBTableName>* tables);
+  Result<client::YBTableName> CreateTable(
+      uint32_t idx, uint32_t num_tablets, YBClient* client, const client::YBSchema& schema);
 
   void WriteWorkload(
       uint32_t start, uint32_t end, YBClient* client, const client::YBTableName& table,
@@ -77,10 +74,17 @@ class XClusterYcqlTestBase : public XClusterTestBase {
       YBClusters* clusters, YBTables* tables, uint32 cluster_id, size_t num_tables,
       uint32_t num_tablets_per_table, bool is_producer, uint32_t num_tservers = 1);
 
- private:
+ protected:
+  virtual bool UseTransactionalTables() { return false; }
+
   server::ClockPtr clock_{new server::HybridClock()};
 
   client::YBSchema schema_;
+
+ private:
+  Status BuildSchemaAndCreateTables(
+      const std::vector<uint32_t>& num_consumer_tablets,
+      const std::vector<uint32_t>& num_producer_tablets);
 };
 
 }  // namespace yb
