diff --git a/src/yb/integration-tests/cdcsdk_ysql-test.cc b/src/yb/integration-tests/cdcsdk_ysql-test.cc
index bdaf32891f..947669cb0e 100644
--- a/src/yb/integration-tests/cdcsdk_ysql-test.cc
+++ b/src/yb/integration-tests/cdcsdk_ysql-test.cc
@@ -7883,8 +7883,7 @@ TEST_F(CDCSDKYsqlTest, YB_DISABLE_TEST_IN_TSAN(TestGetCheckpointOnSnapshotBootst
 TEST_F(CDCSDKYsqlTest, TestTableRewriteOperations) {
   ASSERT_OK(SetUpWithParams(3, 1, false));
   constexpr auto kColumnName = "c1";
-  const auto errstr =
-      "cannot rewrite a table that is a part of CDC or non-automatic mode XCluster replication";
+  const auto errstr = "Cannot rewrite a table that is a part of CDC.";
   auto conn = ASSERT_RESULT(test_cluster_.ConnectToDB(kNamespaceName));
   ASSERT_OK(conn.ExecuteFormat(
       "CREATE TABLE $0(id1 INT PRIMARY KEY, $1 varchar(10))", kTableName, kColumnName));
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc b/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
index 7b84107ad3..efa6426917 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
@@ -122,8 +122,6 @@ using master::GetNamespaceInfoResponsePB;
 
 using pgwrapper::GetValue;
 using pgwrapper::PGConn;
-using pgwrapper::PGResultPtr;
-using pgwrapper::ToString;
 
 static const client::YBTableName producer_transaction_table_name(
     YQL_DATABASE_CQL, master::kSystemNamespaceName, kGlobalTransactionsTableName);
@@ -2663,7 +2661,7 @@ TEST_F(XClusterYsqlTest, TestTableRewriteOperations) {
   ASSERT_OK(SetUpWithParams({1}, {1}, 3, 1));
   constexpr auto kColumnName = "c1";
   const auto errstr =
-      "cannot rewrite a table that is a part of CDC or non-automatic mode XCluster replication";
+      "Cannot rewrite a table that is a part of non-automatic mode XCluster replication.";
   ASSERT_OK(SetupUniverseReplication(producer_tables_));
   for (int i = 0; i <= 1; ++i) {
     auto conn = i == 0 ? EXPECT_RESULT(producer_cluster_.ConnectToDB(namespace_name))
@@ -3248,4 +3246,95 @@ TEST_F(XClusterYSqlTestConsistentTransactionsTest, CreateDropTableAndIndexWithPI
   ASSERT_OK(VerifyWrittenRecords());
 }
 
+// Test commands that trigger nonconcurrent backfills.
+// Want to ensure that these are disallowed since when these backfills run on the target, it will
+// produce duplicate rows.
+TEST_F(XClusterYsqlTest, NonconcurrentBackfills) {
+  const auto kNumTablets = 1;
+  ASSERT_OK(SetUpWithParams({kNumTablets}, {kNumTablets}, /* replication_factor */ 1));
+  ASSERT_OK(SetupUniverseReplication({producer_table_}));
+
+  ASSERT_OK(InsertRowsInProducer(0, 10, producer_table_));
+  ASSERT_OK(VerifyWrittenRecords());
+
+  auto p_conn =
+      EXPECT_RESULT(producer_cluster_.ConnectToDB(producer_table_->name().namespace_name()));
+  const auto table_name = GetCompleteTableName(producer_table_->name());
+
+  const auto expected_error =
+      "Cannot create nonconcurrent index on a table that is a part of non-automatic mode XCluster "
+      "replication.";
+
+  // Create index nonconcurrently.
+  ASSERT_NOK_STR_CONTAINS(
+      p_conn.ExecuteFormat(
+          "CREATE INDEX NONCONCURRENTLY nonconcurrent_index ON $0($1 ASC)", table_name,
+          kKeyColumnName),
+      expected_error);
+
+  // Create unique index nonconcurrently.
+  ASSERT_NOK_STR_CONTAINS(
+      p_conn.ExecuteFormat(
+          "CREATE UNIQUE INDEX NONCONCURRENTLY ON $0($1)", table_name, kKeyColumnName),
+      expected_error);
+
+  // Test adding a unique constraint, this will also trigger a nonconcurrent backfill.
+  ASSERT_NOK_STR_CONTAINS(
+      p_conn.ExecuteFormat(
+          "ALTER TABLE $0 ADD CONSTRAINT unique_constraint UNIQUE($1);", table_name,
+          kKeyColumnName),
+      expected_error);
+
+  // Partitioned table checks.
+  const auto kPartitionedTableName = "partitioned_table";
+  const auto kPartitionedIndexName = "partitioned_index";
+  const auto kPartition1Name = Format("$0_p1", kPartitionedTableName);
+  const auto kPartition2Name = Format("$0_p2", kPartitionedTableName);
+  const std::string kColumn2Name = "a";
+
+  auto create_partitioned_table = [&](pgwrapper::PGConn& conn) {
+    ASSERT_OK(conn.ExecuteFormat(
+        "CREATE TABLE $0 ($1 int PRIMARY KEY, $2 int) PARTITION BY RANGE ($1);",
+        kPartitionedTableName, kKeyColumnName, kColumn2Name));
+    ASSERT_OK(conn.ExecuteFormat(
+        "CREATE TABLE $0 PARTITION OF $1 FOR VALUES FROM (0) TO (100);", kPartition1Name,
+        kPartitionedTableName));
+    ASSERT_OK(conn.ExecuteFormat(
+        "CREATE TABLE $0 PARTITION OF $1 FOR VALUES FROM (100) TO (200);", kPartition2Name,
+        kPartitionedTableName));
+  };
+  ASSERT_NO_FATALS(create_partitioned_table(p_conn));
+  auto c_conn = ASSERT_RESULT(consumer_cluster_.ConnectToDB(namespace_name));
+  ASSERT_NO_FATALS(create_partitioned_table(c_conn));
+
+  auto partition1_name =
+      ASSERT_RESULT(GetYsqlTable(&producer_cluster_, namespace_name, "public", kPartition1Name));
+  auto partition2_name =
+      ASSERT_RESULT(GetYsqlTable(&producer_cluster_, namespace_name, "public", kPartition2Name));
+  std::shared_ptr<client::YBTable> partition1_table, partition2_table;
+  ASSERT_OK(producer_client()->OpenTable(partition1_name, &partition1_table));
+  ASSERT_OK(producer_client()->OpenTable(partition2_name, &partition2_table));
+
+  ASSERT_OK(AlterUniverseReplication(
+      kReplicationGroupId, {partition1_table, partition2_table}, true /* add_tables */));
+
+  ASSERT_OK(p_conn.ExecuteFormat(
+      "INSERT INTO $0 SELECT i, i%2 FROM generate_series(51, 150) as i;", kPartitionedTableName));
+
+  // Create partitioned index on the parent, this will cause nonconcurrent index creates on the
+  // partitions.
+  ASSERT_NOK_STR_CONTAINS(
+      p_conn.ExecuteFormat(
+          "CREATE INDEX $0 ON $1($2 ASC);", kPartitionedIndexName, kPartitionedTableName,
+          kColumn2Name),
+      expected_error);
+
+  // Also verify that we cannot create a unique index on the partitioned table.
+  ASSERT_NOK_STR_CONTAINS(
+      p_conn.ExecuteFormat(
+          "CREATE UNIQUE INDEX ON $0($1, $2);", kPartitionedTableName, kKeyColumnName,
+          kColumn2Name),
+      expected_error);
+}
+
 }  // namespace yb
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 0785995df3..22a9cbed74 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -495,10 +495,6 @@ DEFINE_test_flag(bool, keep_docdb_table_on_ysql_drop_table, false,
 DEFINE_RUNTIME_int32(max_concurrent_delete_replica_rpcs_per_ts, 50,
     "The maximum number of outstanding DeleteReplica RPCs sent to an individual tserver.");
 
-DEFINE_RUNTIME_bool(
-    enable_truncate_cdcsdk_table, false,
-    "When set, enables truncating tables currently part of a CDCSDK Stream");
-
 DEFINE_RUNTIME_bool(enable_tablet_split_of_cdcsdk_streamed_tables, true,
     "When set, it enables automatic tablet splitting for tables that are part of a "
     "CDCSDK stream");
@@ -589,11 +585,10 @@ DEFINE_NON_RUNTIME_bool(emergency_repair_mode, false,
 TAG_FLAG(emergency_repair_mode, advanced);
 TAG_FLAG(emergency_repair_mode, unsafe);
 
-DECLARE_bool(ysql_yb_enable_replica_identity);
-
 DECLARE_bool(enable_pg_cron);
-
+DECLARE_bool(enable_truncate_cdcsdk_table);
 DECLARE_bool(TEST_enable_object_locking_for_table_locks);
+DECLARE_bool(ysql_yb_enable_replica_identity);
 
 namespace yb {
 namespace master {
@@ -3901,22 +3896,8 @@ Status CatalogManager::CreateTable(const CreateTableRequestPB* orig_req,
     return result;
   }
 
-  if (!orig_req->old_rewrite_table_id().empty()) {
-    auto table_id = orig_req->old_rewrite_table_id();
-    auto namespace_id = VERIFY_RESULT(GetTableById(table_id))->LockForRead()->namespace_id();
-    auto automatic_ddl_mode = xcluster_manager_->IsNamespaceInAutomaticDDLMode(namespace_id);
-    SharedLock lock(mutex_);
-    // Fail rewrites on tables that are part of CDC or non-automatic mode XCluster replication,
-    // except for TRUNCATEs on CDC tables when FLAGS_enable_truncate_cdcsdk_table is enabled.
-    if ((xcluster_manager_->IsTableReplicated(table_id) && !automatic_ddl_mode)  ||
-        (IsTablePartOfCDCSDK(table_id) &&
-         (!orig_req->is_truncate() || !FLAGS_enable_truncate_cdcsdk_table))) {
-      return STATUS(
-          NotSupported,
-          "cannot rewrite a table that is a part of CDC or non-automatic mode XCluster replication"
-          " See https://github.com/yugabyte/yugabyte-db/issues/16625.");
-    }
-  }
+  RETURN_NOT_OK(xcluster_manager_->ValidateCreateTableRequest(*orig_req));
+  RETURN_NOT_OK(CDCSDKValidateCreateTableRequest(*orig_req));
 
   // Copy the request, so we can fill in some defaults.
   CreateTableRequestPB req = *orig_req;
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index 7e510f68e6..8be765d650 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -2417,6 +2417,8 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
     int num_tablets, const ReplicationInfoPB& replication_info,
     const TSDescriptorVector& ts_descs);
 
+  Status CDCSDKValidateCreateTableRequest(const CreateTableRequestPB& req);
+
  private:
   friend class yb::master::ClusterLoadBalancer;
   friend class CDCStreamLoader;
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index 30e89adf56..bf735be7b0 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -21,6 +21,7 @@
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master_cluster.pb.h"
+#include "yb/master/master_ddl.pb.h"
 #include "yb/master/master_heartbeat.pb.h"
 #include "yb/master/master_replication.pb.h"
 #include "yb/master/xcluster/master_xcluster_util.h"
@@ -991,4 +992,29 @@ Status XClusterManager::ProcessCreateTableReq(
   return XClusterTargetManager::ProcessCreateTableReq(req, table_pb, table_id, namespace_id);
 }
 
+Status XClusterManager::ValidateCreateTableRequest(const CreateTableRequestPB& req) {
+  TableId table_id;
+  std::string error_str;
+  if (!req.old_rewrite_table_id().empty()) {
+    table_id = req.old_rewrite_table_id();
+    error_str = "Cannot rewrite a table that is a part of non-automatic mode XCluster replication.";
+  } else if (IsIndex(req) && req.skip_index_backfill()) {
+    table_id = req.indexed_table_id();
+    error_str =
+        "Cannot create nonconcurrent index on a table that is a part of non-automatic mode "
+        "XCluster replication.";
+  } else {
+    return Status::OK();
+  }
+
+  const auto namespace_id =
+      VERIFY_RESULT(catalog_manager_.GetTableById(table_id))->LockForRead()->namespace_id();
+
+  SCHECK(
+      !IsTableReplicated(table_id) || IsNamespaceInAutomaticDDLMode(namespace_id), NotSupported,
+      error_str);
+
+  return Status::OK();
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_manager.h b/src/yb/master/xcluster/xcluster_manager.h
index c9068467f3..df51714f5b 100644
--- a/src/yb/master/xcluster/xcluster_manager.h
+++ b/src/yb/master/xcluster/xcluster_manager.h
@@ -302,6 +302,8 @@ class XClusterManager : public XClusterManagerIf,
       const CreateTableRequestPB& req, SysTablesEntryPB& table_pb, const TableId& table_id,
       const NamespaceId& namespace_id) const;
 
+  Status ValidateCreateTableRequest(const CreateTableRequestPB& req);
+
  private:
   CatalogManager& catalog_manager_;
   SysCatalogTable& sys_catalog_;
diff --git a/src/yb/master/xrepl_catalog_manager.cc b/src/yb/master/xrepl_catalog_manager.cc
index d9b3c94da8..3454f46526 100644
--- a/src/yb/master/xrepl_catalog_manager.cc
+++ b/src/yb/master/xrepl_catalog_manager.cc
@@ -140,6 +140,9 @@ DEFINE_test_flag(bool, cdcsdk_skip_table_removal_from_qualified_list, false,
                  "When enabled, table would not be removed from the qualified table list as part "
                  "of the table removal process from CDC stream");
 
+DEFINE_RUNTIME_bool(enable_truncate_cdcsdk_table, false,
+    "When set, enables truncating tables currently part of a CDCSDK Stream");
+
 DECLARE_int32(master_rpc_timeout_ms);
 DECLARE_bool(ysql_yb_enable_replication_commands);
 DECLARE_bool(ysql_yb_allow_replication_slot_lsn_types);
@@ -5342,5 +5345,18 @@ void CatalogManager::RemoveUniverseReplicationFromMap(
   }
 }
 
+Status CatalogManager::CDCSDKValidateCreateTableRequest(const CreateTableRequestPB& req) {
+  // Fail rewrites on tables, and nonconcurrent index backfills, that are part of CDC, except for
+  // TRUNCATEs when FLAGS_enable_truncate_cdcsdk_table is enabled.
+  SharedLock lock(mutex_);
+  const auto table_id = req.old_rewrite_table_id();
+  if (table_id.empty() || !IsTablePartOfCDCSDK(table_id) ||
+      (req.is_truncate() && FLAGS_enable_truncate_cdcsdk_table)) {
+    return Status::OK();
+  }
+
+  return STATUS(NotSupported, "Cannot rewrite a table that is a part of CDC.");
+}
+
 }  // namespace master
 }  // namespace yb
