diff --git a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
index e1be16db2b..2991c51d1e 100644
--- a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
@@ -246,4 +246,64 @@ TEST_F(YsqlMajorUpgradeDdlBlockingTest, CreateAndDropDBs) {
   ASSERT_OK(InsertRowInSimpleTableAndValidate());
 }
 
+// Make sure in-flight DDL transactions are killed by the upgrade.
+TEST_F(YsqlMajorUpgradeDdlBlockingTest, KillInFlightDDLs) {
+  TestThreadHolder thread_holder;
+
+  // Create table with a comment.
+  auto conn = ASSERT_RESULT(cluster_->ConnectToDB());
+  ASSERT_OK(conn.Execute("CREATE TABLE tbl1 (a int)"));
+  ASSERT_OK(conn.Execute("COMMENT on TABLE tbl1 IS 'Hi'"));
+  auto oid = ASSERT_RESULT(
+      conn.FetchRow<pgwrapper::PGOid>("SELECT oid FROM pg_class WHERE relname = 'tbl1'"));
+
+  // Create index, but block it before indisvalid is set.
+  ASSERT_OK(cluster_->SetFlagOnTServers("ysql_yb_test_block_index_phase", "postbackfill"));
+  Status index_creation_status;
+  std::promise<Status> index_creation_promise;
+  auto index_creation_future = index_creation_promise.get_future();
+  thread_holder.AddThreadFunctor([this, &index_creation_promise] {
+    auto conn = ASSERT_RESULT(cluster_->ConnectToDB());
+    index_creation_promise.set_value(conn.Execute("CREATE INDEX idx1 ON tbl1 (a)"));
+  });
+
+  // Update the comment field in a transaction.
+  ASSERT_OK(conn.Execute("SET yb_non_ddl_txn_for_sys_tables_allowed=true"));
+  ASSERT_OK(conn.Execute("BEGIN"));
+  ASSERT_OK(
+      conn.ExecuteFormat("UPDATE pg_description SET description = 'Bye' WHERE objoid = $0", oid));
+  const auto check_comment = [&conn, oid](const std::string& expected_comment) -> Status {
+    auto comment = VERIFY_RESULT(conn.FetchRow<std::string>(
+        Format("SELECT description from pg_description WHERE objoid = $0", oid)));
+    SCHECK_EQ(comment, expected_comment, IllegalState, "Unexpected comment");
+    return Status::OK();
+  };
+
+  // Validate connections before yb-master restart.
+  ASSERT_OK(check_comment("Bye"));
+  ASSERT_EQ(index_creation_future.wait_for(0s), std::future_status::timeout);
+
+  // Wait for the index creation to be blocked.
+  SleepFor(10s);
+
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
+
+  // yb-master restart should not affect in-flight DDLs.
+  ASSERT_OK(check_comment("Bye"));
+  ASSERT_EQ(index_creation_future.wait_for(0s), std::future_status::timeout);
+
+  // Upgrade YSQL catalog.
+  ASSERT_OK(PerformYsqlMajorCatalogUpgrade());
+
+  // DDLs should be killed by the upgrade.
+  ASSERT_NOK_STR_CONTAINS(conn.Execute("COMMIT"), "current transaction is expired or aborted");
+
+  ASSERT_OK(cluster_->SetFlagOnTServers("ysql_yb_test_block_index_phase", "none"));
+  ASSERT_EQ(index_creation_future.wait_for(5min), std::future_status::ready);
+  ASSERT_NOK_STR_CONTAINS(index_creation_future.get(), kExpectedDdlError);
+
+  // Validate rollback of the DDL.
+  ASSERT_OK(check_comment("Hi"));
+}
+
 }  // namespace yb
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 6538b522c5..8a1809cad0 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -9164,16 +9164,13 @@ void CatalogManager::DeleteYsqlDatabaseAsync(
     if (metadata.state() == SysNamespaceEntryPB::DELETED) {
       Status s = sys_catalog_->Delete(leader_ready_term(), database);
       WARN_NOT_OK(s, "SysCatalog DeleteItem for Namespace");
-      if (!s.ok()) {
-        return;
-      }
+      return;
     }
 
     if (is_ysql_major_upgrade) {
       if (metadata.state() != SysNamespaceEntryPB::RUNNING) {
-        // YB_TODO: Switch this to DFATAL once #25594 is fixed.
-        LOG(WARNING) << "Namespace (" << database->name() << ") has invalid state "
-                     << SysNamespaceEntryPB::State_Name(metadata.state());
+        LOG(DFATAL) << "Namespace (" << database->name() << ") has invalid state "
+                    << SysNamespaceEntryPB::State_Name(metadata.state());
         return;
       }
       if (metadata.ysql_next_major_version_state() != SysNamespaceEntryPB::NEXT_VER_DELETING) {
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
index b62238ab33..14d1223bc8 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
@@ -303,6 +303,9 @@ void YsqlInitDBAndMajorUpgradeHandler::RunMajorVersionUpgrade(const LeaderEpoch&
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::RunMajorVersionUpgradeImpl(const LeaderEpoch& epoch) {
+  LOG(INFO) << "Killing any in-flight transactions before starting the YSQL major catalog upgrade";
+  sys_catalog_.tablet_peer()->AbortActiveTransactions();
+
   RETURN_NOT_OK(RunMajorVersionCatalogUpgrade(epoch));
   RETURN_NOT_OK_PREPEND(UpdateCatalogVersions(epoch), "Failed to update catalog versions");
 
diff --git a/src/yb/tablet/tablet.cc b/src/yb/tablet/tablet.cc
index bfee3ee4b4..115687ecd7 100644
--- a/src/yb/tablet/tablet.cc
+++ b/src/yb/tablet/tablet.cc
@@ -5072,8 +5072,8 @@ std::string IncrementedCopy(Slice key) {
 
 } // namespace
 
-Status Tablet::AbortSQLTransactions(CoarseTimePoint deadline) const {
-  if (table_type() != TableType::PGSQL_TABLE_TYPE || transaction_participant() == nullptr) {
+Status Tablet::AbortActiveTransactions(CoarseTimePoint deadline) const {
+  if (transaction_participant() == nullptr) {
     return Status::OK();
   }
   HybridTime max_cutoff = HybridTime::kMax;
diff --git a/src/yb/tablet/tablet.h b/src/yb/tablet/tablet.h
index eb98e14361..fb76d2501b 100644
--- a/src/yb/tablet/tablet.h
+++ b/src/yb/tablet/tablet.h
@@ -967,7 +967,7 @@ class Tablet : public AbstractTablet,
         max_key_length, std::move(callback), colocated_table_id);
   }
 
-  Status AbortSQLTransactions(CoarseTimePoint deadline) const;
+  Status AbortActiveTransactions(CoarseTimePoint deadline) const;
 
   // TODO: Move mutex to private section.
   // Lock used to serialize the creation of RocksDB checkpoints.
diff --git a/src/yb/tablet/tablet_peer.cc b/src/yb/tablet/tablet_peer.cc
index 1c10a8eb5c..06c75e37be 100644
--- a/src/yb/tablet/tablet_peer.cc
+++ b/src/yb/tablet/tablet_peer.cc
@@ -615,7 +615,7 @@ Status TabletPeer::Shutdown(
     // Once raft group state enters QUIESCING state,
     // new queries cannot be processed from then onwards.
     // Aborting any remaining active transactions in the tablet.
-    AbortSQLTransactions();
+    AbortActiveTransactions();
   }
 
   if (is_shutdown_initiated) {
@@ -626,14 +626,14 @@ Status TabletPeer::Shutdown(
   return Status::OK();
 }
 
-void TabletPeer::AbortSQLTransactions() const {
+void TabletPeer::AbortActiveTransactions() const {
   if (!tablet_) {
     return;
   }
   auto deadline =
       CoarseMonoClock::Now() + MonoDelta::FromMilliseconds(FLAGS_ysql_transaction_abort_timeout_ms);
   WARN_NOT_OK(
-      tablet_->AbortSQLTransactions(deadline),
+      tablet_->AbortActiveTransactions(deadline),
       "Cannot abort transactions for tablet " + tablet_->tablet_id());
 }
 
@@ -1102,7 +1102,7 @@ Result<std::pair<OpId, HybridTime>> TabletPeer::GetOpIdAndSafeTimeForXReplBootst
   auto op_id = GetLatestLogEntryOpId();
 
   // The bootstrap_time is the minium time from which the provided OpId will be transactionally
-  // consistent. It is important to call AbortSQLTransactions, which resolves the pending
+  // consistent. It is important to call AbortActiveTransactions, which resolves the pending
   // transactions and aborts the active ones. This step synchronizes our clock with the
   // transaction status tablet clock, ensuring that the bootstrap_time we compute later is correct.
   // Ex: Our safe time is 100, and we have a pending intent for which the log got GCed. So this
@@ -1110,7 +1110,7 @@ Result<std::pair<OpId, HybridTime>> TabletPeer::GetOpIdAndSafeTimeForXReplBootst
   // If, the coordinator is at 110 and the transaction was committed at 105. We need to move our
   // clock to 110 and pick a higher bootstrap_time so that the commit is not part of the bootstrap.
   if (GetAtomicFlag(&FLAGS_abort_active_txns_during_xrepl_bootstrap)) {
-    AbortSQLTransactions();
+    AbortActiveTransactions();
   }
   auto bootstrap_time = VERIFY_RESULT(tablet->SafeTime(RequireLease::kTrue));
   return std::make_pair(std::move(op_id), std::move(bootstrap_time));
diff --git a/src/yb/tablet/tablet_peer.h b/src/yb/tablet/tablet_peer.h
index e3059123b3..d4090ca5e0 100644
--- a/src/yb/tablet/tablet_peer.h
+++ b/src/yb/tablet/tablet_peer.h
@@ -187,7 +187,7 @@ class TabletPeer : public std::enable_shared_from_this<TabletPeer>,
   void CompleteShutdown(DisableFlushOnShutdown disable_flush_on_shutdown, AbortOps abort_ops);
 
   // Abort active transactions on the tablet after shutdown is initiated.
-  void AbortSQLTransactions() const;
+  void AbortActiveTransactions() const;
 
   Status Shutdown(
       ShouldAbortActiveTransactions should_abort_active_txns,
diff --git a/src/yb/tablet/tablet_snapshots.cc b/src/yb/tablet/tablet_snapshots.cc
index 8c594be89f..a302f8d0db 100644
--- a/src/yb/tablet/tablet_snapshots.cc
+++ b/src/yb/tablet/tablet_snapshots.cc
@@ -351,7 +351,7 @@ Status TabletSnapshots::Restore(SnapshotOperation* operation) {
       CoarseMonoClock::Now() +
       MonoDelta::FromMilliseconds(FLAGS_max_wait_for_aborting_transactions_during_restore_ms);
   WARN_NOT_OK(
-      tablet().AbortSQLTransactions(deadline),
+      tablet().AbortActiveTransactions(deadline),
       Format("Cannot abort transactions for tablet $0 during restore", tablet().tablet_id()));
 
   if (!snapshot_dir.empty()) {
diff --git a/src/yb/tserver/read_query.cc b/src/yb/tserver/read_query.cc
index dfdce1e4f8..125d7f29c3 100644
--- a/src/yb/tserver/read_query.cc
+++ b/src/yb/tserver/read_query.cc
@@ -256,9 +256,7 @@ Status ReadQuery::DoPerform() {
   // Get the most restrictive row mark present in the batch of PostgreSQL requests.
   // TODO: rather handle individual row marks once we start batching read requests (issue #2495)
   auto batch_row_mark = RowMarkType::ROW_MARK_ABSENT;
-  CatalogVersionChecker catalog_version_checker(server_);
   for (const auto& pg_req : req_->pgsql_batch()) {
-    RETURN_NOT_OK(catalog_version_checker(pg_req));
     auto current_row_mark = GetRowMarkTypeFromPB(pg_req);
     if (IsValidRowMarkType(current_row_mark)) {
       if (!req_->has_transaction()) {
@@ -290,6 +288,11 @@ Status ReadQuery::DoPerform() {
     leader_peer.leader_term = OpId::kUnknownTerm;
   }
 
+  CatalogVersionChecker catalog_version_checker(server_);
+  for (const auto& pg_req : req_->pgsql_batch()) {
+    RETURN_NOT_OK(catalog_version_checker(pg_req));
+  }
+
   if (req_->consistency_level() == YBConsistencyLevel::CONSISTENT_PREFIX) {
     if (abstract_tablet_) {
       tablet()->metrics()->Increment(
