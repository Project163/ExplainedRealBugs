diff --git a/src/yb/client/auto_flags_manager.cc b/src/yb/client/auto_flags_manager.cc
index 97f7c7aa05..66d6942df1 100644
--- a/src/yb/client/auto_flags_manager.cc
+++ b/src/yb/client/auto_flags_manager.cc
@@ -29,11 +29,12 @@
 #include "yb/util/net/net_util.h"
 #include "yb/util/flags.h"
 #include "yb/util/logging.h"
+#include "yb/util/scope_exit.h"
+#include "yb/util/source_location.h"
+#include "yb/util/thread_restrictions.h"
 #include "yb/util/version_info.h"
 
-using std::string;
-
-DEFINE_UNKNOWN_bool(disable_auto_flags_management, false,
+DEFINE_NON_RUNTIME_bool(disable_auto_flags_management, false,
     "Disables AutoFlags management. A safety switch to turn off automatic promotion of AutoFlags. "
     "More information about AutoFlags can be found in "
     "https://github.com/yugabyte/yugabyte-db/blob/master/architecture/design/auto_flags.md. Use at "
@@ -49,74 +50,33 @@ DEFINE_RUNTIME_AUTO_bool(TEST_auto_flags_new_install, kNewInstallsOnly, false, t
     "AutoFlag that indicates initialization of AutoFlags for new installs only.");
 TAG_FLAG(TEST_auto_flags_new_install, hidden);
 
-DEFINE_UNKNOWN_int32(auto_flags_load_from_master_backoff_increment_ms, 100,
+DEFINE_NON_RUNTIME_int32(auto_flags_load_from_master_backoff_increment_ms, 100,
     "Number of milliseconds added to the delay between reties of fetching AutoFlags config from "
     "master leader. This delay is applied after the RPC reties have been exhausted.");
 TAG_FLAG(auto_flags_load_from_master_backoff_increment_ms, stable);
 TAG_FLAG(auto_flags_load_from_master_backoff_increment_ms, advanced);
 
-DEFINE_UNKNOWN_int32(auto_flags_load_from_master_max_backoff_sec, 3,
+DEFINE_NON_RUNTIME_int32(auto_flags_load_from_master_max_backoff_sec, 3,
     "Maximum number of seconds to delay between reties of fetching AutoFlags config from master "
     "leader. This delay is applied after the RPC reties have been exhausted.");
 TAG_FLAG(auto_flags_load_from_master_max_backoff_sec, stable);
 TAG_FLAG(auto_flags_load_from_master_max_backoff_sec, advanced);
 
+DEFINE_RUNTIME_uint32(auto_flags_apply_delay_ms, 10000,
+    "Number of milliseconds after which a new AutoFlag config is applied. yb-tservers that have "
+    "not heartbeated to yb-master within this duration cannot replicate data to XCluster targets. "
+    "The value must be at least twice the heartbeat_interval_ms.");
+TAG_FLAG(auto_flags_apply_delay_ms, stable);
+TAG_FLAG(auto_flags_apply_delay_ms, advanced);
+
 DECLARE_bool(TEST_running_test);
 DECLARE_int32(yb_client_admin_operation_timeout_sec);
+DECLARE_uint64(max_clock_skew_usec);
 
 namespace yb {
 
 namespace {
 
-class AutoFlagClient {
- public:
-  Status Init(
-      const string& local_hosts, const string& master_addresses, const FsManager& fs_manager) {
-    rpc::MessengerBuilder messenger_builder("auto_flags_client");
-    secure_context_ = VERIFY_RESULT(
-        server::SetupInternalSecureContext(local_hosts, fs_manager, &messenger_builder));
-
-    messenger_ = VERIFY_RESULT(messenger_builder.Build());
-
-    if (PREDICT_FALSE(FLAGS_TEST_running_test)) {
-      std::vector<HostPort> host_ports;
-      RETURN_NOT_OK(HostPort::ParseStrings(local_hosts, 0 /* default_port */, &host_ports));
-      messenger_->TEST_SetOutboundIpBase(VERIFY_RESULT(HostToAddress(host_ports[0].host())));
-    }
-
-    client_ = VERIFY_RESULT(yb::client::YBClientBuilder()
-                                .add_master_server_addr(master_addresses)
-                                .default_admin_operation_timeout(MonoDelta::FromSeconds(
-                                    FLAGS_yb_client_admin_operation_timeout_sec))
-                                .Build(messenger_.get()));
-
-    return Status::OK();
-  }
-
-  client::YBClient* operator->() { return client_.get(); }
-
-  ~AutoFlagClient() {
-    if (messenger_) {
-      messenger_->Shutdown();
-    }
-  }
-
- private:
-  std::unique_ptr<rpc::SecureContext> secure_context_;
-  std::unique_ptr<rpc::Messenger> messenger_;
-  std::shared_ptr<client::YBClient> client_;
-};
-
-// Get the AutoFlagConfig from master. Returns std::nullopt if master is runnning on an older
-// version that does not support AutoFlags.
-Result<std::optional<AutoFlagsConfigPB>> GetAutoFlagConfigFromMaster(
-    const string& local_hosts, const string& master_addresses, const FsManager& fs_manager) {
-  AutoFlagClient af_client;
-  RETURN_NOT_OK(af_client.Init(local_hosts, master_addresses, fs_manager));
-
-  return af_client->GetAutoFlagConfig();
-}
-
 std::unordered_set<std::string> GetPerProcessFlags(
     const ProcessName& process_name, const AutoFlagsConfigPB& config) {
   std::unordered_set<std::string> flags;
@@ -134,11 +94,37 @@ std::unordered_set<std::string> GetPerProcessFlags(
 
 }  // namespace
 
-AutoFlagsManager::AutoFlagsManager(const string& process_name, FsManager* fs_manager)
-    : process_name_(process_name), fs_manager_(fs_manager) {
+AutoFlagsManager::AutoFlagsManager(
+    const std::string& process_name, const scoped_refptr<ClockBase>& clock, FsManager* fs_manager)
+    : process_name_(process_name),
+      clock_(clock),
+      fs_manager_(fs_manager),
+      update_lock_(mutex_, std::defer_lock) {
   // google::ProgramInvocationShortName() cannot be used for process_name as it will return the test
   // name in MiniCluster tests.
-  current_config_.set_config_version(0);
+  current_config_.set_config_version(kInvalidAutoFlagsConfigVersion);
+}
+
+AutoFlagsManager::~AutoFlagsManager() {
+  if (messenger_) {
+    messenger_->Shutdown();
+  }
+}
+
+Status AutoFlagsManager::Init(const std::string& local_hosts) {
+  rpc::MessengerBuilder messenger_builder("auto_flags_client");
+  secure_context_ = VERIFY_RESULT(
+      server::SetupInternalSecureContext(local_hosts, *fs_manager_, &messenger_builder));
+
+  messenger_ = VERIFY_RESULT(messenger_builder.Build());
+
+  if (PREDICT_FALSE(FLAGS_TEST_running_test)) {
+    std::vector<HostPort> host_ports;
+    RETURN_NOT_OK(HostPort::ParseStrings(local_hosts, 0 /* default_port */, &host_ports));
+    messenger_->TEST_SetOutboundIpBase(VERIFY_RESULT(HostToAddress(host_ports[0].host())));
+  }
+
+  return Status::OK();
 }
 
 Result<bool> AutoFlagsManager::LoadFromFile() {
@@ -159,16 +145,27 @@ Result<bool> AutoFlagsManager::LoadFromFile() {
     return status;
   }
 
-  current_config_ = std::move(pb_config);
+  auto valid = VERIFY_RESULT(ValidateAndSetConfig(std::move(pb_config)));
+  RSTATUS_DCHECK(valid, IllegalState, "AutoFlags config loaded from disk failed to get set");
 
   RETURN_NOT_OK(ApplyConfig(ApplyNonRuntimeAutoFlags::kTrue));
 
   return true;
 }
 
+Result<std::optional<AutoFlagsConfigPB>> AutoFlagsManager::GetAutoFlagConfigFromMaster(
+    const std::string& master_addresses) {
+  auto client = VERIFY_RESULT(yb::client::YBClientBuilder()
+                                  .add_master_server_addr(master_addresses)
+                                  .default_admin_operation_timeout(MonoDelta::FromSeconds(
+                                      FLAGS_yb_client_admin_operation_timeout_sec))
+                                  .Build(messenger_.get()));
+
+  return client->GetAutoFlagConfig();
+}
+
 Status AutoFlagsManager::LoadFromMaster(
-    const string& local_hosts, const server::MasterAddresses& master_addresses,
-    ApplyNonRuntimeAutoFlags apply_non_runtime) {
+    const std::string& local_hosts, const server::MasterAddresses& master_addresses) {
   if (FLAGS_disable_auto_flags_management) {
     LOG(WARNING) << "AutoFlags management is disabled.";
     return Status::OK();
@@ -187,6 +184,8 @@ Status AutoFlagsManager::LoadFromMaster(
       !master_addresses_str.empty(), InvalidArgument,
       "No master address found to initialize AutoFlags.");
 
+  // Get lock early to make sure we dont send multiple RPCs to master leader.
+  std::lock_guard l(mutex_);
   LOG(INFO) << "Loading AutoFlags from master leader. Master addresses: [" << master_addresses_str
             << "]";
 
@@ -199,9 +198,9 @@ Status AutoFlagsManager::LoadFromMaster(
   auto delay_time = delay_increment;
 
   uint32_t attempts = 1;
-  auto start_time = CoarseMonoClock::Now();
+  auto start_time = clock_->Now();
   while (true) {
-    auto res = GetAutoFlagConfigFromMaster(local_hosts, master_addresses_str, *fs_manager_);
+    auto res = GetAutoFlagConfigFromMaster(master_addresses_str);
     if (res.ok()) {
       if (res->has_value()) {
         new_config = std::move(res->value());
@@ -210,15 +209,16 @@ Status AutoFlagsManager::LoadFromMaster(
         // Use a empty config. Once master leader is upgraded to a supported version, it will send
         // the new config through the WAL to other masters and through heartbeats to tservers.
         LOG(INFO) << "AutoFlags not yet initialized on master. Defaulting to empty config.";
-        new_config.set_config_version(0);
+        new_config.set_config_version(kInvalidAutoFlagsConfigVersion);
       }
 
       break;
     }
 
     LOG(WARNING) << "Loading AutoFlags from master Leader failed: '" << res.status()
-                 << "'. Attempts: " << attempts
-                 << ", Total Time: " << CoarseMonoClock::Now() - start_time << ". Retrying...";
+                 << "'. Attempts: " << attempts << ", Total Time: "
+                 << clock_->Now().PhysicalDiff(start_time) / MonoTime::kMicrosecondsPerMillisecond
+                 << "ms. Retrying...";
 
     // Delay before retrying so that we don't accidentally DDoS the mater.
     // Time increases linearly by delay_increment up to max_delay.
@@ -227,33 +227,55 @@ Status AutoFlagsManager::LoadFromMaster(
     attempts++;
   }
 
-  return LoadFromConfig(std::move(new_config), apply_non_runtime);
+  // Synchronously load the config.
+  return LoadFromConfigUnlocked(
+      std::move(new_config), ApplyNonRuntimeAutoFlags::kTrue, /* apply_sync */ true);
 }
 
-Status AutoFlagsManager::LoadFromConfig(
-    const AutoFlagsConfigPB new_config, ApplyNonRuntimeAutoFlags apply_non_runtime) {
-  if (FLAGS_disable_auto_flags_management) {
-    LOG(WARNING) << "AutoFlags management is disabled.";
-    return Status::OK();
+Status AutoFlagsManager::LoadNewConfig(const AutoFlagsConfigPB new_config) {
+  std::lock_guard l(mutex_);
+  return LoadFromConfigUnlocked(new_config, ApplyNonRuntimeAutoFlags::kTrue);
+}
+
+Result<MonoDelta> AutoFlagsManager::GetTimeLeftToApplyConfig() const {
+  static const MonoDelta uninitialized_delta;
+
+  if (!current_config_.has_config_apply_time()) {
+    return uninitialized_delta;
   }
 
-  std::lock_guard update_lock(mutex_);
+  HybridTime apply_ht;
+  RETURN_NOT_OK(apply_ht.FromUint64(current_config_.config_apply_time()));
+  const auto now = clock_->Now();
+  if (now < apply_ht) {
+    return MonoDelta::FromMicroseconds(apply_ht.PhysicalDiff(now));
+  }
 
-  // First new config can be empty, and should still be written to disk.
-  // Else no-op if it is the same or lower version.
-  if (current_config_.config_version() != 0 &&
-      new_config.config_version() <= current_config_.config_version()) {
-    LOG(INFO) << "AutoFlags config update ignored as we are already on the same"
-                 " or higher version. Current version: "
-              << current_config_.config_version()
-              << ", New version: " << new_config.config_version();
+  return uninitialized_delta;
+}
+
+Status AutoFlagsManager::LoadFromConfigUnlocked(
+    const AutoFlagsConfigPB new_config, ApplyNonRuntimeAutoFlags apply_non_runtime,
+    bool apply_sync) {
+  if (!VERIFY_RESULT(ValidateAndSetConfig(std::move(new_config)))) {
+    // No-op if the config is the same or lower version.
     return Status::OK();
   }
 
-  LOG(INFO) << "Storing new AutoFlags config: " << new_config.ShortDebugString();
-  RETURN_NOT_OK(fs_manager_->WriteAutoFlagsConfig(&new_config));
-
-  current_config_ = std::move(new_config);
+  RETURN_NOT_OK(WriteConfigToDisk());
+
+  if (!apply_sync) {
+    const auto delay = VERIFY_RESULT(GetTimeLeftToApplyConfig());
+    if (delay) {
+      LOG(INFO) << "New AutoFlags config will be applied in " << delay;
+      RETURN_NOT_OK(messenger_->ScheduleOnReactor(
+          std::bind(
+              &AutoFlagsManager::AsyncApplyConfig, this, current_config_.config_version(),
+              apply_non_runtime),
+          delay, SOURCE_LOCATION()));
+      return Status::OK();
+    }
+  }
 
   return ApplyConfig(apply_non_runtime);
 }
@@ -263,13 +285,47 @@ uint32_t AutoFlagsManager::GetConfigVersion() const {
   return current_config_.config_version();
 }
 
+Result<uint32_t> AutoFlagsManager::ValidateAndGetConfigVersion() const {
+  const auto last_config_sync_time = last_config_sync_time_.load(std::memory_order_acquire);
+  SCHECK(last_config_sync_time, IllegalState, "AutoFlags config is stale. No config sync time set");
+  const auto apply_delay = GetApplyDelay();
+  const auto max_allowed_time =
+      last_config_sync_time.AddDelta(apply_delay)
+          .AddDelta(MonoDelta::FromMicroseconds(-1 * FLAGS_max_clock_skew_usec));
+
+  const auto now = clock_->Now();
+  SCHECK_LT(
+      now, max_allowed_time, IllegalState,
+      Format(
+          "AutoFlags config is stale. Last sync time: $0, Max allowed staleness: $1",
+          last_config_sync_time, apply_delay));
+
+  return GetConfigVersion();
+}
+
 AutoFlagsConfigPB AutoFlagsManager::GetConfig() const {
   SharedLock lock(mutex_);
   return current_config_;
 }
 
-Status AutoFlagsManager::ApplyConfig(ApplyNonRuntimeAutoFlags apply_non_runtime) {
-  const auto required_promoted_flags = GetPerProcessFlags(process_name_, current_config_);
+MonoDelta AutoFlagsManager::GetApplyDelay() const {
+  return MonoDelta::FromMilliseconds(FLAGS_auto_flags_apply_delay_ms);
+}
+
+Result<bool> AutoFlagsManager::ValidateAndSetConfig(const AutoFlagsConfigPB&& new_config) {
+  // First new config can be empty, and should still be written to disk.
+  // Else no-op if it is the same or lower version.
+  const auto& current_version = current_config_.config_version();
+  const auto& new_version = new_config.config_version();
+  if (current_version != kInvalidAutoFlagsConfigVersion && new_version <= current_version) {
+    LOG(INFO) << "AutoFlags config update ignored as we are already on the same"
+                 " or higher version. Current version: "
+              << current_config_.config_version()
+              << ", New version: " << new_config.config_version();
+    return false;
+  }
+
+  const auto required_promoted_flags = GetPerProcessFlags(process_name_, new_config);
   for (const auto& flag_name : required_promoted_flags) {
     // This will fail if the node is running a old version of the code that does not support the
     // flag.
@@ -280,11 +336,52 @@ Status AutoFlagsManager::ApplyConfig(ApplyNonRuntimeAutoFlags apply_non_runtime)
         flag_name, VersionInfo::GetShortVersionString());
   }
 
+  current_config_ = std::move(new_config);
+
+  return true;
+}
+
+Status AutoFlagsManager::WriteConfigToDisk() {
+  LOG(INFO) << "Storing new AutoFlags config: " << current_config_.ShortDebugString();
+  RETURN_NOT_OK_PREPEND(
+      fs_manager_->WriteAutoFlagsConfig(&current_config_), "Failed to store AutoFlag config");
+
+  return Status::OK();
+}
+
+void AutoFlagsManager::AsyncApplyConfig(
+    uint32 apply_version, ApplyNonRuntimeAutoFlags apply_non_runtime) {
+  SharedLock lock(mutex_);
+  if (current_config_.config_version() != apply_version) {
+    LOG(INFO) << "Skipping AutoFlags apply as the config version has changed. Expected: "
+              << apply_version << ", Actual: " << current_config_.config_version();
+    return;
+  }
+
+  CHECK_OK_PREPEND(ApplyConfig(apply_non_runtime), "Failed to Apply AutoFlags");
+}
+
+// This is a blocking function that can block process startup. We relax ThreadRestrictions since it
+// gets invoked from a reactor thread.
+Status AutoFlagsManager::ApplyConfig(ApplyNonRuntimeAutoFlags apply_non_runtime) const {
+  const auto delay = VERIFY_RESULT(GetTimeLeftToApplyConfig());
+  if (delay) {
+    LOG(INFO) << "Sleeping for " << delay << "us before applying AutoFlags.";
+    ThreadRestrictions::ScopedAllowWait scoped_allow_wait;
+    SleepFor(delay);
+  }
+
+  const auto required_promoted_flags = GetPerProcessFlags(process_name_, current_config_);
   std::vector<std::string> flags_promoted;
   std::vector<std::string> flags_demoted;
   std::vector<std::string> non_runtime_flags_skipped;
 
-  const auto server_auto_flags = VERIFY_RESULT(GetAvailableAutoFlagsForServer());
+  std::unordered_set<std::string> server_auto_flags;
+  {
+    ThreadRestrictions::ScopedAllowIO scoped_allow_io;
+    server_auto_flags = VERIFY_RESULT(GetAvailableAutoFlagsForServer());
+  }
+
   for (auto& flag_name : server_auto_flags) {
     auto* flag_desc = CHECK_NOTNULL(GetAutoFlagDescription(flag_name));
     gflags::CommandLineFlagInfo flag_info;
@@ -332,4 +429,72 @@ Result<std::unordered_set<std::string>> AutoFlagsManager::GetAvailableAutoFlagsF
   return process_auto_flags;
 }
 
+// No thread safety analysis, as it cannot detect that the mutex is locked by UniqueLock.
+Status AutoFlagsManager::StoreUpdatedConfig(
+    AutoFlagsConfigPB& new_config,
+    std::function<Status(const AutoFlagsConfigPB&)> persist_config_func) NO_THREAD_SAFETY_ANALYSIS {
+  // The config has to get quorum committed in the sys_catalog before it can be stored in
+  // current_config_ even on the master leader. So, there will be delay between when the
+  // config_apply_time is computed and it being stored.
+  // During this window we should not respond to heartbeats since it will renew the leases in the
+  // tserver for auto_flags_apply_delay_ms, which can cause it to be higher than the
+  // config_apply_time we picked. We hold onto the mutex_ so that we do not respond to heartbeats.
+  //
+  // Raft and master leader election will guarantee that this is safe from crashes:
+  // If we crash between writing the WAL op and the it getting applied, then the new leader will
+  // apply it before responding to heartbeats. This is because new leader will have to commit the
+  // NO_OP record and apply all pending operations before it is marked ready. If the op was never
+  // replicated to the new leader then the operation will be lost, and the user will have to try
+  // again.
+  RSTATUS_DCHECK(
+      !update_lock_.owns_lock(), IllegalState, "AutoFlags config update already in progress");
+  update_lock_.lock();
+  auto se = ScopeExit([this]() NO_THREAD_SAFETY_ANALYSIS { update_lock_.unlock(); });
+
+  // This is an update of an existing config. The initial config must be applied immediately.
+  DCHECK_GT(new_config.config_version(), kMinAutoFlagsConfigVersion);
+  // Every config change must update the version by 1.
+  RSTATUS_DCHECK_EQ(
+      new_config.config_version(), current_config_.config_version() + 1, IllegalState,
+      "Attempting to store a stale config");
+
+  const auto now = clock_->Now();
+  const auto config_apply_ht = now.AddDelta(GetApplyDelay());
+  new_config.set_config_apply_time(config_apply_ht.ToUint64());
+
+  return persist_config_func(new_config);
+}
+
+// No thread safety analysis, as it cannot detect that the mutex is locked by UniqueLock.
+Status AutoFlagsManager::ProcessAutoFlagsConfigOperation(const AutoFlagsConfigPB new_config)
+    NO_THREAD_SAFETY_ANALYSIS {
+  bool unlock_needed = false;
+  auto se = ScopeExit([&update_lock = update_lock_, &unlock_needed]() NO_THREAD_SAFETY_ANALYSIS {
+    if (unlock_needed) {
+      update_lock.unlock();
+    }
+  });
+
+  // This function will be invoked when the ChangeAutoFlagsConfigOperation is applied. The
+  // StoreUpdatedConfig may be holding the lock already and waiting for us to complete in which case
+  // we do not have to reacquire the lock. If we crashed during StoreUpdatedConfig, then the
+  // operation can get applied at tablet bootstrap or a later time, and in both cases we need to get
+  // the lock.
+  if (!update_lock_.owns_lock()) {
+    update_lock_.lock();
+    unlock_needed = true;
+  }
+
+  return LoadFromConfigUnlocked(std::move(new_config), ApplyNonRuntimeAutoFlags::kFalse);
+}
+
+void AutoFlagsManager::HandleMasterHeartbeatResponse(
+    HybridTime heartbeat_sent_time, std::optional<AutoFlagsConfigPB> new_config) {
+  if (new_config) {
+    std::lock_guard l(mutex_);
+    // We cannot fail to load a new config that was provided by the master.
+    CHECK_OK(LoadFromConfigUnlocked(std::move(*new_config), ApplyNonRuntimeAutoFlags::kFalse));
+  }
+  last_config_sync_time_.store(heartbeat_sent_time, std::memory_order_release);
+}
 }  // namespace yb
diff --git a/src/yb/client/auto_flags_manager.h b/src/yb/client/auto_flags_manager.h
index a07702982e..b00fe317a8 100644
--- a/src/yb/client/auto_flags_manager.h
+++ b/src/yb/client/auto_flags_manager.h
@@ -15,11 +15,13 @@
 
 #include <shared_mutex>
 
+#include "yb/common/hybrid_time.h"
 #include "yb/common/wire_protocol.pb.h"
 #include "yb/server/server_base_options.h"
 #include "yb/util/locks.h"
 #include "yb/util/status.h"
 #include "yb/util/flags/auto_flags_util.h"
+#include "yb/util/unique_lock.h"
 
 namespace yb {
 
@@ -29,7 +31,38 @@ class FsManager;
 
 class AutoFlagsManager {
  public:
-  explicit AutoFlagsManager(const std::string& process_name, FsManager* fs_manager);
+  explicit AutoFlagsManager(
+      const std::string& process_name, const scoped_refptr<ClockBase>& clock,
+      FsManager* fs_manager);
+  ~AutoFlagsManager();
+
+  Status Init(const std::string& local_hosts);
+
+  // There are five ways in which a new config is loaded.
+  //
+  // LoadFromFile - On a process restart we load the config that was previous written to its local
+  // disk. Synchronously waits for the apply time to pass before applying the config.
+  //
+  // LoadFromMaster - On startup of a new process which does not have any previous config
+  // stored in its local disk. Synchronously waits for the apply time to pass before applying the
+  // config.
+  //
+  // HandleMasterHeartbeatResponse - tserver only. A running tserver process that has already
+  // applied one version of the config has received a new config. Stores the new config to local
+  // disk immediately, and asynchronously applies the config at the provided config_apply_time.
+  //
+  // LoadNewConfig - master only. Stores a new config on cluster create or on the first upgrade from
+  // a version without AutoFlags to a version with AutoFlags.
+  //
+  // ProcessAutoFlagsConfigOperation - master only. Processes the ChangeAutoFlagsConfigOperation WAL
+  // operation on masters. Stores the new config to local disk immediately, and asynchronously
+  // applies the config at the provided config_apply_time.
+  //
+  // All config changes happen via StoreUpdatedConfig on the master leader.
+  // The master leader picks the config_apply_time and commits the config via a
+  // ChangeAutoFlagsConfigOperation. Heartbeat responses are blocked for the duration of this
+  // function to guarantee correctness. The apply of the WAL operation will trigger
+  // ProcessAutoFlagsConfigOperation on all master (including leader).
 
   // Returns true if the load was successful, false if the file was not found.
   // Returns true without doing any work if AutoFlags management is disabled.
@@ -38,31 +71,71 @@ class AutoFlagsManager {
   // local_hosts is a comma separated list of ip addresses and ports.
   // Returns Status::OK without doing any work if AutoFlags management is disabled.
   Status LoadFromMaster(
-      const std::string& local_hosts, const server::MasterAddresses& master_addresses,
-      ApplyNonRuntimeAutoFlags apply_non_runtime) EXCLUDES(mutex_);
+      const std::string& local_hosts, const server::MasterAddresses& master_addresses)
+      EXCLUDES(mutex_);
+
+  void HandleMasterHeartbeatResponse(
+      HybridTime heartbeat_sent_time, std::optional<AutoFlagsConfigPB> new_config);
 
   // Returns Status::OK without doing any work if AutoFlags management is disabled.
-  Status LoadFromConfig(
-      const AutoFlagsConfigPB new_config, ApplyNonRuntimeAutoFlags apply_non_runtime)
-      EXCLUDES(mutex_);
+  Status LoadNewConfig(const AutoFlagsConfigPB new_config) EXCLUDES(mutex_);
+
+  Status ProcessAutoFlagsConfigOperation(const AutoFlagsConfigPB new_config);
+
+  // Used only on master to atomically set the config apply time and persist it in the sys_catalog.
+  Status StoreUpdatedConfig(
+      AutoFlagsConfigPB& new_config,
+      std::function<Status(const AutoFlagsConfigPB&)> persist_config_func);
 
   uint32_t GetConfigVersion() const EXCLUDES(mutex_);
 
+  // Same as GetConfigVersion but makes sure the config is not stale. Config is stale if the tserver
+  // has not heartbeated to the master in auto_flags_apply_delay_ms ms.
+  Result<uint32_t> ValidateAndGetConfigVersion() const EXCLUDES(mutex_);
+
   AutoFlagsConfigPB GetConfig() const EXCLUDES(mutex_);
 
   // Returns all the AutoFlags associated with this process both promoted, and non-promoted ones.
   Result<std::unordered_set<std::string>> GetAvailableAutoFlagsForServer() const;
 
  private:
-  Status ApplyConfig(ApplyNonRuntimeAutoFlags apply_non_runtime) REQUIRES(mutex_);
+  inline MonoDelta GetApplyDelay() const;
+  Result<MonoDelta> GetTimeLeftToApplyConfig() const REQUIRES_SHARED(mutex_);
+
+  // Sets new config to current_config_ if the version is higher. Validates that all flags in the
+  // new config are indeed present in the current release. Returns true if the config was set.
+  Result<bool> ValidateAndSetConfig(const AutoFlagsConfigPB&& new_config) REQUIRES(mutex_);
+
+  Status WriteConfigToDisk() REQUIRES_SHARED(mutex_);
+
+  Status LoadFromConfigUnlocked(
+      const AutoFlagsConfigPB new_config, ApplyNonRuntimeAutoFlags apply_non_runtime,
+      bool apply_sync = false) REQUIRES(mutex_);
+
+  Status ApplyConfig(ApplyNonRuntimeAutoFlags apply_non_runtime) const REQUIRES_SHARED(mutex_);
+
+  void AsyncApplyConfig(uint32 config_version, ApplyNonRuntimeAutoFlags apply_non_runtime)
+      EXCLUDES(mutex_);
+
+  // Get the AutoFlagConfig from master. Returns std::nullopt if master is runnning on an older
+  // version that does not support AutoFlags.
+  Result<std::optional<AutoFlagsConfigPB>> GetAutoFlagConfigFromMaster(
+      const std::string& master_addresses);
 
   const std::string process_name_;
+  scoped_refptr<ClockBase> clock_;
 
   // FsManager is owned by the parent service, and is expected to outlive this object.
   FsManager* fs_manager_;
 
   // Expected to be held for a short time to either read or update current_config_.
   mutable std::shared_mutex mutex_;
+  UniqueLock<std::shared_mutex> update_lock_;
   AutoFlagsConfigPB current_config_ GUARDED_BY(mutex_);
+  std::atomic<HybridTime> last_config_sync_time_{HybridTime::kInvalid};
+
+  std::unique_ptr<rpc::SecureContext> secure_context_;
+  std::unique_ptr<rpc::Messenger> messenger_;
 };
+
 }  // namespace yb
diff --git a/src/yb/client/client-internal.cc b/src/yb/client/client-internal.cc
index 2b164006dd..cc80ecaf7c 100644
--- a/src/yb/client/client-internal.cc
+++ b/src/yb/client/client-internal.cc
@@ -282,6 +282,7 @@ YB_CLIENT_SPECIALIZE_SIMPLE_EX(Client, RedisConfigSet);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Client, ReservePgsqlOids);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Client, GetStatefulServiceLocation);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Cluster, GetAutoFlagsConfig);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Cluster, ValidateAutoFlagsConfig);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Cluster, IsLoadBalanced);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Cluster, IsLoadBalancerIdle);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Cluster, ListLiveTabletServers);
diff --git a/src/yb/client/client.cc b/src/yb/client/client.cc
index 7ab4f26e01..52fb06fdb6 100644
--- a/src/yb/client/client.cc
+++ b/src/yb/client/client.cc
@@ -2693,6 +2693,9 @@ Result<std::optional<AutoFlagsConfigPB>> YBClient::GetAutoFlagConfig() {
   }();
 
   if (status.ok()) {
+    if (resp.has_error()) {
+      return StatusFromPB(resp.error().status());
+    }
     return std::move(resp.config());
   }
 
@@ -2703,6 +2706,38 @@ Result<std::optional<AutoFlagsConfigPB>> YBClient::GetAutoFlagConfig() {
   return status;
 }
 
+Result<std::optional<std::pair<bool, uint32>>> YBClient::ValidateAutoFlagsConfig(
+    const AutoFlagsConfigPB& config, std::optional<AutoFlagClass> min_flag_class) {
+  master::ValidateAutoFlagsConfigRequestPB req;
+  master::ValidateAutoFlagsConfigResponsePB resp;
+  req.mutable_config()->CopyFrom(config);
+  if (min_flag_class) {
+    req.set_min_flag_class(to_underlying(*min_flag_class));
+  }
+
+  // CALL_SYNC_LEADER_MASTER_RPC_EX will return on failure. Capture the Status so that we can handle
+  // the case when master is running on an older version that does not support this RPC.
+  Status status = [&]() -> Status {
+    CALL_SYNC_LEADER_MASTER_RPC_EX(Cluster, req, resp, ValidateAutoFlagsConfig);
+    return Status::OK();
+  }();
+
+  if (!status.ok()) {
+    if (rpc::RpcError(status) == rpc::ErrorStatusPB::ERROR_NO_SUCH_METHOD) {
+      return std::nullopt;
+    }
+
+    return status;
+  }
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+  SCHECK(
+      resp.has_valid() && resp.has_config_version(), IllegalState,
+      "Invalid response from ValidateAutoFlagsConfig");
+  return std::make_pair(resp.valid(), resp.config_version());
+}
+
 Result<master::StatefulServiceInfoPB> YBClient::GetStatefulServiceLocation(
     StatefulServiceKind service_kind) {
   master::GetStatefulServiceLocationRequestPB req;
diff --git a/src/yb/client/client.h b/src/yb/client/client.h
index eabef0ae97..d076aef7b7 100644
--- a/src/yb/client/client.h
+++ b/src/yb/client/client.h
@@ -930,6 +930,15 @@ class YBClient {
   // version that does not support AutoFlags.
   Result<std::optional<AutoFlagsConfigPB>> GetAutoFlagConfig();
 
+  // Check if the given AutoFlagsConfigPB is compatible with the AutoFlags config of the universe.
+  // Check the description of AutoFlagsUtil::AreAutoFlagsCompatible for more information about what
+  // compatible means.
+  // Returns the result in the bool and the current AutoFlags config version that it was validated
+  // with. Returns nullopt if the master is running on an older version that does not support this
+  // API.
+  Result<std::optional<std::pair<bool, uint32>>> ValidateAutoFlagsConfig(
+      const AutoFlagsConfigPB& config, std::optional<AutoFlagClass> min_flag_class = std::nullopt);
+
   Result<master::StatefulServiceInfoPB> GetStatefulServiceLocation(
       StatefulServiceKind service_kind);
 
diff --git a/src/yb/common/wire_protocol.proto b/src/yb/common/wire_protocol.proto
index 2f2947e6c5..79a7c059fe 100644
--- a/src/yb/common/wire_protocol.proto
+++ b/src/yb/common/wire_protocol.proto
@@ -171,4 +171,7 @@ message PromotedFlagsPerProcessPB {
 message AutoFlagsConfigPB {
   required uint32 config_version = 1;
   repeated PromotedFlagsPerProcessPB promoted_flags = 2;
+
+  // Physical time at which the new config should be applied.
+  optional fixed64 config_apply_time = 3;
 }
diff --git a/src/yb/integration-tests/auto_flags-itest.cc b/src/yb/integration-tests/auto_flags-itest.cc
index e26fb47e1a..58377295bd 100644
--- a/src/yb/integration-tests/auto_flags-itest.cc
+++ b/src/yb/integration-tests/auto_flags-itest.cc
@@ -29,6 +29,7 @@
 
 #include "yb/tablet/tablet_peer.h"
 
+#include "yb/tserver/heartbeater.h"
 #include "yb/tserver/mini_tablet_server.h"
 #include "yb/tserver/tablet_server.h"
 
@@ -46,6 +47,8 @@ DECLARE_int32(heartbeat_interval_ms);
 DECLARE_bool(TEST_disable_versioned_auto_flags);
 DECLARE_bool(enable_tablet_split_of_xcluster_replicated_tables);
 DECLARE_bool(ysql_yb_pushdown_strict_inequality);
+DECLARE_uint32(auto_flags_apply_delay_ms);
+DECLARE_bool(TEST_tserver_disable_heartbeat);
 
 // Required for tests with AutoFlags management disabled
 DISABLE_PROMOTE_ALL_AUTO_FLAGS_FOR_TEST;
@@ -60,6 +63,9 @@ using OK = Status::OK;
 const string kDisableAutoFlagsManagementFlagName = "disable_auto_flags_management";
 const string kTESTAutoFlagsInitializedFlagName = "TEST_auto_flags_initialized";
 const string kTESTAutoFlagsNewInstallFlagName = "TEST_auto_flags_new_install";
+const string kAutoFlagsApplyDelayFlagName = "auto_flags_apply_delay_ms";
+const string kDisableAutoFlagsApplyDelay = Format("--$0=0", kAutoFlagsApplyDelayFlagName);
+const string kDisableAutoFlagPromoteForNewUniverse = "--limit_auto_flag_promote_for_new_universe=0";
 const string kTrue = "true";
 const string kFalse = "false";
 const MonoDelta kTimeout = 20s * kTimeMultiplier;
@@ -177,7 +183,7 @@ Status TestPromote(
 
 }  // namespace
 
-class AutoFlagsMiniClusterTest : public YBMiniClusterTestBase<MiniCluster> {
+class AutoFlagsMiniClusterTest : public MiniClusterTestWithClient<MiniCluster> {
  protected:
   void SetUp() override {}
   void TestBody() override {}
@@ -189,7 +195,8 @@ class AutoFlagsMiniClusterTest : public YBMiniClusterTestBase<MiniCluster> {
     opts.num_tablet_servers = kNumTServers;
     opts.num_masters = kNumMasterServers;
     cluster_.reset(new MiniCluster(opts));
-    return cluster_->Start();
+    RETURN_NOT_OK(cluster_->Start());
+    return CreateClient();
   }
 
   Status ValidateConfig() {
@@ -315,19 +322,29 @@ class AutoFlagsMiniClusterTest : public YBMiniClusterTestBase<MiniCluster> {
     return ValidateConfigOnTservers(expected_config_version);
   }
 
+  Result<master::PromoteAutoFlagsResponsePB> PromoteFlags(
+      master::Master* leader_master, AutoFlagClass flag_class, bool force = false) {
+    master::PromoteAutoFlagsRequestPB req;
+    req.set_max_flag_class(ToString(flag_class));
+    req.set_promote_non_runtime_flags(true);
+    req.set_force(force);
+
+    master::PromoteAutoFlagsResponsePB resp;
+    RETURN_NOT_OK(leader_master->catalog_manager_impl()->PromoteAutoFlags(&req, &resp));
+
+    if (resp.has_error()) {
+      return StatusFromPB(resp.error().status());
+    }
+
+    return resp;
+  }
+
   auto PromoteFlagsAndValidate(
       uint32 expected_config_version, master::Master* leader_master, AutoFlagClass flag_class) {
-    master::PromoteAutoFlagsRequestPB promote_req;
-    promote_req.set_max_flag_class(ToString(flag_class));
-    promote_req.set_promote_non_runtime_flags(true);
-    promote_req.set_force(false);
-
-    master::PromoteAutoFlagsResponsePB promote_resp;
-    CHECK_OK(leader_master->catalog_manager_impl()->PromoteAutoFlags(&promote_req, &promote_resp));
-    CHECK(!promote_resp.has_error());
-    CHECK(promote_resp.has_new_config_version());
-    CHECK_EQ(promote_resp.new_config_version(), expected_config_version);
-    CHECK(promote_resp.flags_promoted());
+    auto resp = CHECK_RESULT(PromoteFlags(leader_master, flag_class, /* force */ false));
+    CHECK(resp.has_new_config_version());
+    CHECK_EQ(resp.new_config_version(), expected_config_version);
+    CHECK(resp.flags_promoted());
 
     CHECK_OK(ValidateConfigOnAllProcesses(expected_config_version));
 
@@ -499,6 +516,7 @@ TEST_F(AutoFlagsMiniClusterTest, Rollback) {
 
 TEST_F(AutoFlagsMiniClusterTest, Demote) {
   ASSERT_OK(RunSetUp());
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_auto_flags_apply_delay_ms) = 0;
   auto leader_master = ASSERT_RESULT(cluster_->GetLeaderMiniMaster())->master();
   uint32 expected_config_version = 1;
   const auto kExternalAutoFlagName = "enable_tablet_split_of_xcluster_replicated_tables";
@@ -581,12 +599,208 @@ TEST_F(AutoFlagsMiniClusterTest, CheckMissingFlag) {
   }
   config.set_config_version(config.config_version() + 1);
 
-  auto s = auto_flags_manager->LoadFromConfig(config, ApplyNonRuntimeAutoFlags::kFalse);
+  auto s = auto_flags_manager->LoadNewConfig(config);
   ASSERT_NOK(s);
   ASSERT_TRUE(s.ToString().find("missing_flag") != std::string::npos) << s;
   ASSERT_TRUE(s.ToString().find(VersionInfo::GetShortVersionString()) != std::string::npos) << s;
 }
 
+// Make sure AutoFlags are not applied before auto_flags_apply_delay_ms
+TEST_F(AutoFlagsMiniClusterTest, HeartbeatDelay) {
+  ASSERT_OK(RunSetUp());
+  ASSERT_OK(cluster_->WaitForLoadBalancerToStabilize(kTimeout));
+
+  // Wait for initial heartbeats with full tablet reports to finish.
+  SleepFor(kTimeout);
+
+  auto leader_master = ASSERT_RESULT(cluster_->GetLeaderMiniMaster())->master();
+  auto initial_config_version = leader_master->GetAutoFlagConfigVersion();
+
+  std::vector<tserver::TabletServer*> tservers;
+  for (auto mini_tablet_server : cluster_->mini_tablet_servers()) {
+    tservers.push_back(mini_tablet_server->server());
+  }
+
+  // Validate initial config on all tservers.
+  for (auto* tserver : tservers) {
+    const auto tserver_version = ASSERT_RESULT(tserver->ValidateAndGetAutoFlagsConfigVersion());
+    ASSERT_EQ(tserver_version, initial_config_version);
+  }
+
+  const auto heartbeat_ms = FLAGS_heartbeat_interval_ms;
+  // Disable the heartbeats and wait for inflight heartbeats to complete.
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_tserver_disable_heartbeat) = true;
+  const auto heartbeat_sleep_ms = heartbeat_ms * 2 * kTimeMultiplier;
+
+  // Sleep out the apply delay as well.
+  const int32 apply_delay_ms = static_cast<int32>(FLAGS_auto_flags_apply_delay_ms);
+  LOG(INFO) << "Sleeping for " << apply_delay_ms << "ms";
+  SleepFor(MonoDelta::FromMilliseconds(std::max(apply_delay_ms, heartbeat_sleep_ms)));
+
+  // Make sure tservers can no longer return the config version.
+  for (auto* tserver : tservers) {
+    ASSERT_NOK(tserver->ValidateAndGetAutoFlagsConfigVersion());
+  }
+
+  // Bump up the config.
+  auto config =
+      ASSERT_RESULT(PromoteFlags(leader_master, AutoFlagClass::kExternal, /* force */ true));
+  ASSERT_EQ(config.new_config_version(), initial_config_version + 1);
+  SleepFor(MonoDelta::FromMilliseconds(heartbeat_sleep_ms));
+
+  // tservers should remain on old version.
+  for (auto* tserver : tservers) {
+    ASSERT_NOK(tserver->ValidateAndGetAutoFlagsConfigVersion());
+    ASSERT_EQ(tserver->TEST_GetAutoFlagConfig().config_version(), initial_config_version);
+  }
+
+  // Trigger heartbeats.
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_tserver_disable_heartbeat) = false;
+  for (auto* tserver : tservers) {
+    tserver->heartbeater()->TriggerASAP();
+  }
+  // Wait for the heartbeats that we started to complete.
+  SleepFor(MonoDelta::FromMilliseconds(heartbeat_sleep_ms));
+
+  // tserver should now be on new version.
+  for (auto* tserver : tservers) {
+    const auto tserver_version = ASSERT_RESULT(tserver->ValidateAndGetAutoFlagsConfigVersion());
+    ASSERT_EQ(tserver_version, initial_config_version + 1);
+  }
+}
+
+// If a new node comes up between the time a new AutoFlags config was created and its apply time,
+// then this new process startup should block till the apply time has passed.
+TEST_F(AutoFlagsMiniClusterTest, AddTserverBeforeApplyDelay) {
+  // Start with an empty config.
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_limit_auto_flag_promote_for_new_universe) = 0;
+  const auto kApplyDelayMs = 10 * MonoTime::kMillisecondsPerSecond * kTimeMultiplier;
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_auto_flags_apply_delay_ms) = kApplyDelayMs;
+
+  ASSERT_OK(RunSetUp());
+  auto leader_master = ASSERT_RESULT(cluster_->GetLeaderMiniMaster())->master();
+  auto now_ht = [&leader_master]() { return leader_master->clock()->Now(); };
+  uint32 expected_config_version = 0;
+  CHECK_OK(ValidateConfigOnAllProcesses(expected_config_version));
+
+  AutoFlagsConfigPB config;
+  ASSERT_NO_FATALS(
+      config = PromoteFlagsAndValidate(
+          ++expected_config_version, leader_master, AutoFlagClass::kExternal));
+
+  ASSERT_TRUE(config.has_config_apply_time());
+  HybridTime config_apply_ht;
+  ASSERT_OK(config_apply_ht.FromUint64(config.config_apply_time()));
+
+  // Make sure we still have time before new config is applied.
+  const auto before_add_tserver = now_ht();
+  ASSERT_GT(config_apply_ht, before_add_tserver.AddDelta(1s));
+
+  // Add a new tserver. This call will block till we can get the config from master leader and apply
+  // it.
+  ASSERT_OK(cluster_->AddTabletServer());
+
+  // Make sure we have waited for the apply time to pass.
+  const auto after_tserver_started = now_ht();
+  ASSERT_GT(after_tserver_started, config_apply_ht);
+
+  // We should have waited for some time atleast.
+  ASSERT_GT(
+      after_tserver_started.PhysicalDiff(before_add_tserver), MonoTime::kMicrosecondsPerSecond);
+
+  // Validate it got the right config.
+  ASSERT_OK(cluster_->WaitForAllTabletServers());
+  CHECK_OK(ValidateConfigOnAllProcesses(expected_config_version));
+}
+
+// If we promote and then Rollback the volatile flags before it has been Applied, the flag values
+// should never change.
+TEST_F(AutoFlagsMiniClusterTest, RollbackBeforeApply) {
+  // Start with an empty config.
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_limit_auto_flag_promote_for_new_universe) = 0;
+  const auto kApplyDelayMs = 10 * MonoTime::kMillisecondsPerSecond * kTimeMultiplier;
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_auto_flags_apply_delay_ms) = kApplyDelayMs;
+  const auto& kLocalVolatileAutoFlag = FLAGS_ysql_yb_pushdown_strict_inequality;
+
+  ASSERT_OK(RunSetUp());
+  auto leader_master = ASSERT_RESULT(cluster_->GetLeaderMiniMaster())->master();
+  uint32 initial_config_version = 0;
+  CHECK_OK(ValidateConfigOnAllProcesses(initial_config_version));
+
+  ASSERT_FALSE(kLocalVolatileAutoFlag);
+
+  // Track if the kLocalVolatileAutoFlag is ever changed;
+  uint32 callback_count = 0;
+  auto registration = ASSERT_RESULT(RegisterFlagUpdateCallback(
+      &kLocalVolatileAutoFlag, "Test", [&callback_count]() { callback_count++; }));
+
+  ASSERT_NO_FATALS(
+      auto config = PromoteFlagsAndValidate(
+          initial_config_version + 1, leader_master, AutoFlagClass::kLocalVolatile));
+  ASSERT_FALSE(kLocalVolatileAutoFlag);
+
+  // Rollback before the Apply happens.
+  ASSERT_NO_FATALS(
+      RollbackFlagsAndValidate(initial_config_version, initial_config_version + 2, leader_master));
+  ASSERT_FALSE(kLocalVolatileAutoFlag);
+
+  // Wait for 3x the Apply delay.
+  SleepFor(MonoDelta::FromMilliseconds(kApplyDelayMs * 3));
+
+  // The callback should never get invoked.
+  ASSERT_EQ(callback_count, 0);
+  ASSERT_FALSE(kLocalVolatileAutoFlag);
+
+  registration.Deregister();
+}
+
+// Make sure ValidateAutoFlagsConfig API returns true only when the passed in config has a superset
+// of flags compared to the universe config.
+TEST_F(AutoFlagsMiniClusterTest, ValidateAutoFlagsConfig) {
+  const auto kYbTServerProcess = "yb-tserver";
+  const auto kVolatileAutoFlagName = "ysql_yb_pushdown_strict_inequality";
+  ASSERT_OK(RunSetUp());
+
+  auto leader_master = ASSERT_RESULT(cluster_->GetLeaderMiniMaster());
+  const auto current_config = leader_master->master()->GetAutoFlagsConfig();
+  AutoFlagsConfigPB config;
+  config.set_config_version(kMinAutoFlagsConfigVersion);
+
+  // Empty request.
+  auto result = ASSERT_RESULT(client_->ValidateAutoFlagsConfig(config));
+  ASSERT_TRUE(result.has_value());
+  ASSERT_FALSE(result->first);
+  ASSERT_EQ(result->second, current_config.config_version());
+
+  // Same config.
+  result = ASSERT_RESULT(client_->ValidateAutoFlagsConfig(current_config));
+  ASSERT_TRUE(result.has_value());
+  ASSERT_TRUE(result->first);
+  ASSERT_EQ(result->second, current_config.config_version());
+
+  // Create a new config without one Volatile AutoFlag in the tserver process.
+  for (const auto& current_promoted_flags : current_config.promoted_flags()) {
+    auto* promoted_flags = config.add_promoted_flags();
+    promoted_flags->set_process_name(current_promoted_flags.process_name());
+
+    for (const auto& flag : current_promoted_flags.flags()) {
+      if (current_promoted_flags.process_name() == kYbTServerProcess &&
+          flag == kVolatileAutoFlagName) {
+        continue;
+      }
+      promoted_flags->add_flags(flag);
+    }
+  }
+  result = ASSERT_RESULT(client_->ValidateAutoFlagsConfig(config));
+  ASSERT_FALSE(result->first);
+  ASSERT_EQ(result->second, current_config.config_version());
+
+  // Set min class to check to External and missing flag should not case error.
+  result = ASSERT_RESULT(client_->ValidateAutoFlagsConfig(config, AutoFlagClass::kExternal));
+  ASSERT_TRUE(result->first);
+  ASSERT_EQ(result->second, current_config.config_version());
+}
+
 class AutoFlagsExternalMiniClusterTest : public ExternalMiniClusterITestBase {
  public:
   void BuildAndStart(
@@ -923,7 +1137,8 @@ TEST_F(AutoFlagsExternalMiniClusterTest, UpgradeCluster) {
 TEST_F(AutoFlagsExternalMiniClusterTest, PromoteOneFlag) {
   // Start with an empty config.
   ASSERT_NO_FATALS(BuildAndStart(
-      {} /* ts_flags */, {"--limit_auto_flag_promote_for_new_universe=0"} /* master_flags */));
+      {kDisableAutoFlagsApplyDelay} /* ts_flags */,
+      {kDisableAutoFlagsApplyDelay, kDisableAutoFlagPromoteForNewUniverse} /* master_flags */));
 
   const auto kVolatileAutoFlagName = "ysql_yb_pushdown_strict_inequality";
   const auto kYbTServerProcess = "yb-tserver";
@@ -958,7 +1173,9 @@ TEST_F(AutoFlagsExternalMiniClusterTest, PromoteOneFlag) {
 
 // Promote one flag and make sure Rollback only affects that one flag.
 TEST_F(AutoFlagsExternalMiniClusterTest, RollbackOneFlag) {
-  ASSERT_NO_FATALS(BuildAndStart());
+  ASSERT_NO_FATALS(BuildAndStart(
+      {kDisableAutoFlagsApplyDelay} /* ts_flags */,
+      {kDisableAutoFlagsApplyDelay} /* master_flags */));
   const auto kVolatileAutoFlagName = "ysql_yb_pushdown_strict_inequality";
   const auto kYbTServerProcess = "yb-tserver";
 
@@ -1027,4 +1244,68 @@ TEST_F(AutoFlagsExternalMiniClusterTest, RollbackOneFlag) {
     ASSERT_EQ(ASSERT_RESULT(daemons->GetFlag(kVolatileAutoFlagName)), "true");
   }
 }
+
+TEST_F(AutoFlagsExternalMiniClusterTest, DelayedApplyFlags) {
+  const uint32 apply_delay_ms = 5000 * kTimeMultiplier;
+  const auto kVolatileAutoFlagName = "ysql_yb_pushdown_strict_inequality";
+  const auto kSetAutoFlagsApplyDelay =
+      Format("--$0=$1", kAutoFlagsApplyDelayFlagName, apply_delay_ms);
+
+  ASSERT_NO_FATALS(BuildAndStart(
+      {kSetAutoFlagsApplyDelay} /* ts_flags */,
+      {kSetAutoFlagsApplyDelay, kDisableAutoFlagPromoteForNewUniverse} /* master_flags */));
+
+  uint32 expected_config_version = 0;
+
+  // Initial config is empty.
+  auto config = ASSERT_RESULT(GetAutoFlagsConfig());
+  ASSERT_EQ(expected_config_version, config.config_version());
+  ASSERT_EQ(CountPromotedFlags(config), 0);
+  ASSERT_FALSE(config.has_config_apply_time());
+  for (auto& tserver : cluster_->tserver_daemons()) {
+    ASSERT_EQ(ASSERT_RESULT(tserver->GetFlag(kVolatileAutoFlagName)), "false");
+  }
+
+  // Promote some flags.
+  auto leader_master = cluster_->GetLeaderMaster();
+  auto before_promote_ht = ASSERT_RESULT(leader_master->GetServerTime());
+  LOG(INFO) << "before_promote_ht: " << before_promote_ht;
+  ASSERT_NO_FATALS(
+      config = PromoteFlagsAndValidate(++expected_config_version, AutoFlagClass::kLocalVolatile));
+
+  ASSERT_EQ(expected_config_version, config.config_version());
+  ASSERT_GT(CountPromotedFlags(config), 0);
+  // config_apply_time must be at least apply_delay_ms more than before_promote_ht.
+  ASSERT_TRUE(config.has_config_apply_time());
+  HybridTime config_apply_ht;
+  ASSERT_OK(config_apply_ht.FromUint64(config.config_apply_time()));
+  LOG(INFO) << "config_apply_ht: " << config_apply_ht;
+  ASSERT_GT(config_apply_ht, before_promote_ht);
+  ASSERT_GT(
+      config_apply_ht.PhysicalDiff(before_promote_ht),
+      apply_delay_ms * MonoTime::kMicrosecondsPerMillisecond);
+
+  auto after_promote_and_validate_ht = ASSERT_RESULT(leader_master->GetServerTime());
+  LOG(INFO) << "after_promote_and_validate_ht: " << after_promote_and_validate_ht;
+  // The apply time cannot be too far in the future.
+  ASSERT_LT(config_apply_ht, after_promote_and_validate_ht.AddMilliseconds(apply_delay_ms));
+
+  // Make sure we still have some time to do the validation.
+  ASSERT_GT(config_apply_ht.AddDelta(MonoDelta::FromSeconds(1)), after_promote_and_validate_ht);
+
+  // Make sure the flag is not applied yet.
+  for (auto& daemon : cluster_->daemons()) {
+    ASSERT_EQ(ASSERT_RESULT(daemon->GetFlag(kVolatileAutoFlagName)), "false");
+  }
+
+  // Wait for config to be applied plus a buffer of 1s.
+  const auto sleep_time_us = config_apply_ht.PhysicalDiff(after_promote_and_validate_ht) +
+                             (MonoTime::kMicrosecondsPerSecond * kTimeMultiplier);
+  LOG(WARNING) << "Sleeping for " << sleep_time_us << "us";
+  SleepFor(MonoDelta::FromMicroseconds(sleep_time_us));
+
+  for (auto& daemon : cluster_->daemons()) {
+    ASSERT_EQ(ASSERT_RESULT(daemon->GetFlag(kVolatileAutoFlagName)), "true");
+  }
+}
 }  // namespace yb
diff --git a/src/yb/integration-tests/external_mini_cluster.cc b/src/yb/integration-tests/external_mini_cluster.cc
index 9c3d827e2a..da0d61aa29 100644
--- a/src/yb/integration-tests/external_mini_cluster.cc
+++ b/src/yb/integration-tests/external_mini_cluster.cc
@@ -2610,6 +2610,21 @@ Result<string> ExternalDaemon::GetFlag(const std::string& flag) {
   return resp.value();
 }
 
+Result<HybridTime> ExternalDaemon::GetServerTime() {
+  server::GenericServiceProxy proxy(proxy_cache_, bound_rpc_addr());
+
+  rpc::RpcController controller;
+  controller.set_timeout(MonoDelta::FromSeconds(30));
+  server::ServerClockRequestPB req;
+  server::ServerClockResponsePB resp;
+  RETURN_NOT_OK(proxy.ServerClock(req, &resp, &controller));
+  SCHECK(resp.has_hybrid_time(), IllegalState, "No hybrid time in response");
+  HybridTime ht;
+  RETURN_NOT_OK(ht.FromUint64(resp.hybrid_time()));
+
+  return ht;
+}
+
 LogWaiter::LogWaiter(ExternalDaemon* daemon, const std::string& string_to_wait) :
     daemon_(daemon), string_to_wait_(string_to_wait) {
   daemon_->SetLogListener(this);
diff --git a/src/yb/integration-tests/external_mini_cluster.h b/src/yb/integration-tests/external_mini_cluster.h
index eb30f9ff94..3edf915ace 100644
--- a/src/yb/integration-tests/external_mini_cluster.h
+++ b/src/yb/integration-tests/external_mini_cluster.h
@@ -82,6 +82,7 @@ class ExternalDaemon;
 class ExternalMaster;
 class ExternalTabletServer;
 class HostPort;
+class HybridTime;
 class OpIdPB;
 class NodeInstancePB;
 class Subprocess;
@@ -769,6 +770,7 @@ class ExternalDaemon : public RefCountedThreadSafe<ExternalDaemon> {
 
   // Get the current value of the flag for the given daemon.
   Result<std::string> GetFlag(const std::string& flag);
+  Result<HybridTime> GetServerTime();
 
  protected:
   friend class RefCountedThreadSafe<ExternalDaemon>;
diff --git a/src/yb/integration-tests/mini_cluster.cc b/src/yb/integration-tests/mini_cluster.cc
index 9011853c49..38546d1c86 100644
--- a/src/yb/integration-tests/mini_cluster.cc
+++ b/src/yb/integration-tests/mini_cluster.cc
@@ -373,7 +373,11 @@ Status MiniCluster::AddTabletServer(const tserver::TabletServerOptions& extra_op
   if (options_.ts_env) {
     tablet_server->options()->env = options_.ts_env;
   }
+
+  LOG(WARNING) << "hk!! ts Start s";
   RETURN_NOT_OK(tablet_server->Start(tserver::WaitTabletsBootstrapped::kFalse));
+
+  LOG(WARNING) << "hk!! ts Start e";
   mini_tablet_servers_.push_back(tablet_server);
   return Status::OK();
 }
diff --git a/src/yb/master/auto_flags_orchestrator.cc b/src/yb/master/auto_flags_orchestrator.cc
index 5e54261935..82dc3214ef 100644
--- a/src/yb/master/auto_flags_orchestrator.cc
+++ b/src/yb/master/auto_flags_orchestrator.cc
@@ -102,7 +102,7 @@ PromoteAutoFlagsOutcome InsertFlagsToConfig(
   auto non_runtime_flags_added = false;
   bool config_changed = false;
   // Initial config or forced version bump.
-  if (config->config_version() == 0 || force_version_change) {
+  if (config->config_version() == kInvalidAutoFlagsConfigVersion || force_version_change) {
     config_changed = true;
   }
   auto new_config_version = config->config_version() + 1;
@@ -164,15 +164,14 @@ PromoteAutoFlagsOutcome InsertFlagsToConfig(
 // Remove flags from the config if they were promoted on a version higher than rollback_version.
 // Bumps up the config version if any flags were removed. Returns the list of removed flags per
 // process.
-std::map<ProcessName, std::vector<std::string>> RemoveFlagsFromConfig(
-    uint32_t rollback_version, AutoFlagsConfigPB* config) {
+AutoFlagsNameMap RemoveFlagsFromConfig(uint32_t rollback_version, AutoFlagsConfigPB* config) {
   bool config_changed = false;
-  std::map<ProcessName, std::vector<std::string>> flags_removed;
+  AutoFlagsNameMap flags_removed;
 
   for (auto& promoted_flags : *config->mutable_promoted_flags()) {
     for (int i = 0; i < promoted_flags.flag_infos().size();) {
       if (promoted_flags.flag_infos(i).promoted_version() > rollback_version) {
-        flags_removed[promoted_flags.process_name()].push_back(promoted_flags.flags(i));
+        flags_removed[promoted_flags.process_name()].insert(promoted_flags.flags(i));
         Erase(promoted_flags.mutable_flags(), i);
         Erase(promoted_flags.mutable_flag_infos(), i);
         config_changed = true;
@@ -212,37 +211,57 @@ Result<bool> RemoveFlagFromConfig(
   return false;
 }
 
-Status StoreAutoFlagsConfig(const AutoFlagsConfigPB& new_config, CatalogManager* catalog_manager) {
-  consensus::ChangeAutoFlagsConfigOpResponsePB operation_res;
-  // SubmitToSysCatalog will set the correct tablet
-  auto operation = std::make_unique<tablet::ChangeAutoFlagsConfigOperation>(nullptr /* tablet */);
-  *operation->AllocateRequest() = new_config;
-  CountDownLatch latch(1);
-  operation->set_completion_callback(
-      tablet::MakeLatchOperationCompletionCallback(&latch, &operation_res));
+Status StoreAutoFlagsConfig(
+    AutoFlagsManager& auto_flag_manager, AutoFlagsConfigPB& new_config,
+    CatalogManager* catalog_manager) {
+  auto persist_config_to_sys_catalog =
+      [catalog_manager](const AutoFlagsConfigPB& new_config) -> Status {
+    consensus::ChangeAutoFlagsConfigOpResponsePB operation_res;
+    // SubmitToSysCatalog will set the correct tablet
+    auto operation = std::make_unique<tablet::ChangeAutoFlagsConfigOperation>(nullptr /* tablet */);
+    *operation->AllocateRequest() = new_config;
+    CountDownLatch latch(1);
+    operation->set_completion_callback(
+        tablet::MakeLatchOperationCompletionCallback(&latch, &operation_res));
+
+    RETURN_NOT_OK_PREPEND(
+        catalog_manager->SubmitToSysCatalog(std::move(operation)),
+        "Failed to store AutoFlags config");
+
+    latch.Wait();
+
+    if (operation_res.has_error()) {
+      auto status = StatusFromPB(operation_res.error().status());
+      LOG(WARNING) << "Failed to apply new AutoFlags config: " << status.ToString();
+      return status;
+    }
 
-  RETURN_NOT_OK(catalog_manager->SubmitToSysCatalog(std::move(operation)));
+    return OK();
+  };
 
-  latch.Wait();
+  return auto_flag_manager.StoreUpdatedConfig(new_config, persist_config_to_sys_catalog);
+}
 
-  if (operation_res.has_error()) {
-    auto status = StatusFromPB(operation_res.error().status());
-    LOG(WARNING) << "Failed to apply new AutoFlags config: " << status.ToString();
-    return status;
+AutoFlagsNameMap GetFlagsFromConfig(const AutoFlagsConfigPB& config) {
+  AutoFlagsNameMap result;
+  for (auto& per_process_flags : config.promoted_flags()) {
+    auto& process_flags = result[per_process_flags.process_name()];
+    for (auto& flag_name : per_process_flags.flags()) {
+      process_flags.insert(flag_name);
+    }
   }
-
-  return OK();
+  return result;
 }
+
 }  // namespace
 
-Status CreateAutoFlagsConfigForNewCluster(AutoFlagsManager* auto_flag_manager) {
+Status CreateAutoFlagsConfigForNewCluster(AutoFlagsManager& auto_flag_manager) {
   LOG(INFO) << "Creating AutoFlags configuration for new cluster.";
 
   if (FLAGS_limit_auto_flag_promote_for_new_universe != 0) {
     const auto max_flag_class = VERIFY_RESULT(yb::UnderlyingToEnumSlow<yb::AutoFlagClass>(
         FLAGS_limit_auto_flag_promote_for_new_universe));
     const auto promote_non_runtime = PromoteNonRuntimeAutoFlags::kTrue;
-    const auto apply_non_runtime = ApplyNonRuntimeAutoFlags::kTrue;
 
     if (FLAGS_disable_auto_flags_management) {
       LOG(WARNING) << "AutoFlags management is disabled.";
@@ -250,34 +269,33 @@ Status CreateAutoFlagsConfigForNewCluster(AutoFlagsManager* auto_flag_manager) {
     }
 
     LOG(INFO) << "Promoting AutoFlags. max_flag_class: " << ToString(max_flag_class)
-              << ", promote_non_runtime: " << promote_non_runtime
-              << ", apply_non_runtime: " << apply_non_runtime;
+              << ", promote_non_runtime: " << promote_non_runtime;
 
     const auto eligible_flags = VERIFY_RESULT(
         AutoFlagsUtil::GetFlagsEligibleForPromotion(max_flag_class, promote_non_runtime));
 
-    auto new_config = auto_flag_manager->GetConfig();
+    auto new_config = auto_flag_manager.GetConfig();
     InsertFlagsToConfig(eligible_flags, &new_config, true /* force */);
+    DCHECK_GE(new_config.config_version(), kMinAutoFlagsConfigVersion);
 
-    RETURN_NOT_OK(auto_flag_manager->LoadFromConfig(std::move(new_config), apply_non_runtime));
+    RETURN_NOT_OK(auto_flag_manager.LoadNewConfig(std::move(new_config)));
   }
 
   return OK();
 }
 
-Status CreateEmptyAutoFlagsConfig(AutoFlagsManager* auto_flag_manager) {
+Status CreateEmptyAutoFlagsConfig(AutoFlagsManager& auto_flag_manager) {
   LOG(INFO) << "Creating empty AutoFlags configuration.";
 
   AutoFlagsConfigPB new_config;
-  new_config.set_config_version(0);
-  RETURN_NOT_OK(
-      auto_flag_manager->LoadFromConfig(std::move(new_config), ApplyNonRuntimeAutoFlags::kTrue));
+  new_config.set_config_version(kInvalidAutoFlagsConfigVersion);
+  RETURN_NOT_OK(auto_flag_manager.LoadNewConfig(std::move(new_config)));
   return OK();
 }
 
 Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteAutoFlags(
     const AutoFlagClass max_flag_class, const PromoteNonRuntimeAutoFlags promote_non_runtime_flags,
-    const bool force_version_change, const AutoFlagsManager& auto_flag_manager,
+    const bool force_version_change, AutoFlagsManager& auto_flag_manager,
     CatalogManager* catalog_manager) {
   SCHECK(!FLAGS_disable_auto_flags_management, NotSupported, "AutoFlags management is disabled.");
 
@@ -292,14 +310,14 @@ Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteAutoFlags(
   auto outcome = InsertFlagsToConfig(eligible_flags, &new_config, force_version_change);
 
   if (outcome != PromoteAutoFlagsOutcome::kNoFlagsPromoted) {
-    RETURN_NOT_OK(StoreAutoFlagsConfig(new_config, catalog_manager));
+    RETURN_NOT_OK(StoreAutoFlagsConfig(auto_flag_manager, new_config, catalog_manager));
   }
 
   return std::make_pair(new_config.config_version(), outcome);
 }
 
 Result<std::pair<uint32_t, bool>> RollbackAutoFlags(
-    uint32_t rollback_version, const AutoFlagsManager& auto_flag_manager,
+    uint32_t rollback_version, AutoFlagsManager& auto_flag_manager,
     CatalogManager* catalog_manager) {
   SCHECK(!FLAGS_disable_auto_flags_management, NotSupported, "AutoFlags management is disabled.");
 
@@ -331,14 +349,14 @@ Result<std::pair<uint32_t, bool>> RollbackAutoFlags(
             << ", flags_removed: " << yb::ToString(removed_flags)
             << ", new_config_version: " << new_config.config_version();
 
-  RETURN_NOT_OK(StoreAutoFlagsConfig(new_config, catalog_manager));
+  RETURN_NOT_OK(StoreAutoFlagsConfig(auto_flag_manager, new_config, catalog_manager));
 
   return std::make_pair(new_config.config_version(), true);
 }
 
 Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteSingleAutoFlag(
     const ProcessName& process_name, const std::string& flag_name,
-    const AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager) {
+    AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager) {
   SCHECK(!FLAGS_disable_auto_flags_management, NotSupported, "AutoFlags management is disabled.");
 
   auto all_flags = VERIFY_RESULT(AutoFlagsUtil::GetAvailableAutoFlags());
@@ -354,7 +372,7 @@ Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteSingleAutoFlag(
   auto outcome = InsertFlagsToConfig(flag_to_insert, &new_config, /* force_version_change */ false);
 
   if (outcome != PromoteAutoFlagsOutcome::kNoFlagsPromoted) {
-    RETURN_NOT_OK(StoreAutoFlagsConfig(new_config, catalog_manager));
+    RETURN_NOT_OK(StoreAutoFlagsConfig(auto_flag_manager, new_config, catalog_manager));
   }
 
   LOG(INFO) << "Promote AutoFlag. process_name: " << process_name << ", flag_name: " << flag_name
@@ -365,7 +383,7 @@ Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteSingleAutoFlag(
 
 Result<std::pair<uint32_t, bool>> DemoteSingleAutoFlag(
     const ProcessName& process_name, const std::string& flag_name,
-    const AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager) {
+    AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager) {
   SCHECK(!FLAGS_disable_auto_flags_management, NotSupported, "AutoFlags management is disabled.");
 
   auto new_config = auto_flag_manager.GetConfig();
@@ -377,8 +395,20 @@ Result<std::pair<uint32_t, bool>> DemoteSingleAutoFlag(
   LOG(INFO) << "Demote AutoFlag. process_name: " << process_name << ", flag_name: " << flag_name
             << ", new_config_version: " << new_config.config_version();
 
-  RETURN_NOT_OK(StoreAutoFlagsConfig(new_config, catalog_manager));
+  RETURN_NOT_OK(StoreAutoFlagsConfig(auto_flag_manager, new_config, catalog_manager));
 
   return std::make_pair(new_config.config_version(), true);
 }
+
+Result<bool> AreAutoFlagsCompatible(
+    const AutoFlagsConfigPB& base_config, const AutoFlagsConfigPB& config_to_check,
+    AutoFlagClass min_class) {
+  const auto base_flags = GetFlagsFromConfig(base_config);
+  const auto to_check_flags = GetFlagsFromConfig(config_to_check);
+  const auto auto_flag_infos = VERIFY_RESULT(AutoFlagsUtil::GetAvailableAutoFlags());
+
+  return AutoFlagsUtil::AreAutoFlagsCompatible(
+      base_flags, to_check_flags, auto_flag_infos, min_class);
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/auto_flags_orchestrator.h b/src/yb/master/auto_flags_orchestrator.h
index ec8e165e6a..081cbe79ec 100644
--- a/src/yb/master/auto_flags_orchestrator.h
+++ b/src/yb/master/auto_flags_orchestrator.h
@@ -18,6 +18,7 @@
 #include "yb/util/status.h"
 
 namespace yb {
+class AutoFlagsConfigPB;
 class AutoFlagsManager;
 class CatalogManager;
 
@@ -25,12 +26,12 @@ namespace master {
 // Create and persist a empty AutoFlags config with version set to 1.
 // Intended to be used during the first process startup after the upgrade of clusters created on
 // versions without AutoFlags.
-Status CreateEmptyAutoFlagsConfig(AutoFlagsManager* auto_flag_manager);
+Status CreateEmptyAutoFlagsConfig(AutoFlagsManager& auto_flag_manager);
 
 // Create and persist a new AutoFlags config where all AutoFlags of class within
 // FLAGS_limit_auto_flag_promote_for_new_universe are promoted and Apply it.
 // Intended to be used in new cluster created with AutoFlags.
-Status CreateAutoFlagsConfigForNewCluster(AutoFlagsManager* auto_flag_manager);
+Status CreateAutoFlagsConfigForNewCluster(AutoFlagsManager& auto_flag_manager);
 
 YB_DEFINE_ENUM(
     PromoteAutoFlagsOutcome, (kNoFlagsPromoted)(kNewFlagsPromoted)(kNonRuntimeFlagsPromoted));
@@ -41,16 +42,16 @@ YB_DEFINE_ENUM(
 // promoted.
 Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteAutoFlags(
     const AutoFlagClass max_flag_class, const PromoteNonRuntimeAutoFlags promote_non_runtime_flags,
-    const bool force, const AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager);
+    const bool force, AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager);
 
 Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteSingleAutoFlag(
     const ProcessName& process_name, const std::string& flag_name,
-    const AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager);
+    AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager);
 
 // Rollback AutoFlags to the specified version. Only Volatile AutoFlags are eligible for rollback.
 // Returns weather any flags were rolled back and the new config version.
 Result<std::pair<uint32_t, bool>> RollbackAutoFlags(
-    uint32_t rollback_version, const AutoFlagsManager& auto_flag_manager,
+    uint32_t rollback_version, AutoFlagsManager& auto_flag_manager,
     CatalogManager* catalog_manager);
 
 // Demote a single AutoFlag. Returns weather the flag was demoted and the new config version.
@@ -58,7 +59,13 @@ Result<std::pair<uint32_t, bool>> RollbackAutoFlags(
 // engineering team.
 Result<std::pair<uint32_t, bool>> DemoteSingleAutoFlag(
     const ProcessName& process_name, const std::string& flag_name,
-    const AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager);
+    AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager);
+
+// Wrapper over the AutoFlagsUtil::AreAutoFlagsCompatible.
+Result<bool> AreAutoFlagsCompatible(
+    const AutoFlagsConfigPB& base_config, const AutoFlagsConfigPB& config_to_check,
+    AutoFlagClass min_class);
+
 }  // namespace master
 
 }  // namespace yb
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 82002ccd37..7f92c07efe 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -13201,6 +13201,28 @@ Status CatalogManager::DemoteSingleAutoFlag(
   return Status::OK();
 }
 
+Status CatalogManager::ValidateAutoFlagsConfig(
+    const ValidateAutoFlagsConfigRequestPB* req, ValidateAutoFlagsConfigResponsePB* resp) {
+  VLOG_WITH_FUNC(1) << req->ShortDebugString();
+
+  auto min_class = AutoFlagClass::kLocalVolatile;
+  if (req->has_min_flag_class()) {
+    min_class = VERIFY_RESULT_PREPEND(
+        yb::UnderlyingToEnumSlow<yb::AutoFlagClass>(req->min_flag_class()),
+        "Invalid value provided for flag class");
+  }
+
+  auto local_auto_flag_config = master_->GetAutoFlagsConfig();
+  auto valid =
+      VERIFY_RESULT(AreAutoFlagsCompatible(local_auto_flag_config, req->config(), min_class));
+  VLOG_WITH_FUNC(1) << valid;
+
+  resp->set_valid(valid);
+  resp->set_config_version(local_auto_flag_config.config_version());
+
+  return Status::OK();
+}
+
 Status CatalogManager::GetStatefulServiceLocation(
     const GetStatefulServiceLocationRequestPB* req, GetStatefulServiceLocationResponsePB* resp) {
   VLOG(4) << "GetStatefulServiceLocation: " << req->ShortDebugString();
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index 383930b391..84a83a6cd9 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -1132,6 +1132,8 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
       const PromoteSingleAutoFlagRequestPB* req, PromoteSingleAutoFlagResponsePB* resp);
   Status DemoteSingleAutoFlag(
       const DemoteSingleAutoFlagRequestPB* req, DemoteSingleAutoFlagResponsePB* resp);
+  Status ValidateAutoFlagsConfig(
+      const ValidateAutoFlagsConfigRequestPB* req, ValidateAutoFlagsConfigResponsePB* resp);
 
   Status ReportYsqlDdlTxnStatus(
       const ReportYsqlDdlTxnStatusRequestPB* req,
diff --git a/src/yb/master/master.cc b/src/yb/master/master.cc
index 9b880cb022..4b3caaf925 100644
--- a/src/yb/master/master.cc
+++ b/src/yb/master/master.cc
@@ -165,7 +165,7 @@ namespace master {
 Master::Master(const MasterOptions& opts)
     : DbServerBase("Master", opts, "yb.master", server::CreateMemTrackerForServer()),
       state_(kStopped),
-      auto_flags_manager_(new AutoFlagsManager("yb-master", fs_manager_.get())),
+      auto_flags_manager_(new AutoFlagsManager("yb-master", clock(), fs_manager_.get())),
       ts_manager_(new TSManager()),
       catalog_manager_(new CatalogManager(this)),
       ysql_backends_manager_(new YsqlBackendsManager(this, catalog_manager_->AsyncTaskPool())),
@@ -235,16 +235,18 @@ Status Master::Init() {
 }
 
 Status Master::InitAutoFlags() {
+  RETURN_NOT_OK(auto_flags_manager_->Init(options_.HostsString()));
+
   if (!VERIFY_RESULT(auto_flags_manager_->LoadFromFile())) {
     if (fs_manager_->LookupTablet(kSysCatalogTabletId)) {
       // Pre-existing cluster
-      RETURN_NOT_OK(CreateEmptyAutoFlagsConfig(auto_flags_manager_.get()));
+      RETURN_NOT_OK(CreateEmptyAutoFlagsConfig(*auto_flags_manager_.get()));
     } else if (!opts().AreMasterAddressesProvided()) {
       // New master in Shell mode
       LOG(INFO) << "AutoFlags initialization delayed as master is in Shell mode.";
     } else {
       // New cluster
-      RETURN_NOT_OK(CreateAutoFlagsConfigForNewCluster(auto_flags_manager_.get()));
+      RETURN_NOT_OK(CreateAutoFlagsConfigForNewCluster(*auto_flags_manager_.get()));
     }
   }
 
@@ -261,7 +263,7 @@ Status Master::InitAutoFlagsFromMasterLeader(const HostPort& leader_address) {
       "Cannot load AutoFlags from another master when not in shell mode.");
 
   return auto_flags_manager_->LoadFromMaster(
-      options_.HostsString(), {{leader_address}}, ApplyNonRuntimeAutoFlags::kTrue);
+      options_.HostsString(), {{leader_address}});
 }
 
 MonoDelta Master::default_client_timeout() {
diff --git a/src/yb/master/master_cluster.proto b/src/yb/master/master_cluster.proto
index 27ceebb40a..1fd7f35b2a 100644
--- a/src/yb/master/master_cluster.proto
+++ b/src/yb/master/master_cluster.proto
@@ -262,6 +262,17 @@ message GetAutoFlagsConfigResponsePB {
   optional MasterErrorPB error = 3;
 }
 
+message ValidateAutoFlagsConfigRequestPB {
+  required AutoFlagsConfigPB config = 1;
+  optional uint32 min_flag_class = 2;
+}
+
+message ValidateAutoFlagsConfigResponsePB {
+  optional MasterErrorPB error = 1;
+  optional bool valid = 2;
+  optional uint32 config_version = 3;
+}
+
 message PromoteAutoFlagsRequestPB {
   required string max_flag_class = 1;
   required bool promote_non_runtime_flags = 2;
@@ -338,6 +349,8 @@ service MasterCluster {
       returns (PromoteSingleAutoFlagResponsePB);
   rpc DemoteSingleAutoFlag(DemoteSingleAutoFlagRequestPB)
       returns (DemoteSingleAutoFlagResponsePB);
+  rpc ValidateAutoFlagsConfig(ValidateAutoFlagsConfigRequestPB)
+      returns (ValidateAutoFlagsConfigResponsePB);
 
   // Get the ready status from the catalog manager for this master.
   // NOTE: Should be used only for unit testing purposes.
diff --git a/src/yb/master/master_cluster_service.cc b/src/yb/master/master_cluster_service.cc
index 2a8dde4c53..3c56add622 100644
--- a/src/yb/master/master_cluster_service.cc
+++ b/src/yb/master/master_cluster_service.cc
@@ -386,6 +386,7 @@ class MasterClusterServiceImpl : public MasterServiceBase, public MasterClusterI
     (RollbackAutoFlags)
     (PromoteSingleAutoFlag)
     (DemoteSingleAutoFlag)
+    (ValidateAutoFlagsConfig)
   )
 
   MASTER_SERVICE_IMPL_ON_LEADER_WITH_LOCK(XClusterManager,
diff --git a/src/yb/server/server_base.cc b/src/yb/server/server_base.cc
index 8c9197db11..946a7230fa 100644
--- a/src/yb/server/server_base.cc
+++ b/src/yb/server/server_base.cc
@@ -297,6 +297,8 @@ Status RpcServerBase::Init() {
     RETURN_NOT_OK_PREPEND(clock_->Init(), "Cannot initialize clock");
   }
 
+  RETURN_NOT_OK(InitAutoFlags());
+
   // Create the Messenger.
   rpc::MessengerBuilder builder(name_);
   builder.UseDefaultConnectionContextFactory(mem_tracker());
@@ -511,8 +513,6 @@ Status RpcAndWebServerBase::Init() {
     return STATUS(NetworkError, "Simulated port conflict error");
   }
 
-  RETURN_NOT_OK(InitAutoFlags());
-
   RETURN_NOT_OK(RpcServerBase::Init());
 
   return Status::OK();
diff --git a/src/yb/tablet/operations/change_auto_flags_config_operation.cc b/src/yb/tablet/operations/change_auto_flags_config_operation.cc
index 553f4f7615..2686bd1d07 100644
--- a/src/yb/tablet/operations/change_auto_flags_config_operation.cc
+++ b/src/yb/tablet/operations/change_auto_flags_config_operation.cc
@@ -51,7 +51,7 @@ Status ChangeAutoFlagsConfigOperation::Apply() {
   // critical failures like IO issues and invalid flags (indicating we are running an unsupported
   // code version). Execution must stop immediately to protect data correctness, so we return the
   // Status directly instead of setting complete_status.
-  RETURN_NOT_OK(tablet->ApplyAutoFlagsConfig(request()->ToGoogleProtobuf()));
+  RETURN_NOT_OK(tablet->ProcessAutoFlagsConfigOperation(request()->ToGoogleProtobuf()));
 
   VLOG_WITH_PREFIX_AND_FUNC(2) << "Completed";
 
diff --git a/src/yb/tablet/tablet.cc b/src/yb/tablet/tablet.cc
index 5ef3e54008..2dfc3bad3c 100644
--- a/src/yb/tablet/tablet.cc
+++ b/src/yb/tablet/tablet.cc
@@ -4306,7 +4306,7 @@ HybridTime Tablet::DeleteMarkerRetentionTime(const std::vector<rocksdb::FileMeta
   return result;
 }
 
-Status Tablet::ApplyAutoFlagsConfig(const AutoFlagsConfigPB& config) {
+Status Tablet::ProcessAutoFlagsConfigOperation(const AutoFlagsConfigPB& config) {
   if (!is_sys_catalog()) {
     LOG_WITH_PREFIX_AND_FUNC(DFATAL) << "AutoFlags config change ignored on non-sys_catalog tablet";
     return Status::OK();
@@ -4317,7 +4317,7 @@ Status Tablet::ApplyAutoFlagsConfig(const AutoFlagsConfigPB& config) {
     return STATUS(InternalError, "AutoFlags manager not found");
   }
 
-  return auto_flags_manager_->LoadFromConfig(config, ApplyNonRuntimeAutoFlags::kFalse);
+  return auto_flags_manager_->ProcessAutoFlagsConfigOperation(config);
 }
 
 Status PopulateLockInfoFromIntent(
diff --git a/src/yb/tablet/tablet.h b/src/yb/tablet/tablet.h
index 88a2f9068c..b73ceea4b3 100644
--- a/src/yb/tablet/tablet.h
+++ b/src/yb/tablet/tablet.h
@@ -854,7 +854,7 @@ class Tablet : public AbstractTablet,
 
   // Store the new AutoFlags config to disk and then applies it. Error Status is returned only for
   // critical failures.
-  Status ApplyAutoFlagsConfig(const AutoFlagsConfigPB& config);
+  Status ProcessAutoFlagsConfigOperation(const AutoFlagsConfigPB& config);
 
   std::string LogPrefix() const;
 
diff --git a/src/yb/tserver/heartbeater.cc b/src/yb/tserver/heartbeater.cc
index 81581c9d43..33d0c11c88 100644
--- a/src/yb/tserver/heartbeater.cc
+++ b/src/yb/tserver/heartbeater.cc
@@ -463,8 +463,10 @@ Status Heartbeater::Thread::TryHeartbeat() {
 
   // Include the hybrid time of this tablet server in the heartbeat.
   auto* hybrid_clock = dynamic_cast<server::HybridClock*>(server_->Clock());
+  HybridTime heartbeat_send_time;
   if (hybrid_clock) {
-    req.set_ts_hybrid_time(hybrid_clock->Now().ToUint64());
+    heartbeat_send_time = hybrid_clock->Now();
+    req.set_ts_hybrid_time(heartbeat_send_time.ToUint64());
     // Also include the physical clock time of this tablet server in the heartbeat.
     Result<PhysicalTime> now = hybrid_clock->physical_clock()->Now();
     if (!now.ok()) {
@@ -618,9 +620,11 @@ Status Heartbeater::Thread::TryHeartbeat() {
 
   server_->UpdateXClusterSafeTime(last_hb_response_.xcluster_namespace_to_safe_time());
 
+  std::optional<AutoFlagsConfigPB> new_config;
   if (last_hb_response_.has_auto_flags_config()) {
-    RETURN_NOT_OK(server_->SetAutoFlagConfig(last_hb_response_.auto_flags_config()));
+    new_config = last_hb_response_.auto_flags_config();
   }
+  server_->HandleMasterHeartbeatResponse(heartbeat_send_time, std::move(new_config));
 
   // Update the live tserver list.
   return server_->PopulateLiveTServers(last_hb_response_);
diff --git a/src/yb/tserver/mini_tablet_server.cc b/src/yb/tserver/mini_tablet_server.cc
index dbd764ce0b..d266dba831 100644
--- a/src/yb/tserver/mini_tablet_server.cc
+++ b/src/yb/tserver/mini_tablet_server.cc
@@ -139,7 +139,9 @@ Status MiniTabletServer::Start(WaitTabletsBootstrapped wait_tablets_bootstrapped
 
   server_.swap(server);
 
+  LOG(WARNING) << "hk!! ts Reconnect s";
   RETURN_NOT_OK(Reconnect());
+  LOG(WARNING) << "hk!! ts Reconnect e";
 
   started_ = true;
   return wait_tablets_bootstrapped ? WaitStarted() : Status::OK();
@@ -179,7 +181,10 @@ Status MiniTabletServer::Reconnect() {
 }
 
 Status MiniTabletServer::WaitStarted() {
+  LOG(WARNING) << "hk!! WaitStarted";
   return server_->WaitInited();
+
+  LOG(WARNING) << "hk!! WaitStarted end";
 }
 
 void MiniTabletServer::Shutdown() {
diff --git a/src/yb/tserver/tablet_server.cc b/src/yb/tserver/tablet_server.cc
index 0da5c581d3..dcb6c9ab67 100644
--- a/src/yb/tserver/tablet_server.cc
+++ b/src/yb/tserver/tablet_server.cc
@@ -301,7 +301,7 @@ TabletServer::TabletServer(const TabletServerOptions& opts)
     : DbServerBase("TabletServer", opts, "yb.tabletserver", server::CreateMemTrackerForServer()),
       fail_heartbeats_for_tests_(false),
       opts_(opts),
-      auto_flags_manager_(new AutoFlagsManager("yb-tserver", fs_manager_.get())),
+      auto_flags_manager_(new AutoFlagsManager("yb-tserver", clock(), fs_manager_.get())),
       tablet_manager_(new TSTabletManager(fs_manager_.get(), this, metric_registry())),
       path_handlers_(new TabletServerPathHandlers(this)),
       maintenance_manager_(new MaintenanceManager(MaintenanceManager::DEFAULT_OPTIONS)),
@@ -500,9 +500,11 @@ Status TabletServer::Init() {
 }
 
 Status TabletServer::InitAutoFlags() {
+  RETURN_NOT_OK(auto_flags_manager_->Init(options_.HostsString()));
+
   if (!VERIFY_RESULT(auto_flags_manager_->LoadFromFile())) {
-    RETURN_NOT_OK(auto_flags_manager_->LoadFromMaster(
-        options_.HostsString(), *opts_.GetMasterAddresses(), ApplyNonRuntimeAutoFlags::kTrue));
+    RETURN_NOT_OK(
+        auto_flags_manager_->LoadFromMaster(options_.HostsString(), *opts_.GetMasterAddresses()));
   }
 
   return RpcAndWebServerBase::InitAutoFlags();
@@ -516,9 +518,13 @@ uint32_t TabletServer::GetAutoFlagConfigVersion() const {
   return auto_flags_manager_->GetConfigVersion();
 }
 
-Status TabletServer::SetAutoFlagConfig(const AutoFlagsConfigPB new_config) {
-  return auto_flags_manager_->LoadFromConfig(
-      std::move(new_config), ApplyNonRuntimeAutoFlags::kFalse);
+void TabletServer::HandleMasterHeartbeatResponse(
+    HybridTime heartbeat_sent_time, std::optional<AutoFlagsConfigPB> new_config) {
+  auto_flags_manager_->HandleMasterHeartbeatResponse(heartbeat_sent_time, std::move(new_config));
+}
+
+Result<uint32> TabletServer::ValidateAndGetAutoFlagsConfigVersion() const {
+  return auto_flags_manager_->ValidateAndGetConfigVersion();
 }
 
 AutoFlagsConfigPB TabletServer::TEST_GetAutoFlagConfig() const {
diff --git a/src/yb/tserver/tablet_server.h b/src/yb/tserver/tablet_server.h
index 0f2d9672c9..8a81b01fda 100644
--- a/src/yb/tserver/tablet_server.h
+++ b/src/yb/tserver/tablet_server.h
@@ -119,7 +119,10 @@ class TabletServer : public DbServerBase, public TabletServerIf {
   std::string ToString() const override;
 
   uint32_t GetAutoFlagConfigVersion() const override;
-  Status SetAutoFlagConfig(const AutoFlagsConfigPB new_config);
+  void HandleMasterHeartbeatResponse(
+      HybridTime heartbeat_sent_time, std::optional<AutoFlagsConfigPB> new_config);
+
+  Result<uint32> ValidateAndGetAutoFlagsConfigVersion() const;
 
   AutoFlagsConfigPB TEST_GetAutoFlagConfig() const;
 
diff --git a/src/yb/util/flags/auto_flags-test.cc b/src/yb/util/flags/auto_flags-test.cc
index 418c530d46..c4d4763443 100644
--- a/src/yb/util/flags/auto_flags-test.cc
+++ b/src/yb/util/flags/auto_flags-test.cc
@@ -201,4 +201,70 @@ TEST(AutoFlagsTest, TestDemote) {
   ASSERT_EQ(FLAGS_test_auto_flag, 10);
   VerifyFlagDefault(0);
 }
+
+// to_check_flags is compatible to base_flags when all flags with class equal to or above
+// min_class in base_flags exist in to_check_flags.
+TEST(AutoFlagsTest, AreAutoFlagsCompatible) {
+  const string kProcess1 = "p1", kProcess2 = "p2", kProcess3 = "p3";
+  const string kLocalVolatileFlag = "LV1", kLocalPersistedFlag = "LP1", kExternalFlag = "E1",
+               kNewInstallsOnlyFlag = "NI1";
+  AutoFlagsInfoMap flag_infos;
+  flag_infos[kProcess1].emplace_back(
+      kLocalVolatileFlag, AutoFlagClass::kLocalVolatile, RuntimeAutoFlag::kTrue);
+  flag_infos[kProcess2].emplace_back(
+      kLocalPersistedFlag, AutoFlagClass::kLocalPersisted, RuntimeAutoFlag::kTrue);
+  flag_infos[kProcess3].emplace_back(
+      kExternalFlag, AutoFlagClass::kExternal, RuntimeAutoFlag::kFalse);
+  flag_infos[kProcess3].emplace_back(
+      kNewInstallsOnlyFlag, AutoFlagClass::kNewInstallsOnly, RuntimeAutoFlag::kTrue);
+
+  AutoFlagsNameMap base_flags;
+  AutoFlagsNameMap to_check_flags;
+
+  auto are_flags_compatible = [&](const AutoFlagClass min_class) {
+    return AutoFlagsUtil::AreAutoFlagsCompatible(base_flags, to_check_flags, flag_infos, min_class);
+  };
+
+  // Invalid process in the base map.
+  base_flags["x1"].emplace(kLocalVolatileFlag);
+  ASSERT_NOK(are_flags_compatible(AutoFlagClass::kLocalVolatile));
+  base_flags.clear();
+
+  // Invalid flag in the base map.
+  base_flags[kProcess1].emplace("x1");
+  ASSERT_NOK(are_flags_compatible(AutoFlagClass::kLocalVolatile));
+  base_flags.clear();
+
+  // base_flags has more kLocalVolatile flags.
+  base_flags[kProcess1].emplace(kLocalVolatileFlag);
+  ASSERT_FALSE(ASSERT_RESULT(are_flags_compatible(AutoFlagClass::kLocalVolatile)));
+  ASSERT_TRUE(ASSERT_RESULT(are_flags_compatible(AutoFlagClass::kLocalPersisted)));
+
+  // Matching kLocalVolatile flags.
+  to_check_flags[kProcess1].emplace(kLocalVolatileFlag);
+  ASSERT_TRUE(ASSERT_RESULT(are_flags_compatible(AutoFlagClass::kLocalVolatile)));
+
+  // to_check_flags has more kLocalVolatile flags.
+  to_check_flags[kProcess1].emplace("LV2");
+  ASSERT_TRUE(ASSERT_RESULT(are_flags_compatible(AutoFlagClass::kLocalVolatile)));
+
+  // base_flags has more kLocalPersisted flags.
+  base_flags[kProcess2].emplace(kLocalPersistedFlag);
+  ASSERT_FALSE(ASSERT_RESULT(are_flags_compatible(AutoFlagClass::kLocalPersisted)));
+  ASSERT_TRUE(ASSERT_RESULT(are_flags_compatible(AutoFlagClass::kExternal)));
+
+  // to_check_flags has kLocalPersisted in different process.
+  to_check_flags[kProcess3].emplace(kLocalPersistedFlag);
+  ASSERT_FALSE(ASSERT_RESULT(are_flags_compatible(AutoFlagClass::kLocalPersisted)));
+
+  // to_check_flags has extra kNewInstallsOnly and kExternal.
+  to_check_flags[kProcess3].emplace(kExternalFlag);
+  to_check_flags[kProcess3].emplace(kNewInstallsOnlyFlag);
+  ASSERT_FALSE(ASSERT_RESULT(are_flags_compatible(AutoFlagClass::kLocalPersisted)));
+
+  // Add the missing flag to to_check_flags.
+  to_check_flags[kProcess2].emplace(kLocalPersistedFlag);
+  ASSERT_TRUE(ASSERT_RESULT(are_flags_compatible(AutoFlagClass::kNewInstallsOnly)));
+}
+
 }  // namespace yb
diff --git a/src/yb/util/flags/auto_flags_util.cc b/src/yb/util/flags/auto_flags_util.cc
index baa558e32a..95ebf6b8f6 100644
--- a/src/yb/util/flags/auto_flags_util.cc
+++ b/src/yb/util/flags/auto_flags_util.cc
@@ -15,6 +15,7 @@
 #include <string>
 
 #include "yb/common/json_util.h"
+#include "yb/gutil/map-util.h"
 #include "yb/util/flags/auto_flags_util.h"
 #include "yb/util/env_util.h"
 #include "yb/util/path_util.h"
@@ -177,6 +178,41 @@ Result<AutoFlagsInfoMap> GetFlagsEligibleForPromotion(
 
   return GetFlagsEligibleForPromotion(available_flags, max_flag_class, promote_non_runtime);
 }
+
+Result<bool> AreAutoFlagsCompatible(
+    const AutoFlagsNameMap& base_flags, const AutoFlagsNameMap& to_check_flags,
+    const AutoFlagsInfoMap& auto_flag_infos, AutoFlagClass min_class) {
+  for (const auto& [process_name, base_process_flags] : base_flags) {
+    auto process_flag_info = FindOrNull(auto_flag_infos, process_name);
+    SCHECK(process_flag_info, NotFound, "AutoFlags info for process $0 not found", process_name);
+
+    auto to_check_flags_set = FindOrNull(to_check_flags, process_name);
+    uint32 num_flags = 0;
+
+    for (const auto& flag : *process_flag_info) {
+      if (!base_process_flags.contains(flag.name)) {
+        continue;
+      }
+      num_flags++;
+      if (flag.flag_class < min_class) {
+        continue;
+      }
+
+      if (!to_check_flags_set || !to_check_flags_set->contains(flag.name)) {
+        LOG_WITH_FUNC(INFO) << "Flag " << flag.name << " of process " << process_name
+                            << " with class " << flag.flag_class
+                            << " not found in config to validate";
+        return false;
+      }
+    }
+
+    SCHECK_EQ(
+        num_flags, base_process_flags.size(), NotFound, "AutoFlags info for some flags not found");
+  }
+
+  return true;
+}
+
 }  // namespace AutoFlagsUtil
 
 }  // namespace yb
diff --git a/src/yb/util/flags/auto_flags_util.h b/src/yb/util/flags/auto_flags_util.h
index d071d2b7d6..8a87e780cd 100644
--- a/src/yb/util/flags/auto_flags_util.h
+++ b/src/yb/util/flags/auto_flags_util.h
@@ -13,12 +13,16 @@
 
 #pragma once
 
-#include <map>
+#include <unordered_map>
 #include "yb/util/flags/auto_flags.h"
 #include "yb/util/status.h"
 #include "yb/util/strongly_typed_string.h"
 
 namespace yb {
+
+constexpr uint32 kInvalidAutoFlagsConfigVersion = 0;
+constexpr uint32 kMinAutoFlagsConfigVersion = 0;
+
 namespace server {
 class ServerBaseOptions;
 }
@@ -37,7 +41,10 @@ struct AutoFlagInfo {
 
 YB_STRONGLY_TYPED_BOOL(PromoteNonRuntimeAutoFlags)
 
-typedef std::map<ProcessName, std::vector<AutoFlagInfo>> AutoFlagsInfoMap;
+// Map from ProcessName to AutoFlag infos.
+using AutoFlagsInfoMap = std::unordered_map<ProcessName, std::vector<AutoFlagInfo>>;
+// Map from ProcessName to AutoFlag names.
+using AutoFlagsNameMap = std::unordered_map<ProcessName, std::unordered_set<std::string>>;
 
 namespace AutoFlagsUtil {
 std::string DumpAutoFlagsToJSON(const ProcessName& program_name);
@@ -50,6 +57,14 @@ Result<AutoFlagsInfoMap> GetFlagsEligibleForPromotion(
 AutoFlagsInfoMap GetFlagsEligibleForPromotion(
     const AutoFlagsInfoMap& available_flags, const AutoFlagClass max_flag_class,
     const PromoteNonRuntimeAutoFlags promote_non_runtime);
+
+// Returns true if all flags in base_config with class greater to or equal to min_class are found in
+// the base_config.
+// That is, base_config is a superset of flags with class greater to or equal to min_class.
+Result<bool> AreAutoFlagsCompatible(
+    const AutoFlagsNameMap& base_flags, const AutoFlagsNameMap& to_check_flags,
+    const AutoFlagsInfoMap& auto_flag_infos, AutoFlagClass min_class);
+
 };  // namespace AutoFlagsUtil
 
 }  // namespace yb
