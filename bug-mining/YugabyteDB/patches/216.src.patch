diff --git a/src/yb/integration-tests/external_mini_cluster.cc b/src/yb/integration-tests/external_mini_cluster.cc
index acd330f6d8..0a963fc98e 100644
--- a/src/yb/integration-tests/external_mini_cluster.cc
+++ b/src/yb/integration-tests/external_mini_cluster.cc
@@ -2238,16 +2238,20 @@ LogWaiter::LogWaiter(ExternalDaemon* daemon, const std::string& string_to_wait)
   daemon_->SetLogListener(this);
 }
 
-Status ExternalMiniCluster::CallYbAdmin(const std::vector<std::string>& args, MonoDelta timeout) {
+Status ExternalMiniCluster::CallYbAdmin(
+    const std::vector<std::string>& args, MonoDelta timeout, std::string* output) {
   auto command = ToStringVector(
       GetToolPath("yb-admin"), "-master_addresses", GetMasterAddresses(), "-timeout_ms",
       timeout.ToMilliseconds());
   command.insert(command.end(), args.begin(), args.end());
 
   LOG(INFO) << "Running " << ToString(command);
-  std::string output, error;
-  auto status = Subprocess::Call(command, &output, &error);
-  LOG(INFO) << "yb-admin Output: " << output;
+  std::string output_internal, error;
+  if (!output) {
+    output = &output_internal;
+  }
+  auto status = Subprocess::Call(command, output, &error);
+  LOG(INFO) << "yb-admin Output: " << *output;
   if (!error.empty()) {
     LOG(INFO) << "yb-admin Error: " << error;
   }
diff --git a/src/yb/integration-tests/external_mini_cluster.h b/src/yb/integration-tests/external_mini_cluster.h
index 3038e481a6..41466c7eaa 100644
--- a/src/yb/integration-tests/external_mini_cluster.h
+++ b/src/yb/integration-tests/external_mini_cluster.h
@@ -583,7 +583,8 @@ class ExternalMiniCluster : public MiniClusterBase {
   void SetMaxGracefulShutdownWaitSec(int max_graceful_shutdown_wait_sec);
 
   Status CallYbAdmin(
-      const std::vector<std::string>& args, MonoDelta timeout = MonoDelta::FromSeconds(60));
+      const std::vector<std::string>& args, MonoDelta timeout = MonoDelta::FromSeconds(60),
+      std::string* output = nullptr);
 
  protected:
   friend class UpgradeTestBase;
diff --git a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_rpcs-test.cc b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_rpcs-test.cc
index 90c99129d4..5640dfe19e 100644
--- a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_rpcs-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_rpcs-test.cc
@@ -14,10 +14,6 @@
 #include "yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h"
 
 #include "yb/master/master_admin.proxy.h"
-#include "yb/tools/yb-admin_client.h"
-#include "yb/util/backoff_waiter.h"
-#include "yb/util/sync_point.h"
-#include "yb/yql/pgwrapper/libpq_utils.h"
 
 using namespace std::literals;
 
@@ -69,6 +65,9 @@ class YsqlMajorUpgradeRpcsTest : public Pg15UpgradeTestBase {
   Status CompleteUpgradeAndValidate() {
     RETURN_NOT_OK(WaitForYsqlMajorCatalogUpgradeToFinish());
 
+    RETURN_NOT_OK(ValidateYsqlMajorCatalogUpgradeState(
+        master::YSQL_MAJOR_CATALOG_UPGRADE_PENDING_FINALIZE_OR_ROLLBACK));
+
     LOG(INFO) << "Restarting yb-tserver " << kMixedModeTserverPg15 << " in current version";
     auto mixed_mode_pg15_tserver = cluster_->tablet_server(kMixedModeTserverPg15);
     RETURN_NOT_OK(RestartTServerInCurrentVersion(
@@ -81,12 +80,73 @@ class YsqlMajorUpgradeRpcsTest : public Pg15UpgradeTestBase {
 
     return InsertRowInSimpleTableAndValidate();
   }
+
+  Status ValidateYsqlMajorCatalogUpgradeState(master::YsqlMajorCatalogUpgradeState state) {
+    rpc::RpcController rpc;
+    rpc.set_timeout(10s);
+    master::GetYsqlMajorCatalogUpgradeStateRequestPB req;
+    master::GetYsqlMajorCatalogUpgradeStateResponsePB resp;
+    RETURN_NOT_OK(GetMasterAdminProxy().GetYsqlMajorCatalogUpgradeState(req, &resp, &rpc));
+    if (resp.has_error()) {
+      return StatusFromPB(resp.error().status());
+    }
+
+    SCHECK(
+        resp.state() == state, IllegalState,
+        Format(
+            "Expected state: $0, actual state: $1",
+            master::YsqlMajorCatalogUpgradeState_Name(state),
+            master::YsqlMajorCatalogUpgradeState_Name(resp.state())));
+
+    RETURN_NOT_OK(ValidateYsqlMajorUpgradeCatalogStateViaYbAdmin(state));
+    return Status::OK();
+  }
+
+  Status ValidateYsqlMajorUpgradeCatalogStateViaYbAdmin(
+      master::YsqlMajorCatalogUpgradeState state) {
+    std::string output;
+    RETURN_NOT_OK(
+        cluster_->CallYbAdmin({"get_ysql_major_version_catalog_upgrade_state"}, 10min, &output));
+
+    switch (state) {
+      case master::YSQL_MAJOR_CATALOG_UPGRADE_UNINITIALIZED:
+        // Bad enum, fail the call.
+        break;
+      case master::YSQL_MAJOR_CATALOG_UPGRADE_DONE:
+        SCHECK_STR_CONTAINS(
+            output, "YSQL major catalog upgrade already completed, or is not required.");
+        return Status::OK();
+      case master::YSQL_MAJOR_CATALOG_UPGRADE_PENDING:
+        SCHECK_STR_CONTAINS(
+            output, "YSQL major catalog upgrade for YSQL major upgrade has not yet started.");
+        return Status::OK();
+      case master::YSQL_MAJOR_CATALOG_UPGRADE_IN_PROGRESS:
+        SCHECK_STR_CONTAINS(output, "YSQL major catalog upgrade is in progress.");
+        return Status::OK();
+      case master::YSQL_MAJOR_CATALOG_UPGRADE_PENDING_ROLLBACK:
+        SCHECK_STR_CONTAINS(output, "YSQL major catalog upgrade failed.");
+        return Status::OK();
+      case master::YSQL_MAJOR_CATALOG_UPGRADE_PENDING_FINALIZE_OR_ROLLBACK:
+        SCHECK_STR_CONTAINS(output, "YSQL major catalog awaiting finalization or rollback.");
+        return Status::OK();
+      case master::YSQL_MAJOR_CATALOG_UPGRADE_ROLLBACK_IN_PROGRESS:
+        SCHECK_STR_CONTAINS(output, "YSQL major catalog rollback is in progress.");
+        return Status::OK();
+    }
+    return STATUS_FORMAT(IllegalState, "Unknown state: $0", state);
+  }
 };
 
 // Start multiple ysql major upgrade RPCs simultaneously. Only one RPC should succeed.
 TEST_F(YsqlMajorUpgradeRpcsTest, SimultaneousUpgrades) {
+  ASSERT_NOK_STR_CONTAINS(
+      ValidateYsqlMajorCatalogUpgradeState(master::YSQL_MAJOR_CATALOG_UPGRADE_DONE),
+      "invalid method name");
+
   ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
 
+  ASSERT_OK(ValidateYsqlMajorCatalogUpgradeState(master::YSQL_MAJOR_CATALOG_UPGRADE_PENDING));
+
   const int kNumSimultaneousRpcs = 2;
 
   rpc::RpcController rpcs[kNumSimultaneousRpcs];
@@ -96,6 +156,13 @@ TEST_F(YsqlMajorUpgradeRpcsTest, SimultaneousUpgrades) {
     AsyncStartYsqlMajorUpgrade(resps[i], rpcs[i], latch);
   }
 
+  // The upgrade takes longer than 5s in all builds.
+  SleepFor(5s);
+  // Make sure ysql major catalog rollback is blocked while we are running ysql major upgrade.
+  ASSERT_NOK_STR_CONTAINS(
+      RollbackYsqlMajorCatalogVersion(),
+      "Global initdb or ysql major catalog upgrade/rollback is already in progress");
+
   latch.Wait();
 
   for (auto& rpc : rpcs) {
@@ -109,8 +176,12 @@ TEST_F(YsqlMajorUpgradeRpcsTest, SimultaneousUpgrades) {
   }
   ASSERT_EQ(num_success, 1);
 
+  ASSERT_OK(ValidateYsqlMajorCatalogUpgradeState(master::YSQL_MAJOR_CATALOG_UPGRADE_IN_PROGRESS));
+
   ASSERT_OK(CompleteUpgradeAndValidate());
 
+  ASSERT_OK(ValidateYsqlMajorCatalogUpgradeState(master::YSQL_MAJOR_CATALOG_UPGRADE_DONE));
+
   ASSERT_NOK_STR_CONTAINS(
       PerformYsqlMajorCatalogUpgrade(), "Ysql Catalog is already on the current major version");
 }
@@ -122,6 +193,8 @@ TEST_F(YsqlMajorUpgradeRpcsTest, SimultaneousRollback) {
   // Calling rollback before upgrade should succeed immediately.
   ASSERT_OK(RollbackYsqlMajorCatalogVersion());
 
+  ASSERT_OK(ValidateYsqlMajorCatalogUpgradeState(master::YSQL_MAJOR_CATALOG_UPGRADE_PENDING));
+
   ASSERT_OK(PerformYsqlMajorCatalogUpgrade());
 
   const int kNumSimultaneousRpcs = 2;
@@ -133,6 +206,17 @@ TEST_F(YsqlMajorUpgradeRpcsTest, SimultaneousRollback) {
     AsyncStartYsqlMajorRollback(resps[i], rpcs[i], latch);
   }
 
+  // Make sure ysql major catalog upgrade is blocked while we are running ysql major upgrade
+  // rollback.
+  // Wait for the async work to start. The rollback takes more than 2s in all builds.
+  SleepFor(2s);
+  ASSERT_NOK_STR_CONTAINS(
+      PerformYsqlMajorCatalogUpgrade(),
+      "Invalid state transition from PERFORMING_ROLLBACK to PERFORMING_INIT_DB");
+
+  ASSERT_OK(ValidateYsqlMajorCatalogUpgradeState(
+      master::YSQL_MAJOR_CATALOG_UPGRADE_ROLLBACK_IN_PROGRESS));
+
   latch.Wait();
 
   for (auto& rpc : rpcs) {
@@ -146,57 +230,14 @@ TEST_F(YsqlMajorUpgradeRpcsTest, SimultaneousRollback) {
   }
   ASSERT_EQ(num_success, 1);
 
-  ASSERT_OK(RestartAllMastersInOldVersion(kNoDelayBetweenNodes));
-  ASSERT_OK(InsertRowInSimpleTableAndValidate());
-}
+  ASSERT_OK(ValidateYsqlMajorCatalogUpgradeState(master::YSQL_MAJOR_CATALOG_UPGRADE_PENDING));
 
-// Make sure ysql major catalog rollback is blocked while we are running ysql major upgrade.
-TEST_F(YsqlMajorUpgradeRpcsTest, RollbackDuringUpgrade) {
-  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
-
-  master::StartYsqlMajorCatalogUpgradeResponsePB upgrade_response;
-  master::RollbackYsqlMajorCatalogVersionResponsePB rollback_response;
-
-  rpc::RpcController rpc;
-  CountDownLatch latch(1);
-
-  AsyncStartYsqlMajorUpgrade(upgrade_response, rpc, latch);
+  ASSERT_OK(RestartAllMastersInOldVersion(kNoDelayBetweenNodes));
 
-  // The upgrade takes longer than 5s in all builds.
-  SleepFor(5s);
   ASSERT_NOK_STR_CONTAINS(
-      RollbackYsqlMajorCatalogVersion(),
-      "Global initdb or ysql major catalog upgrade/rollback is already in progress");
-
-  latch.Wait();
-  ASSERT_TRUE(rpc.finished());
-
-  ASSERT_FALSE(upgrade_response.has_error()) << upgrade_response.error().ShortDebugString();
-
-  ASSERT_OK(CompleteUpgradeAndValidate());
-}
-
-// Make sure ysql major catalog upgrade is blocked while we are running ysql major upgrade rollback.
-TEST_F(YsqlMajorUpgradeRpcsTest, UpgradeDuringRollback) {
-  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
-  ASSERT_OK(PerformYsqlMajorCatalogUpgrade());
-
-  master::RollbackYsqlMajorCatalogVersionResponsePB rollback_response;
-  rpc::RpcController rpc;
-  CountDownLatch latch(1);
-
-  AsyncStartYsqlMajorRollback(rollback_response, rpc, latch);
+      ValidateYsqlMajorCatalogUpgradeState(master::YSQL_MAJOR_CATALOG_UPGRADE_DONE),
+      "invalid method name");
 
-  // The rollback takes around 2s in all builds.
-  SleepFor(2s);
-  ASSERT_NOK(PerformYsqlMajorCatalogUpgrade());
-
-  latch.Wait();
-  ASSERT_TRUE(rpc.finished());
-
-  ASSERT_FALSE(rollback_response.has_error()) << rollback_response.ShortDebugString();
-
-  ASSERT_OK(RestartAllMastersInOldVersion(kNoDelayBetweenNodes));
   ASSERT_OK(InsertRowInSimpleTableAndValidate());
 }
 
@@ -233,6 +274,9 @@ TEST_F(YsqlMajorUpgradeRpcsTest, YB_DISABLE_TEST_EXCEPT_RELEASE(MasterCrashDurin
 
   auto ysql_catalog_config = ASSERT_RESULT(DumpYsqlCatalogConfig());
   ASSERT_STR_CONTAINS(ysql_catalog_config, "state: FAILED");
+  ASSERT_OK(
+      ValidateYsqlMajorCatalogUpgradeState(master::YSQL_MAJOR_CATALOG_UPGRADE_PENDING_ROLLBACK));
+
   ASSERT_OK(InsertRowInSimpleTableAndValidate());
 
   ASSERT_OK(master_leader->Restart());
@@ -258,6 +302,8 @@ TEST_F(YsqlMajorUpgradeRpcsTest, MasterCrashDuringMonitoring) {
 
   auto ysql_catalog_config = ASSERT_RESULT(DumpYsqlCatalogConfig());
   ASSERT_STR_CONTAINS(ysql_catalog_config, "state: MONITORING");
+  ASSERT_OK(ValidateYsqlMajorCatalogUpgradeState(
+      master::YSQL_MAJOR_CATALOG_UPGRADE_PENDING_FINALIZE_OR_ROLLBACK));
 
   ASSERT_OK(InsertRowInSimpleTableAndValidate());
 
diff --git a/src/yb/master/master_admin.proto b/src/yb/master/master_admin.proto
index 4986b8643a..8a54ea4ba8 100644
--- a/src/yb/master/master_admin.proto
+++ b/src/yb/master/master_admin.proto
@@ -203,6 +203,23 @@ message RollbackYsqlMajorCatalogVersionResponsePB {
   optional MasterErrorPB error = 1;
 }
 
+message GetYsqlMajorCatalogUpgradeStateRequestPB {}
+
+enum YsqlMajorCatalogUpgradeState {
+  YSQL_MAJOR_CATALOG_UPGRADE_UNINITIALIZED = 0;
+  YSQL_MAJOR_CATALOG_UPGRADE_DONE = 1;
+  YSQL_MAJOR_CATALOG_UPGRADE_PENDING = 2;
+  YSQL_MAJOR_CATALOG_UPGRADE_IN_PROGRESS = 3;
+  YSQL_MAJOR_CATALOG_UPGRADE_PENDING_FINALIZE_OR_ROLLBACK = 4;
+  YSQL_MAJOR_CATALOG_UPGRADE_ROLLBACK_IN_PROGRESS = 5;
+  YSQL_MAJOR_CATALOG_UPGRADE_PENDING_ROLLBACK = 6;
+}
+
+message GetYsqlMajorCatalogUpgradeStateResponsePB {
+  optional MasterErrorPB error = 1;
+  optional YsqlMajorCatalogUpgradeState state = 2;
+}
+
 message CheckIfPitrActiveRequestPB {}
 
 message CheckIfPitrActiveResponsePB {
@@ -338,6 +355,8 @@ service MasterAdmin {
       returns (FinalizeYsqlMajorCatalogUpgradeResponsePB);
   rpc RollbackYsqlMajorCatalogVersion(RollbackYsqlMajorCatalogVersionRequestPB)
       returns (RollbackYsqlMajorCatalogVersionResponsePB);
+  rpc GetYsqlMajorCatalogUpgradeState(GetYsqlMajorCatalogUpgradeStateRequestPB)
+      returns (GetYsqlMajorCatalogUpgradeStateResponsePB);
 
   rpc CheckIfPitrActive(CheckIfPitrActiveRequestPB)
       returns (CheckIfPitrActiveResponsePB);
diff --git a/src/yb/master/master_admin_service.cc b/src/yb/master/master_admin_service.cc
index 4f268c8742..f96bef9269 100644
--- a/src/yb/master/master_admin_service.cc
+++ b/src/yb/master/master_admin_service.cc
@@ -118,6 +118,7 @@ class MasterAdminServiceImpl : public MasterServiceBase, public MasterAdminIf {
       (IsYsqlMajorCatalogUpgradeDone)
       (FinalizeYsqlMajorCatalogUpgrade)
       (RollbackYsqlMajorCatalogVersion)
+      (GetYsqlMajorCatalogUpgradeState)
   )
 };
 
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
index 873ddde621..85c6ee8532 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
@@ -171,6 +171,31 @@ bool YsqlInitDBAndMajorUpgradeHandler::IsYsqlMajorCatalogUpgradeInProgress() con
   return !IsYsqlMajorCatalogUpgradeDone().done();
 }
 
+Result<YsqlMajorCatalogUpgradeState>
+YsqlInitDBAndMajorUpgradeHandler::GetYsqlMajorCatalogUpgradeState() const {
+  const auto state = ysql_catalog_config_.GetMajorCatalogUpgradeState();
+  switch (state) {
+    case YsqlMajorCatalogUpgradeInfoPB::INVALID:
+      // Bad enum, fail the call.
+      break;
+    case YsqlMajorCatalogUpgradeInfoPB::DONE:
+      return ysql_major_upgrade_in_progress_ ? YSQL_MAJOR_CATALOG_UPGRADE_PENDING
+                                             : YSQL_MAJOR_CATALOG_UPGRADE_DONE;
+    case YsqlMajorCatalogUpgradeInfoPB::FAILED:
+      return YSQL_MAJOR_CATALOG_UPGRADE_PENDING_ROLLBACK;
+    case YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB:
+      FALLTHROUGH_INTENDED;
+    case YsqlMajorCatalogUpgradeInfoPB::PERFORMING_PG_UPGRADE:
+      return YSQL_MAJOR_CATALOG_UPGRADE_IN_PROGRESS;
+    case YsqlMajorCatalogUpgradeInfoPB::MONITORING:
+      return YSQL_MAJOR_CATALOG_UPGRADE_PENDING_FINALIZE_OR_ROLLBACK;
+    case YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK:
+      return YSQL_MAJOR_CATALOG_UPGRADE_ROLLBACK_IN_PROGRESS;
+  }
+
+  return STATUS_FORMAT(IllegalState, "Unknown ysql major upgrade state: $0", state);
+}
+
 bool YsqlInitDBAndMajorUpgradeHandler::IsWriteToCatalogTableAllowed(
     const TableId& table_id, bool is_forced_update) const {
   // During the upgrade only allow special updates to the catalog.
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
index 63fabec874..43bc7acc42 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
@@ -13,6 +13,7 @@
 
 #pragma once
 
+#include "yb/master/master_admin.pb.h"
 #include "yb/util/status_fwd.h"
 
 #include "yb/master/master_fwd.h"
@@ -65,6 +66,8 @@ class YsqlInitDBAndMajorUpgradeHandler {
 
   bool IsYsqlMajorCatalogUpgradeInProgress() const;
 
+  Result<YsqlMajorCatalogUpgradeState> GetYsqlMajorCatalogUpgradeState() const;
+
   // Are we allowed to perform updates to the ysql catalog?
   // True for the current version if the ysql major upgrade completed.
   // The upgrade is considered to have started when the yb-master leader has upgraded to a new major
diff --git a/src/yb/master/ysql/ysql_manager.cc b/src/yb/master/ysql/ysql_manager.cc
index cde625383c..02232715cd 100644
--- a/src/yb/master/ysql/ysql_manager.cc
+++ b/src/yb/master/ysql/ysql_manager.cc
@@ -185,6 +185,15 @@ Status YsqlManager::RollbackYsqlMajorCatalogVersion(
   return Status::OK();
 }
 
+Status YsqlManager::GetYsqlMajorCatalogUpgradeState(
+    const GetYsqlMajorCatalogUpgradeStateRequestPB* req,
+    GetYsqlMajorCatalogUpgradeStateResponsePB* resp, rpc::RpcContext* rpc) {
+  auto state =
+      VERIFY_RESULT(ysql_initdb_and_major_upgrade_helper_->GetYsqlMajorCatalogUpgradeState());
+  resp->set_state(state);
+  return Status::OK();
+}
+
 Status YsqlManager::CreateYbAdvisoryLocksTableIfNeeded(const LeaderEpoch& epoch) {
   if (advisory_locks_table_created_ || !FLAGS_enable_ysql || !FLAGS_ysql_yb_enable_advisory_locks) {
     return Status::OK();
diff --git a/src/yb/master/ysql/ysql_manager.h b/src/yb/master/ysql/ysql_manager.h
index cbbd2cc177..e0a2298581 100644
--- a/src/yb/master/ysql/ysql_manager.h
+++ b/src/yb/master/ysql/ysql_manager.h
@@ -95,6 +95,10 @@ class YsqlManager : public YsqlManagerIf {
       RollbackYsqlMajorCatalogVersionResponsePB* resp, rpc::RpcContext* rpc,
       const LeaderEpoch& epoch);
 
+  Status GetYsqlMajorCatalogUpgradeState(
+      const GetYsqlMajorCatalogUpgradeStateRequestPB* req,
+      GetYsqlMajorCatalogUpgradeStateResponsePB* resp, rpc::RpcContext* rpc);
+
   Status CreateYbAdvisoryLocksTableIfNeeded(const LeaderEpoch& epoch);
 
   Status ValidateWriteToCatalogTableAllowed(const TableId& table_id, bool is_forced_update) const;
diff --git a/src/yb/tools/yb-admin_cli.cc b/src/yb/tools/yb-admin_cli.cc
index 82ff6f389b..bfec4470a3 100644
--- a/src/yb/tools/yb-admin_cli.cc
+++ b/src/yb/tools/yb-admin_cli.cc
@@ -1235,6 +1235,16 @@ Status rollback_ysql_major_version_upgrade_action(const ClusterAdminCli::CLIArgu
   return Status::OK();
 }
 
+const auto get_ysql_major_version_catalog_upgrade_state_args = "";
+Status get_ysql_major_version_catalog_upgrade_state_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  RETURN_NOT_OK(CheckArgumentsCount(args.size(), 0, 0));
+  RETURN_NOT_OK_PREPEND(
+      client->GetYsqlMajorCatalogUpgradeState(),
+      "Unable to determine ysql major catalog upgrade state");
+  return Status::OK();
+}
+
 // Today we have a weird pattern recognization for table name.
 // The expected input argument for the <table> is:
 // <db type>.<namespace> <table name>
@@ -2909,6 +2919,7 @@ void ClusterAdminCli::RegisterCommandHandlers() {
   REGISTER_COMMAND(ysql_major_version_catalog_upgrade);
   REGISTER_COMMAND(finalize_ysql_major_version_catalog_upgrade);
   REGISTER_COMMAND(rollback_ysql_major_version_upgrade);
+  REGISTER_COMMAND(get_ysql_major_version_catalog_upgrade_state);
 
   // SysCatalog util commands
   REGISTER_COMMAND(dump_sys_catalog_entries);
diff --git a/src/yb/tools/yb-admin_client.cc b/src/yb/tools/yb-admin_client.cc
index 7a7d85f51b..73ae9ae67f 100644
--- a/src/yb/tools/yb-admin_client.cc
+++ b/src/yb/tools/yb-admin_client.cc
@@ -2403,6 +2403,47 @@ Status ClusterAdminClient::RollbackYsqlMajorCatalogVersion() {
   return Status::OK();
 }
 
+Status ClusterAdminClient::GetYsqlMajorCatalogUpgradeState() {
+  RpcController rpc;
+  rpc.set_timeout(timeout_);
+  master::GetYsqlMajorCatalogUpgradeStateRequestPB req;
+  master::GetYsqlMajorCatalogUpgradeStateResponsePB resp;
+  RETURN_NOT_OK(master_admin_proxy_->GetYsqlMajorCatalogUpgradeState(req, &resp, &rpc));
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+
+  switch (resp.state()) {
+    case master::YSQL_MAJOR_CATALOG_UPGRADE_UNINITIALIZED:
+      // Bad enum, fail the call.
+      break;
+    case master::YSQL_MAJOR_CATALOG_UPGRADE_DONE:
+      std::cout << "YSQL major catalog upgrade already completed, or is not required.\n";
+      return Status::OK();
+    case master::YSQL_MAJOR_CATALOG_UPGRADE_PENDING:
+      std::cout << "YSQL major catalog upgrade for YSQL major upgrade has not yet started.\n"
+                   "Run `ysql_major_version_catalog_upgrade` to start the catalog upgrade\n";
+      return Status::OK();
+    case master::YSQL_MAJOR_CATALOG_UPGRADE_PENDING_ROLLBACK:
+      std::cout << "YSQL major catalog upgrade failed.\n"
+                   "Roll back the catalog upgrade using `rollback_ysql_major_version_upgrade`. "
+                   "After that you can either retry the catalog upgrade or roll back yb-masters to "
+                   "the older version.\n";
+      return Status::OK();
+    case master::YSQL_MAJOR_CATALOG_UPGRADE_IN_PROGRESS:
+      std::cout << "YSQL major catalog upgrade is in progress.\n";
+      return Status::OK();
+    case master::YSQL_MAJOR_CATALOG_UPGRADE_PENDING_FINALIZE_OR_ROLLBACK:
+      std::cout << "YSQL major catalog awaiting finalization or rollback.\n";
+      return Status::OK();
+    case master::YSQL_MAJOR_CATALOG_UPGRADE_ROLLBACK_IN_PROGRESS:
+      std::cout << "YSQL major catalog rollback is in progress.\n";
+      return Status::OK();
+  }
+
+  return STATUS_FORMAT(IllegalState, "Unknown ysql major upgrade state: $0", resp.state());
+}
+
 Status ClusterAdminClient::ChangeBlacklist(const std::vector<HostPort>& servers, bool add,
     bool blacklist_leader) {
   auto config = VERIFY_RESULT(GetMasterClusterConfig());
diff --git a/src/yb/tools/yb-admin_client.h b/src/yb/tools/yb-admin_client.h
index 1475bf1f3d..7232fc130e 100644
--- a/src/yb/tools/yb-admin_client.h
+++ b/src/yb/tools/yb-admin_client.h
@@ -329,6 +329,8 @@ class ClusterAdminClient {
 
   Status RollbackYsqlMajorCatalogVersion();
 
+  Status GetYsqlMajorCatalogUpgradeState();
+
   // Set WAL retention time in secs for a table name.
   Status SetWalRetentionSecs(
     const client::YBTableName& table_name, const uint32_t wal_ret_secs);
