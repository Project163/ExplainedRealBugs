diff --git a/src/yb/client/client-test-util.cc b/src/yb/client/client-test-util.cc
index ff6fbc2b48..87c294b68d 100644
--- a/src/yb/client/client-test-util.cc
+++ b/src/yb/client/client-test-util.cc
@@ -195,7 +195,8 @@ std::shared_ptr<YBqlReadOp> CreateReadOp(
 
 Result<string> GetNamespaceIdByNamespaceName(YBClient* client,
                                              const string& namespace_name) {
-  const auto namespaces = VERIFY_RESULT(client->ListNamespaces(YQL_DATABASE_PGSQL));
+  const auto namespaces = VERIFY_RESULT(
+      client->ListNamespaces(client::IncludeNonrunningNamespaces::kFalse, YQL_DATABASE_PGSQL));
   for (const auto& ns : namespaces) {
     if (ns.id.name() == namespace_name) {
       return ns.id.id();
diff --git a/src/yb/client/client.cc b/src/yb/client/client.cc
index c92fc8e244..abbd58b0d5 100644
--- a/src/yb/client/client.cc
+++ b/src/yb/client/client.cc
@@ -1029,9 +1029,12 @@ std::unique_ptr<YBNamespaceAlterer> YBClient::NewNamespaceAlterer(
 }
 
 Result<vector<NamespaceInfo>> YBClient::ListNamespaces(
-    const boost::optional<YQLDatabase>& database_type) {
+  IncludeNonrunningNamespaces include_nonrunning, std::optional<YQLDatabase> database_type) {
   ListNamespacesRequestPB req;
   ListNamespacesResponsePB resp;
+  if (include_nonrunning) {
+    req.set_include_nonrunning(include_nonrunning);
+  }
   if (database_type) {
     req.set_database_type(*database_type);
   }
@@ -1122,20 +1125,22 @@ Status YBClient::GrantRevokePermission(GrantRevokeStatementType statement_type,
   return Status::OK();
 }
 
-Result<bool> YBClient::NamespaceExists(const std::string& namespace_name,
-                                       const boost::optional<YQLDatabase>& database_type) {
-  for (const auto& ns : VERIFY_RESULT(ListNamespaces(database_type))) {
-    if (ns.id.name() == namespace_name) {
+Result<bool> YBClient::NamespaceExists(
+    const std::string& NamespaceName, const std::optional<YQLDatabase>& database_type) {
+  for (const auto& ns :
+       VERIFY_RESULT(ListNamespaces(IncludeNonrunningNamespaces::kFalse, database_type))) {
+    if (ns.id.name() == NamespaceName) {
       return true;
     }
   }
   return false;
 }
 
-Result<bool> YBClient::NamespaceIdExists(const std::string& namespace_id,
-                                         const boost::optional<YQLDatabase>& database_type) {
-  for (const auto& ns : VERIFY_RESULT(ListNamespaces(database_type))) {
-    if (ns.id.id() == namespace_id) {
+Result<bool> YBClient::NamespaceIdExists(
+    const std::string& NamespaceId, const std::optional<YQLDatabase>& database_type) {
+  for (const auto& ns :
+       VERIFY_RESULT(ListNamespaces(IncludeNonrunningNamespaces::kFalse, database_type))) {
+    if (ns.id.id() == NamespaceId) {
       return true;
     }
   }
@@ -2778,10 +2783,6 @@ CoarseTimePoint YBClient::PatchAdminDeadline(CoarseTimePoint deadline) const {
   return CoarseMonoClock::Now() + default_admin_operation_timeout();
 }
 
-Result<vector<NamespaceInfo>> YBClient::ListNamespaces() {
-  return ListNamespaces(boost::none);
-}
-
 Result<YBTablePtr> YBClient::OpenTable(const TableId& table_id) {
   YBTablePtr result;
   RETURN_NOT_OK(OpenTable(table_id, &result));
diff --git a/src/yb/client/client.h b/src/yb/client/client.h
index a3d60c7350..8b2218edd6 100644
--- a/src/yb/client/client.h
+++ b/src/yb/client/client.h
@@ -108,6 +108,8 @@ YB_STRONGLY_TYPED_STRING(ReplicationGroupId);
 
 namespace client {
 
+YB_STRONGLY_TYPED_BOOL(IncludeNonrunningNamespaces);
+
 struct NamespaceInfo {
     master::NamespaceIdentifierPB id;
     master::SysNamespaceEntryPB_State state;
@@ -504,9 +506,9 @@ class YBClient {
                                const std::string& role_name);
 
   // List all namespace identifiers.
-  Result<std::vector<NamespaceInfo>> ListNamespaces();
   Result<std::vector<NamespaceInfo>> ListNamespaces(
-      const boost::optional<YQLDatabase>& database_type);
+      IncludeNonrunningNamespaces include_nonrunning = IncludeNonrunningNamespaces::kFalse,
+      std::optional<YQLDatabase> database_type = std::nullopt);
 
   // Get namespace information.
   Status GetNamespaceInfo(const std::string& namespace_id,
@@ -517,9 +519,9 @@ class YBClient {
   // Check if the namespace given by 'namespace_name' or 'namespace_id' exists.
   // Result value is set only on success.
   Result<bool> NamespaceExists(const std::string& namespace_name,
-                               const boost::optional<YQLDatabase>& database_type = boost::none);
+                               const std::optional<YQLDatabase>& database_type = std::nullopt);
   Result<bool> NamespaceIdExists(const std::string& namespace_id,
-                                 const boost::optional<YQLDatabase>& database_type = boost::none);
+                                 const std::optional<YQLDatabase>& database_type = std::nullopt);
 
   Status CreateTablegroup(const std::string& namespace_name,
                           const std::string& namespace_id,
diff --git a/src/yb/client/snapshot-schedule-test.cc b/src/yb/client/snapshot-schedule-test.cc
index 5aca591c91..31f6810654 100644
--- a/src/yb/client/snapshot-schedule-test.cc
+++ b/src/yb/client/snapshot-schedule-test.cc
@@ -200,7 +200,7 @@ TEST_F(SnapshotScheduleTest, TablegroupGC) {
                                      "" /* ns_id */, "" /* src_ns_id */,
                                      boost::none /* next_pg_oid */, nullptr /* txn */, false));
   {
-    auto namespaces = ASSERT_RESULT(client->ListNamespaces(boost::none));
+    auto namespaces = ASSERT_RESULT(client->ListNamespaces());
     for (const auto& ns : namespaces) {
       if (ns.id.name() == namespace_name) {
         namespace_id = ns.id.id();
diff --git a/src/yb/integration-tests/create-table-itest.cc b/src/yb/integration-tests/create-table-itest.cc
index f3c7294617..1f0008b38f 100644
--- a/src/yb/integration-tests/create-table-itest.cc
+++ b/src/yb/integration-tests/create-table-itest.cc
@@ -335,7 +335,7 @@ TEST_F(CreateTableITest, LegacyColocatedDBTableColocationRemoteBootstrapTest) {
 
   {
     string ns_id;
-    auto namespaces = ASSERT_RESULT(client_->ListNamespaces(boost::none));
+    auto namespaces = ASSERT_RESULT(client_->ListNamespaces());
     for (const auto& ns : namespaces) {
       if (ns.id.name() == "colocation_test") {
         ns_id = ns.id.id();
@@ -472,7 +472,7 @@ TEST_F(CreateTableITest, TablegroupRemoteBootstrapTest) {
                                      boost::none /* next_pg_oid */, nullptr /* txn */, false));
 
   {
-    auto namespaces = ASSERT_RESULT(client_->ListNamespaces(boost::none));
+    auto namespaces = ASSERT_RESULT(client_->ListNamespaces());
     for (const auto& ns : namespaces) {
       if (ns.id.name() == namespace_name) {
         namespace_id = ns.id.id();
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 8f58b98f3f..b77ff974d2 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -9824,9 +9824,11 @@ Status CatalogManager::ListNamespaces(const ListNamespacesRequestPB* req,
     if (req->has_database_type() && namespace_info.database_type() != req->database_type()) {
       continue;
     }
-    // Only return RUNNING namespaces.
+    // Only return namespaces in state RUNNING unless list_all is true.
     if (namespace_info.state() != SysNamespaceEntryPB::RUNNING) {
-      continue;
+      if (!req->include_nonrunning()) {
+        continue;
+      }
     }
 
     NamespaceIdentifierPB *ns = resp->add_namespaces();
diff --git a/src/yb/master/master_ddl.proto b/src/yb/master/master_ddl.proto
index 4d271f7eb3..91c3b72dac 100644
--- a/src/yb/master/master_ddl.proto
+++ b/src/yb/master/master_ddl.proto
@@ -574,6 +574,7 @@ message AlterNamespaceResponsePB {
 
 message ListNamespacesRequestPB {
   optional YQLDatabase database_type = 1 [ default = YQL_DATABASE_CQL ];
+  optional bool include_nonrunning = 2;
 }
 
 message ListNamespacesResponsePB {
diff --git a/src/yb/tools/yb-admin-test.cc b/src/yb/tools/yb-admin-test.cc
index 3fba51b0f9..33f61a472e 100644
--- a/src/yb/tools/yb-admin-test.cc
+++ b/src/yb/tools/yb-admin-test.cc
@@ -1349,6 +1349,20 @@ TEST_F(AdminCliTest, TestListNamespaces) {
   ASSERT_LT(user_namespaces_pos, system_namespaces_pos);
   ASSERT_GT(user_namespace_match.position(0), user_namespaces_pos);
   ASSERT_LT(user_namespace_match.position(0), system_namespaces_pos);
+
+  // We test just YSQL namespaces here because YCQL namespaces get directly deleted without being
+  // in the DELETED state and thus there is nothing for include_nonrunning to see in that case.
+  ASSERT_OK(client_->CreateNamespace("new_user_namespace", YQL_DATABASE_PGSQL));
+
+  ASSERT_OK(CallAdmin("delete_namespace", "ysql.new_user_namespace"));
+
+  status = CallAdmin("list_namespaces");
+  ASSERT_OK(status);
+  ASSERT_STR_NOT_CONTAINS(status.ToString(), "new_user_namespace");
+
+  status = CallAdmin("list_namespaces", "include_nonrunning");
+  ASSERT_OK(status);
+  ASSERT_TRUE(std::regex_search(status.ToString(), std::regex("new_user_namespace.*DELETED")));
 }
 
 TEST_F(AdminCliTest, PrintArgumentExpressions) {
diff --git a/src/yb/tools/yb-admin_cli.cc b/src/yb/tools/yb-admin_cli.cc
index 9ae82866ea..61215b1e3d 100644
--- a/src/yb/tools/yb-admin_cli.cc
+++ b/src/yb/tools/yb-admin_cli.cc
@@ -717,11 +717,20 @@ Status delete_read_replica_placement_info_action(
   return Status::OK();
 }
 
-const auto list_namespaces_args = "";
+const auto list_namespaces_args = "[INCLUDE_NONRUNNING] (default false)";
 Status list_namespaces_action(
     const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
-  RETURN_NOT_OK_PREPEND(client->ListAllNamespaces(), "Unable to list namespaces");
-  return Status::OK();
+    bool include_nonrunning = false;
+    if (args.size() > 0) {
+      if (IsEqCaseInsensitive(args[0], "INCLUDE_NONRUNNING")) {
+        include_nonrunning = true;
+      } else {
+        return ClusterAdminCli::kInvalidArguments;
+      }
+    }
+    RETURN_NOT_OK_PREPEND(
+        client->ListAllNamespaces(include_nonrunning), "Unable to list namespaces");
+    return Status::OK();
 }
 
 const auto delete_namespace_args = "<namespace>";
diff --git a/src/yb/tools/yb-admin_client.cc b/src/yb/tools/yb-admin_client.cc
index 3f37938169..bf9ffd4dea 100644
--- a/src/yb/tools/yb-admin_client.cc
+++ b/src/yb/tools/yb-admin_client.cc
@@ -1689,9 +1689,9 @@ Status ClusterAdminClient::DeleteIndexById(const TableId& table_id) {
   return Status::OK();
 }
 
-Status ClusterAdminClient::ListAllNamespaces() {
+Status ClusterAdminClient::ListAllNamespaces(bool include_nonrunning) {
   cout << "name | UUID | language | state | colocated" << endl << endl;
-  const auto namespaces = VERIFY_RESULT_REF(GetNamespaceMap());
+  const auto namespaces = VERIFY_RESULT_REF(GetNamespaceMap(include_nonrunning));
   const auto list_namespaces = [&] (bool for_system_namespace) -> void {
     cout << (for_system_namespace ? "System Namespaces:" : "User Namespaces:") << endl;
     for (const auto& namespace_info_pair : namespaces) {
@@ -2450,9 +2450,11 @@ Result<Response> ClusterAdminClient::InvokeRpc(
       VERIFY_RESULT(InvokeRpcNoResponseCheck(func, obj, req, error_message, timeout)));
 }
 
-Result<const ClusterAdminClient::NamespaceMap&> ClusterAdminClient::GetNamespaceMap() {
+Result<const ClusterAdminClient::NamespaceMap&> ClusterAdminClient::GetNamespaceMap(
+    bool include_nonrunning) {
   if (namespace_map_.empty()) {
-    auto v = VERIFY_RESULT(yb_client_->ListNamespaces());
+    auto v = VERIFY_RESULT(
+        yb_client_->ListNamespaces(client::IncludeNonrunningNamespaces(include_nonrunning)));
     for (auto& ns : v) {
       auto ns_id = ns.id.id();
       namespace_map_.emplace(std::move(ns_id), std::move(ns));
diff --git a/src/yb/tools/yb-admin_client.h b/src/yb/tools/yb-admin_client.h
index 7bb0902147..9f1ea611de 100644
--- a/src/yb/tools/yb-admin_client.h
+++ b/src/yb/tools/yb-admin_client.h
@@ -331,7 +331,7 @@ class ClusterAdminClient {
   Status PromoteSingleAutoFlag(const std::string& process_name, const std::string& flag_name);
   Status DemoteSingleAutoFlag(const std::string& process_name, const std::string& flag_name);
 
-  Status ListAllNamespaces();
+  Status ListAllNamespaces(bool include_nonrunning = false);
 
   // Snapshot operations.
   Result<master::ListSnapshotsResponsePB> ListSnapshots(const ListSnapshotsFlags& flags);
@@ -590,7 +590,7 @@ class ClusterAdminClient {
       const MonoDelta timeout = MonoDelta());
 
   using NamespaceMap = std::unordered_map<NamespaceId, client::NamespaceInfo>;
-  Result<const NamespaceMap&> GetNamespaceMap();
+  Result<const NamespaceMap&> GetNamespaceMap(bool include_nonrunning = false);
 
   Result<TxnSnapshotId> SuitableSnapshotId(
       const SnapshotScheduleId& schedule_id, HybridTime restore_at, CoarseTimePoint deadline);
diff --git a/src/yb/tserver/pg_client_service.cc b/src/yb/tserver/pg_client_service.cc
index d9d4996432..ac06154b80 100644
--- a/src/yb/tserver/pg_client_service.cc
+++ b/src/yb/tserver/pg_client_service.cc
@@ -1574,7 +1574,8 @@ class PgClientServiceImpl::Impl {
 
   Result<std::unordered_set<uint32_t>> GetPgDatabaseOids() {
     LOG(INFO) << "Fetching set of database oids";
-    auto namespaces = VERIFY_RESULT(client().ListNamespaces(YQL_DATABASE_PGSQL));
+    auto namespaces = VERIFY_RESULT(
+        client().ListNamespaces(client::IncludeNonrunningNamespaces::kFalse, YQL_DATABASE_PGSQL));
     std::unordered_set<uint32_t> result;
     for (const auto& ns : namespaces) {
       result.insert(VERIFY_RESULT(GetPgsqlDatabaseOid(ns.id.id())));
