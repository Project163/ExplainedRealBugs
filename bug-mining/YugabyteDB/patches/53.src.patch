diff --git a/src/yb/client/client-internal.cc b/src/yb/client/client-internal.cc
index 2b2b50a92f..98b04adb60 100644
--- a/src/yb/client/client-internal.cc
+++ b/src/yb/client/client-internal.cc
@@ -313,17 +313,31 @@ YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, UpdateConsumerOnProducerMetadata);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, GetXClusterSafeTime);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, BootstrapProducer);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, XClusterReportNewAutoFlagConfigVersion);
-YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, XClusterCreateOutboundReplicationGroup);
-YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, XClusterDeleteOutboundReplicationGroup);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, XClusterAddNamespaceToOutboundReplicationGroup);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, XClusterRemoveNamespaceFromOutboundReplicationGroup);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, SetupUniverseReplication);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, IsSetupUniverseReplicationDone);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, CreateXClusterReplication);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, IsCreateXClusterReplicationDone);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, XClusterCreateOutboundReplicationGroup);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, XClusterDeleteOutboundReplicationGroup);
 
 #define YB_CLIENT_SPECIALIZE_SIMPLE_EX_EACH(i, data, set) YB_CLIENT_SPECIALIZE_SIMPLE_EX set
 
 #define YB_CLIENT_SPECIALIZE_SIMPLE_FOR(rpcs) \
   BOOST_PP_SEQ_FOR_EACH(YB_CLIENT_SPECIALIZE_SIMPLE_EX_EACH, ~, rpcs)
 
-YB_CLIENT_SPECIALIZE_SIMPLE_FOR(CLIENT_SYNC_LEADER_MASTER_RPC_LIST)
+template<class ProxyClass, class RespClass>
+bool SyncClientMasterRpc<ProxyClass, RespClass>::ShouldRetry(const Status& status) {
+  return internal::ClientMasterRpcBase::ShouldRetry(status);
+}
+
+template<>
+bool SyncClientMasterRpc<master::MasterAdminProxy,
+                         WaitForYsqlBackendsCatalogVersionResponsePB>::ShouldRetry(
+    const Status& status) {
+  return status.IsTryAgain();
+}
 
 template<class ProxyClass, class RespClass>
 bool SyncClientMasterRpc<ProxyClass, RespClass>::ShouldRetry(const Status& status) {
@@ -2138,7 +2152,8 @@ class GetXClusterStreamsRpc
           master::GetXClusterStreamsRequestPB, master::GetXClusterStreamsResponsePB> {
  public:
   GetXClusterStreamsRpc(
-      YBClient* client, GetXClusterStreamsCallback user_cb, CoarseTimePoint deadline)
+      YBClient* client, std::function<void(Result<master::GetXClusterStreamsResponsePB>)> user_cb,
+      CoarseTimePoint deadline)
       : ClientMasterRpc(client, deadline), user_cb_(std::move(user_cb)) {}
 
   Status Init(
@@ -2196,7 +2211,7 @@ class GetXClusterStreamsRpc
     user_cb_(std::move(resp_));
   }
 
-  GetXClusterStreamsCallback user_cb_;
+  std::function<void(Result<master::GetXClusterStreamsResponsePB>)> user_cb_;
 };
 
 // A simple RPC that keeps retrying if resp has not_ready set.
@@ -2205,7 +2220,7 @@ class IsXClusterBootstrapRequiredRpc : public ClientMasterRpc<
                                            master::IsXClusterBootstrapRequiredResponsePB> {
  public:
   IsXClusterBootstrapRequiredRpc(
-      YBClient* client, IsXClusterBootstrapRequiredCallback user_cb, CoarseTimePoint deadline)
+      YBClient* client, std::function<void(Result<bool>)> user_cb, CoarseTimePoint deadline)
       : ClientMasterRpc(client, deadline), user_cb_(std::move(user_cb)) {}
 
   Status Init(
@@ -2251,7 +2266,7 @@ class IsXClusterBootstrapRequiredRpc : public ClientMasterRpc<
     user_cb_(resp_.initial_bootstrap_required());
   }
 
-  IsXClusterBootstrapRequiredCallback user_cb_;
+  std::function<void(Result<bool>)> user_cb_;
 };
 
 } // namespace internal
@@ -2901,7 +2916,7 @@ Status YBClient::Data::GetXClusterStreams(
     YBClient* client, CoarseTimePoint deadline,
     const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
     const std::vector<TableName>& table_names, const std::vector<PgSchemaName>& pg_schema_names,
-    GetXClusterStreamsCallback user_cb) {
+    std::function<void(Result<master::GetXClusterStreamsResponsePB>)> user_cb) {
   auto rpc =
       std::make_shared<internal::GetXClusterStreamsRpc>(client, std::move(user_cb), deadline);
   RETURN_NOT_OK(rpc->Init(replication_group_id, namespace_id, table_names, pg_schema_names));
@@ -2913,7 +2928,7 @@ Status YBClient::Data::GetXClusterStreams(
 Status YBClient::Data::IsXClusterBootstrapRequired(
     YBClient* client, CoarseTimePoint deadline,
     const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
-    IsXClusterBootstrapRequiredCallback user_cb) {
+    std::function<void(Result<bool>)> user_cb) {
   auto rpc = std::make_shared<internal::IsXClusterBootstrapRequiredRpc>(
       client, std::move(user_cb), deadline);
   RETURN_NOT_OK(rpc->Init(replication_group_id, namespace_id));
diff --git a/src/yb/client/client-internal.h b/src/yb/client/client-internal.h
index 39e1f679d3..1d48cff1f5 100644
--- a/src/yb/client/client-internal.h
+++ b/src/yb/client/client-internal.h
@@ -448,12 +448,12 @@ class YBClient::Data {
       YBClient* client, CoarseTimePoint deadline,
       const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
       const std::vector<TableName>& table_names, const std::vector<PgSchemaName>& pg_schema_names,
-      GetXClusterStreamsCallback user_cb);
+      std::function<void(Result<master::GetXClusterStreamsResponsePB>)> user_cb);
 
   Status IsXClusterBootstrapRequired(
       YBClient* client, CoarseTimePoint deadline,
       const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
-      IsXClusterBootstrapRequiredCallback user_cb);
+      std::function<void(Result<bool>)> user_cb);
 
   template <class ProxyClass, class ReqClass, class RespClass>
   using SyncLeaderMasterFunc = void (ProxyClass::*)(
diff --git a/src/yb/client/client.cc b/src/yb/client/client.cc
index f2f5803481..a3d80cb4e0 100644
--- a/src/yb/client/client.cc
+++ b/src/yb/client/client.cc
@@ -332,19 +332,6 @@ void FillFromRepeatedTabletLocations(
             BOOST_PP_CAT(method, Async))); \
   } while(0);
 
-#define IMPLEMENT_SYNC_LEADER_MASTER_RPC_IMP(service, method) \
-  Result<master::BOOST_PP_CAT(method, ResponsePB)> YBClient::method( \
-      const master::BOOST_PP_CAT(method, RequestPB) & req) { \
-    master::BOOST_PP_CAT(method, ResponsePB) resp; \
-    CALL_SYNC_LEADER_MASTER_RPC_EX(service, req, resp, method); \
-    return resp; \
-  }
-
-#define IMPLEMENT_SYNC_LEADER_MASTER_RPC(i, data, set) IMPLEMENT_SYNC_LEADER_MASTER_RPC_IMP set
-
-#define IMPLEMENT_SYNC_LEADER_MASTER_RPCS(rpcs) \
-  BOOST_PP_SEQ_FOR_EACH(IMPLEMENT_SYNC_LEADER_MASTER_RPC, ~, rpcs)
-
 // Adapts between the internal LogSeverity and the client's YBLogSeverity.
 static void LoggingAdapterCB(YBLoggingCallback* user_cb,
                              LogSeverity severity,
@@ -1768,62 +1755,6 @@ Status YBClient::BootstrapProducer(
       this, db_type, namespace_name, pg_schema_names, table_names, deadline, std::move(callback));
 }
 
-Result<std::vector<NamespaceId>> YBClient::XClusterCreateOutboundReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id,
-    const std::vector<NamespaceName>& namespace_names) {
-  SCHECK(!namespace_names.empty(), InvalidArgument, "At least one namespace name is required");
-
-  master::XClusterCreateOutboundReplicationGroupRequestPB req;
-  req.set_replication_group_id(replication_group_id.ToString());
-  for (const auto& ns : namespace_names) {
-    req.add_namespace_names(ns);
-  }
-
-  master::XClusterCreateOutboundReplicationGroupResponsePB resp;
-  CALL_SYNC_LEADER_MASTER_RPC_EX(Replication, req, resp, XClusterCreateOutboundReplicationGroup);
-
-  if (resp.has_error()) {
-    return StatusFromPB(resp.error().status());
-  }
-
-  std::vector<NamespaceId> namespace_ids;
-  for (const auto& namespace_id : resp.namespace_ids()) {
-    namespace_ids.push_back(namespace_id);
-  }
-
-  return namespace_ids;
-}
-
-Status YBClient::GetXClusterStreams(
-    CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
-    const NamespaceId& namespace_id, const std::vector<TableName>& table_names,
-    const std::vector<PgSchemaName>& pg_schema_names, GetXClusterStreamsCallback callback) {
-  return data_->GetXClusterStreams(
-      this, deadline, replication_group_id, namespace_id, table_names, pg_schema_names,
-      std::move(callback));
-}
-
-Status YBClient::IsXClusterBootstrapRequired(
-    CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
-    const NamespaceId& namespace_id, IsXClusterBootstrapRequiredCallback callback) {
-  return data_->IsXClusterBootstrapRequired(
-      this, deadline, replication_group_id, namespace_id, std::move(callback));
-}
-
-Status YBClient::XClusterDeleteOutboundReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id) {
-  master::XClusterDeleteOutboundReplicationGroupRequestPB req;
-  req.set_replication_group_id(replication_group_id.ToString());
-
-  master::XClusterDeleteOutboundReplicationGroupResponsePB resp;
-  CALL_SYNC_LEADER_MASTER_RPC_EX(Replication, req, resp, XClusterDeleteOutboundReplicationGroup);
-
-  if (resp.has_error()) {
-    return StatusFromPB(resp.error().status());
-  }
-  return Status::OK();
-}
-
 Result<NamespaceId> YBClient::XClusterAddNamespaceToOutboundReplicationGroup(
     const xcluster::ReplicationGroupId& replication_group_id, const NamespaceName& namespace_name) {
   master::XClusterAddNamespaceToOutboundReplicationGroupRequestPB req;
@@ -2964,7 +2895,5 @@ Result<master::StatefulServiceInfoPB> YBClient::GetStatefulServiceLocation(
   return std::move(resp.service_info());
 }
 
-IMPLEMENT_SYNC_LEADER_MASTER_RPCS(CLIENT_SYNC_LEADER_MASTER_RPC_LIST);
-
 }  // namespace client
 }  // namespace yb
diff --git a/src/yb/client/client.h b/src/yb/client/client.h
index a300ebe20f..65cc5d86e8 100644
--- a/src/yb/client/client.h
+++ b/src/yb/client/client.h
@@ -83,24 +83,6 @@
 #include "yb/util/strongly_typed_bool.h"
 #include "yb/util/threadpool.h"
 
-#define DECLARE_SYNC_LEADER_MASTER_RPC_IMP(service, method) \
-  Result<master::BOOST_PP_CAT(method, ResponsePB)> method( \
-      const master::BOOST_PP_CAT(method, RequestPB)& req);
-
-#define DECLARE_SYNC_LEADER_MASTER_RPC(i, data, set) DECLARE_SYNC_LEADER_MASTER_RPC_IMP set
-
-#define DECLARE_SYNC_LEADER_MASTER_RPCS(rpcs) \
-  BOOST_PP_SEQ_FOR_EACH(DECLARE_SYNC_LEADER_MASTER_RPC, ~, rpcs)
-
-// Add the methods that we want to invoke on master leader here.
-// These functions will take a const reference to the request of the corresponding type as input and
-// return a Result of the appropriate response.
-// Ex: Result<SetupUniverseReplicationResponsePB>
-// SetupUniverseReplication(SetupUniverseReplicationRequestPB req);
-#define CLIENT_SYNC_LEADER_MASTER_RPC_LIST \
-  ((Replication, SetupUniverseReplication)) \
-  ((Replication, IsSetupUniverseReplicationDone)) \
-
 template<class T> class scoped_refptr;
 
 namespace yb {
@@ -178,9 +160,6 @@ using GetTableLocationsCallback =
 using OpenTableAsyncCallback = std::function<void(const Result<YBTablePtr>&)>;
 using CreateSnapshotCallback = std::function<void(Result<TxnSnapshotId>)>;
 using MasterAddressSource = std::function<std::vector<std::string>()>;
-using GetXClusterStreamsCallback =
-    std::function<void(Result<master::GetXClusterStreamsResponsePB>)>;
-using IsXClusterBootstrapRequiredCallback = std::function<void(Result<bool>)>;
 
 struct TransactionStatusTablets {
   std::vector<TabletId> global_tablets;
@@ -697,22 +676,6 @@ class YBClient {
       const std::vector<TableName>& table_names,
       BootstrapProducerCallback callback);
 
-  Result<std::vector<NamespaceId>> XClusterCreateOutboundReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id,
-      const std::vector<NamespaceName>& namespace_names);
-
-  Status GetXClusterStreams(
-      CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
-      const NamespaceId& namespace_id, const std::vector<TableName>& table_names,
-      const std::vector<PgSchemaName>& pg_schema_names, GetXClusterStreamsCallback callback);
-
-  Status IsXClusterBootstrapRequired(
-      CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
-      const NamespaceId& namespace_id, IsXClusterBootstrapRequiredCallback callback);
-
-  Status XClusterDeleteOutboundReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id);
-
   Result<NamespaceId> XClusterAddNamespaceToOutboundReplicationGroup(
       const xcluster::ReplicationGroupId& replication_group_id,
       const NamespaceName& namespace_name);
@@ -1026,8 +989,6 @@ class YBClient {
   Result<google::protobuf::RepeatedPtrField<master::SnapshotInfoPB>> ListSnapshots(
       const TxnSnapshotId& snapshot_id = TxnSnapshotId::Nil(), bool prepare_for_backup = false);
 
-  DECLARE_SYNC_LEADER_MASTER_RPCS(CLIENT_SYNC_LEADER_MASTER_RPC_LIST);
-
   rpc::Messenger* messenger() const;
 
   const scoped_refptr<MetricEntity>& metric_entity() const;
@@ -1077,6 +1038,8 @@ class YBClient {
   friend class internal::TabletInvoker;
   friend class internal::ClientMasterRpcBase;
   friend class PlacementInfoTest;
+  friend class XClusterClient;
+  friend class XClusterRemoteClient;
 
   FRIEND_TEST(ClientTest, TestGetTabletServerBlacklist);
   FRIEND_TEST(ClientTest, TestMasterDown);
diff --git a/src/yb/client/xcluster_client.cc b/src/yb/client/xcluster_client.cc
index 48f5997725..65f4e9a8aa 100644
--- a/src/yb/client/xcluster_client.cc
+++ b/src/yb/client/xcluster_client.cc
@@ -14,7 +14,9 @@
 #include "yb/client/xcluster_client.h"
 
 #include "yb/client/client.h"
+#include "yb/client/client-internal.h"
 #include "yb/master/master_defaults.h"
+#include "yb/master/master_replication.proxy.h"
 #include "yb/util/is_operation_done_result.h"
 #include "yb/rpc/messenger.h"
 #include "yb/rpc/proxy.h"
@@ -24,7 +26,119 @@
 
 DECLARE_bool(use_node_to_node_encryption);
 
+#define CALL_SYNC_LEADER_MASTER_RPC(method, req) \
+  VERIFY_RESULT(SyncLeaderMasterRpc<master::BOOST_PP_CAT(method, ResponsePB)>( \
+      req, \
+      BOOST_PP_STRINGIZE(method), &master::MasterReplicationProxy::BOOST_PP_CAT(method, Async)))
+
 namespace yb::client {
+XClusterClient::XClusterClient(client::YBClient& yb_client) : yb_client_(yb_client) {}
+
+template <typename ResponsePB, typename RequestPB, typename Method>
+Result<ResponsePB> XClusterClient::SyncLeaderMasterRpc(
+    const RequestPB& req, const char* method_name, const Method& method) {
+  ResponsePB resp;
+  RETURN_NOT_OK(yb_client_.data_->SyncLeaderMasterRpc(
+      CoarseMonoClock::Now() + yb_client_.default_admin_operation_timeout(), req, &resp,
+      method_name, method));
+  return resp;
+}
+
+Status XClusterClient::CreateXClusterReplication(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::string& target_master_addresses) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Replication group id is empty");
+  SCHECK(!target_master_addresses.empty(), InvalidArgument, "Target master_addresses is empty");
+
+  master::CreateXClusterReplicationRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+  auto hp_vec =
+      VERIFY_RESULT(HostPort::ParseStrings(target_master_addresses, master::kMasterDefaultPort));
+  HostPortsToPBs(hp_vec, req.mutable_target_master_addresses());
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(CreateXClusterReplication, req);
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+
+  return Status::OK();
+}
+
+Result<bool> XClusterClient::IsCreateXClusterReplicationDone(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::string& target_master_addresses) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Replication group id is empty");
+  SCHECK(!target_master_addresses.empty(), InvalidArgument, "Target master_addresses is empty");
+
+  master::IsCreateXClusterReplicationDoneRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+
+  auto hp_vec =
+      VERIFY_RESULT(HostPort::ParseStrings(target_master_addresses, master::kMasterDefaultPort));
+  HostPortsToPBs(hp_vec, req.mutable_target_master_addresses());
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(IsCreateXClusterReplicationDone, req);
+
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+
+  return resp.done();
+}
+
+Result<std::vector<NamespaceId>> XClusterClient::XClusterCreateOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::vector<NamespaceName>& namespace_names) {
+  SCHECK(!namespace_names.empty(), InvalidArgument, "At least one namespace name is required");
+
+  master::XClusterCreateOutboundReplicationGroupRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+  for (const auto& ns : namespace_names) {
+    req.add_namespace_names(ns);
+  }
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(XClusterCreateOutboundReplicationGroup, req);
+
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+
+  std::vector<NamespaceId> namespace_ids;
+  for (const auto& namespace_id : resp.namespace_ids()) {
+    namespace_ids.push_back(namespace_id);
+  }
+
+  return namespace_ids;
+}
+
+Status XClusterClient::IsXClusterBootstrapRequired(
+    CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
+    const NamespaceId& namespace_id, IsXClusterBootstrapRequiredCallback callback) {
+  return yb_client_.data_->IsXClusterBootstrapRequired(
+      &yb_client_, deadline, replication_group_id, namespace_id, std::move(callback));
+}
+
+Status XClusterClient::XClusterDeleteOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id) {
+  master::XClusterDeleteOutboundReplicationGroupRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(XClusterDeleteOutboundReplicationGroup, req);
+
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+  return Status::OK();
+}
+
+Status XClusterClient::GetXClusterStreams(
+    CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
+    const NamespaceId& namespace_id, const std::vector<TableName>& table_names,
+    const std::vector<PgSchemaName>& pg_schema_names, GetXClusterStreamsCallback callback) {
+  return yb_client_.data_->GetXClusterStreams(
+      &yb_client_, deadline, replication_group_id, namespace_id, table_names, pg_schema_names,
+      std::move(callback));
+}
 
 XClusterRemoteClient::XClusterRemoteClient(const std::string& certs_for_cdc_dir, MonoDelta timeout)
     : certs_for_cdc_dir_(certs_for_cdc_dir), timeout_(timeout) {}
@@ -62,6 +176,16 @@ Status XClusterRemoteClient::Init(
   return Status::OK();
 }
 
+template <typename ResponsePB, typename RequestPB, typename Method>
+Result<ResponsePB> XClusterRemoteClient::SyncLeaderMasterRpc(
+    const RequestPB& req, const char* method_name, const Method& method) {
+  ResponsePB resp;
+  RETURN_NOT_OK(yb_client_->data_->SyncLeaderMasterRpc(
+      CoarseMonoClock::Now() + yb_client_->default_admin_operation_timeout(), req, &resp,
+      method_name, method));
+  return resp;
+}
+
 Result<UniverseUuid> XClusterRemoteClient::SetupDbScopedUniverseReplication(
     const xcluster::ReplicationGroupId& replication_group_id,
     const std::vector<HostPort>& source_master_addresses,
@@ -94,7 +218,7 @@ Result<UniverseUuid> XClusterRemoteClient::SetupDbScopedUniverseReplication(
     req.add_producer_namespace_ids(namespace_id);
   }
 
-  auto resp = VERIFY_RESULT(yb_client_->SetupUniverseReplication(req));
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(SetupUniverseReplication, req);
 
   if (resp.has_error()) {
     auto status = StatusFromPB(resp.error().status());
@@ -114,7 +238,7 @@ Result<IsOperationDoneResult> XClusterRemoteClient::IsSetupUniverseReplicationDo
   master::IsSetupUniverseReplicationDoneRequestPB req;
   req.set_replication_group_id(replication_group_id.ToString());
 
-  auto resp = VERIFY_RESULT(yb_client_->IsSetupUniverseReplicationDone(req));
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(IsSetupUniverseReplicationDone, req);
   if (resp.has_error()) {
     return StatusFromPB(resp.error().status());
   }
@@ -158,9 +282,11 @@ Status XClusterRemoteClient::GetXClusterTableCheckpointInfos(
     cb(std::make_tuple(std::move(producer_table_ids), std::move(stream_ids), HybridTime::kInvalid));
   };
 
-  RETURN_NOT_OK(yb_client_->GetXClusterStreams(
-      CoarseMonoClock::Now() + yb_client_->default_admin_operation_timeout(), replication_group_id,
-      namespace_id, table_names, pg_schema_names, std::move(callback)));
+  RETURN_NOT_OK(XClusterClient(*yb_client_)
+                    .GetXClusterStreams(
+                        CoarseMonoClock::Now() + yb_client_->default_admin_operation_timeout(),
+                        replication_group_id, namespace_id, table_names, pg_schema_names,
+                        std::move(callback)));
 
   return Status::OK();
 }
diff --git a/src/yb/client/xcluster_client.h b/src/yb/client/xcluster_client.h
index 8c8685f6b7..757a71d180 100644
--- a/src/yb/client/xcluster_client.h
+++ b/src/yb/client/xcluster_client.h
@@ -19,11 +19,9 @@
 #include "yb/cdc/xrepl_types.h"
 #include "yb/cdc/xcluster_types.h"
 #include "yb/client/client_fwd.h"
-#include "yb/common/common_net.pb.h"
 #include "yb/common/entity_ids_types.h"
 #include "yb/common/schema.h"
 #include "yb/util/net/net_util.h"
-#include "yb/util/strongly_typed_string.h"
 #include "yb/util/strongly_typed_uuid.h"
 
 namespace yb {
@@ -34,6 +32,7 @@ class IsOperationDoneResult;
 
 namespace master {
 class MasterReplicationProxy;
+class GetXClusterStreamsResponsePB;
 }  // namespace master
 
 namespace rpc {
@@ -45,6 +44,50 @@ class SecureContext;
 namespace client {
 class YBClient;
 
+using GetXClusterStreamsCallback =
+    std::function<void(Result<master::GetXClusterStreamsResponsePB>)>;
+using IsXClusterBootstrapRequiredCallback = std::function<void(Result<bool>)>;
+
+// A wrapper over YBClient to handle xCluster related RPCs.
+// This class performs serialization of C++ objects to PBs and vice versa. Which enables us to limit
+// the scope of xCluster specific types.
+class XClusterClient {
+ public:
+  explicit XClusterClient(client::YBClient& yb_client);
+  virtual ~XClusterClient() = default;
+
+  virtual Status CreateXClusterReplication(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::string& target_master_addresses);
+
+  virtual Result<bool> IsCreateXClusterReplicationDone(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::string& target_master_addresses);
+
+  Result<std::vector<NamespaceId>> XClusterCreateOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::vector<NamespaceName>& namespace_names);
+
+  Status IsXClusterBootstrapRequired(
+      CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
+      const NamespaceId& namespace_id, IsXClusterBootstrapRequiredCallback callback);
+
+  Status XClusterDeleteOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id);
+
+  Status GetXClusterStreams(
+      CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
+      const NamespaceId& namespace_id, const std::vector<TableName>& table_names,
+      const std::vector<PgSchemaName>& pg_schema_names, GetXClusterStreamsCallback callback);
+
+ private:
+  template <typename ResponsePB, typename RequestPB, typename Method>
+  Result<ResponsePB> SyncLeaderMasterRpc(
+      const RequestPB& req, const char* method_name, const Method& method);
+
+  client::YBClient& yb_client_;
+};
+
 // A wrapper over YBClient to handle xCluster related RPCs sent to a different yb universe.
 // This class performs serialization of C++ objects to PBs and vice versa.
 class XClusterRemoteClient {
@@ -75,6 +118,10 @@ class XClusterRemoteClient {
       BootstrapProducerCallback user_callback);
 
  private:
+  template <typename ResponsePB, typename RequestPB, typename Method>
+  Result<ResponsePB> SyncLeaderMasterRpc(
+      const RequestPB& req, const char* method_name, const Method& method);
+
   const std::string certs_for_cdc_dir_;
   const MonoDelta timeout_;
   std::unique_ptr<rpc::SecureContext> secure_context_;
diff --git a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
index 28dd07218b..925c8dc2e2 100644
--- a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
@@ -11,6 +11,7 @@
 // under the License.
 //
 
+#include "yb/client/xcluster_client.h"
 #include "yb/client/yb_table_name.h"
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
 #include "yb/master/catalog_manager.h"
@@ -111,7 +112,7 @@ class XClusterOutboundReplicationGroupTest : public XClusterYsqlTestBase {
       const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
       std::vector<TableName> table_names = {}, std::vector<PgSchemaName> pg_schema_names = {}) {
     std::promise<Result<master::GetXClusterStreamsResponsePB>> promise;
-    RETURN_NOT_OK(client_->GetXClusterStreams(
+    RETURN_NOT_OK(XClusterClient().GetXClusterStreams(
         CoarseMonoClock::Now() + kDeadline, replication_group_id, namespace_id, table_names,
         pg_schema_names, [&promise](const auto& resp) { promise.set_value(resp); }));
 
@@ -133,6 +134,8 @@ class XClusterOutboundReplicationGroupTest : public XClusterYsqlTestBase {
     return Status::OK();
   }
 
+  client::XClusterClient XClusterClient() { return client::XClusterClient(*client_); }
+
   CatalogManager* catalog_manager_;
   LeaderEpoch epoch_;
   YBClient* client_;
@@ -149,8 +152,8 @@ TEST_F(XClusterOutboundReplicationGroupTest, TestMultipleTable) {
 
   ASSERT_NOK(GetXClusterStreams(kReplicationGroupId, namespace_id_));
 
-  auto out_namespace_id = ASSERT_RESULT(
-      client_->XClusterCreateOutboundReplicationGroup(kReplicationGroupId, {kNamespaceName}));
+  auto out_namespace_id = ASSERT_RESULT(XClusterClient().XClusterCreateOutboundReplicationGroup(
+      kReplicationGroupId, {kNamespaceName}));
   ASSERT_EQ(out_namespace_id.size(), 1);
   ASSERT_EQ(out_namespace_id[0], namespace_id_);
 
@@ -185,7 +188,7 @@ TEST_F(XClusterOutboundReplicationGroupTest, TestMultipleTable) {
   ASSERT_OK(VerifyWalRetentionOfTable(table_id_1));
   ASSERT_OK(VerifyWalRetentionOfTable(table_id_2));
 
-  ASSERT_OK(client_->XClusterDeleteOutboundReplicationGroup(kReplicationGroupId));
+  ASSERT_OK(XClusterClient().XClusterDeleteOutboundReplicationGroup(kReplicationGroupId));
   ASSERT_NOK(GetXClusterStreams(kReplicationGroupId, namespace_id_));
 
   // We should have 0 streams now.
@@ -202,8 +205,8 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
   auto ns2_table_id_1 = ASSERT_RESULT(CreateYsqlTable(namespace_name_2, kTableName1));
   auto ns2_table_id_2 = ASSERT_RESULT(CreateYsqlTable(namespace_name_2, kTableName2));
 
-  auto out_namespace_id = ASSERT_RESULT(
-      client_->XClusterCreateOutboundReplicationGroup(kReplicationGroupId, {kNamespaceName}));
+  auto out_namespace_id = ASSERT_RESULT(XClusterClient().XClusterCreateOutboundReplicationGroup(
+      kReplicationGroupId, {kNamespaceName}));
   ASSERT_EQ(out_namespace_id.size(), 1);
   ASSERT_EQ(out_namespace_id[0], namespace_id_);
 
@@ -224,8 +227,9 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
       ns1_table_id_1, ns1_table_id_2, all_xcluster_streams_initial, ns1_info));
 
   // Add the second namespace.
-  auto out_namespace_id2 = ASSERT_RESULT(client_->XClusterAddNamespaceToOutboundReplicationGroup(
-      kReplicationGroupId, namespace_name_2));
+  auto out_namespace_id2 =
+      ASSERT_RESULT(client_->XClusterAddNamespaceToOutboundReplicationGroup(
+          kReplicationGroupId, namespace_name_2));
   ASSERT_EQ(out_namespace_id2, namespace_id_2);
 
   // We should have 4 streams now.
@@ -256,7 +260,7 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
     }
   }
 
-  ASSERT_OK(client_->XClusterDeleteOutboundReplicationGroup(kReplicationGroupId));
+  ASSERT_OK(XClusterClient().XClusterDeleteOutboundReplicationGroup(kReplicationGroupId));
   ASSERT_NOK(GetXClusterStreams(kReplicationGroupId, namespace_id_));
   auto final_xcluster_streams = CleanupAndGetAllXClusterStreams();
   ASSERT_TRUE(final_xcluster_streams.empty());
@@ -266,7 +270,8 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddTable) {
   auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
   ASSERT_OK(VerifyWalRetentionOfTable(table_id_1, 0));
 
-  ASSERT_OK(client_->XClusterCreateOutboundReplicationGroup(kReplicationGroupId, {kNamespaceName}));
+  ASSERT_OK(XClusterClient().XClusterCreateOutboundReplicationGroup(
+      kReplicationGroupId, {kNamespaceName}));
 
   // Wait for the new streams to be ready.
   ASSERT_OK(GetXClusterStreams(kReplicationGroupId, namespace_id_));
@@ -292,11 +297,12 @@ TEST_F(XClusterOutboundReplicationGroupTest, IsBootstrapRequiredEmptyTable) {
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_max_xcluster_streams_to_checkpoint_in_parallel) = 1;
 
   auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
-  ASSERT_OK(client_->XClusterCreateOutboundReplicationGroup(kReplicationGroupId, {kNamespaceName}));
+  ASSERT_OK(XClusterClient().XClusterCreateOutboundReplicationGroup(
+      kReplicationGroupId, {kNamespaceName}));
 
   std::promise<Result<bool>> promise;
 
-  ASSERT_OK(client_->IsXClusterBootstrapRequired(
+  ASSERT_OK(XClusterClient().IsXClusterBootstrapRequired(
       CoarseMonoClock::Now() + kDeadline, kReplicationGroupId, namespace_id_,
       [&promise](Result<bool> result) { promise.set_value(std::move(result)); }));
 
@@ -313,11 +319,12 @@ TEST_F(XClusterOutboundReplicationGroupTest, IsBootstrapRequiredTableWithData) {
   ASSERT_OK(producer_client()->OpenTable(table_id_2, &table_2));
   ASSERT_OK(InsertRowsInProducer(0, 10, table_2));
 
-  ASSERT_OK(client_->XClusterCreateOutboundReplicationGroup(kReplicationGroupId, {kNamespaceName}));
+  ASSERT_OK(XClusterClient().XClusterCreateOutboundReplicationGroup(
+      kReplicationGroupId, {kNamespaceName}));
 
   std::promise<Result<bool>> promise;
 
-  ASSERT_OK(client_->IsXClusterBootstrapRequired(
+  ASSERT_OK(XClusterClient().IsXClusterBootstrapRequired(
       CoarseMonoClock::Now() + kDeadline, kReplicationGroupId, namespace_id_,
       [&promise](Result<bool> result) { promise.set_value(std::move(result)); }));
 
@@ -335,11 +342,12 @@ TEST_F(XClusterOutboundReplicationGroupTest, IsBootstrapRequiredTableWithDeleted
   ASSERT_OK(InsertRowsInProducer(0, 10, table_2));
   ASSERT_OK(DeleteRowsInProducer(0, 10, table_2));
 
-  ASSERT_OK(client_->XClusterCreateOutboundReplicationGroup(kReplicationGroupId, {kNamespaceName}));
+  ASSERT_OK(XClusterClient().XClusterCreateOutboundReplicationGroup(
+      kReplicationGroupId, {kNamespaceName}));
 
   std::promise<Result<bool>> promise;
 
-  ASSERT_OK(client_->IsXClusterBootstrapRequired(
+  ASSERT_OK(XClusterClient().IsXClusterBootstrapRequired(
       CoarseMonoClock::Now() + kDeadline, kReplicationGroupId, namespace_id_,
       [&promise](Result<bool> result) { promise.set_value(std::move(result)); }));
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
index 416d655fad..8811fb69f4 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
@@ -14,6 +14,7 @@
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
 #include "yb/client/client.h"
 #include "yb/client/table.h"
+#include "yb/client/xcluster_client.h"
 #include "yb/client/yb_table_name.h"
 #include "yb/master/master_cluster.pb.h"
 #include "yb/master/master_cluster.proxy.h"
@@ -803,48 +804,33 @@ Status XClusterYsqlTestBase::SetUpWithParams(
 
 Status XClusterYsqlTestBase::CheckpointReplicationGroup() {
   auto producer_namespace_id = VERIFY_RESULT(GetNamespaceId(producer_client()));
-  auto namespace_id_out = VERIFY_RESULT(producer_client()->XClusterCreateOutboundReplicationGroup(
-      kReplicationGroupId, {namespace_name}));
+  auto namespace_id_out = VERIFY_RESULT(
+      client::XClusterClient(*producer_client())
+          .XClusterCreateOutboundReplicationGroup(kReplicationGroupId, {namespace_name}));
   SCHECK_EQ(namespace_id_out.size(), 1, IllegalState, "Namespace count does not match");
   SCHECK_EQ(namespace_id_out[0], producer_namespace_id, IllegalState, "NamespaceId does not match");
 
   std::promise<Result<bool>> promise;
   auto future = promise.get_future();
-  RETURN_NOT_OK(producer_client()->IsXClusterBootstrapRequired(
-      CoarseMonoClock::now() + MonoDelta::FromSeconds(kRpcTimeout), kReplicationGroupId,
-      producer_namespace_id, [&promise](Result<bool> res) { promise.set_value(res); }));
+  RETURN_NOT_OK(client::XClusterClient(*producer_client())
+                    .IsXClusterBootstrapRequired(
+                        CoarseMonoClock::now() + MonoDelta::FromSeconds(kRpcTimeout),
+                        kReplicationGroupId, producer_namespace_id,
+                        [&promise](Result<bool> res) { promise.set_value(res); }));
   auto bootstrap_required = VERIFY_RESULT(future.get());
   SCHECK(!bootstrap_required, IllegalState, "Bootstrap should not be required");
 
   return Status::OK();
 }
 
-Result<bool> XClusterYsqlTestBase::IsCreateXClusterReplicationDone() {
-  master::IsCreateXClusterReplicationDoneRequestPB req;
-  master::IsCreateXClusterReplicationDoneResponsePB resp;
-  req.set_replication_group_id(kReplicationGroupId.ToString());
-  auto master_addr = consumer_cluster()->GetMasterAddresses();
-  auto hp_vec = VERIFY_RESULT(HostPort::ParseStrings(master_addr, 0));
-  HostPortsToPBs(hp_vec, req.mutable_target_master_addresses());
-
-  auto master_proxy = VERIFY_RESULT(GetProducerMasterProxy());
-
-  rpc::RpcController rpc;
-  rpc.set_timeout(MonoDelta::FromSeconds(kRpcTimeout));
-
-  RETURN_NOT_OK(master_proxy.IsCreateXClusterReplicationDone(req, &resp, &rpc));
-
-  if (resp.has_error()) {
-    return StatusFromPB(resp.error().status());
-  }
-
-  return resp.done();
-}
-
 Status XClusterYsqlTestBase::WaitForCreateReplicationToFinish() {
   RETURN_NOT_OK(LoggedWaitFor(
-      [this]() { return IsCreateXClusterReplicationDone(); }, MonoDelta::FromSeconds(kRpcTimeout),
-      __func__));
+      [this]() {
+        return client::XClusterClient(*producer_client())
+            .IsCreateXClusterReplicationDone(
+                kReplicationGroupId, consumer_cluster()->GetMasterAddresses());
+      },
+      MonoDelta::FromSeconds(kRpcTimeout), __func__));
 
   // Wait for the xcluster safe time to propagate to the tserver nodes.
   return WaitForSafeTimeToAdvanceToNow();
@@ -853,23 +839,10 @@ Status XClusterYsqlTestBase::WaitForCreateReplicationToFinish() {
 Status XClusterYsqlTestBase::CreateReplicationFromCheckpoint() {
   RETURN_NOT_OK(SetupCertificates(kReplicationGroupId));
 
-  master::CreateXClusterReplicationRequestPB req;
-  master::CreateXClusterReplicationResponsePB resp;
-  req.set_replication_group_id(kReplicationGroupId.ToString());
   auto master_addr = consumer_cluster()->GetMasterAddresses();
-  auto hp_vec = VERIFY_RESULT(HostPort::ParseStrings(master_addr, 0));
-  HostPortsToPBs(hp_vec, req.mutable_target_master_addresses());
-
-  auto master_proxy = VERIFY_RESULT(GetProducerMasterProxy());
-
-  rpc::RpcController rpc;
-  rpc.set_timeout(MonoDelta::FromSeconds(kRpcTimeout));
-
-  RETURN_NOT_OK(master_proxy.CreateXClusterReplication(req, &resp, &rpc));
 
-  if (resp.has_error()) {
-    return StatusFromPB(resp.error().status());
-  }
+  RETURN_NOT_OK(client::XClusterClient(*producer_client())
+                    .CreateXClusterReplication(kReplicationGroupId, master_addr));
 
   return WaitForCreateReplicationToFinish();
 }
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
index bce36afcc1..e77b0fffb5 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
@@ -118,7 +118,6 @@ class XClusterYsqlTestBase : public XClusterTestBase {
 
   Status CheckpointReplicationGroup();
   Status CreateReplicationFromCheckpoint();
-  Result<bool> IsCreateXClusterReplicationDone();
   Status WaitForCreateReplicationToFinish();
 
  protected:
diff --git a/src/yb/tools/yb-admin_cli.cc b/src/yb/tools/yb-admin_cli.cc
index 92d953a114..c6e045730d 100644
--- a/src/yb/tools/yb-admin_cli.cc
+++ b/src/yb/tools/yb-admin_cli.cc
@@ -2261,6 +2261,121 @@ Status get_xcluster_safe_time_action(
   return PrintJsonResult(client->GetXClusterSafeTime(include_lag_and_skew));
 }
 
+const auto create_xcluster_checkpoint_args = "<replication_group_id> <database_names>";
+Status create_xcluster_checkpoint_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  if (args.size() != 2) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  auto replication_group_id = xcluster::ReplicationGroupId(args[0]);
+  std::vector<NamespaceName> namespace_names;
+  boost::split(namespace_names, args[1], boost::is_any_of(","));
+
+  auto namespace_ids =
+      VERIFY_RESULT(client->CheckpointXClusterReplication(replication_group_id, namespace_names));
+
+  SCHECK_EQ(
+      namespace_ids.size(), namespace_names.size(), IllegalState,
+      "Number of namespace ids does not match number of namespace names");
+
+  std::cout << "Waiting for checkpointing of database(s) to complete" << std::endl << std::endl;
+
+  std::vector<NamespaceName> dbs_with_bootstrap;
+  std::vector<NamespaceName> dbs_without_bootstrap;
+  for (size_t i = 0; i < namespace_ids.size(); i++) {
+    auto is_bootstrap_required =
+        VERIFY_RESULT(client->IsXClusterBootstrapRequired(replication_group_id, namespace_ids[i]));
+    std::cout << "Checkpointing of " << namespace_names[i] << " completed. Bootstrap is "
+              << (is_bootstrap_required ? "" : "not ")
+              << "required for setting up xCluster replication" << std::endl;
+    if (is_bootstrap_required) {
+      dbs_with_bootstrap.push_back(namespace_names[i]);
+    } else {
+      dbs_without_bootstrap.push_back(namespace_names[i]);
+    }
+  }
+  std::cout << "Successfully checkpointed databases for xCluster replication group "
+            << replication_group_id << std::endl
+            << std::endl;
+
+  if (!dbs_with_bootstrap.empty()) {
+    std::cout << "Perform a distributed Backup of database(s) " << AsString(dbs_with_bootstrap)
+              << " and Restore them on the target universe";
+  }
+  if (!dbs_without_bootstrap.empty()) {
+    std::cout << "Create equivalent YSQL objects (schemas, tables, indexes, ...) for databases "
+              << AsString(dbs_without_bootstrap) << " on the target universe";
+  }
+
+  std::cout << "Once the above step(s) complete run `setup_xcluster_replication`" << std::endl;
+
+  return Status::OK();
+}
+
+const auto is_xcluster_bootstrap_required_args = "<replication_group_id> <database_names>";
+Status is_xcluster_bootstrap_required_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  if (args.size() != 2) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  auto replication_group_id = xcluster::ReplicationGroupId(args[0]);
+  std::vector<NamespaceName> namespace_names;
+  boost::split(namespace_names, args[1], boost::is_any_of(","));
+
+  std::cout << "Waiting for checkpointing of database(s) to complete" << std::endl << std::endl;
+
+  for (size_t i = 0; i < namespace_names.size(); i++) {
+    const auto& namespace_info = VERIFY_RESULT_REF(
+        client->GetNamespaceInfo(YQLDatabase::YQL_DATABASE_PGSQL, namespace_names[i]));
+    auto is_bootstrap_required = VERIFY_RESULT(
+        client->IsXClusterBootstrapRequired(replication_group_id, namespace_info.id()));
+    std::cout << "Checkpointing of " << namespace_names[i] << " completed. Bootstrap is "
+              << (is_bootstrap_required ? "" : "not ")
+              << "required for setting up xCluster replication" << std::endl;
+  }
+
+  return Status::OK();
+}
+
+const auto setup_xcluster_replication_args =
+    "<replication_group_id> <target_master_addresses>";
+Status setup_xcluster_replication_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  if (args.size() != 2) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  auto replication_group_id = xcluster::ReplicationGroupId(args[0]);
+
+  RETURN_NOT_OK(client->CreateXClusterReplication(replication_group_id, args[1]));
+
+  RETURN_NOT_OK(client->WaitForCreateXClusterReplication(replication_group_id, args[1]));
+
+  std::cout << "xCluster Replication group " << replication_group_id << " setup successfully"
+            << endl;
+
+  return Status::OK();
+}
+
+const auto drop_xcluster_replication_args = "<replication_group_id>";
+Status drop_xcluster_replication_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  if (args.size() != 1) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  auto replication_group_id = xcluster::ReplicationGroupId(args[0]);
+
+  RETURN_NOT_OK(client->DeleteXClusterOutboundReplicationGroup(replication_group_id));
+
+  std::cout << "Outbound xCluster Replication group " << replication_group_id
+            << " deleted successfully" << endl;
+
+  return Status::OK();
+}
+
 }  // namespace
 
 void ClusterAdminCli::RegisterCommandHandlers() {
@@ -2376,6 +2491,11 @@ void ClusterAdminCli::RegisterCommandHandlers() {
   REGISTER_COMMAND(setup_namespace_universe_replication);
   REGISTER_COMMAND(get_replication_status);
   REGISTER_COMMAND(get_xcluster_safe_time);
+  // xCluster V2 commands
+  REGISTER_COMMAND(create_xcluster_checkpoint);
+  REGISTER_COMMAND(is_xcluster_bootstrap_required);
+  REGISTER_COMMAND(setup_xcluster_replication);
+  REGISTER_COMMAND(drop_xcluster_replication);
 }
 
 Result<std::vector<client::YBTableName>> ResolveTableNames(
diff --git a/src/yb/tools/yb-admin_client.cc b/src/yb/tools/yb-admin_client.cc
index 7575622357..2976228869 100644
--- a/src/yb/tools/yb-admin_client.cc
+++ b/src/yb/tools/yb-admin_client.cc
@@ -52,6 +52,7 @@
 #include "yb/client/table_creator.h"
 #include "yb/client/table_alterer.h"
 #include "yb/client/table_info.h"
+#include "yb/client/xcluster_client.h"
 
 #include "yb/common/colocated_util.h"
 #include "yb/common/json_util.h"
@@ -71,11 +72,11 @@
 #include "yb/master/master_client.proxy.h"
 #include "yb/master/master_cluster.proxy.h"
 #include "yb/master/master_ddl.proxy.h"
+#include "yb/master/master_defaults.h"
 #include "yb/master/master_encryption.proxy.h"
 #include "yb/master/master_error.h"
 #include "yb/master/master_replication.proxy.h"
 #include "yb/master/master_test.proxy.h"
-#include "yb/master/master_defaults.h"
 #include "yb/master/master_util.h"
 #include "yb/master/sys_catalog.h"
 
@@ -2350,7 +2351,7 @@ Status ClusterAdminClient::ChangeBlacklist(const std::vector<HostPort>& servers,
 
 Result<const master::NamespaceIdentifierPB&> ClusterAdminClient::GetNamespaceInfo(
     YQLDatabase db_type, const std::string& namespace_name) {
-  LOG(INFO) << Format(
+  VLOG(1) << Format(
       "Resolving namespace id for '$0' of type '$1'", namespace_name, DatabasePrefix(db_type));
   for (const auto& item : VERIFY_RESULT_REF(GetNamespaceMap())) {
     const auto& namespace_info = item.second;
@@ -4541,6 +4542,58 @@ Result<rapidjson::Document> ClusterAdminClient::GetXClusterSafeTime(bool include
   return document;
 }
 
+Result<std::vector<NamespaceId>> ClusterAdminClient::CheckpointXClusterReplication(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::vector<NamespaceName> databases) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Replication group id is empty");
+
+  return XClusterClient().XClusterCreateOutboundReplicationGroup(replication_group_id, databases);
+}
+
+Result<bool> ClusterAdminClient::IsXClusterBootstrapRequired(
+    const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId namespace_id) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Replication group id is empty");
+
+  auto deadline = CoarseMonoClock::now() + timeout_;
+  auto promise = std::promise<Result<bool>>();
+  RETURN_NOT_OK(XClusterClient().IsXClusterBootstrapRequired(
+      deadline, replication_group_id, namespace_id,
+      [&promise](Result<bool> result) { promise.set_value(std::move(result)); }));
+  return promise.get_future().get();
+}
+
+Status ClusterAdminClient::CreateXClusterReplication(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::string& target_master_addresses) {
+  return XClusterClient().CreateXClusterReplication(replication_group_id, target_master_addresses);
+}
+
+Status ClusterAdminClient::WaitForCreateXClusterReplication(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::string& target_master_addresses) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Replication group id is empty");
+
+  for (;;) {
+    if (VERIFY_RESULT(XClusterClient().IsCreateXClusterReplicationDone(
+            replication_group_id, target_master_addresses))) {
+      return Status::OK();
+    }
+
+    std::this_thread::sleep_for(100ms);
+  }
+}
+
+Status ClusterAdminClient::DeleteXClusterOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Replication group id is empty");
+
+  return XClusterClient().XClusterDeleteOutboundReplicationGroup(replication_group_id);
+}
+
+client::XClusterClient ClusterAdminClient::XClusterClient() {
+  return client::XClusterClient(*yb_client_);
+}
+
 string RightPadToUuidWidth(const string &s) {
   return RightPadToWidth(s, kNumCharactersInUuid);
 }
diff --git a/src/yb/tools/yb-admin_client.h b/src/yb/tools/yb-admin_client.h
index d623808b5f..ac79ac3e6e 100644
--- a/src/yb/tools/yb-admin_client.h
+++ b/src/yb/tools/yb-admin_client.h
@@ -70,6 +70,7 @@ class ConsensusServiceProxy;
 
 namespace client {
 class YBClient;
+class XClusterClient;
 }
 
 namespace tools {
@@ -457,6 +458,24 @@ class ClusterAdminClient {
 
   Result<rapidjson::Document> GetXClusterSafeTime(bool include_lag_and_skew = false);
 
+  Result<std::vector<NamespaceId>> CheckpointXClusterReplication(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::vector<NamespaceName> databases);
+
+  Result<bool> IsXClusterBootstrapRequired(
+      const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId namespace_id);
+
+  Status CreateXClusterReplication(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::string& target_master_addresses);
+
+  Status WaitForCreateXClusterReplication(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::string& target_master_addresses);
+
+  Status DeleteXClusterOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id);
+
  protected:
   // Fetch the locations of the replicas for a given tablet from the Master.
   Status GetTabletLocations(const TabletId& tablet_id,
@@ -536,6 +555,8 @@ class ClusterAdminClient {
   Result<master::IsTabletSplittingCompleteResponsePB> IsTabletSplittingCompleteInternal(
       bool wait_for_parent_deletion, const MonoDelta timeout = MonoDelta());
 
+  client::XClusterClient XClusterClient();
+
   std::string master_addr_list_;
   HostPort init_master_addr_;
   const MonoDelta timeout_;
