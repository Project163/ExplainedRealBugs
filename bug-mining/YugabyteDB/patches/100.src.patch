diff --git a/src/postgres/src/backend/access/yb_access/yb_scan.c b/src/postgres/src/backend/access/yb_access/yb_scan.c
index d6e8f0f896..3df95759b7 100644
--- a/src/postgres/src/backend/access/yb_access/yb_scan.c
+++ b/src/postgres/src/backend/access/yb_access/yb_scan.c
@@ -1343,10 +1343,12 @@ static bool YbNeedTupleRangeCheck(Datum value, TupleDesc bind_desc,
 }
 
 static bool YbIsTupleInRange(Datum value, TupleDesc bind_desc,
-							 int key_length, ScanKey keys[])
+							 int key_length, ScanKey keys[],
+							 AttrNumber bind_key_attnums[])
 {
 	/* Move past header key. */
 	++keys;
+	++bind_key_attnums;
 	--key_length;
 
 	Oid tupType =
@@ -1371,7 +1373,7 @@ static bool YbIsTupleInRange(Datum value, TupleDesc bind_desc,
 	for (int i = 0; i < key_length; i++) {
 		Datum val = datum_values[i];
 		Oid val_type = ybc_get_atttypid(val_tupdesc, i + 1);
-		Oid column_type = ybc_get_atttypid(bind_desc, keys[i]->sk_attno);
+		Oid column_type = ybc_get_atttypid(bind_desc, bind_key_attnums[i]);
 
 		if (!YbShouldRecheckEquality(column_type, val_type))
 			continue;
@@ -1737,7 +1739,8 @@ YbBindSearchArray(YbScanDesc ybScan, YbScanPlan scan_plan,
 				!YbIsTupleInRange(elem_values[j],
 			 					  scan_plan->bind_desc,
 			 					  length_of_key,
-								  &ybScan->keys[i]))
+								  &ybScan->keys[i],
+								  &scan_plan->bind_key_attnums[i]))
 				continue;
 		}
 
diff --git a/src/postgres/src/test/regress/expected/yb_join_batching.out b/src/postgres/src/test/regress/expected/yb_join_batching.out
index 480bfd30af..ffc229e502 100644
--- a/src/postgres/src/test/regress/expected/yb_join_batching.out
+++ b/src/postgres/src/test/regress/expected/yb_join_batching.out
@@ -1829,6 +1829,28 @@ a = int4table.a;
 
 drop table oidtable;
 drop table int4table;
+CREATE TABLE p_inner(a int, b text, PRIMARY KEY(b asc, a asc));
+CREATE TABLE p_outer(a bigint, b text);
+INSERT INTO p_outer VALUES (0, '1');
+INSERT INTO p_inner VALUES (0, '1');
+EXPLAIN (COSTS OFF) SELECT * FROM p_outer, p_inner where p_outer.a = p_inner.a AND p_outer.b = p_inner.b;
+                                             QUERY PLAN
+----------------------------------------------------------------------------------------------------
+ YB Batched Nested Loop Join
+   Join Filter: ((p_outer.a = p_inner.a) AND (p_outer.b = p_inner.b))
+   ->  Seq Scan on p_outer
+   ->  Index Scan using p_inner_pkey on p_inner
+         Index Cond: (ROW(b, a) = ANY (ARRAY[ROW(p_outer.b, p_outer.a), ROW($1, $4), ROW($2, $5)]))
+(5 rows)
+
+SELECT * FROM p_outer, p_inner where p_outer.a = p_inner.a AND p_outer.b = p_inner.b;
+ a | b | a | b
+---+---+---+---
+ 0 | 1 | 0 | 1
+(1 row)
+
+DROP TABLE p_inner;
+DROP TABLE p_outer;
 create table ss1(a int);
 create table ss2(a int);
 create table ss3(a int, b int, primary key(a asc, b asc));
diff --git a/src/postgres/src/test/regress/sql/yb_join_batching.sql b/src/postgres/src/test/regress/sql/yb_join_batching.sql
index c67c00f471..83371702bc 100644
--- a/src/postgres/src/test/regress/sql/yb_join_batching.sql
+++ b/src/postgres/src/test/regress/sql/yb_join_batching.sql
@@ -515,6 +515,15 @@ a = int4table.a;
 drop table oidtable;
 drop table int4table;
 
+CREATE TABLE p_inner(a int, b text, PRIMARY KEY(b asc, a asc));
+CREATE TABLE p_outer(a bigint, b text);
+INSERT INTO p_outer VALUES (0, '1');
+INSERT INTO p_inner VALUES (0, '1');
+EXPLAIN (COSTS OFF) SELECT * FROM p_outer, p_inner where p_outer.a = p_inner.a AND p_outer.b = p_inner.b;
+SELECT * FROM p_outer, p_inner where p_outer.a = p_inner.a AND p_outer.b = p_inner.b;
+DROP TABLE p_inner;
+DROP TABLE p_outer;
+
 create table ss1(a int);
 create table ss2(a int);
 create table ss3(a int, b int, primary key(a asc, b asc));
