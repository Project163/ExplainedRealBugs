diff --git a/java/yb-pgsql/src/test/java/org/yb/pgsql/TestPgRegressThirdPartyExtensionsPgCron.java b/java/yb-pgsql/src/test/java/org/yb/pgsql/TestPgRegressThirdPartyExtensionsPgCron.java
index 75edd5dbb9..6ec7d353d1 100644
--- a/java/yb-pgsql/src/test/java/org/yb/pgsql/TestPgRegressThirdPartyExtensionsPgCron.java
+++ b/java/yb-pgsql/src/test/java/org/yb/pgsql/TestPgRegressThirdPartyExtensionsPgCron.java
@@ -16,10 +16,11 @@ import java.io.File;
 import java.util.Map;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.yb.YBTestRunner;
 import org.yb.client.TestUtils;
+import org.yb.util.YBTestRunnerNonTsanOnly;
 
-@RunWith(value = YBTestRunner.class)
+// Disable in TSAN since it times out on pg_cron exist #22295.
+@RunWith(value = YBTestRunnerNonTsanOnly.class)
 public class TestPgRegressThirdPartyExtensionsPgCron extends BasePgSQLTest {
   @Override
   public int getTestMethodTimeoutSec() {
diff --git a/src/postgres/third-party-extensions/pg_cron/Makefile b/src/postgres/third-party-extensions/pg_cron/Makefile
index 4b7b835b7e..cc8d3ddcbd 100644
--- a/src/postgres/third-party-extensions/pg_cron/Makefile
+++ b/src/postgres/third-party-extensions/pg_cron/Makefile
@@ -6,15 +6,15 @@ DATA_built = $(EXTENSION)--1.0.sql
 DATA = $(wildcard $(EXTENSION)--*--*.sql)
 
 REGRESS_OPTS =--temp-config=./pg_cron.conf --temp-instance=./tmp_check
-REGRESS = pg_cron-test 
+REGRESS = pg_cron-test
 
 # compilation configuration
 MODULE_big = $(EXTENSION)
 OBJS = $(patsubst %.c,%.o,$(wildcard src/*.c))
 ifeq ($(CC),gcc)
-    PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-uninitialized -Wno-implicit-fallthrough -Iinclude -I$(libpq_srcdir)
+    PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-uninitialized -Wno-implicit-fallthrough -Wno-unused-function -Iinclude -I$(libpq_srcdir)
 else
-    PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-implicit-fallthrough -Iinclude -I$(libpq_srcdir)
+    PG_CPPFLAGS = -std=c99 -Wall -Wextra -Werror -Wno-unused-parameter -Wno-implicit-fallthrough -Wno-unused-function -Iinclude -I$(libpq_srcdir)
 endif
 SHLIB_LINK = $(libpq) -L$(YB_BUILD_ROOT)/lib -lyb_pggate $(filter -lintl,$(LIBS))
 EXTRA_CLEAN += $(addprefix src/,*.gcno *.gcda) # clean up after profiling runs
diff --git a/src/postgres/third-party-extensions/pg_cron/expected/yb_pg_cron-test.out b/src/postgres/third-party-extensions/pg_cron/expected/yb_pg_cron-test.out
new file mode 100644
index 0000000000..72c0374403
--- /dev/null
+++ b/src/postgres/third-party-extensions/pg_cron/expected/yb_pg_cron-test.out
@@ -0,0 +1,19 @@
+CREATE EXTENSION pg_cron;
+-- Recreate job with same name
+SELECT cron.schedule('myjob', '0 11 * * *', 'SELECT 1');
+ schedule
+----------
+        1
+(1 row)
+
+SELECT cron.unschedule('myjob');
+ unschedule
+------------
+ t
+(1 row)
+
+SELECT cron.schedule('myjob', '0 11 * * *', 'SELECT 1');
+ schedule
+----------
+        2
+(1 row)
diff --git a/src/postgres/third-party-extensions/pg_cron/sql/pg_cron-test.sql b/src/postgres/third-party-extensions/pg_cron/sql/pg_cron-test.sql
index fc865ec285..71ab292d2c 100644
--- a/src/postgres/third-party-extensions/pg_cron/sql/pg_cron-test.sql
+++ b/src/postgres/third-party-extensions/pg_cron/sql/pg_cron-test.sql
@@ -16,17 +16,17 @@ SELECT cron.unschedule(1);
 SELECT cron.schedule(repeat('a', 1000), '');
 
 -- Invalid input: missing parts
-SELECT cron.schedule('* * * *', 'SELECT 1'); 
+SELECT cron.schedule('* * * *', 'SELECT 1');
 
 -- Invalid input: trailing characters
-SELECT cron.schedule('5 secondc', 'SELECT 1'); 
-SELECT cron.schedule('50 seconds c', 'SELECT 1'); 
+SELECT cron.schedule('5 secondc', 'SELECT 1');
+SELECT cron.schedule('50 seconds c', 'SELECT 1');
 
 -- Invalid input: seconds out of range
-SELECT cron.schedule('-1 seconds', 'SELECT 1'); 
-SELECT cron.schedule('0 seconds', 'SELECT 1'); 
-SELECT cron.schedule('60 seconds', 'SELECT 1'); 
-SELECT cron.schedule('10000000000 seconds', 'SELECT 1'); 
+SELECT cron.schedule('-1 seconds', 'SELECT 1');
+SELECT cron.schedule('0 seconds', 'SELECT 1');
+SELECT cron.schedule('60 seconds', 'SELECT 1');
+SELECT cron.schedule('10000000000 seconds', 'SELECT 1');
 
 -- Try to update pg_cron on restart
 SELECT cron.schedule('@restar', 'ALTER EXTENSION pg_cron UPDATE');
@@ -136,10 +136,10 @@ CREATE EXTENSION pg_cron;
 select * from public.test;
 
 -- valid interval jobs
-SELECT cron.schedule('1 second', 'SELECT 1'); 
-SELECT cron.schedule(' 30 sEcOnDs ', 'SELECT 1'); 
-SELECT cron.schedule('59 seconds', 'SELECT 1'); 
-SELECT cron.schedule('17  seconds ', 'SELECT 1'); 
+SELECT cron.schedule('1 second', 'SELECT 1');
+SELECT cron.schedule(' 30 sEcOnDs ', 'SELECT 1');
+SELECT cron.schedule('59 seconds', 'SELECT 1');
+SELECT cron.schedule('17  seconds ', 'SELECT 1');
 SELECT jobid, jobname, schedule, command FROM cron.job ORDER BY jobid;
 
 -- valid last of day job
diff --git a/src/postgres/third-party-extensions/pg_cron/sql/yb_pg_cron-test.sql b/src/postgres/third-party-extensions/pg_cron/sql/yb_pg_cron-test.sql
new file mode 100644
index 0000000000..9deecf5705
--- /dev/null
+++ b/src/postgres/third-party-extensions/pg_cron/sql/yb_pg_cron-test.sql
@@ -0,0 +1,6 @@
+CREATE EXTENSION pg_cron;
+
+-- Recreate job with same name
+SELECT cron.schedule('myjob', '0 11 * * *', 'SELECT 1');
+SELECT cron.unschedule('myjob');
+SELECT cron.schedule('myjob', '0 11 * * *', 'SELECT 1');
\ No newline at end of file
diff --git a/src/postgres/third-party-extensions/pg_cron/src/job_metadata.c b/src/postgres/third-party-extensions/pg_cron/src/job_metadata.c
index dc0cd0e796..14ac859446 100644
--- a/src/postgres/third-party-extensions/pg_cron/src/job_metadata.c
+++ b/src/postgres/third-party-extensions/pg_cron/src/job_metadata.c
@@ -665,7 +665,7 @@ cron_unschedule(PG_FUNCTION_ARGS)
 	EnsureDeletePermission(cronJobsTable, heapTuple);
 
 	if (IsYugaByteEnabled())
-		YBCDeleteSysCatalogTuple(cronJobsTable, heapTuple);
+		CatalogTupleDelete(cronJobsTable, heapTuple);
 	else
 		simple_heap_delete(cronJobsTable, &heapTuple->t_self);
 
@@ -739,7 +739,7 @@ cron_unschedule_named(PG_FUNCTION_ARGS)
 	EnsureDeletePermission(cronJobsTable, heapTuple);
 
 	if (IsYugaByteEnabled())
-		YBCDeleteSysCatalogTuple(cronJobsTable, heapTuple);
+		CatalogTupleDelete(cronJobsTable, heapTuple);
 	else
 		simple_heap_delete(cronJobsTable, &heapTuple->t_self);
 
diff --git a/src/postgres/third-party-extensions/pg_cron/src/pg_cron.c b/src/postgres/third-party-extensions/pg_cron/src/pg_cron.c
index 97023e2b4d..f08cc2b512 100644
--- a/src/postgres/third-party-extensions/pg_cron/src/pg_cron.c
+++ b/src/postgres/third-party-extensions/pg_cron/src/pg_cron.c
@@ -151,6 +151,7 @@ static bool jobStartupTimeout(CronTask *task, TimestampTz currentTime);
 static char* pg_cron_cmdTuples(char *msg);
 static void bgw_generate_returned_message(StringInfoData *display_msg, ErrorData edata);
 static long YbSecondsPassed(TimestampTz startTime, TimestampTz stopTime);
+static void YbCheckLeadership(List *taskList, TimestampTz currentTime);
 
 /* global settings */
 char *CronTableDatabaseName = "yugabyte";
@@ -190,6 +191,14 @@ static const struct config_enum_entry cron_message_level_options[] = {
 	{NULL, 0, false}
 };
 
+/*
+ * In Yugabyte since postgres is running on several nodes we pick a single
+ * node to act as the cron leader. Only this node will run cron jobs.
+ * Once distributed scheduling(#22336) is implemented the leader will schedule
+ * the job and other nodes will execute jobs that have been scheduled on them.
+ */
+bool ybIsLeader = false;
+
 static const char *cron_error_severity(int elevel);
 
 /*
@@ -577,7 +586,9 @@ PgCronLauncherMain(Datum arg)
 	/* Establish signal handlers before unblocking signals. */
 	pqsignal(SIGHUP, pg_cron_sighup);
 	pqsignal(SIGINT, SIG_IGN);
-	pqsignal(SIGTERM, pg_cron_sigterm);
+	/* YB Note: Exit immediately. */
+	pqsignal(SIGTERM, die);
+	pqsignal(SIGQUIT, quickdie);
 
 	/* We're now ready to receive signals */
 	BackgroundWorkerUnblockSignals();
@@ -595,8 +606,10 @@ PgCronLauncherMain(Datum arg)
 	/*
 	 * Mark anything that was in progress before the database restarted as
 	 * failed.
+	 * YB Note: The cron leader will mark pending runs as failed.
 	 */
-	MarkPendingRunsAsFailed();
+	if (!IsYugaByteEnabled())
+		MarkPendingRunsAsFailed();
 
 	/* Determine how many tasks we can run concurrently */
 	if (MaxConnections < MaxRunningTasks)
@@ -646,9 +659,6 @@ PgCronLauncherMain(Datum arg)
 
 	while (!got_sigterm)
 	{
-		/* YB Note: The latest entries in the catalog must be read during every run */
-		if (IsYugaByteEnabled())
-			YBCPgResetCatalogReadTime();
 
 		List *taskList = NIL;
 		TimestampTz currentTime = 0;
@@ -664,21 +674,25 @@ PgCronLauncherMain(Datum arg)
 			CronReloadConfig = false;
 		}
 
+		currentTime = GetCurrentTimestamp();
+		YbCheckLeadership(taskList, currentTime);
+
 		/*
 		 * Both CronReloadConfig and CronJobCacheValid are triggered by SIGHUP.
 		 * ProcessConfigFile should come first, because RefreshTaskHash depends
 		 * on settings that might have changed.
 		 *
-		 * In Yugabyte mode jobs scheduled from a different nodes cannot invalidate
-		 * the cache on the cron leader. So in addition to the regular invalidations
-		 * we RefreshTaskHash every YbJobListRefreshSeconds.
-		 * NOTE: It can take up to YbJobListRefreshSeconds for change to the jobs
-		 * to take effect.
+		 * YB Note:
+		 * Jobs scheduled from a different nodes cannot
+		 * invalidate the cache on the cron leader. So in addition to the
+		 * regular invalidations we RefreshTaskHash every
+		 * YbJobListRefreshSeconds. NOTE: It can take up to
+		 * YbJobListRefreshSeconds for change to the jobs to take effect.
 		 */
-		currentTime = GetCurrentTimestamp();
 		if (!CronJobCacheValid ||
-			(IsYugaByteEnabled() &&
-				YbSecondsPassed(ybLastRefreshTime, currentTime) >= YbJobListRefreshSeconds))
+			(IsYugaByteEnabled() && ybIsLeader &&
+			 YbSecondsPassed(ybLastRefreshTime, currentTime) >=
+				 YbJobListRefreshSeconds))
 		{
 			ybLastRefreshTime = currentTime;
 			RefreshTaskHash();
@@ -689,6 +703,9 @@ PgCronLauncherMain(Datum arg)
 
 		StartAllPendingRuns(taskList, currentTime);
 
+		/* YB Note: Check again since we could have lost leadership. */
+		YbCheckLeadership(taskList, currentTime);
+
 		WaitForCronTasks(taskList);
 		ManageCronTasks(taskList, currentTime);
 
@@ -712,6 +729,23 @@ StartAllPendingRuns(List *taskList, TimestampTz currentTime)
 {
 	static TimestampTz lastMinute = 0;
 
+	/*
+	 * YB Note: Only start jobs if we are the leader.
+	 * Reset lastMinute because otherwise if we go from leader to follower and
+	 * back to leader we would start all the runs while we were the follower.
+	 * If we had two or more leaders in the same minute we would not run the
+	 * task multiple times since we do not run tasks for the first minute of
+	 * leadership.
+	 * Interval jobs do not have this guarantee since their timer starts when we
+	 * become the leader. Non Yugabyte pg_cron has the same behavior when pg
+	 * restarts.
+	 */
+	if (IsYugaByteEnabled() && !ybIsLeader)
+	{
+		lastMinute = 0;
+		return;
+	}
+
 	int minutesPassed = 0;
 	ListCell *taskCell = NULL;
 	ClockProgress clockProgress;
@@ -2081,6 +2115,8 @@ CronBackgroundWorker(Datum main_arg)
 
 	/* handle SIGTERM like regular backend */
 	pqsignal(SIGTERM, die);
+	/* YB Note: Exit immediately. */
+	pqsignal(SIGQUIT, quickdie);
 	BackgroundWorkerUnblockSignals();
 
 	/* Set up a memory context and resource owner. */
@@ -2397,3 +2433,57 @@ YbSecondsPassed(TimestampTz startTime, TimestampTz stopTime)
 
 	return secondsPassed;
 }
+
+static void
+YbCheckLeadership(List *taskList, TimestampTz currentTime)
+{
+	if (!IsYugaByteEnabled())
+		return;
+
+	if (YBCIsCronLeader())
+	{
+		if (!ybIsLeader)
+		{
+			ereport(LOG, (errmsg("pg_cron switching to leader mode")));
+			ybIsLeader = true;
+
+			/*
+			 * The first time we detect that we are a leader, mark any inflight
+			 * job started by the previous leader as failed as that node might
+			 * still be alive. It will mark the job as completed and stop
+			 * scheduling new runs. This inconsistency will go away once
+			 * distributed job scheduling (#22336) is implemented.
+			 */
+			MarkPendingRunsAsFailed();
+
+			/*
+			 * Reset the start time used for interval job. Check comment in
+			 * GetCronTask.
+			 */
+			ListCell *taskCell = NULL;
+			foreach (taskCell, taskList)
+			{
+				CronTask *task = (CronTask *) lfirst(taskCell);
+				task->lastStartTime = currentTime;
+			}
+
+			CronJobCacheValid = false;
+		}
+	}
+	else if (ybIsLeader)
+	{
+		ereport(LOG, (errmsg("pg_cron switching to idle mode")));
+		ybIsLeader = false;
+
+		/*
+		 * Reset the pending run counts so that we do not start tasks that we
+		 * marked as pending while we were the leader.
+		 */
+		ListCell *taskCell = NULL;
+		foreach(taskCell, taskList)
+		{
+			CronTask *task = (CronTask *) lfirst(taskCell);
+			task->pendingRunCount = 0;
+		}
+	}
+}
diff --git a/src/postgres/third-party-extensions/pg_cron/src/task_states.c b/src/postgres/third-party-extensions/pg_cron/src/task_states.c
index 34077c62c7..f000a4f804 100644
--- a/src/postgres/third-party-extensions/pg_cron/src/task_states.c
+++ b/src/postgres/third-party-extensions/pg_cron/src/task_states.c
@@ -21,6 +21,9 @@
 #include "utils/hsearch.h"
 #include "utils/memutils.h"
 
+/* YB includes */
+#include "pg_yb_utils.h"
+#include "catalog/yb_catalog_version.h"
 
 /* forward declarations */
 static HTAB * CreateCronTaskHash(void);
@@ -81,6 +84,13 @@ CreateCronTaskHash(void)
 void
 RefreshTaskHash(void)
 {
+	/* YB Note: Always read the latest entries in the catalog */
+	if (IsYugaByteEnabled())
+	{
+		YBCPgResetCatalogReadTime();
+		YbUpdateCatalogCacheVersion(YbGetMasterCatalogVersion());
+	}
+
 	List *jobList = NIL;
 	ListCell *jobCell = NULL;
 	CronTask *task = NULL;
diff --git a/src/postgres/third-party-extensions/pg_cron/yb_schedule b/src/postgres/third-party-extensions/pg_cron/yb_schedule
index f9be60676a..96da7294ea 100644
--- a/src/postgres/third-party-extensions/pg_cron/yb_schedule
+++ b/src/postgres/third-party-extensions/pg_cron/yb_schedule
@@ -1,3 +1,4 @@
 # third-party-extensions/pg_cron/yb_schedule
 
 test: pg_cron-test
+test: yb_pg_cron-test
diff --git a/src/yb/integration-tests/CMakeLists.txt b/src/yb/integration-tests/CMakeLists.txt
index 78cf24e136..15f9389cbc 100644
--- a/src/yb/integration-tests/CMakeLists.txt
+++ b/src/yb/integration-tests/CMakeLists.txt
@@ -220,6 +220,7 @@ ADD_YB_TEST(cdcsdk_tablet_split-test)
 ADD_YB_TEST(cdcsdk_consistent_snapshot-test)
 ADD_YB_TEST(transaction-test)
 ADD_YB_TEST(encryption-test)
+ADD_YB_TEST(pg_cron-test)
 ADD_YB_TEST(secure_connection_test)
 ADD_YB_TEST(xcluster/xcluster_consistency-test)
 ADD_YB_TEST(xcluster/xcluster_db_scoped-test)
diff --git a/src/yb/integration-tests/external_mini_cluster.cc b/src/yb/integration-tests/external_mini_cluster.cc
index 98bbd87189..dd50fe4400 100644
--- a/src/yb/integration-tests/external_mini_cluster.cc
+++ b/src/yb/integration-tests/external_mini_cluster.cc
@@ -101,6 +101,7 @@
 #include "yb/util/test_util.h"
 #include "yb/util/tsan_util.h"
 #include "yb/util/flags.h"
+#include "yb/yql/pgwrapper/libpq_utils.h"
 
 #define YB_FORWARD_FLAG(flag_name) \
   "--" BOOST_PP_STRINGIZE(flag_name) "="s + FlagToString(BOOST_PP_CAT(FLAGS_, flag_name))
@@ -2089,6 +2090,18 @@ Status ExternalMiniCluster::WaitForLoadBalancerToBecomeIdle(
   return Status::OK();
 }
 
+Result<pgwrapper::PGConn> ExternalMiniCluster::ConnectToDB(
+    const std::string& db_name, std::optional<size_t> node_index, bool simple_query_protocol) {
+  if (!node_index) {
+    node_index = RandomUniformInt<size_t>(0, num_tablet_servers() - 1);
+  }
+
+  auto* ts = tablet_server(*node_index);
+  return pgwrapper::PGConnBuilder(
+             {.host = ts->bind_host(), .port = ts->pgsql_rpc_port(), .dbname = db_name})
+      .Connect(simple_query_protocol);
+}
+
 //------------------------------------------------------------
 // ExternalDaemon
 //------------------------------------------------------------
diff --git a/src/yb/integration-tests/external_mini_cluster.h b/src/yb/integration-tests/external_mini_cluster.h
index b340bc71a8..2f74d9ee94 100644
--- a/src/yb/integration-tests/external_mini_cluster.h
+++ b/src/yb/integration-tests/external_mini_cluster.h
@@ -90,6 +90,10 @@ class OpIdPB;
 class NodeInstancePB;
 class Subprocess;
 
+namespace pgwrapper {
+class PGConn;
+}  // namespace pgwrapper
+
 namespace rpc {
 class SecureContext;
 }
@@ -541,6 +545,12 @@ class ExternalMiniCluster : public MiniClusterBase {
   Status WaitForLoadBalancerToBecomeIdle(
       const std::unique_ptr<yb::client::YBClient>& client, MonoDelta timeout);
 
+  // Create a PG connection to the given database. If node_index is not set, a random node is
+  // chosen.
+  Result<pgwrapper::PGConn> ConnectToDB(
+      const std::string& db_name = "yugabyte", std::optional<size_t> node_index = std::nullopt,
+      bool simple_query_protocol = false);
+
  protected:
   FRIEND_TEST(MasterFailoverTest, TestKillAnyMaster);
 
diff --git a/src/yb/integration-tests/pg_cron-test.cc b/src/yb/integration-tests/pg_cron-test.cc
new file mode 100644
index 0000000000..c591360c10
--- /dev/null
+++ b/src/yb/integration-tests/pg_cron-test.cc
@@ -0,0 +1,152 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include <chrono>
+
+#include "yb/integration-tests/external_mini_cluster.h"
+#include "yb/tserver/tablet_server.h"
+#include "yb/yql/pgwrapper/pg_mini_test_base.h"
+
+using namespace std::chrono_literals;
+
+namespace yb {
+
+constexpr auto kTableName = "tbl1";
+constexpr auto kDefaultJobName = "Job1";
+constexpr auto kobListRefreshInterval = 10;
+
+class PgCronTest : public MiniClusterTestWithClient<ExternalMiniCluster> {
+ public:
+  PgCronTest() = default;
+
+  void SetUp() override {
+    YBMiniClusterTestBase<ExternalMiniCluster>::SetUp();
+    ExternalMiniClusterOptions opts;
+    opts.num_tablet_servers = 3;
+    opts.replication_factor = 3;
+    opts.num_masters = 1;
+    opts.enable_ysql = true;
+
+    opts.extra_tserver_flags.push_back("--vmodule=pg_cron*=4");
+    opts.extra_tserver_flags.push_back("--TEST_enable_pg_cron=true");
+    opts.extra_tserver_flags.push_back(
+        Format("--ysql_pg_conf_csv=cron.yb_job_list_refresh_interval=$0", kobListRefreshInterval));
+
+    cluster_.reset(new ExternalMiniCluster(opts));
+    ASSERT_OK(cluster_->Start());
+    ASSERT_OK(MiniClusterTestWithClient<ExternalMiniCluster>::CreateClient());
+
+    conn_ = std::make_unique<pgwrapper::PGConn>(ASSERT_RESULT(Connect()));
+
+    ASSERT_OK(CreateTable());
+    ASSERT_OK(CreateCronExtension());
+
+    // Make the first tserver the cron leader. #22360 will make this unnecessary.
+    ASSERT_OK(cluster_->SetFlag(cluster_->tablet_server(0), "TEST_is_ysql_cron_leader", "true"));
+  }
+
+  Result<pgwrapper::PGConn> Connect() { return cluster_->ConnectToDB(); }
+
+  Status CreateTable(const std::string& table_name = kTableName) {
+    return conn_->Execute(Format(
+        "CREATE TABLE $0 (a INT, node TEXT, insert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP)",
+        table_name));
+  }
+
+  Status CreateCronExtension() { return conn_->Execute("CREATE EXTENSION pg_cron"); }
+
+  Result<int64_t> Schedule1SecInsertJob(const std::string& job_name = kDefaultJobName) {
+    auto insert_query =
+        Format("INSERT INTO $0(a, node) VALUES (1, host(inet_server_addr()))", kTableName);
+    return ScheduleJob(job_name, "1 second", insert_query);
+  }
+
+  // Returns the JobId
+  Result<int64_t> ScheduleJob(
+      const std::string& job_name, const std::string& schedule, const std::string& query) {
+    LOG(INFO) << Format(
+        "Scheduling job $0 with schedule $1 and query $2", job_name, schedule, query);
+    return conn_->FetchRow<int64_t>(
+        Format("SELECT cron.schedule('$0', '$1', '$2')", job_name, schedule, query));
+  }
+
+  Status UnscheduleJob(const int64_t& job_id) {
+    LOG(INFO) << Format("Unscheduling job $0", job_id);
+
+    // Returns a bool indicating if the job was unscheduled.
+    auto result =
+        VERIFY_RESULT(conn_->FetchRow<bool>(Format("SELECT cron.unschedule($0)", job_id)));
+    SCHECK(result, IllegalState, "Failed to unschedule job");
+    return Status::OK();
+  }
+
+  Result<int64_t> GetRowCount(const std::string& table_name = kTableName) {
+    return conn_->FetchRow<int64_t>(Format("SELECT COUNT(*) FROM $0", table_name));
+  }
+
+  std::unique_ptr<pgwrapper::PGConn> conn_;
+  TabletId tablet_id_;
+};
+
+// Make sure cron jobs are run only once in the provided interval.
+TEST_F(PgCronTest, AtMostOnceTest) {
+  // Schedule a 1sec job.
+  const auto job_id = ASSERT_RESULT(Schedule1SecInsertJob());
+
+  // Wait for the job to get picked up and run for a while.
+  const auto default_sleep_sec = 10;
+  const auto buffer_sec = 3;
+  const auto sleep_time_sec = kobListRefreshInterval + default_sleep_sec + buffer_sec;
+  SleepFor(sleep_time_sec * 1s);
+
+  // Stop the job.
+  ASSERT_OK(UnscheduleJob(job_id));
+  SleepFor(kobListRefreshInterval * 1s);
+
+  // Make sure we inserted the correct number of rows.
+  auto row_count = ASSERT_RESULT(GetRowCount());
+  ASSERT_GE(row_count, default_sleep_sec);
+  // Max rows is the total amount of time we slept.
+  ASSERT_LE(row_count, sleep_time_sec + kobListRefreshInterval);
+
+  // Wait a little bit longer to make sure job is still not running.
+  SleepFor(default_sleep_sec * 1s);
+  auto row_count2 = ASSERT_RESULT(GetRowCount());
+  ASSERT_EQ(row_count, row_count2);
+
+  // Make sure it was cron that inserted all the rows.
+  auto job_run_count =
+      ASSERT_RESULT(conn_->FetchRow<int64_t>("SELECT COUNT(*) FROM cron.job_run_details"));
+  ASSERT_EQ(row_count, job_run_count);
+}
+
+TEST_F(PgCronTest, PerMinuteTask) {
+  auto insert_query =
+      Format("INSERT INTO $0(a, node) VALUES (1, host(inet_server_addr()))", kTableName);
+  ASSERT_OK(ScheduleJob("job1", "* * * * *", insert_query));
+
+  // Wait 2 minutes.
+  const auto default_sleep_min = 2;
+  const auto buffer_sec = 3;
+  const auto sleep_time_sec = kobListRefreshInterval + (60 * default_sleep_min) + buffer_sec;
+  SleepFor(sleep_time_sec * 1s);
+
+  // We should have (default_sleep_min, default_sleep_min+1) rows.
+  auto row_count = ASSERT_RESULT(GetRowCount());
+  ASSERT_GE(row_count, default_sleep_min);
+  ASSERT_LE(row_count, default_sleep_min + 1);
+}
+
+TEST_F(PgCronTest, RecreatejobWithSameName) {}
+
+}  // namespace yb
diff --git a/src/yb/tserver/tablet_server.cc b/src/yb/tserver/tablet_server.cc
index 6853bc0f24..7a3ad66fa8 100644
--- a/src/yb/tserver/tablet_server.cc
+++ b/src/yb/tserver/tablet_server.cc
@@ -230,6 +230,9 @@ DEFINE_RUNTIME_uint32(ysql_min_new_version_ignored_count, 10,
     "Minimum consecutive number of times that a tserver is allowed to ignore an older catalog "
     "version that is retrieved from a tserver-master heartbeat response.");
 
+DEFINE_test_flag(
+    bool, is_ysql_cron_leader, false, "Make the current node run as the pg_cron leader");
+
 namespace yb::tserver {
 
 namespace {
@@ -513,6 +516,12 @@ Status TabletServer::Init() {
 
   shared_object().SetTserverUuid(fs_manager()->uuid());
 
+  TEST_is_cron_leader_callback_ = VERIFY_RESULT(
+      RegisterFlagUpdateCallback(&FLAGS_TEST_is_ysql_cron_leader, "is_ysql_cron_leader", [this] {
+        LOG(INFO) << "Setting the current node as the pg_cron leader";
+        TEST_SetIsCronLeader(FLAGS_TEST_is_ysql_cron_leader);
+      }));
+
   return Status::OK();
 }
 
@@ -670,6 +679,8 @@ void TabletServer::Shutdown() {
 
   bool expected = true;
   if (initted_.compare_exchange_strong(expected, false, std::memory_order_acq_rel)) {
+    TEST_is_cron_leader_callback_.Deregister();
+
     auto xcluster_consumer = GetXClusterConsumer();
     if (xcluster_consumer) {
       xcluster_consumer->Shutdown();
@@ -1450,4 +1461,8 @@ Result<std::vector<tablet::TabletStatusPB>> TabletServer::GetLocalTabletsMetadat
   return result;
 }
 
+void TabletServer::TEST_SetIsCronLeader(bool is_cron_leader) {
+  SharedObject().SetIsCronLeader(is_cron_leader);
+}
+
 }  // namespace yb::tserver
diff --git a/src/yb/tserver/tablet_server.h b/src/yb/tserver/tablet_server.h
index b61c1a748e..938c0748cb 100644
--- a/src/yb/tserver/tablet_server.h
+++ b/src/yb/tserver/tablet_server.h
@@ -356,6 +356,8 @@ class TabletServer : public DbServerBase, public TabletServerIf {
 
   Result<std::vector<tablet::TabletStatusPB>> GetLocalTabletsMetadata() const override;
 
+  void TEST_SetIsCronLeader(bool is_cron_leader);
+
  protected:
   virtual Status RegisterServices();
 
@@ -497,6 +499,8 @@ class TabletServer : public DbServerBase, public TabletServerIf {
   std::atomic<yb::server::RpcAndWebServerBase*> cql_server_{nullptr};
   std::atomic<yb::server::YCQLStatementStatsProvider*> cql_stmt_provider_{nullptr};
 
+  FlagCallbackRegistration TEST_is_cron_leader_callback_;
+
   DISALLOW_COPY_AND_ASSIGN(TabletServer);
 };
 
diff --git a/src/yb/tserver/tserver_shared_mem.h b/src/yb/tserver/tserver_shared_mem.h
index 999f19e859..ab7bf17495 100644
--- a/src/yb/tserver/tserver_shared_mem.h
+++ b/src/yb/tserver/tserver_shared_mem.h
@@ -110,6 +110,10 @@ class TServerSharedData {
     return tserver_uuid_;
   }
 
+  void SetIsCronLeader(bool is_leader) { is_cron_leader_ = is_leader; }
+
+  bool IsCronLeader() const { return is_cron_leader_; }
+
  private:
   // Endpoint that should be used by local processes to access this tserver.
   Endpoint endpoint_;
@@ -122,6 +126,8 @@ class TServerSharedData {
   std::atomic<uint64_t> db_catalog_versions_[kMaxNumDbCatalogVersions] = {0};
   // See same variable comments in CatalogManager.
   std::atomic<std::optional<bool>> catalog_version_table_in_perdb_mode_{std::nullopt};
+
+  bool is_cron_leader_ = false;
 };
 
 YB_STRONGLY_TYPED_BOOL(Create);
diff --git a/src/yb/yql/pggate/pggate.cc b/src/yb/yql/pggate/pggate.cc
index 1157d859ad..d0108193bd 100644
--- a/src/yb/yql/pggate/pggate.cc
+++ b/src/yb/yql/pggate/pggate.cc
@@ -2459,4 +2459,6 @@ void PgApiImpl::ClearSessionState() {
   pg_session_->explicit_row_lock_buffer().Clear();
 }
 
+bool PgApiImpl::IsCronLeader() const { return tserver_shared_object_->IsCronLeader(); }
+
 } // namespace yb::pggate
diff --git a/src/yb/yql/pggate/pggate.h b/src/yb/yql/pggate/pggate.h
index 092b24d01e..f709342061 100644
--- a/src/yb/yql/pggate/pggate.h
+++ b/src/yb/yql/pggate/pggate.h
@@ -801,6 +801,8 @@ class PgApiImpl {
 
   Result<tserver::PgTabletsMetadataResponsePB> TabletsMetadata();
 
+  bool IsCronLeader() const;
+
  private:
   void ClearSessionState();
 
diff --git a/src/yb/yql/pggate/ybc_pggate.cc b/src/yb/yql/pggate/ybc_pggate.cc
index 505da8ec02..f703668c6f 100644
--- a/src/yb/yql/pggate/ybc_pggate.cc
+++ b/src/yb/yql/pggate/ybc_pggate.cc
@@ -2579,6 +2579,8 @@ YBCStatus YBCLocalTablets(YBCPgTabletsDescriptor** tablets, size_t* count) {
   return YBCStatusOK();
 }
 
+bool YBCIsCronLeader() { return pgapi->IsCronLeader(); }
+
 } // extern "C"
 
 } // namespace yb::pggate
diff --git a/src/yb/yql/pggate/ybc_pggate.h b/src/yb/yql/pggate/ybc_pggate.h
index 4d03dd9820..d5aa3957ea 100644
--- a/src/yb/yql/pggate/ybc_pggate.h
+++ b/src/yb/yql/pggate/ybc_pggate.h
@@ -114,6 +114,9 @@ YBCStatus YBCGetHeapConsumption(YbTcmallocStats *desc);
 // Validate the JWT based on the options including the identity matching based on the identity map.
 YBCStatus YBCValidateJWT(const char *token, const YBCPgJwtAuthOptions *options);
 
+// Is this node acting as the pg_cron leader?
+bool YBCIsCronLeader();
+
 //--------------------------------------------------------------------------------------------------
 // YB Bitmap Scan Operations
 //--------------------------------------------------------------------------------------------------
