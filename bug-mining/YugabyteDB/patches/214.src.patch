diff --git a/pg15_tests/test_upgrade.sh b/pg15_tests/test_upgrade.sh
index c751eed09e..6ba09a4e9b 100755
--- a/pg15_tests/test_upgrade.sh
+++ b/pg15_tests/test_upgrade.sh
@@ -33,7 +33,6 @@ restart_node_2_in_pg15
 
 # Demonstrate simultaneous access for DMLs before the upgrade has been finalized. (DDLs are not
 # allowed, and rollback to PG11 is still possible.)
-# YB_TODO: Test that DDLs are prohibited when the functionality is implemented.
 
 # Insert from PG15
 diff <(ysqlsh 2 <<EOT | sed 's/ *$//'
diff --git a/src/postgres/src/common/pg_yb_common.c b/src/postgres/src/common/pg_yb_common.c
index 122ef9d40c..2d41a98ab2 100644
--- a/src/postgres/src/common/pg_yb_common.c
+++ b/src/postgres/src/common/pg_yb_common.c
@@ -240,13 +240,6 @@ YBColocateDatabaseByDefault()
 	return cached_value;
 }
 
-bool
-YBIsMajorUpgradeInitDb()
-{
-	return YBCIsEnvVarTrueWithDefault("YB_PG_MAJOR_UPGRADE_INITDB",
-									  false /* default_value */);
-}
-
 Oid YBGetDatabaseOidFromEnv(const char *database_name)
 {
 	char *env_var = psprintf("YB_DATABASE_OID_%s", database_name);
diff --git a/src/postgres/src/include/common/pg_yb_common.h b/src/postgres/src/include/common/pg_yb_common.h
index d28a0110d8..8012463974 100644
--- a/src/postgres/src/include/common/pg_yb_common.h
+++ b/src/postgres/src/include/common/pg_yb_common.h
@@ -151,11 +151,6 @@ extern const bool kTestOnlyUseOSDefaultCollation;
  */
 extern bool YBColocateDatabaseByDefault();
 
-/**
- * Returns whether we're doing an initdb for a ysql major upgrade.
- */
-extern bool YBIsMajorUpgradeInitDb();
-
 /**
  * Returns the OID for database_name from the environment, if it exists and is
  * valid. Otherwise, returns InvalidOid.
diff --git a/src/postgres/yb-extensions/yb_pg_metrics/yb_pg_metrics.c b/src/postgres/yb-extensions/yb_pg_metrics/yb_pg_metrics.c
index 7dcc77ff51..8a9a8b0738 100644
--- a/src/postgres/yb-extensions/yb_pg_metrics/yb_pg_metrics.c
+++ b/src/postgres/yb-extensions/yb_pg_metrics/yb_pg_metrics.c
@@ -770,28 +770,32 @@ _PG_init(void)
 
 	BackgroundWorker worker;
 
-	/* Registering the YSQL webserver as a background worker */
-	MemSet(&worker, 0, sizeof(BackgroundWorker));
-	strcpy(worker.bgw_name, "YSQL webserver");
-	worker.bgw_flags = BGWORKER_SHMEM_ACCESS;
-	worker.bgw_start_time = BgWorkerStart_PostmasterStart;
-	/* Value of 1 allows the background worker for webserver to restart */
-	worker.bgw_restart_time = 1;
-	worker.bgw_main_arg = (Datum) 0;
-	strcpy(worker.bgw_library_name, "yb_pg_metrics");
-	strcpy(worker.bgw_function_name, "webserver_worker_main");
-	worker.bgw_notify_pid = 0;
-	if (getenv("FLAGS_yb_webserver_oom_score_adj") != NULL)
-		strncpy(worker.bgw_oom_score_adj,
-				getenv("FLAGS_yb_webserver_oom_score_adj"),
-				BGW_MAXLEN);
-
-	RegisterBackgroundWorker(&worker);
-	/*
-	 * Set the value of the hooks.
-	 */
+	if (!IsBinaryUpgrade)
+	{
+		/* Registering the YSQL webserver as a background worker */
+		MemSet(&worker, 0, sizeof(BackgroundWorker));
+		strcpy(worker.bgw_name, "YSQL webserver");
+		worker.bgw_flags = BGWORKER_SHMEM_ACCESS;
+		worker.bgw_start_time = BgWorkerStart_PostmasterStart;
+		/* Value of 1 allows the background worker for webserver to restart */
+		worker.bgw_restart_time = 1;
+		worker.bgw_main_arg = (Datum) 0;
+		strcpy(worker.bgw_library_name, "yb_pg_metrics");
+		strcpy(worker.bgw_function_name, "webserver_worker_main");
+		worker.bgw_notify_pid = 0;
+		if (getenv("FLAGS_yb_webserver_oom_score_adj") != NULL)
+			strncpy(worker.bgw_oom_score_adj,
+					getenv("FLAGS_yb_webserver_oom_score_adj"),
+					BGW_MAXLEN);
+
+		RegisterBackgroundWorker(&worker);
+	}
+
+  /*
+   * Set the value of the hooks.
+   */
 
-	prev_shmem_request_hook = shmem_request_hook;
+  prev_shmem_request_hook = shmem_request_hook;
 	shmem_request_hook = ybpgm_shmem_request;
 
 	prev_shmem_startup_hook = shmem_startup_hook;
diff --git a/src/yb/common/entity_ids.cc b/src/yb/common/entity_ids.cc
index 73fe5a0b8a..a7b49b2d88 100644
--- a/src/yb/common/entity_ids.cc
+++ b/src/yb/common/entity_ids.cc
@@ -33,10 +33,8 @@ namespace {
 // Dev Note: When the major catalog version changes, meaning, for the YugabyteDB version that uses
 // PG17+ for the YSQL layer, update kPgPreviousUuidVersion to kPgCurrentUuidVersion, and increase
 // kPgCurrentUuidVersion by 1.
-// PG11
-constexpr uint8_t kPgPreviousUuidVersion = 0;
-// PG15
-constexpr uint8_t kPgCurrentUuidVersion = 1;
+constexpr uint8_t kPgPreviousUuidVersion = 0;  // PG11
+constexpr uint8_t kPgCurrentUuidVersion = 1;   // PG15
 
 }  // namespace
 
@@ -55,7 +53,7 @@ const TableId kPgProcTableId = GetPgsqlTableId(kTemplate1Oid, kPgProcTableOid);
 const TableId kPgYbCatalogVersionTableId =
     GetPgsqlTableId(kTemplate1Oid, kPgYbCatalogVersionTableOid);
 const TableId kPgYbCatalogVersionTableIdPriorVersion =
-    GetPgsqlTableIdPriorVersion(kTemplate1Oid, kPgYbCatalogVersionTableOid);
+    GetPriorVersionYsqlCatalogTableId(kTemplate1Oid, kPgYbCatalogVersionTableOid);
 const TableId kPgTablespaceTableId =
     GetPgsqlTableId(kTemplate1Oid, kPgTablespaceTableOid);
 const TableId kPgSequencesDataTableId =
@@ -69,8 +67,6 @@ const string kPgSequencesDataNamespaceId =
 
 namespace {
 
-YB_STRONGLY_TYPED_BOOL(IsCurrentVersion);
-
 // Layout of Postgres database and table 4-byte oids in a YugaByte 16-byte table UUID:
 //
 // +-----------------------------------------------------------------------------------------------+
@@ -104,6 +100,15 @@ void UuidSetTableIds(const uint32_t table_oid, uuid* id) {
   id->data[15] = table_oid & 0xFF;
 }
 
+inline void UuidSetPgVersion(uuid& id, bool is_current_version) {
+  id.data[9] = is_current_version ? kPgCurrentUuidVersion : kPgPreviousUuidVersion;
+}
+
+inline bool IsCurrentPgVersion(const TableId& table_id) {
+  const auto binary_id = a2b_hex(table_id);
+  return binary_id[9] == kPgCurrentUuidVersion;
+}
+
 std::string UuidToString(uuid* id) {
   // Set variant that is stored in octet 7, which is index 8, since indexes count backwards.
   // Variant must be 0b10xxxxxx for RFC 4122 UUID variant 1.
@@ -118,24 +123,36 @@ std::string UuidToString(uuid* id) {
 }
 
 TableId GetPgsqlTableIdInternal(
-    const uint32_t database_oid, const uint32_t table_oid, IsCurrentVersion is_current_version) {
+    const uint32_t database_oid, const uint32_t table_oid, bool is_current_version) {
   uuid id = boost::uuids::nil_uuid();
   UuidSetDatabaseId(database_oid, &id);
 
   // For catalog tables, we need to set the correct version in id.data[9], which is "pgv" in the
   // above diagram. Note that normal object IDs are versionless, always id.data[9] == 0.
   if (table_oid < kPgFirstNormalObjectId) {
-    if (is_current_version) {
-      id.data[9] = kPgCurrentUuidVersion;
-    } else {
-      id.data[9] = kPgPreviousUuidVersion;
-    }
+    UuidSetPgVersion(id, is_current_version);
+  } else {
+    LOG_IF(DFATAL, !is_current_version) << "User table IDs do not have prior versions.";
   }
 
   UuidSetTableIds(table_oid, &id);
   return UuidToString(&id);
 }
 
+bool IsYsqlCatalogTable(const TableId& table_id) {
+  if (!IsPgsqlId(table_id)) {
+    return false;
+  }
+  Result<uint32_t> oid_res = GetPgsqlTableOid(table_id);
+  if (!oid_res.ok()) {
+    YB_LOG_EVERY_N_SECS(WARNING, 5)
+        << "Invalid PostgreSQL table id " << table_id << ": " << oid_res.status();
+    return false;
+  }
+
+  return *oid_res < kPgFirstNormalObjectId;
+}
+
 } // namespace
 
 NamespaceId GetPgsqlNamespaceId(const uint32_t database_oid) {
@@ -145,11 +162,7 @@ NamespaceId GetPgsqlNamespaceId(const uint32_t database_oid) {
 }
 
 TableId GetPgsqlTableId(const uint32_t database_oid, const uint32_t table_oid) {
-  return GetPgsqlTableIdInternal(database_oid, table_oid, IsCurrentVersion::kTrue);
-}
-
-TableId GetPgsqlTableIdPriorVersion(const uint32_t database_oid, const uint32_t table_oid) {
-  return GetPgsqlTableIdInternal(database_oid, table_oid, IsCurrentVersion::kFalse);
+  return GetPgsqlTableIdInternal(database_oid, table_oid, /*is_current_version=*/true);
 }
 
 TablegroupId GetPgsqlTablegroupId(const uint32_t database_oid, const uint32_t tablegroup_oid) {
@@ -231,29 +244,24 @@ Result<uint32_t> GetPgsqlTablespaceOid(const TablespaceId& tablespace_id) {
   return GetPgsqlOid(tablespace_id, 0, "tablespace id");
 }
 
-bool IsPriorVersionCatalogId(const TableId& hex_id) {
-  if (!IsPgsqlId(hex_id)) {
-    return false;
-  }
-  Result<uint32_t> res_oid = GetPgsqlTableOid(hex_id);
-  if (!res_oid.ok()) {
+TableId GetPriorVersionYsqlCatalogTableId(const uint32_t database_oid, const uint32_t table_oid) {
+  return GetPgsqlTableIdInternal(database_oid, table_oid, /*is_current_version=*/false);
+}
+
+bool IsPriorVersionYsqlCatalogTable(const TableId& table_id) {
+  if (!IsYsqlCatalogTable(table_id)) {
     return false;
   }
-  uint32_t oid = *res_oid;
-  std::string id = a2b_hex(hex_id);
-  // Dev Note: When the major catalog version changes, meaning, for the YugabyteDB version that uses
-  // PG17+ for the YSQL layer, the check for oid being less than kPgFirstNormalObjectId will no
-  // longer be necessary because user tables will keep version 0 forever and the previous version
-  // will be > 0.
-  return id[9] == kPgPreviousUuidVersion && oid < kPgFirstNormalObjectId;
+
+  return !IsCurrentPgVersion(table_id);
 }
 
-bool IsCurrentVersionCatalogId(const TableId& hex_id) {
-  if (!IsPgsqlId(hex_id)) {
+bool IsCurrentVersionYsqlCatalogTable(const TableId& table_id) {
+  if (!IsYsqlCatalogTable(table_id)) {
     return false;
   }
-  std::string id = a2b_hex(hex_id);
-  return id[9] == kPgCurrentUuidVersion;
+
+  return IsCurrentPgVersion(table_id);
 }
 
 namespace xrepl {
diff --git a/src/yb/common/entity_ids.h b/src/yb/common/entity_ids.h
index bc5535ca7c..5a716c0c9a 100644
--- a/src/yb/common/entity_ids.h
+++ b/src/yb/common/entity_ids.h
@@ -52,7 +52,6 @@ NamespaceId GetPgsqlNamespaceId(uint32_t database_oid);
 
 // Get YB table id for a Postgres table.
 TableId GetPgsqlTableId(uint32_t database_oid, uint32_t table_oid);
-TableId GetPgsqlTableIdPriorVersion(uint32_t database_oid, uint32_t table_oid);
 
 // Get YB tablegroup id for a Postgres tablegroup.
 TablegroupId GetPgsqlTablegroupId(uint32_t database_oid, uint32_t tablegroup_oid);
@@ -72,12 +71,15 @@ Result<uint32_t> GetPgsqlDatabaseOidByTableId(const TableId& table_id);
 Result<uint32_t> GetPgsqlDatabaseOidByTablegroupId(const TablegroupId& tablegroup_id);
 Result<uint32_t> GetPgsqlTablespaceOid(const TablespaceId& tablespace_id);
 
-// Called with any table UUID, is it a catalog ID for the prior version (pre-ysql major catalog
-// upgrade)? All other cases return false.
-bool IsPriorVersionCatalogId(const TableId& id);
+// NOTE: Only catalog table oids are allowed.
+TableId GetPriorVersionYsqlCatalogTableId(uint32_t database_oid, uint32_t table_oid);
 
-// Called with any table UUID, is it a catalog ID for the current version? All other cases return
-// false.
-bool IsCurrentVersionCatalogId(const TableId& id);
+// If this is a YSQL catalog table, then is it the previous version?
+// Returns false for user tables.
+bool IsPriorVersionYsqlCatalogTable(const TableId& table_id);
+
+// If this is a YSQL catalog table, then is it the current version?
+// Returns false for user tables.
+bool IsCurrentVersionYsqlCatalogTable(const TableId& table_id);
 
 }  // namespace yb
diff --git a/src/yb/integration-tests/CMakeLists.txt b/src/yb/integration-tests/CMakeLists.txt
index 7a6683e1bd..28d2096498 100644
--- a/src/yb/integration-tests/CMakeLists.txt
+++ b/src/yb/integration-tests/CMakeLists.txt
@@ -267,6 +267,7 @@ ADD_YB_TEST(upgrade-tests/basic_upgrade-test)
 ADD_YB_TEST(upgrade-tests/pg15_upgrade-test)
 ADD_YB_TEST(upgrade-tests/pg15_upgrade_pgregress-test)
 ADD_YB_TEST(upgrade-tests/ysql_major_upgrade_rpcs-test)
+ADD_YB_TEST(upgrade-tests/ysql_major_upgrade_ddl_blocking-test)
 
 set(YB_TEST_LINK_LIBS_SAVED ${YB_TEST_LINK_LIBS})
 set(YB_TEST_LINK_LIBS ${YB_TEST_LINK_LIBS} cassandra)
diff --git a/src/yb/integration-tests/upgrade-tests/builds.xml b/src/yb/integration-tests/upgrade-tests/builds.xml
index e3f9d0c6e0..e3f44a6c3d 100644
--- a/src/yb/integration-tests/upgrade-tests/builds.xml
+++ b/src/yb/integration-tests/upgrade-tests/builds.xml
@@ -57,6 +57,21 @@ NOTE:
       https://s3.us-west-2.amazonaws.com/uploads.dev.yugabyte.com/local-provider-test/2024.2.0.0-b58/yugabyte-2024.2.0.0-d78199a0d53b4ab2bd86e6805a46a38fad783ba2-release-clang-darwin-arm64.tar.gz
     </darwin_release_arm64>
   </build>
+  <build version="2024.2.1.0">
+    <build_number>b116</build_number>
+    <linux_debug_x86>
+      https://s3.us-west-2.amazonaws.com/uploads.dev.yugabyte.com/local-provider-test/2024.2.1.0-b116/yugabyte-2024.2.1.0-e1f9880f523ef6b5f3563ec7c6061319e826b74a-debug-clang17-centos-x86_64.tar.gz
+    </linux_debug_x86>
+    <linux_release_x86>
+      https://s3.us-west-2.amazonaws.com/uploads.dev.yugabyte.com/local-provider-test/2024.2.1.0-b116/yugabyte-2024.2.1.0-e1f9880f523ef6b5f3563ec7c6061319e826b74a-release-clang17-centos-x86_64.tar.gz
+    </linux_release_x86>
+    <darwin_debug_arm64>
+      https://s3.us-west-2.amazonaws.com/uploads.dev.yugabyte.com/local-provider-test/2024.2.1.0-b116/yugabyte-2024.2.1.0-ef5232e8f428fba9d52c6cc2002d46ffd79ab999-debug-clang-darwin-arm64.tar.gz
+    </darwin_debug_arm64>
+    <darwin_release_arm64>
+      https://s3.us-west-2.amazonaws.com/uploads.dev.yugabyte.com/local-provider-test/2024.2.1.0-b116/yugabyte-2024.2.1.0-ef5232e8f428fba9d52c6cc2002d46ffd79ab999-release-clang-darwin-arm64.tar.gz
+    </darwin_release_arm64>
+  </build>
   <build version="2.25.0.0">
     <build_number>b340</build_number>
     <linux_debug_x86>
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
index cff4850c96..ca56df989f 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
@@ -780,7 +780,8 @@ TEST_F(Pg15UpgradeTest, Matviews) {
   ASSERT_VECTORS_EQ(result, (decltype(result){1, 2, 3, 4, 5, 6, 7}));
 }
 
-TEST_F(Pg15UpgradeTest, PartitionedTables) {
+// Blocked by #24226
+TEST_F(Pg15UpgradeTest, YB_DISABLE_TEST(PartitionedTables)) {
   // Set up partitioned tables
   ASSERT_OK(ExecuteStatements({
     "CREATE TABLE t_r (v INT, z TEXT, PRIMARY KEY(v ASC)) PARTITION BY RANGE (v)",
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h
index c524c86b32..ffb03056f1 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h
@@ -19,7 +19,7 @@ namespace yb {
 
 class Pg15UpgradeTestBase : public UpgradeTestBase {
  public:
-  Pg15UpgradeTestBase() : UpgradeTestBase(kBuild_2024_2_0_0) {}
+  Pg15UpgradeTestBase() : UpgradeTestBase(kBuild_2024_2_1_0) {}
   virtual ~Pg15UpgradeTestBase() override = default;
 
   void SetUp() override;
diff --git a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
index 8b3a2358ce..00bd40e260 100644
--- a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
+++ b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.cc
@@ -420,6 +420,14 @@ Status UpgradeTestBase::PerformYsqlMajorCatalogUpgrade() {
     return Status::OK();
   }
 
+  RETURN_NOT_OK(StartYsqlMajorCatalogUpgrade());
+
+  return WaitForYsqlMajorCatalogUpgradeToFinish();
+}
+
+Status UpgradeTestBase::StartYsqlMajorCatalogUpgrade() {
+  LOG_WITH_FUNC(INFO) << "Starting ysql major upgrade";
+
   LOG(INFO) << "Running ysql major catalog version upgrade";
 
   master::StartYsqlMajorCatalogUpgradeRequestPB req;
@@ -432,7 +440,7 @@ Status UpgradeTestBase::PerformYsqlMajorCatalogUpgrade() {
     return StatusFromPB(resp.error().status());
   }
 
-  return WaitForYsqlMajorCatalogUpgradeToFinish();
+  return Status::OK();
 }
 
 Status UpgradeTestBase::WaitForYsqlMajorCatalogUpgradeToFinish() {
diff --git a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h
index ec38b6565c..189c440711 100644
--- a/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h
+++ b/src/yb/integration-tests/upgrade-tests/upgrade_test_base.h
@@ -54,6 +54,10 @@ class UpgradeTestBase : public ExternalMiniClusterITestBase {
       ExternalTabletServer& ts, bool wait_for_cluster_to_stabilize = true);
 
   virtual Status PerformYsqlMajorCatalogUpgrade();
+
+  // Only starts the upgrade. WaitForYsqlMajorCatalogUpgradeToFinish should be called to wait for
+  // the upgrade to finish.
+  Status StartYsqlMajorCatalogUpgrade();
   Status WaitForYsqlMajorCatalogUpgradeToFinish();
 
   Status FinalizeUpgrade();
@@ -110,6 +114,7 @@ class UpgradeTestBase : public ExternalMiniClusterITestBase {
 static constexpr auto kBuild_2_20_2_4 = "2.20.2.4";
 static constexpr auto kBuild_2024_1_0_1 = "2024.1.0.1";
 static constexpr auto kBuild_2024_2_0_0 = "2024.2.0.0";
+static constexpr auto kBuild_2024_2_1_0 = "2024.2.1.0";
 static constexpr auto kBuild_2_25_0_0 = "2.25.0.0";
 
 }  // namespace yb
diff --git a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
new file mode 100644
index 0000000000..adb54ba002
--- /dev/null
+++ b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
@@ -0,0 +1,209 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/integration-tests/upgrade-tests/pg15_upgrade_test_base.h"
+
+#include "yb/util/backoff_waiter.h"
+#include "yb/yql/pgwrapper/libpq_utils.h"
+
+using namespace std::chrono_literals;
+using namespace std::placeholders;
+
+#define RUN_DDL_FUNC(func_name) std::bind(&YsqlMajorUpgradeDdlBlockingTest::func_name, this, _1)
+
+YB_DEFINE_ENUM(UpgradeState, (kBeforeUpgrade)(kDuringUpgrade)(kAfterUpgrade));
+
+namespace yb {
+
+constexpr auto kExpectedDdlError =
+    "YSQL DDLs, and catalog modifications are not allowed during a major YSQL upgrade";
+
+static const MonoDelta kNoDelayBetweenNodes = 0s;
+
+class YsqlMajorUpgradeDdlBlockingTest : public Pg15UpgradeTestBase {
+ public:
+  YsqlMajorUpgradeDdlBlockingTest() = default;
+
+  void SetUp() override {
+    Pg15UpgradeTestBase::SetUp();
+    if (IsTestSkipped()) {
+      return;
+    }
+
+    auto conn = ASSERT_RESULT(CreateConnToTs(std::nullopt));
+    ASSERT_OK(conn.ExecuteFormat("CREATE TABLE $0(a int)", kCommentTable));
+  }
+
+ protected:
+  Status SwitchToMixedMode() {
+    LOG(INFO) << "Restarting yb-tserver " << kMixedModeTserverPg15 << " in current version";
+    auto mixed_mode_pg15_tserver = cluster_->tablet_server(kMixedModeTserverPg15);
+    return RestartTServerInCurrentVersion(
+        *mixed_mode_pg15_tserver, /*wait_for_cluster_to_stabilize=*/true);
+  }
+
+  Status RunDdlFunctions(std::optional<size_t> node_index, bool error_expected = false) {
+    static const auto func_list = std::vector<std::function<Status(std::optional<size_t>)>>{
+        RUN_DDL_FUNC(RunTempTableDdls), RUN_DDL_FUNC(RunRegularTableDdls),
+        RUN_DDL_FUNC(RunForceSetComment)};
+
+    for (const auto& ddl_func : func_list) {
+      auto status = ddl_func(node_index);
+      if (!error_expected) {
+        RETURN_NOT_OK(status);
+      } else {
+        SCHECK(
+            !status.ok() &&
+                status.message().ToString().find(kExpectedDdlError) != std::string::npos,
+            IllegalState, "Unexpected status: ", status.ToString());
+      }
+    }
+    return Status::OK();
+  }
+
+  Status RunTempTableDdls(std::optional<size_t> node_index) {
+    // Run twice to force drop of the temporary table.
+    for (int i = 0; i < 2; i++) {
+      auto conn = VERIFY_RESULT(CreateConnToTs(node_index));
+      // Needed to prevent read restart errors.
+      SleepFor(550ms);
+
+      RETURN_NOT_OK(conn.Execute("CREATE TEMP TABLE tmp_tbl (a int PRIMARY KEY)"));
+
+      RETURN_NOT_OK(conn.Execute("INSERT INTO tmp_tbl VALUES (1)"));
+      auto count = VERIFY_RESULT(conn.FetchRow<int64_t>("SELECT count(*) FROM tmp_tbl"));
+      SCHECK_EQ(count, 1, IllegalState, "Unexpected count");
+
+      RETURN_NOT_OK(conn.Execute("ALTER TABLE tmp_tbl ADD COLUMN b TEXT"));
+      RETURN_NOT_OK(conn.Execute("CREATE INDEX temp_idx ON tmp_tbl (b)"));
+      RETURN_NOT_OK(conn.Execute("DROP INDEX temp_idx"));
+
+      if (i % 2) {
+        RETURN_NOT_OK(conn.Execute("DROP TABLE tmp_tbl"));
+      }
+    }
+
+    return Status::OK();
+  }
+
+  Status RunRegularTableDdls(std::optional<size_t> node_index) {
+    const auto check_regular_tbl_stmts = {
+        "CREATE TABLE tbl1(a int)", "INSERT INTO tbl1 VALUES (1)",
+        "ALTER TABLE tbl1 ADD COLUMN b TEXT", "DROP TABLE tbl1"};
+    const auto check_view_stmts = {"CREATE VIEW v1 AS SELECT 1", "DROP VIEW v1"};
+    const auto statements_to_run = {check_regular_tbl_stmts, check_view_stmts};
+
+    // No DDLs allowed during the catalog upgrade and monitoring phases.
+    const bool expect_error = upgrade_state_ == UpgradeState::kDuringUpgrade;
+
+    auto conn = VERIFY_RESULT(CreateConnToTs(node_index));
+    for (const auto& statements : statements_to_run) {
+      for (const auto& stmt : statements) {
+        auto status = conn.Execute(stmt);
+        if (!status.ok()) {
+          LOG(INFO) << "Statement: " << stmt << ", Status: " << status;
+          if (!expect_error ||
+              status.message().ToString().find(kExpectedDdlError) == std::string::npos) {
+            return status;
+          }
+          break;
+        }
+      }
+    }
+    return Status::OK();
+  }
+
+  static constexpr auto kCommentTable = "comment_tbl1";
+
+  Status RunForceSetComment(std::optional<size_t> node_index) {
+    static int count = 0;
+    auto conn = VERIFY_RESULT(CreateConnToTs(node_index));
+
+    const auto new_comment = Format("comment $0", count++);
+
+    RETURN_NOT_OK(conn.Execute("SET yb_force_catalog_update_on_next_ddl = true"));
+    RETURN_NOT_OK(conn.ExecuteFormat("COMMENT ON TABLE $0 IS '$1'", kCommentTable, new_comment));
+
+    const auto kSelectTableComment = Format(
+        "SELECT description from pg_description JOIN pg_class on pg_description.objoid = "
+        "pg_class.oid WHERE relname = '$0'",
+        kCommentTable);
+    const auto selected_comment = VERIFY_RESULT(conn.FetchRow<std::string>(kSelectTableComment));
+    SCHECK_EQ(selected_comment, new_comment, IllegalState, "Unexpected comment after DDL ran");
+
+    return Status::OK();
+  }
+
+  UpgradeState upgrade_state_ = UpgradeState::kBeforeUpgrade;
+};
+
+TEST_F(YsqlMajorUpgradeDdlBlockingTest, TestDdlsDuringUpgrade) {
+  upgrade_state_ = UpgradeState::kBeforeUpgrade;
+  ASSERT_OK(RunDdlFunctions(std::nullopt));
+
+  upgrade_state_ = UpgradeState::kDuringUpgrade;
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
+
+  ASSERT_OK(RunDdlFunctions(std::nullopt));
+
+  ASSERT_OK(StartYsqlMajorCatalogUpgrade());
+
+  ASSERT_OK(RunDdlFunctions(std::nullopt));
+
+  ASSERT_OK(WaitForYsqlMajorCatalogUpgradeToFinish());
+
+  ASSERT_OK(SwitchToMixedMode());
+
+  ASSERT_OK(RunDdlFunctions(kMixedModeTserverPg15));
+  ASSERT_OK(RunDdlFunctions(kMixedModeTserverPg11));
+
+  // Finalize upgrade without upgrading all tservers
+  ASSERT_OK(FinalizeYsqlMajorCatalogUpgrade());
+  upgrade_state_ = UpgradeState::kAfterUpgrade;
+
+  ASSERT_OK(RunDdlFunctions(kMixedModeTserverPg15));
+
+  // Pg11 tserver should not be allowed to update the catalog after catalog upgrade has been
+  // finalized.
+  ASSERT_OK(RunDdlFunctions(kMixedModeTserverPg11, /*error_expected=*/true));
+}
+
+// Make sure we cannot run DDLs during a failed upgrade.
+TEST_F(YsqlMajorUpgradeDdlBlockingTest, TestFailedUpgrade) {
+  upgrade_state_ = UpgradeState::kDuringUpgrade;
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
+
+  auto master_leader = cluster_->GetLeaderMaster();
+  ASSERT_OK(cluster_->SetFlag(
+      master_leader, "TEST_fail_ysql_catalog_upgrade_state_transition_from",
+      "PERFORMING_PG_UPGRADE"));
+
+  ASSERT_OK(StartYsqlMajorCatalogUpgrade());
+
+  ASSERT_OK(LoggedWaitFor(
+      [this]() -> Result<bool> {
+        return VERIFY_RESULT(DumpYsqlCatalogConfig()).find("state: PERFORMING_PG_UPGRADE") !=
+               std::string::npos;
+      },
+      5min, "Waiting for pg_upgrade to start"));
+
+  // The pg_upgrade takes longer than 2s in all builds.
+  SleepFor(2s);
+
+  master_leader->Shutdown();
+  ASSERT_OK(WaitForClusterToStabilize());
+
+  ASSERT_OK(RunDdlFunctions(kMixedModeTserverPg11));
+}
+
+}  // namespace yb
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 4b2876bdda..d70475e878 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -2315,8 +2315,8 @@ Status CatalogManager::ValidateTableReplicationInfo(
 }
 
 Result<shared_ptr<TablespaceIdToReplicationInfoMap>> CatalogManager::GetYsqlTablespaceInfo() {
-  auto table_info =
-      GetTableInfo(VERIFY_RESULT(GetVersionSpecificCatalogTableId(kPgTablespaceTableId)));
+  auto table_info = GetTableInfo(
+      VERIFY_RESULT(ysql_manager_->GetVersionSpecificCatalogTableId(kPgTablespaceTableId)));
   if (table_info == nullptr) {
     return STATUS(InternalError, "pg_tablespace table info not found");
   }
@@ -2490,8 +2490,9 @@ Result<shared_ptr<TableToTablespaceIdMap>> CatalogManager::GetYsqlTableToTablesp
                    << nsid << " with error: " << table_tablespace_status.ToString();
     }
 
-    const TableId tablegroup_table_id = VERIFY_RESULT(
-        GetVersionSpecificCatalogTableId(GetPgsqlTableId(database_oid, kPgYbTablegroupTableOid)));
+    const TableId tablegroup_table_id =
+        VERIFY_RESULT(ysql_manager_->GetVersionSpecificCatalogTableId(
+            GetPgsqlTableId(database_oid, kPgYbTablegroupTableOid)));
     const bool pg_yb_tablegroup_exists =
         VERIFY_RESULT(DoesTableExist(FindTableById(tablegroup_table_id)));
 
@@ -8525,17 +8526,9 @@ Status CatalogManager::CreateNamespace(const CreateNamespaceRequestPB* req,
           //
           // So in case #2, we must accept only current-version catalog tables.
           const auto& table_id = table->id();
-          if (IsPgsqlId(table_id) && CHECK_RESULT(GetPgsqlDatabaseOid(table_id)) == *source_oid) {
-            if (IsYsqlMajorCatalogUpgradeInProgress()) {
-              if (!IsCurrentVersionCatalogId(table_id)) {
-                continue;
-              }
-            } else {
-              // YB_TODO: Remove when we support cleanup of prior-version catalog tables after the
-              // YSQL major version upgrade.
-              if (IsPriorVersionCatalogId(table_id)) {
-                continue;
-              }
+          if (IsPgsqlId(table_id) && VERIFY_RESULT(GetPgsqlDatabaseOid(table_id)) == *source_oid) {
+            if (IsPriorVersionYsqlCatalogTable(table_id)) {
+              continue;
             }
             // Since indexes have dependencies on the base tables, put the tables in the front.
             const bool is_table = table->indexed_table_id().empty();
@@ -9269,7 +9262,7 @@ Status CatalogManager::DeleteYsqlDBTables(
       //  * The rollback deletes all current-version catalog tables in order to prepare for the next
       //    upgrade attempt.
       // In both cases, we delete only the current version's catalog tables.
-      if (is_ysql_major_upgrade && !IsCurrentVersionCatalogId(table->id())) {
+      if (is_ysql_major_upgrade && !IsCurrentVersionYsqlCatalogTable(table->id())) {
         continue;
       }
       if (table->namespace_id() != database->id()) {
@@ -9914,13 +9907,12 @@ Status CatalogManager::GetYsqlCatalogVersion(uint64_t* catalog_version,
 Status CatalogManager::GetYsqlDBCatalogVersion(uint32_t db_oid,
                                                uint64_t* catalog_version,
                                                uint64_t* last_breaking_version) {
-  auto table_id = VERIFY_RESULT(GetVersionSpecificCatalogTableId(kPgYbCatalogVersionTableId));
+  auto table_id =
+      VERIFY_RESULT(ysql_manager_->GetVersionSpecificCatalogTableId(kPgYbCatalogVersionTableId));
   auto table_info = GetTableInfo(table_id);
   if (table_info != nullptr) {
-    RETURN_NOT_OK(sys_catalog_->ReadYsqlDBCatalogVersion(table_id,
-                                                         db_oid,
-                                                         catalog_version,
-                                                         last_breaking_version));
+    RETURN_NOT_OK(sys_catalog_->ReadYsqlDBCatalogVersion(
+        kPgYbCatalogVersionTableId, db_oid, catalog_version, last_breaking_version));
     // If the version is properly initialized, we're done.
     if ((!catalog_version || *catalog_version > 0) &&
         (!last_breaking_version || *last_breaking_version > 0)) {
@@ -9944,10 +9936,11 @@ Status CatalogManager::GetYsqlDBCatalogVersion(uint32_t db_oid,
 }
 
 Status CatalogManager::GetYsqlAllDBCatalogVersionsImpl(DbOidToCatalogVersionMap* versions) {
-  auto table_id = VERIFY_RESULT(GetVersionSpecificCatalogTableId(kPgYbCatalogVersionTableId));
+  auto table_id =
+      VERIFY_RESULT(ysql_manager_->GetVersionSpecificCatalogTableId(kPgYbCatalogVersionTableId));
   auto table_info = GetTableInfo(table_id);
   if (table_info != nullptr) {
-    RETURN_NOT_OK(sys_catalog_->ReadYsqlAllDBCatalogVersions(table_id, versions));
+    RETURN_NOT_OK(sys_catalog_->ReadYsqlAllDBCatalogVersions(kPgYbCatalogVersionTableId, versions));
   } else {
     versions->clear();
   }
@@ -13391,22 +13384,6 @@ bool CatalogManager::IsYsqlMajorCatalogUpgradeInProgress() const {
   return ysql_manager_->IsYsqlMajorCatalogUpgradeInProgress();
 }
 
-Result<TableId> CatalogManager::GetVersionSpecificCatalogTableId(const TableId& table_id) const {
-  if (!ysql_manager_->IsCurrentVersionCatalogEstablished()) {
-    // When a yb-master goes through the ysql major catalog upgrade process, the process begins
-    // before the current version's initdb and catalog upgrade have been run, so we can't depend on
-    // the existence of valid current-version catalog tables. We therefore utilize prior-version
-    // catalog tables while initdb and the catalog upgrade are in progress. Once we enter the
-    // MONITORING state, we switch to the current version's catalogs so that they can be exercised
-    // and tested.
-    uint32_t database_oid = VERIFY_RESULT(GetPgsqlDatabaseOid(table_id));
-    uint32_t table_oid = VERIFY_RESULT(GetPgsqlTableOid(table_id));
-    return GetPgsqlTableIdPriorVersion(database_oid, table_oid);
-  } else {
-    return table_id;
-  }
-}
-
 bool CatalogManager::SkipCatalogVersionChecks() {
   // Only skip if we are leader and the major catalog upgrade is in progress.
   SCOPED_LEADER_SHARED_LOCK(l, this);
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index d98ccad8cc..306f8e3464 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -2932,12 +2932,6 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
 
   bool IsYsqlMajorCatalogUpgradeInProgress() const;
 
-  // In the case of an online ysql major catalog upgrade, returns the current version only if the
-  // current version's catalog is valid, meaning in the MONITORING stage, or post-upgrade. If we are
-  // before the MONITORING stage, returns the prior version's table. In the case of a clean install,
-  // returns the current version.
-  Result<TableId> GetVersionSpecificCatalogTableId(const TableId& table_id) const override;
-
   bool SkipCatalogVersionChecks() override;
 
   // Should be bumped up when tablet locations are changed.
diff --git a/src/yb/master/catalog_manager_if.h b/src/yb/master/catalog_manager_if.h
index 9849c7824a..603a147406 100644
--- a/src/yb/master/catalog_manager_if.h
+++ b/src/yb/master/catalog_manager_if.h
@@ -336,8 +336,6 @@ class CatalogManagerIf : public tserver::TabletPeerLookupIf {
 
   virtual Result<TSDescriptorPtr> GetClosestLiveTserver(bool* local_ts = nullptr) const = 0;
 
-  virtual Result<TableId> GetVersionSpecificCatalogTableId(const TableId& table_id) const = 0;
-
   virtual bool SkipCatalogVersionChecks() = 0;
 
   virtual ~CatalogManagerIf() = default;
diff --git a/src/yb/master/master_tablet_service.cc b/src/yb/master/master_tablet_service.cc
index d41d4bb14f..7f0379d111 100644
--- a/src/yb/master/master_tablet_service.cc
+++ b/src/yb/master/master_tablet_service.cc
@@ -25,6 +25,7 @@
 #include "yb/master/master.h"
 #include "yb/master/scoped_leader_shared_lock.h"
 #include "yb/master/scoped_leader_shared_lock-internal.h"
+#include "yb/master/ysql/ysql_manager.h"
 
 #include "yb/rpc/rpc_context.h"
 
@@ -114,6 +115,16 @@ void MasterTabletServiceImpl::Write(const tserver::WriteRequestPB* req,
       return;
     }
 
+    {
+      auto write_allowed = master_->ysql_manager_impl().ValidateWriteToCatalogTableAllowed(
+          pg_req.table_id(), pg_req.force_catalog_modifications());
+      if (!write_allowed.ok()) {
+        VLOG(1) << "Write to catalog table while it is not allowed: " << pg_req.ShortDebugString();
+        context.RespondRpcFailure(rpc::ErrorStatusPB::ERROR_APPLICATION, std::move(write_allowed));
+        return;
+      }
+    }
+
     if (pg_req.is_ysql_catalog_change_using_protobuf()) {
       const auto& res = master_->catalog_manager()->IncrementYsqlCatalogVersion();
       if (!res.ok()) {
diff --git a/src/yb/master/master_tserver.cc b/src/yb/master/master_tserver.cc
index 68957bb67e..966813522b 100644
--- a/src/yb/master/master_tserver.cc
+++ b/src/yb/master/master_tserver.cc
@@ -192,7 +192,6 @@ client::TransactionPool& MasterTabletServer::TransactionPool() {
 }
 
 rpc::Messenger* MasterTabletServer::GetMessenger(ash::Component component) const {
-  LOG(WARNING) << "Unexpected call of GetMessenger()";
   return nullptr;
 }
 
diff --git a/src/yb/master/sys_catalog.cc b/src/yb/master/sys_catalog.cc
index 7544469d82..29523f85e2 100644
--- a/src/yb/master/sys_catalog.cc
+++ b/src/yb/master/sys_catalog.cc
@@ -42,6 +42,7 @@
 
 #include "yb/common/colocated_util.h"
 #include "yb/common/pg_catversions.h"
+#include "yb/master/ysql/ysql_manager_if.h"
 #include "yb/qlexpr/index.h"
 #include "yb/dockv/partial_row.h"
 #include "yb/dockv/partition.h"
@@ -2068,8 +2069,8 @@ Result<tablet::TabletPtr> SysCatalogTable::Tablet() const {
 Result<PgTableReadData> SysCatalogTable::TableReadData(
     const TableId& original_table_id, const ReadHybridTime& read_ht) const {
   PgTableReadData result;
-  const TableId table_id = VERIFY_RESULT(
-      master_->catalog_manager()->GetVersionSpecificCatalogTableId(original_table_id));
+  const TableId table_id =
+      VERIFY_RESULT(master_->ysql_manager().GetVersionSpecificCatalogTableId(original_table_id));
   result.table_id = table_id;
   result.tablet = VERIFY_RESULT(Tablet());
   result.table_info = VERIFY_RESULT(result.tablet->metadata()->GetTableInfo(table_id));
diff --git a/src/yb/master/ysql/ysql_catalog_config.cc b/src/yb/master/ysql/ysql_catalog_config.cc
index 9e1269eeed..9001901877 100644
--- a/src/yb/master/ysql/ysql_catalog_config.cc
+++ b/src/yb/master/ysql/ysql_catalog_config.cc
@@ -13,40 +13,18 @@
 
 #include "yb/master/ysql/ysql_catalog_config.h"
 
-#include "yb/master/master_admin.pb.h"
 #include "yb/master/master_defaults.h"
 #include "yb/util/shared_lock.h"
 #include "yb/master/sys_catalog.h"
 
 #include "yb/master/catalog_entity_info.h"
-#include "yb/util/version_info.pb.h"
-#include "yb/util/version_info.h"
 #include "yb/util/is_operation_done_result.h"
+#include "yb/util/version_info.h"
 
 DECLARE_bool(log_ysql_catalog_versions);
 
-DEFINE_test_flag(
-    string, fail_ysql_catalog_upgrade_state_transition_from, "",
-    "When set fail the transition to the provided state");
-
 namespace yb::master {
 
-namespace {
-
-uint32 GetMajorVersionOfCurrentBuild() {
-  VersionInfoPB version_info;
-  VersionInfo::GetVersionInfoPB(&version_info);
-  return version_info.ysql_major_version();
-}
-
-bool IsYsqlMajorCatalogOperationRunning(YsqlMajorCatalogUpgradeInfoPB::State state) {
-  return state == YsqlMajorCatalogUpgradeInfoPB::PERFORMING_PG_UPGRADE ||
-         state == YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB ||
-         state == YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK;
-}
-
-}  // namespace
-
 YsqlCatalogConfig::YsqlCatalogConfig(SysCatalogTable& sys_catalog) : sys_catalog_(sys_catalog) {}
 
 Status YsqlCatalogConfig::PrepareDefaultIfNeeded(const LeaderEpoch& epoch) {
@@ -58,7 +36,7 @@ Status YsqlCatalogConfig::PrepareDefaultIfNeeded(const LeaderEpoch& epoch) {
   SysYSQLCatalogConfigEntryPB ysql_catalog_config;
   ysql_catalog_config.set_version(0);
   ysql_catalog_config.mutable_ysql_major_catalog_upgrade_info()->set_catalog_version(
-      GetMajorVersionOfCurrentBuild());
+      VersionInfo::YsqlMajorVersion());
 
   config_ = new SysConfigInfo(kYsqlCatalogConfigType);
   auto l = config_->LockForWrite();
@@ -71,39 +49,11 @@ Status YsqlCatalogConfig::PrepareDefaultIfNeeded(const LeaderEpoch& epoch) {
 }
 
 void YsqlCatalogConfig::SetConfig(scoped_refptr<SysConfigInfo> config) {
-  auto& ysql_catalog_config = config->mutable_metadata()->mutable_dirty()->pb.ysql_catalog_config();
-  if (ysql_catalog_config.has_ysql_major_catalog_upgrade_info()) {
-    const auto persisted_version =
-        ysql_catalog_config.ysql_major_catalog_upgrade_info().catalog_version();
-    LOG_IF(FATAL, persisted_version > GetMajorVersionOfCurrentBuild())
-        << "Persisted major version in YSQL catalog config is not supported. Restart "
-           "the process in the correct version. Min required major version: "
-        << persisted_version << ", Current major version: " << VersionInfo::GetShortVersionString();
-
-    // A new yb-master leader has started. If we were in the middle of the ysql major catalog
-    // upgrade (initdb, pg_upgrade, or rollback) then mark the major upgrade as failed. No action
-    // is taken if we are in the monitoring phase.
-    // We cannot update the config right now, so do so after the sys_catalog is loaded.
-    restarted_during_major_upgrade_ = IsYsqlMajorCatalogOperationRunning(
-        ysql_catalog_config.ysql_major_catalog_upgrade_info().state());
-  }
-
   std::lock_guard m_lock(mutex_);
   LOG_IF(WARNING, config_ != nullptr) << "Multiple Ysql Catalog configs found";
   config_ = std::move(config);
 }
 
-void YsqlCatalogConfig::SysCatalogLoaded(const LeaderEpoch& epoch) {
-  if (restarted_during_major_upgrade_) {
-    ERROR_NOT_OK(
-        TransitionMajorCatalogUpgradeState(
-            YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch,
-            STATUS(InternalError, "yb-master restarted during ysql major catalog upgrade")),
-        "Failed to set major version upgrade state to FAILED");
-    restarted_during_major_upgrade_ = false;
-  }
-}
-
 void YsqlCatalogConfig::Reset() {
   std::lock_guard m_lock(mutex_);
   config_.reset();
@@ -201,123 +151,31 @@ Status YsqlCatalogConfig::SetTransactionalSysCatalogEnabled(const LeaderEpoch& e
   return Status::OK();
 }
 
-IsOperationDoneResult YsqlCatalogConfig::IsYsqlMajorCatalogUpgradeDone() const {
+YsqlMajorCatalogUpgradeInfoPB::State YsqlCatalogConfig::GetMajorCatalogUpgradeState() const {
   auto [l, pb] = LockForRead();
   if (!pb.has_ysql_major_catalog_upgrade_info()) {
-    return IsOperationDoneResult::Done();
-  }
-
-  const auto state = pb.ysql_major_catalog_upgrade_info().state();
-  if (IsYsqlMajorCatalogOperationRunning(state)) {
-    return IsOperationDoneResult::NotDone();
+    return YsqlMajorCatalogUpgradeInfoPB::DONE;
   }
 
-  Status status;
-  if (pb.ysql_major_catalog_upgrade_info().has_previous_error()) {
-    status = StatusFromPB(pb.ysql_major_catalog_upgrade_info().previous_error());
-  }
-
-  return IsOperationDoneResult::Done(status);
-}
-
-YsqlMajorCatalogUpgradeInfoPB::State YsqlCatalogConfig::GetMajorCatalogUpgradeState() const {
-  auto [l, pb] = LockForRead();
   return pb.ysql_major_catalog_upgrade_info().state();
 }
 
-bool YsqlCatalogConfig::IsCurrentVersionCatalogEstablished() const {
+Status YsqlCatalogConfig::GetMajorCatalogUpgradePreviousError() const {
   auto [l, pb] = LockForRead();
-  auto major_upgrade_info = pb.ysql_major_catalog_upgrade_info();
-
-  // In the DONE state we either have not started the catalog upgrade or have completed it.
-  if (major_upgrade_info.state() == YsqlMajorCatalogUpgradeInfoPB::DONE) {
-    return major_upgrade_info.catalog_version() == GetMajorVersionOfCurrentBuild();
+  Status status;
+  if (pb.has_ysql_major_catalog_upgrade_info() &&
+      pb.ysql_major_catalog_upgrade_info().has_previous_error()) {
+    status = StatusFromPB(pb.ysql_major_catalog_upgrade_info().previous_error());
   }
-
-  return major_upgrade_info.state() == YsqlMajorCatalogUpgradeInfoPB::MONITORING;
+  return status;
 }
 
-const std::unordered_map<
-    YsqlMajorCatalogUpgradeInfoPB::State, std::unordered_set<YsqlMajorCatalogUpgradeInfoPB::State>>
-    kAllowedTransitions = {
-        {YsqlMajorCatalogUpgradeInfoPB::INVALID, {}},
-
-        {YsqlMajorCatalogUpgradeInfoPB::DONE, {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB}},
-
-        {YsqlMajorCatalogUpgradeInfoPB::FAILED,
-         {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK}},
-
-        {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB,
-         {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_PG_UPGRADE,
-          YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK,
-          YsqlMajorCatalogUpgradeInfoPB::FAILED}},
-
-        {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_PG_UPGRADE,
-         {YsqlMajorCatalogUpgradeInfoPB::MONITORING,
-          YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK,
-          YsqlMajorCatalogUpgradeInfoPB::FAILED}},
-
-        {YsqlMajorCatalogUpgradeInfoPB::MONITORING,
-         {YsqlMajorCatalogUpgradeInfoPB::DONE, YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK,
-          YsqlMajorCatalogUpgradeInfoPB::FAILED}},
-
-        {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK,
-         {YsqlMajorCatalogUpgradeInfoPB::DONE, YsqlMajorCatalogUpgradeInfoPB::FAILED}},
-};
-
-Status YsqlCatalogConfig::TransitionMajorCatalogUpgradeState(
-    const YsqlMajorCatalogUpgradeInfoPB::State new_state, const LeaderEpoch& epoch,
-    const Status& failed_status) {
-  DCHECK_EQ(kAllowedTransitions.size(), YsqlMajorCatalogUpgradeInfoPB::State_ARRAYSIZE);
-
-  const auto new_state_str = YsqlMajorCatalogUpgradeInfoPB::State_Name(new_state);
-
-  RSTATUS_DCHECK_EQ(
-      failed_status.ok(), new_state != YsqlMajorCatalogUpgradeInfoPB::FAILED, IllegalState,
-      Format("Bad status must be set if and only if transitioning to FAILED state", failed_status));
-
+Status YsqlCatalogConfig::Update(
+    const LeaderEpoch& epoch, std::function<Status(SysYSQLCatalogConfigEntryPB&)> update_function) {
   SharedLock m_lock(mutex_);
   auto [l, pb] = LockForWrite();
 
-  auto* ysql_major_catalog_upgrade_info = pb.mutable_ysql_major_catalog_upgrade_info();
-  const auto current_state = ysql_major_catalog_upgrade_info->state();
-  SCHECK_NE(
-      current_state, new_state, IllegalState,
-      Format("Major upgrade state already set to $0", new_state_str));
-
-  const auto current_state_str = YsqlMajorCatalogUpgradeInfoPB::State_Name(current_state);
-
-  SCHECK_NE(
-      current_state_str, FLAGS_TEST_fail_ysql_catalog_upgrade_state_transition_from, IllegalState,
-      "Failed due to FLAGS_TEST_fail_ysql_catalog_upgrade_state_transition_from");
-
-  auto allowed_states_it = FindOrNull(kAllowedTransitions, current_state);
-  RSTATUS_DCHECK(allowed_states_it, IllegalState, Format("Invalid state $0", current_state_str));
-
-  SCHECK(
-      allowed_states_it->contains(new_state), IllegalState,
-      Format("Invalid state transition from $0 to $1", current_state_str, new_state_str));
-
-  if (current_state == YsqlMajorCatalogUpgradeInfoPB::MONITORING &&
-      new_state == YsqlMajorCatalogUpgradeInfoPB::DONE) {
-    ysql_major_catalog_upgrade_info->set_catalog_version(GetMajorVersionOfCurrentBuild());
-  } else if (current_state == YsqlMajorCatalogUpgradeInfoPB::DONE) {
-    const auto major_version = GetMajorVersionOfCurrentBuild();
-    SCHECK_GT(
-        major_version, ysql_major_catalog_upgrade_info->catalog_version(), IllegalState,
-        "Ysql Catalog is already on the current major version");
-  }
-
-  ysql_major_catalog_upgrade_info->set_state(new_state);
-
-  if (!failed_status.ok()) {
-    StatusToPB(failed_status, ysql_major_catalog_upgrade_info->mutable_previous_error());
-  } else {
-    ysql_major_catalog_upgrade_info->clear_previous_error();
-  }
-
-  LOG(INFO) << "Transitioned major upgrade state from " << current_state_str << " to "
-            << new_state_str;
+  RETURN_NOT_OK(update_function(pb));
 
   RETURN_NOT_OK(sys_catalog_.Upsert(epoch, config_));
   l.Commit();
diff --git a/src/yb/master/ysql/ysql_catalog_config.h b/src/yb/master/ysql/ysql_catalog_config.h
index fde1367ce2..5c23ff004a 100644
--- a/src/yb/master/ysql/ysql_catalog_config.h
+++ b/src/yb/master/ysql/ysql_catalog_config.h
@@ -37,8 +37,6 @@ class YsqlCatalogConfig {
   void SetConfig(scoped_refptr<SysConfigInfo> config) EXCLUDES(mutex_);
   void Reset() EXCLUDES(mutex_);
 
-  void SysCatalogLoaded(const LeaderEpoch& epoch);
-
   uint64 GetVersion() const EXCLUDES(mutex_);
 
   // Increments and return the new version.
@@ -51,18 +49,15 @@ class YsqlCatalogConfig {
   bool IsTransactionalSysCatalogEnabled() const EXCLUDES(mutex_);
   Status SetTransactionalSysCatalogEnabled(const LeaderEpoch& epoch) EXCLUDES(mutex_);
 
+  // Are we running a major catalog upgrade or rollback?
   IsOperationDoneResult IsYsqlMajorCatalogUpgradeDone() const EXCLUDES(mutex_);
 
   YsqlMajorCatalogUpgradeInfoPB::State GetMajorCatalogUpgradeState() const EXCLUDES(mutex_);
+  Status GetMajorCatalogUpgradePreviousError() const EXCLUDES(mutex_);
 
-  bool IsCurrentVersionCatalogEstablished() const EXCLUDES(mutex_);
-
-  // Transition the ysql major catalog upgrade to a new state if allowed.
-  // failed_status must be set to a NonOk status if and only if transitioning to FAILED state.
-  // Check kAllowedTransitions for list of allowed transitions.
-  Status TransitionMajorCatalogUpgradeState(
-      const YsqlMajorCatalogUpgradeInfoPB::State new_state, const LeaderEpoch& epoch,
-      const Status& failed_status = Status::OK()) EXCLUDES(mutex_);
+  Status Update(
+      const LeaderEpoch& epoch, std::function<Status(SysYSQLCatalogConfigEntryPB&)> update_function)
+      EXCLUDES(mutex_);
 
  private:
   std::pair<CowReadLock<PersistentSysConfigInfo>, const SysYSQLCatalogConfigEntryPB&> LockForRead()
@@ -74,8 +69,6 @@ class YsqlCatalogConfig {
   SysCatalogTable& sys_catalog_;
   mutable std::shared_mutex mutex_;
   scoped_refptr<SysConfigInfo> config_ GUARDED_BY(mutex_);
-
-  std::atomic<bool> restarted_during_major_upgrade_ = false;
 };
 
 }  // namespace master
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
index e7e7881bc9..fdf2c91fe6 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
@@ -26,6 +26,7 @@
 #include "yb/util/pg_util.h"
 #include "yb/util/scope_exit.h"
 #include "yb/util/status.h"
+#include "yb/util/version_info.h"
 
 #include "yb/yql/pgwrapper/pg_wrapper.h"
 
@@ -36,10 +37,24 @@ DECLARE_string(rpc_bind_addresses);
 DEFINE_RUNTIME_uint32(ysql_upgrade_postgres_port, 5434,
   "Port used to start the postgres process for ysql upgrade");
 
+DEFINE_test_flag(
+    string, fail_ysql_catalog_upgrade_state_transition_from, "",
+    "When set fail the transition to the provided state");
+
 using yb::pgwrapper::PgWrapper;
 
 namespace yb::master {
 
+namespace {
+
+bool IsYsqlMajorCatalogOperationRunning(YsqlMajorCatalogUpgradeInfoPB::State state) {
+  return state == YsqlMajorCatalogUpgradeInfoPB::PERFORMING_PG_UPGRADE ||
+         state == YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB ||
+         state == YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK;
+}
+
+}  // namespace
+
 YsqlInitDBAndMajorUpgradeHandler::YsqlInitDBAndMajorUpgradeHandler(
     Master& master, YsqlCatalogConfig& ysql_catalog_config, CatalogManager& catalog_manager,
     SysCatalogTable& sys_catalog, yb::ThreadPool& thread_pool)
@@ -49,6 +64,56 @@ YsqlInitDBAndMajorUpgradeHandler::YsqlInitDBAndMajorUpgradeHandler(
       sys_catalog_(sys_catalog),
       thread_pool_(thread_pool) {}
 
+void YsqlInitDBAndMajorUpgradeHandler::Load(scoped_refptr<SysConfigInfo> config) {
+  auto& ysql_catalog_config = config->mutable_metadata()->mutable_dirty()->pb.ysql_catalog_config();
+  if (ysql_catalog_config.has_ysql_major_catalog_upgrade_info()) {
+    const auto persisted_version =
+        ysql_catalog_config.ysql_major_catalog_upgrade_info().catalog_version();
+    const auto major_version_of_current_build = VersionInfo::YsqlMajorVersion();
+    LOG_IF(FATAL, persisted_version > major_version_of_current_build)
+        << "Persisted major version in YSQL catalog config is not supported. Restart "
+           "the process in the correct version. Min required major version: "
+        << persisted_version << ", Current major version: " << VersionInfo::GetShortVersionString();
+
+    // If the persisted version is different from the current version then we are in the middle of
+    // ysql major upgrade.
+    ysql_major_upgrade_in_progress_ = persisted_version != major_version_of_current_build;
+
+    // A new yb-master leader has started. If we were in the middle of the ysql major catalog
+    // upgrade (initdb, pg_upgrade, or rollback) then mark the major upgrade as failed. No action
+    // is taken if we are in the monitoring phase.
+    // We cannot update the config right now, so do so after the sys_catalog is loaded.
+    auto state = ysql_catalog_config.ysql_major_catalog_upgrade_info().state();
+
+    if (!ysql_major_upgrade_in_progress_ && state != YsqlMajorCatalogUpgradeInfoPB::DONE) {
+      LOG(FATAL) << "Ysql catalog is in state " << YsqlMajorCatalogUpgradeInfoPB::State_Name(state)
+                 << " but the persisted major ysql version " << persisted_version
+                 << " is the same as the current major version supported by this build. yb-master "
+                    "process seems to have been incorrectly downgraded in the middle of an ysql "
+                    "major upgrade. Restart the yb-master in the newer version and rollback the "
+                    "ysql catalog before downgrading. Current process version: "
+                 << VersionInfo::GetShortVersionString();
+    }
+
+    restarted_during_major_upgrade_ = IsYsqlMajorCatalogOperationRunning(state);
+  } else {
+    // This is Pg11 to Pg15. major_catalog_upgrade_info was only added in pg15.
+    ysql_major_upgrade_in_progress_ = true;
+    restarted_during_major_upgrade_ = false;
+  }
+}
+
+void YsqlInitDBAndMajorUpgradeHandler::SysCatalogLoaded(const LeaderEpoch& epoch) {
+  if (restarted_during_major_upgrade_) {
+    ERROR_NOT_OK(
+        TransitionMajorCatalogUpgradeState(
+            YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch,
+            STATUS(InternalError, "yb-master restarted during ysql major catalog upgrade")),
+        "Failed to set major version upgrade state to FAILED");
+    restarted_during_major_upgrade_ = false;
+  }
+}
+
 Status YsqlInitDBAndMajorUpgradeHandler::StartNewClusterGlobalInitDB(const LeaderEpoch& epoch) {
   SCHECK(
       !FLAGS_master_join_existing_universe, IllegalState,
@@ -59,14 +124,13 @@ Status YsqlInitDBAndMajorUpgradeHandler::StartNewClusterGlobalInitDB(const Leade
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::StartYsqlMajorCatalogUpgrade(const LeaderEpoch& epoch) {
-  RETURN_NOT_OK(ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
-      YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB, epoch));
+  RETURN_NOT_OK(
+      TransitionMajorCatalogUpgradeState(YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB, epoch));
 
   auto status = RunOperationAsync([this, epoch]() { RunMajorVersionUpgrade(epoch); });
   if (!status.ok()) {
     ERROR_NOT_OK(
-        ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
-            YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch, status),
+        TransitionMajorCatalogUpgradeState(YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch, status),
         "Failed to set major version upgrade state");
   }
 
@@ -74,17 +138,22 @@ Status YsqlInitDBAndMajorUpgradeHandler::StartYsqlMajorCatalogUpgrade(const Lead
 }
 
 IsOperationDoneResult YsqlInitDBAndMajorUpgradeHandler::IsYsqlMajorCatalogUpgradeDone() const {
-  return ysql_catalog_config_.IsYsqlMajorCatalogUpgradeDone();
+  const auto state = ysql_catalog_config_.GetMajorCatalogUpgradeState();
+  if (IsYsqlMajorCatalogOperationRunning(state)) {
+    return IsOperationDoneResult::NotDone();
+  }
+
+  return IsOperationDoneResult::Done(ysql_catalog_config_.GetMajorCatalogUpgradePreviousError());
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::FinalizeYsqlMajorCatalogUpgrade(const LeaderEpoch& epoch) {
-  return ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
-      YsqlMajorCatalogUpgradeInfoPB::DONE, epoch);
+  return TransitionMajorCatalogUpgradeState(YsqlMajorCatalogUpgradeInfoPB::DONE, epoch);
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::RollbackYsqlMajorCatalogVersion(const LeaderEpoch& epoch) {
-  // Since Rollback is synchronous, we can perform the state transitions inside the async function.
-  // It also ensures there are no inflight operations when the rollback state transition occurs.
+  // Since Rollback is synchronous, we can perform the state transitions inside the async
+  // function. It also ensures there are no inflight operations when the rollback state transition
+  // occurs.
   Synchronizer sync;
   auto cb = sync.AsStdStatusCallback();
 
@@ -102,6 +171,18 @@ bool YsqlInitDBAndMajorUpgradeHandler::IsYsqlMajorCatalogUpgradeInProgress() con
   return !IsYsqlMajorCatalogUpgradeDone().done();
 }
 
+bool YsqlInitDBAndMajorUpgradeHandler::IsWriteToCatalogTableAllowed(
+    const TableId& table_id, bool is_forced_update) const {
+  // During the upgrade only allow special updates to the catalog.
+  if (IsYsqlMajorUpgradeInProgress()) {
+    return is_forced_update;
+  }
+
+  // If we are not in the middle of a major upgrade then only allow updates to the current
+  // version.
+  return IsCurrentVersionYsqlCatalogTable(table_id);
+}
+
 Status YsqlInitDBAndMajorUpgradeHandler::RunOperationAsync(std::function<void()> func) {
   bool expected = false;
   if (!is_running_.compare_exchange_strong(expected, true)) {
@@ -159,8 +240,8 @@ Status YsqlInitDBAndMajorUpgradeHandler::InitDBAndSnapshotSysCatalog(
 void YsqlInitDBAndMajorUpgradeHandler::RunMajorVersionUpgrade(const LeaderEpoch& epoch) {
   auto status = RunMajorVersionUpgradeImpl(epoch);
   if (status.ok()) {
-    auto update_state_status = ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
-        YsqlMajorCatalogUpgradeInfoPB::MONITORING, epoch);
+    auto update_state_status =
+        TransitionMajorCatalogUpgradeState(YsqlMajorCatalogUpgradeInfoPB::MONITORING, epoch);
     if (update_state_status.ok()) {
       LOG(INFO) << "Ysql major catalog upgrade completed successfully";
     } else {
@@ -171,8 +252,7 @@ void YsqlInitDBAndMajorUpgradeHandler::RunMajorVersionUpgrade(const LeaderEpoch&
 
   LOG(ERROR) << "Ysql major catalog upgrade failed: " << status;
   ERROR_NOT_OK(
-      ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
-          YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch, status),
+      TransitionMajorCatalogUpgradeState(YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch, status),
       "Failed to set major version upgrade state");
 }
 
@@ -183,13 +263,13 @@ Status YsqlInitDBAndMajorUpgradeHandler::RunMajorVersionUpgradeImpl(const Leader
   return Status::OK();
 }
 
-// pg_upgrade does not migrate the catalog version table, so we have to explicitly copy the contents
-// of the pre-existing catalog table to the current version's catalog version table.
+// pg_upgrade does not migrate the catalog version table, so we have to explicitly copy the
+// contents of the pre-existing catalog table to the current version's catalog version table.
 Status YsqlInitDBAndMajorUpgradeHandler::UpdateCatalogVersions(const LeaderEpoch& epoch) {
-  RETURN_NOT_OK(sys_catalog_.DeleteAllYsqlCatalogTableRows({kPgYbCatalogVersionTableId},
-                                                           epoch.leader_term));
-  RETURN_NOT_OK(sys_catalog_.CopyPgsqlTables({kPgYbCatalogVersionTableIdPriorVersion},
-                                             {kPgYbCatalogVersionTableId}, epoch.leader_term));
+  RETURN_NOT_OK(
+      sys_catalog_.DeleteAllYsqlCatalogTableRows({kPgYbCatalogVersionTableId}, epoch.leader_term));
+  RETURN_NOT_OK(sys_catalog_.CopyPgsqlTables(
+      {kPgYbCatalogVersionTableIdPriorVersion}, {kPgYbCatalogVersionTableId}, epoch.leader_term));
   return Status::OK();
 }
 
@@ -199,7 +279,7 @@ Status YsqlInitDBAndMajorUpgradeHandler::RunMajorVersionCatalogUpgrade(const Lea
       InitDBAndSnapshotSysCatalog(db_name_to_oid_list, /*is_major_upgrade=*/true, epoch),
       "Failed to run initdb");
 
-  RETURN_NOT_OK(ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
+  RETURN_NOT_OK(TransitionMajorCatalogUpgradeState(
       YsqlMajorCatalogUpgradeInfoPB::PERFORMING_PG_UPGRADE, epoch));
 
   RETURN_NOT_OK_PREPEND(PerformPgUpgrade(epoch), "Failed to run pg_upgrade");
@@ -281,16 +361,15 @@ Status YsqlInitDBAndMajorUpgradeHandler::RunRollbackMajorVersionUpgrade(const Le
     return Status::OK();
   }
 
-  RETURN_NOT_OK(ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
+  RETURN_NOT_OK(TransitionMajorCatalogUpgradeState(
       YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK, epoch));
 
   auto status = RollbackMajorVersionCatalogImpl(epoch);
   if (status.ok()) {
-    RETURN_NOT_OK(ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
-        YsqlMajorCatalogUpgradeInfoPB::DONE, epoch));
+    RETURN_NOT_OK(TransitionMajorCatalogUpgradeState(YsqlMajorCatalogUpgradeInfoPB::DONE, epoch));
   } else {
-    RETURN_NOT_OK(ysql_catalog_config_.TransitionMajorCatalogUpgradeState(
-        YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch, status));
+    RETURN_NOT_OK(
+        TransitionMajorCatalogUpgradeState(YsqlMajorCatalogUpgradeInfoPB::FAILED, epoch, status));
   }
 
   return status;
@@ -351,4 +430,97 @@ Status YsqlInitDBAndMajorUpgradeHandler::RollbackMajorVersionCatalogImpl(const L
   return Status::OK();
 }
 
+const std::unordered_map<
+    YsqlMajorCatalogUpgradeInfoPB::State, std::unordered_set<YsqlMajorCatalogUpgradeInfoPB::State>>
+    kAllowedTransitions = {
+        {YsqlMajorCatalogUpgradeInfoPB::INVALID, {}},
+
+        {YsqlMajorCatalogUpgradeInfoPB::DONE, {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB}},
+
+        {YsqlMajorCatalogUpgradeInfoPB::FAILED,
+         {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK}},
+
+        {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_INIT_DB,
+         {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_PG_UPGRADE,
+          YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK,
+          YsqlMajorCatalogUpgradeInfoPB::FAILED}},
+
+        {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_PG_UPGRADE,
+         {YsqlMajorCatalogUpgradeInfoPB::MONITORING,
+          YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK,
+          YsqlMajorCatalogUpgradeInfoPB::FAILED}},
+
+        {YsqlMajorCatalogUpgradeInfoPB::MONITORING,
+         {YsqlMajorCatalogUpgradeInfoPB::DONE, YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK,
+          YsqlMajorCatalogUpgradeInfoPB::FAILED}},
+
+        {YsqlMajorCatalogUpgradeInfoPB::PERFORMING_ROLLBACK,
+         {YsqlMajorCatalogUpgradeInfoPB::DONE, YsqlMajorCatalogUpgradeInfoPB::FAILED}},
+};
+
+Status YsqlInitDBAndMajorUpgradeHandler::TransitionMajorCatalogUpgradeState(
+    const YsqlMajorCatalogUpgradeInfoPB::State new_state, const LeaderEpoch& epoch,
+    const Status& failed_status) {
+  DCHECK_EQ(kAllowedTransitions.size(), YsqlMajorCatalogUpgradeInfoPB::State_ARRAYSIZE);
+
+  SCHECK_FORMAT(
+      ysql_major_upgrade_in_progress_, IllegalState,
+      "Ysql Catalog is already on the current major version: $0", VersionInfo::YsqlMajorVersion());
+
+  const auto new_state_str = YsqlMajorCatalogUpgradeInfoPB::State_Name(new_state);
+
+  RSTATUS_DCHECK_EQ(
+      failed_status.ok(), new_state != YsqlMajorCatalogUpgradeInfoPB::FAILED, IllegalState,
+      Format("Bad status must be set if and only if transitioning to FAILED state", failed_status));
+
+  bool ysql_major_upgrade_done = false;
+
+  auto update_config_func = [&](SysYSQLCatalogConfigEntryPB& pb) -> Status {
+    auto* ysql_major_catalog_upgrade_info = pb.mutable_ysql_major_catalog_upgrade_info();
+    const auto current_state = ysql_major_catalog_upgrade_info->state();
+    SCHECK_NE(
+        current_state, new_state, IllegalState,
+        Format("Major upgrade state already set to $0", new_state_str));
+
+    const auto current_state_str = YsqlMajorCatalogUpgradeInfoPB::State_Name(current_state);
+
+    SCHECK_NE(
+        current_state_str, FLAGS_TEST_fail_ysql_catalog_upgrade_state_transition_from, IllegalState,
+        "Failed due to FLAGS_TEST_fail_ysql_catalog_upgrade_state_transition_from");
+
+    auto allowed_states_it = FindOrNull(kAllowedTransitions, current_state);
+    RSTATUS_DCHECK(allowed_states_it, IllegalState, Format("Invalid state $0", current_state_str));
+
+    SCHECK(
+        allowed_states_it->contains(new_state), IllegalState,
+        Format("Invalid state transition from $0 to $1", current_state_str, new_state_str));
+
+    if (current_state == YsqlMajorCatalogUpgradeInfoPB::MONITORING &&
+        new_state == YsqlMajorCatalogUpgradeInfoPB::DONE) {
+      ysql_major_catalog_upgrade_info->set_catalog_version(VersionInfo::YsqlMajorVersion());
+      ysql_major_upgrade_done = true;
+    }
+
+    ysql_major_catalog_upgrade_info->set_state(new_state);
+
+    if (!failed_status.ok()) {
+      StatusToPB(failed_status, ysql_major_catalog_upgrade_info->mutable_previous_error());
+    } else {
+      ysql_major_catalog_upgrade_info->clear_previous_error();
+    }
+
+    LOG(INFO) << "Transitioned major upgrade state from " << current_state_str << " to "
+              << new_state_str;
+
+    return Status::OK();
+  };
+
+  RETURN_NOT_OK(ysql_catalog_config_.Update(epoch, update_config_func));
+
+  if (ysql_major_upgrade_done) {
+    ysql_major_upgrade_in_progress_ = false;
+  }
+
+  return Status::OK();
+}
 }  // namespace yb::master
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
index 4bf91a4715..63fabec874 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
@@ -37,6 +37,10 @@ class YsqlInitDBAndMajorUpgradeHandler {
 
   ~YsqlInitDBAndMajorUpgradeHandler() = default;
 
+  void Load(scoped_refptr<SysConfigInfo> config);
+
+  void SysCatalogLoaded(const LeaderEpoch& epoch);
+
   // Starts the global initdb procedure to create the initial universe level ysql sys catalog using
   // the initdb process.
   Status StartNewClusterGlobalInitDB(const LeaderEpoch& epoch);
@@ -53,8 +57,22 @@ class YsqlInitDBAndMajorUpgradeHandler {
   // to a clean state.
   Status RollbackYsqlMajorCatalogVersion(const LeaderEpoch& epoch);
 
+  // Are we in a ysql major upgrade?
+  // The upgrade is considered to have started when the yb-master leader has upgraded to a new major
+  // catalog version.
+  // The upgrade is completed after it has been finalized.
+  bool IsYsqlMajorUpgradeInProgress() const { return ysql_major_upgrade_in_progress_; }
+
   bool IsYsqlMajorCatalogUpgradeInProgress() const;
 
+  // Are we allowed to perform updates to the ysql catalog?
+  // True for the current version if the ysql major upgrade completed.
+  // The upgrade is considered to have started when the yb-master leader has upgraded to a new major
+  // catalog version.
+  // The upgrade is completed after it has been finalized.
+  // During the upgrade only is_forced_update operations are allowed.
+  bool IsWriteToCatalogTableAllowed(const TableId& table_id, bool is_forced_update) const;
+
  private:
   using DbNameToOidList = std::vector<std::pair<std::string, YBCPgOid>>;
 
@@ -94,6 +112,13 @@ class YsqlInitDBAndMajorUpgradeHandler {
   // Get the address to a live tserver process that is closest to the master.
   Result<std::string> GetClosestLiveTserverAddress();
 
+  // Transition the ysql major catalog upgrade to a new state if allowed.
+  // failed_status must be set to a NonOk status if and only if transitioning to FAILED state.
+  // Check kAllowedTransitions for list of allowed transitions.
+  Status TransitionMajorCatalogUpgradeState(
+      const YsqlMajorCatalogUpgradeInfoPB::State new_state, const LeaderEpoch& epoch,
+      const Status& failed_status = Status::OK());
+
   Master& master_;
   YsqlCatalogConfig& ysql_catalog_config_;
   CatalogManager& catalog_manager_;
@@ -104,6 +129,9 @@ class YsqlInitDBAndMajorUpgradeHandler {
   // progress.
   std::atomic<bool> is_running_{false};
 
+  std::atomic<bool> restarted_during_major_upgrade_ = false;
+  std::atomic<bool> ysql_major_upgrade_in_progress_ = false;
+
   DISALLOW_COPY_AND_ASSIGN(YsqlInitDBAndMajorUpgradeHandler);
 };
 
diff --git a/src/yb/master/ysql/ysql_manager.cc b/src/yb/master/ysql/ysql_manager.cc
index 57cc9704b4..cde625383c 100644
--- a/src/yb/master/ysql/ysql_manager.cc
+++ b/src/yb/master/ysql/ysql_manager.cc
@@ -53,11 +53,12 @@ Status YsqlManager::PrepareDefaultSysConfig(const LeaderEpoch& epoch) {
 }
 
 void YsqlManager::LoadConfig(scoped_refptr<SysConfigInfo> config) {
-  return ysql_catalog_config_.SetConfig(config);
+  ysql_initdb_and_major_upgrade_helper_->Load(config);
+  ysql_catalog_config_.SetConfig(config);
 }
 
 void YsqlManager::SysCatalogLoaded(const LeaderEpoch& epoch) {
-  ysql_catalog_config_.SysCatalogLoaded(epoch);
+  ysql_initdb_and_major_upgrade_helper_->SysCatalogLoaded(epoch);
 }
 
 Result<bool> YsqlManager::StartRunningInitDbIfNeeded(const LeaderEpoch& epoch) {
@@ -106,7 +107,7 @@ Status YsqlManager::SetInitDbDone(const LeaderEpoch& epoch) {
 }
 
 bool YsqlManager::IsYsqlMajorCatalogUpgradeInProgress() const {
-  return !ysql_catalog_config_.IsYsqlMajorCatalogUpgradeDone().done();
+  return ysql_initdb_and_major_upgrade_helper_->IsYsqlMajorCatalogUpgradeInProgress();
 }
 
 uint64_t YsqlManager::GetYsqlCatalogVersion() const { return ysql_catalog_config_.GetVersion(); }
@@ -147,8 +148,20 @@ Status YsqlManager::IsYsqlMajorCatalogUpgradeDone(
   return Status::OK();
 }
 
-bool YsqlManager::IsCurrentVersionCatalogEstablished() const {
-  return ysql_catalog_config_.IsCurrentVersionCatalogEstablished();
+Result<TableId> YsqlManager::GetVersionSpecificCatalogTableId(
+    const TableId& current_table_id) const {
+  DCHECK(IsCurrentVersionYsqlCatalogTable(current_table_id))
+      << "Table id " << current_table_id << " is not a current version YSQL catalog table";
+
+  // Use the current version of the catalog if it is updatable, since if the current version is
+  // available in the MONITORING phase, it can be deleted by a Rollback.
+  if (!ysql_initdb_and_major_upgrade_helper_->IsYsqlMajorUpgradeInProgress()) {
+    return current_table_id;
+  }
+
+  uint32_t database_oid = VERIFY_RESULT(GetPgsqlDatabaseOid(current_table_id));
+  uint32_t table_oid = VERIFY_RESULT(GetPgsqlTableOid(current_table_id));
+  return GetPriorVersionYsqlCatalogTableId(database_oid, table_oid);
 }
 
 Status YsqlManager::FinalizeYsqlMajorCatalogUpgrade(
@@ -207,4 +220,15 @@ Status YsqlManager::CreateYbAdvisoryLocksTableIfNeeded(const LeaderEpoch& epoch)
   return Status::OK();
 }
 
+Status YsqlManager::ValidateWriteToCatalogTableAllowed(
+    const TableId& table_id, bool is_forced_update) const {
+  SCHECK(
+      ysql_initdb_and_major_upgrade_helper_->IsWriteToCatalogTableAllowed(
+          table_id, is_forced_update),
+      InternalError,
+      "YSQL DDLs, and catalog modifications are not allowed during a major YSQL upgrade");
+
+  return Status::OK();
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/ysql/ysql_manager.h b/src/yb/master/ysql/ysql_manager.h
index 1d48efbdee..cbbd2cc177 100644
--- a/src/yb/master/ysql/ysql_manager.h
+++ b/src/yb/master/ysql/ysql_manager.h
@@ -77,7 +77,9 @@ class YsqlManager : public YsqlManagerIf {
       const IsYsqlMajorCatalogUpgradeDoneRequestPB* req,
       IsYsqlMajorCatalogUpgradeDoneResponsePB* resp, rpc::RpcContext* rpc);
 
-  bool IsCurrentVersionCatalogEstablished() const;
+  // Returns the prior version's table if we are in the middle of a ysql major upgrade.
+  // In all other cases, returns the current version.
+  Result<TableId> GetVersionSpecificCatalogTableId(const TableId& current_table_id) const override;
 
   Status FinalizeYsqlMajorCatalogUpgrade(
       const FinalizeYsqlMajorCatalogUpgradeRequestPB* req,
@@ -95,6 +97,8 @@ class YsqlManager : public YsqlManagerIf {
 
   Status CreateYbAdvisoryLocksTableIfNeeded(const LeaderEpoch& epoch);
 
+  Status ValidateWriteToCatalogTableAllowed(const TableId& table_id, bool is_forced_update) const;
+
  private:
   Result<bool> StartRunningInitDbIfNeededInternal(const LeaderEpoch& epoch);
 
diff --git a/src/yb/master/ysql/ysql_manager_if.h b/src/yb/master/ysql/ysql_manager_if.h
index 03abe16534..a10f2813db 100644
--- a/src/yb/master/ysql/ysql_manager_if.h
+++ b/src/yb/master/ysql/ysql_manager_if.h
@@ -13,6 +13,7 @@
 
 #pragma once
 
+#include "yb/common/entity_ids_types.h"
 #include "yb/master/leader_epoch.h"
 #include "yb/util/status_fwd.h"
 
@@ -31,6 +32,9 @@ class YsqlManagerIf {
 
   virtual bool IsTransactionalSysCatalogEnabled() const = 0;
   virtual Status SetTransactionalSysCatalogEnabled(const LeaderEpoch& epoch) = 0;
+
+  virtual Result<TableId> GetVersionSpecificCatalogTableId(
+      const TableId& current_table_id) const = 0;
 };
 
 }  // namespace yb::master
diff --git a/src/yb/util/version_info.cc b/src/yb/util/version_info.cc
index 6201cc4cea..8fca0420b8 100644
--- a/src/yb/util/version_info.cc
+++ b/src/yb/util/version_info.cc
@@ -41,6 +41,8 @@
 #include <rapidjson/writer.h>
 
 #include "yb/gutil/casts.h"
+#include "yb/gutil/once.h"
+
 #include "yb/util/env_util.h"
 #include "yb/util/path_util.h"
 #include "yb/util/status.h"
@@ -212,4 +214,17 @@ void VersionInfo::InitInternal(Status* status_dest) {
   *status_dest = ReadVersionDataFromFile();
 }
 
+uint32 VersionInfo::YsqlMajorVersion() {
+  static uint32 ysql_major_version;
+  static GoogleOnceType once = GOOGLE_ONCE_INIT;
+  void (*get_ysql_major_version)(uint32*) = [](uint32* ysql_major_version) {
+    VersionInfoPB version_info;
+    VersionInfo::GetVersionInfoPB(&version_info);
+    *ysql_major_version = version_info.ysql_major_version();
+  };
+  GoogleOnceInitArg(&once, get_ysql_major_version, &ysql_major_version);
+
+  return ysql_major_version;
+}
+
 } // namespace yb
diff --git a/src/yb/util/version_info.h b/src/yb/util/version_info.h
index e7a94dc8b9..dcd893b75b 100644
--- a/src/yb/util/version_info.h
+++ b/src/yb/util/version_info.h
@@ -64,6 +64,8 @@ class VersionInfo {
   // Init version data.
   static Status Init();
 
+  static uint32 YsqlMajorVersion();
+
  private:
   // Get the git hash for this build. If the working directory was dirty when
   // YB was built, also appends "-dirty".
diff --git a/src/yb/yql/pggate/pg_dml_write.cc b/src/yb/yql/pggate/pg_dml_write.cc
index a60865ad7d..bfdb8b0481 100644
--- a/src/yb/yql/pggate/pg_dml_write.cc
+++ b/src/yb/yql/pggate/pg_dml_write.cc
@@ -52,7 +52,8 @@ Status PgDmlWrite::Prepare(const PgObjectId& table_id, bool is_region_local) {
   write_req_->set_schema_version(target_->schema_version());
   write_req_->set_stmt_id(reinterpret_cast<uint64_t>(write_req_.get()));
 
-  if (pg_session_->AreCatalogModificationsForceAllowed()) {
+  if (YBIsMajorUpgradeInitDb() || pg_session_->IsMajorPgVersionUpgrade() ||
+      pg_session_->AreCatalogModificationsForceAllowed()) {
     write_req_->set_force_catalog_modifications(true);
   }
 
diff --git a/src/yb/yql/pggate/pg_session.h b/src/yb/yql/pggate/pg_session.h
index 852f16384f..8be78df5fb 100644
--- a/src/yb/yql/pggate/pg_session.h
+++ b/src/yb/yql/pggate/pg_session.h
@@ -304,6 +304,8 @@ class PgSession : public RefCountedThreadSafe<PgSession> {
 
   bool AreCatalogModificationsForceAllowed() const { return force_allow_catalog_modifications_; }
 
+  bool IsMajorPgVersionUpgrade() const { return is_major_pg_version_upgrade_; }
+
  private:
   Result<PgTableDescPtr> DoLoadTable(
       const PgObjectId& table_id, bool fail_on_cache_hit,
diff --git a/src/yb/yql/pggate/util/ybc_util.cc b/src/yb/yql/pggate/util/ybc_util.cc
index 32b0985d27..c2e527f8b0 100644
--- a/src/yb/yql/pggate/util/ybc_util.cc
+++ b/src/yb/yql/pggate/util/ybc_util.cc
@@ -532,6 +532,16 @@ bool YBCIsNonColocatedYbctidsOnlyFetch(const YBCPgPrepareParameters *params) {
   return params->fetch_ybctids_only && !params->querying_colocated_table;
 }
 
+bool YBIsMajorUpgradeInitDb() {
+  static int cached_value = -1;
+  if (cached_value == -1) {
+    const char* env_var_value = getenv("YB_PG_MAJOR_UPGRADE_INITDB");
+    cached_value = env_var_value && strcmp(env_var_value, "true") == 0;
+  }
+
+  return cached_value;
+}
+
 } // extern "C"
 
 } // namespace yb::pggate
diff --git a/src/yb/yql/pggate/util/ybc_util.h b/src/yb/yql/pggate/util/ybc_util.h
index 1dba3be6cc..8f9945dece 100644
--- a/src/yb/yql/pggate/util/ybc_util.h
+++ b/src/yb/yql/pggate/util/ybc_util.h
@@ -361,6 +361,8 @@ int YBCGetCallStackFrames(void** result, int max_depth, int skip_count);
 
 bool YBCIsNonColocatedYbctidsOnlyFetch(const YBCPgPrepareParameters *params);
 
+bool YBIsMajorUpgradeInitDb();
+
 #ifdef __cplusplus
 } // extern "C"
 #endif
