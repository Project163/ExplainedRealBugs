diff --git a/src/yb/client/client-internal.cc b/src/yb/client/client-internal.cc
index f166da5741..ec4d923409 100644
--- a/src/yb/client/client-internal.cc
+++ b/src/yb/client/client-internal.cc
@@ -328,6 +328,8 @@ YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, IsAlterXClusterReplicationDone);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, DeleteUniverseReplication);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, RepairOutboundXClusterReplicationGroupAddTable);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, RepairOutboundXClusterReplicationGroupRemoveTable);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, GetXClusterOutboundReplicationGroups);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, GetXClusterOutboundReplicationGroupInfo);
 
 #define YB_CLIENT_SPECIALIZE_SIMPLE_EX_EACH(i, data, set) YB_CLIENT_SPECIALIZE_SIMPLE_EX set
 
diff --git a/src/yb/client/xcluster_client.cc b/src/yb/client/xcluster_client.cc
index 89af4d6d73..eb959bfd3d 100644
--- a/src/yb/client/xcluster_client.cc
+++ b/src/yb/client/xcluster_client.cc
@@ -359,6 +359,49 @@ void XClusterClient::CreateXClusterStreamAsync(
       transactional, GetDeadline(), std::move(callback));
 }
 
+Result<std::vector<xcluster::ReplicationGroupId>>
+XClusterClient::GetXClusterOutboundReplicationGroups(const NamespaceId& namespace_id) {
+  master::GetXClusterOutboundReplicationGroupsRequestPB req;
+  if (!namespace_id.empty()) {
+    req.set_namespace_id(namespace_id);
+  }
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(GetXClusterOutboundReplicationGroups, req);
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+
+  std::vector<xcluster::ReplicationGroupId> replication_group_ids;
+  for (const auto& replication_group_id : resp.replication_group_ids()) {
+    replication_group_ids.emplace_back(replication_group_id);
+  }
+
+  return replication_group_ids;
+}
+
+Result<std::unordered_map<NamespaceId, std::unordered_map<TableId, xrepl::StreamId>>>
+XClusterClient::GetXClusterOutboundReplicationGroupInfo(
+    const xcluster::ReplicationGroupId& replication_group_id) {
+  master::GetXClusterOutboundReplicationGroupInfoRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(GetXClusterOutboundReplicationGroupInfo, req);
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+
+  std::unordered_map<NamespaceId, std::unordered_map<TableId, xrepl::StreamId>> result;
+  for (const auto& namespace_info : resp.namespace_infos()) {
+    auto& table_info = result[namespace_info.namespace_id()];
+    for (const auto& [table_id, stream_id] : namespace_info.table_streams()) {
+      table_info.emplace(table_id, VERIFY_RESULT(xrepl::StreamId::FromString(stream_id)));
+    }
+  }
+  return result;
+}
+
+// XClusterRemoteClient
+
 XClusterRemoteClient::XClusterRemoteClient(const std::string& certs_for_cdc_dir, MonoDelta timeout)
     : certs_for_cdc_dir_(certs_for_cdc_dir), timeout_(timeout) {}
 
diff --git a/src/yb/client/xcluster_client.h b/src/yb/client/xcluster_client.h
index 4f3ed01ca6..955a2fb517 100644
--- a/src/yb/client/xcluster_client.h
+++ b/src/yb/client/xcluster_client.h
@@ -135,6 +135,14 @@ class XClusterClient {
       const TableId& table_id, bool active, cdc::StreamModeTransactional transactional,
       CreateCDCStreamCallback callback);
 
+  // Returns the outbound replication groups for the given namespace. If namespace_id is empty, then
+  // all outbound replication groups are returned.
+  Result<std::vector<xcluster::ReplicationGroupId>> GetXClusterOutboundReplicationGroups(
+      const NamespaceId& namespace_id = {});
+
+  Result<std::unordered_map<NamespaceId, std::unordered_map<TableId, xrepl::StreamId>>>
+  GetXClusterOutboundReplicationGroupInfo(const xcluster::ReplicationGroupId& replication_group_id);
+
  private:
   CoarseTimePoint GetDeadline() const;
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
index e97a1deb9f..318884365e 100644
--- a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
@@ -727,6 +727,22 @@ TEST_F_EX(XClusterDBScopedTest, TestYbAdmin, XClusterDBScopedTestWithTwoDBs) {
   ASSERT_OK(CallAdmin(
       producer_cluster(), "setup_xcluster_replication", kReplicationGroupId,
       target_master_address));
+
+  result =
+      ASSERT_RESULT(CallAdmin(producer_cluster(), "list_xcluster_outbound_replication_groups"));
+  ASSERT_STR_CONTAINS(result, kReplicationGroupId.ToString());
+  const auto source_namespace_id = producer_table_->name().namespace_id();
+  result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "list_xcluster_outbound_replication_groups", source_namespace_id));
+  ASSERT_STR_CONTAINS(result, kReplicationGroupId.ToString());
+  result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "get_xcluster_outbound_replication_group_info",
+      kReplicationGroupId.ToString()));
+  ASSERT_STR_CONTAINS(result, source_namespace_id);
+  ASSERT_STR_CONTAINS(result, producer_table_->id());
+  ASSERT_STR_NOT_CONTAINS(result, source_namespace2_id_);
+  ASSERT_STR_NOT_CONTAINS(result, source_namespace2_table_->id());
+
   ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
 
   ASSERT_OK(InsertRowsInProducer(0, 10));
@@ -742,6 +758,14 @@ TEST_F_EX(XClusterDBScopedTest, TestYbAdmin, XClusterDBScopedTestWithTwoDBs) {
       producer_cluster(), "add_namespace_to_xcluster_replication", kReplicationGroupId,
       namespace_name2_, target_master_address));
 
+  result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "get_xcluster_outbound_replication_group_info",
+      kReplicationGroupId.ToString()));
+  ASSERT_STR_CONTAINS(result, namespace_name);
+  ASSERT_STR_CONTAINS(result, producer_table_->id());
+  ASSERT_STR_CONTAINS(result, namespace_name2_);
+  ASSERT_STR_CONTAINS(result, source_namespace2_table_->id());
+
   // Remove database from both sides with one command.
   ASSERT_OK(CallAdmin(
       producer_cluster(), "remove_namespace_from_xcluster_replication", kReplicationGroupId,
@@ -769,7 +793,6 @@ TEST_F_EX(XClusterDBScopedTest, TestYbAdmin, XClusterDBScopedTestWithTwoDBs) {
   ASSERT_NOK_STR_CONTAINS(
       VerifyUniverseReplication(&resp), "Could not find xCluster replication group");
 
-  const auto source_namespace_id = producer_table_->name().namespace_id();
   ASSERT_NOK_STR_CONTAINS(GetAllXClusterStreams(source_namespace_id), "Not found");
 
   result = ASSERT_RESULT(CallAdmin(
diff --git a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
index a239a215b5..cf91edf2c1 100644
--- a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
@@ -505,5 +505,103 @@ TEST_F(XClusterOutboundReplicationGroupTest, RepairWithYbAdmin) {
   ASSERT_EQ(resp.table_infos_size(), 2);
 }
 
+// Validate the GetXClusterOutboundReplicationGroupInfo, and
+// GetXClusterOutboundReplicationGroups RPCs.
+TEST_F(XClusterOutboundReplicationGroupTest, TestListAPIs) {
+  // Create two DBs with different table counts.
+  ASSERT_OK(CreateYsqlTable(kNamespaceName, kTableName1));
+
+  const NamespaceId namespace_name_2 = "db2";
+  const auto namespace_id_2 = ASSERT_RESULT(CreateYsqlNamespace(namespace_name_2));
+  ASSERT_OK(CreateYsqlTable(namespace_name_2, kTableName1));
+  ASSERT_OK(CreateYsqlTable(namespace_name_2, "table_2"));
+
+  // Replication group 1 with two namespaces.
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
+      kReplicationGroupId, {namespace_id_, namespace_id_2}));
+  // Wait for checkpointing to complete.
+  ASSERT_OK(GetXClusterStreams(kReplicationGroupId, namespace_id_));
+  ASSERT_OK(GetXClusterStreams(kReplicationGroupId, namespace_id_2));
+  {
+    auto group_info = ASSERT_RESULT(
+        XClusterClient().GetXClusterOutboundReplicationGroupInfo(kReplicationGroupId));
+    ASSERT_EQ(group_info.size(), 2);
+    ASSERT_TRUE(group_info.contains(namespace_id_));
+    ASSERT_TRUE(group_info.contains(namespace_id_2));
+    ASSERT_EQ(group_info[namespace_id_].size(), 1);
+    ASSERT_EQ(group_info[namespace_id_2].size(), 2);
+  }
+
+  // Replication group 2 with one namespace.
+  const xcluster::ReplicationGroupId replication_group2("rg2");
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(replication_group2, {namespace_id_}));
+  ASSERT_OK(GetXClusterStreams(replication_group2, namespace_id_));
+  // Wait for checkpointing to complete.
+  {
+    auto group_info =
+        ASSERT_RESULT(XClusterClient().GetXClusterOutboundReplicationGroupInfo(replication_group2));
+    ASSERT_EQ(group_info.size(), 1);
+    ASSERT_TRUE(group_info.contains(namespace_id_));
+    ASSERT_EQ(group_info[namespace_id_].size(), 1);
+  }
+
+  // List groups for a namespace without any replication groups.
+  {
+    auto replication_groups =
+        ASSERT_RESULT(XClusterClient().GetXClusterOutboundReplicationGroups("NA"));
+    ASSERT_EQ(replication_groups.size(), 0);
+  }
+
+  // List all Outbound groups.
+  {
+    auto replication_groups =
+        ASSERT_RESULT(XClusterClient().GetXClusterOutboundReplicationGroups());
+    ASSERT_EQ(replication_groups.size(), 2);
+    std::unordered_set<xcluster::ReplicationGroupId> replication_groups_set(
+        replication_groups.begin(), replication_groups.end());
+    ASSERT_TRUE(replication_groups_set.contains(kReplicationGroupId));
+    ASSERT_TRUE(replication_groups_set.contains(replication_group2));
+  }
+
+  // List outbound Group per Namespace.
+  {
+    auto replication_groups =
+        ASSERT_RESULT(XClusterClient().GetXClusterOutboundReplicationGroups(namespace_id_));
+    ASSERT_EQ(replication_groups.size(), 2);
+    std::unordered_set<xcluster::ReplicationGroupId> replication_groups_set(
+        replication_groups.begin(), replication_groups.end());
+    ASSERT_TRUE(replication_groups_set.contains(kReplicationGroupId));
+    ASSERT_TRUE(replication_groups_set.contains(replication_group2));
+  }
+  {
+    auto replication_groups =
+        ASSERT_RESULT(XClusterClient().GetXClusterOutboundReplicationGroups(namespace_id_2));
+    ASSERT_EQ(replication_groups.size(), 1);
+    ASSERT_EQ(replication_groups[0], kReplicationGroupId);
+  }
+
+  // Delete the first replication group.
+  ASSERT_OK(XClusterClient().DeleteOutboundReplicationGroup(
+      kReplicationGroupId, /*target_master_addresses=*/""));
+
+  {
+    auto replication_groups =
+        ASSERT_RESULT(XClusterClient().GetXClusterOutboundReplicationGroups());
+    ASSERT_EQ(replication_groups.size(), 1);
+    ASSERT_EQ(replication_groups[0], replication_group2);
+  }
+  {
+    auto replication_groups =
+        ASSERT_RESULT(XClusterClient().GetXClusterOutboundReplicationGroups(namespace_id_));
+    ASSERT_EQ(replication_groups.size(), 1);
+    ASSERT_EQ(replication_groups[0], replication_group2);
+  }
+  {
+    auto replication_groups =
+        ASSERT_RESULT(XClusterClient().GetXClusterOutboundReplicationGroups(namespace_id_2));
+    ASSERT_EQ(replication_groups.size(), 0);
+  }
+}
+
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/master_replication.proto b/src/yb/master/master_replication.proto
index 7fe7d7bcca..a1a0ab8b31 100644
--- a/src/yb/master/master_replication.proto
+++ b/src/yb/master/master_replication.proto
@@ -697,6 +697,30 @@ message RepairOutboundXClusterReplicationGroupRemoveTableResponsePB {
   optional MasterErrorPB error = 1;
 }
 
+message GetXClusterOutboundReplicationGroupsRequestPB {
+  optional string namespace_id = 1;
+}
+
+message GetXClusterOutboundReplicationGroupsResponsePB {
+  optional MasterErrorPB error = 1;
+  repeated string replication_group_ids = 2;
+}
+
+message GetXClusterOutboundReplicationGroupInfoRequestPB {
+  required string replication_group_id = 1;
+}
+
+message GetXClusterOutboundReplicationGroupInfoResponsePB {
+  optional MasterErrorPB error = 1;
+
+  message NamespaceInfoPB {
+    required string namespace_id = 1;
+    // Map of Source TableId to xCluster StreamId
+    map<string, string> table_streams = 2;
+  }
+  repeated NamespaceInfoPB namespace_infos = 2;
+}
+
 service MasterReplication {
   option (yb.rpc.custom_service_name) = "yb.master.MasterService";
 
@@ -793,6 +817,12 @@ service MasterReplication {
   rpc RepairOutboundXClusterReplicationGroupRemoveTable(
       RepairOutboundXClusterReplicationGroupRemoveTableRequestPB)
       returns (RepairOutboundXClusterReplicationGroupRemoveTableResponsePB);
+  rpc GetXClusterOutboundReplicationGroups(
+      GetXClusterOutboundReplicationGroupsRequestPB)
+      returns (GetXClusterOutboundReplicationGroupsResponsePB);
+  rpc GetXClusterOutboundReplicationGroupInfo(
+      GetXClusterOutboundReplicationGroupInfoRequestPB)
+      returns (GetXClusterOutboundReplicationGroupInfoResponsePB);
 
   // xCluster APIsV2
   rpc CreateXClusterReplication(CreateXClusterReplicationRequestPB)
diff --git a/src/yb/master/master_replication_service.cc b/src/yb/master/master_replication_service.cc
index 56b806ae3b..fabf225e6c 100644
--- a/src/yb/master/master_replication_service.cc
+++ b/src/yb/master/master_replication_service.cc
@@ -76,6 +76,8 @@ class MasterReplicationServiceImpl : public MasterServiceBase, public MasterRepl
       (IsAlterXClusterReplicationDone)
       (RepairOutboundXClusterReplicationGroupAddTable)
       (RepairOutboundXClusterReplicationGroupRemoveTable)
+      (GetXClusterOutboundReplicationGroups)
+      (GetXClusterOutboundReplicationGroupInfo)
   )
 };
 
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index b5a509893a..a426771591 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -437,6 +437,42 @@ Status XClusterManager::RepairOutboundXClusterReplicationGroupRemoveTable(
       xcluster::ReplicationGroupId(req->replication_group_id()), req->table_id(), epoch);
 }
 
+Status XClusterManager::GetXClusterOutboundReplicationGroups(
+    const GetXClusterOutboundReplicationGroupsRequestPB* req,
+    GetXClusterOutboundReplicationGroupsResponsePB* resp, rpc::RpcContext* rpc,
+    const LeaderEpoch& epoch) {
+  LOG_FUNC_AND_RPC;
+
+  auto outbound_groups =
+      XClusterSourceManager::GetXClusterOutboundReplicationGroups(req->namespace_id());
+  for (const auto& group_id : outbound_groups) {
+    resp->add_replication_group_ids(group_id.ToString());
+  }
+
+  return Status::OK();
+}
+
+Status XClusterManager::GetXClusterOutboundReplicationGroupInfo(
+    const GetXClusterOutboundReplicationGroupInfoRequestPB* req,
+    GetXClusterOutboundReplicationGroupInfoResponsePB* resp, rpc::RpcContext* rpc,
+    const LeaderEpoch& epoch) {
+  LOG_FUNC_AND_RPC;
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id);
+
+  auto group_info = VERIFY_RESULT(XClusterSourceManager::GetXClusterOutboundReplicationGroupInfo(
+      xcluster::ReplicationGroupId(req->replication_group_id())));
+
+  for (const auto& [namespace_id, table_streams] : group_info) {
+    auto* ns_info = resp->add_namespace_infos();
+    ns_info->set_namespace_id(namespace_id);
+    for (const auto& [table_id, stream_id] : table_streams) {
+      ns_info->mutable_table_streams()->insert({table_id, stream_id.ToString()});
+    }
+  }
+
+  return Status::OK();
+}
+
 std::vector<std::shared_ptr<PostTabletCreateTaskBase>> XClusterManager::GetPostTabletCreateTasks(
     const TableInfoPtr& table_info, const LeaderEpoch& epoch) {
   std::vector<std::shared_ptr<PostTabletCreateTaskBase>> result;
diff --git a/src/yb/master/xcluster/xcluster_manager.h b/src/yb/master/xcluster/xcluster_manager.h
index e422ff7e03..1356627eed 100644
--- a/src/yb/master/xcluster/xcluster_manager.h
+++ b/src/yb/master/xcluster/xcluster_manager.h
@@ -151,6 +151,14 @@ class XClusterManager : public XClusterManagerIf,
       const RepairOutboundXClusterReplicationGroupRemoveTableRequestPB* req,
       RepairOutboundXClusterReplicationGroupRemoveTableResponsePB* resp, rpc::RpcContext* rpc,
       const LeaderEpoch& epoch);
+  Status GetXClusterOutboundReplicationGroups(
+      const GetXClusterOutboundReplicationGroupsRequestPB* req,
+      GetXClusterOutboundReplicationGroupsResponsePB* resp, rpc::RpcContext* rpc,
+      const LeaderEpoch& epoch);
+  Status GetXClusterOutboundReplicationGroupInfo(
+      const GetXClusterOutboundReplicationGroupInfoRequestPB* req,
+      GetXClusterOutboundReplicationGroupInfoResponsePB* resp, rpc::RpcContext* rpc,
+      const LeaderEpoch& epoch);
 
   std::vector<std::shared_ptr<PostTabletCreateTaskBase>> GetPostTabletCreateTasks(
       const TableInfoPtr& table_info, const LeaderEpoch& epoch);
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
index a6145f8be3..edbea717ef 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
@@ -1080,4 +1080,15 @@ Status XClusterOutboundReplicationGroup::VerifyNoTasksInProgress() {
   return Status::OK();
 }
 
+Result<std::vector<NamespaceId>> XClusterOutboundReplicationGroup::GetNamespaces() const {
+  SharedLock mutex_lock(mutex_);
+  auto l = VERIFY_RESULT(LockForRead());
+  std::vector<NamespaceId> namespace_ids;
+  for (const auto& [namespace_id, _] : l->pb.namespace_infos()) {
+    namespace_ids.push_back(namespace_id);
+  }
+
+  return namespace_ids;
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.h b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
index 652c8e2bab..6ef4857017 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.h
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
@@ -128,6 +128,8 @@ class XClusterOutboundReplicationGroup
 
   Status RepairRemoveTable(const TableId& table_id, const LeaderEpoch& epoch) EXCLUDES(mutex_);
 
+  Result<std::vector<NamespaceId>> GetNamespaces() const EXCLUDES(mutex_);
+
  private:
   friend class XClusterOutboundReplicationGroupMocked;
   friend class AddTableToXClusterSourceTask;
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index c2ccddbe3d..ec7435fc1f 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -1111,4 +1111,39 @@ Status XClusterSourceManager::RepairOutboundReplicationGroupRemoveTable(
   return outbound_replication_group->RepairRemoveTable(table_id, epoch);
 }
 
+std::vector<xcluster::ReplicationGroupId>
+XClusterSourceManager::GetXClusterOutboundReplicationGroups(NamespaceId namespace_filter) {
+  std::vector<xcluster::ReplicationGroupId> replication_groups;
+  for (const auto& outbound_group : GetAllOutboundGroups()) {
+    if (namespace_filter.empty() || outbound_group->HasNamespace(namespace_filter)) {
+      replication_groups.push_back(outbound_group->Id());
+    }
+  }
+
+  return replication_groups;
+}
+
+Result<std::unordered_map<NamespaceId, std::unordered_map<TableId, xrepl::StreamId>>>
+XClusterSourceManager::GetXClusterOutboundReplicationGroupInfo(
+    const xcluster::ReplicationGroupId& replication_group_id) {
+  auto outbound_replication_group =
+      VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
+  const auto namespace_ids = VERIFY_RESULT(outbound_replication_group->GetNamespaces());
+
+  std::unordered_map<NamespaceId, std::unordered_map<TableId, xrepl::StreamId>> result;
+  for (const auto& namespace_id : namespace_ids) {
+    const auto namespace_info =
+        VERIFY_RESULT(outbound_replication_group->GetNamespaceCheckpointInfo(namespace_id));
+    if (!namespace_info) {
+      continue;
+    }
+    std::unordered_map<TableId, xrepl::StreamId> ns_info;
+    for (const auto& table_info : namespace_info->table_infos) {
+      ns_info.emplace(table_info.table_id, table_info.stream_id);
+    }
+    result[namespace_id] = std::move(ns_info);
+  }
+  return result;
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_source_manager.h b/src/yb/master/xcluster/xcluster_source_manager.h
index b96ef48b93..4c7f289c1e 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.h
+++ b/src/yb/master/xcluster/xcluster_source_manager.h
@@ -155,6 +155,12 @@ class XClusterSourceManager {
       const xcluster::ReplicationGroupId& replication_group_id, const TableId& table_id,
       const LeaderEpoch& epoch);
 
+  std::vector<xcluster::ReplicationGroupId> GetXClusterOutboundReplicationGroups(
+      NamespaceId namespace_filter);
+
+  Result<std::unordered_map<NamespaceId, std::unordered_map<TableId, xrepl::StreamId>>>
+  GetXClusterOutboundReplicationGroupInfo(const xcluster::ReplicationGroupId& replication_group_id);
+
  private:
   friend class XClusterOutboundReplicationGroup;
 
diff --git a/src/yb/tools/yb-admin_cli.cc b/src/yb/tools/yb-admin_cli.cc
index c3fbc79e8b..0559b3f1a4 100644
--- a/src/yb/tools/yb-admin_cli.cc
+++ b/src/yb/tools/yb-admin_cli.cc
@@ -2518,6 +2518,57 @@ Status repair_xcluster_outbound_replication_remove_table_action(
   return Status::OK();
 }
 
+const auto list_xcluster_outbound_replication_groups_args = "[namespace_id]";
+Status list_xcluster_outbound_replication_groups_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  if (args.size() > 1) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  NamespaceId namespace_id;
+  if (args.size() > 0) {
+    namespace_id = args[0];
+  }
+
+  auto group_ids =
+      VERIFY_RESULT(client->XClusterClient().GetXClusterOutboundReplicationGroups(namespace_id));
+
+  std::cout << group_ids.size() << " Outbound Replication Groups found"
+            << (namespace_id.empty() ? "" : Format(" for namespace $0", namespace_id)) << ": "
+            << std::endl
+            << yb::AsString(group_ids) << std::endl;
+
+  return Status::OK();
+}
+
+const auto get_xcluster_outbound_replication_group_info_args = "<replication_group_id>";
+Status get_xcluster_outbound_replication_group_info_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  if (args.size() != 1) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  const auto replication_group_id = xcluster::ReplicationGroupId(args[0]);
+  const auto group_info = VERIFY_RESULT(
+      client->XClusterClient().GetXClusterOutboundReplicationGroupInfo(replication_group_id));
+
+  const auto& namespace_map = VERIFY_RESULT_REF(client->GetNamespaceMap());
+
+  std::cout << "Outbound Replication Group: " << replication_group_id << std::endl;
+
+  for (const auto& [namespace_id, table_info] : group_info) {
+    std::cout << std::endl << "NamespaceId: " << namespace_id << std::endl;
+    auto* namespace_info = FindOrNull(namespace_map, namespace_id);
+    std::cout << "Namespace name: " << (namespace_info ? namespace_info->id.name() : "<N/A>")
+              << std::endl;
+    for (const auto& [table_id, stream_id] : table_info) {
+      std::cout << "\tTable: " << table_id << ", Stream: " << stream_id << std::endl;
+    }
+  }
+
+  return Status::OK();
+}
+
 }  // namespace
 
 void ClusterAdminCli::RegisterCommandHandlers() {
@@ -2645,6 +2696,8 @@ void ClusterAdminCli::RegisterCommandHandlers() {
   REGISTER_COMMAND(remove_namespace_from_xcluster_replication);
   REGISTER_COMMAND(repair_xcluster_outbound_replication_add_table);
   REGISTER_COMMAND(repair_xcluster_outbound_replication_remove_table);
+  REGISTER_COMMAND(list_xcluster_outbound_replication_groups);
+  REGISTER_COMMAND(get_xcluster_outbound_replication_group_info);
 }
 
 Result<std::vector<client::YBTableName>> ResolveTableNames(
diff --git a/src/yb/tools/yb-admin_client.h b/src/yb/tools/yb-admin_client.h
index ce0f0ae52f..28a902f90d 100644
--- a/src/yb/tools/yb-admin_client.h
+++ b/src/yb/tools/yb-admin_client.h
@@ -476,6 +476,9 @@ class ClusterAdminClient {
   Status RepairOutboundXClusterReplicationGroupRemoveTable(
       const xcluster::ReplicationGroupId& replication_group_id, const TableId& table_id);
 
+  using NamespaceMap = std::unordered_map<NamespaceId, client::NamespaceInfo>;
+  Result<const NamespaceMap&> GetNamespaceMap(bool include_nonrunning = false);
+
  protected:
   // Fetch the locations of the replicas for a given tablet from the Master.
   Status GetTabletLocations(const TabletId& tablet_id,
@@ -604,9 +607,6 @@ class ClusterAdminClient {
       const Object& obj, const Request& req, const char* error_message = nullptr,
       const MonoDelta timeout = MonoDelta());
 
-  using NamespaceMap = std::unordered_map<NamespaceId, client::NamespaceInfo>;
-  Result<const NamespaceMap&> GetNamespaceMap(bool include_nonrunning = false);
-
   Result<TxnSnapshotId> SuitableSnapshotId(
       const SnapshotScheduleId& schedule_id, HybridTime restore_at, CoarseTimePoint deadline);
 
