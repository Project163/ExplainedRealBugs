diff --git a/src/yb/client/xcluster_client.cc b/src/yb/client/xcluster_client.cc
index fec418dcea..fd0b309211 100644
--- a/src/yb/client/xcluster_client.cc
+++ b/src/yb/client/xcluster_client.cc
@@ -83,6 +83,10 @@ Result<IsOperationDoneResult> XClusterClient::IsCreateXClusterReplicationDone(
     return StatusFromPB(resp.error().status());
   }
 
+  if (!resp.done()) {
+    return IsOperationDoneResult::NotDone();
+  }
+
   if (resp.has_replication_error()) {
     return IsOperationDoneResult::Done(StatusFromPB(resp.replication_error()));
   }
@@ -247,12 +251,16 @@ Result<IsOperationDoneResult> XClusterRemoteClient::IsSetupUniverseReplicationDo
     return StatusFromPB(resp.error().status());
   }
 
+  if (!resp.done()) {
+    return IsOperationDoneResult::NotDone();
+  }
+
   if (resp.has_replication_error()) {
     // IsSetupUniverseReplicationDoneRequestPB will contain an OK status on success.
     return IsOperationDoneResult::Done(StatusFromPB(resp.replication_error()));
   }
 
-  return resp.done() ? IsOperationDoneResult::Done() : IsOperationDoneResult::NotDone();
+  return IsOperationDoneResult::Done();
 }
 
 Status XClusterRemoteClient::GetXClusterTableCheckpointInfos(
diff --git a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
index 7da9e20872..339625207b 100644
--- a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
@@ -37,12 +37,32 @@ class XClusterDBScopedTest : public XClusterYsqlTestBase {
 };
 
 TEST_F(XClusterDBScopedTest, TestCreateWithCheckpoint) {
-  ASSERT_OK(SetUpClusters());
+  SetupParams param;
+  param.num_producer_tablets = {};
+  param.num_consumer_tablets = {};
+  ASSERT_OK(SetUpClusters(param));
+
+  ASSERT_NOK_STR_CONTAINS(
+      CheckpointReplicationGroup(),
+      "Database should have at least one table in order to be part of xCluster replication");
+
+  auto producer_table_name = ASSERT_RESULT(CreateYsqlTable(
+      /*idx=*/0, /*num_tablets=*/3, &producer_cluster_));
+  ASSERT_OK(producer_client()->OpenTable(producer_table_name, &producer_table_));
 
   ASSERT_OK(CheckpointReplicationGroup());
 
+  ASSERT_OK(InsertRowsInProducer(0, 50));
+
   ASSERT_NOK(CreateReplicationFromCheckpoint("bad-master-addr"));
 
+  ASSERT_NOK_STR_CONTAINS(
+      CreateReplicationFromCheckpoint(), "Could not find matching table for yugabyte.test_table_0");
+
+  auto consumer_table_name = ASSERT_RESULT(CreateYsqlTable(
+      /*idx=*/0, /*num_tablets=*/3, &consumer_cluster_));
+  ASSERT_OK(producer_client()->OpenTable(consumer_table_name, &consumer_table_));
+
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   // Verify that universe was setup on consumer.
@@ -52,7 +72,7 @@ TEST_F(XClusterDBScopedTest, TestCreateWithCheckpoint) {
   ASSERT_EQ(resp.entry().tables_size(), 1);
   ASSERT_EQ(resp.entry().tables(0), producer_table_->id());
 
-  ASSERT_OK(InsertRowsInProducer(0, 50));
+  ASSERT_OK(InsertRowsInProducer(50, 100));
 
   ASSERT_OK(VerifyWrittenRecords());
 }
@@ -63,10 +83,10 @@ TEST_F(XClusterDBScopedTest, CreateTable) {
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   // Creating a new table on target first should fail.
-  auto status = CreateYsqlTable(
-      /*idx=*/1, /*num_tablets=*/3, &consumer_cluster_);
-  ASSERT_NOK(status);
-  ASSERT_STR_CONTAINS(status.ToString(), "Table public.test_table_1 not found");
+  ASSERT_NOK_STR_CONTAINS(
+      CreateYsqlTable(
+          /*idx=*/1, /*num_tablets=*/3, &consumer_cluster_),
+      "Table public.test_table_1 not found");
 
   auto new_producer_table_name = ASSERT_RESULT(CreateYsqlTable(
       /*idx=*/1, /*num_tablets=*/3, &producer_cluster_));
@@ -125,4 +145,101 @@ TEST_F(XClusterDBScopedTest, DropTableOnProducerThenConsumer) {
   ASSERT_STR_CONTAINS(result.status().ToString(), "test_table_0 not found in namespace");
 }
 
+TEST_F(XClusterDBScopedTest, ColocatedDB) {
+  namespace_name = "colocated_db";
+  SetupParams param;
+  param.is_colocated = true;
+
+  // Create clusters with colocated database, and 1 non-colocated table.
+  ASSERT_OK(SetUpClusters(param));
+
+  ASSERT_NOK_STR_CONTAINS(
+      CheckpointReplicationGroup(),
+      "Colocated database should have at least one colocated table in order to be part of "
+      "xCluster replication");
+
+  auto producer_colocated_table_name = ASSERT_RESULT(CreateYsqlTable(
+      /*idx=*/1, /*num_tablets=*/3, &producer_cluster_,
+      /*tablegroup_name=*/boost::none, /*colocated=*/true));
+  std::shared_ptr<client::YBTable> producer_colocated_table;
+  ASSERT_OK(producer_client()->OpenTable(producer_colocated_table_name, &producer_colocated_table));
+
+  ASSERT_OK(CheckpointReplicationGroup());
+
+  ASSERT_OK(InsertRowsInProducer(0, 10));
+  ASSERT_OK(InsertRowsInProducer(0, 50, producer_colocated_table));
+
+  ASSERT_NOK_STR_CONTAINS(
+      CreateReplicationFromCheckpoint(),
+      "Could not find matching table for colocated_db.test_table_1");
+
+  auto consumer_colocated_table_name = ASSERT_RESULT(CreateYsqlTable(
+      /*idx=*/1, /*num_tablets=*/3, &consumer_cluster_,
+      /*tablegroup_name=*/boost::none, /*colocated=*/true));
+  std::shared_ptr<client::YBTable> consumer_colocated_table;
+  ASSERT_OK(consumer_client()->OpenTable(consumer_colocated_table_name, &consumer_colocated_table));
+
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+
+  ASSERT_OK(VerifyWrittenRecords());
+  ASSERT_OK(VerifyWrittenRecords(producer_colocated_table_name, consumer_colocated_table_name));
+  ASSERT_OK(VerifyWrittenRecords(producer_colocated_table, consumer_colocated_table));
+
+  // Make sure we only colocated parent table and one non-colocated table
+  master::GetUniverseReplicationResponsePB resp;
+  ASSERT_OK(VerifyUniverseReplication(&resp));
+  ASSERT_EQ(resp.entry().tables_size(), 2);
+
+  auto producer_table2_name = ASSERT_RESULT(CreateYsqlTable(
+      /*idx=*/2, /*num_tablets=*/3, &producer_cluster_));
+  std::shared_ptr<client::YBTable> producer_table2;
+  ASSERT_OK(producer_client()->OpenTable(producer_table2_name, &producer_table2));
+
+  ASSERT_OK(InsertRowsInProducer(0, 50, producer_table2));
+
+  auto consumer_table2_name = ASSERT_RESULT(CreateYsqlTable(
+      /*idx=*/2, /*num_tablets=*/3, &consumer_cluster_));
+  std::shared_ptr<client::YBTable> consumer_table2;
+  ASSERT_OK(producer_client()->OpenTable(consumer_table2_name, &consumer_table2));
+
+  ASSERT_OK(VerifyWrittenRecords(producer_table2, consumer_table2));
+
+  auto producer_colocated_table2_name = ASSERT_RESULT(CreateYsqlTable(
+      /*idx=*/3, /*num_tablets=*/3, &producer_cluster_,
+      /*tablegroup_name=*/boost::none, /*colocated=*/true));
+  std::shared_ptr<client::YBTable> producer_colocated_table2;
+  ASSERT_OK(
+      producer_client()->OpenTable(producer_colocated_table2_name, &producer_colocated_table2));
+  ASSERT_OK(InsertRowsInProducer(0, 50, producer_colocated_table2));
+
+  auto consumer_colocated_table2_name = ASSERT_RESULT(CreateYsqlTable(
+      /*idx=*/3, /*num_tablets=*/3, &consumer_cluster_,
+      /*tablegroup_name=*/boost::none, /*colocated=*/true));
+  std::shared_ptr<client::YBTable> consumer_colocated_table2;
+  ASSERT_OK(
+      consumer_client()->OpenTable(consumer_colocated_table2_name, &consumer_colocated_table2));
+  ASSERT_OK(VerifyWrittenRecords(producer_colocated_table2, consumer_colocated_table2));
+
+  ASSERT_OK(DropYsqlTable(producer_cluster_, *producer_colocated_table));
+  ASSERT_OK(DropYsqlTable(consumer_cluster_, *consumer_colocated_table));
+
+  ASSERT_OK(VerifyUniverseReplication(&resp));
+  ASSERT_EQ(resp.entry().tables_size(), 3);
+
+  // Insert some rows to the initial table.
+  ASSERT_OK(InsertRowsInProducer(10, 20, producer_table_));
+  ASSERT_OK(InsertRowsInProducer(50, 100, producer_table2));
+  ASSERT_OK(VerifyWrittenRecords());
+
+  // Make sure the other table remains unchanged.
+  ASSERT_OK(VerifyWrittenRecords(producer_table2, consumer_table2));
+  ASSERT_OK(VerifyWrittenRecords(producer_colocated_table2, consumer_colocated_table2));
+
+  ASSERT_OK(DropYsqlTable(producer_cluster_, *producer_table2));
+  ASSERT_OK(DropYsqlTable(consumer_cluster_, *consumer_table2));
+
+  ASSERT_OK(VerifyUniverseReplication(&resp));
+  ASSERT_EQ(resp.entry().tables_size(), 2);
+}
+
 }  // namespace yb
diff --git a/src/yb/integration-tests/xcluster/xcluster_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_test_base.cc
index 23d62aaed6..44a343dd6f 100644
--- a/src/yb/integration-tests/xcluster/xcluster_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_test_base.cc
@@ -219,7 +219,7 @@ Status XClusterTestBase::CreateDatabase(
     Cluster* cluster, const std::string& namespace_name, bool colocated) {
   auto conn = VERIFY_RESULT(cluster->Connect());
   return conn.ExecuteFormat(
-      "CREATE DATABASE $0$1", namespace_name, colocated ? " colocated = true" : "");
+      "CREATE DATABASE $0$1", namespace_name, colocated ? " COLOCATION = true" : "");
 }
 
 Status XClusterTestBase::DropDatabase(Cluster& cluster, const std::string& namespace_name) {
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
index 4b309e3f98..9c284e0477 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
@@ -286,6 +286,7 @@ Result<YBTableName> XClusterYsqlTestBase::CreateYsqlTable(
       }
     }
   }
+  LOG_WITH_FUNC(INFO) << "Executing: " << query;
   RETURN_NOT_OK(conn.Execute(query));
 
   // Only check the schema name if it is set AND we created the table with a valid pgschema_name.
diff --git a/src/yb/master/CMakeLists.txt b/src/yb/master/CMakeLists.txt
index 13d472593c..e10ec221d6 100644
--- a/src/yb/master/CMakeLists.txt
+++ b/src/yb/master/CMakeLists.txt
@@ -136,6 +136,7 @@ set(MASTER_SRCS
   util/yql_vtable_helpers.cc
   xcluster/add_table_to_xcluster_source_task.cc
   xcluster/add_table_to_xcluster_target_task.cc
+  xcluster/master_xcluster_util.cc
   xcluster/xcluster_catalog_entity.cc
   xcluster/xcluster_config.cc
   xcluster/xcluster_consumer_metrics.cc
diff --git a/src/yb/master/catalog_entity_info.cc b/src/yb/master/catalog_entity_info.cc
index 5863231185..fe1dc554ad 100644
--- a/src/yb/master/catalog_entity_info.cc
+++ b/src/yb/master/catalog_entity_info.cc
@@ -960,6 +960,30 @@ bool TableInfo::IsColocatedUserTable() const {
   return colocated() && !IsColocationParentTable();
 }
 
+bool TableInfo::IsSequencesSystemTable() const {
+  if (GetTableType() == PGSQL_TABLE_TYPE && !IsColocationParentTable()) {
+    // This case commonly occurs during unit testing. Avoid unnecessary assert within Get().
+    if (!IsPgsqlId(namespace_id()) || !IsPgsqlId(id())) {
+      LOG(WARNING) << "Not PGSQL IDs " << namespace_id() << ", " << id();
+      return false;
+    }
+    Result<uint32_t> database_oid = GetPgsqlDatabaseOid(namespace_id());
+    if (!database_oid.ok()) {
+      LOG(WARNING) << "Invalid Namespace ID " << namespace_id();
+      return false;
+    }
+    Result<uint32_t> table_oid = GetPgsqlTableOid(id());
+    if (!table_oid.ok()) {
+      LOG(WARNING) << "Invalid Table ID " << id();
+      return false;
+    }
+    if (*database_oid == kPgSequencesDataDatabaseOid && *table_oid == kPgSequencesDataTableOid) {
+      return true;
+    }
+  }
+  return false;
+}
+
 TablespaceId TableInfo::TablespaceIdForTableCreation() const {
   SharedLock<decltype(lock_)> l(lock_);
   return tablespace_id_for_table_creation_;
@@ -1293,6 +1317,11 @@ Status UniverseReplicationInfo::GetSetupUniverseReplicationErrorStatus() const {
   return setup_universe_replication_error_;
 }
 
+bool UniverseReplicationInfo::IsDbScoped() const {
+  auto l = LockForRead();
+  return l->pb.has_db_scoped_info() && l->pb.db_scoped_info().namespace_infos_size() > 0;
+}
+
 // ================================================================================================
 // PersistentUniverseReplicationBootstrapInfo
 // ================================================================================================
diff --git a/src/yb/master/catalog_entity_info.h b/src/yb/master/catalog_entity_info.h
index b01af5f63d..fff0cee48f 100644
--- a/src/yb/master/catalog_entity_info.h
+++ b/src/yb/master/catalog_entity_info.h
@@ -725,6 +725,7 @@ class TableInfo : public RefCountedThreadSafe<TableInfo>,
   bool IsColocatedDbParentTable() const;
   bool IsTablegroupParentTable() const;
   bool IsColocatedUserTable() const;
+  bool IsSequencesSystemTable() const;
 
   // Provides the ID of the tablespace that will be used to determine
   // where the tablets for this table should be placed when the table
@@ -1236,6 +1237,8 @@ class UniverseReplicationInfo : public UniverseReplicationInfoBase,
   // Get the Status of the last error from the current SetupUniverseReplication.
   Status GetSetupUniverseReplicationErrorStatus() const;
 
+  bool IsDbScoped() const;
+
  private:
   friend class RefCountedThreadSafe<UniverseReplicationInfo>;
   virtual ~UniverseReplicationInfo() = default;
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 7ee64af120..3fc3f6e41c 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -7455,10 +7455,8 @@ Status CatalogManager::GetTableSchemaInternal(const GetTableSchemaRequestPB* req
 
   // Due to pgschema_name being added after 2.13, older YSQL tables may not have this field.
   // So backfill pgschema_name for older YSQL tables. Skip for some special cases.
-  if (l->table_type() == TableType::PGSQL_TABLE_TYPE &&
-      resp->schema().pgschema_name().empty() &&
-      !table->is_system() &&
-      !IsSequencesSystemTable(*table) &&
+  if (l->table_type() == TableType::PGSQL_TABLE_TYPE && resp->schema().pgschema_name().empty() &&
+      !table->is_system() && !table->IsSequencesSystemTable() &&
       !table->IsColocationParentTable()) {
     SharedLock lock(mutex_);
     TRACE("Acquired catalog manager lock for schema name lookup");
@@ -7934,7 +7932,7 @@ bool CatalogManager::IsUserCreatedTable(const TableInfo& table) const {
 
 bool CatalogManager::IsUserCreatedTableUnlocked(const TableInfo& table) const {
   if (table.GetTableType() == PGSQL_TABLE_TYPE || table.GetTableType() == YQL_TABLE_TYPE) {
-    if (!IsSystemTable(table) && !IsSequencesSystemTable(table) &&
+    if (!IsSystemTable(table) && !table.IsSequencesSystemTable() &&
         GetNamespaceNameUnlocked(table.namespace_id()) != kSystemNamespaceName &&
         !table.IsColocationParentTable()) {
       return true;
@@ -7961,30 +7959,6 @@ bool CatalogManager::IsUserIndexUnlocked(const TableInfo& table) const {
   return IsUserCreatedTableUnlocked(table) && !table.indexed_table_id().empty();
 }
 
-bool CatalogManager::IsSequencesSystemTable(const TableInfo& table) const {
-  if (table.GetTableType() == PGSQL_TABLE_TYPE && !table.IsColocationParentTable()) {
-    // This case commonly occurs during unit testing. Avoid unnecessary assert within Get().
-    if (!IsPgsqlId(table.namespace_id()) || !IsPgsqlId(table.id())) {
-      LOG(WARNING) << "Not PGSQL IDs " << table.namespace_id() << ", " << table.id();
-      return false;
-    }
-    Result<uint32_t> database_oid = GetPgsqlDatabaseOid(table.namespace_id());
-    if (!database_oid.ok()) {
-      LOG(WARNING) << "Invalid Namespace ID " << table.namespace_id();
-      return false;
-    }
-    Result<uint32_t> table_oid = GetPgsqlTableOid(table.id());
-    if (!table_oid.ok()) {
-      LOG(WARNING) << "Invalid Table ID " << table.id();
-      return false;
-    }
-    if (*database_oid == kPgSequencesDataDatabaseOid && *table_oid == kPgSequencesDataTableOid) {
-      return true;
-    }
-  }
-  return false;
-}
-
 bool CatalogManager::IsMatviewTable(const TableInfo& table) const {
   return table.GetTableType() == PGSQL_TABLE_TYPE && table.is_matview();
 }
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index 2c796ad529..c567178f75 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -788,9 +788,6 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
   bool IsUserIndex(const TableInfo& table) const override EXCLUDES(mutex_);
   bool IsUserIndexUnlocked(const TableInfo& table) const REQUIRES_SHARED(mutex_);
 
-  // Is the table a special sequences system table?
-  bool IsSequencesSystemTable(const TableInfo& table) const;
-
   // Is the table a materialized view?
   bool IsMatviewTable(const TableInfo& table) const;
 
@@ -2870,7 +2867,7 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
   // updates consumer_table_id with the new table id. Return the consumer table schema if the
   // validation is successful.
   Status ValidateTableSchemaForXCluster(
-      const std::shared_ptr<client::YBTableInfo>& info, const SetupReplicationInfo& setup_info,
+      const client::YBTableInfo& info, const SetupReplicationInfo& setup_info,
       GetTableSchemaResponsePB* resp);
 
   // Adds a validated table to the sys catalog table map for the given universe
@@ -2911,9 +2908,13 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
       const SetupReplicationInfo& setup_info, const Status& s);
   void GetTablegroupSchemaCallback(
       const xcluster::ReplicationGroupId& replication_group_id,
-      const std::shared_ptr<std::vector<client::YBTableInfo>>& info,
+      const std::shared_ptr<std::vector<client::YBTableInfo>>& infos,
       const TablegroupId& producer_tablegroup_id, const SetupReplicationInfo& setup_info,
       const Status& s);
+  Status GetTablegroupSchemaCallbackInternal(
+      scoped_refptr<UniverseReplicationInfo>& universe,
+      const std::vector<client::YBTableInfo>& infos, const TablegroupId& producer_tablegroup_id,
+      const SetupReplicationInfo& setup_info, const Status& s);
   void GetColocatedTabletSchemaCallback(
       const xcluster::ReplicationGroupId& replication_group_id,
       const std::shared_ptr<std::vector<client::YBTableInfo>>& info,
diff --git a/src/yb/master/xcluster/add_table_to_xcluster_target_task.cc b/src/yb/master/xcluster/add_table_to_xcluster_target_task.cc
index e7648228b0..df75211cde 100644
--- a/src/yb/master/xcluster/add_table_to_xcluster_target_task.cc
+++ b/src/yb/master/xcluster/add_table_to_xcluster_target_task.cc
@@ -51,7 +51,7 @@ AddTableToXClusterTargetTask::AddTableToXClusterTargetTask(
           std::move(epoch)),
       universe_(universe),
       xcluster_manager_(*catalog_manager.GetXClusterManager()) {
-  is_db_scoped_ = universe_->LockForRead()->pb.has_db_scoped_info();
+  is_db_scoped_ = universe_->IsDbScoped();
 }
 
 std::string AddTableToXClusterTargetTask::description() const {
diff --git a/src/yb/master/xcluster/master_xcluster_util.cc b/src/yb/master/xcluster/master_xcluster_util.cc
new file mode 100644
index 0000000000..802435d1b5
--- /dev/null
+++ b/src/yb/master/xcluster/master_xcluster_util.cc
@@ -0,0 +1,58 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/master/xcluster/master_xcluster_util.h"
+#include "yb/common/common_types.pb.h"
+#include "yb/master/catalog_entity_info.h"
+
+namespace yb::master {
+
+bool IsTableEligibleForXClusterReplication(const master::TableInfo& table) {
+  if (table.GetTableType() != PGSQL_TABLE_TYPE || table.is_system()) {
+    // DB Scoped replication Limited to ysql databases.
+    // System tables are not replicated. DDLs statements will be replicated and executed on the
+    // target universe to handle catalog changes.
+    return false;
+  }
+
+  if (table.IsColocationParentTable()) {
+    // The colocated parent table needs to be replicated.
+    return true;
+  }
+
+  if (table.is_matview()) {
+    // Materialized views need not be replicated, since they are not modified. Every time the view
+    // is refreshed, new tablets are created. The same refresh can just run on the target universe.
+    return false;
+  }
+
+  if (table.IsColocatedUserTable()) {
+    // Only the colocated parent table needs to be replicated.
+    return false;
+  }
+
+  if (table.IsSequencesSystemTable()) {
+    // xCluster does not yet support replication of sequences.
+    return false;
+  }
+
+  if (table.name() == xcluster::kDDLReplicatedTableName &&
+      table.pgschema_name() == xcluster::kDDLQueuePgSchemaName) {
+    // replicated_ddls is only used on the target, so we do not want to replicate it.
+    return false;
+  }
+
+  return true;
+}
+
+}  // namespace yb::master
diff --git a/src/yb/master/xcluster/master_xcluster_util.h b/src/yb/master/xcluster/master_xcluster_util.h
new file mode 100644
index 0000000000..28deb2eb1c
--- /dev/null
+++ b/src/yb/master/xcluster/master_xcluster_util.h
@@ -0,0 +1,22 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+namespace yb::master {
+class TableInfo;
+
+// Should the table be automatically added to xCluster replication?
+bool IsTableEligibleForXClusterReplication(const master::TableInfo& table);
+
+}  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
index c670d83334..83e10b4624 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
@@ -188,7 +188,11 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
   }
 
   void CreateNamespace(const NamespaceName& namespace_name, const NamespaceId& namespace_id) {
-    namespace_ids[namespace_name] = namespace_id;
+    scoped_refptr<NamespaceInfo> ns = new NamespaceInfo(namespace_id, /*tasks_tracker=*/nullptr);
+    auto l = ns->LockForWrite();
+    l.mutable_data()->pb.set_name(namespace_name);
+    l.Commit();
+    namespace_infos[namespace_id] = std::move(ns);
   }
 
   TableInfoPtr CreateTable(
@@ -229,25 +233,15 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
   }
 
   std::unordered_map<NamespaceId, std::vector<TableInfoPtr>> namespace_tables;
-  std::unordered_map<NamespaceName, NamespaceId> namespace_ids;
+  std::unordered_map<NamespaceId, scoped_refptr<NamespaceInfo>> namespace_infos;
   std::unordered_set<xrepl::StreamId> xcluster_streams;
   std::unique_ptr<ThreadPool> thread_pool;
   std::unique_ptr<rpc::Messenger> messenger;
   std::unique_ptr<XClusterOutboundReplicationGroupTaskFactoryMocked> task_factory;
 
   XClusterOutboundReplicationGroup::HelperFunctions helper_functions = {
-      .get_namespace_id_func =
-          [this](YQLDatabase, const NamespaceName& namespace_name) {
-            return namespace_ids[namespace_name];
-          },
-      .get_namespace_name_func = [this](const NamespaceId& namespace_id) -> Result<NamespaceName> {
-        for (const auto& [name, id] : namespace_ids) {
-          if (id == namespace_id) {
-            return name;
-          }
-        }
-        return STATUS_FORMAT(NotFound, "Namespace $0 not found", namespace_id);
-      },
+      .get_namespace_func =
+          std::bind(&XClusterOutboundReplicationGroupMockedTest::GetNamespace, this, _1),
       .get_tables_func =
           [this](const NamespaceId& namespace_id) { return namespace_tables[namespace_id]; },
       .create_xcluster_streams_func =
@@ -281,6 +275,23 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
           [](const LeaderEpoch&, XClusterOutboundReplicationGroupInfo*) { return Status::OK(); },
   };
 
+  Result<scoped_refptr<NamespaceInfo>> GetNamespace(const NamespaceIdentifierPB& ns_identifier) {
+    scoped_refptr<NamespaceInfo> ns_info;
+    if (ns_identifier.has_id()) {
+      ns_info = FindPtrOrNull(namespace_infos, ns_identifier.id());
+    } else {
+      for (const auto& [_, namespace_info] : namespace_infos) {
+        if (namespace_info->name() == ns_identifier.name()) {
+          ns_info = namespace_info;
+          break;
+        }
+      }
+    }
+
+    SCHECK(ns_info, NotFound, "Namespace not found", ns_identifier.DebugString());
+    return ns_info;
+  }
+
   void VerifyNamespaceCheckpointInfo(
       const TableId& table_id1, const TableId& table_id2, const NamespaceCheckpointInfo& ns_info,
       bool skip_schema_name_check = false) {
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
index e2a5b4ffde..f4ce2348c0 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
@@ -13,6 +13,7 @@
 
 #include "yb/master/xcluster/xcluster_outbound_replication_group.h"
 #include "yb/client/xcluster_client.h"
+#include "yb/common/colocated_util.h"
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/xcluster/xcluster_outbound_replication_group_tasks.h"
 #include "yb/util/is_operation_done_result.h"
@@ -326,13 +327,49 @@ void XClusterOutboundReplicationGroup::MarkCheckpointNamespaceAsFailed(
   WARN_NOT_OK(Upsert(*lock_result, epoch), ToString());
 }
 
+Result<scoped_refptr<NamespaceInfo>> XClusterOutboundReplicationGroup::GetYbNamespaceInfo(
+    const NamespaceId& namespace_id) const {
+  NamespaceIdentifierPB ns_id_pb;
+  ns_id_pb.set_id(namespace_id);
+  return helper_functions_.get_namespace_func(ns_id_pb);
+}
+
+Result<NamespaceId> XClusterOutboundReplicationGroup::GetNamespaceId(
+    const NamespaceName& namespace_name) const {
+  NamespaceIdentifierPB ns_id_pb;
+  ns_id_pb.set_name(namespace_name);
+  ns_id_pb.set_database_type(YQLDatabase::YQL_DATABASE_PGSQL);
+  auto ns = VERIFY_RESULT(helper_functions_.get_namespace_func(ns_id_pb));
+  return ns->id();
+}
+
+Result<NamespaceName> XClusterOutboundReplicationGroup::GetNamespaceName(
+    const NamespaceId& namespace_id) const {
+  return VERIFY_RESULT(GetYbNamespaceInfo(namespace_id))->name();
+}
+
 Result<XClusterOutboundReplicationGroup::NamespaceInfoPB>
 XClusterOutboundReplicationGroup::CreateNamespaceInfo(
     const NamespaceId& namespace_id, const LeaderEpoch& epoch) {
   auto table_infos = VERIFY_RESULT(helper_functions_.get_tables_func(namespace_id));
   VLOG_WITH_PREFIX_AND_FUNC(1) << "Tables: " << yb::ToString(table_infos);
 
-  SCHECK(!table_infos.empty(), InvalidArgument, "No tables to bootstrap");
+  SCHECK(
+      !table_infos.empty(), InvalidArgument,
+      "Database should have at least one table in order to be part of xCluster replication");
+
+  auto yb_ns_info = VERIFY_RESULT(GetYbNamespaceInfo(namespace_id));
+  if (yb_ns_info->colocated()) {
+    bool has_any_colocated_table =
+        std::any_of(table_infos.begin(), table_infos.end(), [](const TableInfoPtr& table_info) {
+          return IsColocatedDbTablegroupParentTableId(table_info->id());
+        });
+    SCHECK(
+        has_any_colocated_table, InvalidArgument,
+        "Colocated database should have at least one colocated table in order to be part of "
+        "xCluster replication");
+  }
+
   NamespaceInfoPB ns_info;
   ns_info.set_state(NamespaceInfoPB::CHECKPOINTING);
 
@@ -352,8 +389,7 @@ Result<NamespaceId> XClusterOutboundReplicationGroup::AddNamespaceInternal(
   SCHECK(!namespace_name.empty(), InvalidArgument, "Namespace name cannot be empty");
   VLOG_WITH_PREFIX_AND_FUNC(1) << namespace_name;
 
-  auto namespace_id = VERIFY_RESULT(
-      helper_functions_.get_namespace_id_func(YQLDatabase::YQL_DATABASE_PGSQL, namespace_name));
+  auto namespace_id = VERIFY_RESULT(GetNamespaceId(namespace_name));
 
   auto& outbound_group_pb = l.mutable_data()->pb;
 
@@ -573,9 +609,7 @@ Status XClusterOutboundReplicationGroup::CreateXClusterReplication(
         Format("Namespace $0 is not yet ready to start replicating", ns_id));
 
     namespace_ids.push_back(ns_id);
-    namespace_names.push_back(VERIFY_RESULT(helper_functions_.get_namespace_name_func(ns_id)));
-
-    auto all_tables = VERIFY_RESULT(helper_functions_.get_tables_func(ns_id));
+    namespace_names.push_back(VERIFY_RESULT(GetNamespaceName(ns_id)));
 
     for (const auto& [table_id, table_info] : ns_info.table_infos()) {
       if (!table_info.is_part_of_initial_bootstrap()) {
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.h b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
index 7f0a5d7f31..ea87afceea 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.h
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
@@ -37,9 +37,8 @@ class XClusterOutboundReplicationGroup
       public CatalogEntityWithTasks {
  public:
   struct HelperFunctions {
-    const std::function<Result<NamespaceId>(YQLDatabase, const NamespaceName&)>
-        get_namespace_id_func;
-    const std::function<Result<NamespaceName>(const NamespaceId&)> get_namespace_name_func;
+    const std::function<Result<scoped_refptr<NamespaceInfo>>(const NamespaceIdentifierPB&)>
+        get_namespace_func;
     const std::function<Result<std::vector<TableInfoPtr>>(const NamespaceId&)> get_tables_func;
     const std::function<Result<std::unique_ptr<XClusterCreateStreamsContext>>(
         const std::vector<TableId>&, const LeaderEpoch&)>
@@ -127,6 +126,10 @@ class XClusterOutboundReplicationGroup
       REQUIRES_SHARED(mutex_);
   Result<XClusterOutboundReplicationGroupInfo::WriteLock> LockForWrite() REQUIRES(mutex_);
 
+  Result<scoped_refptr<NamespaceInfo>> GetYbNamespaceInfo(const NamespaceId& namespace_id) const;
+  Result<NamespaceId> GetNamespaceId(const NamespaceName& namespace_name) const;
+  Result<NamespaceName> GetNamespaceName(const NamespaceId& namespace_id) const;
+
   Result<NamespaceId> AddNamespaceInternal(
       const NamespaceName& namespace_name, XClusterOutboundReplicationGroupInfo::WriteLock& l,
       const LeaderEpoch& epoch) REQUIRES(mutex_);
diff --git a/src/yb/master/xcluster/xcluster_replication_group.cc b/src/yb/master/xcluster/xcluster_replication_group.cc
index 3b9a9e76df..6cd18eef2c 100644
--- a/src/yb/master/xcluster/xcluster_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_replication_group.cc
@@ -20,6 +20,7 @@
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/catalog_manager_util.h"
+#include "yb/master/xcluster/master_xcluster_util.h"
 #include "yb/util/is_operation_done_result.h"
 #include "yb/master/xcluster_rpc_tasks.h"
 #include "yb/master/xcluster/xcluster_manager_if.h"
@@ -267,12 +268,7 @@ Result<bool> ShouldAddTableToReplicationGroup(
     CatalogManager& catalog_manager) {
   const auto& table_pb = table_info.old_pb();
 
-  // Only user created YSQL tables should be automatically added to xCluster replication.
-  // xCluster DDL Repl: replicated_ddls is only used on the target, so don't replicate it either.
-  if (table_pb.colocated() || table_pb.table_type() != PGSQL_TABLE_TYPE ||
-      !catalog_manager.IsUserCreatedTable(table_info) ||
-      (table_pb.name() == xcluster::kDDLReplicatedTableName &&
-       table_pb.schema().pgschema_name() == xcluster::kDDLQueuePgSchemaName)) {
+  if (!IsTableEligibleForXClusterReplication(table_info)) {
     return false;
   }
 
@@ -333,16 +329,23 @@ Result<bool> ShouldAddTableToReplicationGroup(
     }
   }
 
+  SCHECK(
+      !table_info.IsColocationParentTable(), IllegalState,
+      Format(
+          "Colocated parent tables can only be added during the initial xCluster replication "
+          "setup: $0",
+          table_info.ToString()));
+
   return true;
 }
 
 Result<NamespaceId> GetProducerNamespaceId(
     UniverseReplicationInfo& universe, const NamespaceId& consumer_namespace_id) {
-  auto l = universe.LockForRead();
   SCHECK(
-      l->pb.has_db_scoped_info(), IllegalState, "Replication group $0 is not db-scoped",
+      universe.IsDbScoped(), IllegalState, "Replication group $0 is not db-scoped",
       universe.ToString());
 
+  auto l = universe.LockForRead();
   auto opt_namespace_id = GetProducerNamespaceIdInternal(l->pb, consumer_namespace_id);
   SCHECK_FORMAT(
       opt_namespace_id, NotFound, "Namespace $0 not found in replication group $1",
@@ -353,11 +356,10 @@ Result<NamespaceId> GetProducerNamespaceId(
 
 bool IncludesConsumerNamespace(
     UniverseReplicationInfo& universe, const NamespaceId& consumer_namespace_id) {
-  auto l = universe.LockForRead();
-  if (!l->pb.has_db_scoped_info()) {
+  if (!universe.IsDbScoped()) {
     return false;
   }
-
+  auto l = universe.LockForRead();
   auto opt_namespace_id = GetProducerNamespaceIdInternal(l->pb, consumer_namespace_id);
   return opt_namespace_id.has_value();
 }
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index c5c79fc50f..dc8ceba137 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -19,6 +19,7 @@
 #include "yb/cdc/xcluster_types.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master.h"
+#include "yb/master/xcluster/master_xcluster_util.h"
 #include "yb/master/xcluster/xcluster_status.h"
 #include "yb/util/is_operation_done_result.h"
 #include "yb/master/xcluster/add_table_to_xcluster_source_task.h"
@@ -35,38 +36,6 @@ using namespace std::placeholders;
 
 namespace yb::master {
 
-namespace {
-// Should the table be part of xCluster replication?
-bool ShouldReplicateTable(const TableInfoPtr& table) {
-  if (table->GetTableType() != PGSQL_TABLE_TYPE || table->is_system()) {
-    // Limited to ysql databases.
-    // System tables are not replicated. DDLs statements will be replicated and executed on the
-    // target universe to handle catalog changes.
-    return false;
-  }
-
-  if (table->is_matview()) {
-    // Materialized views need not be replicated, since they are not modified. Every time the view
-    // is refreshed, new tablets are created. The same refresh can just run on the target universe.
-    return false;
-  }
-
-  if (table->IsColocatedUserTable()) {
-    // Only the colocated parent table needs to be replicated.
-    return false;
-  }
-
-  if (table->name() == xcluster::kDDLReplicatedTableName &&
-      table->pgschema_name() == xcluster::kDDLQueuePgSchemaName) {
-    // replicated_ddls is only used on the target, so we do not want to replicate it.
-    return false;
-  }
-
-  return true;
-}
-
-}  // namespace
-
 XClusterSourceManager::XClusterSourceManager(
     Master& master, CatalogManager& catalog_manager, SysCatalogTable& sys_catalog)
     : master_(master), catalog_manager_(catalog_manager), sys_catalog_(sys_catalog) {}
@@ -206,14 +175,9 @@ XClusterSourceManager::InitOutboundReplicationGroup(
     const xcluster::ReplicationGroupId& replication_group_id,
     const SysXClusterOutboundReplicationGroupEntryPB& metadata) {
   XClusterOutboundReplicationGroup::HelperFunctions helper_functions = {
-      .get_namespace_id_func =
-          [&catalog_manager = catalog_manager_](
-              YQLDatabase db_type, const NamespaceName& namespace_name) {
-            return catalog_manager.GetNamespaceId(db_type, namespace_name);
-          },
-      .get_namespace_name_func =
-          [&catalog_manager = catalog_manager_](const NamespaceId& namespace_id) {
-            return catalog_manager.GetNamespaceName(namespace_id);
+      .get_namespace_func =
+          [&catalog_manager = catalog_manager_](const NamespaceIdentifierPB& ns_identifier) {
+            return catalog_manager.FindNamespace(ns_identifier);
           },
       .get_tables_func = std::bind(&XClusterSourceManager::GetTablesToReplicate, this, _1),
       .create_xcluster_streams_func =
@@ -262,14 +226,16 @@ XClusterSourceManager::GetOutboundReplicationGroup(
 Result<std::vector<TableInfoPtr>> XClusterSourceManager::GetTablesToReplicate(
     const NamespaceId& namespace_id) {
   auto table_infos = VERIFY_RESULT(catalog_manager_.GetTableInfosForNamespace(namespace_id));
-  EraseIf([](const TableInfoPtr& table) { return !ShouldReplicateTable(table); }, &table_infos);
+  EraseIf(
+      [](const TableInfoPtr& table) { return !IsTableEligibleForXClusterReplication(*table); },
+      &table_infos);
   return table_infos;
 }
 
 std::vector<std::shared_ptr<PostTabletCreateTaskBase>>
 XClusterSourceManager::GetPostTabletCreateTasks(
     const TableInfoPtr& table_info, const LeaderEpoch& epoch) {
-  if (!ShouldReplicateTable(table_info)) {
+  if (!IsTableEligibleForXClusterReplication(*table_info)) {
     return {};
   }
 
diff --git a/src/yb/master/xrepl_catalog_manager.cc b/src/yb/master/xrepl_catalog_manager.cc
index 8b28ef9011..efff5a5475 100644
--- a/src/yb/master/xrepl_catalog_manager.cc
+++ b/src/yb/master/xrepl_catalog_manager.cc
@@ -3570,7 +3570,7 @@ Status CatalogManager::ValidateTableAndCreateCdcStreams(
   l.Commit();
 
   GetTableSchemaResponsePB consumer_schema;
-  RETURN_NOT_OK(ValidateTableSchemaForXCluster(producer_info, setup_info, &consumer_schema));
+  RETURN_NOT_OK(ValidateTableSchemaForXCluster(*producer_info, setup_info, &consumer_schema));
 
   // If Bootstrap Id is passed in then it must be provided for all tables.
   const auto& producer_bootstrap_ids = setup_info.table_bootstrap_ids;
@@ -3610,42 +3610,39 @@ void CatalogManager::GetTablegroupSchemaCallback(
     }
   }
 
-  if (!s.ok()) {
-    MarkUniverseReplicationFailed(universe, s);
+  auto status =
+      GetTablegroupSchemaCallbackInternal(universe, *infos, producer_tablegroup_id, setup_info, s);
+  if (!status.ok()) {
     std::ostringstream oss;
     for (size_t i = 0; i < infos->size(); ++i) {
       oss << ((i == 0) ? "" : ", ") << (*infos)[i].table_id;
     }
-    LOG(ERROR) << "Error getting schema for tables: [ " << oss.str() << " ]: " << s;
-    return;
+    LOG(ERROR) << "Error processing for tables: [ " << oss.str()
+               << " ] for xCluster replication group " << replication_group_id << ": " << status;
+    MarkUniverseReplicationFailed(universe, status);
   }
+}
 
-  if (infos->empty()) {
-    LOG(WARNING) << "Received empty list of tables to validate: " << s;
-    return;
-  }
+Status CatalogManager::GetTablegroupSchemaCallbackInternal(
+    scoped_refptr<UniverseReplicationInfo>& universe, const std::vector<client::YBTableInfo>& infos,
+    const TablegroupId& producer_tablegroup_id, const SetupReplicationInfo& setup_info,
+    const Status& s) {
+  RETURN_NOT_OK(s);
+
+  SCHECK(!infos.empty(), IllegalState, Format("Tablegroup $0 is empty", producer_tablegroup_id));
 
   // validated_consumer_tables contains the table IDs corresponding to that
   // from the producer tables.
   std::unordered_set<TableId> validated_consumer_tables;
   ColocationSchemaVersions colocated_schema_versions;
-  colocated_schema_versions.reserve(infos->size());
-  for (const auto& info : *infos) {
+  colocated_schema_versions.reserve(infos.size());
+  for (const auto& info : infos) {
     // Validate each of the member table in the tablegroup.
     GetTableSchemaResponsePB resp;
-    Status table_status = ValidateTableSchemaForXCluster(
-        std::make_shared<client::YBTableInfo>(info), setup_info, &resp);
+    RETURN_NOT_OK(ValidateTableSchemaForXCluster(info, setup_info, &resp));
 
-    if (!table_status.ok()) {
-      MarkUniverseReplicationFailed(universe, table_status);
-      LOG(ERROR) << "Found error while validating table schema for table " << info.table_id << ": "
-                 << table_status;
-      return;
-    }
-
-    colocated_schema_versions.emplace_back(resp.schema().colocated_table_id().colocation_id(),
-                                           info.schema.version(),
-                                           resp.version());
+    colocated_schema_versions.emplace_back(
+        resp.schema().colocated_table_id().colocation_id(), info.schema.version(), resp.version());
     validated_consumer_tables.insert(resp.identifier().table_id());
   }
 
@@ -3657,23 +3654,16 @@ void CatalogManager::GetTablegroupSchemaCallback(
   {
     SharedLock lock(mutex_);
     const auto* tablegroup = tablegroup_manager_->FindByTable(*validated_consumer_tables.begin());
-    if (!tablegroup) {
-      std::string message = Format(
-          "No consumer tablegroup found for producer tablegroup: $0", producer_tablegroup_id);
-      MarkUniverseReplicationFailed(universe, STATUS(IllegalState, message));
-      LOG(ERROR) << message;
-      return;
-    }
+    SCHECK(
+        tablegroup, IllegalState,
+        Format("No consumer tablegroup found for producer tablegroup: $0", producer_tablegroup_id));
+
     consumer_tablegroup_id = tablegroup->id();
 
-    scoped_refptr<NamespaceInfo> ns = FindPtrOrNull(namespace_ids_map_, tablegroup->database_id());
-    if (ns == nullptr) {
-      std::string message =
-          Format("Could not find namespace by namespace id $0", tablegroup->database_id());
-      MarkUniverseReplicationFailed(universe, STATUS(IllegalState, message));
-      LOG(ERROR) << message;
-      return;
-    }
+    auto ns = FindPtrOrNull(namespace_ids_map_, tablegroup->database_id());
+    SCHECK(
+        ns, IllegalState,
+        Format("Could not find namespace by namespace id $0", tablegroup->database_id()));
     colocated_database = ns->colocated();
   }
 
@@ -3684,14 +3674,13 @@ void CatalogManager::GetTablegroupSchemaCallback(
     GetTablegroupSchemaRequestPB req;
     GetTablegroupSchemaResponsePB resp;
     req.mutable_tablegroup()->set_id(consumer_tablegroup_id);
-    Status status = GetTablegroupSchema(&req, &resp);
-    if (!status.ok() || resp.has_error()) {
-      std::string message =
-          Format("Error when getting consumer tablegroup schema: $0", consumer_tablegroup_id);
-      MarkUniverseReplicationFailed(universe, STATUS(IllegalState, message));
-      LOG(ERROR) << message;
-      return;
+    auto status = GetTablegroupSchema(&req, &resp);
+    if (status.ok() && resp.has_error()) {
+      status = StatusFromPB(resp.error().status());
     }
+    RETURN_NOT_OK_PREPEND(
+        status,
+        Format("Error when getting consumer tablegroup schema: $0", consumer_tablegroup_id));
 
     for (const auto& info : resp.get_table_schema_response_pbs()) {
       tables_in_consumer_tablegroup.insert(info.identifier().table_id());
@@ -3699,23 +3688,21 @@ void CatalogManager::GetTablegroupSchemaCallback(
   }
 
   if (validated_consumer_tables != tables_in_consumer_tablegroup) {
-    std::string message = Format(
-        "Mismatch between tables associated with producer tablegroup $0 and "
-        "tables in consumer tablegroup $1: ($2) vs ($3).",
-        producer_tablegroup_id, consumer_tablegroup_id, AsString(validated_consumer_tables),
-        AsString(tables_in_consumer_tablegroup));
-    MarkUniverseReplicationFailed(universe, STATUS(IllegalState, message));
-    LOG(ERROR) << message;
-    return;
+    return STATUS(
+        IllegalState,
+        Format(
+            "Mismatch between tables associated with producer tablegroup $0 and "
+            "tables in consumer tablegroup $1: ($2) vs ($3).",
+            producer_tablegroup_id, consumer_tablegroup_id, AsString(validated_consumer_tables),
+            AsString(tables_in_consumer_tablegroup)));
   }
 
-  Status status = IsBootstrapRequiredOnProducer(
-      universe, producer_tablegroup_id, setup_info.table_bootstrap_ids);
-  if (!status.ok()) {
-    MarkUniverseReplicationFailed(universe, status);
-    LOG(ERROR) << "Found error while checking if bootstrap is required for table "
-               << producer_tablegroup_id << ": " << status;
-  }
+  RETURN_NOT_OK_PREPEND(
+      IsBootstrapRequiredOnProducer(
+          universe, producer_tablegroup_id, setup_info.table_bootstrap_ids),
+      Format(
+          "Found error while checking if bootstrap is required for table $0",
+          producer_tablegroup_id));
 
   TableId producer_parent_table_id;
   TableId consumer_parent_table_id;
@@ -3729,25 +3716,15 @@ void CatalogManager::GetTablegroupSchemaCallback(
 
   {
     SharedLock lock(mutex_);
-    if (xcluster_consumer_table_stream_ids_map_.contains(consumer_parent_table_id)) {
-      std::string message = "N:1 replication topology not supported";
-      MarkUniverseReplicationFailed(universe, STATUS(IllegalState, message));
-      LOG(ERROR) << message;
-      return;
-    }
+    SCHECK(
+        !xcluster_consumer_table_stream_ids_map_.contains(consumer_parent_table_id), IllegalState,
+        "N:1 replication topology not supported");
   }
 
-  status = AddValidatedTableAndCreateCdcStreams(
-      universe,
-      setup_info.table_bootstrap_ids,
-      producer_parent_table_id,
-      consumer_parent_table_id,
-      colocated_schema_versions);
-  if (!status.ok()) {
-    LOG(ERROR) << "Found error while adding validated table to system catalog: "
-               << producer_tablegroup_id << ": " << status;
-    return;
-  }
+  RETURN_NOT_OK(AddValidatedTableAndCreateCdcStreams(
+      universe, setup_info.table_bootstrap_ids, producer_parent_table_id, consumer_parent_table_id,
+      colocated_schema_versions));
+  return Status::OK();
 }
 
 void CatalogManager::GetColocatedTabletSchemaCallback(
@@ -3798,8 +3775,7 @@ void CatalogManager::GetColocatedTabletSchemaCallback(
     }
     // Validate each table, and get the parent colocated table id for the consumer.
     GetTableSchemaResponsePB resp;
-    Status table_status = ValidateTableSchemaForXCluster(
-        std::make_shared<client::YBTableInfo>(info), setup_info, &resp);
+    Status table_status = ValidateTableSchemaForXCluster(info, setup_info, &resp);
     if (!table_status.ok()) {
       MarkUniverseReplicationFailed(universe, table_status);
       LOG(ERROR) << "Found error while validating table schema for table " << info.table_id << ": "
@@ -6890,24 +6866,24 @@ Status CatalogManager::BumpVersionAndStoreClusterConfig(
 }
 
 Status CatalogManager::ValidateTableSchemaForXCluster(
-    const std::shared_ptr<client::YBTableInfo>& info, const SetupReplicationInfo& setup_info,
+    const client::YBTableInfo& info, const SetupReplicationInfo& setup_info,
     GetTableSchemaResponsePB* resp) {
-  bool is_ysql_table = info->table_type == client::YBTableType::PGSQL_TABLE_TYPE;
+  bool is_ysql_table = info.table_type == client::YBTableType::PGSQL_TABLE_TYPE;
   if (setup_info.transactional && !GetAtomicFlag(&FLAGS_TEST_allow_ycql_transactional_xcluster) &&
       !is_ysql_table) {
     return STATUS_FORMAT(
         NotSupported, "Transactional replication is not supported for non-YSQL tables: $0",
-        info->table_name.ToString());
+        info.table_name.ToString());
   }
 
   // Get corresponding table schema on local universe.
   GetTableSchemaRequestPB req;
 
   auto* table = req.mutable_table();
-  table->set_table_name(info->table_name.table_name());
-  table->mutable_namespace_()->set_name(info->table_name.namespace_name());
+  table->set_table_name(info.table_name.table_name());
+  table->mutable_namespace_()->set_name(info.table_name.namespace_name());
   table->mutable_namespace_()->set_database_type(
-      GetDatabaseTypeForTable(client::ClientToPBTableType(info->table_type)));
+      GetDatabaseTypeForTable(client::ClientToPBTableType(info.table_type)));
 
   // Since YSQL tables are not present in table map, we first need to list tables to get the table
   // ID and then get table schema.
@@ -6915,17 +6891,17 @@ Status CatalogManager::ValidateTableSchemaForXCluster(
   ListTablesRequestPB list_req;
   ListTablesResponsePB list_resp;
 
-  list_req.set_name_filter(info->table_name.table_name());
+  list_req.set_name_filter(info.table_name.table_name());
   Status status = ListTables(&list_req, &list_resp);
   SCHECK(
       status.ok() && !list_resp.has_error(), NotFound,
       Format("Error while listing table: $0", status.ToString()));
 
-  const auto& source_schema = client::internal::GetSchema(info->schema);
+  const auto& source_schema = client::internal::GetSchema(info.schema);
   for (const auto& t : list_resp.tables()) {
     // Check that table name and namespace both match.
-    if (t.name() != info->table_name.table_name() ||
-        t.namespace_().name() != info->table_name.namespace_name()) {
+    if (t.name() != info.table_name.table_name() ||
+        t.namespace_().name() != info.table_name.namespace_name()) {
       continue;
     }
 
@@ -6957,7 +6933,7 @@ Status CatalogManager::ValidateTableSchemaForXCluster(
     if (is_ysql_table && t.has_relation_type() && t.relation_type() == MATVIEW_TABLE_RELATION) {
       return STATUS_FORMAT(
           NotSupported, "Replication is not supported for materialized view: $0",
-          info->table_name.ToString());
+          info.table_name.ToString());
     }
 
     Schema consumer_schema;
@@ -6969,7 +6945,7 @@ Status CatalogManager::ValidateTableSchemaForXCluster(
         Format(
             "Source and target schemas don't match: "
             "Source: $0, Target: $1, Source schema: $2, Target schema: $3",
-            info->table_id, resp->identifier().table_id(), info->schema.ToString(),
+            info.table_id, resp->identifier().table_id(), info.schema.ToString(),
             resp->schema().DebugString()));
     break;
   }
@@ -6977,19 +6953,19 @@ Status CatalogManager::ValidateTableSchemaForXCluster(
   SCHECK(
       table->has_table_id(), NotFound,
       Format(
-          "Could not find matching table for $0$1", info->table_name.ToString(),
+          "Could not find matching table for $0$1", info.table_name.ToString(),
           (is_ysql_table ? " pgschema_name: " + source_schema.SchemaName() : "")));
 
   // Still need to make map of table id to resp table id (to add to validated map)
   // For colocated tables, only add the parent table since we only added the parent table to the
   // original pb (we use the number of tables in the pb to determine when validation is done).
-  if (info->colocated) {
+  if (info.colocated) {
     // We require that colocated tables have the same colocation ID.
     //
     // Backward compatibility: tables created prior to #7378 use YSQL table OID as a colocation ID.
-    auto source_clc_id = info->schema.has_colocation_id()
-                             ? info->schema.colocation_id()
-                             : CHECK_RESULT(GetPgsqlTableOid(info->table_id));
+    auto source_clc_id = info.schema.has_colocation_id()
+                             ? info.schema.colocation_id()
+                             : CHECK_RESULT(GetPgsqlTableOid(info.table_id));
     auto target_clc_id = (resp->schema().has_colocated_table_id() &&
                           resp->schema().colocated_table_id().has_colocation_id())
                              ? resp->schema().colocated_table_id().colocation_id()
@@ -6999,7 +6975,7 @@ Status CatalogManager::ValidateTableSchemaForXCluster(
         Format(
             "Source and target colocation IDs don't match for colocated table: "
             "Source: $0, Target: $1, Source colocation ID: $2, Target colocation ID: $3",
-            info->table_id, resp->identifier().table_id(), source_clc_id, target_clc_id));
+            info.table_id, resp->identifier().table_id(), source_clc_id, target_clc_id));
   }
 
   {
