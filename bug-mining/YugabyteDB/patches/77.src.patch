diff --git a/src/yb/integration-tests/xcluster/xcluster-tablet-split-itest.cc b/src/yb/integration-tests/xcluster/xcluster-tablet-split-itest.cc
index 143d24c6fc..cfca988be9 100644
--- a/src/yb/integration-tests/xcluster/xcluster-tablet-split-itest.cc
+++ b/src/yb/integration-tests/xcluster/xcluster-tablet-split-itest.cc
@@ -1237,11 +1237,9 @@ TEST_F(NotSupportedTabletSplitITest, SplittingWithXClusterReplicationOnProducer)
   auto consumer_cluster =
       ASSERT_RESULT(CreateNewUniverseAndTable("consumer", "C", &consumer_cluster_table));
 
-  ASSERT_OK(tools::RunAdminToolCommand(consumer_cluster->GetMasterAddresses(),
-                                       "setup_universe_replication",
-                                       "",  // Producer cluster id (default is set to "").
-                                       cluster_->GetMasterAddresses(),
-                                       table_->id()));
+  ASSERT_OK(tools::RunAdminToolCommand(
+      consumer_cluster->GetMasterAddresses(), "setup_universe_replication", kProducerClusterId,
+      cluster_->GetMasterAddresses(), table_->id()));
 
   // Try splitting this tablet, and restart the server to ensure split still fails after a restart.
   const auto split_hash_code =
@@ -1249,7 +1247,7 @@ TEST_F(NotSupportedTabletSplitITest, SplittingWithXClusterReplicationOnProducer)
 
   // Now delete replication and verify that the tablet can now be split.
   ASSERT_OK(tools::RunAdminToolCommand(
-      consumer_cluster->GetMasterAddresses(), "delete_universe_replication", ""));
+      consumer_cluster->GetMasterAddresses(), "delete_universe_replication", kProducerClusterId));
   // Deleting cdc streams is async so wait for that to complete.
   ASSERT_OK(WaitFor([&]() -> Result<bool> {
     return SplitTabletAndValidate(split_hash_code, kDefaultNumRows).ok();
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index 11d905cd6c..b5a509893a 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -231,7 +231,7 @@ Status XClusterManager::XClusterCreateOutboundReplicationGroup(
     const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
   SCHECK(FLAGS_enable_xcluster_api_v2, IllegalState, "xCluster API v2 is not enabled.");
-  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id);
   SCHECK(!req->namespace_ids().empty(), InvalidArgument, "Missing Namespace Ids");
 
   std::vector<NamespaceId> namespace_ids;
@@ -249,7 +249,7 @@ Status XClusterManager::XClusterAddNamespaceToOutboundReplicationGroup(
     XClusterAddNamespaceToOutboundReplicationGroupResponsePB* resp, rpc::RpcContext* rpc,
     const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
-  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id, namespace_id);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id, namespace_id);
 
   RETURN_NOT_OK(AddNamespaceToOutboundReplicationGroup(
       xcluster::ReplicationGroupId(req->replication_group_id()), req->namespace_id(), epoch));
@@ -262,7 +262,7 @@ Status XClusterManager::XClusterRemoveNamespaceFromOutboundReplicationGroup(
     XClusterRemoveNamespaceFromOutboundReplicationGroupResponsePB* resp, rpc::RpcContext* rpc,
     const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
-  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id, namespace_id);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id, namespace_id);
 
   std::vector<HostPort> target_master_addresses;
   if (!req->target_master_addresses().empty()) {
@@ -279,7 +279,7 @@ Status XClusterManager::XClusterDeleteOutboundReplicationGroup(
     XClusterDeleteOutboundReplicationGroupResponsePB* resp, rpc::RpcContext* rpc,
     const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
-  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id);
 
   std::vector<HostPort> target_master_addresses;
   if (!req->target_master_addresses().empty()) {
@@ -294,7 +294,7 @@ Status XClusterManager::IsXClusterBootstrapRequired(
     const IsXClusterBootstrapRequiredRequestPB* req, IsXClusterBootstrapRequiredResponsePB* resp,
     rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
-  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id, namespace_id);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id, namespace_id);
 
   auto bootstrap_required = VERIFY_RESULT(IsBootstrapRequired(
       xcluster::ReplicationGroupId(req->replication_group_id()), req->namespace_id()));
@@ -313,7 +313,7 @@ Status XClusterManager::GetXClusterStreams(
     const GetXClusterStreamsRequestPB* req, GetXClusterStreamsResponsePB* resp,
     rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
-  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id, namespace_id);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id, namespace_id);
 
   std::vector<std::pair<TableName, PgSchemaName>> table_names;
   for (const auto& table_name : req->table_infos()) {
@@ -344,7 +344,7 @@ Status XClusterManager::CreateXClusterReplication(
     const CreateXClusterReplicationRequestPB* req, CreateXClusterReplicationResponsePB* resp,
     rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
-  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id);
   SCHECK(
       !req->target_master_addresses().empty(), InvalidArgument, "Missing Target Master addresses");
 
@@ -360,7 +360,7 @@ Status XClusterManager::IsCreateXClusterReplicationDone(
     IsCreateXClusterReplicationDoneResponsePB* resp, rpc::RpcContext* rpc,
     const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
-  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id);
   SCHECK(
       !req->target_master_addresses().empty(), InvalidArgument, "Missing Target Master addresses");
 
@@ -382,7 +382,7 @@ Status XClusterManager::AddNamespaceToXClusterReplication(
     AddNamespaceToXClusterReplicationResponsePB* resp, rpc::RpcContext* rpc,
     const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
-  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id, namespace_id);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id, namespace_id);
   SCHECK(
       !req->target_master_addresses().empty(), InvalidArgument, "Missing Target Master addresses");
 
@@ -399,7 +399,7 @@ Status XClusterManager::IsAlterXClusterReplicationDone(
     IsAlterXClusterReplicationDoneResponsePB* resp, rpc::RpcContext* rpc,
     const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
-  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id);
   SCHECK(
       !req->target_master_addresses().empty(), InvalidArgument, "Missing Target Master addresses");
 
diff --git a/src/yb/master/xrepl_catalog_manager.cc b/src/yb/master/xrepl_catalog_manager.cc
index cd6ad508ce..6e0f7e200b 100644
--- a/src/yb/master/xrepl_catalog_manager.cc
+++ b/src/yb/master/xrepl_catalog_manager.cc
@@ -4818,7 +4818,7 @@ Status CatalogManager::AlterUniverseReplication(
   LOG(INFO) << "Servicing AlterUniverseReplication request from " << RequestorString(rpc) << ": "
             << req->ShortDebugString();
 
-  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id);
 
   RETURN_NOT_OK(ValidateUniverseUUID(req, *this));
 
@@ -5161,7 +5161,7 @@ Status CatalogManager::IsSetupUniverseReplicationDone(
   LOG(INFO) << "IsSetupUniverseReplicationDone from " << RequestorString(rpc) << ": "
             << req->DebugString();
 
-  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id);
 
   auto is_operation_done = VERIFY_RESULT(master::IsSetupUniverseReplicationDone(
       xcluster::ReplicationGroupId(req->replication_group_id()), *this));
diff --git a/src/yb/util/pb_util-test.cc b/src/yb/util/pb_util-test.cc
index 51ea55ac4b..6000cb4df3 100644
--- a/src/yb/util/pb_util-test.cc
+++ b/src/yb/util/pb_util-test.cc
@@ -506,94 +506,98 @@ TEST_F(TestPBUtil, TestPBRequiredToOptional) {
   ASSERT_OK(env_->DeleteFile(path_));
 }
 
+// Capture the outcome of the SCHECK into a variable.
+#define PB_FIELDS_ARE_SET(pb, ...) \
+  [&pb]() -> Status { \
+    SCHECK_PB_FIELDS_SET(pb, __VA_ARGS__); \
+    return Status::OK(); \
+  }()
+
 TEST_F(TestPBUtil, TestScheckPbFieldsAreSetMacro) {
   ProtoContainerTestPB pb;
   pb.set_name("foo");
   pb.set_note("bar");
   // value not set
 
-  ASSERT_OK([&pb]() -> Status {
-    SCHECK_PB_FIELDS_ARE_SET(pb, name);
-    return Status::OK();
-  }());
-
-  ASSERT_OK([&pb]() -> Status {
-    SCHECK_PB_FIELDS_ARE_SET(pb, note);
-    return Status::OK();
-  }());
-
-  auto result = [&pb]() -> Status {
-    SCHECK_PB_FIELDS_ARE_SET(pb, value);
-    return Status::OK();
-  }();
-  ASSERT_NOK(result);
-  ASSERT_STR_CONTAINS(result.ToString(), "Missing required arguments: [value]");
-
-  ASSERT_OK([&pb]() -> Status {
-    SCHECK_PB_FIELDS_ARE_SET(pb, name, note);
-    return Status::OK();
-  }());
-
-  result = [&pb]() -> Status {
-    SCHECK_PB_FIELDS_ARE_SET(pb, name, value);
-    return Status::OK();
-  }();
-  ASSERT_NOK(result);
-  ASSERT_STR_CONTAINS(result.ToString(), "Missing required arguments: [value]");
-
-  result = [&pb]() -> Status {
-    SCHECK_PB_FIELDS_ARE_SET(pb, value, note);
-    return Status::OK();
-  }();
-  ASSERT_NOK(result);
-  ASSERT_STR_CONTAINS(result.ToString(), "Missing required arguments: [value]");
-
-  result = [&pb]() -> Status {
-    SCHECK_PB_FIELDS_ARE_SET(pb, name, value, note);
-    return Status::OK();
-  }();
-  ASSERT_NOK(result);
-  ASSERT_STR_CONTAINS(result.ToString(), "Missing required arguments: [value]");
+  ASSERT_OK(PB_FIELDS_ARE_SET(pb, name));
+  ASSERT_OK(PB_FIELDS_ARE_SET(pb, note));
+  ASSERT_NOK_STR_CONTAINS(PB_FIELDS_ARE_SET(pb, value), "Missing required arguments: [value]");
+
+  ASSERT_OK(PB_FIELDS_ARE_SET(pb, name, note));
+  ASSERT_NOK_STR_CONTAINS(
+      PB_FIELDS_ARE_SET(pb, name, value), "Missing required arguments: [value]");
+
+  ASSERT_NOK_STR_CONTAINS(
+      PB_FIELDS_ARE_SET(pb, value, note), "Missing required arguments: [value]");
+
+  ASSERT_NOK_STR_CONTAINS(
+      PB_FIELDS_ARE_SET(pb, name, value, note), "Missing required arguments: [value]");
 
   pb.Clear();
   pb.set_name("foo");
   // value, note not set
 
-  ASSERT_OK([&pb]() -> Status {
-    SCHECK_PB_FIELDS_ARE_SET(pb, name);
-    return Status::OK();
-  }());
-
-  result = [&pb]() -> Status {
-    SCHECK_PB_FIELDS_ARE_SET(pb, name, value, note);
-    return Status::OK();
-  }();
-  ASSERT_NOK(result);
-  ASSERT_STR_CONTAINS(result.ToString(), "Missing required arguments: [value, note]");
-
-  result = [&pb]() -> Status {
-    SCHECK_PB_FIELDS_ARE_SET(pb, note, name, value);
-    return Status::OK();
-  }();
-  ASSERT_NOK(result);
-  ASSERT_STR_CONTAINS(result.ToString(), "Missing required arguments: [note, value]");
+  ASSERT_OK(PB_FIELDS_ARE_SET(pb, name));
+  ASSERT_NOK_STR_CONTAINS(
+      PB_FIELDS_ARE_SET(pb, name, value, note), "Missing required arguments: [value, note]");
+  ASSERT_NOK_STR_CONTAINS(
+      PB_FIELDS_ARE_SET(pb, note, name, value), "Missing required arguments: [note, value]");
 
   pb.Clear();
   pb.set_note("foo");
   // name, value not set
 
-  ASSERT_OK([&pb]() -> Status {
-    SCHECK_PB_FIELDS_ARE_SET(pb, note);
-    return Status::OK();
-  }());
-
-  result = [&pb]() -> Status {
-    SCHECK_PB_FIELDS_ARE_SET(pb, name, value, note);
-    return Status::OK();
-  }();
-  ASSERT_NOK(result);
-  ASSERT_STR_CONTAINS(result.ToString(), "Missing required arguments: [name, value]");
+  ASSERT_OK(PB_FIELDS_ARE_SET(pb, note));
+  ASSERT_NOK_STR_CONTAINS(
+      PB_FIELDS_ARE_SET(pb, name, value, note), "Missing required arguments: [name, value]");
 }
 
+#undef PB_FIELDS_ARE_SET
+
+// Capture the outcome of the SCHECK into a variable.
+#define PB_FIELDS_NOT_EMPTY(pb, ...) \
+  [&pb]() -> Status { \
+    SCHECK_PB_FIELDS_NOT_EMPTY(pb, __VA_ARGS__); \
+    return Status::OK(); \
+  }()
+
+TEST_F(TestPBUtil, TestScheckPbFieldsNotEmptyMacro) {
+  ProtoContainerTestPB pb;
+
+  // Empty note.
+  pb.set_note("");
+  ASSERT_NOK_STR_CONTAINS(PB_FIELDS_NOT_EMPTY(pb, note), "Empty required arguments: [note]");
+  ASSERT_OK(PB_FIELDS_NOT_EMPTY(pb, value));
+
+  // Empty repeated string field.
+  ASSERT_NOK_STR_CONTAINS(
+      PB_FIELDS_NOT_EMPTY(pb, str_list), "Empty required arguments: [str_list]");
+  pb.add_str_list("");
+  ASSERT_NOK_STR_CONTAINS(
+      PB_FIELDS_NOT_EMPTY(pb, str_list), "Empty required arguments: [str_list]");
+
+  // Empty repeated int field.
+  ASSERT_NOK_STR_CONTAINS(
+      PB_FIELDS_NOT_EMPTY(pb, str_list, int_list),
+      "Empty required arguments: [str_list, int_list]");
+
+  pb.add_int_list(0);
+  ASSERT_NOK_STR_CONTAINS(
+      PB_FIELDS_NOT_EMPTY(pb, str_list, int_list), "Empty required arguments: [str_list]");
+
+  pb.clear_str_list();
+  pb.add_str_list("test");
+
+  ASSERT_NOK_STR_CONTAINS(
+      PB_FIELDS_NOT_EMPTY(pb, name, value, note, str_list, int_list),
+      "Empty required arguments: [name, note]");
+
+  pb.set_name("name");
+  pb.set_note("note");
+  ASSERT_OK(PB_FIELDS_NOT_EMPTY(pb, name, value, note, str_list, int_list));
+}
+
+#undef PB_FIELDS_NOT_EMPTY
+
 } // namespace pb_util
 } // namespace yb
diff --git a/src/yb/util/pb_util.h b/src/yb/util/pb_util.h
index d0ccb36785..d16cbe05bb 100644
--- a/src/yb/util/pb_util.h
+++ b/src/yb/util/pb_util.h
@@ -37,31 +37,55 @@
 
 #include <string>
 
+#include <google/protobuf/repeated_field.h>
 #include <gtest/gtest_prod.h>
 
 #include "yb/util/faststring.h"
 #include "yb/util/slice.h"
 #include "yb/util/status_fwd.h"
 
-#define INTERNAL_SCHECK_PB_FIELD_IS_SET(i, pb, field) \
+// Check that the provided fields have been set in the protobuf. If the check fails, this returns
+// an InvalidArgument Status who's message containing the list of missing fields.
+//
+// Ex: SCHECK_PB_FIELDS_SET(req, field_1, field_2, field_3);
+#define SCHECK_PB_FIELDS_SET(pb, ...) \
+  do { \
+    std::vector<std::string> _missing_fields; \
+    BOOST_PP_SEQ_FOR_EACH( \
+        INTERNAL_SCHECK_PB_FIELD_SET, (pb), BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__)) \
+    SCHECK_FORMAT( \
+        _missing_fields.empty(), InvalidArgument, "Missing required arguments: $0", \
+        _missing_fields); \
+  } while (0)
+
+#define INTERNAL_SCHECK_PB_FIELD_SET(i, pb, field) \
   if (!pb.BOOST_PP_CAT(has_, field)()) { \
     _missing_fields.emplace_back(BOOST_PP_STRINGIZE(field)); \
   }
 
-// Check that the provided fields have been set in the protobuf. If the check fails returns from the
-// function with an InvalidArgument Status who's message containing the list of missing fields.
-// Ex:
-// SCHECK_PB_FIELDS_ARE_SET(req, field_1, field_2, field_3);
-#define SCHECK_PB_FIELDS_ARE_SET(pb, ...) \
+// Check that the provided fields are not empty in the protobuf.
+// This uses the empty() function for fields that support it (string and repeated types). For
+// repeated types all elements in the list are also checked individually. If the check fails, this
+// returns an InvalidArgument Status who's message containing the list of
+// empty fields. If the type does not implement empty() then it is treated as not empty.
+// SCHECK_PB_FIELDS_SET must be used for these types.
+//
+// Ex: SCHECK_PB_FIELDS_NOT_EMPTY(req, field_1, field_2, field_3);
+#define SCHECK_PB_FIELDS_NOT_EMPTY(pb, ...) \
   do { \
     std::vector<std::string> _missing_fields; \
     BOOST_PP_SEQ_FOR_EACH( \
-        INTERNAL_SCHECK_PB_FIELD_IS_SET, (pb), BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__)) \
+        INTERNAL_SCHECK_PB_FIELD_NOT_EMPTY, (pb), BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__)) \
     SCHECK_FORMAT( \
-        _missing_fields.empty(), InvalidArgument, "Missing required arguments: $0", \
+        _missing_fields.empty(), InvalidArgument, "Empty required arguments: $0", \
         _missing_fields); \
   } while (0)
 
+#define INTERNAL_SCHECK_PB_FIELD_NOT_EMPTY(i, pb, field) \
+  if (yb::pb_util_internal::IsPbFieldEmpty(pb.field())) { \
+    _missing_fields.emplace_back(BOOST_PP_STRINGIZE(field)); \
+  }
+
 namespace google {
 namespace protobuf {
 
@@ -70,14 +94,49 @@ class FileDescriptorSet;
 class MessageLite;
 class Message;
 
-template <class T>
-class RepeatedPtrField;
-
 } // namespace protobuf
 } // namespace google
 
 namespace yb {
 
+namespace pb_util_internal {
+template <class T>
+concept TypeWithEmpty = requires(const T& t) { empty(t); };  // NOLINT
+
+template <class T>
+concept TypeWithoutEmpty = !TypeWithEmpty<T>;  // NOLINT
+
+template <TypeWithoutEmpty T>
+bool IsPbFieldEmpty(const T& field) {
+  return false;
+}
+
+template <TypeWithEmpty T>
+bool IsPbFieldEmpty(const T& field) {
+  return field.empty();
+}
+
+template <typename T>
+bool IsPbFieldEmpty(const google::protobuf::RepeatedField<T>& repeated_field) {
+  // RepeatedField only has basic types which do not implement empty().
+  return repeated_field.empty();
+}
+
+template <typename T>
+bool IsPbFieldEmpty(const google::protobuf::RepeatedPtrField<T>& repeated_field) {
+  if (repeated_field.empty()) {
+    return true;
+  }
+  for (const auto& field : repeated_field) {
+    if (IsPbFieldEmpty(field)) {
+      return true;
+    }
+  }
+  return false;
+}
+
+}  // namespace pb_util_internal
+
 class Env;
 class RandomAccessFile;
 class SequentialFile;
diff --git a/src/yb/util/proto_container_test.proto b/src/yb/util/proto_container_test.proto
index 325006be0e..d9131a1a7d 100644
--- a/src/yb/util/proto_container_test.proto
+++ b/src/yb/util/proto_container_test.proto
@@ -38,6 +38,8 @@ message ProtoContainerTestPB {
   required string name = 1;
   required int32 value = 2;
   optional string note = 3;
+  repeated string str_list = 4;
+  repeated int32 int_list = 5;
 }
 
 message TestStringRequiredPB {
