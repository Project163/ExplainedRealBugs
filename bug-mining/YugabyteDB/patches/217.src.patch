diff --git a/src/postgres/src/bin/pg_dump/pg_dumpall.c b/src/postgres/src/bin/pg_dump/pg_dumpall.c
index b27f1293c3..82d4e14374 100644
--- a/src/postgres/src/bin/pg_dump/pg_dumpall.c
+++ b/src/postgres/src/bin/pg_dump/pg_dumpall.c
@@ -854,18 +854,6 @@ dumpRoles(PGconn *conn)
 			continue;
 		}
 
-		/*
-		 * In Yugabyte, we run as user yugabyte during the PG major version
-		 * upgrade, and the postgres install user has already been created by
-		 * initdb, so we skip creating it which would create a conflict.
-		 */
-		if (IsYugabyteEnabled && binary_upgrade &&
-			strcmp(rolename, "postgres") == 0)
-		{
-			pg_log_warning("role name \"postgres\" skipped");
-			continue;
-		}
-
 		resetPQExpBuffer(buf);
 
 		if (binary_upgrade)
@@ -885,8 +873,26 @@ dumpRoles(PGconn *conn)
 		 * have failed to drop it.  binary_upgrade cannot generate any errors,
 		 * so we assume the current role is already created.
 		 */
-		if (!binary_upgrade ||
-			strcmp(PQgetvalue(res, i, i_is_current_user), "f") == 0)
+		if (IsYugabyteEnabled && binary_upgrade)
+		{
+			/*
+			 * In Yugabyte, the restore can be run by a different user than the
+			 * one running the dump, so create all users with an if-exists
+			 * check.
+			 */
+			appendPQExpBuffer(buf,
+					"\\set role_exists false\n"
+					"SELECT EXISTS(SELECT 1 FROM pg_roles WHERE rolname = '%s')"
+					" AS role_exists \\gset\n"
+					"\\if :role_exists\n"
+					"    \\echo 'Role %s already exists.'\n"
+					"\\else\n"
+					"    CREATE ROLE %s;\n"
+					"\\endif\n",
+					rolename, yb_frolename, rolename);
+		}
+		else if (!binary_upgrade ||
+				 strcmp(PQgetvalue(res, i, i_is_current_user), "f") == 0)
 		{
 			if (include_yb_metadata)
 				appendPQExpBuffer(buf,
diff --git a/src/postgres/src/bin/pg_upgrade/option.c b/src/postgres/src/bin/pg_upgrade/option.c
index 1a146cc3e3..840b828572 100644
--- a/src/postgres/src/bin/pg_upgrade/option.c
+++ b/src/postgres/src/bin/pg_upgrade/option.c
@@ -76,13 +76,23 @@ parseCommandLine(int argc, char *argv[])
 	old_cluster.port = getenv("PGPORTOLD") ? atoi(getenv("PGPORTOLD")) : DEF_PGUPORT;
 	new_cluster.port = getenv("PGPORTNEW") ? atoi(getenv("PGPORTNEW")) : DEF_PGUPORT;
 
-	os_user_effective_id = get_user_info(&os_info.user);
-	/* we override just the database user name;  we got the OS id above */
-	if (getenv("PGUSER"))
+	if (is_yugabyte_enabled())
 	{
-		pg_free(os_info.user);
-		/* must save value, getenv()'s pointer is not stable */
-		os_info.user = pg_strdup(getenv("PGUSER"));
+		/* In YB we allow root users to run pg_upgrade.
+		   User name is a required parameter so we can skip the env checks.
+		 */
+		os_user_effective_id = -1;
+	}
+	else
+	{
+		os_user_effective_id = get_user_info(&os_info.user);
+		/* we override just the database user name;  we got the OS id above */
+		if (getenv("PGUSER"))
+		{
+			pg_free(os_info.user);
+			/* must save value, getenv()'s pointer is not stable */
+			os_info.user = pg_strdup(getenv("PGUSER"));
+		}
 	}
 
 	if (argc > 1)
@@ -220,6 +230,13 @@ parseCommandLine(int argc, char *argv[])
 	if (optind < argc)
 		pg_fatal("too many command-line arguments (first is \"%s\")\n", argv[optind]);
 
+	if (is_yugabyte_enabled())
+	{
+		old_cluster.yb_user = os_info.user;
+		/* In YB, the new cluster is always connected via the yugabyte user */
+		new_cluster.yb_user = "yugabyte";
+	}
+
 	if (log_opts.verbose)
 		pg_log(PG_REPORT, "Running in verbose mode\n");
 
diff --git a/src/postgres/src/bin/pg_upgrade/pg_upgrade.h b/src/postgres/src/bin/pg_upgrade/pg_upgrade.h
index 8e9f966761..5c0437301e 100644
--- a/src/postgres/src/bin/pg_upgrade/pg_upgrade.h
+++ b/src/postgres/src/bin/pg_upgrade/pg_upgrade.h
@@ -268,6 +268,7 @@ typedef struct
 	const char *tablespace_suffix;	/* directory specification */
 
 	char	   *yb_hostaddr;	/* host address for Yugabyte node */
+	char	   *yb_user;		/* username for the cluster */
 } ClusterInfo;
 
 
diff --git a/src/postgres/src/bin/pg_upgrade/server.c b/src/postgres/src/bin/pg_upgrade/server.c
index ecdd927d40..bca800ee98 100644
--- a/src/postgres/src/bin/pg_upgrade/server.c
+++ b/src/postgres/src/bin/pg_upgrade/server.c
@@ -64,7 +64,10 @@ get_db_conn(ClusterInfo *cluster, const char *db_name)
 	appendPQExpBufferStr(&conn_opts, "dbname=");
 	appendConnStrVal(&conn_opts, db_name);
 	appendPQExpBufferStr(&conn_opts, " user=");
-	appendConnStrVal(&conn_opts, os_info.user);
+	if (is_yugabyte_enabled())
+		appendConnStrVal(&conn_opts, cluster->yb_user);
+	else
+		appendConnStrVal(&conn_opts, os_info.user);
 	appendPQExpBuffer(&conn_opts, " port=%d", cluster->port);
 	if (is_yugabyte_enabled() && cluster->yb_hostaddr)
 	{
@@ -116,7 +119,10 @@ cluster_conn_opts(ClusterInfo *cluster)
 		appendPQExpBufferChar(buf, ' ');
 	}
 	appendPQExpBuffer(buf, "--port %d --username ", cluster->port);
-	appendShellString(buf, os_info.user);
+	if (is_yugabyte_enabled())
+		appendShellString(buf, cluster->yb_user);
+	else
+		appendShellString(buf, os_info.user);
 
 	return buf->data;
 }
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
index ca56df989f..4932706902 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
@@ -18,6 +18,7 @@
 
 using namespace std::chrono_literals;
 
+DECLARE_string(ysql_major_upgrade_user);
 namespace yb {
 
 class Pg15UpgradeTest : public Pg15UpgradeTestBase {
@@ -1043,15 +1044,45 @@ TEST_F(Pg15UpgradeTest, NoTserverOnMasterNode) {
   ASSERT_OK(FinalizeUpgrade());
 }
 
-// Make sure upgrade fails in auth enabled universes if there is no tserver on the master node.
+// If there is no tserver on the master node make sure the upgrade fails unless the yugabyte_upgrade
+// user is created.
 TEST_F(Pg15UpgradeTestWithAuth, NoTserverOnMasterNode) {
   static const MonoDelta no_delay_between_nodes = 0s;
+
+// Disabled the rollback step on debug builds and MacOS because it times out.
+#if !defined(__APPLE__) && defined(NDEBUG)
+  ASSERT_OK(RestartAllMastersInCurrentVersion(no_delay_between_nodes));
+
+  {
+    auto master_tserver = ASSERT_RESULT(StopMasterLeaderTServer());
+
+    ASSERT_NOK_STR_CONTAINS(PerformYsqlMajorCatalogUpgrade(), "Failed to run pg_upgrade");
+    ASSERT_OK(RollbackYsqlMajorCatalogVersion());
+    ASSERT_OK(master_tserver->Restart());
+  }
+#endif
+
+  // Rollback and create the upgrade user.
+  ASSERT_OK(RestartAllMastersInOldVersion(no_delay_between_nodes));
+
+  const auto password = "yugabyte";
+  // Set the password in the environment variable, which will propagate it to all child processes
+  // started after this point.
+  setenv("PGPASSWORD", password, /*overwrite=*/true);
+
+  ASSERT_OK(ExecuteStatement(Format(
+      "CREATE USER $0 WITH SUPERUSER PASSWORD '$1'", FLAGS_ysql_major_upgrade_user, password)));
+
   ASSERT_OK(RestartAllMastersInCurrentVersion(no_delay_between_nodes));
 
   auto master_tserver = ASSERT_RESULT(StopMasterLeaderTServer());
 
-  ASSERT_NOK_STR_CONTAINS(PerformYsqlMajorCatalogUpgrade(), "Failed to run pg_upgrade");
+  ASSERT_OK(PerformYsqlMajorCatalogUpgrade());
   ASSERT_OK(master_tserver->Restart());
+  ASSERT_OK(WaitForClusterToStabilize());
+
+  ASSERT_OK(RestartAllTServersInCurrentVersion(no_delay_between_nodes));
+  ASSERT_OK(FinalizeUpgrade());
 }
 
 TEST_F(Pg15UpgradeTestWithAuth, UpgradeAuthEnabledUniverse) {
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
index 85c6ee8532..4cdec73c4c 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
@@ -33,6 +33,7 @@
 DECLARE_string(tmp_dir);
 DECLARE_bool(master_join_existing_universe);
 DECLARE_string(rpc_bind_addresses);
+DECLARE_bool(ysql_enable_auth);
 
 DEFINE_RUNTIME_uint32(ysql_upgrade_postgres_port, 5434,
   "Port used to start the postgres process for ysql upgrade");
@@ -41,6 +42,13 @@ DEFINE_test_flag(
     string, fail_ysql_catalog_upgrade_state_transition_from, "",
     "When set fail the transition to the provided state");
 
+DEFINE_RUNTIME_string(ysql_major_upgrade_user, "yugabyte_upgrade",
+    "The ysql user to use for ysql major upgrade operations when both:"
+    " authentication is enabled, "
+    " no yb-tserver process running on the yb-master nodes. "
+    "This user should have superuser privileges and the password must be placed in the `.pgpass` "
+    "file on all yb-master nodes.");
+
 using yb::pgwrapper::PgWrapper;
 
 namespace yb::master {
@@ -356,6 +364,7 @@ Status YsqlInitDBAndMajorUpgradeHandler::PerformPgUpgrade(const LeaderEpoch& epo
   RETURN_NOT_OK(pg_supervisor.Start());
 
   PgWrapper::PgUpgradeParams pg_upgrade_params;
+  pg_upgrade_params.ysql_user_name = "yugabyte";
   pg_upgrade_params.data_dir = pg_conf.data_dir;
   pg_upgrade_params.new_version_socket_dir =
       PgDeriveSocketDir(HostPort(pg_conf.listen_addresses, pg_conf.pg_port));
@@ -370,7 +379,16 @@ Status YsqlInitDBAndMajorUpgradeHandler::PerformPgUpgrade(const LeaderEpoch& epo
   if (local_ts) {
     pg_upgrade_params.old_version_socket_dir = PgDeriveSocketDir(closest_ts_hp);
   } else {
+    // Remote tserver.
     pg_upgrade_params.old_version_pg_address = closest_ts_hp.host();
+
+    if (FLAGS_ysql_enable_auth || pg_conf.enable_tls) {
+      pg_upgrade_params.ysql_user_name = FLAGS_ysql_major_upgrade_user;
+      LOG(INFO) << "Running ysql major upgrade on a authentication enabled universe which does not "
+                   "have a yb-tserver on the same node as the yb-master. Upgrade will be performed "
+                   "using yb-tserver hosted on "
+                << closest_ts_hp << " by user " << pg_upgrade_params.ysql_user_name;
+    }
   }
   pg_upgrade_params.old_version_pg_port = closest_ts_hp.port();
 
diff --git a/src/yb/yql/pgwrapper/pg_wrapper.cc b/src/yb/yql/pgwrapper/pg_wrapper.cc
index c474e06fec..0c1760d09b 100644
--- a/src/yb/yql/pgwrapper/pg_wrapper.cc
+++ b/src/yb/yql/pgwrapper/pg_wrapper.cc
@@ -899,14 +899,14 @@ Status PgWrapper::InitDb(InitdbParams initdb_params) {
     }
   }
 
-  std::string stdout, stderr;
-  auto status = initdb_subprocess.Call(&stdout, &stderr);
-  LOG(INFO) << "initdb stdout: " << stdout;
-  if (!stderr.empty()) {
-    LOG(WARNING) << "initdb stderr: " << stderr;
-  }
-  if (!status.ok()) {
-    return status.CloneAndAppend(stderr);
+  int status = 0;
+  RETURN_NOT_OK(initdb_subprocess.Start());
+  RETURN_NOT_OK(initdb_subprocess.Wait(&status));
+  if (status != 0) {
+    SCHECK(
+        WIFEXITED(status), InternalError, Format("$0 did not exit normally", initdb_program_path));
+    return STATUS_FORMAT(
+        RuntimeError, "$0 failed with exit code $1", initdb_program_path, WEXITSTATUS(status));
   }
 
   LOG(INFO) << "initdb completed successfully. Database initialized at " << conf_.data_dir;
@@ -923,7 +923,7 @@ Status PgWrapper::RunPgUpgrade(const PgUpgradeParams& param) {
   std::vector<std::string> args{
       program_path,
       "--new-datadir", param.data_dir,
-      "--username", "yugabyte",
+      "--username", param.ysql_user_name,
       "--new-socketdir", param.new_version_socket_dir,
       "--new-port", ToString(param.new_version_pg_port),
       "--old-port", ToString(param.old_version_pg_port)};
@@ -939,14 +939,10 @@ Status PgWrapper::RunPgUpgrade(const PgUpgradeParams& param) {
   LOG(INFO) << "Launching pg_upgrade: " << AsString(args);
   Subprocess subprocess(program_path, args);
 
-  std::string stdout, stderr;
-  auto status = Subprocess::Call(args, &stdout, &stderr);
-  LOG(INFO) << "pg_upgrade stdout: " << stdout;
-  if (!stderr.empty()) {
-    LOG(WARNING) << "pg_upgrade stderr: " << stderr;
-  }
+  auto status = Subprocess::Call(args);
   if (!status.ok()) {
-    return status.CloneAndAppend(stderr);
+    return status.CloneAndAppend(
+        "pg_upgrade failed. Check the standard output and standard error for more details.");
   }
 
   LOG(INFO) << "pg_upgrade completed successfully";
diff --git a/src/yb/yql/pgwrapper/pg_wrapper.h b/src/yb/yql/pgwrapper/pg_wrapper.h
index a602f99430..fe847ed9ad 100644
--- a/src/yb/yql/pgwrapper/pg_wrapper.h
+++ b/src/yb/yql/pgwrapper/pg_wrapper.h
@@ -95,6 +95,7 @@ class PgWrapper : public ProcessWrapper {
   Status SetYsqlConnManagerStatsShmKey(key_t statsshmkey);
 
   struct PgUpgradeParams {
+    std::string ysql_user_name;
     std::string data_dir;
     std::string old_version_pg_address;
     std::string old_version_socket_dir;
