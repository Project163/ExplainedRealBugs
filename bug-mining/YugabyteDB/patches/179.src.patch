diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_index-test.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_index-test.cc
index ffadc5e2f7..acd5e3cc44 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_index-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_index-test.cc
@@ -32,7 +32,6 @@ DECLARE_bool(TEST_disable_apply_committed_transactions);
 DECLARE_bool(TEST_xcluster_fail_table_create_during_bootstrap);
 DECLARE_int32(TEST_user_ddl_operation_timeout_sec);
 DECLARE_bool(TEST_fail_universe_replication_merge);
-DECLARE_bool(auto_add_new_index_to_bidirectional_xcluster);
 DECLARE_string(ysql_yb_test_block_index_phase);
 DECLARE_int32(ysql_yb_index_state_flags_update_delay);
 
@@ -652,8 +651,6 @@ class XClusterBiDirectionalIndexTest : public XClusterYsqlNonTransactionalTest,
 
   void SetUp() override {
     YB_SKIP_TEST_IN_TSAN();
-    ANNOTATE_UNPROTECTED_WRITE(FLAGS_auto_add_new_index_to_bidirectional_xcluster) = true;
-
     XClusterYsqlNonTransactionalTest::SetUp();
 
     // Setup the reverse replication.
diff --git a/src/yb/master/backfill_index.cc b/src/yb/master/backfill_index.cc
index dfe87da92d..9e79e228fb 100644
--- a/src/yb/master/backfill_index.cc
+++ b/src/yb/master/backfill_index.cc
@@ -121,8 +121,6 @@ DEFINE_test_flag(bool, simulate_cannot_enable_compactions, false,
 DEFINE_test_flag(int32, delay_clearing_fully_applied_ms, 0,
     "Amount of time to delay clearing the fully applied schema.");
 
-DECLARE_bool(auto_add_new_index_to_bidirectional_xcluster);
-
 namespace yb {
 namespace master {
 
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index 82b107797d..8d10a420d5 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -20,6 +20,7 @@
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master_cluster.pb.h"
+#include "yb/master/xcluster/master_xcluster_util.h"
 #include "yb/master/xcluster/xcluster_status.h"
 #include "yb/master/xcluster/xcluster_universe_replication_setup_helper.h"
 #include "yb/util/backoff_waiter.h"
@@ -58,7 +59,13 @@ DEFINE_test_flag(bool, force_automatic_ddl_replication_mode, false,
     "Make XClusterCreateOutboundReplicationGroup always use automatic instead of semi-automatic "
     "xCluster replication mode.");
 
-DEFINE_RUNTIME_bool(auto_add_new_index_to_bidirectional_xcluster, false,
+DEFINE_RUNTIME_AUTO_bool(ysql_auto_add_new_index_to_bidirectional_xcluster_infra, kExternal,
+    false, true,
+    "Determines if the system supports the capability of automatically adding ysql index to "
+    "bi-directional xCluster. NOTE: Do not change this flag directly. If you want to disable the "
+    "feature, use ysql_auto_add_new_index_to_bidirectional_xcluster instead.");
+
+DEFINE_RUNTIME_bool(ysql_auto_add_new_index_to_bidirectional_xcluster, true,
     "If the indexed table is part of a bi-directional xCluster setup, then automatically add new "
     "indexes for this table to replication. This flag must be set on both universes, and the index "
     "must be created concurrently on both universes.");
@@ -83,6 +90,11 @@ Status ValidateUniverseUUID(const RequestType& req, CatalogManager& catalog_mana
   return Status::OK();
 }
 
+bool IsYsqlAutoAddNewIndexToBiDirectionalXClusterEnabled() {
+  return FLAGS_ysql_auto_add_new_index_to_bidirectional_xcluster_infra &&
+         FLAGS_ysql_auto_add_new_index_to_bidirectional_xcluster;
+}
+
 }  // namespace
 
 XClusterManager::XClusterManager(
@@ -731,6 +743,21 @@ bool XClusterManager::IsTableBiDirectionallyReplicated(const TableId& table_id)
          XClusterTargetManager::IsTableReplicated(table_id);
 }
 
+bool XClusterManager::ShouldAutoAddIndexesToBiDirectionalXCluster(
+    const TableInfo& indexed_table) const {
+  if (!IsYsqlAutoAddNewIndexToBiDirectionalXClusterEnabled() ||
+      indexed_table.GetTableType() != PGSQL_TABLE_TYPE) {
+    return false;
+  }
+
+  auto table_id = indexed_table.id();
+  if (indexed_table.colocated()) {
+    table_id = indexed_table.LockForRead()->pb.parent_table_id();
+  }
+
+  return IsTableBiDirectionallyReplicated(table_id);
+}
+
 Status XClusterManager::HandleTabletSplit(
     const TableId& consumer_table_id, const SplitTabletIds& split_tablet_ids,
     const LeaderEpoch& epoch) {
diff --git a/src/yb/master/xcluster/xcluster_manager.h b/src/yb/master/xcluster/xcluster_manager.h
index 9ba8e06ecb..1663ab0195 100644
--- a/src/yb/master/xcluster/xcluster_manager.h
+++ b/src/yb/master/xcluster/xcluster_manager.h
@@ -260,6 +260,8 @@ class XClusterManager : public XClusterManagerIf,
 
   bool IsTableBiDirectionallyReplicated(const TableId& table_id) const override;
 
+  bool ShouldAutoAddIndexesToBiDirectionalXCluster(const TableInfo& indexed_table) const override;
+
   Status HandleTabletSplit(
       const TableId& consumer_table_id, const SplitTabletIds& split_tablet_ids,
       const LeaderEpoch& epoch) override;
diff --git a/src/yb/master/xcluster/xcluster_manager_if.h b/src/yb/master/xcluster/xcluster_manager_if.h
index 6de344ddf0..80770711cd 100644
--- a/src/yb/master/xcluster/xcluster_manager_if.h
+++ b/src/yb/master/xcluster/xcluster_manager_if.h
@@ -106,6 +106,9 @@ class XClusterManagerIf {
 
   virtual bool IsTableBiDirectionallyReplicated(const TableId& table_id) const = 0;
 
+  virtual bool ShouldAutoAddIndexesToBiDirectionalXCluster(
+      const TableInfo& indexed_table) const = 0;
+
  protected:
   virtual ~XClusterManagerIf() = default;
 };
diff --git a/src/yb/master/xcluster/xcluster_replication_group.cc b/src/yb/master/xcluster/xcluster_replication_group.cc
index 6ec6f724f5..71e4b8df51 100644
--- a/src/yb/master/xcluster/xcluster_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_replication_group.cc
@@ -38,8 +38,6 @@ DEFINE_RUNTIME_bool(xcluster_skip_health_check_on_replication_setup, false,
 DEFINE_test_flag(bool, exit_unfinished_deleting, false,
     "Whether to exit part way through the deleting universe process.");
 
-DECLARE_bool(auto_add_new_index_to_bidirectional_xcluster);
-
 namespace yb::master {
 
 namespace {
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index f50dd7a328..c5dbd50ded 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -40,7 +40,6 @@ DEFINE_RUNTIME_bool(enable_tablet_split_of_xcluster_bootstrapping_tables, false,
     "When set, it enables automatic tablet splitting for tables that are part of an "
     "xCluster replication setup and are currently being bootstrapped for xCluster.");
 
-DECLARE_bool(auto_add_new_index_to_bidirectional_xcluster);
 DECLARE_int32(master_yb_client_default_timeout_ms);
 DECLARE_uint32(cdc_wal_retention_time_secs);
 DECLARE_bool(TEST_disable_cdc_state_insert_on_setup);
@@ -273,24 +272,29 @@ XClusterSourceManager::GetPostTabletCreateTasks(
     }
   }
 
-  if (FLAGS_auto_add_new_index_to_bidirectional_xcluster && table_info->is_index() &&
-      master_.xcluster_manager()->IsTableBiDirectionallyReplicated(
-          table_info->indexed_table_id())) {
-    DCHECK(tasks.empty()) << "BiDirectional table should not have any DB Scoped table tasks";
-    if (!tasks.empty()) {
-      // During a switch over we will have Bi-directional xCluster with DB scoped replication
-      // groups. But we do not expect to receive any DDLs at this time.
-      table_info->SetCreateTableErrorStatus(STATUS_FORMAT(
-          IllegalState,
-          "Index $0 created while its base table $1 is under bi-directional xCluster replication, "
-          "and has DB scoped replication groups",
-          table_info->id(), table_info->indexed_table_id()));
+  if (table_info->is_index() && !table_info->colocated()) {
+    auto indexed_table = catalog_manager_.GetTableById(table_info->indexed_table_id());
+    if (!indexed_table) {
+      table_info->SetCreateTableErrorStatus(indexed_table.status());
       return {};
     }
+    if (master_.xcluster_manager()->ShouldAutoAddIndexesToBiDirectionalXCluster(**indexed_table)) {
+      DCHECK(tasks.empty()) << "BiDirectional table should not have any DB Scoped table tasks";
+      if (!tasks.empty()) {
+        // During a switch over we will have Bi-directional xCluster with DB scoped replication
+        // groups. But we do not expect to receive any DDLs at this time.
+        table_info->SetCreateTableErrorStatus(STATUS_FORMAT(
+            IllegalState,
+            "Index $0 created while its base table $1 is under bi-directional xCluster "
+            "replication, and has DB scoped replication groups",
+            table_info->id(), table_info->indexed_table_id()));
+        return {};
+      }
 
-    tasks.emplace_back(std::make_shared<CreateXClusterStreamForBiDirectionalIndexTask>(
-        std::bind(&XClusterSourceManager::CreateNonTxnStreamForNewTable, this, _1, _2, _3),
-        catalog_manager_, *master_.messenger(), table_info, epoch));
+      tasks.emplace_back(std::make_shared<CreateXClusterStreamForBiDirectionalIndexTask>(
+          std::bind(&XClusterSourceManager::CreateNonTxnStreamForNewTable, this, _1, _2, _3),
+          catalog_manager_, *master_.messenger(), table_info, epoch));
+    }
   }
 
   return tasks;
diff --git a/src/yb/master/xcluster/xcluster_target_manager.cc b/src/yb/master/xcluster/xcluster_target_manager.cc
index 8cf7263a4b..947550d597 100644
--- a/src/yb/master/xcluster/xcluster_target_manager.cc
+++ b/src/yb/master/xcluster/xcluster_target_manager.cc
@@ -48,10 +48,9 @@ DEFINE_RUNTIME_bool(xcluster_wait_on_ddl_alter, true,
 DEFINE_RUNTIME_uint32(add_new_index_to_bidirectional_xcluster_timeout_secs, 10 * 60,
     "Time in seconds within which index must be created on other universe when the indexed table "
     "is part of bidirectional xCluster replication. Applies only when "
-    "--auto_add_new_index_to_bidirectional_xcluster "
-    "is set.");
+    "--ysql_auto_add_new_index_to_bidirectional_xcluster is set.");
 
-DECLARE_bool(auto_add_new_index_to_bidirectional_xcluster);
+DECLARE_bool(ysql_auto_add_new_index_to_bidirectional_xcluster);
 DECLARE_uint64(max_clock_skew_usec);
 
 namespace yb::master {
@@ -1347,12 +1346,10 @@ Result<std::optional<HybridTime>> XClusterTargetManager::TryGetXClusterSafeTimeF
   const bool is_colocated = indexed_table->colocated();
   auto indexed_table_id = indexed_table->id();
 
-  if (is_colocated) {
-    indexed_table_id = indexed_table->LockForRead()->pb.parent_table_id();
-  }
-
-  if (FLAGS_auto_add_new_index_to_bidirectional_xcluster &&
-      xcluster_manager.IsTableBiDirectionallyReplicated(indexed_table_id)) {
+  if (master_.xcluster_manager()->ShouldAutoAddIndexesToBiDirectionalXCluster(*indexed_table)) {
+    if (is_colocated) {
+      indexed_table_id = indexed_table->LockForRead()->pb.parent_table_id();
+    }
     auto backfill_ht = VERIFY_RESULT_PREPEND(
         PrepareAndGetBackfillTimeForBiDirectionalIndex(index_table_ids, indexed_table_id, epoch),
         "Failed while preparing index for xCluster");
