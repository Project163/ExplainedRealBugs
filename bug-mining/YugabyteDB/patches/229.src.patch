diff --git a/src/yb/common/version_info.cc b/src/yb/common/version_info.cc
index 2bf8f33757..8cc50b909a 100644
--- a/src/yb/common/version_info.cc
+++ b/src/yb/common/version_info.cc
@@ -44,10 +44,11 @@
 #include "yb/gutil/once.h"
 
 #include "yb/util/env_util.h"
+#include "yb/util/flags.h"
 #include "yb/util/path_util.h"
-#include "yb/util/status.h"
+#include "yb/util/pb_util.h"
 #include "yb/util/status_log.h"
-#include "yb/util/flags.h"
+#include "yb/util/status.h"
 
 DEFINE_NON_RUNTIME_string(version_file_json_path, "",
               "Path to directory containing JSON file with version info.");
@@ -227,4 +228,43 @@ uint32 VersionInfo::YsqlMajorVersion() {
   return ysql_major_version;
 }
 
+bool VersionInfo::ValidateVersion(
+    std::optional<ConstRefWrap<VersionInfoPB>> version_opt, ValidateVersionInfoOp op) {
+  if (!version_opt.has_value()) {
+    // PG11 versions. Is a lower version allowed?
+    if (op == ValidateVersionInfoOp::kYsqlMajorVersionLE ||
+        op == ValidateVersionInfoOp::kYsqlMajorVersionLT) {
+      return true;
+    }
+    VLOG(1) << "Version validation skipped for older process missing the version_info since op: "
+            << ToString(op);
+    return false;
+  }
+
+  const VersionInfoPB& version = *version_opt;
+  const auto& current_version = GetVersionData()->pb;
+  bool result = false;
+  switch (op) {
+    case ValidateVersionInfoOp::kVersionEQ:
+      // We do not check build_type, since we support rolling migration to other hardwares.
+      result = version.version_number() == current_version.version_number() &&
+               version.build_number() == current_version.build_number() &&
+               version.ysql_major_version() == current_version.ysql_major_version();
+      break;
+    case ValidateVersionInfoOp::kYsqlMajorVersionLT:
+      result = version.ysql_major_version() < current_version.ysql_major_version();
+      break;
+    case ValidateVersionInfoOp::kYsqlMajorVersionLE:
+      result = version.ysql_major_version() <= current_version.ysql_major_version();
+      break;
+    case ValidateVersionInfoOp::kYsqlMajorVersionEQ:
+      result = version.ysql_major_version() == current_version.ysql_major_version();
+      break;
+  }
+
+  VLOG_IF(1, !result) << "Version validation failed: " << version.ShortDebugString() << " vs "
+                      << current_version.ShortDebugString() << ", op: " << ToString(op);
+  return result;
+}
+
 } // namespace yb
diff --git a/src/yb/common/version_info.h b/src/yb/common/version_info.h
index 9ad9538e3a..8aa1eb94a4 100644
--- a/src/yb/common/version_info.h
+++ b/src/yb/common/version_info.h
@@ -36,7 +36,9 @@
 
 #include "yb/gutil/macros.h"
 
+#include "yb/util/ref_wrap.h"
 #include "yb/util/status_fwd.h"
+#include "yb/util/enums.h"
 #include "yb/common/version_info.pb.h"
 
 namespace yb {
@@ -46,6 +48,13 @@ struct VersionData {
   std::string json;
 };
 
+YB_DEFINE_ENUM(
+    ValidateVersionInfoOp,
+    (kVersionEQ)            // The version, build, and ysql major version are the same.
+    (kYsqlMajorVersionLT)   // The ysql major version is lower.
+    (kYsqlMajorVersionLE)   // The ysql major version is lower or equal.
+    (kYsqlMajorVersionEQ))  // The ysql major version is equal.
+
 // Static functions related to fetching information about the current build.
 class VersionInfo {
  public:
@@ -66,6 +75,13 @@ class VersionInfo {
 
   static uint32 YsqlMajorVersion();
 
+  static bool ValidateVersion(
+      std::optional<ConstRefWrap<VersionInfoPB>> version, ValidateVersionInfoOp op);
+
+  static bool ValidateVersion(const VersionInfoPB& version, ValidateVersionInfoOp op) {
+    return ValidateVersion(std::optional(std::cref(version)), op);
+  }
+
  private:
   // Get the git hash for this build. If the working directory was dirty when
   // YB was built, also appends "-dirty".
diff --git a/src/yb/integration-tests/CMakeLists.txt b/src/yb/integration-tests/CMakeLists.txt
index ea68946db1..b9881560ea 100644
--- a/src/yb/integration-tests/CMakeLists.txt
+++ b/src/yb/integration-tests/CMakeLists.txt
@@ -265,6 +265,7 @@ ADD_YB_TEST(xcluster/xcluster-tablet-split-itest)
 ADD_YB_TEST(xcluster/xcluster-test)
 ADD_YB_TEST(xcluster/xcluster_outbound_replication_group-itest)
 ADD_YB_TEST(retryable_request-test)
+ADD_YB_TEST(upgrade-tests/auto_flag_upgrade-test)
 ADD_YB_TEST(upgrade-tests/basic_upgrade-test)
 ADD_YB_TEST(upgrade-tests/replication_info_upgrade-test)
 ADD_YB_TEST(upgrade-tests/pg15_upgrade-test)
diff --git a/src/yb/integration-tests/upgrade-tests/auto_flag_upgrade-test.cc b/src/yb/integration-tests/upgrade-tests/auto_flag_upgrade-test.cc
new file mode 100644
index 0000000000..58d6955236
--- /dev/null
+++ b/src/yb/integration-tests/upgrade-tests/auto_flag_upgrade-test.cc
@@ -0,0 +1,103 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/integration-tests/upgrade-tests/upgrade_test_base.h"
+
+namespace yb {
+
+const MonoDelta kRpcTimeout = 5s * kTimeMultiplier;
+
+// Test upgrade and rollback with a simple workload with updates and selects.
+class AutoFlagUpgradeTest : public UpgradeTestBase {
+ public:
+  AutoFlagUpgradeTest() : UpgradeTestBase(kBuild_2_25_0_0) {}
+
+  Result<master::PromoteAutoFlagsResponsePB> PromoteAutoFlags(AutoFlagClass flag_class) {
+    LOG(INFO) << "Promoting AutoFlags " << flag_class;
+
+    master::PromoteAutoFlagsRequestPB req;
+    master::PromoteAutoFlagsResponsePB resp;
+    rpc::RpcController rpc;
+    rpc.set_timeout(kRpcTimeout);
+    req.set_max_flag_class(ToString(flag_class));
+    req.set_promote_non_runtime_flags(false);
+    req.set_force(false);
+    RETURN_NOT_OK(cluster_->GetLeaderMasterProxy<master::MasterClusterProxy>().PromoteAutoFlags(
+        req, &resp, &rpc));
+    if (resp.has_error()) {
+      return StatusFromPB(resp.error().status());
+    }
+
+    return resp;
+  }
+
+  Status RollbackAutoFlags(uint32 old_version) {
+    master::RollbackAutoFlagsRequestPB req;
+    master::RollbackAutoFlagsResponsePB resp;
+    rpc::RpcController rpc;
+    rpc.set_timeout(kRpcTimeout);
+    req.set_rollback_version(old_version);
+    RETURN_NOT_OK(cluster_->GetLeaderMasterProxy<master::MasterClusterProxy>().RollbackAutoFlags(
+        req, &resp, &rpc));
+    if (resp.has_error()) {
+      return StatusFromPB(resp.error().status());
+    }
+
+    return Status::OK();
+  }
+};
+
+TEST_F(AutoFlagUpgradeTest, TestUpgrade) {
+  ASSERT_OK(StartClusterInOldVersion());
+
+  // These should all be no-ops since we deployed a new cluster.
+  {
+    auto validate_no_flags_promoted = [this](AutoFlagClass flag_class) {
+      auto resp = ASSERT_RESULT(PromoteAutoFlags(flag_class));
+      ASSERT_FALSE(resp.flags_promoted());
+    };
+    ASSERT_NO_FATAL_FAILURE(validate_no_flags_promoted(AutoFlagClass::kLocalVolatile));
+    ASSERT_NO_FATAL_FAILURE(validate_no_flags_promoted(AutoFlagClass::kLocalPersisted));
+    ASSERT_NO_FATAL_FAILURE(validate_no_flags_promoted(AutoFlagClass::kExternal));
+  }
+
+  ASSERT_OK(RestartAllMastersInCurrentVersion(kNoDelayBetweenNodes));
+
+  // We should not be allowed to promote any AutoFlags before all yb-tservers have been upgraded.
+  {
+    auto validate_no_promote = [this](AutoFlagClass flag_class) {
+      ASSERT_NOK_STR_CONTAINS(
+          PromoteAutoFlags(flag_class),
+          "Cannot promote AutoFlags before all yb-tservers have been upgraded to the current "
+          "version");
+    };
+    ASSERT_NO_FATAL_FAILURE(validate_no_promote(AutoFlagClass::kLocalVolatile));
+    ASSERT_NO_FATAL_FAILURE(validate_no_promote(AutoFlagClass::kLocalPersisted));
+    ASSERT_NO_FATAL_FAILURE(validate_no_promote(AutoFlagClass::kExternal));
+  }
+
+  ASSERT_OK(RestartAllTServersInCurrentVersion(kNoDelayBetweenNodes));
+
+  ASSERT_OK(PromoteAutoFlags(AutoFlagClass::kLocalVolatile));
+
+  // Promote all AutoFlags.
+  auto resp = ASSERT_RESULT(PromoteAutoFlags(AutoFlagClass::kExternal));
+  ASSERT_TRUE(resp.flags_promoted());
+  ASSERT_GT(resp.new_config_version(), 1);
+
+  // No more rollbacks.
+  ASSERT_NOK_STR_CONTAINS(
+      RollbackAutoFlags(resp.new_config_version() - 1), "not eligible for rollback");
+}
+
+}  // namespace yb
diff --git a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
index b9c28785be..0c3b42f649 100644
--- a/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/pg15_upgrade-test.cc
@@ -88,6 +88,21 @@ TEST_F(Pg15UpgradeTest, CheckVersion) {
   ysql_catalog_config = ASSERT_RESULT(DumpYsqlCatalogConfig());
   ASSERT_STR_NOT_CONTAINS(ysql_catalog_config, "catalog_version");
 
+  // We should not be allowed to finalize before upgrading all tservers.
+  ASSERT_NOK_STR_CONTAINS(
+      FinalizeYsqlMajorCatalogUpgrade(),
+      "Cannot finalize YSQL major catalog upgrade before all yb-tservers have been upgraded to the "
+      "current version: yb-tserver(s) not on the correct version");
+  // We should not be allowed to rollback before rolling back all tservers.
+  ASSERT_NOK_STR_CONTAINS(
+      RollbackYsqlMajorCatalogVersion(),
+      "Cannot rollback YSQL major catalog while yb-tservers are running on a newer YSQL major "
+      "version: yb-tserver(s) not on the correct version");
+
+  ASSERT_NOK_STR_CONTAINS(
+      PromoteAutoFlags(),
+      "Cannot promote non-volatile AutoFlags before YSQL major catalog upgrade is complete");
+
   ASSERT_OK(FinalizeUpgradeFromMixedMode());
 
   {
diff --git a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
index dfcbcdd30d..701d274dc1 100644
--- a/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
+++ b/src/yb/integration-tests/upgrade-tests/ysql_major_upgrade_ddl_blocking-test.cc
@@ -175,14 +175,10 @@ TEST_F(YsqlMajorUpgradeDdlBlockingTest, TestDdlsDuringUpgrade) {
   ASSERT_OK(RunDdlFunctions(kMixedModeTserverPg11));
 
   // Finalize upgrade without upgrading all tservers
-  ASSERT_OK(FinalizeYsqlMajorCatalogUpgrade());
+  ASSERT_OK(FinalizeUpgradeFromMixedMode());
   upgrade_state_ = UpgradeState::kAfterUpgrade;
 
-  ASSERT_OK(RunDdlFunctions(kMixedModeTserverPg15));
-
-  // Pg11 tserver should not be allowed to update the catalog after catalog upgrade has been
-  // finalized.
-  ASSERT_OK(RunDdlFunctions(kMixedModeTserverPg11, /*error_expected=*/true));
+  ASSERT_OK(RunDdlFunctions(std::nullopt));
 }
 
 // Make sure we cannot run DDLs during a failed upgrade.
diff --git a/src/yb/master/catalog_entity_info.proto b/src/yb/master/catalog_entity_info.proto
index f5b56f2817..0bc7622ce2 100644
--- a/src/yb/master/catalog_entity_info.proto
+++ b/src/yb/master/catalog_entity_info.proto
@@ -22,6 +22,7 @@ import "yb/common/common.proto";
 import "yb/common/common_net.proto";
 import "yb/common/common_types.proto";
 import "yb/common/transaction.proto";
+import "yb/common/version_info.proto";
 import "yb/common/wire_protocol.proto";
 import "yb/consensus/metadata.proto";
 import "yb/master/master_types.proto";
@@ -979,4 +980,6 @@ message SysTabletServerEntryPB {
   optional bool live_client_operation_lease = 7;
 
   optional uint64 lease_epoch = 8;
+
+  optional VersionInfoPB version_info = 9;
 }
diff --git a/src/yb/master/master.cc b/src/yb/master/master.cc
index aaa4e16382..d62f7030b4 100644
--- a/src/yb/master/master.cc
+++ b/src/yb/master/master.cc
@@ -159,8 +159,7 @@ Master::Master(const MasterOptions& opts)
       sys_catalog_(new SysCatalogTable(this, metric_registry_.get())),
       ts_manager_(new TSManager(*sys_catalog_, *clock())),
       catalog_manager_(new CatalogManager(this, sys_catalog_.get())),
-      auto_flags_manager_(
-          new MasterAutoFlagsManager(clock(), fs_manager_.get(), catalog_manager_impl())),
+      auto_flags_manager_(new MasterAutoFlagsManager(*this)),
       ysql_backends_manager_(new YsqlBackendsManager(this, catalog_manager_->AsyncTaskPool())),
       path_handlers_(new MasterPathHandlers(this)),
       flush_manager_(new FlushManager(this, catalog_manager())),
diff --git a/src/yb/master/master_auto_flags_manager.cc b/src/yb/master/master_auto_flags_manager.cc
index 03e41fa9ce..7e35fb0133 100644
--- a/src/yb/master/master_auto_flags_manager.cc
+++ b/src/yb/master/master_auto_flags_manager.cc
@@ -12,9 +12,12 @@
 //
 
 #include "yb/master/master_auto_flags_manager.h"
+
 #include "yb/consensus/consensus.pb.h"
 #include "yb/master/catalog_manager.h"
+#include "yb/master/master.h"
 #include "yb/master/xcluster/xcluster_manager_if.h"
+#include "yb/master/ysql/ysql_manager_if.h"
 #include "yb/tablet/operations/change_auto_flags_config_operation.h"
 #include "yb/util/scope_exit.h"
 
@@ -235,10 +238,10 @@ Result<bool> AreAutoFlagsCompatible(
 
 constexpr auto kYbMasterProcessName = "yb-master";
 
-MasterAutoFlagsManager::MasterAutoFlagsManager(
-    const scoped_refptr<ClockBase>& clock, FsManager* fs_manager, CatalogManager* catalog_manager)
-    : AutoFlagsManagerBase(kYbMasterProcessName, clock, fs_manager),
-      catalog_manager_(catalog_manager),
+MasterAutoFlagsManager::MasterAutoFlagsManager(Master& master)
+    : AutoFlagsManagerBase(kYbMasterProcessName, master.clock(), master.fs_manager()),
+      master_(master),
+      catalog_manager_(master.catalog_manager_impl()),
       update_lock_(mutex_, std::defer_lock) {}
 
 Status MasterAutoFlagsManager::Init(
@@ -400,6 +403,16 @@ Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> MasterAutoFlagsManager::Pro
     const bool force_version_change) {
   SCHECK(!FLAGS_disable_auto_flags_management, NotSupported, "AutoFlags management is disabled.");
 
+  SCHECK(
+      max_flag_class == AutoFlagClass::kLocalVolatile ||
+          !master_.ysql_manager().IsMajorUpgradeInProgress(),
+      InvalidArgument,
+      "Cannot promote non-volatile AutoFlags before YSQL major catalog upgrade is complete");
+
+  RETURN_NOT_OK_PREPEND(
+      master_.ts_manager()->ValidateAllTserverVersions(ValidateVersionInfoOp::kVersionEQ),
+      "Cannot promote AutoFlags before all yb-tservers have been upgraded to the current version");
+
   LOG(INFO) << "Promoting AutoFlags. max_flag_class: " << ToString(max_flag_class)
             << ", promote_non_runtime: " << promote_non_runtime_flags
             << ", force: " << force_version_change;
@@ -421,6 +434,11 @@ Result<std::pair<uint32_t, bool>> MasterAutoFlagsManager::RollbackAutoFlags(
     uint32_t rollback_version) {
   SCHECK(!FLAGS_disable_auto_flags_management, NotSupported, "AutoFlags management is disabled.");
 
+  // We do not validate tserver versions. All yb-tservers should be on the same version as the
+  // master but, we do not want to block the rollback in the rare case that some are already on a
+  // different version. Rollback is an emergency operation and we should not block it when the
+  // system is already in a bad state.
+
   auto new_config = GetConfig();
   const auto removed_flags = RemoveFlagsFromConfig(rollback_version, new_config);
   if (removed_flags.empty()) {
diff --git a/src/yb/master/master_auto_flags_manager.h b/src/yb/master/master_auto_flags_manager.h
index c0ff4dd4fe..a37d23d07f 100644
--- a/src/yb/master/master_auto_flags_manager.h
+++ b/src/yb/master/master_auto_flags_manager.h
@@ -24,6 +24,7 @@ namespace yb {
 namespace master {
 
 class CatalogManager;
+class Master;
 
 YB_DEFINE_ENUM(
     PromoteAutoFlagsOutcome, (kNoFlagsPromoted)(kNewFlagsPromoted)(kNonRuntimeFlagsPromoted));
@@ -46,9 +47,7 @@ YB_DEFINE_ENUM(
 // ProcessAutoFlagsConfigOperation on all master (including leader).
 class MasterAutoFlagsManager : public AutoFlagsManagerBase {
  public:
-  explicit MasterAutoFlagsManager(
-      const scoped_refptr<ClockBase>& clock, FsManager* fs_manager,
-      CatalogManager* catalog_manager);
+  explicit MasterAutoFlagsManager(Master& master);
 
   virtual ~MasterAutoFlagsManager() {}
 
@@ -113,6 +112,7 @@ class MasterAutoFlagsManager : public AutoFlagsManagerBase {
   Result<std::pair<uint32_t, bool>> DemoteSingleAutoFlag(
       const ProcessName& process_name, const std::string& flag_name);
 
+  Master& master_;
   CatalogManager* catalog_manager_;
   UniqueLock<std::shared_mutex> update_lock_;
 };
diff --git a/src/yb/master/master_heartbeat.proto b/src/yb/master/master_heartbeat.proto
index a1c6842100..65e6db34fc 100644
--- a/src/yb/master/master_heartbeat.proto
+++ b/src/yb/master/master_heartbeat.proto
@@ -333,6 +333,10 @@ message TSHeartbeatResponsePB {
   optional string universe_uuid = 25;
 
   optional ClientOperationLeaseUpdatePB op_lease_update = 26;
+
+  // Only set if error is set. When set, indicates that the yb-master believes
+  // the server to be in a severe bad state and should be immediately shutdown.
+  optional bool is_fatal_error = 27;
 }
 
 service MasterHeartbeat {
diff --git a/src/yb/master/master_heartbeat_service.cc b/src/yb/master/master_heartbeat_service.cc
index f49328e7e7..62be28e6a2 100644
--- a/src/yb/master/master_heartbeat_service.cc
+++ b/src/yb/master/master_heartbeat_service.cc
@@ -35,6 +35,7 @@
 #include "yb/master/ts_descriptor.h"
 #include "yb/master/ts_manager.h"
 #include "yb/master/xcluster/xcluster_manager_if.h"
+#include "yb/master/ysql/ysql_manager_if.h"
 #include "yb/master/yql_partitions_vtable.h"
 
 #include "yb/util/debug/trace_event.h"
@@ -116,6 +117,7 @@ DEFINE_test_flag(bool, simulate_sys_catalog_data_loss, false,
 DECLARE_bool(enable_register_ts_from_raft);
 DECLARE_bool(enable_heartbeat_pg_catalog_versions_cache);
 DECLARE_int32(heartbeat_rpc_timeout_ms);
+DECLARE_bool(skip_tserver_version_checks);
 
 namespace yb {
 namespace master {
@@ -1459,6 +1461,22 @@ Result<HeartbeatResult>
 MasterHeartbeatServiceImpl::RegisterTServerOrRespond(
     const LeaderEpoch& epoch, const TSHeartbeatRequestPB& req, TSHeartbeatResponsePB* resp,
     rpc::RpcContext* rpc) {
+  if (!FLAGS_skip_tserver_version_checks && req.registration().has_version_info()) {
+    const auto& registration = req.registration();
+    auto status = server_->ysql_manager().ValidateTServerVersion(registration.version_info());
+    if (!status.ok()) {
+      LOG(WARNING) << "yb-tserver " << registration.common().ShortDebugString()
+                   << " running invalid version: "
+                   << registration.version_info().ShortDebugString();
+      resp->set_is_fatal_error(true);
+      auto* error = resp->mutable_error();
+      error->set_code(MasterErrorPB::INTERNAL_ERROR);
+      StatusToPB(status, error->mutable_status());
+      rpc->RespondSuccess();
+      return status;
+    }
+  }
+
   auto desc_result = server_->ts_manager()->RegisterFromHeartbeat(
       req, epoch, server_->MakeCloudInfoPB(), &server_->proxy_cache());
   if (desc_result.ok()) {
diff --git a/src/yb/master/master_types.proto b/src/yb/master/master_types.proto
index 9a727c3b94..318db34124 100644
--- a/src/yb/master/master_types.proto
+++ b/src/yb/master/master_types.proto
@@ -17,6 +17,7 @@ package yb.master;
 option java_package = "org.yb.master";
 
 import "yb/common/common_types.proto";
+import "yb/common/version_info.proto";
 import "yb/common/wire_protocol.proto";
 
 enum RelationType {
@@ -208,6 +209,8 @@ message TSRegistrationPB {
 
   // Resources available at the tserver.
   optional ResourcesPB resources = 3;
+
+  optional VersionInfoPB version_info = 4;
 }
 
 message TServerMetricsPB {
diff --git a/src/yb/master/ts_descriptor.cc b/src/yb/master/ts_descriptor.cc
index 7546386cfe..b6e34e64bf 100644
--- a/src/yb/master/ts_descriptor.cc
+++ b/src/yb/master/ts_descriptor.cc
@@ -62,6 +62,8 @@ DECLARE_bool(TEST_enable_ysql_operation_lease);
 namespace yb {
 namespace master {
 
+bool PersistentTServerInfo::IsLive() const { return pb.state() == SysTabletServerEntryPB::LIVE; }
+
 TSDescriptor::TSDescriptor(const std::string& permanent_uuid,
                            RegisteredThroughHeartbeat registered_through_heartbeat,
                            CloudInfoPB&& local_cloud_info,
@@ -141,6 +143,11 @@ Result<TSDescriptor::WriteLock> TSDescriptor::UpdateRegistration(
   l.mutable_data()->pb.set_instance_seqno(instance.instance_seqno());
   *l.mutable_data()->pb.mutable_registration() = registration.common();
   *l.mutable_data()->pb.mutable_resources() = registration.resources();
+  if (registration.has_version_info()) {
+    *l.mutable_data()->pb.mutable_version_info() = registration.version_info();
+  } else {
+    l.mutable_data()->pb.clear_version_info();
+  }
   l.mutable_data()->pb.set_state(
       registered_through_heartbeat ? SysTabletServerEntryPB::LIVE
                                    : SysTabletServerEntryPB::UNRESPONSIVE);
@@ -483,9 +490,7 @@ std::size_t TSDescriptor::NumTasks() const {
   return tablets_pending_delete_.size();
 }
 
-bool TSDescriptor::IsLive() const {
-  return LockForRead()->pb.state() == SysTabletServerEntryPB::LIVE;
-}
+bool TSDescriptor::IsLive() const { return LockForRead()->IsLive(); }
 
 bool TSDescriptor::IsLiveAndHasReported() const {
   return IsLive() && has_tablet_report();
diff --git a/src/yb/master/ts_descriptor.h b/src/yb/master/ts_descriptor.h
index c17ebb1cdf..a1a3eb576d 100644
--- a/src/yb/master/ts_descriptor.h
+++ b/src/yb/master/ts_descriptor.h
@@ -105,8 +105,9 @@ using ProxyTuple = util::SharedPtrTuple<
   cdc::CDCServiceProxy,
   consensus::ConsensusServiceProxy>;
 
-struct PersistentTServerInfo
-    : public Persistent<SysTabletServerEntryPB> {};
+struct PersistentTServerInfo : public Persistent<SysTabletServerEntryPB> {
+  bool IsLive() const;
+};
 
 // Master-side view of a single tablet server.
 //
diff --git a/src/yb/master/ts_manager.cc b/src/yb/master/ts_manager.cc
index 2bc06db3e1..7ed7429411 100644
--- a/src/yb/master/ts_manager.cc
+++ b/src/yb/master/ts_manager.cc
@@ -35,6 +35,7 @@
 #include <mutex>
 #include <vector>
 
+#include "yb/common/version_info.h"
 #include "yb/common/wire_protocol.h"
 
 #include "yb/gutil/map-util.h"
@@ -70,6 +71,8 @@ DEFINE_test_flag(bool, enable_ysql_operation_lease, false,
     "Enables the client operation lease. The client operation lease must be held by a tserver to "
     "host pg sessions. It is refreshed by the master leader.");
 
+DEFINE_RUNTIME_bool(skip_tserver_version_checks, false, "Skip all tserver version checks");
+
 namespace yb::master {
 namespace {
 
@@ -538,6 +541,36 @@ Status TSManager::RemoveTabletServer(
   return Status::OK();
 }
 
+Status TSManager::ValidateAllTserverVersions(ValidateVersionInfoOp op) const {
+  if (FLAGS_skip_tserver_version_checks) {
+    return Status::OK();
+  }
+
+  std::vector<std::string> invalid_tservers;
+  SharedLock l(map_lock_);
+  for (const auto& [ts_id, ts_dsc] : servers_by_id_) {
+    auto l = ts_dsc->LockForRead();
+    if (!l->IsLive()) {
+      // This is probably some old tserver that has been dead for hours. When it comes back up we
+      // will validate it, so it can be ignored here.
+      continue;
+    }
+    auto version_info_opt =
+        l->pb.has_version_info() ? std::optional(std::cref(l->pb.version_info())) : std::nullopt;
+    if (!VersionInfo::ValidateVersion(version_info_opt, op)) {
+      invalid_tservers.push_back(Format(
+          "[TS $0; Version $1]", ts_dsc->ToString(),
+          version_info_opt ? version_info_opt->get().ShortDebugString() : "<NA>"));
+    }
+  }
+
+  SCHECK_FORMAT(
+      invalid_tservers.empty(), IllegalState, "yb-tserver(s) not on the correct version: $0",
+      yb::ToString(invalid_tservers));
+
+  return Status::OK();
+}
+
 HeartbeatResult::HeartbeatResult() : desc(nullptr), lease_update(std::nullopt) { }
 
 HeartbeatResult::HeartbeatResult(
diff --git a/src/yb/master/ts_manager.h b/src/yb/master/ts_manager.h
index 4229c650a1..13f9d8b56c 100644
--- a/src/yb/master/ts_manager.h
+++ b/src/yb/master/ts_manager.h
@@ -39,6 +39,7 @@
 
 #include "yb/common/common_fwd.h"
 
+#include "yb/common/version_info.h"
 #include "yb/gutil/macros.h"
 #include "yb/gutil/thread_annotations.h"
 
@@ -190,6 +191,9 @@ class TSManager {
       const std::string& permanent_uuid, const BlacklistSet& blacklist,
       const std::vector<TableInfoPtr>& tables, const LeaderEpoch& epoch);
 
+  // Make sure all live tservers are on the expected version.
+  Status ValidateAllTserverVersions(ValidateVersionInfoOp op) const;
+
  private:
   // Performs all mutations necessary to register a new tserver or update the registration of an
   // existing tserver. There are two registration pathways, one through heartbeats and the other
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
index 9c2c3f6966..ea6a035dc1 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.cc
@@ -162,10 +162,20 @@ IsOperationDoneResult YsqlInitDBAndMajorUpgradeHandler::IsYsqlMajorCatalogUpgrad
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::FinalizeYsqlMajorCatalogUpgrade(const LeaderEpoch& epoch) {
+  RETURN_NOT_OK_PREPEND(
+      master_.ts_manager()->ValidateAllTserverVersions(ValidateVersionInfoOp::kVersionEQ),
+      "Cannot finalize YSQL major catalog upgrade before all yb-tservers have been upgraded to the "
+      "current version");
+
   return TransitionMajorCatalogUpgradeState(YsqlMajorCatalogUpgradeInfoPB::DONE, epoch);
 }
 
 Status YsqlInitDBAndMajorUpgradeHandler::RollbackYsqlMajorCatalogVersion(const LeaderEpoch& epoch) {
+  RETURN_NOT_OK_PREPEND(
+      master_.ts_manager()->ValidateAllTserverVersions(ValidateVersionInfoOp::kYsqlMajorVersionLT),
+      "Cannot rollback YSQL major catalog while yb-tservers are running on a newer YSQL major "
+      "version");
+
   // Since Rollback is synchronous, we can perform the state transitions inside the async
   // function. It also ensures there are no inflight operations when the rollback state transition
   // occurs.
@@ -632,4 +642,46 @@ Status YsqlInitDBAndMajorUpgradeHandler::CleanupPreviousYsqlMajorCatalog(const L
   return Status::OK();
 }
 
+Status YsqlInitDBAndMajorUpgradeHandler::ValidateTServerVersion(
+    const VersionInfoPB& ts_version) const {
+  // Dev note: Returning a bad status will cause the yb-tserver to FATAL.
+  const auto current_major_version = VersionInfo::YsqlMajorVersion();
+
+  if (!ysql_major_upgrade_in_progress_) {
+    // When not in YSQL major upgrade only tservers of the current version are allowed.
+    SCHECK_FORMAT(
+        VersionInfo::ValidateVersion(ts_version, ValidateVersionInfoOp::kYsqlMajorVersionEQ),
+        IllegalState,
+        "yb-tserver YSQL major version $0 does not match the cluster version $1. Restart the "
+        "yb-tserver in the correct version.",
+        ts_version.ysql_major_version(), current_major_version);
+
+    return Status::OK();
+  }
+
+  if (ysql_catalog_config_.GetMajorCatalogUpgradeState() ==
+      YsqlMajorCatalogUpgradeInfoPB::MONITORING) {
+    // During monitoring phase we allow the tservers to be in both previous and current version.
+    SCHECK_FORMAT(
+        VersionInfo::ValidateVersion(ts_version, ValidateVersionInfoOp::kYsqlMajorVersionLE),
+        IllegalState,
+        "yb-tserver YSQL major version $0 is too high. Restart the yb-tserver in a version less "
+        "than or equal to YSQL major version $1.",
+        ts_version.ysql_major_version(), current_major_version);
+
+    return Status::OK();
+  }
+
+  // During all other phases of the major upgrade, the tserver must be in the previous version.
+  SCHECK_FORMAT(
+      VersionInfo::ValidateVersion(ts_version, ValidateVersionInfoOp::kYsqlMajorVersionLT),
+      IllegalState,
+      "yb-tserver YSQL major version $0 is too high. Cluster is not in a state to accept "
+      "yb-tservers on a higher version yet. Restart the yb-tserver in the previous YSQL major "
+      "version",
+      ts_version.ysql_major_version());
+
+  return Status::OK();
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
index e5ca6e288c..cf2cea0c35 100644
--- a/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
+++ b/src/yb/master/ysql/ysql_initdb_major_upgrade_handler.h
@@ -23,6 +23,7 @@ namespace yb {
 
 class IsOperationDoneResult;
 class ThreadPool;
+class VersionInfoPB;
 
 namespace master {
 struct LeaderEpoch;
@@ -79,6 +80,8 @@ class YsqlInitDBAndMajorUpgradeHandler {
   Status CleanupPreviousYsqlMajorCatalog(const LeaderEpoch& epoch);
   void ScheduleCleanupPreviousYsqlMajorCatalog(const LeaderEpoch& epoch);
 
+  Status ValidateTServerVersion(const VersionInfoPB& version) const;
+
  private:
   using DbNameToOidList = std::vector<std::pair<std::string, YbcPgOid>>;
 
diff --git a/src/yb/master/ysql/ysql_manager.cc b/src/yb/master/ysql/ysql_manager.cc
index 4d9b9863fb..61f95ae5a8 100644
--- a/src/yb/master/ysql/ysql_manager.cc
+++ b/src/yb/master/ysql/ysql_manager.cc
@@ -240,4 +240,8 @@ Status YsqlManager::ValidateWriteToCatalogTableAllowed(
   return Status::OK();
 }
 
+Status YsqlManager::ValidateTServerVersion(const VersionInfoPB& version) const {
+  return ysql_initdb_and_major_upgrade_helper_->ValidateTServerVersion(version);
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/ysql/ysql_manager.h b/src/yb/master/ysql/ysql_manager.h
index 013b4d1b4c..8fdefe73b8 100644
--- a/src/yb/master/ysql/ysql_manager.h
+++ b/src/yb/master/ysql/ysql_manager.h
@@ -57,7 +57,7 @@ class YsqlManager : public YsqlManagerIf {
 
   Status SetInitDbDone(const LeaderEpoch& epoch);
 
-  bool IsMajorUpgradeInProgress() const;
+  bool IsMajorUpgradeInProgress() const override;
 
   void HandleNewTableId(const TableId& table_id);
 
@@ -103,6 +103,8 @@ class YsqlManager : public YsqlManagerIf {
 
   Status ValidateWriteToCatalogTableAllowed(const TableId& table_id, bool is_forced_update) const;
 
+  Status ValidateTServerVersion(const VersionInfoPB& version) const override;
+
  private:
   Result<bool> StartRunningInitDbIfNeededInternal(const LeaderEpoch& epoch);
 
diff --git a/src/yb/master/ysql/ysql_manager_if.h b/src/yb/master/ysql/ysql_manager_if.h
index a10f2813db..4af5765c05 100644
--- a/src/yb/master/ysql/ysql_manager_if.h
+++ b/src/yb/master/ysql/ysql_manager_if.h
@@ -17,7 +17,11 @@
 #include "yb/master/leader_epoch.h"
 #include "yb/util/status_fwd.h"
 
-namespace yb::master {
+namespace yb {
+
+class VersionInfoPB;
+
+namespace master {
 
 class YsqlCatalogConfig;
 
@@ -35,6 +39,11 @@ class YsqlManagerIf {
 
   virtual Result<TableId> GetVersionSpecificCatalogTableId(
       const TableId& current_table_id) const = 0;
+
+  virtual bool IsMajorUpgradeInProgress() const = 0;
+
+  virtual Status ValidateTServerVersion(const VersionInfoPB& version) const = 0;
 };
 
-}  // namespace yb::master
+}  // namespace master
+}  // namespace yb
diff --git a/src/yb/tserver/heartbeater.cc b/src/yb/tserver/heartbeater.cc
index 942af33063..8aa08a2c5f 100644
--- a/src/yb/tserver/heartbeater.cc
+++ b/src/yb/tserver/heartbeater.cc
@@ -44,6 +44,7 @@
 
 #include "yb/common/common_flags.h"
 #include "yb/common/hybrid_time.h"
+#include "yb/common/version_info.h"
 #include "yb/common/wire_protocol.h"
 
 #include "yb/gutil/bind.h"
@@ -343,6 +344,8 @@ Status Heartbeater::Thread::SetupRegistration(master::TSRegistrationPB* reg) {
   if (tablet_overhead_limit > 0) {
     resources->set_tablet_overhead_ram_in_bytes(tablet_overhead_limit);
   }
+  VersionInfo::GetVersionInfoPB(reg->mutable_version_info());
+
   return Status::OK();
 }
 
@@ -486,8 +489,12 @@ Status Heartbeater::Thread::TryHeartbeat() {
           break;
         }
         default:
-          return StatusFromPB(resp.error().status());
-
+          auto status = StatusFromPB(resp.error().status());
+          if (resp.is_fatal_error()) {
+            // yb-master has requested us to terminate the process immediately.
+            LOG(FATAL) << "Unable to join universe: " << status;
+          }
+          return status;
       }
     }
 
