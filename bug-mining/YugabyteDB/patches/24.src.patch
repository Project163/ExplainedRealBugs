diff --git a/src/yb/cdc/xcluster_producer-test.cc b/src/yb/cdc/xcluster_producer-test.cc
index f65b72b90f..856d18182a 100644
--- a/src/yb/cdc/xcluster_producer-test.cc
+++ b/src/yb/cdc/xcluster_producer-test.cc
@@ -25,6 +25,7 @@
 #include "yb/integration-tests/mini_cluster.h"
 #include "yb/integration-tests/yb_mini_cluster_test_base.h"
 #include "yb/master/catalog_manager.h"
+#include "yb/master/master_auto_flags_manager.h"
 #include "yb/master/master_cluster.pb.h"
 #include "yb/master/mini_master.h"
 #include "yb/master/master.h"
@@ -345,7 +346,7 @@ TEST_F(XClusterProducerTest, ProducerUpgrade) {
   promote_auto_flags_req.set_force(true);
   master::PromoteAutoFlagsResponsePB promote_auto_flags_resp;
   auto leader_master = ASSERT_RESULT(cluster_->GetLeaderMiniMaster())->master();
-  ASSERT_OK(leader_master->catalog_manager_impl()->PromoteAutoFlags(
+  ASSERT_OK(leader_master->GetAutoFlagsManagerImpl()->PromoteAutoFlags(
       &promote_auto_flags_req, &promote_auto_flags_resp));
   ASSERT_FALSE(promote_auto_flags_resp.has_error());
   ASSERT_EQ(promote_auto_flags_resp.new_config_version(), config_version + 1);
diff --git a/src/yb/client/CMakeLists.txt b/src/yb/client/CMakeLists.txt
index 31f246dcff..4eec55e57b 100644
--- a/src/yb/client/CMakeLists.txt
+++ b/src/yb/client/CMakeLists.txt
@@ -36,7 +36,6 @@ set(YB_PCH_DEP_LIBS opid_proto)
 set(CLIENT_SRCS
   async_initializer.cc
   async_rpc.cc
-  auto_flags_manager.cc
   batcher.cc
   client.cc
   client_builder-internal.cc
diff --git a/src/yb/integration-tests/auto_flags-itest.cc b/src/yb/integration-tests/auto_flags-itest.cc
index c75c9b8c4d..78eb34de30 100644
--- a/src/yb/integration-tests/auto_flags-itest.cc
+++ b/src/yb/integration-tests/auto_flags-itest.cc
@@ -22,6 +22,7 @@
 #include "yb/integration-tests/yb_mini_cluster_test_base.h"
 
 #include "yb/master/catalog_manager.h"
+#include "yb/master/master_auto_flags_manager.h"
 #include "yb/master/mini_master.h"
 #include "yb/master/master.h"
 
@@ -33,8 +34,6 @@
 #include "yb/tserver/mini_tablet_server.h"
 #include "yb/tserver/tablet_server.h"
 
-#include "yb/client/auto_flags_manager.h"
-
 #include "yb/util/flags.h"
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/version_info.h"
@@ -330,7 +329,7 @@ class AutoFlagsMiniClusterTest : public MiniClusterTestWithClient<MiniCluster> {
     req.set_force(force);
 
     master::PromoteAutoFlagsResponsePB resp;
-    RETURN_NOT_OK(leader_master->catalog_manager_impl()->PromoteAutoFlags(&req, &resp));
+    RETURN_NOT_OK(leader_master->GetAutoFlagsManagerImpl()->PromoteAutoFlags(&req, &resp));
 
     if (resp.has_error()) {
       return StatusFromPB(resp.error().status());
@@ -362,7 +361,7 @@ class AutoFlagsMiniClusterTest : public MiniClusterTestWithClient<MiniCluster> {
 
     master::RollbackAutoFlagsResponsePB rollback_resp;
     auto s =
-        leader_master->catalog_manager_impl()->RollbackAutoFlags(&rollback_req, &rollback_resp);
+        leader_master->GetAutoFlagsManagerImpl()->RollbackAutoFlags(&rollback_req, &rollback_resp);
     auto config = leader_master->GetAutoFlagsConfig();
     if (!expect_success) {
       CHECK(!s.ok());
@@ -387,7 +386,7 @@ class AutoFlagsMiniClusterTest : public MiniClusterTestWithClient<MiniCluster> {
     req.set_process_name(process_name);
     req.set_auto_flag_name(flag_name);
     master::DemoteSingleAutoFlagResponsePB resp;
-    auto s = leader_master->catalog_manager_impl()->DemoteSingleAutoFlag(&req, &resp);
+    auto s = leader_master->GetAutoFlagsManagerImpl()->DemoteSingleAutoFlag(&req, &resp);
     auto config = leader_master->GetAutoFlagsConfig();
 
     if (!expect_success) {
@@ -467,7 +466,7 @@ TEST_F(AutoFlagsMiniClusterTest, Promote) {
       /* promote_auto_flags */
       [&](const auto& req) -> Result<master::PromoteAutoFlagsResponsePB> {
         master::PromoteAutoFlagsResponsePB resp;
-        RETURN_NOT_OK(leader_master->catalog_manager_impl()->PromoteAutoFlags(&req, &resp));
+        RETURN_NOT_OK(leader_master->GetAutoFlagsManagerImpl()->PromoteAutoFlags(&req, &resp));
         return resp;
       },
       /* validate_config_on_all_nodes */
@@ -586,12 +585,15 @@ TEST_F(AutoFlagsMiniClusterTest, DemoteFlagBeforeBackfillFlagInfos) {
   ASSERT_EQ(config.promoted_flags(1).flag_infos_size(), 0);
 }
 
+// This test is in master namespace so that it can access private methods of
+// yb::master::MasterAutoFlagsManager.
+namespace master {
 TEST_F(AutoFlagsMiniClusterTest, CheckMissingFlag) {
   ASSERT_OK(RunSetUp());
   ASSERT_OK(ValidateConfig());
 
   auto leader_master = ASSERT_RESULT(cluster_->GetLeaderMiniMaster());
-  auto auto_flags_manager = leader_master->master()->auto_flags_manager();
+  auto auto_flags_manager = leader_master->master()->GetAutoFlagsManagerImpl();
 
   auto config = auto_flags_manager->GetConfig();
   for (auto& promoted_flags : *config.mutable_promoted_flags()) {
@@ -604,6 +606,7 @@ TEST_F(AutoFlagsMiniClusterTest, CheckMissingFlag) {
   ASSERT_TRUE(s.ToString().find("missing_flag") != std::string::npos) << s;
   ASSERT_TRUE(s.ToString().find(VersionInfo::GetShortVersionString()) != std::string::npos) << s;
 }
+}  // namespace master
 
 // Make sure AutoFlags are not applied before auto_flags_apply_delay_ms
 TEST_F(AutoFlagsMiniClusterTest, HeartbeatDelay) {
diff --git a/src/yb/integration-tests/xcluster/xcluster_upgrade-test.cc b/src/yb/integration-tests/xcluster/xcluster_upgrade-test.cc
index 9204e720e7..6e7850e95d 100644
--- a/src/yb/integration-tests/xcluster/xcluster_upgrade-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_upgrade-test.cc
@@ -16,6 +16,7 @@
 #include "yb/integration-tests/xcluster/xcluster_ycql_test_base.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master.h"
+#include "yb/master/master_auto_flags_manager.h"
 #include "yb/master/master_cluster.pb.h"
 #include "yb/master/mini_master.h"
 #include "yb/util/flags/auto_flags_util.h"
@@ -74,7 +75,7 @@ class XClusterUpgradeTest : public XClusterYcqlTestBase {
     auto leader_master = VERIFY_RESULT(cluster.GetLeaderMiniMaster())->master();
 
     master::PromoteAutoFlagsResponsePB resp;
-    RETURN_NOT_OK(leader_master->catalog_manager_impl()->PromoteAutoFlags(&req, &resp));
+    RETURN_NOT_OK(leader_master->GetAutoFlagsManagerImpl()->PromoteAutoFlags(&req, &resp));
     if (resp.has_error()) {
       return StatusFromPB(resp.error().status());
     }
@@ -87,7 +88,7 @@ class XClusterUpgradeTest : public XClusterYcqlTestBase {
     auto leader_master = VERIFY_RESULT(cluster.GetLeaderMiniMaster())->master();
 
     master::RollbackAutoFlagsResponsePB resp;
-    RETURN_NOT_OK(leader_master->catalog_manager_impl()->RollbackAutoFlags(&req, &resp));
+    RETURN_NOT_OK(leader_master->GetAutoFlagsManagerImpl()->RollbackAutoFlags(&req, &resp));
     if (resp.has_error()) {
       return StatusFromPB(resp.error().status());
     }
@@ -102,7 +103,7 @@ class XClusterUpgradeTest : public XClusterYcqlTestBase {
 
     master::DemoteSingleAutoFlagResponsePB resp;
     auto leader_master = VERIFY_RESULT(cluster.GetLeaderMiniMaster())->master();
-    RETURN_NOT_OK(leader_master->catalog_manager_impl()->DemoteSingleAutoFlag(&req, &resp));
+    RETURN_NOT_OK(leader_master->GetAutoFlagsManagerImpl()->DemoteSingleAutoFlag(&req, &resp));
     if (resp.has_error()) {
       return StatusFromPB(resp.error().status());
     }
diff --git a/src/yb/master/CMakeLists.txt b/src/yb/master/CMakeLists.txt
index 82c9277d31..38ec349381 100644
--- a/src/yb/master/CMakeLists.txt
+++ b/src/yb/master/CMakeLists.txt
@@ -72,7 +72,6 @@ set(MASTER_SRCS
   async_rpc_tasks.cc
   async_snapshot_tasks.cc
   async_snapshot_transfer_task.cc
-  auto_flags_orchestrator.cc
   master_call_home.cc
   backfill_index.cc
   catalog_manager.cc
@@ -91,6 +90,7 @@ set(MASTER_SRCS
   flush_manager.cc
   master.cc
   master_admin_service.cc
+  master_auto_flags_manager.cc
   tablet_health_manager.cc
   master_backup_service.cc
   master_client_service.cc
@@ -180,6 +180,7 @@ set(MASTER_DEPS
   yb_pggate_flags
   yb_pggate
   cdc_util
+  auto_flags_manager_common
 )
 
 ADD_YB_LIBRARY(master
diff --git a/src/yb/master/auto_flags_orchestrator.h b/src/yb/master/auto_flags_orchestrator.h
deleted file mode 100644
index 081cbe79ec..0000000000
--- a/src/yb/master/auto_flags_orchestrator.h
+++ /dev/null
@@ -1,71 +0,0 @@
-// Copyright (c) YugaByte, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
-// in compliance with the License.  You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software distributed under the License
-// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
-// or implied.  See the License for the specific language governing permissions and limitations
-// under the License.
-//
-
-#pragma once
-
-#include "yb/util/flags/auto_flags.h"
-#include "yb/util/flags/auto_flags_util.h"
-#include "yb/util/status.h"
-
-namespace yb {
-class AutoFlagsConfigPB;
-class AutoFlagsManager;
-class CatalogManager;
-
-namespace master {
-// Create and persist a empty AutoFlags config with version set to 1.
-// Intended to be used during the first process startup after the upgrade of clusters created on
-// versions without AutoFlags.
-Status CreateEmptyAutoFlagsConfig(AutoFlagsManager& auto_flag_manager);
-
-// Create and persist a new AutoFlags config where all AutoFlags of class within
-// FLAGS_limit_auto_flag_promote_for_new_universe are promoted and Apply it.
-// Intended to be used in new cluster created with AutoFlags.
-Status CreateAutoFlagsConfigForNewCluster(AutoFlagsManager& auto_flag_manager);
-
-YB_DEFINE_ENUM(
-    PromoteAutoFlagsOutcome, (kNoFlagsPromoted)(kNewFlagsPromoted)(kNonRuntimeFlagsPromoted));
-
-// Promote eligible AutoFlags up to max_flag_class. If no new flags were eligible, Status
-// AlreadyPresent is returned. When force is set, the config version is bumped up even if no new
-// flags are eligible. Returns the new config version and whether any non-runtime flags were
-// promoted.
-Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteAutoFlags(
-    const AutoFlagClass max_flag_class, const PromoteNonRuntimeAutoFlags promote_non_runtime_flags,
-    const bool force, AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager);
-
-Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteSingleAutoFlag(
-    const ProcessName& process_name, const std::string& flag_name,
-    AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager);
-
-// Rollback AutoFlags to the specified version. Only Volatile AutoFlags are eligible for rollback.
-// Returns weather any flags were rolled back and the new config version.
-Result<std::pair<uint32_t, bool>> RollbackAutoFlags(
-    uint32_t rollback_version, AutoFlagsManager& auto_flag_manager,
-    CatalogManager* catalog_manager);
-
-// Demote a single AutoFlag. Returns weather the flag was demoted and the new config version.
-// Note: This is extremely dangerous and should only be used under the guidance of YugabyteDB
-// engineering team.
-Result<std::pair<uint32_t, bool>> DemoteSingleAutoFlag(
-    const ProcessName& process_name, const std::string& flag_name,
-    AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager);
-
-// Wrapper over the AutoFlagsUtil::AreAutoFlagsCompatible.
-Result<bool> AreAutoFlagsCompatible(
-    const AutoFlagsConfigPB& base_config, const AutoFlagsConfigPB& config_to_check,
-    AutoFlagClass min_class);
-
-}  // namespace master
-
-}  // namespace yb
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index c32db6791d..644b540d3c 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -117,7 +117,6 @@
 
 #include "yb/master/leader_epoch.h"
 #include "yb/master/master_fwd.h"
-#include "yb/master/auto_flags_orchestrator.h"
 #include "yb/master/async_rpc_tasks.h"
 #include "yb/master/backfill_index.h"
 #include "yb/master/catalog_entity_info.h"
@@ -13453,84 +13452,6 @@ Status CatalogManager::SubmitToSysCatalog(std::unique_ptr<tablet::Operation> ope
   return Status::OK();
 }
 
-Status CatalogManager::PromoteAutoFlags(
-    const PromoteAutoFlagsRequestPB* req, PromoteAutoFlagsResponsePB* resp) {
-  const auto max_class = VERIFY_RESULT_PREPEND(
-      ParseEnumInsensitive<AutoFlagClass>(req->max_flag_class()),
-      "Invalid value provided for flag class");
-
-  // It is expected PromoteAutoFlags RPC is triggered only for upgrades, hence it is required
-  // to avoid promotion of flags with AutoFlagClass::kNewInstallsOnly class.
-  SCHECK_LT(
-      max_class, AutoFlagClass::kNewInstallsOnly, InvalidArgument,
-      Format(
-          "max_class cannot be set to $0.",
-          ToString(AutoFlagClass::kNewInstallsOnly)));
-
-  auto [new_config_version, outcome] = VERIFY_RESULT(master::PromoteAutoFlags(
-      max_class, PromoteNonRuntimeAutoFlags(req->promote_non_runtime_flags()), req->force(),
-      *master_->auto_flags_manager(), this));
-
-  resp->set_new_config_version(new_config_version);
-  resp->set_flags_promoted(outcome != PromoteAutoFlagsOutcome::kNoFlagsPromoted);
-  resp->set_non_runtime_flags_promoted(
-      outcome == PromoteAutoFlagsOutcome::kNonRuntimeFlagsPromoted);
-  return Status::OK();
-}
-
-Status CatalogManager::RollbackAutoFlags(
-    const RollbackAutoFlagsRequestPB* req, RollbackAutoFlagsResponsePB* resp) {
-  auto [new_config_version, outcome] = VERIFY_RESULT(
-      master::RollbackAutoFlags(req->rollback_version(), *master_->auto_flags_manager(), this));
-
-  resp->set_new_config_version(new_config_version);
-  resp->set_flags_rolledback(outcome);
-  return Status::OK();
-}
-
-Status CatalogManager::PromoteSingleAutoFlag(
-    const PromoteSingleAutoFlagRequestPB* req, PromoteSingleAutoFlagResponsePB* resp) {
-  auto [new_config_version, outcome] = VERIFY_RESULT(master::PromoteSingleAutoFlag(
-      req->process_name(), req->auto_flag_name(), *master_->auto_flags_manager(), this));
-
-  resp->set_new_config_version(new_config_version);
-  resp->set_flag_promoted(outcome != PromoteAutoFlagsOutcome::kNoFlagsPromoted);
-  resp->set_non_runtime_flag_promoted(outcome == PromoteAutoFlagsOutcome::kNonRuntimeFlagsPromoted);
-  return Status::OK();
-}
-
-Status CatalogManager::DemoteSingleAutoFlag(
-    const DemoteSingleAutoFlagRequestPB* req, DemoteSingleAutoFlagResponsePB* resp) {
-  auto [new_config_version, outcome] = VERIFY_RESULT(master::DemoteSingleAutoFlag(
-      req->process_name(), req->auto_flag_name(), *master_->auto_flags_manager(), this));
-
-  resp->set_new_config_version(new_config_version);
-  resp->set_flag_demoted(outcome);
-  return Status::OK();
-}
-
-Status CatalogManager::ValidateAutoFlagsConfig(
-    const ValidateAutoFlagsConfigRequestPB* req, ValidateAutoFlagsConfigResponsePB* resp) {
-  VLOG_WITH_FUNC(1) << req->ShortDebugString();
-
-  auto min_class = AutoFlagClass::kLocalVolatile;
-  if (req->has_min_flag_class()) {
-    min_class = VERIFY_RESULT_PREPEND(
-        yb::UnderlyingToEnumSlow<yb::AutoFlagClass>(req->min_flag_class()),
-        "Invalid value provided for flag class");
-  }
-
-  auto local_auto_flag_config = master_->GetAutoFlagsConfig();
-  auto valid =
-      VERIFY_RESULT(AreAutoFlagsCompatible(local_auto_flag_config, req->config(), min_class));
-  VLOG_WITH_FUNC(1) << valid;
-
-  resp->set_valid(valid);
-  resp->set_config_version(local_auto_flag_config.config_version());
-
-  return Status::OK();
-}
-
 Status CatalogManager::GetStatefulServiceLocation(
     const GetStatefulServiceLocationRequestPB* req, GetStatefulServiceLocationResponsePB* resp) {
   VLOG(4) << "GetStatefulServiceLocation: " << req->ShortDebugString();
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index 3808ad299b..9aa64c9c35 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -1147,16 +1147,6 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
 
   Status SubmitToSysCatalog(std::unique_ptr<tablet::Operation> operation);
 
-  Status PromoteAutoFlags(const PromoteAutoFlagsRequestPB* req, PromoteAutoFlagsResponsePB* resp);
-  Status RollbackAutoFlags(
-      const RollbackAutoFlagsRequestPB* req, RollbackAutoFlagsResponsePB* resp);
-  Status PromoteSingleAutoFlag(
-      const PromoteSingleAutoFlagRequestPB* req, PromoteSingleAutoFlagResponsePB* resp);
-  Status DemoteSingleAutoFlag(
-      const DemoteSingleAutoFlagRequestPB* req, DemoteSingleAutoFlagResponsePB* resp);
-  Status ValidateAutoFlagsConfig(
-      const ValidateAutoFlagsConfigRequestPB* req, ValidateAutoFlagsConfigResponsePB* resp);
-
   Status ReportYsqlDdlTxnStatus(
       const ReportYsqlDdlTxnStatusRequestPB* req,
       ReportYsqlDdlTxnStatusResponsePB* resp,
diff --git a/src/yb/master/master.cc b/src/yb/master/master.cc
index c00cb26812..af8589181a 100644
--- a/src/yb/master/master.cc
+++ b/src/yb/master/master.cc
@@ -37,9 +37,9 @@
 #include <memory>
 #include <vector>
 
+#include "yb/master/master_auto_flags_manager.h"
 #include "yb/util/logging.h"
 
-#include "yb/client/auto_flags_manager.h"
 #include "yb/client/async_initializer.h"
 #include "yb/client/client.h"
 
@@ -50,7 +50,6 @@
 
 #include "yb/gutil/bind.h"
 
-#include "yb/master/auto_flags_orchestrator.h"
 #include "yb/master/master_fwd.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/flush_manager.h"
@@ -106,6 +105,7 @@ DEFINE_NON_RUNTIME_int32(master_backup_svc_queue_length, 50,
 TAG_FLAG(master_backup_svc_queue_length, advanced);
 
 DECLARE_string(cert_node_filename);
+DECLARE_bool(master_join_existing_universe);
 
 METRIC_DEFINE_entity(cluster);
 
@@ -165,9 +165,10 @@ namespace master {
 Master::Master(const MasterOptions& opts)
     : DbServerBase("Master", opts, "yb.master", server::CreateMemTrackerForServer()),
       state_(kStopped),
-      auto_flags_manager_(new AutoFlagsManager("yb-master", clock(), fs_manager_.get())),
       ts_manager_(new TSManager()),
       catalog_manager_(new CatalogManager(this)),
+      auto_flags_manager_(
+          new MasterAutoFlagsManager(clock(), fs_manager_.get(), catalog_manager_impl())),
       ysql_backends_manager_(new YsqlBackendsManager(this, catalog_manager_->AsyncTaskPool())),
       path_handlers_(new MasterPathHandlers(this)),
       flush_manager_(new FlushManager(this, catalog_manager())),
@@ -235,20 +236,16 @@ Status Master::Init() {
 }
 
 Status Master::InitAutoFlags() {
-  RETURN_NOT_OK(auto_flags_manager_->Init(options_.HostsString()));
-
-  if (!VERIFY_RESULT(auto_flags_manager_->LoadFromFile())) {
-    if (fs_manager_->LookupTablet(kSysCatalogTabletId)) {
-      // Pre-existing cluster
-      RETURN_NOT_OK(CreateEmptyAutoFlagsConfig(*auto_flags_manager_.get()));
-    } else if (!opts().AreMasterAddressesProvided()) {
-      // New master in Shell mode
-      LOG(INFO) << "AutoFlags initialization delayed as master is in Shell mode.";
-    } else {
-      // New cluster
-      RETURN_NOT_OK(CreateAutoFlagsConfigForNewCluster(*auto_flags_manager_.get()));
-    }
-  }
+  // Will we be in shell mode if we dont have a sys catalog yet?
+  bool is_shell_mode_if_new =
+      FLAGS_master_join_existing_universe || !opts().AreMasterAddressesProvided();
+
+  RETURN_NOT_OK(auto_flags_manager_->Init(
+      options_.HostsString(),
+      [this]() {
+        return fs_manager_->LookupTablet(kSysCatalogTabletId);
+      } /* has_sys_catalog_func */,
+      is_shell_mode_if_new));
 
   return RpcAndWebServerBase::InitAutoFlags();
 }
@@ -262,8 +259,7 @@ Status Master::InitAutoFlagsFromMasterLeader(const HostPort& leader_address) {
       opts().IsShellMode(), IllegalState,
       "Cannot load AutoFlags from another master when not in shell mode.");
 
-  return auto_flags_manager_->LoadFromMaster(
-      options_.HostsString(), {{leader_address}});
+  return auto_flags_manager_->LoadFromMasterLeader(options_.HostsString(), {{leader_address}});
 }
 
 MonoDelta Master::default_client_timeout() {
diff --git a/src/yb/master/master.h b/src/yb/master/master.h
index df4411db43..3bde9c6d92 100644
--- a/src/yb/master/master.h
+++ b/src/yb/master/master.h
@@ -62,7 +62,7 @@ class MaintenanceManager;
 class RpcServer;
 class ServerEntryPB;
 class ThreadPool;
-class AutoFlagsManager;
+class AutoFlagsManagerBase;
 class AutoFlagsConfigPB;
 
 namespace server {
@@ -79,6 +79,8 @@ class SecureContext;
 
 namespace master {
 
+class MasterAutoFlagsManager;
+
 class Master : public tserver::DbServerBase {
  public:
   explicit Master(const MasterOptions& opts);
@@ -123,12 +125,12 @@ class Master : public tserver::DbServerBase {
     return ysql_backends_manager_.get();
   }
 
-  AutoFlagsManager* auto_flags_manager() { return auto_flags_manager_.get(); }
-
   PermissionsManager& permissions_manager();
 
   EncryptionManager& encryption_manager();
 
+  MasterAutoFlagsManager* GetAutoFlagsManagerImpl() { return auto_flags_manager_.get(); }
+
   scoped_refptr<MetricEntity> metric_entity_cluster();
 
   void SetMasterAddresses(std::shared_ptr<server::MasterAddresses> master_addresses) {
@@ -247,9 +249,9 @@ class Master : public tserver::DbServerBase {
 
   std::atomic<MasterState> state_;
 
-  std::unique_ptr<AutoFlagsManager> auto_flags_manager_;
   std::unique_ptr<TSManager> ts_manager_;
   std::unique_ptr<CatalogManager> catalog_manager_;
+  std::unique_ptr<MasterAutoFlagsManager> auto_flags_manager_;
   std::unique_ptr<YsqlBackendsManager> ysql_backends_manager_;
   std::unique_ptr<MasterPathHandlers> path_handlers_;
   std::unique_ptr<FlushManager> flush_manager_;
diff --git a/src/yb/master/auto_flags_orchestrator.cc b/src/yb/master/master_auto_flags_manager.cc
similarity index 53%
rename from src/yb/master/auto_flags_orchestrator.cc
rename to src/yb/master/master_auto_flags_manager.cc
index 0462920170..1634ff2106 100644
--- a/src/yb/master/auto_flags_orchestrator.cc
+++ b/src/yb/master/master_auto_flags_manager.cc
@@ -1,4 +1,4 @@
-// Copyright (c) YugaByte, Inc.
+// Copyright (c) YugabyteDB, Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 // in compliance with the License.  You may obtain a copy of the License at
@@ -11,25 +11,11 @@
 // under the License.
 //
 
-#include <fstream>
-#include <string>
-
-#include "yb/client/auto_flags_manager.h"
-
-#include "yb/common/wire_protocol.h"
-#include "yb/common/wire_protocol.pb.h"
-
+#include "yb/master/master_auto_flags_manager.h"
 #include "yb/consensus/consensus.pb.h"
-
-#include "yb/master/auto_flags_orchestrator.h"
 #include "yb/master/catalog_manager.h"
-
 #include "yb/tablet/operations/change_auto_flags_config_operation.h"
-#include "yb/tablet/operations/operation.h"
-
-#include "yb/util/countdown_latch.h"
-#include "yb/util/flags/auto_flags_util.h"
-#include "yb/util/flags.h"
+#include "yb/util/scope_exit.h"
 
 DEFINE_NON_RUNTIME_int32(limit_auto_flag_promote_for_new_universe,
     yb::to_underlying(yb::AutoFlagClass::kNewInstallsOnly),
@@ -57,12 +43,12 @@ bool ValidateAutoFlagClass(const char* flag_name, int32_t value) {
   return true;
 }
 }  // namespace
+
 DEFINE_validator(limit_auto_flag_promote_for_new_universe, &ValidateAutoFlagClass);
 
 DECLARE_bool(disable_auto_flags_management);
 
 namespace yb::master {
-using OK = Status::OK;
 
 namespace {
 
@@ -98,20 +84,20 @@ const AutoFlagInfo* FindOrNullptr(
 // true if any new flags were added. Config with version 0 is always bumped to 1. Second output bool
 // indicates if any non-runtime flags were added.
 PromoteAutoFlagsOutcome InsertFlagsToConfig(
-    const AutoFlagsInfoMap& flags_to_insert, AutoFlagsConfigPB* config, bool force_version_change) {
+    const AutoFlagsInfoMap& flags_to_insert, AutoFlagsConfigPB& config, bool force_version_change) {
   auto non_runtime_flags_added = false;
   bool config_changed = false;
   // Initial config or forced version bump.
-  if (config->config_version() == kInvalidAutoFlagsConfigVersion || force_version_change) {
+  if (config.config_version() == kInvalidAutoFlagsConfigVersion || force_version_change) {
     config_changed = true;
   }
-  auto new_config_version = config->config_version() + 1;
+  auto new_config_version = config.config_version() + 1;
 
   for (const auto& [process_name, process_flags] : flags_to_insert) {
     if (!process_flags.empty()) {
       google::protobuf::RepeatedPtrField<std::string>* process_flags_pb = nullptr;
       google::protobuf::RepeatedPtrField<PromotedFlagInfoPB>* process_flag_info_pb = nullptr;
-      for (auto& promoted_flags : *config->mutable_promoted_flags()) {
+      for (auto& promoted_flags : *config.mutable_promoted_flags()) {
         if (promoted_flags.process_name() == process_name) {
           process_flags_pb = promoted_flags.mutable_flags();
           process_flag_info_pb = promoted_flags.mutable_flag_infos();
@@ -131,7 +117,7 @@ PromoteAutoFlagsOutcome InsertFlagsToConfig(
 
       if (!process_flags_pb) {
         // Process not found in the config. Add a new entry.
-        auto new_per_process_flags = config->add_promoted_flags();
+        auto new_per_process_flags = config.add_promoted_flags();
         new_per_process_flags->set_process_name(process_name);
         process_flags_pb = new_per_process_flags->mutable_flags();
         process_flag_info_pb = new_per_process_flags->mutable_flag_infos();
@@ -156,7 +142,7 @@ PromoteAutoFlagsOutcome InsertFlagsToConfig(
     return PromoteAutoFlagsOutcome::kNoFlagsPromoted;
   }
 
-  config->set_config_version(new_config_version);
+  config.set_config_version(new_config_version);
   return non_runtime_flags_added ? PromoteAutoFlagsOutcome::kNonRuntimeFlagsPromoted
                                  : PromoteAutoFlagsOutcome::kNewFlagsPromoted;
 }
@@ -164,11 +150,11 @@ PromoteAutoFlagsOutcome InsertFlagsToConfig(
 // Remove flags from the config if they were promoted on a version higher than rollback_version.
 // Bumps up the config version if any flags were removed. Returns the list of removed flags per
 // process.
-AutoFlagsNameMap RemoveFlagsFromConfig(uint32_t rollback_version, AutoFlagsConfigPB* config) {
+AutoFlagsNameMap RemoveFlagsFromConfig(uint32_t rollback_version, AutoFlagsConfigPB& config) {
   bool config_changed = false;
   AutoFlagsNameMap flags_removed;
 
-  for (auto& promoted_flags : *config->mutable_promoted_flags()) {
+  for (auto& promoted_flags : *config.mutable_promoted_flags()) {
     for (int i = 0; i < promoted_flags.flag_infos().size();) {
       if (promoted_flags.flag_infos(i).promoted_version() > rollback_version) {
         flags_removed[promoted_flags.process_name()].insert(promoted_flags.flags(i));
@@ -182,7 +168,7 @@ AutoFlagsNameMap RemoveFlagsFromConfig(uint32_t rollback_version, AutoFlagsConfi
   }
 
   if (config_changed) {
-    config->set_config_version(config->config_version() + 1);
+    config.set_config_version(config.config_version() + 1);
   }
 
   return flags_removed;
@@ -211,38 +197,6 @@ Result<bool> RemoveFlagFromConfig(
   return false;
 }
 
-Status StoreAutoFlagsConfig(
-    AutoFlagsManager& auto_flag_manager, AutoFlagsConfigPB& new_config,
-    CatalogManager* catalog_manager) {
-  auto persist_config_to_sys_catalog =
-      [catalog_manager](const AutoFlagsConfigPB& new_config) -> Status {
-    consensus::ChangeAutoFlagsConfigOpResponsePB operation_res;
-    // SubmitToSysCatalog will set the correct tablet
-    auto operation = std::make_unique<tablet::ChangeAutoFlagsConfigOperation>(nullptr /* tablet */);
-    *operation->AllocateRequest() = new_config;
-    CountDownLatch latch(1);
-    operation->set_completion_callback(
-        tablet::MakeLatchOperationCompletionCallback(&latch, &operation_res));
-
-    RETURN_NOT_OK_PREPEND(
-        catalog_manager->SubmitToSysCatalog(std::move(operation)),
-        "Failed to store AutoFlags config");
-
-    latch.Wait();
-
-    if (operation_res.has_error()) {
-      auto status = StatusFromPB(operation_res.error().status());
-      LOG(WARNING) << "Failed to apply new AutoFlags config: " << status.ToString();
-      return status;
-    }
-    catalog_manager->NotifyAutoFlagsConfigChanged();
-
-    return OK();
-  };
-
-  return auto_flag_manager.StoreUpdatedConfig(new_config, persist_config_to_sys_catalog);
-}
-
 AutoFlagsNameMap GetFlagsFromConfig(const AutoFlagsConfigPB& config) {
   AutoFlagsNameMap result;
   for (auto& per_process_flags : config.promoted_flags()) {
@@ -264,9 +218,72 @@ Result<AutoFlagInfo> GetFlagInfo(const ProcessName& process_name, const std::str
   return *flag_info;
 }
 
+// Wrapper over the AutoFlagsUtil::AreAutoFlagsCompatible.
+Result<bool> AreAutoFlagsCompatible(
+    const AutoFlagsConfigPB& base_config, const AutoFlagsConfigPB& config_to_check,
+    AutoFlagClass min_class) {
+  const auto base_flags = GetFlagsFromConfig(base_config);
+  const auto to_check_flags = GetFlagsFromConfig(config_to_check);
+  const auto auto_flag_infos = VERIFY_RESULT(AutoFlagsUtil::GetAvailableAutoFlags());
+
+  return AutoFlagsUtil::AreAutoFlagsCompatible(
+      base_flags, to_check_flags, auto_flag_infos, min_class);
+}
+
 }  // namespace
 
-Status CreateAutoFlagsConfigForNewCluster(AutoFlagsManager& auto_flag_manager) {
+constexpr auto kYbMasterProcessName = "yb-master";
+
+MasterAutoFlagsManager::MasterAutoFlagsManager(
+    const scoped_refptr<ClockBase>& clock, FsManager* fs_manager, CatalogManager* catalog_manager)
+    : AutoFlagsManagerBase(kYbMasterProcessName, clock, fs_manager),
+      catalog_manager_(catalog_manager),
+      update_lock_(mutex_, std::defer_lock) {}
+
+Status MasterAutoFlagsManager::Init(
+    const std::string& local_hosts, std::function<bool()> has_sys_catalog_func,
+    bool is_shell_mode) {
+  RETURN_NOT_OK(AutoFlagsManagerBase::Init(local_hosts));
+
+  if (VERIFY_RESULT(LoadFromFile())) {
+    return Status::OK();
+  }
+
+  if (has_sys_catalog_func()) {
+    // Pre-existing cluster that has just upgraded to a version with AutoFlags.
+    RETURN_NOT_OK(CreateEmptyConfig());
+    return Status::OK();
+  }
+
+  if (is_shell_mode) {
+    // New master in Shell mode.
+    LOG(INFO) << "AutoFlags initialization delayed as master is in Shell mode.";
+    return Status::OK();
+  }
+
+  // Newly created cluster.
+  return CreateConfigForNewCluster();
+}
+
+Status MasterAutoFlagsManager::LoadFromMasterLeader(
+    const std::string& local_hosts, const server::MasterAddresses& master_addresses) {
+  return AutoFlagsManagerBase::LoadFromMasterLeader(local_hosts, master_addresses);
+}
+
+Status MasterAutoFlagsManager::LoadNewConfig(const AutoFlagsConfigPB new_config) {
+  std::lock_guard l(mutex_);
+  return LoadFromConfigUnlocked(std::move(new_config), ApplyNonRuntimeAutoFlags::kTrue);
+}
+
+Status MasterAutoFlagsManager::CreateEmptyConfig() {
+  LOG(INFO) << "Creating empty AutoFlags configuration.";
+
+  AutoFlagsConfigPB new_config;
+  new_config.set_config_version(kInvalidAutoFlagsConfigVersion);
+  return LoadNewConfig(std::move(new_config));
+}
+
+Status MasterAutoFlagsManager::CreateConfigForNewCluster() {
   LOG(INFO) << "Creating AutoFlags configuration for new cluster.";
 
   if (FLAGS_limit_auto_flag_promote_for_new_universe != 0) {
@@ -276,7 +293,7 @@ Status CreateAutoFlagsConfigForNewCluster(AutoFlagsManager& auto_flag_manager) {
 
     if (FLAGS_disable_auto_flags_management) {
       LOG(WARNING) << "AutoFlags management is disabled.";
-      return OK();
+      return Status::OK();
     }
 
     LOG(INFO) << "Promoting AutoFlags. max_flag_class: " << ToString(max_flag_class)
@@ -285,29 +302,102 @@ Status CreateAutoFlagsConfigForNewCluster(AutoFlagsManager& auto_flag_manager) {
     const auto eligible_flags = VERIFY_RESULT(
         AutoFlagsUtil::GetFlagsEligibleForPromotion(max_flag_class, promote_non_runtime));
 
-    auto new_config = auto_flag_manager.GetConfig();
-    InsertFlagsToConfig(eligible_flags, &new_config, true /* force */);
+    auto new_config = GetConfig();
+    InsertFlagsToConfig(eligible_flags, new_config, true /* force */);
     DCHECK_GE(new_config.config_version(), kMinAutoFlagsConfigVersion);
 
-    RETURN_NOT_OK(auto_flag_manager.LoadNewConfig(std::move(new_config)));
+    RETURN_NOT_OK(LoadNewConfig(std::move(new_config)));
   }
 
-  return OK();
+  return Status::OK();
 }
 
-Status CreateEmptyAutoFlagsConfig(AutoFlagsManager& auto_flag_manager) {
-  LOG(INFO) << "Creating empty AutoFlags configuration.";
+Status MasterAutoFlagsManager::PersistConfigInSysCatalog(AutoFlagsConfigPB& new_config) {
+  consensus::ChangeAutoFlagsConfigOpResponsePB operation_res;
+  // SubmitToSysCatalog will set the correct tablet
+  auto operation = std::make_unique<tablet::ChangeAutoFlagsConfigOperation>(nullptr /* tablet */);
+  *operation->AllocateRequest() = new_config;
+  CountDownLatch latch(1);
+  operation->set_completion_callback(
+      tablet::MakeLatchOperationCompletionCallback(&latch, &operation_res));
+
+  RETURN_NOT_OK_PREPEND(
+      catalog_manager_->SubmitToSysCatalog(std::move(operation)),
+      "Failed to store AutoFlags config");
+
+  latch.Wait();
+
+  if (operation_res.has_error()) {
+    auto status = StatusFromPB(operation_res.error().status());
+    LOG(WARNING) << "Failed to apply new AutoFlags config: " << status.ToString();
+    return status;
+  }
+  catalog_manager_->NotifyAutoFlagsConfigChanged();
 
-  AutoFlagsConfigPB new_config;
-  new_config.set_config_version(kInvalidAutoFlagsConfigVersion);
-  RETURN_NOT_OK(auto_flag_manager.LoadNewConfig(std::move(new_config)));
-  return OK();
+  return Status::OK();
+}
+
+// No thread safety analysis, as it cannot detect that the mutex is locked by UniqueLock.
+Status MasterAutoFlagsManager::StoreConfig(AutoFlagsConfigPB& new_config)
+    NO_THREAD_SAFETY_ANALYSIS {
+  // The config has to get quorum committed in the sys_catalog before it can be stored in
+  // current_config_ even on the master leader. So, there will be delay between when the
+  // config_apply_time is computed and it being stored.
+  // During this window we should not respond to heartbeats since it will renew the leases in the
+  // tserver for auto_flags_apply_delay_ms, which can cause it to be higher than the
+  // config_apply_time we picked. We hold onto the mutex_ so that we do not respond to heartbeats.
+  //
+  // Raft and master leader election will guarantee that this is safe from crashes:
+  // If we crash between writing the WAL op and the it getting applied, then the new leader will
+  // apply it before responding to heartbeats. This is because new leader will have to commit the
+  // NO_OP record and apply all pending operations before it is marked ready. If the op was never
+  // replicated to the new leader then the operation will be lost, and the user will have to try
+  // again.
+  RSTATUS_DCHECK(
+      !update_lock_.owns_lock(), IllegalState, "AutoFlags config update already in progress");
+  update_lock_.lock();
+  auto se = ScopeExit([this]() NO_THREAD_SAFETY_ANALYSIS { update_lock_.unlock(); });
+
+  // This is an update of an existing config. The initial config must be applied immediately.
+  DCHECK_GE(new_config.config_version(), kMinAutoFlagsConfigVersion);
+  // Every config change must update the version by 1.
+  RSTATUS_DCHECK_EQ(
+      new_config.config_version(), current_config_.config_version() + 1, IllegalState,
+      "Attempting to store a stale config");
+
+  const auto now = clock_->Now();
+  const auto config_apply_ht = now.AddDelta(GetApplyDelay());
+  new_config.set_config_apply_time(config_apply_ht.ToUint64());
+
+  return PersistConfigInSysCatalog(new_config);
 }
 
-Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteAutoFlags(
+// No thread safety analysis, as it cannot detect that the mutex is locked by UniqueLock.
+Status MasterAutoFlagsManager::ProcessAutoFlagsConfigOperation(const AutoFlagsConfigPB new_config)
+    NO_THREAD_SAFETY_ANALYSIS {
+  bool unlock_needed = false;
+  auto se = ScopeExit([&update_lock = update_lock_, &unlock_needed]() NO_THREAD_SAFETY_ANALYSIS {
+    if (unlock_needed) {
+      update_lock.unlock();
+    }
+  });
+
+  // This function will be invoked when the ChangeAutoFlagsConfigOperation is applied. The
+  // StoreUpdatedConfig may be holding the lock already and waiting for us to complete in which case
+  // we do not have to reacquire the lock. If we crashed during StoreUpdatedConfig, then the
+  // operation can get applied at tablet bootstrap or a later time, and in both cases we need to get
+  // the lock.
+  if (!update_lock_.owns_lock()) {
+    update_lock_.lock();
+    unlock_needed = true;
+  }
+
+  return LoadFromConfigUnlocked(std::move(new_config), ApplyNonRuntimeAutoFlags::kFalse);
+}
+
+Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> MasterAutoFlagsManager::PromoteAutoFlags(
     const AutoFlagClass max_flag_class, const PromoteNonRuntimeAutoFlags promote_non_runtime_flags,
-    const bool force_version_change, AutoFlagsManager& auto_flag_manager,
-    CatalogManager* catalog_manager) {
+    const bool force_version_change) {
   SCHECK(!FLAGS_disable_auto_flags_management, NotSupported, "AutoFlags management is disabled.");
 
   LOG(INFO) << "Promoting AutoFlags. max_flag_class: " << ToString(max_flag_class)
@@ -317,26 +407,25 @@ Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteAutoFlags(
   const auto eligible_flags = VERIFY_RESULT(
       AutoFlagsUtil::GetFlagsEligibleForPromotion(max_flag_class, promote_non_runtime_flags));
 
-  auto new_config = auto_flag_manager.GetConfig();
-  auto outcome = InsertFlagsToConfig(eligible_flags, &new_config, force_version_change);
+  auto new_config = GetConfig();
+  auto outcome = InsertFlagsToConfig(eligible_flags, new_config, force_version_change);
 
   if (outcome != PromoteAutoFlagsOutcome::kNoFlagsPromoted) {
-    RETURN_NOT_OK(StoreAutoFlagsConfig(auto_flag_manager, new_config, catalog_manager));
+    RETURN_NOT_OK(StoreConfig(new_config));
   }
 
   return std::make_pair(new_config.config_version(), outcome);
 }
 
-Result<std::pair<uint32_t, bool>> RollbackAutoFlags(
-    uint32_t rollback_version, AutoFlagsManager& auto_flag_manager,
-    CatalogManager* catalog_manager) {
+Result<std::pair<uint32_t, bool>> MasterAutoFlagsManager::RollbackAutoFlags(
+    uint32_t rollback_version) {
   SCHECK(!FLAGS_disable_auto_flags_management, NotSupported, "AutoFlags management is disabled.");
 
-  auto new_config = auto_flag_manager.GetConfig();
-  const auto removed_flags = RemoveFlagsFromConfig(rollback_version, &new_config);
+  auto new_config = GetConfig();
+  const auto removed_flags = RemoveFlagsFromConfig(rollback_version, new_config);
   if (removed_flags.empty()) {
     // Nothing to rollback.
-    return std::make_pair(auto_flag_manager.GetConfig().config_version(), false);
+    return std::make_pair(GetConfigVersion(), false);
   }
 
   // Make sure only Volatile flags are being rolled back.
@@ -360,24 +449,23 @@ Result<std::pair<uint32_t, bool>> RollbackAutoFlags(
             << ", flags_removed: " << yb::ToString(removed_flags)
             << ", new_config_version: " << new_config.config_version();
 
-  RETURN_NOT_OK(StoreAutoFlagsConfig(auto_flag_manager, new_config, catalog_manager));
+  RETURN_NOT_OK(StoreConfig(new_config));
 
   return std::make_pair(new_config.config_version(), true);
 }
 
-Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteSingleAutoFlag(
-    const ProcessName& process_name, const std::string& flag_name,
-    AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager) {
+Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> MasterAutoFlagsManager::PromoteSingleAutoFlag(
+    const ProcessName& process_name, const std::string& flag_name) {
   SCHECK(!FLAGS_disable_auto_flags_management, NotSupported, "AutoFlags management is disabled.");
 
   AutoFlagsInfoMap flag_to_insert;
   flag_to_insert[process_name].emplace_back(VERIFY_RESULT(GetFlagInfo(process_name, flag_name)));
 
-  auto new_config = auto_flag_manager.GetConfig();
-  auto outcome = InsertFlagsToConfig(flag_to_insert, &new_config, /* force_version_change */ false);
+  auto new_config = GetConfig();
+  auto outcome = InsertFlagsToConfig(flag_to_insert, new_config, /* force_version_change */ false);
 
   if (outcome != PromoteAutoFlagsOutcome::kNoFlagsPromoted) {
-    RETURN_NOT_OK(StoreAutoFlagsConfig(auto_flag_manager, new_config, catalog_manager));
+    RETURN_NOT_OK(StoreConfig(new_config));
   }
 
   LOG(INFO) << "Promote AutoFlag. process_name: " << process_name << ", flag_name: " << flag_name
@@ -386,37 +474,106 @@ Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteSingleAutoFlag(
   return std::make_pair(new_config.config_version(), outcome);
 }
 
-Result<std::pair<uint32_t, bool>> DemoteSingleAutoFlag(
-    const ProcessName& process_name, const std::string& flag_name,
-    AutoFlagsManager& auto_flag_manager, CatalogManager* catalog_manager) {
+Result<std::pair<uint32_t, bool>> MasterAutoFlagsManager::DemoteSingleAutoFlag(
+    const ProcessName& process_name, const std::string& flag_name) {
   SCHECK(!FLAGS_disable_auto_flags_management, NotSupported, "AutoFlags management is disabled.");
 
   // Make sure process and AutoFlag exists.
   RETURN_NOT_OK(GetFlagInfo(process_name, flag_name));
 
-  auto new_config = auto_flag_manager.GetConfig();
+  auto new_config = GetConfig();
   if (!VERIFY_RESULT(RemoveFlagFromConfig(process_name, flag_name, &new_config))) {
     // Nothing to rollback.
-    return std::make_pair(auto_flag_manager.GetConfig().config_version(), false);
+    return std::make_pair(GetConfigVersion(), false);
   }
 
   LOG(INFO) << "Demote AutoFlag. process_name: " << process_name << ", flag_name: " << flag_name
             << ", new_config_version: " << new_config.config_version();
 
-  RETURN_NOT_OK(StoreAutoFlagsConfig(auto_flag_manager, new_config, catalog_manager));
+  RETURN_NOT_OK(StoreConfig(new_config));
 
   return std::make_pair(new_config.config_version(), true);
 }
 
-Result<bool> AreAutoFlagsCompatible(
-    const AutoFlagsConfigPB& base_config, const AutoFlagsConfigPB& config_to_check,
-    AutoFlagClass min_class) {
-  const auto base_flags = GetFlagsFromConfig(base_config);
-  const auto to_check_flags = GetFlagsFromConfig(config_to_check);
-  const auto auto_flag_infos = VERIFY_RESULT(AutoFlagsUtil::GetAvailableAutoFlags());
+Status MasterAutoFlagsManager::GetAutoFlagsConfig(
+    const GetAutoFlagsConfigRequestPB* req, GetAutoFlagsConfigResponsePB* resp) {
+  *resp->mutable_config() = GetConfig();
 
-  return AutoFlagsUtil::AreAutoFlagsCompatible(
-      base_flags, to_check_flags, auto_flag_infos, min_class);
+  return Status::OK();
+}
+
+Status MasterAutoFlagsManager::PromoteAutoFlags(
+    const PromoteAutoFlagsRequestPB* req, PromoteAutoFlagsResponsePB* resp) {
+  const auto max_class = VERIFY_RESULT_PREPEND(
+      ParseEnumInsensitive<AutoFlagClass>(req->max_flag_class()),
+      "Invalid value provided for flag class");
+
+  // It is expected PromoteAutoFlags RPC is triggered only for upgrades, hence it is required
+  // to avoid promotion of flags with AutoFlagClass::kNewInstallsOnly class.
+  SCHECK_LT(
+      max_class, AutoFlagClass::kNewInstallsOnly, InvalidArgument,
+      Format("max_class cannot be set to $0.", ToString(AutoFlagClass::kNewInstallsOnly)));
+
+  auto [new_config_version, outcome] = VERIFY_RESULT(PromoteAutoFlags(
+      max_class, PromoteNonRuntimeAutoFlags(req->promote_non_runtime_flags()), req->force()));
+
+  resp->set_new_config_version(new_config_version);
+  resp->set_flags_promoted(outcome != PromoteAutoFlagsOutcome::kNoFlagsPromoted);
+  resp->set_non_runtime_flags_promoted(
+      outcome == PromoteAutoFlagsOutcome::kNonRuntimeFlagsPromoted);
+  return Status::OK();
+}
+
+Status MasterAutoFlagsManager::RollbackAutoFlags(
+    const RollbackAutoFlagsRequestPB* req, RollbackAutoFlagsResponsePB* resp) {
+  auto [new_config_version, outcome] = VERIFY_RESULT(RollbackAutoFlags(req->rollback_version()));
+
+  resp->set_new_config_version(new_config_version);
+  resp->set_flags_rolledback(outcome);
+  return Status::OK();
+}
+
+Status MasterAutoFlagsManager::PromoteSingleAutoFlag(
+    const PromoteSingleAutoFlagRequestPB* req, PromoteSingleAutoFlagResponsePB* resp) {
+  auto [new_config_version, outcome] =
+      VERIFY_RESULT(PromoteSingleAutoFlag(req->process_name(), req->auto_flag_name()));
+
+  resp->set_new_config_version(new_config_version);
+  resp->set_flag_promoted(outcome != PromoteAutoFlagsOutcome::kNoFlagsPromoted);
+  resp->set_non_runtime_flag_promoted(outcome == PromoteAutoFlagsOutcome::kNonRuntimeFlagsPromoted);
+  return Status::OK();
+}
+
+Status MasterAutoFlagsManager::DemoteSingleAutoFlag(
+    const DemoteSingleAutoFlagRequestPB* req, DemoteSingleAutoFlagResponsePB* resp) {
+  auto [new_config_version, outcome] =
+      VERIFY_RESULT(DemoteSingleAutoFlag(req->process_name(), req->auto_flag_name()));
+
+  resp->set_new_config_version(new_config_version);
+  resp->set_flag_demoted(outcome);
+  return Status::OK();
+}
+
+Status MasterAutoFlagsManager::ValidateAutoFlagsConfig(
+    const ValidateAutoFlagsConfigRequestPB* req, ValidateAutoFlagsConfigResponsePB* resp) {
+  VLOG_WITH_FUNC(1) << req->ShortDebugString();
+
+  auto min_class = AutoFlagClass::kLocalVolatile;
+  if (req->has_min_flag_class()) {
+    min_class = VERIFY_RESULT_PREPEND(
+        yb::UnderlyingToEnumSlow<yb::AutoFlagClass>(req->min_flag_class()),
+        "Invalid value provided for flag class");
+  }
+
+  auto local_auto_flag_config = GetConfig();
+  auto valid =
+      VERIFY_RESULT(AreAutoFlagsCompatible(local_auto_flag_config, req->config(), min_class));
+  VLOG_WITH_FUNC(1) << valid;
+
+  resp->set_valid(valid);
+  resp->set_config_version(local_auto_flag_config.config_version());
+
+  return Status::OK();
 }
 
 }  // namespace yb::master
diff --git a/src/yb/master/master_auto_flags_manager.h b/src/yb/master/master_auto_flags_manager.h
new file mode 100644
index 0000000000..c1bee966be
--- /dev/null
+++ b/src/yb/master/master_auto_flags_manager.h
@@ -0,0 +1,119 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include "yb/server/auto_flags_manager_base.h"
+#include "yb/master/master_cluster.pb.h"
+
+namespace yb {
+namespace master {
+
+class CatalogManager;
+
+YB_DEFINE_ENUM(
+    PromoteAutoFlagsOutcome, (kNoFlagsPromoted)(kNewFlagsPromoted)(kNonRuntimeFlagsPromoted));
+
+// There are four ways in which a new config is loaded on the yb-masters.
+//
+// LoadFromFile and LoadFromMasterLeader as described in AutoFlagsManagerBase.
+//
+// LoadNewConfig - Stores a new config on cluster create or on the first upgrade from a version
+// without AutoFlags to a version with AutoFlags.
+//
+// ProcessAutoFlagsConfigOperation -Processes the ChangeAutoFlagsConfigOperation WAL operation on
+// masters. Stores the new config to local disk immediately, and asynchronously applies the config
+// at the provided config_apply_time.
+//
+// All config changes happen via StoreConfig on the master leader.
+// The master leader picks the config_apply_time and commits the config via a
+// ChangeAutoFlagsConfigOperation. Heartbeat responses are blocked for the duration of this
+// function to guarantee correctness. The apply of the WAL operation will trigger
+// ProcessAutoFlagsConfigOperation on all master (including leader).
+class MasterAutoFlagsManager : public AutoFlagsManagerBase {
+ public:
+  explicit MasterAutoFlagsManager(
+      const scoped_refptr<ClockBase>& clock, FsManager* fs_manager,
+      CatalogManager* catalog_manager);
+
+  virtual ~MasterAutoFlagsManager() {}
+
+  Status Init(
+      const std::string& local_hosts, std::function<bool()> has_sys_catalog_func,
+      bool is_shell_mode);
+
+  Status LoadFromMasterLeader(
+      const std::string& local_hosts, const server::MasterAddresses& master_addresses);
+
+  Status ProcessAutoFlagsConfigOperation(const AutoFlagsConfigPB new_config) override;
+
+  // RPC handlers.
+  Status GetAutoFlagsConfig(
+      const GetAutoFlagsConfigRequestPB* req, GetAutoFlagsConfigResponsePB* resp);
+  Status PromoteAutoFlags(const PromoteAutoFlagsRequestPB* req, PromoteAutoFlagsResponsePB* resp);
+  Status RollbackAutoFlags(
+      const RollbackAutoFlagsRequestPB* req, RollbackAutoFlagsResponsePB* resp);
+  Status PromoteSingleAutoFlag(
+      const PromoteSingleAutoFlagRequestPB* req, PromoteSingleAutoFlagResponsePB* resp);
+  Status DemoteSingleAutoFlag(
+      const DemoteSingleAutoFlagRequestPB* req, DemoteSingleAutoFlagResponsePB* resp);
+  Status ValidateAutoFlagsConfig(
+      const ValidateAutoFlagsConfigRequestPB* req, ValidateAutoFlagsConfigResponsePB* resp);
+
+ private:
+  FRIEND_TEST(AutoFlagsMiniClusterTest, CheckMissingFlag);
+
+  Status LoadNewConfig(const AutoFlagsConfigPB new_config) EXCLUDES(mutex_);
+
+  // Create and persist a empty AutoFlags config with version set to 1.
+  // Intended to be used during the first process startup after the upgrade of clusters created on
+  // versions without AutoFlags.
+  Status CreateEmptyConfig();
+
+  // Create and persist a new AutoFlags config where all AutoFlags of class within
+  // FLAGS_limit_auto_flag_promote_for_new_universe are promoted and Apply it.
+  // Intended to be used in new cluster created with AutoFlags.
+  Status CreateConfigForNewCluster();
+
+  // Set the config apply time and persist it in the sys_catalog.
+  Status StoreConfig(AutoFlagsConfigPB& new_config);
+
+  Status PersistConfigInSysCatalog(AutoFlagsConfigPB& new_config);
+
+  // Promote eligible AutoFlags up to max_flag_class. If no new flags were eligible, Status
+  // AlreadyPresent is returned. When force is set, the config version is bumped up even if no new
+  // flags are eligible. Returns the new config version and whether any non-runtime flags were
+  // promoted.
+  Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteAutoFlags(
+      const AutoFlagClass max_flag_class,
+      const PromoteNonRuntimeAutoFlags promote_non_runtime_flags, const bool force_version_change);
+
+  Result<std::pair<uint32_t, PromoteAutoFlagsOutcome>> PromoteSingleAutoFlag(
+      const ProcessName& process_name, const std::string& flag_name);
+
+  // Rollback AutoFlags to the specified version. Only Volatile AutoFlags are eligible for rollback.
+  // Returns weather any flags were rolled back and the new config version.
+  Result<std::pair<uint32_t, bool>> RollbackAutoFlags(uint32_t rollback_version);
+
+  // Demote a single AutoFlag. Returns weather the flag was demoted and the new config version.
+  // Note: This is extremely dangerous and should only be used under the guidance of YugabyteDB
+  // engineering team.
+  Result<std::pair<uint32_t, bool>> DemoteSingleAutoFlag(
+      const ProcessName& process_name, const std::string& flag_name);
+
+  CatalogManager* catalog_manager_;
+  UniqueLock<std::shared_mutex> update_lock_;
+};
+
+}  // namespace master
+}  // namespace yb
diff --git a/src/yb/master/master_cluster_service.cc b/src/yb/master/master_cluster_service.cc
index 3c56add622..27a26bc280 100644
--- a/src/yb/master/master_cluster_service.cc
+++ b/src/yb/master/master_cluster_service.cc
@@ -15,6 +15,7 @@
 
 #include "yb/master/catalog_manager.h"
 #include "yb/master/catalog_manager_util.h"
+#include "yb/master/master_auto_flags_manager.h"
 #include "yb/master/tablet_health_manager.h"
 #include "yb/master/master_cluster.service.h"
 #include "yb/master/master_heartbeat.pb.h"
@@ -358,19 +359,6 @@ class MasterClusterServiceImpl : public MasterServiceBase, public MasterClusterI
     HANDLE_ON_LEADER_WITH_LOCK(CatalogManager, GetLoadMoveCompletionPercent);
   }
 
-  void GetAutoFlagsConfig(
-      const GetAutoFlagsConfigRequestPB* req, GetAutoFlagsConfigResponsePB* resp,
-      rpc::RpcContext rpc) override {
-    SCOPED_LEADER_SHARED_LOCK(l, server_->catalog_manager_impl());
-    if (!l.CheckIsInitializedAndIsLeaderOrRespond(resp, &rpc)) {
-      return;
-    }
-
-    *resp->mutable_config() = server_->GetAutoFlagsConfig();
-
-    rpc.RespondSuccess();
-  }
-
   MASTER_SERVICE_IMPL_ON_ALL_MASTERS(
     TabletHealthManager,
     (CheckMasterTabletHealth)
@@ -382,6 +370,11 @@ class MasterClusterServiceImpl : public MasterServiceBase, public MasterClusterI
     (IsLoadBalanced)
     (IsLoadBalancerIdle)
     (SetPreferredZones)
+  )
+
+  MASTER_SERVICE_IMPL_ON_LEADER_WITH_LOCK(
+    MasterAutoFlagsManager,
+    (GetAutoFlagsConfig)
     (PromoteAutoFlags)
     (RollbackAutoFlags)
     (PromoteSingleAutoFlag)
diff --git a/src/yb/master/master_service_base.cc b/src/yb/master/master_service_base.cc
index 59d29a8e82..ecaf31c0e4 100644
--- a/src/yb/master/master_service_base.cc
+++ b/src/yb/master/master_service_base.cc
@@ -53,6 +53,10 @@ TabletHealthManager* MasterServiceBase::handler(TabletHealthManager*) {
   return server_->tablet_health_manager();
 }
 
+MasterAutoFlagsManager* MasterServiceBase::handler(MasterAutoFlagsManager*) {
+  return server_->GetAutoFlagsManagerImpl();
+}
+
 Status HandleLockAndCallFunction(
     const std::function<Status()>& f,
     HoldCatalogLock hold_catalog_lock,
diff --git a/src/yb/master/master_service_base.h b/src/yb/master/master_service_base.h
index 590a4fb700..c4561543d8 100644
--- a/src/yb/master/master_service_base.h
+++ b/src/yb/master/master_service_base.h
@@ -37,6 +37,7 @@ class EncryptionManager;
 class TabletHealthManager;
 struct LeaderEpoch;
 class XClusterManager;
+class MasterAutoFlagsManager;
 
 // Tells HandleIn/HandleOnLeader to either acquire the lock briefly to check leadership (kFalse)
 // or to hold it throughout the handler invocation (kTrue).
@@ -121,6 +122,7 @@ class MasterServiceBase {
   EncryptionManager* handler(EncryptionManager*);
   XClusterManager* handler(XClusterManager*);
   TestAsyncRpcManager* handler(TestAsyncRpcManager*);
+  MasterAutoFlagsManager* handler(MasterAutoFlagsManager*);
 
   Master* server_;
 
diff --git a/src/yb/master/sys_catalog.cc b/src/yb/master/sys_catalog.cc
index e30f73436e..0970d31b4d 100644
--- a/src/yb/master/sys_catalog.cc
+++ b/src/yb/master/sys_catalog.cc
@@ -73,6 +73,7 @@
 #include "yb/gutil/strings/escaping.h"
 #include "yb/gutil/strings/split.h"
 
+#include "yb/master/master_auto_flags_manager.h"
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/catalog_manager_if.h"
 #include "yb/master/catalog_manager.h"
@@ -614,10 +615,10 @@ Status SysCatalogTable::OpenTablet(const scoped_refptr<tablet::RaftGroupMetadata
       .snapshot_coordinator = &master_->catalog_manager()->snapshot_coordinator(),
       .tablet_splitter = nullptr,
       .allowed_history_cutoff_provider = std::bind(
-          &CatalogManager::AllowedHistoryCutoffProvider,
-          master_->catalog_manager_impl(), std::placeholders::_1),
+          &CatalogManager::AllowedHistoryCutoffProvider, master_->catalog_manager_impl(),
+          std::placeholders::_1),
       .transaction_manager_provider = nullptr,
-      .auto_flags_manager = master_->auto_flags_manager(),
+      .auto_flags_manager = master_->GetAutoFlagsManagerImpl(),
       // We won't be doing full compactions on the catalog tablet.
       .full_compaction_pool = nullptr,
       .admin_triggered_compaction_pool = nullptr,
diff --git a/src/yb/server/CMakeLists.txt b/src/yb/server/CMakeLists.txt
index e426282250..3a198762ae 100644
--- a/src/yb/server/CMakeLists.txt
+++ b/src/yb/server/CMakeLists.txt
@@ -130,3 +130,21 @@ endif()
 set(YB_TEST_LINK_LIBS server_process ${YB_MIN_TEST_LIBS})
 ADD_YB_TEST(webserver-test)
 ADD_YB_TEST(pprof-path-handler_util-test)
+
+#########################################
+# auto_flags_manager_common
+#########################################
+
+set(AUTO_FLAGS_MANAGER_COMMON_SRCS
+  auto_flags_manager_base.cc
+)
+
+add_library(auto_flags_manager_common ${AUTO_FLAGS_MANAGER_COMMON_SRCS})
+target_link_libraries(auto_flags_manager_common
+  server_process
+  yb_common
+  yb_fs
+  gutil
+  yrpc
+  yb_util
+  yb_client)
diff --git a/src/yb/client/auto_flags_manager.cc b/src/yb/server/auto_flags_manager_base.cc
similarity index 70%
rename from src/yb/client/auto_flags_manager.cc
rename to src/yb/server/auto_flags_manager_base.cc
index 1bfb9a86d2..caab68fd0f 100644
--- a/src/yb/client/auto_flags_manager.cc
+++ b/src/yb/server/auto_flags_manager_base.cc
@@ -11,7 +11,7 @@
 // under the License.
 //
 
-#include "yb/client/auto_flags_manager.h"
+#include "yb/server/auto_flags_manager_base.h"
 #include "yb/client/client.h"
 
 #include "yb/fs/fs_manager.h"
@@ -29,7 +29,6 @@
 #include "yb/util/net/net_util.h"
 #include "yb/util/flags.h"
 #include "yb/util/logging.h"
-#include "yb/util/scope_exit.h"
 #include "yb/util/source_location.h"
 #include "yb/util/thread_restrictions.h"
 #include "yb/util/version_info.h"
@@ -71,7 +70,6 @@ TAG_FLAG(auto_flags_apply_delay_ms, advanced);
 
 DECLARE_bool(TEST_running_test);
 DECLARE_int32(yb_client_admin_operation_timeout_sec);
-DECLARE_uint64(max_clock_skew_usec);
 
 namespace yb {
 
@@ -94,24 +92,21 @@ std::unordered_set<std::string> GetPerProcessFlags(
 
 }  // namespace
 
-AutoFlagsManager::AutoFlagsManager(
+AutoFlagsManagerBase::AutoFlagsManagerBase(
     const std::string& process_name, const scoped_refptr<ClockBase>& clock, FsManager* fs_manager)
-    : process_name_(process_name),
-      clock_(clock),
-      fs_manager_(fs_manager),
-      update_lock_(mutex_, std::defer_lock) {
+    : fs_manager_(fs_manager), clock_(clock), process_name_(process_name) {
   // google::ProgramInvocationShortName() cannot be used for process_name as it will return the test
   // name in MiniCluster tests.
   current_config_.set_config_version(kInvalidAutoFlagsConfigVersion);
 }
 
-AutoFlagsManager::~AutoFlagsManager() {
+AutoFlagsManagerBase::~AutoFlagsManagerBase() {
   if (messenger_) {
     messenger_->Shutdown();
   }
 }
 
-Status AutoFlagsManager::Init(const std::string& local_hosts) {
+Status AutoFlagsManagerBase::Init(const std::string& local_hosts) {
   rpc::MessengerBuilder messenger_builder("auto_flags_client");
   secure_context_ = VERIFY_RESULT(
       server::SetupInternalSecureContext(local_hosts, *fs_manager_, &messenger_builder));
@@ -127,7 +122,7 @@ Status AutoFlagsManager::Init(const std::string& local_hosts) {
   return Status::OK();
 }
 
-Result<bool> AutoFlagsManager::LoadFromFile() {
+Result<bool> AutoFlagsManagerBase::LoadFromFile() {
   if (FLAGS_disable_auto_flags_management) {
     LOG(WARNING) << "AutoFlags management is disabled.";
     return true;
@@ -153,7 +148,7 @@ Result<bool> AutoFlagsManager::LoadFromFile() {
   return true;
 }
 
-Result<std::optional<AutoFlagsConfigPB>> AutoFlagsManager::GetAutoFlagConfigFromMaster(
+Result<std::optional<AutoFlagsConfigPB>> AutoFlagsManagerBase::GetAutoFlagConfigFromMasterLeader(
     const std::string& master_addresses) {
   auto client = VERIFY_RESULT(yb::client::YBClientBuilder()
                                   .add_master_server_addr(master_addresses)
@@ -164,7 +159,7 @@ Result<std::optional<AutoFlagsConfigPB>> AutoFlagsManager::GetAutoFlagConfigFrom
   return client->GetAutoFlagConfig();
 }
 
-Status AutoFlagsManager::LoadFromMaster(
+Status AutoFlagsManagerBase::LoadFromMasterLeader(
     const std::string& local_hosts, const server::MasterAddresses& master_addresses) {
   if (FLAGS_disable_auto_flags_management) {
     LOG(WARNING) << "AutoFlags management is disabled.";
@@ -200,7 +195,7 @@ Status AutoFlagsManager::LoadFromMaster(
   uint32_t attempts = 1;
   auto start_time = clock_->Now();
   while (true) {
-    auto res = GetAutoFlagConfigFromMaster(master_addresses_str);
+    auto res = GetAutoFlagConfigFromMasterLeader(master_addresses_str);
     if (res.ok()) {
       if (res->has_value()) {
         new_config = std::move(res->value());
@@ -232,12 +227,7 @@ Status AutoFlagsManager::LoadFromMaster(
       std::move(new_config), ApplyNonRuntimeAutoFlags::kTrue, /* apply_sync */ true);
 }
 
-Status AutoFlagsManager::LoadNewConfig(const AutoFlagsConfigPB new_config) {
-  std::lock_guard l(mutex_);
-  return LoadFromConfigUnlocked(new_config, ApplyNonRuntimeAutoFlags::kTrue);
-}
-
-Result<MonoDelta> AutoFlagsManager::GetTimeLeftToApplyConfig() const {
+Result<MonoDelta> AutoFlagsManagerBase::GetTimeLeftToApplyConfig() const {
   static const MonoDelta uninitialized_delta;
 
   if (!current_config_.has_config_apply_time()) {
@@ -254,7 +244,7 @@ Result<MonoDelta> AutoFlagsManager::GetTimeLeftToApplyConfig() const {
   return uninitialized_delta;
 }
 
-Status AutoFlagsManager::LoadFromConfigUnlocked(
+Status AutoFlagsManagerBase::LoadFromConfigUnlocked(
     const AutoFlagsConfigPB new_config, ApplyNonRuntimeAutoFlags apply_non_runtime,
     bool apply_sync) {
   if (!VERIFY_RESULT(ValidateAndSetConfig(std::move(new_config)))) {
@@ -270,7 +260,7 @@ Status AutoFlagsManager::LoadFromConfigUnlocked(
       LOG(INFO) << "New AutoFlags config will be applied in " << delay;
       RETURN_NOT_OK(messenger_->ScheduleOnReactor(
           std::bind(
-              &AutoFlagsManager::AsyncApplyConfig, this, current_config_.config_version(),
+              &AutoFlagsManagerBase::AsyncApplyConfig, this, current_config_.config_version(),
               apply_non_runtime),
           delay, SOURCE_LOCATION()));
       return Status::OK();
@@ -280,39 +270,21 @@ Status AutoFlagsManager::LoadFromConfigUnlocked(
   return ApplyConfig(apply_non_runtime);
 }
 
-uint32_t AutoFlagsManager::GetConfigVersion() const {
+uint32_t AutoFlagsManagerBase::GetConfigVersion() const {
   SharedLock lock(mutex_);
   return current_config_.config_version();
 }
 
-Result<uint32_t> AutoFlagsManager::ValidateAndGetConfigVersion() const {
-  const auto last_config_sync_time = last_config_sync_time_.load(std::memory_order_acquire);
-  SCHECK(last_config_sync_time, IllegalState, "AutoFlags config is stale. No config sync time set");
-  const auto apply_delay = GetApplyDelay();
-  const auto max_allowed_time =
-      last_config_sync_time.AddDelta(apply_delay)
-          .AddDelta(MonoDelta::FromMicroseconds(-1 * FLAGS_max_clock_skew_usec));
-
-  const auto now = clock_->Now();
-  SCHECK_LT(
-      now, max_allowed_time, IllegalState,
-      Format(
-          "AutoFlags config is stale. Last sync time: $0, Max allowed staleness: $1",
-          last_config_sync_time, apply_delay));
-
-  return GetConfigVersion();
-}
-
-AutoFlagsConfigPB AutoFlagsManager::GetConfig() const {
+AutoFlagsConfigPB AutoFlagsManagerBase::GetConfig() const {
   SharedLock lock(mutex_);
   return current_config_;
 }
 
-MonoDelta AutoFlagsManager::GetApplyDelay() const {
+MonoDelta AutoFlagsManagerBase::GetApplyDelay() const {
   return MonoDelta::FromMilliseconds(FLAGS_auto_flags_apply_delay_ms);
 }
 
-Result<bool> AutoFlagsManager::ValidateAndSetConfig(const AutoFlagsConfigPB&& new_config) {
+Result<bool> AutoFlagsManagerBase::ValidateAndSetConfig(const AutoFlagsConfigPB&& new_config) {
   // First new config can be empty, and should still be written to disk.
   // Else no-op if it is the same or lower version.
   const auto& current_version = current_config_.config_version();
@@ -341,7 +313,7 @@ Result<bool> AutoFlagsManager::ValidateAndSetConfig(const AutoFlagsConfigPB&& ne
   return true;
 }
 
-Status AutoFlagsManager::WriteConfigToDisk() {
+Status AutoFlagsManagerBase::WriteConfigToDisk() {
   LOG(INFO) << "Storing new AutoFlags config: " << current_config_.ShortDebugString();
   RETURN_NOT_OK_PREPEND(
       fs_manager_->WriteAutoFlagsConfig(&current_config_), "Failed to store AutoFlag config");
@@ -349,7 +321,7 @@ Status AutoFlagsManager::WriteConfigToDisk() {
   return Status::OK();
 }
 
-void AutoFlagsManager::AsyncApplyConfig(
+void AutoFlagsManagerBase::AsyncApplyConfig(
     uint32 apply_version, ApplyNonRuntimeAutoFlags apply_non_runtime) {
   SharedLock lock(mutex_);
   if (current_config_.config_version() != apply_version) {
@@ -363,7 +335,7 @@ void AutoFlagsManager::AsyncApplyConfig(
 
 // This is a blocking function that can block process startup. We relax ThreadRestrictions since it
 // gets invoked from a reactor thread.
-Status AutoFlagsManager::ApplyConfig(ApplyNonRuntimeAutoFlags apply_non_runtime) const {
+Status AutoFlagsManagerBase::ApplyConfig(ApplyNonRuntimeAutoFlags apply_non_runtime) const {
   const auto delay = VERIFY_RESULT(GetTimeLeftToApplyConfig());
   if (delay) {
     LOG(INFO) << "Sleeping for " << delay << "us before applying AutoFlags.";
@@ -420,7 +392,8 @@ Status AutoFlagsManager::ApplyConfig(ApplyNonRuntimeAutoFlags apply_non_runtime)
   return Status::OK();
 }
 
-Result<std::unordered_set<std::string>> AutoFlagsManager::GetAvailableAutoFlagsForServer() const {
+Result<std::unordered_set<std::string>> AutoFlagsManagerBase::GetAvailableAutoFlagsForServer()
+    const {
   auto all_auto_flags = VERIFY_RESULT(AutoFlagsUtil::GetAvailableAutoFlags());
   std::unordered_set<std::string> process_auto_flags;
   for (const auto& flag : all_auto_flags[process_name_]) {
@@ -429,72 +402,4 @@ Result<std::unordered_set<std::string>> AutoFlagsManager::GetAvailableAutoFlagsF
   return process_auto_flags;
 }
 
-// No thread safety analysis, as it cannot detect that the mutex is locked by UniqueLock.
-Status AutoFlagsManager::StoreUpdatedConfig(
-    AutoFlagsConfigPB& new_config,
-    std::function<Status(const AutoFlagsConfigPB&)> persist_config_func) NO_THREAD_SAFETY_ANALYSIS {
-  // The config has to get quorum committed in the sys_catalog before it can be stored in
-  // current_config_ even on the master leader. So, there will be delay between when the
-  // config_apply_time is computed and it being stored.
-  // During this window we should not respond to heartbeats since it will renew the leases in the
-  // tserver for auto_flags_apply_delay_ms, which can cause it to be higher than the
-  // config_apply_time we picked. We hold onto the mutex_ so that we do not respond to heartbeats.
-  //
-  // Raft and master leader election will guarantee that this is safe from crashes:
-  // If we crash between writing the WAL op and the it getting applied, then the new leader will
-  // apply it before responding to heartbeats. This is because new leader will have to commit the
-  // NO_OP record and apply all pending operations before it is marked ready. If the op was never
-  // replicated to the new leader then the operation will be lost, and the user will have to try
-  // again.
-  RSTATUS_DCHECK(
-      !update_lock_.owns_lock(), IllegalState, "AutoFlags config update already in progress");
-  update_lock_.lock();
-  auto se = ScopeExit([this]() NO_THREAD_SAFETY_ANALYSIS { update_lock_.unlock(); });
-
-  // This is an update of an existing config. The initial config must be applied immediately.
-  DCHECK_GE(new_config.config_version(), kMinAutoFlagsConfigVersion);
-  // Every config change must update the version by 1.
-  RSTATUS_DCHECK_EQ(
-      new_config.config_version(), current_config_.config_version() + 1, IllegalState,
-      "Attempting to store a stale config");
-
-  const auto now = clock_->Now();
-  const auto config_apply_ht = now.AddDelta(GetApplyDelay());
-  new_config.set_config_apply_time(config_apply_ht.ToUint64());
-
-  return persist_config_func(new_config);
-}
-
-// No thread safety analysis, as it cannot detect that the mutex is locked by UniqueLock.
-Status AutoFlagsManager::ProcessAutoFlagsConfigOperation(const AutoFlagsConfigPB new_config)
-    NO_THREAD_SAFETY_ANALYSIS {
-  bool unlock_needed = false;
-  auto se = ScopeExit([&update_lock = update_lock_, &unlock_needed]() NO_THREAD_SAFETY_ANALYSIS {
-    if (unlock_needed) {
-      update_lock.unlock();
-    }
-  });
-
-  // This function will be invoked when the ChangeAutoFlagsConfigOperation is applied. The
-  // StoreUpdatedConfig may be holding the lock already and waiting for us to complete in which case
-  // we do not have to reacquire the lock. If we crashed during StoreUpdatedConfig, then the
-  // operation can get applied at tablet bootstrap or a later time, and in both cases we need to get
-  // the lock.
-  if (!update_lock_.owns_lock()) {
-    update_lock_.lock();
-    unlock_needed = true;
-  }
-
-  return LoadFromConfigUnlocked(std::move(new_config), ApplyNonRuntimeAutoFlags::kFalse);
-}
-
-void AutoFlagsManager::HandleMasterHeartbeatResponse(
-    HybridTime heartbeat_sent_time, std::optional<AutoFlagsConfigPB> new_config) {
-  if (new_config) {
-    std::lock_guard l(mutex_);
-    // We cannot fail to load a new config that was provided by the master.
-    CHECK_OK(LoadFromConfigUnlocked(std::move(*new_config), ApplyNonRuntimeAutoFlags::kFalse));
-  }
-  last_config_sync_time_.store(heartbeat_sent_time, std::memory_order_release);
-}
 }  // namespace yb
diff --git a/src/yb/client/auto_flags_manager.h b/src/yb/server/auto_flags_manager_base.h
similarity index 56%
rename from src/yb/client/auto_flags_manager.h
rename to src/yb/server/auto_flags_manager_base.h
index b00fe317a8..526db0b290 100644
--- a/src/yb/client/auto_flags_manager.h
+++ b/src/yb/server/auto_flags_manager_base.h
@@ -29,40 +29,37 @@ YB_STRONGLY_TYPED_BOOL(ApplyNonRuntimeAutoFlags);
 
 class FsManager;
 
-class AutoFlagsManager {
+// There are two common ways in which a new config is loaded.
+//
+// LoadFromFile - On a process restart we load the config that was previous written to its local
+// disk. Synchronously waits for the apply time to pass before applying the config.
+//
+// LoadFromMasterLeader - On startup of a new process which does not have any previous config
+// stored in its local disk. Synchronously waits for the apply time to pass before applying the
+// config.
+//
+// Check the derived classes TserverAutoFlagsManager and MasterAutoFlagsManager for more details on
+// how they handle new config.
+class AutoFlagsManagerBase {
  public:
-  explicit AutoFlagsManager(
+  virtual Status ProcessAutoFlagsConfigOperation(const AutoFlagsConfigPB new_config) = 0;
+
+  uint32_t GetConfigVersion() const EXCLUDES(mutex_);
+
+  AutoFlagsConfigPB GetConfig() const EXCLUDES(mutex_);
+
+  // Returns all the AutoFlags associated with this process both promoted, and non-promoted ones.
+  Result<std::unordered_set<std::string>> GetAvailableAutoFlagsForServer() const;
+
+ protected:
+  explicit AutoFlagsManagerBase(
       const std::string& process_name, const scoped_refptr<ClockBase>& clock,
       FsManager* fs_manager);
-  ~AutoFlagsManager();
+  virtual ~AutoFlagsManagerBase();
 
-  Status Init(const std::string& local_hosts);
+  MonoDelta GetApplyDelay() const;
 
-  // There are five ways in which a new config is loaded.
-  //
-  // LoadFromFile - On a process restart we load the config that was previous written to its local
-  // disk. Synchronously waits for the apply time to pass before applying the config.
-  //
-  // LoadFromMaster - On startup of a new process which does not have any previous config
-  // stored in its local disk. Synchronously waits for the apply time to pass before applying the
-  // config.
-  //
-  // HandleMasterHeartbeatResponse - tserver only. A running tserver process that has already
-  // applied one version of the config has received a new config. Stores the new config to local
-  // disk immediately, and asynchronously applies the config at the provided config_apply_time.
-  //
-  // LoadNewConfig - master only. Stores a new config on cluster create or on the first upgrade from
-  // a version without AutoFlags to a version with AutoFlags.
-  //
-  // ProcessAutoFlagsConfigOperation - master only. Processes the ChangeAutoFlagsConfigOperation WAL
-  // operation on masters. Stores the new config to local disk immediately, and asynchronously
-  // applies the config at the provided config_apply_time.
-  //
-  // All config changes happen via StoreUpdatedConfig on the master leader.
-  // The master leader picks the config_apply_time and commits the config via a
-  // ChangeAutoFlagsConfigOperation. Heartbeat responses are blocked for the duration of this
-  // function to guarantee correctness. The apply of the WAL operation will trigger
-  // ProcessAutoFlagsConfigOperation on all master (including leader).
+  Status Init(const std::string& local_hosts);
 
   // Returns true if the load was successful, false if the file was not found.
   // Returns true without doing any work if AutoFlags management is disabled.
@@ -70,36 +67,24 @@ class AutoFlagsManager {
 
   // local_hosts is a comma separated list of ip addresses and ports.
   // Returns Status::OK without doing any work if AutoFlags management is disabled.
-  Status LoadFromMaster(
+  Status LoadFromMasterLeader(
       const std::string& local_hosts, const server::MasterAddresses& master_addresses)
       EXCLUDES(mutex_);
 
-  void HandleMasterHeartbeatResponse(
-      HybridTime heartbeat_sent_time, std::optional<AutoFlagsConfigPB> new_config);
-
-  // Returns Status::OK without doing any work if AutoFlags management is disabled.
-  Status LoadNewConfig(const AutoFlagsConfigPB new_config) EXCLUDES(mutex_);
-
-  Status ProcessAutoFlagsConfigOperation(const AutoFlagsConfigPB new_config);
-
-  // Used only on master to atomically set the config apply time and persist it in the sys_catalog.
-  Status StoreUpdatedConfig(
-      AutoFlagsConfigPB& new_config,
-      std::function<Status(const AutoFlagsConfigPB&)> persist_config_func);
-
-  uint32_t GetConfigVersion() const EXCLUDES(mutex_);
+  Status LoadFromConfigUnlocked(
+      const AutoFlagsConfigPB new_config, ApplyNonRuntimeAutoFlags apply_non_runtime,
+      bool apply_sync = false) REQUIRES(mutex_);
 
-  // Same as GetConfigVersion but makes sure the config is not stale. Config is stale if the tserver
-  // has not heartbeated to the master in auto_flags_apply_delay_ms ms.
-  Result<uint32_t> ValidateAndGetConfigVersion() const EXCLUDES(mutex_);
+  // FsManager is owned by the parent service, and is expected to outlive this object.
+  FsManager* fs_manager_;
 
-  AutoFlagsConfigPB GetConfig() const EXCLUDES(mutex_);
+  scoped_refptr<ClockBase> clock_;
 
-  // Returns all the AutoFlags associated with this process both promoted, and non-promoted ones.
-  Result<std::unordered_set<std::string>> GetAvailableAutoFlagsForServer() const;
+  // Expected to be held for a short time to either read or update current_config_.
+  mutable std::shared_mutex mutex_;
+  AutoFlagsConfigPB current_config_ GUARDED_BY(mutex_);
 
  private:
-  inline MonoDelta GetApplyDelay() const;
   Result<MonoDelta> GetTimeLeftToApplyConfig() const REQUIRES_SHARED(mutex_);
 
   // Sets new config to current_config_ if the version is higher. Validates that all flags in the
@@ -108,10 +93,6 @@ class AutoFlagsManager {
 
   Status WriteConfigToDisk() REQUIRES_SHARED(mutex_);
 
-  Status LoadFromConfigUnlocked(
-      const AutoFlagsConfigPB new_config, ApplyNonRuntimeAutoFlags apply_non_runtime,
-      bool apply_sync = false) REQUIRES(mutex_);
-
   Status ApplyConfig(ApplyNonRuntimeAutoFlags apply_non_runtime) const REQUIRES_SHARED(mutex_);
 
   void AsyncApplyConfig(uint32 config_version, ApplyNonRuntimeAutoFlags apply_non_runtime)
@@ -119,23 +100,15 @@ class AutoFlagsManager {
 
   // Get the AutoFlagConfig from master. Returns std::nullopt if master is runnning on an older
   // version that does not support AutoFlags.
-  Result<std::optional<AutoFlagsConfigPB>> GetAutoFlagConfigFromMaster(
+  Result<std::optional<AutoFlagsConfigPB>> GetAutoFlagConfigFromMasterLeader(
       const std::string& master_addresses);
 
   const std::string process_name_;
-  scoped_refptr<ClockBase> clock_;
-
-  // FsManager is owned by the parent service, and is expected to outlive this object.
-  FsManager* fs_manager_;
-
-  // Expected to be held for a short time to either read or update current_config_.
-  mutable std::shared_mutex mutex_;
-  UniqueLock<std::shared_mutex> update_lock_;
-  AutoFlagsConfigPB current_config_ GUARDED_BY(mutex_);
-  std::atomic<HybridTime> last_config_sync_time_{HybridTime::kInvalid};
 
   std::unique_ptr<rpc::SecureContext> secure_context_;
   std::unique_ptr<rpc::Messenger> messenger_;
+
+  DISALLOW_COPY_AND_ASSIGN(AutoFlagsManagerBase);
 };
 
 }  // namespace yb
diff --git a/src/yb/tablet/operations/change_auto_flags_config_operation.cc b/src/yb/tablet/operations/change_auto_flags_config_operation.cc
index 2686bd1d07..9673395700 100644
--- a/src/yb/tablet/operations/change_auto_flags_config_operation.cc
+++ b/src/yb/tablet/operations/change_auto_flags_config_operation.cc
@@ -10,7 +10,6 @@
 
 #include "yb/tablet/operations/change_auto_flags_config_operation.h"
 
-#include "yb/client/auto_flags_manager.h"
 #include "yb/consensus/consensus.messages.h"
 
 #include "yb/tablet/tablet.h"
diff --git a/src/yb/tablet/tablet.cc b/src/yb/tablet/tablet.cc
index c507a81b26..29a0be9302 100644
--- a/src/yb/tablet/tablet.cc
+++ b/src/yb/tablet/tablet.cc
@@ -36,7 +36,7 @@
 
 #include <boost/container/static_vector.hpp>
 
-#include "yb/client/auto_flags_manager.h"
+#include "yb/server/auto_flags_manager_base.h"
 #include "yb/client/client.h"
 #include "yb/client/error.h"
 #include "yb/client/meta_data_cache.h"
diff --git a/src/yb/tablet/tablet.h b/src/yb/tablet/tablet.h
index 8d21bf6cea..6e77109c74 100644
--- a/src/yb/tablet/tablet.h
+++ b/src/yb/tablet/tablet.h
@@ -1235,7 +1235,7 @@ class Tablet : public AbstractTablet,
 
   docdb::YQLRowwiseIteratorIf* cdc_iterator_ = nullptr;
 
-  AutoFlagsManager* auto_flags_manager_ = nullptr;
+  AutoFlagsManagerBase* auto_flags_manager_ = nullptr;
 
   mutable std::mutex control_path_mutex_;
   std::unordered_map<std::string, std::shared_ptr<void>> additional_metadata_
diff --git a/src/yb/tablet/tablet_options.h b/src/yb/tablet/tablet_options.h
index 020bb77bed..1a15817048 100644
--- a/src/yb/tablet/tablet_options.h
+++ b/src/yb/tablet/tablet_options.h
@@ -43,7 +43,7 @@ struct RocksDBPriorityThreadPoolMetrics;
 
 namespace yb {
 
-class AutoFlagsManager;
+class AutoFlagsManagerBase;
 class Env;
 class MemTracker;
 class MetricRegistry;
@@ -86,7 +86,7 @@ struct TabletInitData {
   TransactionManagerProvider transaction_manager_provider;
   docdb::LocalWaitingTxnRegistry* waiting_txn_registry = nullptr;
   ThreadPool* wait_queue_pool = nullptr;
-  AutoFlagsManager* auto_flags_manager = nullptr;
+  AutoFlagsManagerBase* auto_flags_manager = nullptr;
   ThreadPool* full_compaction_pool;
   ThreadPool* admin_triggered_compaction_pool;
   scoped_refptr<yb::AtomicGauge<uint64_t>> post_split_compaction_added;
diff --git a/src/yb/tserver/CMakeLists.txt b/src/yb/tserver/CMakeLists.txt
index 3ee7e6578d..0cee718076 100644
--- a/src/yb/tserver/CMakeLists.txt
+++ b/src/yb/tserver/CMakeLists.txt
@@ -239,6 +239,7 @@ set(TSERVER_SRCS
   tablet_validator.cc
   ts_tablet_manager.cc
   tserver-path-handlers.cc
+  tserver_auto_flags_manager.cc
   tserver_metrics_heartbeat_data_provider.cc
   server_main_util.cc
   stateful_services/pg_auto_analyze_service.cc
@@ -278,7 +279,9 @@ set(TSERVER_DEPS
   ysql_upgrade
   cdc
   cdc_consumer_proto
-  xcluster_producer_proto)
+  xcluster_producer_proto
+  auto_flags_manager_common
+)
 
 ADD_YB_LIBRARY(tserver
   SRCS ${TSERVER_SRCS}
diff --git a/src/yb/tserver/tablet_server.cc b/src/yb/tserver/tablet_server.cc
index 44bc403407..80f0f4348a 100644
--- a/src/yb/tserver/tablet_server.cc
+++ b/src/yb/tserver/tablet_server.cc
@@ -37,7 +37,6 @@
 #include <list>
 #include <thread>
 
-#include "yb/client/auto_flags_manager.h"
 #include "yb/client/client.h"
 #include "yb/client/client_fwd.h"
 #include "yb/client/transaction_manager.h"
@@ -83,6 +82,7 @@
 #include "yb/tserver/pg_table_mutation_count_sender.h"
 #include "yb/tserver/ts_tablet_manager.h"
 #include "yb/tserver/tserver-path-handlers.h"
+#include "yb/tserver/tserver_auto_flags_manager.h"
 #include "yb/tserver/tserver_service.proxy.h"
 #include "yb/tserver/xcluster_consumer_if.h"
 #include "yb/tserver/backup_service.h"
@@ -305,7 +305,7 @@ TabletServer::TabletServer(const TabletServerOptions& opts)
     : DbServerBase("TabletServer", opts, "yb.tabletserver", server::CreateMemTrackerForServer()),
       fail_heartbeats_for_tests_(false),
       opts_(opts),
-      auto_flags_manager_(new AutoFlagsManager("yb-tserver", clock(), fs_manager_.get())),
+      auto_flags_manager_(new TserverAutoFlagsManager(clock(), fs_manager_.get())),
       tablet_manager_(new TSTabletManager(fs_manager_.get(), this, metric_registry())),
       path_handlers_(new TabletServerPathHandlers(this)),
       maintenance_manager_(new MaintenanceManager(MaintenanceManager::DEFAULT_OPTIONS)),
@@ -506,12 +506,7 @@ Status TabletServer::Init() {
 }
 
 Status TabletServer::InitAutoFlags() {
-  RETURN_NOT_OK(auto_flags_manager_->Init(options_.HostsString()));
-
-  if (!VERIFY_RESULT(auto_flags_manager_->LoadFromFile())) {
-    RETURN_NOT_OK(
-        auto_flags_manager_->LoadFromMaster(options_.HostsString(), *opts_.GetMasterAddresses()));
-  }
+  RETURN_NOT_OK(auto_flags_manager_->Init(options_.HostsString(), *opts_.GetMasterAddresses()));
 
   return RpcAndWebServerBase::InitAutoFlags();
 }
diff --git a/src/yb/tserver/tablet_server.h b/src/yb/tserver/tablet_server.h
index 0b3699e5d0..5961d2f4a3 100644
--- a/src/yb/tserver/tablet_server.h
+++ b/src/yb/tserver/tablet_server.h
@@ -78,7 +78,12 @@ namespace yb {
 
 class Env;
 class MaintenanceManager;
-class AutoFlagsManager;
+
+namespace cdc {
+
+class CDCServiceImpl;
+
+}
 
 namespace cdc {
 
@@ -88,6 +93,7 @@ class CDCServiceImpl;
 
 namespace tserver {
 
+class TserverAutoFlagsManager;
 class PgClientServiceImpl;
 class XClusterConsumerIf;
 
@@ -351,7 +357,7 @@ class TabletServer : public DbServerBase, public TabletServerIf {
   // The options passed at construction time, and will be updated if master config changes.
   TabletServerOptions opts_;
 
-  std::unique_ptr<AutoFlagsManager> auto_flags_manager_;
+  std::unique_ptr<TserverAutoFlagsManager> auto_flags_manager_;
 
   // Manager for tablets which are available on this server.
   std::unique_ptr<TSTabletManager> tablet_manager_;
diff --git a/src/yb/tserver/tserver_auto_flags_manager.cc b/src/yb/tserver/tserver_auto_flags_manager.cc
new file mode 100644
index 0000000000..b0af505885
--- /dev/null
+++ b/src/yb/tserver/tserver_auto_flags_manager.cc
@@ -0,0 +1,71 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/tserver/tserver_auto_flags_manager.h"
+#include "yb/common/clock.h"
+
+DECLARE_uint64(max_clock_skew_usec);
+
+namespace yb::tserver {
+
+constexpr auto kYbTserverProcessName = "yb-tserver";
+
+TserverAutoFlagsManager::TserverAutoFlagsManager(
+    const scoped_refptr<ClockBase>& clock, FsManager* fs_manager)
+    : AutoFlagsManagerBase(kYbTserverProcessName, clock, fs_manager) {}
+
+Status TserverAutoFlagsManager::Init(
+    const std::string& local_hosts, const server::MasterAddresses& master_addresses) {
+  RETURN_NOT_OK(AutoFlagsManagerBase::Init(local_hosts));
+
+  if (VERIFY_RESULT(LoadFromFile())) {
+    return Status::OK();
+  }
+
+  return LoadFromMasterLeader(local_hosts, master_addresses);
+}
+
+Status TserverAutoFlagsManager::ProcessAutoFlagsConfigOperation(
+    const AutoFlagsConfigPB new_config) {
+  return STATUS(
+      NotSupported, "ProcessAutoFlagsConfigOperation not supported on TserverAutoFlagsManager");
+}
+
+void TserverAutoFlagsManager::HandleMasterHeartbeatResponse(
+    HybridTime heartbeat_sent_time, std::optional<AutoFlagsConfigPB> new_config) {
+  if (new_config) {
+    std::lock_guard l(mutex_);
+    // We cannot fail to load a new config that was provided by the master.
+    CHECK_OK(LoadFromConfigUnlocked(std::move(*new_config), ApplyNonRuntimeAutoFlags::kFalse));
+  }
+  last_config_sync_time_.store(heartbeat_sent_time, std::memory_order_release);
+}
+
+Result<uint32_t> TserverAutoFlagsManager::ValidateAndGetConfigVersion() const {
+  const auto last_config_sync_time = last_config_sync_time_.load(std::memory_order_acquire);
+  SCHECK(last_config_sync_time, IllegalState, "AutoFlags config is stale. No config sync time set");
+  const auto apply_delay = GetApplyDelay();
+  const auto max_allowed_time =
+      last_config_sync_time.AddDelta(apply_delay)
+          .AddDelta(MonoDelta::FromMicroseconds(-1 * FLAGS_max_clock_skew_usec));
+
+  const auto now = clock_->Now();
+  SCHECK_LT(
+      now, max_allowed_time, IllegalState,
+      Format(
+          "AutoFlags config is stale. Last sync time: $0, Max allowed staleness: $1",
+          last_config_sync_time, apply_delay));
+
+  return GetConfigVersion();
+}
+} // namespace yb::tserver
diff --git a/src/yb/tserver/tserver_auto_flags_manager.h b/src/yb/tserver/tserver_auto_flags_manager.h
new file mode 100644
index 0000000000..0a893eb633
--- /dev/null
+++ b/src/yb/tserver/tserver_auto_flags_manager.h
@@ -0,0 +1,50 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include "yb/server/auto_flags_manager_base.h"
+
+namespace yb {
+namespace tserver {
+
+// There are three ways in which a new config is loaded on the yb-tservers.
+//
+// LoadFromFile and LoadFromMasterLeader as described in AutoFlagsManagerBase.
+//
+// HandleMasterHeartbeatResponse - A running tserver process that has already applied one version of
+// the config has received a new config. Stores the new config to local disk immediately, and
+// asynchronously applies the config at the provided config_apply_time.
+class TserverAutoFlagsManager : public AutoFlagsManagerBase {
+ public:
+  explicit TserverAutoFlagsManager(const scoped_refptr<ClockBase>& clock, FsManager* fs_manager);
+
+  virtual ~TserverAutoFlagsManager() {}
+
+  Status Init(const std::string& local_hosts, const server::MasterAddresses& master_addresses);
+
+  Status ProcessAutoFlagsConfigOperation(const AutoFlagsConfigPB new_config) override;
+
+  void HandleMasterHeartbeatResponse(
+      HybridTime heartbeat_sent_time, std::optional<AutoFlagsConfigPB> new_config);
+
+  // Same as GetConfigVersion but makes sure the config is not stale. Config is stale if the tserver
+  // has not heartbeated to the master in auto_flags_apply_delay_ms ms.
+  Result<uint32_t> ValidateAndGetConfigVersion() const EXCLUDES(mutex_);
+
+ private:
+  std::atomic<HybridTime> last_config_sync_time_{HybridTime::kInvalid};
+};
+
+}  // namespace tserver
+}  // namespace yb
