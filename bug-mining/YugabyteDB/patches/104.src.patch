diff --git a/src/yb/consensus/log-dump.cc b/src/yb/consensus/log-dump.cc
index abb50865a5..86601f6540 100644
--- a/src/yb/consensus/log-dump.cc
+++ b/src/yb/consensus/log-dump.cc
@@ -30,8 +30,6 @@
 // under the License.
 //
 
-#include <map>
-#include <set>
 #include <vector>
 
 #include <boost/preprocessor/cat.hpp>
@@ -51,49 +49,45 @@
 #include "yb/docdb/docdb_types.h"
 #include "yb/dockv/doc_key.h"
 #include "yb/docdb/kv_debug.h"
-#include "yb/dockv/schema_packing.h"
 
-#include "yb/gutil/stl_util.h"
 #include "yb/gutil/strings/numbers.h"
 
-#include "yb/util/atomic.h"
 #include "yb/util/env.h"
 #include "yb/util/flags.h"
 #include "yb/util/logging.h"
-#include "yb/util/memory/arena.h"
 #include "yb/util/metric_entity.h"
-#include "yb/util/monotime.h"
 #include "yb/util/pb_util.h"
 #include "yb/util/result.h"
 #include "yb/util/slice.h"
 #include "yb/util/size_literals.h"
 #include "yb/util/status_format.h"
 
-DEFINE_UNKNOWN_bool(print_headers, true, "print the log segment headers/footers");
-DEFINE_UNKNOWN_bool(filter_log_segment, false, "filter the input log segment");
-DEFINE_UNKNOWN_string(print_entries, "decoded",
+DEFINE_NON_RUNTIME_bool(print_headers, true, "print the log segment headers/footers");
+DEFINE_NON_RUNTIME_bool(filter_log_segment, false, "filter the input log segment");
+DEFINE_NON_RUNTIME_string(print_entries, "decoded",
               "How to print entries:\n"
               "  false|0|no = don't print\n"
               "  true|1|yes|decoded = print them decoded\n"
               "  pb = print the raw protobuf\n"
               "  id = print only their ids");
-DEFINE_UNKNOWN_int32(truncate_data, 100,
+DEFINE_NON_RUNTIME_int32(truncate_data, 100,
              "Truncate the data fields to the given number of bytes "
              "before printing. Set to 0 to disable");
 
-DEFINE_UNKNOWN_int64(min_op_term_to_omit, yb::OpId::Invalid().term,
+DEFINE_NON_RUNTIME_int64(min_op_term_to_omit, yb::OpId::Invalid().term,
              "Term of first record (inclusive) to omit from the result for --filter_log_segment");
 
-DEFINE_UNKNOWN_int64(min_op_index_to_omit, yb::OpId::Invalid().index,
+DEFINE_NON_RUNTIME_int64(min_op_index_to_omit, yb::OpId::Invalid().index,
              "Index of first record (inclusive) to omit from the result for --filter_log_segment");
 
-DEFINE_UNKNOWN_int64(max_op_term_to_omit, yb::OpId::Invalid().term,
+DEFINE_NON_RUNTIME_int64(max_op_term_to_omit, yb::OpId::Invalid().term,
              "Term of last record (inclusive) to omit from the result for --filter_log_segment");
 
-DEFINE_UNKNOWN_int64(max_op_index_to_omit, yb::OpId::Invalid().index,
+DEFINE_NON_RUNTIME_int64(max_op_index_to_omit, yb::OpId::Invalid().index,
              "Index of last record (inclusive) to omit from the result for --filter_log_segment");
 
-DEFINE_UNKNOWN_string(output_wal_dir, "", "WAL directory for the output of --filter_log_segment");
+DEFINE_NON_RUNTIME_string(output_wal_dir, "",
+             "WAL directory for the output of --filter_log_segment");
 
 namespace yb {
 namespace log {
@@ -154,6 +148,10 @@ void PrintIdOnly(const LogEntryPB& entry) {
 
 Status PrintDecodedWriteRequestPB(const string& indent, const tablet::WritePB& write) {
   cout << indent << "write {" << endl;
+  if (write.has_external_hybrid_time()) {
+    HybridTime ht(write.external_hybrid_time());
+    cout << indent << indent << "external_hybrid_time: " << ht.ToDebugString() << endl;
+  }
   if (write.has_write_batch()) {
     if (write.has_unused_tablet_id()) {
       cout << indent << indent << "unused_tablet_id: " << write.unused_tablet_id() << endl;
@@ -178,6 +176,11 @@ Status PrintDecodedWriteRequestPB(const string& indent, const tablet::WritePB& w
             nullptr /*schema_packing_provider*/);
         cout << indent << indent << indent << indent << "Value: " << formatted_value << endl;
       }
+      if (kv.has_external_hybrid_time()) {
+        HybridTime ht(kv.external_hybrid_time());
+        cout << indent << indent << indent << indent
+             << "external_hybrid_time: " << ht.ToDebugString() << endl;
+      }
       cout << indent << indent << indent << "}" << endl;  // write_pairs {
     }
     cout << indent << indent << "}" << endl;  // write_batch {
