diff --git a/src/postgres/third-party-extensions/pg_cron/src/pg_cron.c b/src/postgres/third-party-extensions/pg_cron/src/pg_cron.c
index 197bc5e500..addad8d4ff 100644
--- a/src/postgres/third-party-extensions/pg_cron/src/pg_cron.c
+++ b/src/postgres/third-party-extensions/pg_cron/src/pg_cron.c
@@ -2418,6 +2418,14 @@ ExecuteSqlString(const char *sql)
 static bool
 jobCanceled(CronTask *task)
 {
+	if (IsYugaByteEnabled() && !ybIsLeader)
+	{
+		task->errorMessage = "pg_cron leader changed";
+		task->state = CRON_TASK_ERROR;
+		task->pollingStatus = 0;
+		return true;
+	}
+
     Assert(task->state == CRON_TASK_CONNECTING || \
             task->state == CRON_TASK_SENDING || \
             task->state == CRON_TASK_BGW_RUNNING || \
diff --git a/src/yb/integration-tests/pg_cron-test.cc b/src/yb/integration-tests/pg_cron-test.cc
index 6ea19b9023..c908b20353 100644
--- a/src/yb/integration-tests/pg_cron-test.cc
+++ b/src/yb/integration-tests/pg_cron-test.cc
@@ -581,4 +581,42 @@ TEST_F(PgCronTest, DeactivateRunningJob) {
   ASSERT_OK(WaitForRowCountAbove(initial_row_count));
 }
 
+TEST_F(PgCronTest, CancelJobOnLeaderChange) {
+  // Start a job that will run for a long time.
+  ASSERT_OK(ScheduleJob("Sleep Job", "1 second", "SELECT pg_sleep(1000)"));
+  ASSERT_OK(Schedule1SecInsertJob());
+
+  ASSERT_OK(WaitForRowCountAbove(0));
+
+  auto nodes_running_sleep_jobs = [this]() -> Result<std::set<size_t>> {
+    std::set<size_t> nodes_running_job;
+    for (size_t idx = 0; idx < cluster_->num_tablet_servers(); ++idx) {
+      auto conn = VERIFY_RESULT(cluster_->ConnectToDB("yugabyte", idx));
+      if (VERIFY_RESULT(conn.FetchRow<pgwrapper::PGUint64>(
+              "SELECT COUNT(*) FROM pg_stat_activity WHERE query = 'SELECT pg_sleep(1000)'")) > 0) {
+        nodes_running_job.insert(idx);
+      }
+    }
+    return nodes_running_job;
+  };
+
+  const auto initial_nodes_running_job = ASSERT_RESULT(nodes_running_sleep_jobs());
+  ASSERT_EQ(initial_nodes_running_job.size(), 1);
+
+  ASSERT_OK(cluster_->MoveTabletLeader(tablet_id_));
+
+  // Wait for the new leader to start running.
+  const auto initial_row_count = ASSERT_RESULT(GetRowCount());
+  ASSERT_OK(WaitForRowCountAbove(initial_row_count));
+
+  const auto final_nodes_running_job = ASSERT_RESULT(nodes_running_sleep_jobs());
+  ASSERT_EQ(final_nodes_running_job.size(), 1);
+  ASSERT_NE(*final_nodes_running_job.begin(), *initial_nodes_running_job.begin());
+
+  const auto count_killed = ASSERT_RESULT(conn_->FetchRow<pgwrapper::PGUint64>(
+      "SELECT COUNT(*) FROM cron.job_run_details WHERE return_message = 'pg_cron leader changed'"));
+  ASSERT_TRUE(count_killed == 1 || count_killed == 2)
+      << count_killed << " rows found when only 1 or 2 is expected";
+}
+
 }  // namespace yb
