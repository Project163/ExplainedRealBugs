diff --git a/src/yb/integration-tests/xcluster/xcluster_consistency-test.cc b/src/yb/integration-tests/xcluster/xcluster_consistency-test.cc
index d8c4bbd0ca..b2bfabc1d1 100644
--- a/src/yb/integration-tests/xcluster/xcluster_consistency-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_consistency-test.cc
@@ -147,7 +147,7 @@ class XClusterConsistencyTest : public XClusterYsqlTestBase {
   virtual Status PreReplicationSetup() { return Status::OK(); }
 
   Status WriteWorkload(const client::YBTableName& table, uint32_t start, uint32_t end) {
-    return super::WriteWorkload(table, start, end, &producer_cluster_);
+    return super::WriteWorkload(start, end, &producer_cluster_, table);
   }
 
   virtual Status PostReplicationSetup() {
@@ -493,7 +493,7 @@ class XClusterSingleClusterTest : public XClusterYsqlTestBase {
 TEST_F_EX(XClusterConsistencyTest, BootstrapAbortInFlightTxn, XClusterSingleClusterTest) {
   ASSERT_OK(TestAbortInFlightTxn());
 
-  ASSERT_OK(WriteWorkload(producer_table_->name(), 0, 10, &producer_cluster_));
+  ASSERT_OK(WriteWorkload(0, 10, &producer_cluster_, producer_table_->name()));
   auto count = ASSERT_RESULT(GetRowCount(producer_table_->name(), &producer_cluster_));
   ASSERT_EQ(count, 10);
 }
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
index 13fd4eb90b..0e160df921 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
@@ -1426,7 +1426,7 @@ TEST_F(XClusterDDLReplicationSwitchoverTest, SwitchoverWithWorkload) {
   num_rows_written += kNumRecordsPerBatch;
   // B should still disallow writes as it is still a target.
   ASSERT_NOK_STR_CONTAINS(
-      WriteWorkload(table_name, num_rows_written, num_rows_written + 1, cluster_B_),
+      WriteWorkload(num_rows_written, num_rows_written + 1, cluster_B_, table_name),
       "Data modification is forbidden");
 
   LOG(INFO) << "===== Switchover: set up replication from B to A";
@@ -1437,10 +1437,10 @@ TEST_F(XClusterDDLReplicationSwitchoverTest, SwitchoverWithWorkload) {
   ASSERT_OK(ValidateReplicationRole(*cluster_A_, "target"));
   ASSERT_OK(ValidateReplicationRole(*cluster_B_, "target"));
   ASSERT_NOK_STR_CONTAINS(
-      WriteWorkload(table_name, num_rows_written, num_rows_written + 1, cluster_A_),
+      WriteWorkload(num_rows_written, num_rows_written + 1, cluster_A_, table_name),
       "Data modification is forbidden");
   ASSERT_NOK_STR_CONTAINS(
-      WriteWorkload(table_name, num_rows_written, num_rows_written + 1, cluster_B_),
+      WriteWorkload(num_rows_written, num_rows_written + 1, cluster_B_, table_name),
       "Data modification is forbidden");
 
   LOG(INFO) << "===== Continuing switchover: drop replication from A to B";
@@ -1467,7 +1467,7 @@ TEST_F(XClusterDDLReplicationSwitchoverTest, SwitchoverWithWorkload) {
       kBackwardsReplicationGroupId);
   // Writes on A should be blocked.
   ASSERT_NOK_STR_CONTAINS(
-      WriteWorkload(table_name, num_rows_written, num_rows_written + 1, cluster_A_),
+      WriteWorkload(num_rows_written, num_rows_written + 1, cluster_A_, table_name),
       "Data modification is forbidden");
 }
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_dr-itest.cc b/src/yb/integration-tests/xcluster/xcluster_dr-itest.cc
index c566173b3b..aa8cc1af95 100644
--- a/src/yb/integration-tests/xcluster/xcluster_dr-itest.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_dr-itest.cc
@@ -99,16 +99,16 @@ class XClusterDRTest : public XClusterYsqlTestBase {
 
   Status WriteBatchOnSource() {
     RETURN_NOT_OK(WriteWorkload(
-        (*source_table_)->name(), written_rows_count_, written_rows_count_ + kNumRecordsPerBatch,
-        source_cluster_));
+        written_rows_count_, written_rows_count_ + kNumRecordsPerBatch, source_cluster_,
+        (*source_table_)->name()));
     written_rows_count_ += kNumRecordsPerBatch;
     return Status::OK();
   }
 
   Status WriteBatchOnTarget() {
     return WriteWorkload(
-        (*target_table_)->name(), written_rows_count_, written_rows_count_ + kNumRecordsPerBatch,
-        target_cluster_);
+        written_rows_count_, written_rows_count_ + kNumRecordsPerBatch,
+        target_cluster_, (*target_table_)->name());
   }
 
   Status ValidateBatchCountOnTarget(int expected_num_batches) {
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc b/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
index 284d667824..6f84d80689 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
@@ -2247,7 +2247,7 @@ void XClusterYsqlTest::ValidateRecordsXClusterWithCDCSDK(
   if (do_explict_transaction) {
     ASSERT_OK(InsertTransactionalBatchOnProducer(0, 10));
   } else {
-    ASSERT_OK(InsertRowsInProducer(0, 10));
+    ASSERT_OK(InsertRowsInProducer(0, 10, /*producer_table=*/nullptr, /*use_transaction=*/false));
   }
 
   // Verify data is written on the producer.
@@ -2297,7 +2297,9 @@ void XClusterYsqlTest::ValidateRecordsXClusterWithCDCSDK(
   if (do_explict_transaction) {
     ASSERT_OK(InsertTransactionalBatchOnProducer(batch_insert_count, batch_insert_count * 2));
   } else {
-    ASSERT_OK(InsertRowsInProducer(batch_insert_count, batch_insert_count * 2));
+    ASSERT_OK(InsertRowsInProducer(
+        batch_insert_count, batch_insert_count * 2, /*producer_table=*/nullptr,
+        /*use_transaction=*/false));
   }
   // Verify data is written on the producer, which should previous plus
   // current new insert.
@@ -2522,7 +2524,9 @@ TEST_P(XClusterPgSchemaNameTest, SetupSameNameDifferentSchemaUniverseReplication
   // Write different numbers of records to the 3 producers, and verify that the
   // corresponding receivers receive the records.
   for (int i = 0; i < kNumTables; i++) {
-    ASSERT_OK(WriteWorkload(0, 2 * (i + 1), &producer_cluster_, producer_table_names[i]));
+    ASSERT_OK(WriteWorkload(
+        0, 2 * (i + 1), &producer_cluster_, producer_table_names[i], /*delete_op=*/false,
+        /*use_transaction=*/false));
     ASSERT_OK(VerifyWrittenRecords(producer_table_names[i], consumer_table_names[i]));
   }
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
index 4f24a37002..7c841b25ec 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
@@ -512,31 +512,6 @@ Status XClusterYsqlTestBase::DropYsqlTable(Cluster& cluster, const client::YBTab
       table_name.relation_type() == master::INDEX_TABLE_RELATION);
 }
 
-Status XClusterYsqlTestBase::WriteWorkload(
-    const YBTableName& table, uint32_t start, uint32_t end, Cluster* cluster) {
-  auto conn = VERIFY_RESULT(cluster->ConnectToDB(table.namespace_name()));
-  std::string table_name_str = GetCompleteTableName(table);
-
-  LOG(INFO) << "Writing " << end - start << " inserts";
-
-  // Use a transaction if more than 1 row is to be inserted.
-  const bool use_tran = end - start > 1;
-  if (use_tran) {
-    RETURN_NOT_OK(conn.ExecuteFormat("BEGIN"));
-  }
-
-  for (uint32_t i = start; i < end; i++) {
-    RETURN_NOT_OK(
-        conn.ExecuteFormat("INSERT INTO $0($1) VALUES ($2)", table_name_str, kKeyColumnName, i));
-  }
-
-  if (use_tran) {
-    RETURN_NOT_OK(conn.ExecuteFormat("COMMIT"));
-  }
-
-  return Status::OK();
-}
-
 Result<pgwrapper::PGResultPtr> XClusterYsqlTestBase::ScanToStrings(
     const YBTableName& table_name, XClusterTestBase::Cluster* cluster) {
   auto conn = VERIFY_RESULT(cluster->ConnectToDB(table_name.namespace_name()));
@@ -715,7 +690,7 @@ void XClusterYsqlTestBase::BumpUpSchemaVersionsWithAlters(
 
 Status XClusterYsqlTestBase::InsertRowsInProducer(
     uint32_t start, uint32_t end, std::shared_ptr<client::YBTable> producer_table,
-    bool use_transaction) {
+    std::optional<bool> use_transaction) {
   if (!producer_table) {
     producer_table = producer_table_;
   }
@@ -726,7 +701,7 @@ Status XClusterYsqlTestBase::InsertRowsInProducer(
 
 Status XClusterYsqlTestBase::DeleteRowsInProducer(
     uint32_t start, uint32_t end, std::shared_ptr<client::YBTable> producer_table,
-    bool use_transaction) {
+    std::optional<bool> use_transaction) {
   if (!producer_table) {
     producer_table = producer_table_;
   }
@@ -782,12 +757,13 @@ Status XClusterYsqlTestBase::WriteTransactionalWorkload(
 
 Status XClusterYsqlTestBase::WriteWorkload(
     uint32_t start, uint32_t end, Cluster* cluster, const YBTableName& table, bool delete_op,
-    bool use_transaction) {
+    std::optional<bool> use_transaction_opt) {
   auto conn = VERIFY_RESULT(cluster->ConnectToDB(table.namespace_name()));
   std::string table_name_str = GetCompleteTableName(table);
 
+  bool use_transaction = use_transaction_opt.value_or(end != start);
   LOG(INFO) << "Writing " << end - start << (delete_op ? " deletes" : " inserts")
-            << " using transaction " << use_transaction;
+            << " use_transaction: " << use_transaction;
   if (use_transaction) {
     RETURN_NOT_OK(conn.ExecuteFormat("BEGIN"));
   }
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
index 2b43ab1fab..f0b53c0dc8 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
@@ -116,9 +116,6 @@ class XClusterYsqlTestBase : public XClusterTestBase {
 
   Status DropYsqlTable(Cluster& cluster, const client::YBTable& table);
 
-  static Status WriteWorkload(
-      const client::YBTableName& table, uint32_t start, uint32_t end, Cluster* cluster);
-
   static Result<pgwrapper::PGResultPtr> ScanToStrings(
       const client::YBTableName& table_name, Cluster* cluster);
 
@@ -152,13 +149,17 @@ class XClusterYsqlTestBase : public XClusterTestBase {
 
   void BumpUpSchemaVersionsWithAlters(const std::vector<std::shared_ptr<client::YBTable>>& tables);
 
+  // If use_transaction is not set, the workload will be written in a transaction if more than 1 row
+  // is specified.
   Status InsertRowsInProducer(
       uint32_t start, uint32_t end, std::shared_ptr<client::YBTable> producer_table = {},
-      bool use_transaction = false);
+      std::optional<bool> use_transaction = std::nullopt);
 
+  // If use_transaction is not set, the workload will be written in a transaction if more than 1 row
+  // is specified.
   Status DeleteRowsInProducer(
       uint32_t start, uint32_t end, std::shared_ptr<client::YBTable> producer_table = {},
-      bool use_transaction = false);
+      std::optional<bool> use_transaction = std::nullopt);
 
   Status InsertGenerateSeriesOnProducer(
       uint32_t start, uint32_t end, std::shared_ptr<client::YBTable> producer_table = {});
@@ -167,9 +168,11 @@ class XClusterYsqlTestBase : public XClusterTestBase {
       uint32_t start, uint32_t end, std::shared_ptr<client::YBTable> producer_table = {},
       bool commit_transaction = true);
 
+  // If use_transaction is not set, the workload will be written in a transaction if more than 1 row
+  // is specified.
   Status WriteWorkload(
       uint32_t start, uint32_t end, Cluster* cluster, const client::YBTableName& table,
-      bool delete_op = false, bool use_transaction = false);
+      bool delete_op = false, std::optional<bool> use_transaction = std::nullopt);
 
   virtual Status CheckpointReplicationGroup(
       const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId,
