diff --git a/src/yb/client/client-internal.cc b/src/yb/client/client-internal.cc
index 8612e7cdad..4bce558a6c 100644
--- a/src/yb/client/client-internal.cc
+++ b/src/yb/client/client-internal.cc
@@ -322,6 +322,9 @@ YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, CreateXClusterReplication);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, IsCreateXClusterReplicationDone);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, XClusterCreateOutboundReplicationGroup);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, XClusterDeleteOutboundReplicationGroup);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, AddNamespaceToXClusterReplication);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, IsAlterXClusterReplicationDone);
+YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, DeleteUniverseReplication);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, RepairOutboundXClusterReplicationGroupAddTable);
 YB_CLIENT_SPECIALIZE_SIMPLE_EX(Replication, RepairOutboundXClusterReplicationGroupRemoveTable);
 
diff --git a/src/yb/client/client.cc b/src/yb/client/client.cc
index fb99bbd833..8df4924191 100644
--- a/src/yb/client/client.cc
+++ b/src/yb/client/client.cc
@@ -1783,40 +1783,6 @@ Status YBClient::BootstrapProducer(
       this, db_type, namespace_name, pg_schema_names, table_names, deadline, std::move(callback));
 }
 
-Result<NamespaceId> YBClient::XClusterAddNamespaceToOutboundReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id, const NamespaceName& namespace_name) {
-  master::XClusterAddNamespaceToOutboundReplicationGroupRequestPB req;
-  req.set_replication_group_id(replication_group_id.ToString());
-  req.set_namespace_name(namespace_name);
-
-  master::XClusterAddNamespaceToOutboundReplicationGroupResponsePB resp;
-  CALL_SYNC_LEADER_MASTER_RPC_EX(
-      Replication, req, resp, XClusterAddNamespaceToOutboundReplicationGroup);
-
-  if (resp.has_error()) {
-    return StatusFromPB(resp.error().status());
-  }
-
-  return resp.namespace_id();
-}
-
-Status YBClient::XClusterRemoveNamespaceFromOutboundReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id) {
-  master::XClusterRemoveNamespaceFromOutboundReplicationGroupRequestPB req;
-  req.set_replication_group_id(replication_group_id.ToString());
-  req.set_namespace_id(namespace_id);
-
-  master::XClusterRemoveNamespaceFromOutboundReplicationGroupResponsePB resp;
-  CALL_SYNC_LEADER_MASTER_RPC_EX(
-      Replication, req, resp, XClusterRemoveNamespaceFromOutboundReplicationGroup);
-
-  if (resp.has_error()) {
-    return StatusFromPB(resp.error().status());
-  }
-
-  return Status::OK();
-}
-
 Status YBClient::UpdateConsumerOnProducerSplit(
     const xcluster::ReplicationGroupId& replication_group_id, const xrepl::StreamId& stream_id,
     const master::ProducerSplitTabletInfoPB& split_info) {
diff --git a/src/yb/client/client.h b/src/yb/client/client.h
index 27fed46bf2..b19a0a610f 100644
--- a/src/yb/client/client.h
+++ b/src/yb/client/client.h
@@ -680,12 +680,6 @@ class YBClient {
       const std::vector<TableName>& table_names,
       BootstrapProducerCallback callback);
 
-  Result<NamespaceId> XClusterAddNamespaceToOutboundReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id,
-      const NamespaceName& namespace_name);
-
-  Status XClusterRemoveNamespaceFromOutboundReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id);
 
   // Update consumer pollers after a producer side tablet split.
   Status UpdateConsumerOnProducerSplit(
diff --git a/src/yb/client/xcluster_client.cc b/src/yb/client/xcluster_client.cc
index 4f0a08e126..31506a86c0 100644
--- a/src/yb/client/xcluster_client.cc
+++ b/src/yb/client/xcluster_client.cc
@@ -44,11 +44,11 @@ Result<ResponsePB> XClusterClient::SyncLeaderMasterRpc(
   return resp;
 }
 
-Status XClusterClient::CreateXClusterReplication(
+Status XClusterClient::CreateXClusterReplicationFromCheckpoint(
     const xcluster::ReplicationGroupId& replication_group_id,
     const std::string& target_master_addresses) {
-  SCHECK(!replication_group_id.empty(), InvalidArgument, "Replication group id is empty");
-  SCHECK(!target_master_addresses.empty(), InvalidArgument, "Target master_addresses is empty");
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication group Id");
+  SCHECK(!target_master_addresses.empty(), InvalidArgument, "Invalid Target master_addresses");
 
   master::CreateXClusterReplicationRequestPB req;
   req.set_replication_group_id(replication_group_id.ToString());
@@ -67,8 +67,8 @@ Status XClusterClient::CreateXClusterReplication(
 Result<IsOperationDoneResult> XClusterClient::IsCreateXClusterReplicationDone(
     const xcluster::ReplicationGroupId& replication_group_id,
     const std::string& target_master_addresses) {
-  SCHECK(!replication_group_id.empty(), InvalidArgument, "Replication group id is empty");
-  SCHECK(!target_master_addresses.empty(), InvalidArgument, "Target master_addresses is empty");
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication group Id");
+  SCHECK(!target_master_addresses.empty(), InvalidArgument, "Invalid Target master_addresses");
 
   master::IsCreateXClusterReplicationDoneRequestPB req;
   req.set_replication_group_id(replication_group_id.ToString());
@@ -94,15 +94,16 @@ Result<IsOperationDoneResult> XClusterClient::IsCreateXClusterReplicationDone(
   return IsOperationDoneResult::Done();
 }
 
-Result<std::vector<NamespaceId>> XClusterClient::XClusterCreateOutboundReplicationGroup(
+Status XClusterClient::CreateOutboundReplicationGroup(
     const xcluster::ReplicationGroupId& replication_group_id,
-    const std::vector<NamespaceName>& namespace_names) {
-  SCHECK(!namespace_names.empty(), InvalidArgument, "At least one namespace name is required");
+    const std::vector<NamespaceId>& namespace_ids) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication group Id");
+  SCHECK(!namespace_ids.empty(), InvalidArgument, "At least one namespace Id is required");
 
   master::XClusterCreateOutboundReplicationGroupRequestPB req;
   req.set_replication_group_id(replication_group_id.ToString());
-  for (const auto& ns : namespace_names) {
-    req.add_namespace_names(ns);
+  for (const auto& namespace_id : namespace_ids) {
+    req.add_namespace_ids(namespace_id);
   }
 
   auto resp = CALL_SYNC_LEADER_MASTER_RPC(XClusterCreateOutboundReplicationGroup, req);
@@ -111,26 +112,58 @@ Result<std::vector<NamespaceId>> XClusterClient::XClusterCreateOutboundReplicati
     return StatusFromPB(resp.error().status());
   }
 
-  std::vector<NamespaceId> namespace_ids;
-  for (const auto& namespace_id : resp.namespace_ids()) {
-    namespace_ids.push_back(namespace_id);
-  }
-
-  return namespace_ids;
+  return Status::OK();
 }
 
-Status XClusterClient::IsXClusterBootstrapRequired(
+Status XClusterClient::IsBootstrapRequired(
     CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
     const NamespaceId& namespace_id, IsXClusterBootstrapRequiredCallback callback) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication group Id");
+  SCHECK(!namespace_id.empty(), InvalidArgument, "Invalid Namespace Id");
+
   return yb_client_.data_->IsXClusterBootstrapRequired(
       &yb_client_, deadline, replication_group_id, namespace_id, std::move(callback));
 }
 
-Status XClusterClient::XClusterDeleteOutboundReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id) {
+Status XClusterClient::RemoveNamespaceFromOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
+    const std::string& target_master_addresses) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication group Id");
+  SCHECK(!namespace_id.empty(), InvalidArgument, "Invalid Namespace Id");
+
+  master::XClusterRemoveNamespaceFromOutboundReplicationGroupRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+  req.set_namespace_id(namespace_id);
+
+  if (!target_master_addresses.empty()) {
+    auto hp_vec =
+        VERIFY_RESULT(HostPort::ParseStrings(target_master_addresses, master::kMasterDefaultPort));
+    HostPortsToPBs(hp_vec, req.mutable_target_master_addresses());
+  }
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(XClusterRemoveNamespaceFromOutboundReplicationGroup, req);
+
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+
+  return Status::OK();
+}
+
+Status XClusterClient::DeleteOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::string& target_master_addresses) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication group Id");
+
   master::XClusterDeleteOutboundReplicationGroupRequestPB req;
   req.set_replication_group_id(replication_group_id.ToString());
 
+  if (!target_master_addresses.empty()) {
+    auto hp_vec =
+        VERIFY_RESULT(HostPort::ParseStrings(target_master_addresses, master::kMasterDefaultPort));
+    HostPortsToPBs(hp_vec, req.mutable_target_master_addresses());
+  }
+
   auto resp = CALL_SYNC_LEADER_MASTER_RPC(XClusterDeleteOutboundReplicationGroup, req);
 
   if (resp.has_error()) {
@@ -139,21 +172,137 @@ Status XClusterClient::XClusterDeleteOutboundReplicationGroup(
   return Status::OK();
 }
 
+Status XClusterClient::RemoveNamespaceFromUniverseReplication(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const NamespaceId& source_namespace_id, const UniverseUuid& target_universe_uuid) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication group Id");
+  SCHECK(!source_namespace_id.empty(), InvalidArgument, "Invalid Namespace Id");
+
+  master::AlterUniverseReplicationRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+  req.set_producer_namespace_id_to_remove(source_namespace_id);
+  if (!target_universe_uuid.IsNil()) {
+    req.set_universe_uuid(target_universe_uuid.ToString());
+  }
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(AlterUniverseReplication, req);
+
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+  return Status::OK();
+}
+
+Status XClusterClient::DeleteUniverseReplication(
+    const xcluster::ReplicationGroupId& replication_group_id, bool ignore_errors,
+    const UniverseUuid& target_universe_uuid) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication group Id");
+
+  master::DeleteUniverseReplicationRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+  req.set_ignore_errors(ignore_errors);
+  if (!target_universe_uuid.IsNil()) {
+    req.set_universe_uuid(target_universe_uuid.ToString());
+  }
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(DeleteUniverseReplication, req);
+
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+  return Status::OK();
+}
+
 Status XClusterClient::GetXClusterStreams(
     CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
     const NamespaceId& namespace_id, const std::vector<TableName>& table_names,
     const std::vector<PgSchemaName>& pg_schema_names, GetXClusterStreamsCallback callback) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication group Id");
+  SCHECK(!namespace_id.empty(), InvalidArgument, "Invalid Namespace Id");
+
   return yb_client_.data_->GetXClusterStreams(
       &yb_client_, deadline, replication_group_id, namespace_id, table_names, pg_schema_names,
       std::move(callback));
 }
 
+Status XClusterClient::AddNamespaceToOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication Group Id");
+  SCHECK(!namespace_id.empty(), InvalidArgument, "Invalid namespace name");
+
+  master::XClusterAddNamespaceToOutboundReplicationGroupRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+  req.set_namespace_id(namespace_id);
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(XClusterAddNamespaceToOutboundReplicationGroup, req);
+
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+
+  return Status::OK();
+}
+
+Status XClusterClient::AddNamespaceToXClusterReplication(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::string& target_master_addresses, const NamespaceId& source_namespace_id) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication Group Id");
+  SCHECK(!target_master_addresses.empty(), InvalidArgument, "Invalid target master addresses");
+  SCHECK(!source_namespace_id.empty(), InvalidArgument, "Invalid namespace name");
+
+  master::AddNamespaceToXClusterReplicationRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+  req.set_namespace_id(source_namespace_id);
+
+  auto hp_vec =
+      VERIFY_RESULT(HostPort::ParseStrings(target_master_addresses, master::kMasterDefaultPort));
+  HostPortsToPBs(hp_vec, req.mutable_target_master_addresses());
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(AddNamespaceToXClusterReplication, req);
+
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+
+  return Status::OK();
+}
+
+Result<IsOperationDoneResult> XClusterClient::IsAlterXClusterReplicationDone(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::string& target_master_addresses) {
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication Group Id");
+  SCHECK(!target_master_addresses.empty(), InvalidArgument, "Invalid target master_addresses");
+
+  master::IsAlterXClusterReplicationDoneRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+
+  auto hp_vec =
+      VERIFY_RESULT(HostPort::ParseStrings(target_master_addresses, master::kMasterDefaultPort));
+  HostPortsToPBs(hp_vec, req.mutable_target_master_addresses());
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(IsAlterXClusterReplicationDone, req);
+
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+
+  if (!resp.done()) {
+    return IsOperationDoneResult::NotDone();
+  }
+
+  if (resp.has_replication_error()) {
+    return IsOperationDoneResult::Done(StatusFromPB(resp.replication_error()));
+  }
+
+  return IsOperationDoneResult::Done();
+}
+
 Status XClusterClient::RepairOutboundXClusterReplicationGroupAddTable(
     const xcluster::ReplicationGroupId& replication_group_id, const TableId& table_id,
     const xrepl::StreamId& stream_id) {
-  SCHECK(!replication_group_id.empty(), InvalidArgument, "Replication group id is empty");
-  SCHECK(!table_id.empty(), InvalidArgument, "Table id is empty");
-  SCHECK(!stream_id.IsNil(), InvalidArgument, "Stream id is empty");
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication Group Id");
+  SCHECK(!table_id.empty(), InvalidArgument, "Invalid Table Id");
+  SCHECK(!stream_id.IsNil(), InvalidArgument, "Invalid Stream Id");
 
   master::RepairOutboundXClusterReplicationGroupAddTableRequestPB req;
   req.set_replication_group_id(replication_group_id.ToString());
@@ -170,8 +319,8 @@ Status XClusterClient::RepairOutboundXClusterReplicationGroupAddTable(
 
 Status XClusterClient::RepairOutboundXClusterReplicationGroupRemoveTable(
     const xcluster::ReplicationGroupId& replication_group_id, const TableId& table_id) {
-  SCHECK(!replication_group_id.empty(), InvalidArgument, "Replication group id is empty");
-  SCHECK(!table_id.empty(), InvalidArgument, "Table id is empty");
+  SCHECK(!replication_group_id.empty(), InvalidArgument, "Invalid Replication group Id");
+  SCHECK(!table_id.empty(), InvalidArgument, "Invalid Table Id");
 
   master::RepairOutboundXClusterReplicationGroupRemoveTableRequestPB req;
   req.set_replication_group_id(replication_group_id.ToString());
@@ -217,10 +366,16 @@ Status XClusterRemoteClient::Init(
                                  .add_master_server_addr(master_addrs)
                                  .default_admin_operation_timeout(timeout_)
                                  .Build(messenger_.get()));
+  xcluster_client_ = std::make_unique<XClusterClient>(*yb_client_);
 
   return Status::OK();
 }
 
+XClusterClient* XClusterRemoteClient::GetXClusterClient() {
+  CHECK_NOTNULL(xcluster_client_);
+  return xcluster_client_.get();
+}
+
 template <typename ResponsePB, typename RequestPB, typename Method>
 Result<ResponsePB> XClusterRemoteClient::SyncLeaderMasterRpc(
     const RequestPB& req, const char* method_name, const Method& method) {
@@ -256,11 +411,11 @@ Result<UniverseUuid> XClusterRemoteClient::SetupDbScopedUniverseReplication(
   SCHECK_EQ(
       namespace_names.size(), source_namespace_ids.size(), InvalidArgument,
       "Namespace names and IDs count must match");
-  for (const auto& namespace_name : namespace_names) {
-    req.add_namespace_names(namespace_name);
-  }
-  for (const auto& namespace_id : source_namespace_ids) {
-    req.add_producer_namespace_ids(namespace_id);
+  for (size_t i = 0; i < namespace_names.size(); i++) {
+    auto* namespace_id = req.add_producer_namespaces();
+    namespace_id->set_id(source_namespace_ids[i]);
+    namespace_id->set_name(namespace_names[i]);
+    namespace_id->set_database_type(YQLDatabase::YQL_DATABASE_PGSQL);
   }
 
   auto resp = CALL_SYNC_LEADER_MASTER_RPC(SetupUniverseReplication, req);
@@ -339,4 +494,41 @@ Status XClusterRemoteClient::GetXClusterTableCheckpointInfos(
 
   return Status::OK();
 }
+
+Status XClusterRemoteClient::AddNamespaceToDbScopedUniverseReplication(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const UniverseUuid& target_universe_uuid, const NamespaceName& namespace_name,
+    const NamespaceId& source_namespace_id, const std::vector<TableId>& source_table_ids,
+    const std::vector<xrepl::StreamId>& bootstrap_ids) {
+  master::AlterUniverseReplicationRequestPB req;
+  req.set_replication_group_id(replication_group_id.ToString());
+  req.set_universe_uuid(target_universe_uuid.ToString());
+
+  master::NamespaceIdentifierPB namespace_info;
+  namespace_info.set_id(source_namespace_id);
+  namespace_info.set_name(namespace_name);
+  namespace_info.set_database_type(YQLDatabase::YQL_DATABASE_PGSQL);
+  req.mutable_producer_namespace_to_add()->Swap(&namespace_info);
+
+  req.mutable_producer_table_ids_to_add()->Reserve(narrow_cast<int>(source_table_ids.size()));
+  for (const auto& table_id : source_table_ids) {
+    req.add_producer_table_ids_to_add(table_id);
+  }
+
+  for (const auto& bootstrap_id : bootstrap_ids) {
+    req.add_producer_bootstrap_ids_to_add(bootstrap_id.ToString());
+  }
+
+  auto resp = CALL_SYNC_LEADER_MASTER_RPC(AlterUniverseReplication, req);
+
+  if (resp.has_error()) {
+    auto status = StatusFromPB(resp.error().status());
+    if (!status.ok() && !status.IsAlreadyPresent()) {
+      return status;
+    }
+  }
+
+  return Status::OK();
+}
+
 }  // namespace yb::client
diff --git a/src/yb/client/xcluster_client.h b/src/yb/client/xcluster_client.h
index f11d1c6c84..629bbc2504 100644
--- a/src/yb/client/xcluster_client.h
+++ b/src/yb/client/xcluster_client.h
@@ -49,14 +49,33 @@ using GetXClusterStreamsCallback =
 using IsXClusterBootstrapRequiredCallback = std::function<void(Result<bool>)>;
 
 // A wrapper over YBClient to handle xCluster related RPCs.
-// This class performs serialization of C++ objects to PBs and vice versa. Which enables us to limit
-// the scope of xCluster specific types.
+// This class performs serialization of C++ objects to PBs and vice versa.
 class XClusterClient {
  public:
   explicit XClusterClient(client::YBClient& yb_client);
   virtual ~XClusterClient() = default;
 
-  virtual Status CreateXClusterReplication(
+  // Starts the creation of the outbound replication group on the source. IsBootstrapRequired or
+  // GetXClusterStreams must be called on each namespace in order to wait for the operation to
+  // complete.
+  Status CreateOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::vector<NamespaceId>& namespace_ids);
+
+  Status IsBootstrapRequired(
+      CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
+      const NamespaceId& namespace_id, IsXClusterBootstrapRequiredCallback callback);
+
+  // Count of table_names and pg_schema_names must match. If no table_names are provided then all
+  // tables of the namespace are returned.
+  Status GetXClusterStreams(
+      CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
+      const NamespaceId& namespace_id, const std::vector<TableName>& table_names,
+      const std::vector<PgSchemaName>& pg_schema_names, GetXClusterStreamsCallback callback);
+
+  // Starts the creation of Db scoped inbound replication group from a outbound replication group.
+  // IsCreateXClusterReplicationDone must be called in order to wait for the operation to complete.
+  virtual Status CreateXClusterReplicationFromCheckpoint(
       const xcluster::ReplicationGroupId& replication_group_id,
       const std::string& target_master_addresses);
 
@@ -64,21 +83,42 @@ class XClusterClient {
       const xcluster::ReplicationGroupId& replication_group_id,
       const std::string& target_master_addresses);
 
-  Result<std::vector<NamespaceId>> XClusterCreateOutboundReplicationGroup(
+  // target_master_addresses is optional. If set the Inbound replication group on the target will be
+  // deleted. If not set the target has to be separately deled with DeleteUniverseReplication.
+  Status DeleteOutboundReplicationGroup(
       const xcluster::ReplicationGroupId& replication_group_id,
-      const std::vector<NamespaceName>& namespace_names);
+      const std::string& target_master_addresses);
 
-  Status IsXClusterBootstrapRequired(
-      CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
-      const NamespaceId& namespace_id, IsXClusterBootstrapRequiredCallback callback);
+  Status DeleteUniverseReplication(
+      const xcluster::ReplicationGroupId& replication_group_id, bool ignore_errors,
+      const UniverseUuid& target_universe_uuid);
 
-  Status XClusterDeleteOutboundReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id);
+  // Starts the checkpointing of the given namespace. IsBootstrapRequired or
+  // GetXClusterStreams must be called on each namespace in order to wait for the operation to
+  // complete.
+  Status AddNamespaceToOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id);
 
-  Status GetXClusterStreams(
-      CoarseTimePoint deadline, const xcluster::ReplicationGroupId& replication_group_id,
-      const NamespaceId& namespace_id, const std::vector<TableName>& table_names,
-      const std::vector<PgSchemaName>& pg_schema_names, GetXClusterStreamsCallback callback);
+  // Starts the addition of namespace to inbound replication group.
+  // IsAlterXClusterReplicationDone must be called in order to wait for the operation to complete.
+  Status AddNamespaceToXClusterReplication(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::string& target_master_addresses, const NamespaceId& source_namespace_id);
+
+  Result<IsOperationDoneResult> IsAlterXClusterReplicationDone(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::string& target_master_addresses);
+
+  // target_master_addresses is optional. If set the Inbound replication group on the target will be
+  // deleted. If not set the target has to be separately deled with
+  // RemoveNamespaceFromUniverseReplication.
+  Status RemoveNamespaceFromOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
+      const std::string& target_master_addresses);
+
+  Status RemoveNamespaceFromUniverseReplication(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const NamespaceId& source_namespace_id, const UniverseUuid& target_universe_uuid);
 
   Status RepairOutboundXClusterReplicationGroupAddTable(
       const xcluster::ReplicationGroupId& replication_group_id, const TableId& table_id,
@@ -106,7 +146,9 @@ class XClusterRemoteClient {
       const xcluster::ReplicationGroupId& replication_group_id,
       const std::vector<HostPort>& remote_masters);
 
-  YB_STRONGLY_TYPED_BOOL(Transactional);
+  XClusterClient* operator->() {return GetXClusterClient();}
+  XClusterClient* GetXClusterClient();
+
   // This requires flag enable_xcluster_api_v2 to be set.
   virtual Result<UniverseUuid> SetupDbScopedUniverseReplication(
       const xcluster::ReplicationGroupId& replication_group_id,
@@ -124,6 +166,12 @@ class XClusterRemoteClient {
       const std::vector<TableName>& table_names, const std::vector<PgSchemaName>& pg_schema_names,
       BootstrapProducerCallback user_callback);
 
+  virtual Status AddNamespaceToDbScopedUniverseReplication(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const UniverseUuid& target_universe_uuid, const NamespaceName& namespace_name,
+      const NamespaceId& source_namespace_id, const std::vector<TableId>& source_table_ids,
+      const std::vector<xrepl::StreamId>& bootstrap_ids);
+
  private:
   template <typename ResponsePB, typename RequestPB, typename Method>
   Result<ResponsePB> SyncLeaderMasterRpc(
@@ -135,6 +183,7 @@ class XClusterRemoteClient {
   std::unique_ptr<rpc::Messenger> messenger_;
 
   std::unique_ptr<client::YBClient> yb_client_;
+  std::unique_ptr<client::XClusterClient> xcluster_client_;
 };
 
 }  // namespace client
diff --git a/src/yb/integration-tests/xcluster/xcluster-test.cc b/src/yb/integration-tests/xcluster/xcluster-test.cc
index 02928fab34..2ac2b7b193 100644
--- a/src/yb/integration-tests/xcluster/xcluster-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster-test.cc
@@ -3897,4 +3897,60 @@ TEST_F_EX(XClusterTest, DeleteWithoutStreamCleanup, XClusterTestNoParam) {
   ASSERT_OK(VerifyNumCDCStreams(producer_client(), producer_cluster(), /* num_streams = */ 0));
 }
 
+TEST_F_EX(XClusterTest, DeleteWhenSourceIsDown, XClusterTestNoParam) {
+  SetAtomicFlag(true, &FLAGS_xcluster_wait_on_ddl_alter);
+
+  // Create 2 tables with 3 tablets each.
+  ASSERT_OK(SetUpWithParams({3, 3}, /*replication_factor=*/3));
+  ASSERT_OK(SetupReplication());
+
+  master::ListCDCStreamsRequestPB list_streams_req;
+  master::ListCDCStreamsResponsePB list_streams_resp;
+  auto master_proxy = std::make_shared<master::MasterReplicationProxy>(
+      &producer_client()->proxy_cache(),
+      ASSERT_RESULT(producer_cluster()->GetLeaderMiniMaster())->bound_rpc_addr());
+  {
+    rpc::RpcController rpc;
+    rpc.set_timeout(MonoDelta::FromSeconds(kRpcTimeout));
+    ASSERT_OK(master_proxy->ListCDCStreams(list_streams_req, &list_streams_resp, &rpc));
+  }
+  ASSERT_EQ(list_streams_resp.streams_size(), 2);
+
+  producer_cluster()->StopSync();
+
+  {
+    auto consumer_master_proxy = std::make_shared<master::MasterReplicationProxy>(
+        &consumer_client()->proxy_cache(),
+        ASSERT_RESULT(consumer_cluster()->GetLeaderMiniMaster())->bound_rpc_addr());
+    rpc::RpcController rpc;
+    rpc.set_timeout(MonoDelta::FromSeconds(2 * kRpcTimeout));
+    master::DeleteUniverseReplicationRequestPB delete_req;
+    master::DeleteUniverseReplicationResponsePB delete_resp;
+    delete_req.set_ignore_errors(true);
+    delete_req.set_replication_group_id(kReplicationGroupId.ToString());
+
+    ASSERT_OK(consumer_master_proxy->DeleteUniverseReplication(delete_req, &delete_resp, &rpc));
+    ASSERT_FALSE(delete_resp.has_error()) << delete_resp.DebugString();
+  }
+
+  ASSERT_OK(VerifyUniverseReplicationDeleted(
+      consumer_cluster(), consumer_client(), kReplicationGroupId, kRpcTimeout));
+  ASSERT_OK(CorrectlyPollingAllTablets(0));
+
+  ASSERT_OK(producer_cluster()->StartSync());
+
+  master::DeleteCDCStreamRequestPB delete_cdc_stream_req;
+  master::DeleteCDCStreamResponsePB delete_cdc_stream_resp;
+  for (const auto& stream : list_streams_resp.streams()) {
+    delete_cdc_stream_req.add_stream_id(stream.stream_id());
+  }
+  delete_cdc_stream_req.set_force_delete(true);
+
+  {
+    rpc::RpcController rpc;
+    rpc.set_timeout(MonoDelta::FromSeconds(kRpcTimeout));
+    ASSERT_OK(master_proxy->DeleteCDCStream(delete_cdc_stream_req, &delete_cdc_stream_resp, &rpc));
+  }
+}
+
 }  // namespace yb
diff --git a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
index 0974ca2756..e97a1deb9f 100644
--- a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
@@ -15,6 +15,8 @@
 #include "yb/client/xcluster_client.h"
 #include "yb/client/yb_table_name.h"
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
+#include "yb/master/catalog_manager.h"
+#include "yb/master/mini_master.h"
 #include "yb/util/backoff_waiter.h"
 
 DECLARE_bool(enable_xcluster_api_v2);
@@ -76,14 +78,28 @@ TEST_F(XClusterDBScopedTest, TestCreateWithCheckpoint) {
   ASSERT_OK(InsertRowsInProducer(0, 50));
 
   ASSERT_NOK(CreateReplicationFromCheckpoint("bad-master-addr"));
+  ASSERT_OK(ClearFailedUniverse(consumer_cluster_));
 
   ASSERT_NOK_STR_CONTAINS(
       CreateReplicationFromCheckpoint(), "Could not find matching table for yugabyte.test_table_0");
+  ASSERT_OK(ClearFailedUniverse(consumer_cluster_));
 
   auto consumer_table_name = ASSERT_RESULT(CreateYsqlTable(
       /*idx=*/0, /*num_tablets=*/3, &consumer_cluster_));
   ASSERT_OK(producer_client()->OpenTable(consumer_table_name, &consumer_table_));
 
+  auto consumer_extra_table_name = ASSERT_RESULT(CreateYsqlTable(
+      /*idx=*/1, /*num_tablets=*/3, &consumer_cluster_));
+
+  ASSERT_NOK_STR_CONTAINS(
+      CreateReplicationFromCheckpoint(),
+      "has additional tables that were not added to xCluster DB Scoped replication group");
+  ASSERT_OK(ClearFailedUniverse(consumer_cluster_));
+
+  ASSERT_OK(DropYsqlTable(
+      &consumer_cluster_, consumer_extra_table_name.namespace_name(),
+      consumer_extra_table_name.pgschema_name(), consumer_extra_table_name.table_name()));
+
   ASSERT_OK(CreateReplicationFromCheckpoint());
 
   // Verify that universe was setup on consumer.
@@ -235,6 +251,7 @@ TEST_F(XClusterDBScopedTest, ColocatedDB) {
   ASSERT_NOK_STR_CONTAINS(
       CreateReplicationFromCheckpoint(),
       "Could not find matching table for colocated_db.test_table_1");
+  ASSERT_OK(ClearFailedUniverse(consumer_cluster_));
 
   auto consumer_colocated_table_name = ASSERT_RESULT(CreateYsqlTable(
       /*idx=*/1, /*num_tablets=*/3, &consumer_cluster_,
@@ -357,4 +374,407 @@ TEST_F(XClusterDBScopedTest, DisableAutoTableProcessing) {
   ASSERT_OK(VerifyWrittenRecords(producer_table3, consumer_table3));
 }
 
+class XClusterDBScopedTestWithTwoDBs : public XClusterDBScopedTest {
+ public:
+  Status SetUpClusters() {
+    RETURN_NOT_OK(XClusterYsqlTestBase::SetUpClusters());
+
+    RETURN_NOT_OK(RunOnBothClusters([this](Cluster* cluster) -> Status {
+      RETURN_NOT_OK(CreateDatabase(cluster, namespace_name2_));
+      auto table_name = VERIFY_RESULT(CreateYsqlTable(
+          cluster, namespace_name2_, "" /* schema_name */, namespace2_table_name_,
+          /*tablegroup_name=*/boost::none, /*num_tablets=*/3));
+
+      std::shared_ptr<client::YBTable> table;
+      RETURN_NOT_OK(cluster->client_->OpenTable(table_name, &table));
+      cluster->tables_.emplace_back(std::move(table));
+
+      return Status::OK();
+    }));
+
+    source_namespace2_table_ = producer_tables_.back();
+    target_namespace2_table_ = consumer_tables_.back();
+    source_namespace2_id_ = VERIFY_RESULT(GetNamespaceId(producer_client(), namespace_name2_));
+    target_namespace2_id_ = VERIFY_RESULT(GetNamespaceId(consumer_client(), namespace_name2_));
+
+    return Status::OK();
+  }
+
+  const NamespaceName namespace_name2_ = "db2";
+  const TableName namespace2_table_name_ = "test_table";
+  NamespaceId source_namespace2_id_, target_namespace2_id_;
+  std::shared_ptr<client::YBTable> source_namespace2_table_, target_namespace2_table_;
+};
+
+// Testing adding and removing namespaces to replication.
+TEST_F_EX(XClusterDBScopedTest, AddRemoveNamespace, XClusterDBScopedTestWithTwoDBs) {
+  ASSERT_OK(SetUpClusters());
+  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+
+  auto source_xcluster_client = client::XClusterClient(*producer_client());
+
+  // Add the namespace to the source replication group.
+  ASSERT_OK(source_xcluster_client.AddNamespaceToOutboundReplicationGroup(
+      kReplicationGroupId, source_namespace2_id_));
+
+  auto bootstrap_required =
+      ASSERT_RESULT(IsXClusterBootstrapRequired(kReplicationGroupId, source_namespace2_id_));
+  ASSERT_FALSE(bootstrap_required);
+
+  // Validate streams on source.
+  auto streams = ASSERT_RESULT(GetAllXClusterStreams(source_namespace2_id_));
+  ASSERT_EQ(streams.table_infos_size(), 1);
+  ASSERT_EQ(streams.table_infos(0).table_name(), namespace2_table_name_);
+  ASSERT_EQ(streams.table_infos(0).table_id(), source_namespace2_table_->id());
+
+  // Add the namespace to the target.
+  ASSERT_OK(AddNamespaceToXClusterReplication(source_namespace2_id_, target_namespace2_id_));
+
+  // Validate streams on target.
+  master::GetUniverseReplicationResponsePB resp;
+  ASSERT_OK(VerifyUniverseReplication(&resp));
+  ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
+  ASSERT_EQ(resp.entry().tables_size(), 2);
+
+  auto replication_info = ASSERT_RESULT(consumer_cluster()->GetLeaderMiniMaster())
+                              ->catalog_manager_impl()
+                              .GetUniverseReplication(kReplicationGroupId);
+  ASSERT_TRUE(replication_info);
+  ASSERT_TRUE(replication_info->IsDbScoped());
+  ASSERT_EQ(replication_info->LockForRead()->pb.db_scoped_info().namespace_infos_size(), 2);
+
+  ASSERT_OK(InsertRowsInProducer(0, 100, source_namespace2_table_));
+  ASSERT_OK(VerifyWrittenRecords(source_namespace2_table_, target_namespace2_table_));
+
+  // Remove the namespace from both sides.
+  const auto target_master_address = consumer_cluster()->GetMasterAddresses();
+  ASSERT_OK(source_xcluster_client.RemoveNamespaceFromOutboundReplicationGroup(
+      kReplicationGroupId, source_namespace2_id_, target_master_address));
+
+  // Check the target side.
+  ASSERT_OK(VerifyUniverseReplication(&resp));
+  ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
+  ASSERT_EQ(resp.entry().tables_size(), 1);
+  // Only the first table should be left.
+  ASSERT_EQ(resp.entry().tables(0), producer_table_->id());
+
+  replication_info = ASSERT_RESULT(consumer_cluster()->GetLeaderMiniMaster())
+                         ->catalog_manager_impl()
+                         .GetUniverseReplication(kReplicationGroupId);
+  ASSERT_TRUE(replication_info);
+  ASSERT_EQ(replication_info->LockForRead()->pb.db_scoped_info().namespace_infos_size(), 1);
+
+  // Check the source side.
+  auto streams_result = GetAllXClusterStreams(source_namespace2_id_);
+  ASSERT_NOK_STR_CONTAINS(streams_result, "Not found");
+
+  // Checkpoint the namespace again and make sure it now requires bootstrap.
+  ASSERT_OK(source_xcluster_client.AddNamespaceToOutboundReplicationGroup(
+      kReplicationGroupId, source_namespace2_id_));
+
+  bootstrap_required =
+      ASSERT_RESULT(IsXClusterBootstrapRequired(kReplicationGroupId, source_namespace2_id_));
+  ASSERT_TRUE(bootstrap_required) << "Bootstrap should be required";
+}
+
+// Remove a namespaces from replication when the target side is down.
+TEST_F_EX(XClusterDBScopedTest, RemoveNamespaceWhenTargetIsDown, XClusterDBScopedTestWithTwoDBs) {
+  // Setup replication with both databases.
+  ASSERT_OK(SetUpClusters());
+  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+  auto source_xcluster_client = client::XClusterClient(*producer_client());
+  ASSERT_OK(source_xcluster_client.AddNamespaceToOutboundReplicationGroup(
+      kReplicationGroupId, source_namespace2_id_));
+  ASSERT_OK(IsXClusterBootstrapRequired(kReplicationGroupId, source_namespace2_id_));
+  ASSERT_OK(AddNamespaceToXClusterReplication(source_namespace2_id_, target_namespace2_id_));
+
+  ASSERT_OK(InsertRowsInProducer(0, 100, source_namespace2_table_));
+  ASSERT_OK(VerifyWrittenRecords(source_namespace2_table_, target_namespace2_table_));
+
+  // Take down the target.
+  consumer_cluster()->StopSync();
+
+  // Remove the namespace from source side.
+  ASSERT_OK(source_xcluster_client.RemoveNamespaceFromOutboundReplicationGroup(
+      kReplicationGroupId, source_namespace2_id_, /*target_master_addresses=*/""));
+
+  ASSERT_NOK_STR_CONTAINS(GetAllXClusterStreams(source_namespace2_id_), "Not found");
+
+  // Bring the target back up.
+  {
+    TEST_SetThreadPrefixScoped prefix_se("C");
+    ASSERT_OK(consumer_cluster()->StartSync());
+  }
+
+  // It should still have both namespaces.
+  master::GetUniverseReplicationResponsePB resp;
+  ASSERT_OK(VerifyUniverseReplication(&resp));
+  ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
+  ASSERT_EQ(resp.entry().tables_size(), 2);
+
+  auto target_xcluster_client = client::XClusterClient(*consumer_client());
+
+  // Make sure universe uuid is checked.
+  ASSERT_NOK_STR_CONTAINS(
+      target_xcluster_client.RemoveNamespaceFromUniverseReplication(
+          kReplicationGroupId, source_namespace2_id_, UniverseUuid::GenerateRandom()),
+      "Invalid Universe UUID");
+
+  ASSERT_OK(target_xcluster_client.RemoveNamespaceFromUniverseReplication(
+      kReplicationGroupId, source_namespace2_id_, UniverseUuid::Nil()));
+  ASSERT_OK(VerifyUniverseReplication(&resp));
+  ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
+  ASSERT_EQ(resp.entry().tables_size(), 1);
+  ASSERT_EQ(resp.entry().tables(0), producer_table_->id());
+}
+
+// Remove a namespaces from replication when the source side is down.
+TEST_F_EX(XClusterDBScopedTest, RemoveNamespaceWhenSourceIsDown, XClusterDBScopedTestWithTwoDBs) {
+  ASSERT_OK(SetUpClusters());
+  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+  auto source_xcluster_client = client::XClusterClient(*producer_client());
+  ASSERT_OK(source_xcluster_client.AddNamespaceToOutboundReplicationGroup(
+      kReplicationGroupId, source_namespace2_id_));
+  ASSERT_OK(IsXClusterBootstrapRequired(kReplicationGroupId, source_namespace2_id_));
+  ASSERT_OK(AddNamespaceToXClusterReplication(source_namespace2_id_, target_namespace2_id_));
+
+  ASSERT_OK(InsertRowsInProducer(0, 100, source_namespace2_table_));
+  ASSERT_OK(VerifyWrittenRecords(source_namespace2_table_, target_namespace2_table_));
+
+  // Take down the source.
+  producer_cluster()->StopSync();
+
+  // Remove replication from target and verify.
+  auto target_xcluster_client = client::XClusterClient(*consumer_client());
+  ASSERT_OK(target_xcluster_client.RemoveNamespaceFromUniverseReplication(
+      kReplicationGroupId, source_namespace2_id_, UniverseUuid::Nil()));
+
+  master::GetUniverseReplicationResponsePB resp;
+  ASSERT_OK(VerifyUniverseReplication(&resp));
+  ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
+  ASSERT_EQ(resp.entry().tables_size(), 1);
+  ASSERT_EQ(resp.entry().tables(0), producer_table_->id());
+
+  // Bring the source back up.
+  {
+    TEST_SetThreadPrefixScoped prefix_se("P");
+    ASSERT_OK(producer_cluster()->StartSync());
+  }
+
+  // Source should still have the namespace and stream.
+  auto streams = ASSERT_RESULT(GetAllXClusterStreams(source_namespace2_id_));
+  ASSERT_EQ(streams.table_infos_size(), 1);
+
+  // Remove the namespace from source side.
+  ASSERT_OK(source_xcluster_client.RemoveNamespaceFromOutboundReplicationGroup(
+      kReplicationGroupId, source_namespace2_id_, /*target_master_addresses=*/""));
+
+  ASSERT_NOK_STR_CONTAINS(GetAllXClusterStreams(source_namespace2_id_), "Not found");
+}
+
+// Delete replication from both sides using one command.
+TEST_F(XClusterDBScopedTest, Delete) {
+  ASSERT_OK(SetUpClusters());
+  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+
+  // Insert some rows to the initial table.
+  ASSERT_OK(InsertRowsInProducer(0, 10));
+  ASSERT_OK(VerifyWrittenRecords());
+
+  // Delete from both sides.
+  auto source_xcluster_client = client::XClusterClient(*producer_client());
+  const auto target_master_address = consumer_cluster()->GetMasterAddresses();
+  ASSERT_OK(source_xcluster_client.DeleteOutboundReplicationGroup(
+      kReplicationGroupId, target_master_address));
+
+  auto source_namespace_id = ASSERT_RESULT(GetNamespaceId(producer_client()));
+
+  // Running the same command again should fail.
+  ASSERT_NOK_STR_CONTAINS(GetAllXClusterStreams(source_namespace_id), "Not found");
+
+  master::GetUniverseReplicationResponsePB resp;
+  ASSERT_NOK_STR_CONTAINS(
+      VerifyUniverseReplication(&resp), "Could not find xCluster replication group");
+
+  auto replication_info = ASSERT_RESULT(consumer_cluster()->GetLeaderMiniMaster())
+                              ->catalog_manager_impl()
+                              .GetUniverseReplication(kReplicationGroupId);
+  ASSERT_FALSE(replication_info);
+}
+
+// Delete replication when the target side is down.
+TEST_F(XClusterDBScopedTest, DeleteWhenTargetIsDown) {
+  ASSERT_OK(SetUpClusters());
+  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+
+  // Insert some rows to the initial table.
+  ASSERT_OK(InsertRowsInProducer(0, 10));
+  ASSERT_OK(VerifyWrittenRecords());
+
+  // Take down the target.
+  consumer_cluster()->StopSync();
+
+  // Delete only from source.
+  auto source_xcluster_client = client::XClusterClient(*producer_client());
+  ASSERT_OK(source_xcluster_client.DeleteOutboundReplicationGroup(
+      kReplicationGroupId, /*target_master_addresses=*/""));
+
+  auto source_namespace_id = ASSERT_RESULT(GetNamespaceId(producer_client()));
+  ASSERT_NOK_STR_CONTAINS(GetAllXClusterStreams(source_namespace_id), "Not found");
+
+  // Bring the target back up.
+  {
+    TEST_SetThreadPrefixScoped prefix_se("C");
+    ASSERT_OK(consumer_cluster()->StartSync());
+  }
+
+  // Target should still have the replication group.
+  master::GetUniverseReplicationResponsePB resp;
+  ASSERT_OK(VerifyUniverseReplication(&resp));
+  ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
+  ASSERT_EQ(resp.entry().tables_size(), 1);
+
+  auto target_xcluster_client = client::XClusterClient(*consumer_client());
+
+  // Make sure the universe uuid is checked.
+  ASSERT_NOK_STR_CONTAINS(
+      target_xcluster_client.DeleteUniverseReplication(
+          kReplicationGroupId, /*ignore_errors=*/true, UniverseUuid::GenerateRandom()),
+      "Invalid Universe UUID");
+
+  // Delete from the target.
+  ASSERT_OK(target_xcluster_client.DeleteUniverseReplication(
+      kReplicationGroupId, /*ignore_errors=*/true, /*target_universe_uuid=*/UniverseUuid::Nil()));
+
+  ASSERT_NOK_STR_CONTAINS(
+      VerifyUniverseReplication(&resp), "Could not find xCluster replication group");
+}
+
+// Delete replication when the source side is down.
+TEST_F(XClusterDBScopedTest, DeleteWhenSourceIsDown) {
+  ASSERT_OK(SetUpClusters());
+  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+
+  // Insert some rows to the initial table.
+  ASSERT_OK(InsertRowsInProducer(0, 10));
+  ASSERT_OK(VerifyWrittenRecords());
+
+  // Take down the source.
+  producer_cluster()->StopSync();
+
+  // Delete from the target.
+  auto target_xcluster_client = client::XClusterClient(*consumer_client());
+  ASSERT_OK(target_xcluster_client.DeleteUniverseReplication(
+      kReplicationGroupId, /*ignore_errors=*/true, /*target_universe_uuid=*/UniverseUuid::Nil()));
+
+  master::GetUniverseReplicationResponsePB resp;
+  ASSERT_NOK_STR_CONTAINS(
+      VerifyUniverseReplication(&resp), "Could not find xCluster replication group");
+
+  // Bring the source back up.
+  {
+    TEST_SetThreadPrefixScoped prefix_se("P");
+    ASSERT_OK(producer_cluster()->StartSync());
+  }
+
+  auto source_namespace_id = ASSERT_RESULT(GetNamespaceId(producer_client()));
+  // Source should still have the replication group and streams.
+  auto streams = ASSERT_RESULT(GetAllXClusterStreams(source_namespace_id));
+  ASSERT_EQ(streams.table_infos_size(), 1);
+
+  auto source_xcluster_client = client::XClusterClient(*producer_client());
+
+  // Delete from the source.
+  ASSERT_OK(source_xcluster_client.DeleteOutboundReplicationGroup(
+      kReplicationGroupId, /*target_master_addresses=*/""));
+
+  ASSERT_NOK_STR_CONTAINS(GetAllXClusterStreams(source_namespace_id), "Not found");
+}
+
+// Validate that we can only have one inbound replication group per database.
+TEST_F(XClusterDBScopedTest, MultipleInboundReplications) {
+  ASSERT_OK(SetUpClusters());
+  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+
+  auto group2 = xcluster::ReplicationGroupId("group2");
+
+  ASSERT_OK(CheckpointReplicationGroup(group2));
+  ASSERT_NOK_STR_CONTAINS(
+      CreateReplicationFromCheckpoint(/*target_master_addresses=*/"", group2),
+      "already included in replication group");
+}
+
+TEST_F_EX(XClusterDBScopedTest, TestYbAdmin, XClusterDBScopedTestWithTwoDBs) {
+  ASSERT_OK(SetUpClusters());
+
+  // Create replication with 1 db.
+  auto result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "create_xcluster_checkpoint", kReplicationGroupId, namespace_name));
+  ASSERT_STR_CONTAINS(result, "Bootstrap is not required");
+
+  result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "is_xcluster_bootstrap_required", kReplicationGroupId, namespace_name));
+  ASSERT_STR_CONTAINS(result, "Bootstrap is not required");
+
+  const auto target_master_address = consumer_cluster()->GetMasterAddresses();
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "setup_xcluster_replication", kReplicationGroupId,
+      target_master_address));
+  ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
+
+  ASSERT_OK(InsertRowsInProducer(0, 10));
+  ASSERT_OK(VerifyWrittenRecords());
+
+  // Add second db to replication.
+  result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "add_namespace_to_xcluster_checkpoint", kReplicationGroupId,
+      namespace_name2_));
+  ASSERT_STR_CONTAINS(result, "Bootstrap is not required");
+
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "add_namespace_to_xcluster_replication", kReplicationGroupId,
+      namespace_name2_, target_master_address));
+
+  // Remove database from both sides with one command.
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "remove_namespace_from_xcluster_replication", kReplicationGroupId,
+      namespace_name2_, target_master_address));
+
+  // Remove database from replication from each cluster individually.
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "add_namespace_to_xcluster_checkpoint", kReplicationGroupId,
+      namespace_name2_));
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "add_namespace_to_xcluster_replication", kReplicationGroupId,
+      namespace_name2_, target_master_address));
+  ASSERT_OK(CallAdmin(
+      consumer_cluster(), "alter_universe_replication", kReplicationGroupId, "remove_namespace",
+      namespace_name2_));
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "remove_namespace_from_xcluster_replication", kReplicationGroupId,
+      namespace_name2_));
+
+  // Drop replication on both sides.
+  ASSERT_OK(CallAdmin(
+      producer_cluster(), "drop_xcluster_replication", kReplicationGroupId, target_master_address));
+
+  master::GetUniverseReplicationResponsePB resp;
+  ASSERT_NOK_STR_CONTAINS(
+      VerifyUniverseReplication(&resp), "Could not find xCluster replication group");
+
+  const auto source_namespace_id = producer_table_->name().namespace_id();
+  ASSERT_NOK_STR_CONTAINS(GetAllXClusterStreams(source_namespace_id), "Not found");
+
+  result = ASSERT_RESULT(CallAdmin(
+      producer_cluster(), "create_xcluster_checkpoint", kReplicationGroupId, namespace_name));
+  ASSERT_STR_CONTAINS(result, "Bootstrap is required");
+}
+
 }  // namespace yb
diff --git a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
index 090b39bc9a..a239a215b5 100644
--- a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
@@ -163,10 +163,7 @@ TEST_F(XClusterOutboundReplicationGroupTest, TestMultipleTable) {
 
   ASSERT_NOK(GetXClusterStreams(kReplicationGroupId, namespace_id_));
 
-  auto out_namespace_id = ASSERT_RESULT(XClusterClient().XClusterCreateOutboundReplicationGroup(
-      kReplicationGroupId, {kNamespaceName}));
-  ASSERT_EQ(out_namespace_id.size(), 1);
-  ASSERT_EQ(out_namespace_id[0], namespace_id_);
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
 
   auto resp = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
 
@@ -198,7 +195,8 @@ TEST_F(XClusterOutboundReplicationGroupTest, TestMultipleTable) {
   ASSERT_OK(VerifyWalRetentionOfTable(table_id_1));
   ASSERT_OK(VerifyWalRetentionOfTable(table_id_2));
 
-  ASSERT_OK(XClusterClient().XClusterDeleteOutboundReplicationGroup(kReplicationGroupId));
+  ASSERT_OK(XClusterClient().DeleteOutboundReplicationGroup(
+      kReplicationGroupId, /*target_master_addresses=*/{}));
   ASSERT_NOK(GetXClusterStreams(kReplicationGroupId, namespace_id_));
 
   // We should have 0 streams now.
@@ -215,10 +213,7 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
   auto ns2_table_id_1 = ASSERT_RESULT(CreateYsqlTable(namespace_name_2, kTableName1));
   auto ns2_table_id_2 = ASSERT_RESULT(CreateYsqlTable(namespace_name_2, kTableName2));
 
-  auto out_namespace_id = ASSERT_RESULT(XClusterClient().XClusterCreateOutboundReplicationGroup(
-      kReplicationGroupId, {kNamespaceName}));
-  ASSERT_EQ(out_namespace_id.size(), 1);
-  ASSERT_EQ(out_namespace_id[0], namespace_id_);
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
 
   // Wait for the new streams to be ready.
   auto ns1_info = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
@@ -238,10 +233,8 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
       VerifyNamespaceCheckpointInfo(ns1_table_id_1, ns1_table_id_2, stream_count, ns1_info));
 
   // Add the second namespace.
-  auto out_namespace_id2 =
-      ASSERT_RESULT(client_->XClusterAddNamespaceToOutboundReplicationGroup(
-          kReplicationGroupId, namespace_name_2));
-  ASSERT_EQ(out_namespace_id2, namespace_id_2);
+  ASSERT_OK(client::XClusterClient(*client_).AddNamespaceToOutboundReplicationGroup(
+      kReplicationGroupId, namespace_id_2));
 
   // We should have 4 streams now.
   stream_count = 4;
@@ -255,8 +248,8 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
   ASSERT_NO_FATALS(
       VerifyNamespaceCheckpointInfo(ns2_table_id_1, ns2_table_id_2, stream_count, ns2_info));
 
-  ASSERT_OK(client_->XClusterRemoveNamespaceFromOutboundReplicationGroup(
-      kReplicationGroupId, namespace_id_));
+  ASSERT_OK(XClusterClient().RemoveNamespaceFromOutboundReplicationGroup(
+      kReplicationGroupId, namespace_id_, /*target_master_addresses=*/{}));
   ASSERT_NOK(GetXClusterStreams(kReplicationGroupId, namespace_id_));
 
   // We should only have only the streams from second namespace.
@@ -270,7 +263,8 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
     }
   }
 
-  ASSERT_OK(XClusterClient().XClusterDeleteOutboundReplicationGroup(kReplicationGroupId));
+  ASSERT_OK(XClusterClient().DeleteOutboundReplicationGroup(
+      kReplicationGroupId, /*target_master_addresses=*/{}));
   ASSERT_NOK(GetXClusterStreams(kReplicationGroupId, namespace_id_));
   auto final_xcluster_streams = CleanupAndGetAllXClusterStreams();
   ASSERT_TRUE(final_xcluster_streams.empty());
@@ -280,8 +274,7 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddTable) {
   auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
   ASSERT_OK(VerifyWalRetentionOfTable(table_id_1, 0));
 
-  ASSERT_OK(XClusterClient().XClusterCreateOutboundReplicationGroup(
-      kReplicationGroupId, {kNamespaceName}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
 
   // Wait for the new streams to be ready.
   ASSERT_OK(GetXClusterStreams(kReplicationGroupId, namespace_id_));
@@ -305,12 +298,11 @@ TEST_F(XClusterOutboundReplicationGroupTest, IsBootstrapRequiredEmptyTable) {
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_max_xcluster_streams_to_checkpoint_in_parallel) = 1;
 
   auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
-  ASSERT_OK(XClusterClient().XClusterCreateOutboundReplicationGroup(
-      kReplicationGroupId, {kNamespaceName}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
 
   std::promise<Result<bool>> promise;
 
-  ASSERT_OK(XClusterClient().IsXClusterBootstrapRequired(
+  ASSERT_OK(XClusterClient().IsBootstrapRequired(
       CoarseMonoClock::Now() + kDeadline, kReplicationGroupId, namespace_id_,
       [&promise](Result<bool> result) { promise.set_value(std::move(result)); }));
 
@@ -327,12 +319,11 @@ TEST_F(XClusterOutboundReplicationGroupTest, IsBootstrapRequiredTableWithData) {
   ASSERT_OK(producer_client()->OpenTable(table_id_2, &table_2));
   ASSERT_OK(InsertRowsInProducer(0, 10, table_2));
 
-  ASSERT_OK(XClusterClient().XClusterCreateOutboundReplicationGroup(
-      kReplicationGroupId, {kNamespaceName}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
 
   std::promise<Result<bool>> promise;
 
-  ASSERT_OK(XClusterClient().IsXClusterBootstrapRequired(
+  ASSERT_OK(XClusterClient().IsBootstrapRequired(
       CoarseMonoClock::Now() + kDeadline, kReplicationGroupId, namespace_id_,
       [&promise](Result<bool> result) { promise.set_value(std::move(result)); }));
 
@@ -350,12 +341,11 @@ TEST_F(XClusterOutboundReplicationGroupTest, IsBootstrapRequiredTableWithDeleted
   ASSERT_OK(InsertRowsInProducer(0, 10, table_2));
   ASSERT_OK(DeleteRowsInProducer(0, 10, table_2));
 
-  ASSERT_OK(XClusterClient().XClusterCreateOutboundReplicationGroup(
-      kReplicationGroupId, {kNamespaceName}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
 
   std::promise<Result<bool>> promise;
 
-  ASSERT_OK(XClusterClient().IsXClusterBootstrapRequired(
+  ASSERT_OK(XClusterClient().IsBootstrapRequired(
       CoarseMonoClock::Now() + kDeadline, kReplicationGroupId, namespace_id_,
       [&promise](Result<bool> result) { promise.set_value(std::move(result)); }));
 
@@ -370,8 +360,7 @@ TEST_F(XClusterOutboundReplicationGroupTest, MasterRestartDuringCheckpoint) {
 
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_block_xcluster_checkpoint_namespace_task) = true;
 
-  ASSERT_OK(XClusterClient().XClusterCreateOutboundReplicationGroup(
-      kReplicationGroupId, {kNamespaceName}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
 
   std::promise<Result<master::GetXClusterStreamsResponsePB>> promise;
   auto future = promise.get_future();
@@ -408,8 +397,7 @@ TEST_F(XClusterOutboundReplicationGroupTest, Repair) {
   auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
   auto table_id_2 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName2));
 
-  ASSERT_OK(XClusterClient().XClusterCreateOutboundReplicationGroup(
-      kReplicationGroupId, {kNamespaceName}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
 
   auto resp = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
   ASSERT_EQ(resp.table_infos_size(), 2);
@@ -491,8 +479,7 @@ TEST_F(XClusterOutboundReplicationGroupTest, RepairWithYbAdmin) {
   auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
   auto table_id_2 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName2));
 
-  ASSERT_OK(XClusterClient().XClusterCreateOutboundReplicationGroup(
-      kReplicationGroupId, {kNamespaceName}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
 
   auto resp = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
   ASSERT_EQ(resp.table_infos_size(), 2);
diff --git a/src/yb/integration-tests/xcluster/xcluster_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_test_base.cc
index 867a9b0a2c..232c72935d 100644
--- a/src/yb/integration-tests/xcluster/xcluster_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_test_base.cc
@@ -29,7 +29,7 @@
 
 #include "yb/integration-tests/cdc_test_util.h"
 #include "yb/integration-tests/mini_cluster.h"
-#include "yb/master/catalog_manager_if.h"
+#include "yb/master/catalog_manager.h"
 #include "yb/master/master.h"
 #include "yb/master/master_ddl.pb.h"
 #include "yb/master/master_ddl.proxy.h"
@@ -601,6 +601,9 @@ Status XClusterTestBase::DeleteUniverseReplication(
   rpc::RpcController rpc;
   rpc.set_timeout(MonoDelta::FromSeconds(kRpcTimeout));
   RETURN_NOT_OK(master_proxy->DeleteUniverseReplication(req, &resp, &rpc));
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
   LOG(INFO) << "Delete universe succeeded";
 
   return Status::OK();
@@ -1048,4 +1051,11 @@ Result<TableId> XClusterTestBase::GetColocatedDatabaseParentTableId() {
 Result<master::MasterReplicationProxy> XClusterTestBase::GetProducerMasterProxy() {
   return GetMasterProxy(producer_cluster_);
 }
+
+Status XClusterTestBase::ClearFailedUniverse(Cluster& cluster) {
+  auto& catalog_manager =
+      VERIFY_RESULT(cluster.mini_cluster_->GetLeaderMiniMaster())->catalog_manager_impl();
+  return catalog_manager.ClearFailedUniverse();
+}
+
 } // namespace yb
diff --git a/src/yb/integration-tests/xcluster/xcluster_test_base.h b/src/yb/integration-tests/xcluster/xcluster_test_base.h
index 3068e8e626..094e37d3cb 100644
--- a/src/yb/integration-tests/xcluster/xcluster_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_test_base.h
@@ -350,6 +350,8 @@ class XClusterTestBase : public YBTest {
 
   Result<master::MasterReplicationProxy> GetProducerMasterProxy();
 
+  Status ClearFailedUniverse(Cluster& cluster);
+
  protected:
   CoarseTimePoint PropagationDeadline() const {
     return CoarseMonoClock::Now() + propagation_timeout_;
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
index 3e1f75b4fb..b24ce26049 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
@@ -838,7 +838,8 @@ Status XClusterYsqlTestBase::SetUpWithParams(
 
 Status XClusterYsqlTestBase::SetUpClusters() {
   static const SetupParams default_params;
-  return SetUpClusters(default_params); }
+  return SetUpClusters(default_params);
+}
 
 Status XClusterYsqlTestBase::SetUpClusters(const SetupParams& params) {
   SCHECK(
@@ -884,25 +885,52 @@ Status XClusterYsqlTestBase::SetUpClusters(const SetupParams& params) {
   return PostSetUp();
 }
 
-Status XClusterYsqlTestBase::CheckpointReplicationGroup() {
+Status XClusterYsqlTestBase::CheckpointReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id) {
   auto producer_namespace_id = VERIFY_RESULT(GetNamespaceId(producer_client()));
-  auto namespace_id_out = VERIFY_RESULT(
-      client::XClusterClient(*producer_client())
-          .XClusterCreateOutboundReplicationGroup(kReplicationGroupId, {namespace_name}));
-  SCHECK_EQ(namespace_id_out.size(), 1, IllegalState, "Namespace count does not match");
-  SCHECK_EQ(namespace_id_out[0], producer_namespace_id, IllegalState, "NamespaceId does not match");
+  RETURN_NOT_OK(client::XClusterClient(*producer_client())
+                    .CreateOutboundReplicationGroup(replication_group_id, {producer_namespace_id}));
+
+  auto bootstrap_required =
+      VERIFY_RESULT(IsXClusterBootstrapRequired(replication_group_id, producer_namespace_id));
+  SCHECK(!bootstrap_required, IllegalState, "Bootstrap should not be required");
 
+  return Status::OK();
+}
+
+Result<bool> XClusterYsqlTestBase::IsXClusterBootstrapRequired(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const NamespaceId& source_namespace_id) {
   std::promise<Result<bool>> promise;
   auto future = promise.get_future();
   RETURN_NOT_OK(client::XClusterClient(*producer_client())
-                    .IsXClusterBootstrapRequired(
+                    .IsBootstrapRequired(
                         CoarseMonoClock::now() + MonoDelta::FromSeconds(kRpcTimeout),
-                        kReplicationGroupId, producer_namespace_id,
+                        replication_group_id, source_namespace_id,
                         [&promise](Result<bool> res) { promise.set_value(res); }));
-  auto bootstrap_required = VERIFY_RESULT(future.get());
-  SCHECK(!bootstrap_required, IllegalState, "Bootstrap should not be required");
+  return future.get();
+}
 
-  return Status::OK();
+Status XClusterYsqlTestBase::AddNamespaceToXClusterReplication(
+    const NamespaceId& source_namespace_id, const NamespaceId& target_namespace_id) {
+  auto source_xcluster_client = client::XClusterClient(*producer_client());
+  auto target_master_address = consumer_cluster()->GetMasterAddresses();
+
+  RETURN_NOT_OK(source_xcluster_client.AddNamespaceToXClusterReplication(
+      kReplicationGroupId, target_master_address, source_namespace_id));
+  RETURN_NOT_OK(LoggedWaitFor(
+      [this, &target_master_address]() -> Result<bool> {
+        auto result = VERIFY_RESULT(
+            client::XClusterClient(*producer_client())
+                .IsAlterXClusterReplicationDone(kReplicationGroupId, target_master_address));
+        if (!result.status().ok()) {
+          return result.status();
+        }
+        return result.done();
+      },
+      MonoDelta::FromSeconds(kRpcTimeout), "IsAlterXClusterReplicationDone"));
+
+  return WaitForValidSafeTimeOnAllTServers(target_namespace_id);
 }
 
 Status XClusterYsqlTestBase::WaitForCreateReplicationToFinish(
@@ -924,8 +952,9 @@ Status XClusterYsqlTestBase::WaitForCreateReplicationToFinish(
 }
 
 Status XClusterYsqlTestBase::CreateReplicationFromCheckpoint(
-    const std::string& target_master_addresses) {
-  RETURN_NOT_OK(SetupCertificates(kReplicationGroupId));
+    const std::string& target_master_addresses,
+    const xcluster::ReplicationGroupId& replication_group_id) {
+  RETURN_NOT_OK(SetupCertificates(replication_group_id));
 
   auto master_addr = target_master_addresses;
   if (master_addr.empty()) {
@@ -933,7 +962,7 @@ Status XClusterYsqlTestBase::CreateReplicationFromCheckpoint(
   }
 
   RETURN_NOT_OK(client::XClusterClient(*producer_client())
-                    .CreateXClusterReplication(kReplicationGroupId, master_addr));
+                    .CreateXClusterReplicationFromCheckpoint(replication_group_id, master_addr));
 
   return WaitForCreateReplicationToFinish(master_addr);
 }
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
index 55697da763..3bfa5521b6 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
@@ -135,8 +135,16 @@ class XClusterYsqlTestBase : public XClusterTestBase {
       uint32_t start, uint32_t end, Cluster* cluster, const client::YBTableName& table,
       bool delete_op = false, bool use_transaction = false);
 
-  Status CheckpointReplicationGroup();
-  Status CreateReplicationFromCheckpoint(const std::string& target_master_addresses = {});
+  Status CheckpointReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId);
+  Result<bool> IsXClusterBootstrapRequired(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const NamespaceId& source_namespace_id);
+  Status AddNamespaceToXClusterReplication(
+      const NamespaceId& source_namespace_id, const NamespaceId& target_namespace_id);
+  Status CreateReplicationFromCheckpoint(
+      const std::string& target_master_addresses = {},
+      const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId);
   Status WaitForCreateReplicationToFinish(const std::string& target_master_addresses);
 
  protected:
diff --git a/src/yb/master/catalog_entity_info.cc b/src/yb/master/catalog_entity_info.cc
index 6848b76cc4..aff6d920b9 100644
--- a/src/yb/master/catalog_entity_info.cc
+++ b/src/yb/master/catalog_entity_info.cc
@@ -41,6 +41,7 @@
 #include "yb/common/schema_pbutil.h"
 #include "yb/common/wire_protocol.h"
 
+#include "yb/master/xcluster/master_xcluster_util.h"
 #include "yb/master/xcluster_rpc_tasks.h"
 #include "yb/master/master_client.pb.h"
 #include "yb/master/master_defaults.h"
@@ -1313,6 +1314,12 @@ Result<std::shared_ptr<XClusterRpcTasks>> UniverseReplicationInfoBase::GetOrCrea
   return rpc_task;
 }
 
+// ================================================================================================
+// PersistentUniverseReplicationInfo
+// ================================================================================================
+
+bool PersistentUniverseReplicationInfo::IsDbScoped() const { return yb::master::IsDbScoped(pb); }
+
 // ================================================================================================
 // UniverseReplicationInfo
 // ================================================================================================
@@ -1333,10 +1340,7 @@ Status UniverseReplicationInfo::GetSetupUniverseReplicationErrorStatus() const {
   return setup_universe_replication_error_;
 }
 
-bool UniverseReplicationInfo::IsDbScoped() const {
-  auto l = LockForRead();
-  return l->pb.has_db_scoped_info() && l->pb.db_scoped_info().namespace_infos_size() > 0;
-}
+bool UniverseReplicationInfo::IsDbScoped() const { return LockForRead()->IsDbScoped(); }
 
 // ================================================================================================
 // PersistentUniverseReplicationBootstrapInfo
diff --git a/src/yb/master/catalog_entity_info.h b/src/yb/master/catalog_entity_info.h
index a89ea06456..8f83b633dd 100644
--- a/src/yb/master/catalog_entity_info.h
+++ b/src/yb/master/catalog_entity_info.h
@@ -1228,6 +1228,8 @@ struct PersistentUniverseReplicationInfo
   bool is_active() const {
     return pb.state() == SysUniverseReplicationEntryPB::ACTIVE;
   }
+
+  bool IsDbScoped() const;
 };
 
 class UniverseReplicationInfo : public UniverseReplicationInfoBase,
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 827e1120d4..85ad7fe151 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -7901,7 +7901,7 @@ scoped_refptr<TableInfo> CatalogManager::GetTableInfoFromNamespaceNameAndTableNa
 }
 
 Result<std::vector<scoped_refptr<TableInfo>>> CatalogManager::GetTableInfosForNamespace(
-    const NamespaceId& namespace_id) {
+    const NamespaceId& namespace_id) const {
   std::vector<scoped_refptr<TableInfo>> table_infos;
   SharedLock lock(mutex_);
   for (const auto& table : tables_->GetAllTables()) {
@@ -13971,5 +13971,19 @@ bool CatalogManager::ShouldRetainHiddenTablet(
   return false;
 }
 
+std::optional<UniverseUuid> CatalogManager::GetUniverseUuidIfExists() const {
+  auto l = ClusterConfig()->LockForRead();
+  if (!l->pb.has_universe_uuid()) {
+    return std::nullopt;
+  }
+  auto universe_uuid_res = UniverseUuid::FromString(l->pb.universe_uuid());
+  if (!universe_uuid_res.ok()) {
+    LOG(WARNING) << "Failed to parse universe UUID: " << universe_uuid_res.status();
+    return std::nullopt;
+  }
+
+  return *universe_uuid_res;
+}
+
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index 9c2cd84263..455ee2c91e 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -747,7 +747,7 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
       const TableName& table_name, const PgSchemaName pg_schema_name = {}) override;
 
   Result<std::vector<scoped_refptr<TableInfo>>> GetTableInfosForNamespace(
-      const NamespaceId& namespace_id);
+      const NamespaceId& namespace_id) const;
 
   // Return TableInfos according to specified mode.
   virtual std::vector<TableInfoPtr> GetTables(
@@ -1615,6 +1615,8 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
   std::unordered_map<TableId, XClusterConsumerTableStreamIds> GetXClusterConsumerTableStreams()
       const EXCLUDES(mutex_);
 
+  std::optional<UniverseUuid> GetUniverseUuidIfExists() const;
+
  protected:
   // TODO Get rid of these friend classes and introduce formal interface.
   friend class TableLoader;
@@ -2967,6 +2969,10 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
       const xcluster::ReplicationGroupId& replication_group_id, const TableId& table,
       const Result<xrepl::StreamId>& stream_id, std::function<void()> on_success_cb = nullptr);
 
+  Status AddCDCStreamToUniverseAndInitConsumerInternal(
+      scoped_refptr<UniverseReplicationInfo> universe, const TableId& table,
+      const xrepl::StreamId& stream_id, std::function<void()> on_success_cb);
+
   void MergeUniverseReplication(
       scoped_refptr<UniverseReplicationInfo> info, xcluster::ReplicationGroupId original_id);
 
diff --git a/src/yb/master/master_replication.proto b/src/yb/master/master_replication.proto
index 562015b710..f621165396 100644
--- a/src/yb/master/master_replication.proto
+++ b/src/yb/master/master_replication.proto
@@ -271,9 +271,9 @@ message SetupUniverseReplicationRequestPB {
   // Is the created replication group transactionally consistent.
   optional bool transactional = 5; // [default = false]
 
-  // Used for DB Scoped replication.
-  repeated string namespace_names = 6; // YSQL database names.
-  repeated string producer_namespace_ids = 7;
+  // Used for DB Scoped replication. transactional must be set.
+  // Both id and name must be set. Only YQL_DATABASE_PGSQL are allowed.
+  repeated NamespaceIdentifierPB producer_namespaces = 6;
 }
 
 message SetupUniverseReplicationResponsePB {
@@ -286,6 +286,8 @@ message DeleteUniverseReplicationRequestPB {
   optional string replication_group_id = 1;
   optional bool ignore_errors = 2 [default = false];
   optional bool skip_producer_stream_deletion = 3 [ default = false ];
+  // Used to validate that the request is sent to the correct universe.
+  optional string universe_uuid = 4;
 }
 
 message DeleteUniverseReplicationResponsePB {
@@ -306,6 +308,14 @@ message AlterUniverseReplicationRequestPB {
   repeated string producer_bootstrap_ids_to_add = 6;
 
   optional bool remove_table_ignore_errors = 8 [default = false];
+
+  // Used to validate the requests are sent to the correct universe.
+  optional string universe_uuid = 9;
+
+  // Used for DB Scoped replication.
+  // Both id and name must be set. Only YQL_DATABASE_PGSQL are allowed.
+  optional NamespaceIdentifierPB producer_namespace_to_add = 10;
+  optional string producer_namespace_id_to_remove = 11;
 }
 
 message AlterUniverseReplicationResponsePB {
@@ -538,27 +548,28 @@ message YsqlBackfillReplicationSlotNameToCDCSDKStreamResponsePB {
 
 message XClusterCreateOutboundReplicationGroupRequestPB {
   required string replication_group_id = 1;
-  repeated string namespace_names = 2;
+  repeated string namespace_ids = 2;
 }
 
 message XClusterCreateOutboundReplicationGroupResponsePB {
   optional MasterErrorPB error = 1;
-  repeated bytes namespace_ids = 2; // One per namespace.
 }
 
 message XClusterAddNamespaceToOutboundReplicationGroupRequestPB {
   required string replication_group_id = 1;
-  optional string namespace_name = 2;
+  required string namespace_id = 2;
 }
 
 message XClusterAddNamespaceToOutboundReplicationGroupResponsePB {
   optional MasterErrorPB error = 1;
-  optional bytes namespace_id = 2;
 }
 
 message XClusterRemoveNamespaceFromOutboundReplicationGroupRequestPB {
   required string replication_group_id = 1;
-  optional bytes namespace_id = 2;
+  required string namespace_id = 2;
+
+  // Optional. When set target cluster is also cleaned up.
+  repeated HostPortPB target_master_addresses = 3;
 }
 
 message XClusterRemoveNamespaceFromOutboundReplicationGroupResponsePB {
@@ -567,6 +578,9 @@ message XClusterRemoveNamespaceFromOutboundReplicationGroupResponsePB {
 
 message XClusterDeleteOutboundReplicationGroupRequestPB {
   required string replication_group_id = 1;
+
+  // Optional. When set target cluster is also cleaned up.
+  repeated HostPortPB target_master_addresses = 2;
 }
 
 message XClusterDeleteOutboundReplicationGroupResponsePB {
@@ -574,8 +588,8 @@ message XClusterDeleteOutboundReplicationGroupResponsePB {
 }
 
 message IsXClusterBootstrapRequiredRequestPB {
-  required bytes replication_group_id = 1;
-  optional bytes namespace_id = 2;
+  required string replication_group_id = 1;
+  required string namespace_id = 2;
 }
 
 message IsXClusterBootstrapRequiredResponsePB {
@@ -585,8 +599,8 @@ message IsXClusterBootstrapRequiredResponsePB {
 }
 
 message GetXClusterStreamsRequestPB {
-  required bytes replication_group_id = 1;
-  optional bytes namespace_id = 2;
+  required string replication_group_id = 1;
+  required string namespace_id = 2;
 
   message TableInfo {
     required string table_name = 1;
@@ -636,6 +650,31 @@ message IsCreateXClusterReplicationDoneResponsePB {
   optional AppStatusPB replication_error = 3;
 }
 
+message AddNamespaceToXClusterReplicationRequestPB {
+  required string replication_group_id = 1;
+  repeated HostPortPB target_master_addresses = 2;
+  required string namespace_id = 3;
+}
+
+message AddNamespaceToXClusterReplicationResponsePB {
+  optional MasterErrorPB error = 1;
+}
+
+message IsAlterXClusterReplicationDoneRequestPB {
+  required string replication_group_id = 1;
+  repeated HostPortPB target_master_addresses = 2;
+}
+
+message IsAlterXClusterReplicationDoneResponsePB {
+  optional MasterErrorPB error = 1;
+
+  optional bool done = 2; // [default = false]
+
+  // Only set when done is true. OK if the created succeeded or the error if it
+  // failed.
+  optional AppStatusPB replication_error = 3;
+}
+
 message RepairOutboundXClusterReplicationGroupAddTableRequestPB {
   required string replication_group_id = 1;
   required bytes table_id = 2;
@@ -757,4 +796,8 @@ service MasterReplication {
       returns (CreateXClusterReplicationResponsePB);
   rpc IsCreateXClusterReplicationDone(IsCreateXClusterReplicationDoneRequestPB)
       returns (IsCreateXClusterReplicationDoneResponsePB);
+  rpc AddNamespaceToXClusterReplication(AddNamespaceToXClusterReplicationRequestPB)
+      returns (AddNamespaceToXClusterReplicationResponsePB);
+  rpc IsAlterXClusterReplicationDone(IsAlterXClusterReplicationDoneRequestPB)
+      returns (IsAlterXClusterReplicationDoneResponsePB);
 }
diff --git a/src/yb/master/master_replication_service.cc b/src/yb/master/master_replication_service.cc
index b1d982649a..56b806ae3b 100644
--- a/src/yb/master/master_replication_service.cc
+++ b/src/yb/master/master_replication_service.cc
@@ -72,6 +72,8 @@ class MasterReplicationServiceImpl : public MasterServiceBase, public MasterRepl
       (GetXClusterStreams)
       (CreateXClusterReplication)
       (IsCreateXClusterReplicationDone)
+      (AddNamespaceToXClusterReplication)
+      (IsAlterXClusterReplicationDone)
       (RepairOutboundXClusterReplicationGroupAddTable)
       (RepairOutboundXClusterReplicationGroupRemoveTable)
   )
diff --git a/src/yb/master/xcluster/master_xcluster_util.cc b/src/yb/master/xcluster/master_xcluster_util.cc
index cbec84351c..fcca632763 100644
--- a/src/yb/master/xcluster/master_xcluster_util.cc
+++ b/src/yb/master/xcluster/master_xcluster_util.cc
@@ -14,6 +14,7 @@
 #include "yb/master/xcluster/master_xcluster_util.h"
 #include "yb/common/common_types.pb.h"
 #include "yb/master/catalog_entity_info.h"
+#include "yb/master/catalog_manager.h"
 
 namespace yb::master {
 
@@ -63,4 +64,17 @@ std::string GetFullTableName(const TableInfo& table_info) {
   return Format("$0.$1", schema_name, table_info.name());
 }
 
+Result<std::vector<TableInfoPtr>> GetTablesEligibleForXClusterReplication(
+    const CatalogManager& catalog_manager, const NamespaceId& namespace_id) {
+  auto table_infos = VERIFY_RESULT(catalog_manager.GetTableInfosForNamespace(namespace_id));
+  EraseIf(
+      [](const TableInfoPtr& table) { return !IsTableEligibleForXClusterReplication(*table); },
+      &table_infos);
+  return table_infos;
+}
+
+bool IsDbScoped(const SysUniverseReplicationEntryPB& replication_info) {
+  return replication_info.has_db_scoped_info() &&
+         replication_info.db_scoped_info().namespace_infos_size() > 0;
+}
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/master_xcluster_util.h b/src/yb/master/xcluster/master_xcluster_util.h
index 5d75a95f46..0a6be86669 100644
--- a/src/yb/master/xcluster/master_xcluster_util.h
+++ b/src/yb/master/xcluster/master_xcluster_util.h
@@ -14,6 +14,9 @@
 #pragma once
 
 #include <string>
+#include <vector>
+
+#include "yb/master/master_fwd.h"
 
 namespace yb::master {
 class TableInfo;
@@ -24,4 +27,9 @@ bool IsTableEligibleForXClusterReplication(const master::TableInfo& table);
 // Get the table name along with the YSQL schema name if this is a YSQL table.
 std::string GetFullTableName(const TableInfo& table_info);
 
+Result<std::vector<TableInfoPtr>> GetTablesEligibleForXClusterReplication(
+    const CatalogManager& catalog_manager, const NamespaceId& namespace_id);
+
+bool IsDbScoped(const SysUniverseReplicationEntryPB& replication_info);
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index 2fad4bf3a9..11d905cd6c 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -229,25 +229,17 @@ Status XClusterManager::XClusterCreateOutboundReplicationGroup(
     const XClusterCreateOutboundReplicationGroupRequestPB* req,
     XClusterCreateOutboundReplicationGroupResponsePB* resp, rpc::RpcContext* rpc,
     const LeaderEpoch& epoch) {
-  SCHECK(FLAGS_enable_xcluster_api_v2, IllegalState, "xCluster API v2 is not enabled.");
-
   LOG_FUNC_AND_RPC;
+  SCHECK(FLAGS_enable_xcluster_api_v2, IllegalState, "xCluster API v2 is not enabled.");
+  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id);
+  SCHECK(!req->namespace_ids().empty(), InvalidArgument, "Missing Namespace Ids");
 
-  SCHECK(
-      !req->replication_group_id().empty(), InvalidArgument,
-      "Replication group id cannot be empty");
-  SCHECK(req->namespace_names_size() > 0, InvalidArgument, "Namespace names must be specified");
-
-  std::vector<NamespaceName> namespace_names;
-  for (const auto& namespace_name : req->namespace_names()) {
-    namespace_names.emplace_back(namespace_name);
-  }
-
-  auto namespace_ids = VERIFY_RESULT(CreateOutboundReplicationGroup(
-      xcluster::ReplicationGroupId(req->replication_group_id()), namespace_names, epoch));
-  for (const auto& namespace_id : namespace_ids) {
-    *resp->add_namespace_ids() = namespace_id;
+  std::vector<NamespaceId> namespace_ids;
+  for (const auto& namespace_id : req->namespace_ids()) {
+    namespace_ids.emplace_back(namespace_id);
   }
+  RETURN_NOT_OK(CreateOutboundReplicationGroup(
+      xcluster::ReplicationGroupId(req->replication_group_id()), namespace_ids, epoch));
 
   return Status::OK();
 }
@@ -257,12 +249,11 @@ Status XClusterManager::XClusterAddNamespaceToOutboundReplicationGroup(
     XClusterAddNamespaceToOutboundReplicationGroupResponsePB* resp, rpc::RpcContext* rpc,
     const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
-  SCHECK(req->has_namespace_name(), InvalidArgument, "Namespace name must be specified");
+  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id, namespace_id);
 
-  auto namespace_id = VERIFY_RESULT(AddNamespaceToOutboundReplicationGroup(
-      xcluster::ReplicationGroupId(req->replication_group_id()), req->namespace_name(), epoch));
+  RETURN_NOT_OK(AddNamespaceToOutboundReplicationGroup(
+      xcluster::ReplicationGroupId(req->replication_group_id()), req->namespace_id(), epoch));
 
-  resp->set_namespace_id(namespace_id);
   return Status::OK();
 }
 
@@ -271,10 +262,16 @@ Status XClusterManager::XClusterRemoveNamespaceFromOutboundReplicationGroup(
     XClusterRemoveNamespaceFromOutboundReplicationGroupResponsePB* resp, rpc::RpcContext* rpc,
     const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
-  SCHECK(req->has_namespace_id(), InvalidArgument, "Namespace id must be specified");
+  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id, namespace_id);
+
+  std::vector<HostPort> target_master_addresses;
+  if (!req->target_master_addresses().empty()) {
+    HostPortsFromPBs(req->target_master_addresses(), &target_master_addresses);
+  }
 
   return RemoveNamespaceFromOutboundReplicationGroup(
-      xcluster::ReplicationGroupId(req->replication_group_id()), req->namespace_id(), epoch);
+      xcluster::ReplicationGroupId(req->replication_group_id()), req->namespace_id(),
+      target_master_addresses, epoch);
 }
 
 Status XClusterManager::XClusterDeleteOutboundReplicationGroup(
@@ -282,17 +279,22 @@ Status XClusterManager::XClusterDeleteOutboundReplicationGroup(
     XClusterDeleteOutboundReplicationGroupResponsePB* resp, rpc::RpcContext* rpc,
     const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
+  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id);
+
+  std::vector<HostPort> target_master_addresses;
+  if (!req->target_master_addresses().empty()) {
+    HostPortsFromPBs(req->target_master_addresses(), &target_master_addresses);
+  }
 
   return DeleteOutboundReplicationGroup(
-      xcluster::ReplicationGroupId(req->replication_group_id()), epoch);
+      xcluster::ReplicationGroupId(req->replication_group_id()), target_master_addresses, epoch);
 }
 
 Status XClusterManager::IsXClusterBootstrapRequired(
     const IsXClusterBootstrapRequiredRequestPB* req, IsXClusterBootstrapRequiredResponsePB* resp,
     rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
-  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id, namespace_id);
-
   LOG_FUNC_AND_RPC;
+  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id, namespace_id);
 
   auto bootstrap_required = VERIFY_RESULT(IsBootstrapRequired(
       xcluster::ReplicationGroupId(req->replication_group_id()), req->namespace_id()));
@@ -310,9 +312,8 @@ Status XClusterManager::IsXClusterBootstrapRequired(
 Status XClusterManager::GetXClusterStreams(
     const GetXClusterStreamsRequestPB* req, GetXClusterStreamsResponsePB* resp,
     rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
-  SCHECK(req->has_namespace_id(), InvalidArgument, "Namespace id must be specified");
-
   LOG_FUNC_AND_RPC;
+  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id, namespace_id);
 
   std::vector<std::pair<TableName, PgSchemaName>> table_names;
   for (const auto& table_name : req->table_infos()) {
@@ -343,6 +344,9 @@ Status XClusterManager::CreateXClusterReplication(
     const CreateXClusterReplicationRequestPB* req, CreateXClusterReplicationResponsePB* resp,
     rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
+  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id);
+  SCHECK(
+      !req->target_master_addresses().empty(), InvalidArgument, "Missing Target Master addresses");
 
   std::vector<HostPort> target_master_addresses;
   HostPortsFromPBs(req->target_master_addresses(), &target_master_addresses);
@@ -356,6 +360,9 @@ Status XClusterManager::IsCreateXClusterReplicationDone(
     IsCreateXClusterReplicationDoneResponsePB* resp, rpc::RpcContext* rpc,
     const LeaderEpoch& epoch) {
   LOG_FUNC_AND_RPC;
+  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id);
+  SCHECK(
+      !req->target_master_addresses().empty(), InvalidArgument, "Missing Target Master addresses");
 
   std::vector<HostPort> target_master_addresses;
   HostPortsFromPBs(req->target_master_addresses(), &target_master_addresses);
@@ -370,6 +377,45 @@ Status XClusterManager::IsCreateXClusterReplicationDone(
   return Status::OK();
 }
 
+Status XClusterManager::AddNamespaceToXClusterReplication(
+    const AddNamespaceToXClusterReplicationRequestPB* req,
+    AddNamespaceToXClusterReplicationResponsePB* resp, rpc::RpcContext* rpc,
+    const LeaderEpoch& epoch) {
+  LOG_FUNC_AND_RPC;
+  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id, namespace_id);
+  SCHECK(
+      !req->target_master_addresses().empty(), InvalidArgument, "Missing Target Master addresses");
+
+  std::vector<HostPort> target_master_addresses;
+  HostPortsFromPBs(req->target_master_addresses(), &target_master_addresses);
+
+  return XClusterSourceManager::AddNamespaceToTarget(
+      xcluster::ReplicationGroupId(req->replication_group_id()), target_master_addresses,
+      req->namespace_id(), epoch);
+}
+
+Status XClusterManager::IsAlterXClusterReplicationDone(
+    const IsAlterXClusterReplicationDoneRequestPB* req,
+    IsAlterXClusterReplicationDoneResponsePB* resp, rpc::RpcContext* rpc,
+    const LeaderEpoch& epoch) {
+  LOG_FUNC_AND_RPC;
+  SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id);
+  SCHECK(
+      !req->target_master_addresses().empty(), InvalidArgument, "Missing Target Master addresses");
+
+  std::vector<HostPort> target_master_addresses;
+  HostPortsFromPBs(req->target_master_addresses(), &target_master_addresses);
+
+  auto create_result = VERIFY_RESULT(XClusterSourceManager::IsAlterXClusterReplicationDone(
+      xcluster::ReplicationGroupId(req->replication_group_id()), target_master_addresses, epoch));
+
+  resp->set_done(create_result.done());
+  if (create_result.done()) {
+    StatusToPB(create_result.status(), resp->mutable_replication_error());
+  }
+  return Status::OK();
+}
+
 Status XClusterManager::RepairOutboundXClusterReplicationGroupAddTable(
     const RepairOutboundXClusterReplicationGroupAddTableRequestPB* req,
     RepairOutboundXClusterReplicationGroupAddTableResponsePB* resp, rpc::RpcContext* rpc,
diff --git a/src/yb/master/xcluster/xcluster_manager.h b/src/yb/master/xcluster/xcluster_manager.h
index 46ba55fbdb..e422ff7e03 100644
--- a/src/yb/master/xcluster/xcluster_manager.h
+++ b/src/yb/master/xcluster/xcluster_manager.h
@@ -135,6 +135,14 @@ class XClusterManager : public XClusterManagerIf,
       const IsCreateXClusterReplicationDoneRequestPB* req,
       IsCreateXClusterReplicationDoneResponsePB* resp, rpc::RpcContext* rpc,
       const LeaderEpoch& epoch);
+  Status AddNamespaceToXClusterReplication(
+      const AddNamespaceToXClusterReplicationRequestPB* req,
+      AddNamespaceToXClusterReplicationResponsePB* resp, rpc::RpcContext* rpc,
+      const LeaderEpoch& epoch);
+  Status IsAlterXClusterReplicationDone(
+      const IsAlterXClusterReplicationDoneRequestPB* req,
+      IsAlterXClusterReplicationDoneResponsePB* resp, rpc::RpcContext* rpc,
+      const LeaderEpoch& epoch);
   Status RepairOutboundXClusterReplicationGroupAddTable(
       const RepairOutboundXClusterReplicationGroupAddTableRequestPB* req,
       RepairOutboundXClusterReplicationGroupAddTableResponsePB* resp, rpc::RpcContext* rpc,
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
index 83e10b4624..4a75af9b20 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
@@ -28,6 +28,7 @@
 #include "yb/util/tsan_util.h"
 
 DECLARE_bool(TEST_enable_sync_points);
+DECLARE_bool(TEST_block_xcluster_checkpoint_namespace_task);
 
 using namespace std::placeholders;
 using testing::_;
@@ -63,6 +64,14 @@ class XClusterRemoteClientMocked : public client::XClusterRemoteClient {
   MOCK_METHOD1(
       IsSetupUniverseReplicationDone,
       Result<IsOperationDoneResult>(const xcluster::ReplicationGroupId&));
+
+  MOCK_METHOD6(
+      AddNamespaceToDbScopedUniverseReplication,
+      Status(
+          const xcluster::ReplicationGroupId& replication_group_id,
+          const UniverseUuid& target_universe_uuid, const NamespaceName& namespace_name,
+          const NamespaceId& source_namespace_id, const std::vector<TableId>& source_table_ids,
+          const std::vector<xrepl::StreamId>& bootstrap_ids));
 };
 
 Status ValidateEpoch(const LeaderEpoch& epoch) {
@@ -121,18 +130,15 @@ class XClusterOutboundReplicationGroupMocked : public XClusterOutboundReplicatio
         delta, "Waiting for namespace checkpoint");
   }
 
-  Result<NamespaceId> AddNamespaceSync(
-      const LeaderEpoch& epoch, const NamespaceName& namespace_name, MonoDelta delta) {
-    auto namespace_id = VERIFY_RESULT(AddNamespace(epoch, namespace_name));
-    RETURN_NOT_OK(WaitForCheckpoint(namespace_id, delta));
-
-    return namespace_id;
+  Status AddNamespaceSync(
+      const LeaderEpoch& epoch, const NamespaceId& namespace_id, MonoDelta delta) {
+    RETURN_NOT_OK(AddNamespace(epoch, namespace_id));
+    return WaitForCheckpoint(namespace_id, delta);
   }
 
-  Result<std::vector<NamespaceId>> AddNamespacesSync(
-      const LeaderEpoch& epoch, const std::vector<NamespaceName>& namespace_names,
-      MonoDelta delta) {
-    auto namespace_ids = VERIFY_RESULT(AddNamespaces(epoch, namespace_names));
+  Status AddNamespacesSync(
+      const LeaderEpoch& epoch, const std::vector<NamespaceId>& namespace_ids, MonoDelta delta) {
+    RETURN_NOT_OK(AddNamespaces(epoch, namespace_ids));
     for (const auto& namespace_id : namespace_ids) {
       RETURN_NOT_OK(LoggedWaitFor(
           [this, namespace_id]() -> Result<bool> {
@@ -141,7 +147,7 @@ class XClusterOutboundReplicationGroupMocked : public XClusterOutboundReplicatio
           delta, "Waiting for namespace checkpoint"));
     }
 
-    return namespace_ids;
+    return Status::OK();
   }
 
  private:
@@ -190,7 +196,9 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
   void CreateNamespace(const NamespaceName& namespace_name, const NamespaceId& namespace_id) {
     scoped_refptr<NamespaceInfo> ns = new NamespaceInfo(namespace_id, /*tasks_tracker=*/nullptr);
     auto l = ns->LockForWrite();
-    l.mutable_data()->pb.set_name(namespace_name);
+    auto& pb = l.mutable_data()->pb;
+    pb.set_name(namespace_name);
+    pb.set_database_type(YQLDatabase::YQL_DATABASE_PGSQL);
     l.Commit();
     namespace_infos[namespace_id] = std::move(ns);
   }
@@ -329,8 +337,7 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, TestMultipleTable) {
   auto& outbound_rg = *outbound_rg_ptr;
 
   ASSERT_FALSE(outbound_rg.HasNamespace(kNamespaceId));
-  auto namespace_id = ASSERT_RESULT(outbound_rg.AddNamespaceSync(kEpoch, kNamespaceName, kTimeout));
-  ASSERT_EQ(namespace_id, kNamespaceId);
+  ASSERT_OK(outbound_rg.AddNamespaceSync(kEpoch, kNamespaceId, kTimeout));
   ASSERT_TRUE(outbound_rg.HasNamespace(kNamespaceId));
 
   auto ns_info_opt = ASSERT_RESULT(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
@@ -362,7 +369,7 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, TestMultipleTable) {
   ASSERT_EQ(ns_info_opt->table_infos[0].table_name, kTableName2);
   ASSERT_EQ(ns_info_opt->table_infos[1].table_name, kTableName1);
 
-  ASSERT_OK(outbound_rg.Delete(kEpoch));
+  ASSERT_OK(outbound_rg.Delete(/*target_master_addresses=*/{}, kEpoch));
   ASSERT_FALSE(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
   auto result = outbound_rg.GetMetadata();
   ASSERT_NOK(result);
@@ -377,6 +384,8 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddDeleteNamespaces) {
   CreateTable(kNamespaceId, kTableId1, kTableName1, kPgSchemaName);
   CreateTable(kNamespaceId, kTableId2, kTableName2, kPgSchemaName);
 
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_block_xcluster_checkpoint_namespace_task) = true;
+
   const NamespaceName namespace_name_2 = "db2";
   const NamespaceId namespace_id_2 = "ns_id_2";
   const TableId ns2_table_id_1 = "ns2_table_id_1", ns2_table_id_2 = "ns2_table_id_2";
@@ -386,10 +395,24 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddDeleteNamespaces) {
 
   auto outbound_rg_ptr = CreateReplicationGroup();
   auto& outbound_rg = *outbound_rg_ptr;
-  auto out_namespace_id =
-      ASSERT_RESULT(outbound_rg.AddNamespacesSync(kEpoch, {kNamespaceName}, kTimeout));
-  ASSERT_EQ(out_namespace_id.size(), 1);
-  ASSERT_EQ(out_namespace_id[0], kNamespaceId);
+  ASSERT_OK(outbound_rg.AddNamespaces(kEpoch, {kNamespaceId}));
+
+  // Adding second namespace while the first operation has not completed should fail.
+  ASSERT_NOK_STR_CONTAINS(
+      outbound_rg.AddNamespace(kEpoch, namespace_id_2), "has in progress tasks");
+
+  // Removing the namespace should succeed and cause the task to complete.
+  ASSERT_OK(outbound_rg.RemoveNamespace(kEpoch, kNamespaceId, /*target_master_addresses=*/{}));
+  ASSERT_FALSE(outbound_rg.HasNamespace(kNamespaceId));
+
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_block_xcluster_checkpoint_namespace_task) = false;
+
+  ASSERT_OK(LoggedWaitFor(
+      [&outbound_rg]() { return !outbound_rg.HasTasks(); }, kTimeout,
+      "Waiting for tasks to complete"));
+  ASSERT_EQ(xcluster_streams.size(), 0);
+
+  ASSERT_OK(outbound_rg.AddNamespacesSync(kEpoch, {kNamespaceId}, kTimeout));
 
   // We should have 2 streams now.
   ASSERT_EQ(xcluster_streams.size(), 2);
@@ -406,9 +429,7 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddDeleteNamespaces) {
   ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(kTableId1, kTableId2, *ns1_info_opt));
 
   // Add the second namespace.
-  auto out_namespace_id2 =
-      ASSERT_RESULT(outbound_rg.AddNamespaceSync(kEpoch, namespace_name_2, kTimeout));
-  ASSERT_EQ(out_namespace_id2, namespace_id_2);
+  ASSERT_OK(outbound_rg.AddNamespaceSync(kEpoch, namespace_id_2, kTimeout));
 
   // We should have 4 streams now.
   ASSERT_EQ(xcluster_streams.size(), 4);
@@ -423,7 +444,7 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddDeleteNamespaces) {
   ASSERT_TRUE(ns2_info_opt.has_value());
   ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(ns2_table_id_1, ns2_table_id_2, *ns2_info_opt));
 
-  ASSERT_OK(outbound_rg.RemoveNamespace(kEpoch, kNamespaceId));
+  ASSERT_OK(outbound_rg.RemoveNamespace(kEpoch, kNamespaceId, /*target_master_addresses=*/{}));
   ASSERT_FALSE(outbound_rg.HasNamespace(kNamespaceId));
   ASSERT_NOK(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
 
@@ -435,8 +456,14 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddDeleteNamespaces) {
     ASSERT_FALSE(xcluster_streams_initial.contains(stream));
   }
 
-  ASSERT_OK(outbound_rg.Delete(kEpoch));
+  // Delete the group while there is a checkpoint task in progress.
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_block_xcluster_checkpoint_namespace_task) = true;
+  ASSERT_OK(outbound_rg.AddNamespaces(kEpoch, {kNamespaceId}));
+
+  ASSERT_OK(outbound_rg.Delete(/*target_master_addresses=*/{}, kEpoch));
+  ASSERT_FALSE(outbound_rg.HasNamespace(kNamespaceId));
   ASSERT_FALSE(outbound_rg.HasNamespace(namespace_id_2));
+  ASSERT_NOK(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
   ASSERT_NOK(outbound_rg.GetNamespaceCheckpointInfo(namespace_id_2));
   ASSERT_TRUE(xcluster_streams.empty());
 }
@@ -449,7 +476,7 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, CreateTargetReplicationGroup)
   auto remote_client = std::make_shared<XClusterRemoteClientMocked>();
   outbound_rg.SetRemoteClient(remote_client);
 
-  ASSERT_OK(outbound_rg.AddNamespaceSync(kEpoch, kNamespaceName, kTimeout));
+  ASSERT_OK(outbound_rg.AddNamespaceSync(kEpoch, kNamespaceId, kTimeout));
 
   std::vector<xrepl::StreamId> streams{xcluster_streams.begin(), xcluster_streams.end()};
   EXPECT_CALL(
@@ -516,8 +543,8 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddTable) {
   CreateTable(kNamespaceId, kTableId2, kTableName2, kPgSchemaName2);
 
   auto outbound_rg = CreateReplicationGroup();
-  auto namespace_id =
-      ASSERT_RESULT(outbound_rg->AddNamespaceSync(kEpoch, kNamespaceName, kTimeout));
+
+  ASSERT_OK(outbound_rg->AddNamespaceSync(kEpoch, kNamespaceId, kTimeout));
   ASSERT_TRUE(outbound_rg->HasNamespace(kNamespaceId));
   ASSERT_EQ(xcluster_streams.size(), 2);
 
@@ -554,12 +581,12 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddTableDuringCheckpoint) {
   CreateTable(kNamespaceId, kTableId1, kTableName1, kPgSchemaName);
 
   auto outbound_rg = CreateReplicationGroup();
-  auto namespace_id = ASSERT_RESULT(outbound_rg->AddNamespace(kEpoch, kNamespaceName));
+  ASSERT_OK(outbound_rg->AddNamespace(kEpoch, kNamespaceId));
 
   CreateTable(kNamespaceId, kTableId2, kTableName2, kPgSchemaName2);
   TEST_SYNC_POINT("TESTAddTableDuringCheckpoint::TableCreated");
 
-  auto status = outbound_rg->WaitForCheckpoint(namespace_id, kTimeout);
+  auto status = outbound_rg->WaitForCheckpoint(kNamespaceId, kTimeout);
   ASSERT_NOK(status);
   ASSERT_STR_CONTAINS(
       status.ToString(),
@@ -583,12 +610,12 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, DropTableDuringCheckpoint) {
   CreateTable(kNamespaceId, kTableId2, kTableName2, kPgSchemaName2);
 
   auto outbound_rg = CreateReplicationGroup();
-  auto namespace_id = ASSERT_RESULT(outbound_rg->AddNamespace(kEpoch, kNamespaceName));
+  ASSERT_OK(outbound_rg->AddNamespace(kEpoch, kNamespaceId));
 
   DropTable(kNamespaceId, kTableId1);
   TEST_SYNC_POINT("TESTAddTableDuringCheckpoint::TableCreated");
 
-  auto status = outbound_rg->WaitForCheckpoint(namespace_id, kTimeout);
+  auto status = outbound_rg->WaitForCheckpoint(kNamespaceId, kTimeout);
   ASSERT_NOK(status);
   ASSERT_STR_CONTAINS(
       status.ToString(),
@@ -597,4 +624,5 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, DropTableDuringCheckpoint) {
 
   sync_point_instance->DisableProcessing();
 }
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
index e535324742..a6145f8be3 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
@@ -12,6 +12,7 @@
 //
 
 #include "yb/master/xcluster/xcluster_outbound_replication_group.h"
+#include "yb/cdc/xcluster_util.h"
 #include "yb/client/xcluster_client.h"
 #include "yb/common/colocated_util.h"
 #include "yb/master/catalog_entity_info.h"
@@ -334,15 +335,6 @@ Result<scoped_refptr<NamespaceInfo>> XClusterOutboundReplicationGroup::GetYbName
   return helper_functions_.get_namespace_func(ns_id_pb);
 }
 
-Result<NamespaceId> XClusterOutboundReplicationGroup::GetNamespaceId(
-    const NamespaceName& namespace_name) const {
-  NamespaceIdentifierPB ns_id_pb;
-  ns_id_pb.set_name(namespace_name);
-  ns_id_pb.set_database_type(YQLDatabase::YQL_DATABASE_PGSQL);
-  auto ns = VERIFY_RESULT(helper_functions_.get_namespace_func(ns_id_pb));
-  return ns->id();
-}
-
 Result<NamespaceName> XClusterOutboundReplicationGroup::GetNamespaceName(
     const NamespaceId& namespace_id) const {
   return VERIFY_RESULT(GetYbNamespaceInfo(namespace_id))->name();
@@ -359,6 +351,10 @@ XClusterOutboundReplicationGroup::CreateNamespaceInfo(
       "Database should have at least one table in order to be part of xCluster replication");
 
   auto yb_ns_info = VERIFY_RESULT(GetYbNamespaceInfo(namespace_id));
+  SCHECK_EQ(
+      yb_ns_info->database_type(), YQLDatabase::YQL_DATABASE_PGSQL, InvalidArgument,
+      "Only YSQL databases are supported in xCluster DB Scoped replication");
+
   if (yb_ns_info->colocated()) {
     bool has_any_colocated_table =
         std::any_of(table_infos.begin(), table_infos.end(), [](const TableInfoPtr& table_info) {
@@ -383,57 +379,77 @@ XClusterOutboundReplicationGroup::CreateNamespaceInfo(
   return ns_info;
 }
 
-Result<NamespaceId> XClusterOutboundReplicationGroup::AddNamespaceInternal(
-    const NamespaceName& namespace_name, XClusterOutboundReplicationGroupInfo::WriteLock& l,
+Result<bool> XClusterOutboundReplicationGroup::AddNamespaceInternal(
+    const NamespaceId& namespace_id, XClusterOutboundReplicationGroupInfo::WriteLock& l,
     const LeaderEpoch& epoch) {
-  SCHECK(!namespace_name.empty(), InvalidArgument, "Namespace name cannot be empty");
-  VLOG_WITH_PREFIX_AND_FUNC(1) << namespace_name;
-
-  auto namespace_id = VERIFY_RESULT(GetNamespaceId(namespace_name));
+  VLOG_WITH_PREFIX_AND_FUNC(1) << namespace_id;
 
   auto& outbound_group_pb = l.mutable_data()->pb;
 
   if (HasNamespaceUnlocked(namespace_id)) {
-    LOG(INFO) << "Skip adding Namespace " << namespace_name << " since it already exists in "
+    LOG(INFO) << "Skip adding Namespace " << namespace_id << " since it already exists in "
               << ToString();
-    return namespace_id;
+    return false;
   }
 
   auto ns_checkpoint_info = VERIFY_RESULT(CreateNamespaceInfo(namespace_id, epoch));
   outbound_group_pb.mutable_namespace_infos()->insert(
       {namespace_id, std::move(ns_checkpoint_info)});
 
-  return namespace_id;
+  return true;
 }
 
-Result<std::vector<NamespaceId>> XClusterOutboundReplicationGroup::AddNamespaces(
-    const LeaderEpoch& epoch, const std::vector<NamespaceName>& namespace_names) {
-  std::vector<NamespaceId> namespace_ids;
+Status XClusterOutboundReplicationGroup::AddNamespaces(
+    const LeaderEpoch& epoch, const std::vector<NamespaceId>& namespace_ids) {
   std::lock_guard mutex_lock(mutex_);
   auto l = VERIFY_RESULT(LockForWrite());
 
-  for (const auto& namespace_name : namespace_names) {
-    auto namespace_id = VERIFY_RESULT(AddNamespaceInternal(namespace_name, l, epoch));
-    namespace_ids.push_back(std::move(namespace_id));
+  std::vector<NamespaceId> namespaces_added_now;
+  for (const auto& namespace_id : namespace_ids) {
+    auto added_now = VERIFY_RESULT(AddNamespaceInternal(namespace_id, l, epoch));
+    if (added_now) {
+      namespaces_added_now.push_back(namespace_id);
+    }
   }
+  if (namespaces_added_now.empty()) {
+    return Status::OK();
+  }
+
+  // Checkpoint tasks operate on namespace Ids. We currently cannot detect which task works on which
+  // namespace so we do not kill any when removing a namespace. Removing and re-adding the same
+  // namespace can cause an older task to incorrectly mark stale streams. To prevent this we make
+  // sure no tasks are running.
+  RETURN_NOT_OK(VerifyNoTasksInProgress());
+
   RETURN_NOT_OK(Upsert(l, epoch));
 
-  StartNamespaceCheckpointTasks(namespace_ids, epoch);
+  StartNamespaceCheckpointTasks(namespaces_added_now, epoch);
 
-  return namespace_ids;
+  return Status::OK();
 }
 
-Result<NamespaceId> XClusterOutboundReplicationGroup::AddNamespace(
-    const LeaderEpoch& epoch, const NamespaceName& namespace_name) {
-  NamespaceId namespace_id;
+Status XClusterOutboundReplicationGroup::AddNamespace(
+    const LeaderEpoch& epoch, const NamespaceId& namespace_id) {
   std::lock_guard mutex_lock(mutex_);
   auto l = VERIFY_RESULT(LockForWrite());
-  namespace_id = VERIFY_RESULT(AddNamespaceInternal(namespace_name, l, epoch));
+
+  auto added_now = VERIFY_RESULT(AddNamespaceInternal(namespace_id, l, epoch));
+  if (!added_now) {
+    // Already exists.
+    return Status::OK();
+  }
+
+  // Checkpoint tasks operate on namespace Ids. We currently cannot detect which task works on which
+  // namespace so we do not kill any when removing a namespace. Removing and re-adding the same
+  // namespace can cause an older task to incorrectly mark stale streams. To prevent this we make
+  // sure no tasks are running.
+  RETURN_NOT_OK(VerifyNoTasksInProgress());
+
   RETURN_NOT_OK(Upsert(l, epoch));
 
   StartNamespaceCheckpointTasks({namespace_id}, epoch);
 
-  return namespace_id;
+  return Status::OK();
 }
 
 Status XClusterOutboundReplicationGroup::DeleteNamespaceStreams(
@@ -468,11 +484,28 @@ Status XClusterOutboundReplicationGroup::DeleteNamespaceStreams(
 }
 
 Status XClusterOutboundReplicationGroup::RemoveNamespace(
-    const LeaderEpoch& epoch, const NamespaceId& namespace_id) {
+    const LeaderEpoch& epoch, const NamespaceId& namespace_id,
+    const std::vector<HostPort>& target_master_addresses) {
   std::lock_guard mutex_lock(mutex_);
   auto l = VERIFY_RESULT(LockForWrite());
   auto& outbound_group_pb = l.mutable_data()->pb;
 
+  if (!target_master_addresses.empty()) {
+    LOG(INFO) << "Removing Namespace from target " << AsString(target_master_addresses)
+              << " replication group " << Id();
+
+    SCHECK(
+        outbound_group_pb.has_target_universe_info(), IllegalState,
+        "Target universe info not found. xCluster replication must already be setup in order to "
+        "remove namespace from the target.");
+    auto target_uuid = VERIFY_RESULT(
+        UniverseUuid::FromString(outbound_group_pb.target_universe_info().universe_uuid()));
+
+    auto remote_client = VERIFY_RESULT(GetRemoteClient(target_master_addresses));
+    RETURN_NOT_OK(
+        (*remote_client)->RemoveNamespaceFromUniverseReplication(Id(), namespace_id, target_uuid));
+  }
+
   RETURN_NOT_OK(DeleteNamespaceStreams(epoch, namespace_id, outbound_group_pb));
 
   outbound_group_pb.mutable_namespace_infos()->erase(namespace_id);
@@ -480,11 +513,30 @@ Status XClusterOutboundReplicationGroup::RemoveNamespace(
   return Upsert(l, epoch);
 }
 
-Status XClusterOutboundReplicationGroup::Delete(const LeaderEpoch& epoch) {
+Status XClusterOutboundReplicationGroup::Delete(
+    const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch) {
+  CloseAndWaitForAllTasksToAbort();
+
   std::lock_guard mutex_lock(mutex_);
   auto l = VERIFY_RESULT(LockForWrite());
   auto& outbound_group_pb = l.mutable_data()->pb;
 
+  if (!target_master_addresses.empty()) {
+    LOG(INFO) << "Deleting replication group " << Id() << " from target "
+              << AsString(target_master_addresses);
+
+    SCHECK(
+        outbound_group_pb.has_target_universe_info(), IllegalState,
+        "Target universe info not found. xCluster replication must already be setup in order to "
+        "remove namespace from the target.");
+    auto target_uuid = VERIFY_RESULT(
+        UniverseUuid::FromString(outbound_group_pb.target_universe_info().universe_uuid()));
+
+    auto remote_client = VERIFY_RESULT(GetRemoteClient(target_master_addresses));
+    RETURN_NOT_OK(
+        (*remote_client)->DeleteUniverseReplication(Id(), /*ignore_errors=*/true, target_uuid));
+  }
+
   for (const auto& [namespace_id, _] : *outbound_group_pb.mutable_namespace_infos()) {
     RETURN_NOT_OK(DeleteNamespaceStreams(epoch, namespace_id, outbound_group_pb));
   }
@@ -703,6 +755,64 @@ Result<IsOperationDoneResult> XClusterOutboundReplicationGroup::IsCreateXCluster
   return setup_result;
 }
 
+Status XClusterOutboundReplicationGroup::AddNamespaceToTarget(
+    const std::vector<HostPort>& target_master_addresses, const NamespaceId& source_namespace_id,
+    const LeaderEpoch& epoch) const {
+  SharedLock mutex_lock(mutex_);
+  auto l = VERIFY_RESULT(LockForRead());
+  auto& outbound_group = l.data().pb;
+
+  SCHECK(
+      outbound_group.has_target_universe_info(), IllegalState,
+      "Target universe info not found. xCluster replication must already be setup in order to add "
+      "a new namespace to the target.");
+  auto target_uuid = VERIFY_RESULT(
+      UniverseUuid::FromString(outbound_group.target_universe_info().universe_uuid()));
+
+  SCHECK(
+      outbound_group.namespace_infos().count(source_namespace_id), NotFound,
+      Format("Namespace $0 not found in replication group $1", source_namespace_id, ToString()));
+
+  const auto& ns_info = outbound_group.namespace_infos().at(source_namespace_id);
+  SCHECK_EQ(
+      ns_info.state(), NamespaceInfoPB::READY, TryAgain,
+      Format("Namespace $0 is not yet ready to start replicating", source_namespace_id));
+
+  auto namespace_name = VERIFY_RESULT(GetNamespaceName(source_namespace_id));
+
+  std::vector<TableId> source_table_ids;
+  std::vector<xrepl::StreamId> bootstrap_ids;
+  for (const auto& [table_id, table_info] : ns_info.table_infos()) {
+    if (!table_info.is_part_of_initial_bootstrap()) {
+      // Only include tables that were part of the initial bootstrap as only those are backed up
+      // and restored on the target. The remaining will get added as DDLs execute.
+      continue;
+    }
+    // This is not expected since the namespace is marked ready.
+    RSTATUS_DCHECK(
+        !table_info.is_checkpointing(), IllegalState, Format("Table $0 is not yet ready"));
+
+    source_table_ids.push_back(table_id);
+    bootstrap_ids.push_back(VERIFY_RESULT(xrepl::StreamId::FromString(table_info.stream_id())));
+  }
+
+  auto remote_client = VERIFY_RESULT(GetRemoteClient(target_master_addresses));
+
+  RETURN_NOT_OK(remote_client->AddNamespaceToDbScopedUniverseReplication(
+      Id(), target_uuid, namespace_name, source_namespace_id, source_table_ids, bootstrap_ids));
+
+  // TODO(#20810): Start a async task that will poll for IsCreateXClusterReplicationDone and update
+  // the state.
+
+  return Status::OK();
+}
+
+Result<IsOperationDoneResult> XClusterOutboundReplicationGroup::IsAlterXClusterReplicationDone(
+    const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch) {
+  auto remote_client = VERIFY_RESULT(GetRemoteClient(target_master_addresses));
+  return remote_client->IsSetupUniverseReplicationDone(xcluster::GetAlterReplicationGroupId(Id()));
+}
+
 bool XClusterOutboundReplicationGroup::HasNamespace(const NamespaceId& namespace_id) const {
   SharedLock mutex_lock(mutex_);
   auto lock_result = LockForRead();
@@ -964,4 +1074,10 @@ Status XClusterOutboundReplicationGroup::RepairRemoveTable(
   return Upsert(l, epoch);
 }
 
+Status XClusterOutboundReplicationGroup::VerifyNoTasksInProgress() {
+  auto tasks = GetTasks();
+  SCHECK(tasks.empty(), IllegalState, "$0 has in progress tasks: $1", ToString(), AsString(tasks));
+  return Status::OK();
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.h b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
index 6b225d1dae..652c8e2bab 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.h
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
@@ -75,19 +75,20 @@ class XClusterOutboundReplicationGroup
 
   Result<SysXClusterOutboundReplicationGroupEntryPB> GetMetadata() const EXCLUDES(mutex_);
 
-  Result<std::vector<NamespaceId>> AddNamespaces(
-      const LeaderEpoch& epoch, const std::vector<NamespaceName>& namespace_names) EXCLUDES(mutex_);
-
-  Result<NamespaceId> AddNamespace(const LeaderEpoch& epoch, const NamespaceName& namespace_name)
+  Status AddNamespaces(const LeaderEpoch& epoch, const std::vector<NamespaceId>& namespace_ids)
       EXCLUDES(mutex_);
 
-  Status RemoveNamespace(const LeaderEpoch& epoch, const NamespaceId& namespace_id)
-      EXCLUDES(mutex_);
+  Status AddNamespace(const LeaderEpoch& epoch, const NamespaceId& namespace_id) EXCLUDES(mutex_);
+
+  Status RemoveNamespace(
+      const LeaderEpoch& epoch, const NamespaceId& namespace_id,
+      const std::vector<HostPort>& target_master_addresses) EXCLUDES(mutex_);
 
   Status RemoveStreams(const std::vector<CDCStreamInfo*>& streams, const LeaderEpoch& epoch)
       EXCLUDES(mutex_);
 
-  Status Delete(const LeaderEpoch& epoch) EXCLUDES(mutex_);
+  Status Delete(const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch)
+      EXCLUDES(mutex_);
 
   // Returns std::nullopt if the namespace is not yet ready.
   Result<std::optional<bool>> IsBootstrapRequired(const NamespaceId& namespace_id) const
@@ -109,6 +110,14 @@ class XClusterOutboundReplicationGroup
       const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch)
       EXCLUDES(mutex_);
 
+  Status AddNamespaceToTarget(
+      const std::vector<HostPort>& target_master_addresses, const NamespaceId& source_namespace_id,
+      const LeaderEpoch& epoch) const EXCLUDES(mutex_);
+
+  Result<IsOperationDoneResult> IsAlterXClusterReplicationDone(
+      const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch)
+      EXCLUDES(mutex_);
+
   bool HasNamespace(const NamespaceId& namespace_id) const EXCLUDES(mutex_);
 
   void StartPostLoadTasks(const LeaderEpoch& epoch) EXCLUDES(mutex_);
@@ -135,11 +144,11 @@ class XClusterOutboundReplicationGroup
   Result<XClusterOutboundReplicationGroupInfo::WriteLock> LockForWrite() REQUIRES(mutex_);
 
   Result<scoped_refptr<NamespaceInfo>> GetYbNamespaceInfo(const NamespaceId& namespace_id) const;
-  Result<NamespaceId> GetNamespaceId(const NamespaceName& namespace_name) const;
   Result<NamespaceName> GetNamespaceName(const NamespaceId& namespace_id) const;
 
-  Result<NamespaceId> AddNamespaceInternal(
-      const NamespaceName& namespace_name, XClusterOutboundReplicationGroupInfo::WriteLock& l,
+  // Returns true if we added the table. Returns false if the table already existed.
+  Result<bool> AddNamespaceInternal(
+      const NamespaceId& namespace_id, XClusterOutboundReplicationGroupInfo::WriteLock& l,
       const LeaderEpoch& epoch) REQUIRES(mutex_);
 
   Status Upsert(
@@ -220,6 +229,8 @@ class XClusterOutboundReplicationGroup
   void MarkCheckpointNamespaceAsFailed(
       const NamespaceId& namespace_id, const LeaderEpoch& epoch, const Status& status);
 
+  Status VerifyNoTasksInProgress() REQUIRES(mutex_);
+
   HelperFunctions helper_functions_;
 
   // Mutex used to ensure reads are not allowed when writes are happening.
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
index c27d8af821..7b95dfe24b 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
@@ -91,7 +91,7 @@ Status XClusterCheckpointNamespaceTask::MarkTablesAsCheckpointed(
     ScheduleNextStepWithDelay(
         std::bind(
             &XClusterCheckpointNamespaceTask::MarkTablesAsCheckpointed, this, std::move(result)),
-        "CheckpointStreams", MonoDelta::FromMilliseconds(100));
+        "MarkTablesAsCheckpointed", MonoDelta::FromMilliseconds(100));
     return Status::OK();
   }
 
diff --git a/src/yb/master/xcluster/xcluster_replication_group.cc b/src/yb/master/xcluster/xcluster_replication_group.cc
index c35202e0ef..7e2d546edd 100644
--- a/src/yb/master/xcluster/xcluster_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_replication_group.cc
@@ -281,7 +281,7 @@ Result<bool> ShouldAddTableToReplicationGroup(
     return false;
   }
 
-  if (universe_pb.has_db_scoped_info()) {
+  if (l->IsDbScoped()) {
     if (!IncludesConsumerNamespace(universe, table_info.namespace_id())) {
       return false;
     }
@@ -374,7 +374,7 @@ Result<std::shared_ptr<client::XClusterRemoteClient>> GetXClusterRemoteClient(
 
 Result<bool> IsSafeTimeReady(
     const SysUniverseReplicationEntryPB& universe_pb, const XClusterManagerIf& xcluster_manager) {
-  if (!universe_pb.has_db_scoped_info()) {
+  if (!IsDbScoped(universe_pb)) {
     // Only valid in Db scoped replication.
     return true;
   }
@@ -443,19 +443,72 @@ Result<IsOperationDoneResult> IsSetupUniverseReplicationDone(
   return is_done ? IsOperationDoneResult::Done() : IsOperationDoneResult::NotDone();
 }
 
+Status RemoveNamespaceFromReplicationGroup(
+    scoped_refptr<UniverseReplicationInfo> universe, const NamespaceId& producer_namespace_id,
+    CatalogManager& catalog_manager, const LeaderEpoch& epoch) {
+  SCHECK(
+      universe->IsDbScoped(), IllegalState, "Replication group $0 is not DB Scoped",
+      universe->id());
+
+  auto l = universe->LockForWrite();
+  auto& universe_pb = l.mutable_data()->pb;
+
+  NamespaceId consumer_namespace_id;
+  auto* namespace_infos = universe_pb.mutable_db_scoped_info()->mutable_namespace_infos();
+  for (auto it = namespace_infos->begin(); it != namespace_infos->end(); ++it) {
+    if (it->producer_namespace_id() == producer_namespace_id) {
+      consumer_namespace_id = it->consumer_namespace_id();
+      namespace_infos->erase(it);
+      break;
+    }
+  }
+  if (consumer_namespace_id.empty()) {
+    LOG(INFO) << "Producer Namespace " << producer_namespace_id
+              << " not found in xCluster replication group " << universe->ReplicationGroupId();
+    return Status::OK();
+  }
+
+  auto consumer_tables =
+      VERIFY_RESULT(catalog_manager.GetTableInfosForNamespace(consumer_namespace_id));
+  std::unordered_set<TableId> consumer_table_ids;
+  for (const auto& table_info : consumer_tables) {
+    consumer_table_ids.insert(table_info->id());
+  }
+
+  std::vector<TableId> producer_table_ids;
+  for (const auto& [producer_table_id, consumer_table_id] : universe_pb.validated_tables()) {
+    if (consumer_table_ids.contains(consumer_table_id)) {
+      producer_table_ids.push_back(producer_table_id);
+    }
+  }
+
+  // For DB Scoped replication the streams will be cleaned up when the namespace is removed from
+  // the outbound replication group on the source.
+  return RemoveTablesFromReplicationGroupInternal(
+      *universe, l, producer_table_ids, catalog_manager, epoch, /*cleanup_source_streams=*/false);
+}
+
 Status RemoveTablesFromReplicationGroup(
     scoped_refptr<UniverseReplicationInfo> universe, const std::vector<TableId>& producer_table_ids,
     CatalogManager& catalog_manager, const LeaderEpoch& epoch) {
+  auto l = universe->LockForWrite();
+  return RemoveTablesFromReplicationGroupInternal(
+      *universe, l, producer_table_ids, catalog_manager, epoch, /*cleanup_source_streams=*/true);
+}
+
+Status RemoveTablesFromReplicationGroupInternal(
+    UniverseReplicationInfo& universe, UniverseReplicationInfo::WriteLock& l,
+    const std::vector<TableId>& producer_table_ids, CatalogManager& catalog_manager,
+    const LeaderEpoch& epoch, bool cleanup_source_streams) {
   RSTATUS_DCHECK(!producer_table_ids.empty(), InvalidArgument, "No tables to remove");
 
-  auto& replication_group_id = universe->ReplicationGroupId();
+  auto& replication_group_id = universe.ReplicationGroupId();
 
   std::set<TableId> producer_table_ids_to_remove(
       producer_table_ids.begin(), producer_table_ids.end());
   std::set<TableId> consumer_table_ids_to_remove;
 
   // 1. Get the corresponding stream ids and consumer table ids for the tables to remove.
-  auto l = universe->LockForWrite();
   auto& universe_pb = l.mutable_data()->pb;
 
   // Filter out any tables that aren't in the existing replication config.
@@ -500,16 +553,16 @@ Status RemoveTablesFromReplicationGroup(
   }
 
   // 2. Delete xCluster streams on the Producer.
-  if (!streams_to_remove.empty()) {
+  if (!streams_to_remove.empty() && cleanup_source_streams) {
     auto rpc_task = VERIFY_RESULT(
-        universe->GetOrCreateXClusterRpcTasks(universe_pb.producer_master_addresses()));
+        universe.GetOrCreateXClusterRpcTasks(universe_pb.producer_master_addresses()));
 
     // Atomicity cannot be guaranteed for both producer and consumer deletion. So ignore any errors
     // due to missing streams.
     RETURN_NOT_OK_PREPEND(
         rpc_task->client()->DeleteCDCStream(
             streams_to_remove, true /* force_delete */, true /* remove_table_ignore_errors */),
-        "Unable to delete xCluster streams on source. Try setting the ignore-errors option");
+        "Unable to delete xCluster streams on source");
   }
 
   // 3. Update the Consumer Registry (removes from TServers) and Master Configs.
@@ -533,7 +586,7 @@ Status RemoveTablesFromReplicationGroup(
     Erase(table_id, universe_pb.mutable_tables());
   }
 
-  RETURN_NOT_OK(catalog_manager.sys_catalog()->Upsert(epoch, universe.get(), cluster_config.get()));
+  RETURN_NOT_OK(catalog_manager.sys_catalog()->Upsert(epoch, &universe, cluster_config.get()));
 
   // 4. Clear in-mem maps.
   catalog_manager.SyncXClusterConsumerReplicationStatusMap(replication_group_id, producer_map);
@@ -547,4 +600,41 @@ Status RemoveTablesFromReplicationGroup(
   return Status::OK();
 }
 
+Status ValidateTableListForDbScopedReplication(
+    UniverseReplicationInfo& universe, const std::vector<NamespaceId>& namespace_ids,
+    const std::set<TableId>& replicated_tables, const CatalogManager& catalog_manager) {
+  std::set<TableId> validated_tables;
+
+  for (const auto& namespace_id : namespace_ids) {
+    auto table_infos =
+        VERIFY_RESULT(GetTablesEligibleForXClusterReplication(catalog_manager, namespace_id));
+
+    std::vector<TableId> missing_tables;
+
+    for (const auto& table_info : table_infos) {
+      const auto& table_id = table_info->id();
+      if (replicated_tables.contains(table_id)) {
+        validated_tables.insert(table_id);
+      } else {
+        missing_tables.push_back(table_id);
+      }
+    }
+
+    SCHECK_FORMAT(
+        missing_tables.empty(), IllegalState,
+        "Namespace $0 has additional tables that were not added to xCluster DB Scoped replication "
+        "group $1: $2",
+        namespace_id, universe.id(), yb::ToString(missing_tables));
+  }
+
+  auto diff = STLSetSymmetricDifference(replicated_tables, validated_tables);
+  SCHECK_FORMAT(
+      diff.empty(), IllegalState,
+      "xCluster DB Scoped replication group $0 contains tables $1 that do not belong to replicated "
+      "namespaces $2",
+      universe.id(), yb::ToString(diff), yb::ToString(namespace_ids));
+
+  return Status::OK();
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_replication_group.h b/src/yb/master/xcluster/xcluster_replication_group.h
index ab5a94911b..6208a52bf4 100644
--- a/src/yb/master/xcluster/xcluster_replication_group.h
+++ b/src/yb/master/xcluster/xcluster_replication_group.h
@@ -85,5 +85,18 @@ Status RemoveTablesFromReplicationGroup(
     scoped_refptr<UniverseReplicationInfo> universe, const std::vector<TableId>& producer_table_ids,
     CatalogManager& catalog_manager, const LeaderEpoch& epoch);
 
+Status RemoveTablesFromReplicationGroupInternal(
+    UniverseReplicationInfo& universe, UniverseReplicationInfo::WriteLock& l,
+    const std::vector<TableId>& producer_table_ids, CatalogManager& catalog_manager,
+    const LeaderEpoch& epoch, bool cleanup_source_streams);
+
+Status RemoveNamespaceFromReplicationGroup(
+    scoped_refptr<UniverseReplicationInfo> universe, const NamespaceId& producer_namespace_id,
+    CatalogManager& catalog_manager, const LeaderEpoch& epoch);
+
+Status ValidateTableListForDbScopedReplication(
+    UniverseReplicationInfo& universe, const std::vector<NamespaceId>& namespace_ids,
+    const std::set<TableId>& replicated_table_ids, const CatalogManager& catalog_manager);
+
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index 7ba62cef09..6bd17fc83d 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -183,7 +183,10 @@ XClusterSourceManager::InitOutboundReplicationGroup(
           [&catalog_manager = catalog_manager_](const NamespaceIdentifierPB& ns_identifier) {
             return catalog_manager.FindNamespace(ns_identifier);
           },
-      .get_tables_func = std::bind(&XClusterSourceManager::GetTablesToReplicate, this, _1),
+      .get_tables_func =
+          [&catalog_manager = catalog_manager_](const NamespaceId& namespace_id) {
+            return GetTablesEligibleForXClusterReplication(catalog_manager, namespace_id);
+          },
       .create_xcluster_streams_func =
           std::bind(&XClusterSourceManager::CreateStreamsForDbScoped, this, _1, _2),
       .checkpoint_xcluster_streams_func =
@@ -227,15 +230,6 @@ XClusterSourceManager::GetOutboundReplicationGroup(
   return *outbound_replication_group;
 }
 
-Result<std::vector<TableInfoPtr>> XClusterSourceManager::GetTablesToReplicate(
-    const NamespaceId& namespace_id) {
-  auto table_infos = VERIFY_RESULT(catalog_manager_.GetTableInfosForNamespace(namespace_id));
-  EraseIf(
-      [](const TableInfoPtr& table) { return !IsTableEligibleForXClusterReplication(*table); },
-      &table_infos);
-  return table_infos;
-}
-
 std::vector<std::shared_ptr<PostTabletCreateTaskBase>>
 XClusterSourceManager::GetPostTabletCreateTasks(
     const TableInfoPtr& table_info, const LeaderEpoch& epoch) {
@@ -272,9 +266,9 @@ std::optional<uint32> XClusterSourceManager::GetDefaultWalRetentionSec(
   return std::nullopt;
 }
 
-Result<std::vector<NamespaceId>> XClusterSourceManager::CreateOutboundReplicationGroup(
+Status XClusterSourceManager::CreateOutboundReplicationGroup(
     const xcluster::ReplicationGroupId& replication_group_id,
-    const std::vector<NamespaceName>& namespace_names, const LeaderEpoch& epoch) {
+    const std::vector<NamespaceId>& namespace_ids, const LeaderEpoch& epoch) {
   {
     std::lock_guard l(outbound_replication_group_map_mutex_);
     SCHECK(
@@ -295,8 +289,7 @@ Result<std::vector<NamespaceId>> XClusterSourceManager::CreateOutboundReplicatio
   auto outbound_replication_group = InitOutboundReplicationGroup(replication_group_id, metadata);
 
   // This will persist the group to SysCatalog.
-  auto namespace_ids =
-      VERIFY_RESULT(outbound_replication_group->AddNamespaces(epoch, namespace_names));
+  RETURN_NOT_OK(outbound_replication_group->AddNamespaces(epoch, namespace_ids));
 
   se.Cancel();
   {
@@ -304,34 +297,37 @@ Result<std::vector<NamespaceId>> XClusterSourceManager::CreateOutboundReplicatio
     outbound_replication_group_map_[replication_group_id] = std::move(outbound_replication_group);
   }
 
-  return namespace_ids;
+  return Status::OK();
 }
 
-Result<NamespaceId> XClusterSourceManager::AddNamespaceToOutboundReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id, const NamespaceName& namespace_name,
+Status XClusterSourceManager::AddNamespaceToOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
     const LeaderEpoch& epoch) {
   auto outbound_replication_group =
       VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
 
-  return outbound_replication_group->AddNamespace(epoch, namespace_name);
+  RETURN_NOT_OK(outbound_replication_group->AddNamespace(epoch, namespace_id));
+
+  return Status::OK();
 }
 
 Status XClusterSourceManager::RemoveNamespaceFromOutboundReplicationGroup(
     const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
-    const LeaderEpoch& epoch) {
+    const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch) {
   auto outbound_replication_group =
       VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
 
-  return outbound_replication_group->RemoveNamespace(epoch, namespace_id);
+  return outbound_replication_group->RemoveNamespace(epoch, namespace_id, target_master_addresses);
 }
 
 Status XClusterSourceManager::DeleteOutboundReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id, const LeaderEpoch& epoch) {
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch) {
   auto outbound_replication_group =
       VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
 
   // This will remove the group from SysCatalog.
-  RETURN_NOT_OK(outbound_replication_group->Delete(epoch));
+  RETURN_NOT_OK(outbound_replication_group->Delete(target_master_addresses, epoch));
 
   {
     std::lock_guard l(outbound_replication_group_map_mutex_);
@@ -378,6 +374,24 @@ Result<IsOperationDoneResult> XClusterSourceManager::IsCreateXClusterReplication
       target_master_addresses, epoch);
 }
 
+Status XClusterSourceManager::AddNamespaceToTarget(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::vector<HostPort>& target_master_addresses, const NamespaceId& source_namespace_id,
+    const LeaderEpoch& epoch) {
+  auto outbound_replication_group =
+      VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
+  return outbound_replication_group->AddNamespaceToTarget(
+      target_master_addresses, source_namespace_id, epoch);
+}
+
+Result<IsOperationDoneResult> XClusterSourceManager::IsAlterXClusterReplicationDone(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch) {
+  auto outbound_replication_group =
+      VERIFY_RESULT(GetOutboundReplicationGroup(replication_group_id));
+  return outbound_replication_group->IsAlterXClusterReplicationDone(target_master_addresses, epoch);
+}
+
 class XClusterCreateStreamContextImpl : public XClusterCreateStreamsContext {
  public:
   explicit XClusterCreateStreamContextImpl(
diff --git a/src/yb/master/xcluster/xcluster_source_manager.h b/src/yb/master/xcluster/xcluster_source_manager.h
index 7748f995f3..d463e01d44 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.h
+++ b/src/yb/master/xcluster/xcluster_source_manager.h
@@ -97,20 +97,21 @@ class XClusterSourceManager {
   std::vector<std::shared_ptr<PostTabletCreateTaskBase>> GetPostTabletCreateTasks(
       const TableInfoPtr& table_info, const LeaderEpoch& epoch);
 
-  Result<std::vector<NamespaceId>> CreateOutboundReplicationGroup(
+  Status CreateOutboundReplicationGroup(
       const xcluster::ReplicationGroupId& replication_group_id,
-      const std::vector<NamespaceName>& namespace_names, const LeaderEpoch& epoch);
+      const std::vector<NamespaceId>& namespace_ids, const LeaderEpoch& epoch);
 
-  Result<NamespaceId> AddNamespaceToOutboundReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id, const NamespaceName& namespace_name,
+  Status AddNamespaceToOutboundReplicationGroup(
+      const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
       const LeaderEpoch& epoch);
 
   Status RemoveNamespaceFromOutboundReplicationGroup(
       const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId& namespace_id,
-      const LeaderEpoch& epoch);
+      const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch);
 
   Status DeleteOutboundReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id, const LeaderEpoch& epoch);
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch);
 
   Result<std::optional<bool>> IsBootstrapRequired(
       const xcluster::ReplicationGroupId& replication_group_id,
@@ -128,6 +129,15 @@ class XClusterSourceManager {
       const xcluster::ReplicationGroupId& replication_group_id,
       const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch);
 
+  Status AddNamespaceToTarget(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::vector<HostPort>& target_master_addresses, const NamespaceId& source_namespace_id,
+      const LeaderEpoch& epoch);
+
+  Result<IsOperationDoneResult> IsAlterXClusterReplicationDone(
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::vector<HostPort>& target_master_addresses, const LeaderEpoch& epoch);
+
   Status PopulateXClusterStatus(
       XClusterStatus& xcluster_status, const SysXClusterConfigEntryPB& xcluster_config) const;
 
@@ -173,8 +183,6 @@ class XClusterSourceManager {
       const xcluster::ReplicationGroupId& replication_group_id) const
       EXCLUDES(outbound_replication_group_map_mutex_);
 
-  Result<std::vector<TableInfoPtr>> GetTablesToReplicate(const NamespaceId& namespace_id);
-
   Result<std::unique_ptr<XClusterCreateStreamsContext>> CreateStreamsForDbScoped(
       const std::vector<TableId>& table_ids, const LeaderEpoch& epoch);
 
diff --git a/src/yb/master/xrepl_catalog_manager.cc b/src/yb/master/xrepl_catalog_manager.cc
index c56c9473d4..cd6ad508ce 100644
--- a/src/yb/master/xrepl_catalog_manager.cc
+++ b/src/yb/master/xrepl_catalog_manager.cc
@@ -176,6 +176,23 @@ using client::internal::RemoteTabletServer;
 namespace master {
 using TableMetaPB = ImportSnapshotMetaResponsePB::TableMetaPB;
 
+namespace {
+
+template <typename RequestType>
+Status ValidateUniverseUUID(const RequestType& req, CatalogManager& catalog_manager) {
+  if (req->has_universe_uuid() && !req->universe_uuid().empty()) {
+    auto universe_uuid = catalog_manager.GetUniverseUuidIfExists();
+    SCHECK(
+        universe_uuid && universe_uuid->ToString() == req->universe_uuid(), InvalidArgument,
+        "Invalid Universe UUID $0. Expected $1", req->universe_uuid(),
+        (universe_uuid ? universe_uuid->ToString() : "empty"));
+  }
+
+  return Status::OK();
+}
+
+}  // namespace
+
 ////////////////////////////////////////////////////////////
 // CDC Stream Loader
 ////////////////////////////////////////////////////////////
@@ -3241,28 +3258,32 @@ Status CatalogManager::SetupUniverseReplication(
     }
   }
 
-  SCHECK_EQ(
-      req->namespace_names_size(), req->producer_namespace_ids_size(), InvalidArgument,
-      "Incorrect number of namespace names and producer namespace ids");
   SCHECK(
-      req->namespace_names_size() == 0 || req->transactional(), InvalidArgument,
+      req->producer_namespaces().empty() || req->transactional(), InvalidArgument,
       "Transactional flag must be set for Db scoped replication groups");
 
   std::vector<NamespaceId> producer_namespace_ids, consumer_namespace_ids;
-  for (int i = 0; i < req->namespace_names_size(); ++i) {
-    NamespaceIdentifierPB ns_id;
-    ns_id.set_database_type(YQLDatabase::YQL_DATABASE_PGSQL);
-    ns_id.set_name(req->namespace_names(i));
-    auto ns_info = VERIFY_RESULT(FindNamespace(ns_id));
+  for (const auto& producer_ns_id : req->producer_namespaces()) {
+    SCHECK(!producer_ns_id.id().empty(), InvalidArgument, "Invalid Namespace Id");
+    SCHECK(!producer_ns_id.name().empty(), InvalidArgument, "Invalid Namespace name");
+    SCHECK_EQ(
+        producer_ns_id.database_type(), YQLDatabase::YQL_DATABASE_PGSQL, InvalidArgument,
+        "Invalid Namespace database_type");
+
+    producer_namespace_ids.push_back(producer_ns_id.id());
+
+    NamespaceIdentifierPB consumer_ns_id;
+    consumer_ns_id.set_database_type(YQLDatabase::YQL_DATABASE_PGSQL);
+    consumer_ns_id.set_name(producer_ns_id.name());
+    auto ns_info = VERIFY_RESULT(FindNamespace(consumer_ns_id));
     consumer_namespace_ids.push_back(ns_info->id());
-    producer_namespace_ids.push_back(req->producer_namespace_ids(i));
   }
 
   // We should set the universe uuid even if we fail with AlreadyPresent error.
   {
-    auto l = ClusterConfig()->LockForRead();
-    if (l->pb.has_universe_uuid()) {
-      resp->set_universe_uuid(l->pb.universe_uuid());
+    auto universe_uuid = GetUniverseUuidIfExists();
+    if (universe_uuid) {
+      resp->set_universe_uuid(universe_uuid->ToString());
     }
   }
 
@@ -4009,12 +4030,22 @@ void CatalogManager::AddCDCStreamToUniverseAndInitConsumer(
     }
   }
 
+  Status s;
   if (!stream_id.ok()) {
-    LOG(ERROR) << "Error setting up CDC stream for table " << table_id;
-    MarkUniverseReplicationFailed(universe, ResultToStatus(stream_id));
-    return;
+    s = std::move(stream_id).status();
+  } else {
+    s = AddCDCStreamToUniverseAndInitConsumerInternal(
+        universe, table_id, *stream_id, std::move(on_success_cb));
+  }
+
+  if (!s.ok()) {
+    MarkUniverseReplicationFailed(universe, s);
   }
+}
 
+Status CatalogManager::AddCDCStreamToUniverseAndInitConsumerInternal(
+    scoped_refptr<UniverseReplicationInfo> universe, const TableId& table_id,
+    const xrepl::StreamId& stream_id, std::function<void()> on_success_cb) {
   bool merge_alter = false;
   bool validated_all_tables = false;
   std::vector<XClusterConsumerStreamInfo> consumer_info;
@@ -4022,7 +4053,7 @@ void CatalogManager::AddCDCStreamToUniverseAndInitConsumer(
     auto l = universe->LockForWrite();
     if (l->is_deleted_or_failed()) {
       // Nothing to do if universe is being deleted.
-      return;
+      return Status::OK();
     }
 
     auto map = l.mutable_data()->pb.mutable_table_streams();
@@ -4034,56 +4065,40 @@ void CatalogManager::AddCDCStreamToUniverseAndInitConsumer(
       validated_all_tables = true;
       LOG(INFO) << "Registering CDC consumers for universe " << universe->id();
 
-      auto& validated_tables = l->pb.validated_tables();
-
       consumer_info.reserve(l->pb.tables_size());
-      bool failed = false;
-      for (const auto& [producer_table_id, consumer_table_id] : validated_tables) {
-        auto stream_id_result = xrepl::StreamId::FromString((*map)[producer_table_id]);
-        if (!stream_id_result) {
-          LOG(WARNING) << "Invalid StreamId for producer tablet: " << producer_table_id
-                       << " consumer tablet: " << consumer_table_id << ": "
-                       << stream_id_result.status();
-          l.mutable_data()->pb.set_state(SysUniverseReplicationEntryPB::FAILED);
-          failed = true;
-          break;
-        }
+      std::set<TableId> consumer_table_ids;
+      for (const auto& [producer_table_id, consumer_table_id] : l->pb.validated_tables()) {
+        consumer_table_ids.insert(consumer_table_id);
 
         XClusterConsumerStreamInfo info;
         info.producer_table_id = producer_table_id;
         info.consumer_table_id = consumer_table_id;
-        info.stream_id = *stream_id_result;
+        info.stream_id = VERIFY_RESULT(xrepl::StreamId::FromString((*map)[producer_table_id]));
         consumer_info.push_back(info);
       }
 
-      if (!failed) {
-        std::vector<HostPort> hp;
-        HostPortsFromPBs(l->pb.producer_master_addresses(), &hp);
-
-        auto xcluster_rpc_tasks_result =
-            universe->GetOrCreateXClusterRpcTasks(l->pb.producer_master_addresses());
-        if (!xcluster_rpc_tasks_result.ok()) {
-          LOG(WARNING) << "CDC streams won't be created: " << xcluster_rpc_tasks_result;
-          l.mutable_data()->pb.set_state(SysUniverseReplicationEntryPB::FAILED);
-        } else {
-          auto xcluster_rpc_tasks = *xcluster_rpc_tasks_result;
-          Status s = InitXClusterConsumer(
-              consumer_info, HostPort::ToCommaSeparatedString(hp), *universe.get(),
-              xcluster_rpc_tasks);
-          if (!s.ok()) {
-            LOG(ERROR) << "Universe replication " << replication_group_id
-                       << " failed. Error registering subscriber: " << s;
-            l.mutable_data()->pb.set_state(SysUniverseReplicationEntryPB::FAILED);
-            universe->SetSetupUniverseReplicationErrorStatus(s);
-          } else {
-            if (xcluster::IsAlterReplicationGroupId(universe->ReplicationGroupId())) {
-              // Don't enable ALTER universes, merge them into the main universe instead.
-              merge_alter = true;
-            } else {
-              l.mutable_data()->pb.set_state(SysUniverseReplicationEntryPB::ACTIVE);
-            }
-          }
+      if (l->IsDbScoped()) {
+        std::vector<NamespaceId> consumer_namespace_ids;
+        for (const auto& ns_info : l->pb.db_scoped_info().namespace_infos()) {
+          consumer_namespace_ids.push_back(ns_info.consumer_namespace_id());
         }
+        RETURN_NOT_OK(ValidateTableListForDbScopedReplication(
+            *universe, consumer_namespace_ids, consumer_table_ids, *this));
+      }
+
+      std::vector<HostPort> hp;
+      HostPortsFromPBs(l->pb.producer_master_addresses(), &hp);
+      auto xcluster_rpc_tasks =
+          VERIFY_RESULT(universe->GetOrCreateXClusterRpcTasks(l->pb.producer_master_addresses()));
+      RETURN_NOT_OK(InitXClusterConsumer(
+          consumer_info, HostPort::ToCommaSeparatedString(hp), *universe.get(),
+          xcluster_rpc_tasks));
+
+      if (xcluster::IsAlterReplicationGroupId(universe->ReplicationGroupId())) {
+        // Don't enable ALTER universes, merge them into the main universe instead.
+        merge_alter = true;
+      } else {
+        l.mutable_data()->pb.set_state(SysUniverseReplicationEntryPB::ACTIVE);
       }
     }
 
@@ -4108,11 +4123,13 @@ void CatalogManager::AddCDCStreamToUniverseAndInitConsumer(
     // Update the in-memory cache of consumer tables.
     LockGuard lock(mutex_);
     for (const auto& info : consumer_info) {
-      auto c_table_id = info.consumer_table_id;
-      auto c_stream_id = info.stream_id;
+      const auto& c_table_id = info.consumer_table_id;
+      const auto& c_stream_id = info.stream_id;
       xcluster_consumer_table_stream_ids_map_[c_table_id].emplace(final_id, c_stream_id);
     }
   }
+
+  return Status::OK();
 }
 
 /*
@@ -4265,7 +4282,7 @@ Status CatalogManager::InitXClusterConsumer(
   auto* consumer_registry = l.mutable_data()->pb.mutable_consumer_registry();
   auto transactional = universe_l->pb.transactional();
   if (!xcluster::IsAlterReplicationGroupId(replication_info.ReplicationGroupId())) {
-    if (universe_l->pb.has_db_scoped_info()) {
+    if (universe_l->IsDbScoped()) {
       DCHECK(transactional);
     }
   }
@@ -4391,16 +4408,28 @@ void CatalogManager::MergeUniverseReplication(
 
     // Merge Master Config on Consumer. (no need for Producer changes, since it uses stream_id)
     // Merge Table->StreamID mapping.
-    auto at = alter_lock.mutable_data()->pb.mutable_tables();
-    original_lock.mutable_data()->pb.mutable_tables()->MergeFrom(*at);
-    at->Clear();
-    auto as = alter_lock.mutable_data()->pb.mutable_table_streams();
-    original_lock.mutable_data()->pb.mutable_table_streams()->insert(as->begin(), as->end());
-    as->clear();
-    auto av = alter_lock.mutable_data()->pb.mutable_validated_tables();
-    original_lock.mutable_data()->pb.mutable_validated_tables()->insert(av->begin(), av->end());
-    av->clear();
-    alter_lock.mutable_data()->pb.set_state(SysUniverseReplicationEntryPB::DELETED);
+    auto& alter_pb = alter_lock.mutable_data()->pb;
+    auto& original_pb = original_lock.mutable_data()->pb;
+
+    auto* alter_tables = alter_pb.mutable_tables();
+    original_pb.mutable_tables()->MergeFrom(*alter_tables);
+    alter_tables->Clear();
+    auto* alter_table_streams = alter_pb.mutable_table_streams();
+    original_pb.mutable_table_streams()->insert(
+        alter_table_streams->begin(), alter_table_streams->end());
+    alter_table_streams->clear();
+    auto* alter_validated_tables = alter_pb.mutable_validated_tables();
+    original_pb.mutable_validated_tables()->insert(
+        alter_validated_tables->begin(), alter_validated_tables->end());
+    alter_validated_tables->clear();
+    if (alter_lock.mutable_data()->IsDbScoped()) {
+      auto* alter_namespace_info = alter_pb.mutable_db_scoped_info()->mutable_namespace_infos();
+      original_pb.mutable_db_scoped_info()->mutable_namespace_infos()->MergeFrom(
+          *alter_namespace_info);
+      alter_namespace_info->Clear();
+    }
+
+    alter_pb.set_state(SysUniverseReplicationEntryPB::DELETED);
 
     if (PREDICT_FALSE(FLAGS_TEST_exit_unfinished_merging)) {
       // Exit for texting services
@@ -4465,6 +4494,12 @@ Status CatalogManager::DeleteUniverseReplication(
   auto l = ri->LockForWrite();
   l.mutable_data()->pb.set_state(SysUniverseReplicationEntryPB::DELETED);
 
+  // We can skip the deletion of individual streams for DB Scoped replication since deletion of the
+  // outbound replication group will clean it up.
+  if (l->IsDbScoped()) {
+    skip_producer_stream_deletion = true;
+  }
+
   // Delete subscribers on the Consumer Registry (removes from TServers).
   LOG(INFO) << "Deleting subscribers for producer " << replication_group_id;
   {
@@ -4564,6 +4599,8 @@ Status CatalogManager::DeleteUniverseReplication(
         MasterError(MasterErrorPB::INVALID_REQUEST));
   }
 
+  RETURN_NOT_OK(ValidateUniverseUUID(req, *this));
+
   RETURN_NOT_OK(DeleteUniverseReplication(
       xcluster::ReplicationGroupId(req->replication_group_id()), req->ignore_errors(),
       req->skip_producer_stream_deletion(), resp));
@@ -4783,6 +4820,8 @@ Status CatalogManager::AlterUniverseReplication(
 
   SCHECK_PB_FIELDS_ARE_SET(*req, replication_group_id);
 
+  RETURN_NOT_OK(ValidateUniverseUUID(req, *this));
+
   auto replication_group_id = xcluster::ReplicationGroupId(req->replication_group_id());
   auto original_ri = GetUniverseReplication(replication_group_id);
   SCHECK_EC_FORMAT(
@@ -4793,7 +4832,8 @@ Status CatalogManager::AlterUniverseReplication(
   int config_count = (req->producer_master_addresses_size() > 0 ? 1 : 0) +
                      (req->producer_table_ids_to_remove_size() > 0 ? 1 : 0) +
                      (req->producer_table_ids_to_add_size() > 0 ? 1 : 0) +
-                     (req->has_new_replication_group_id() ? 1 : 0);
+                     (req->has_new_replication_group_id() ? 1 : 0) +
+                     (!req->producer_namespace_id_to_remove().empty() ? 1 : 0);
   SCHECK_EC_FORMAT(
       config_count == 1, InvalidArgument, MasterError(MasterErrorPB::INVALID_REQUEST),
       "Only 1 Alter operation per request currently supported: $0", req->ShortDebugString());
@@ -4802,6 +4842,11 @@ Status CatalogManager::AlterUniverseReplication(
     return UpdateProducerAddress(original_ri, req);
   }
 
+  if (req->has_producer_namespace_id_to_remove()) {
+    return RemoveNamespaceFromReplicationGroup(
+        original_ri, req->producer_namespace_id_to_remove(), *this, epoch);
+  }
+
   if (req->producer_table_ids_to_remove_size() > 0) {
     std::vector<TableId> table_ids(
         req->producer_table_ids_to_remove().begin(), req->producer_table_ids_to_remove().end());
@@ -4876,18 +4921,40 @@ Status CatalogManager::UpdateProducerAddress(
 Status CatalogManager::AddTablesToReplication(
     scoped_refptr<UniverseReplicationInfo> universe, const AlterUniverseReplicationRequestPB* req,
     AlterUniverseReplicationResponsePB* resp, rpc::RpcContext* rpc) {
-  CHECK_GT(req->producer_table_ids_to_add_size() , 0);
+  SCHECK_GT(req->producer_table_ids_to_add_size(), 0, InvalidArgument, "No tables specified");
+
+  if (universe->IsDbScoped()) {
+    // We either add the entire namespace at once, or one table at a time as they get created.
+    if (req->has_producer_namespace_to_add()) {
+      SCHECK(
+          !req->producer_namespace_to_add().id().empty(), InvalidArgument, "Invalid Namespace Id");
+      SCHECK(
+          !req->producer_namespace_to_add().name().empty(), InvalidArgument,
+          "Invalid Namespace name");
+      SCHECK_EQ(
+          req->producer_namespace_to_add().database_type(), YQLDatabase::YQL_DATABASE_PGSQL,
+          InvalidArgument, "Invalid Namespace database_type");
+    } else {
+      SCHECK_EQ(
+          req->producer_table_ids_to_add_size(), 1, InvalidArgument,
+          "When adding more than table to a DB scoped replication the namespace info must also be "
+          "provided");
+    }
+  } else {
+    SCHECK(
+        !req->has_producer_namespace_to_add(), InvalidArgument,
+        "Cannot add namespaces to non DB scoped replication");
+  }
 
   xcluster::ReplicationGroupId alter_replication_group_id(xcluster::GetAlterReplicationGroupId(
       xcluster::ReplicationGroupId(req->replication_group_id())));
 
   // If user passed in bootstrap ids, check that there is a bootstrap id for every table.
-  if (req->producer_bootstrap_ids_to_add().size() > 0 &&
-      req->producer_table_ids_to_add().size() != req->producer_bootstrap_ids_to_add().size()) {
-    return STATUS(
-        InvalidArgument, "Number of bootstrap ids must be equal to number of tables",
-        req->ShortDebugString(), MasterError(MasterErrorPB::INVALID_REQUEST));
-  }
+  SCHECK(
+      req->producer_bootstrap_ids_to_add_size() == 0 ||
+          req->producer_table_ids_to_add_size() == req->producer_bootstrap_ids_to_add().size(),
+      InvalidArgument, "Number of bootstrap ids must be equal to number of tables",
+      req->ShortDebugString());
 
   // Verify no 'alter' command running.
   scoped_refptr<UniverseReplicationInfo> alter_ri;
@@ -4944,11 +5011,11 @@ Status CatalogManager::AddTablesToReplication(
   // Only add new tables.  Ignore tables that are currently being replicated.
   auto tid_iter = req->producer_table_ids_to_add();
   std::unordered_set<string> new_tables(tid_iter.begin(), tid_iter.end());
-  {
-    auto l = universe->LockForRead();
-    for (const auto& table_id : l->pb.tables()) {
-      new_tables.erase(table_id);
-    }
+  auto original_universe_l = universe->LockForRead();
+  auto& original_universe_pb = original_universe_l->pb;
+
+  for (const auto& table_id : original_universe_pb.tables()) {
+    new_tables.erase(table_id);
   }
   if (new_tables.empty()) {
     return STATUS(
@@ -4961,7 +5028,13 @@ Status CatalogManager::AddTablesToReplication(
   master::SetupUniverseReplicationResponsePB setup_resp;
   setup_req.set_replication_group_id(alter_replication_group_id.ToString());
   setup_req.mutable_producer_master_addresses()->CopyFrom(
-      universe->LockForRead()->pb.producer_master_addresses());
+      original_universe_pb.producer_master_addresses());
+  setup_req.set_transactional(original_universe_pb.transactional());
+
+  if (req->has_producer_namespace_to_add()) {
+    *setup_req.add_producer_namespaces() = req->producer_namespace_to_add();
+  }
+
   for (const auto& table_id : new_tables) {
     setup_req.add_producer_table_ids(table_id);
 
diff --git a/src/yb/tools/yb-admin_cli.cc b/src/yb/tools/yb-admin_cli.cc
index 19fa50bddf..d0fa5e32f3 100644
--- a/src/yb/tools/yb-admin_cli.cc
+++ b/src/yb/tools/yb-admin_cli.cc
@@ -40,6 +40,7 @@
 
 #include "yb/cdc/cdc_service.h"
 
+#include "yb/client/xcluster_client.h"
 #include "yb/common/hybrid_time.h"
 #include "yb/common/json_util.h"
 
@@ -2026,7 +2027,8 @@ const auto alter_universe_replication_args =
     "add_table [<comma_separated_list_of_table_ids>] "
     "[<comma_separated_list_of_producer_bootstrap_ids>] | "
     "remove_table [<comma_separated_list_of_table_ids>] [ignore-errors] | "
-    "rename_id <new_producer_universe_id>)";
+    "rename_id <new_producer_universe_id> | "
+    "remove_namespace <source_namespace_id>)";
 Status alter_universe_replication_action(
     const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
   if (args.size() < 3 || args.size() > 4) {
@@ -2043,6 +2045,7 @@ Status alter_universe_replication_action(
   vector<string> bootstrap_ids_to_add;
   string new_replication_group_id = "";
   bool remove_table_ignore_errors = false;
+  NamespaceId source_namespace_to_remove;
 
   vector<string> newElem, *lst;
   if (args[1] == "set_master_addresses") {
@@ -2057,6 +2060,9 @@ Status alter_universe_replication_action(
   } else if (args[1] == "rename_id") {
     lst = nullptr;
     new_replication_group_id = args[2];
+  } else if (args[1] == "remove_namespace") {
+    lst = nullptr;
+    source_namespace_to_remove = args[2];
   } else {
     return ClusterAdminCli::kInvalidArguments;
   }
@@ -2073,7 +2079,7 @@ Status alter_universe_replication_action(
   RETURN_NOT_OK_PREPEND(
       client->AlterUniverseReplication(
           replication_group_id, master_addresses, add_tables, remove_tables, bootstrap_ids_to_add,
-          new_replication_group_id, remove_table_ignore_errors),
+          new_replication_group_id, source_namespace_to_remove, remove_table_ignore_errors),
       Format("Unable to alter replication for universe $0", replication_group_id));
 
   return Status::OK();
@@ -2258,7 +2264,7 @@ Status get_xcluster_safe_time_action(
   return PrintJsonResult(client->GetXClusterSafeTime(include_lag_and_skew));
 }
 
-const auto create_xcluster_checkpoint_args = "<replication_group_id> <database_names>";
+const auto create_xcluster_checkpoint_args = "<replication_group_id> <namespace_names>";
 Status create_xcluster_checkpoint_action(
     const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
   if (args.size() != 2) {
@@ -2268,13 +2274,16 @@ Status create_xcluster_checkpoint_action(
   auto replication_group_id = xcluster::ReplicationGroupId(args[0]);
   std::vector<NamespaceName> namespace_names;
   boost::split(namespace_names, args[1], boost::is_any_of(","));
+  std::vector<NamespaceName> namespace_ids;
 
-  auto namespace_ids =
-      VERIFY_RESULT(client->CheckpointXClusterReplication(replication_group_id, namespace_names));
+  for (const auto& namespace_name : namespace_names) {
+    const auto& namespace_info = VERIFY_RESULT_REF(
+        client->GetNamespaceInfo(YQLDatabase::YQL_DATABASE_PGSQL, namespace_name));
+    namespace_ids.push_back(namespace_info.id());
+  }
 
-  SCHECK_EQ(
-      namespace_ids.size(), namespace_names.size(), IllegalState,
-      "Number of namespace ids does not match number of namespace names");
+  RETURN_NOT_OK(
+      client->XClusterClient().CreateOutboundReplicationGroup(replication_group_id, namespace_ids));
 
   std::cout << "Waiting for checkpointing of database(s) to complete" << std::endl << std::endl;
 
@@ -2311,7 +2320,7 @@ Status create_xcluster_checkpoint_action(
   return Status::OK();
 }
 
-const auto is_xcluster_bootstrap_required_args = "<replication_group_id> <database_names>";
+const auto is_xcluster_bootstrap_required_args = "<replication_group_id> <namespace_names>";
 Status is_xcluster_bootstrap_required_action(
     const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
   if (args.size() != 2) {
@@ -2347,7 +2356,8 @@ Status setup_xcluster_replication_action(
 
   auto replication_group_id = xcluster::ReplicationGroupId(args[0]);
 
-  RETURN_NOT_OK(client->CreateXClusterReplication(replication_group_id, args[1]));
+  RETURN_NOT_OK(client->XClusterClient().CreateXClusterReplicationFromCheckpoint(
+      replication_group_id, args[1]));
 
   RETURN_NOT_OK(client->WaitForCreateXClusterReplication(replication_group_id, args[1]));
 
@@ -2357,16 +2367,22 @@ Status setup_xcluster_replication_action(
   return Status::OK();
 }
 
-const auto drop_xcluster_replication_args = "<replication_group_id>";
+const auto drop_xcluster_replication_args = "<replication_group_id> [<target_master_addresses>]";
 Status drop_xcluster_replication_action(
     const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
-  if (args.size() != 1) {
+  if (args.size() != 1 && args.size() != 2) {
     return ClusterAdminCli::kInvalidArguments;
   }
 
   auto replication_group_id = xcluster::ReplicationGroupId(args[0]);
 
-  RETURN_NOT_OK(client->DeleteXClusterOutboundReplicationGroup(replication_group_id));
+  std::string target_master_addresses;
+  if (args.size() == 2) {
+    target_master_addresses = args[1];
+  }
+
+  RETURN_NOT_OK(client->XClusterClient().DeleteOutboundReplicationGroup(
+      replication_group_id, target_master_addresses));
 
   std::cout << "Outbound xCluster Replication group " << replication_group_id
             << " deleted successfully" << endl;
@@ -2374,6 +2390,102 @@ Status drop_xcluster_replication_action(
   return Status::OK();
 }
 
+const auto add_namespace_to_xcluster_checkpoint_args = "<replication_group_id> <namespace_name>";
+Status add_namespace_to_xcluster_checkpoint_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  if (args.size() != 2) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  const auto replication_group_id = xcluster::ReplicationGroupId(args[0]);
+  const auto& namespace_name = args[1];
+  const auto& namespace_info =
+      VERIFY_RESULT_REF(client->GetNamespaceInfo(YQLDatabase::YQL_DATABASE_PGSQL, namespace_name));
+  const auto& namespace_id = namespace_info.id();
+
+  RETURN_NOT_OK(client->XClusterClient().AddNamespaceToOutboundReplicationGroup(
+      replication_group_id, namespace_id));
+
+  std::cout << "Waiting for checkpointing of database to complete" << std::endl << std::endl;
+
+  auto is_bootstrap_required =
+      VERIFY_RESULT(client->IsXClusterBootstrapRequired(replication_group_id, namespace_id));
+
+  std::cout << "Successfully checkpointed database " << namespace_name
+            << " for xCluster replication group " << replication_group_id << std::endl
+            << std::endl;
+
+  std::cout << "Bootstrap is " << (is_bootstrap_required ? "" : "not ")
+            << "required for adding database to xCluster replication" << std::endl;
+
+  if (is_bootstrap_required) {
+    std::cout
+        << "Perform a distributed Backup of the database and Restore it on the target universe";
+  } else {
+    std::cout
+        << "Create equivalent YSQL objects (schemas, tables, indexes, ...) for the database in "
+           "the target universe";
+  }
+
+  std::cout << std::endl
+            << "After completing the above step run `add_namespace_to_xcluster_replication`"
+            << std::endl;
+
+  return Status::OK();
+}
+
+const auto add_namespace_to_xcluster_replication_args =
+    "<replication_group_id> <namespace_name> <target_master_addresses>";
+Status add_namespace_to_xcluster_replication_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  if (args.size() != 3) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  auto replication_group_id = xcluster::ReplicationGroupId(args[0]);
+  const auto& namespace_info =
+      VERIFY_RESULT_REF(client->GetNamespaceInfo(YQLDatabase::YQL_DATABASE_PGSQL, args[1]));
+
+  const auto& target_master_addresses = args[2];
+
+  RETURN_NOT_OK(client->XClusterClient().AddNamespaceToXClusterReplication(
+      replication_group_id, target_master_addresses, namespace_info.id()));
+
+  RETURN_NOT_OK(
+      client->WaitForAlterXClusterReplication(replication_group_id, target_master_addresses));
+
+  std::cout << "Successfully added " << namespace_info.name() << " to xCluster Replication group "
+            << replication_group_id << endl;
+
+  return Status::OK();
+}
+
+const auto remove_namespace_from_xcluster_replication_args =
+    "<replication_group_id> <namespace_name> [<target_master_addresses>]";
+Status remove_namespace_from_xcluster_replication_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  if (args.size() != 2 && args.size() != 3) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  auto replication_group_id = xcluster::ReplicationGroupId(args[0]);
+  const auto& namespace_info =
+      VERIFY_RESULT_REF(client->GetNamespaceInfo(YQLDatabase::YQL_DATABASE_PGSQL, args[1]));
+
+  std::string target_master_addresses;
+  if (args.size() == 3) {
+    target_master_addresses = args[2];
+  }
+
+  RETURN_NOT_OK(client->XClusterClient().RemoveNamespaceFromOutboundReplicationGroup(
+      replication_group_id, namespace_info.id(), target_master_addresses));
+
+  std::cout << "Successfully removed " << namespace_info.name()
+            << " from xCluster Replication group " << replication_group_id << endl;
+
+  return Status::OK();
+}
+
 const auto repair_xcluster_outbound_replication_add_table_args =
     "<replication_group_id> <table_id> <stream_id>";
 Status repair_xcluster_outbound_replication_add_table_action(
@@ -2386,7 +2498,7 @@ Status repair_xcluster_outbound_replication_add_table_action(
   const auto& table_id = args[1];
   const auto stream_id = VERIFY_RESULT(xrepl::StreamId::FromString(args[2]));
 
-  RETURN_NOT_OK(client->RepairOutboundXClusterReplicationGroupAddTable(
+  RETURN_NOT_OK(client->XClusterClient().RepairOutboundXClusterReplicationGroupAddTable(
       replication_group_id, table_id, stream_id));
 
   std::cout << "Table " << table_id << " successfully added to outbound xCluster Replication group "
@@ -2406,8 +2518,8 @@ Status repair_xcluster_outbound_replication_remove_table_action(
   auto replication_group_id = xcluster::ReplicationGroupId(args[0]);
   const auto& table_id = args[1];
 
-  RETURN_NOT_OK(
-      client->RepairOutboundXClusterReplicationGroupRemoveTable(replication_group_id, table_id));
+  RETURN_NOT_OK(client->XClusterClient().RepairOutboundXClusterReplicationGroupRemoveTable(
+      replication_group_id, table_id));
 
   std::cout << "Table " << table_id
             << " successfully removed from outbound xCluster Replication group "
@@ -2536,6 +2648,9 @@ void ClusterAdminCli::RegisterCommandHandlers() {
   REGISTER_COMMAND(is_xcluster_bootstrap_required);
   REGISTER_COMMAND(setup_xcluster_replication);
   REGISTER_COMMAND(drop_xcluster_replication);
+  REGISTER_COMMAND(add_namespace_to_xcluster_checkpoint);
+  REGISTER_COMMAND(add_namespace_to_xcluster_replication);
+  REGISTER_COMMAND(remove_namespace_from_xcluster_replication);
   REGISTER_COMMAND(repair_xcluster_outbound_replication_add_table);
   REGISTER_COMMAND(repair_xcluster_outbound_replication_remove_table);
 }
diff --git a/src/yb/tools/yb-admin_client.cc b/src/yb/tools/yb-admin_client.cc
index 6443800b4c..4b3ffbad78 100644
--- a/src/yb/tools/yb-admin_client.cc
+++ b/src/yb/tools/yb-admin_client.cc
@@ -4219,7 +4219,8 @@ Status ClusterAdminClient::AlterUniverseReplication(
     const std::string& replication_group_id, const std::vector<std::string>& producer_addresses,
     const std::vector<TableId>& add_tables, const std::vector<TableId>& remove_tables,
     const std::vector<std::string>& producer_bootstrap_ids_to_add,
-    const std::string& new_replication_group_id, bool remove_table_ignore_errors) {
+    const std::string& new_replication_group_id, const NamespaceId& source_namespace_to_remove,
+    bool remove_table_ignore_errors) {
   master::AlterUniverseReplicationRequestPB req;
   master::AlterUniverseReplicationResponsePB resp;
   req.set_replication_group_id(replication_group_id);
@@ -4268,6 +4269,10 @@ Status ClusterAdminClient::AlterUniverseReplication(
     req.set_new_replication_group_id(new_replication_group_id);
   }
 
+  if (!source_namespace_to_remove.empty()) {
+    req.set_producer_namespace_id_to_remove(source_namespace_to_remove);
+  }
+
   RpcController rpc;
   rpc.set_timeout(timeout_);
   RETURN_NOT_OK(master_replication_proxy_->AlterUniverseReplication(req, &resp, &rpc));
@@ -4528,32 +4533,18 @@ Result<rapidjson::Document> ClusterAdminClient::GetXClusterSafeTime(bool include
   return document;
 }
 
-Result<std::vector<NamespaceId>> ClusterAdminClient::CheckpointXClusterReplication(
-    const xcluster::ReplicationGroupId& replication_group_id,
-    const std::vector<NamespaceName> databases) {
-  SCHECK(!replication_group_id.empty(), InvalidArgument, "Replication group id is empty");
-
-  return XClusterClient().XClusterCreateOutboundReplicationGroup(replication_group_id, databases);
-}
-
 Result<bool> ClusterAdminClient::IsXClusterBootstrapRequired(
     const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId namespace_id) {
   SCHECK(!replication_group_id.empty(), InvalidArgument, "Replication group id is empty");
 
   auto deadline = CoarseMonoClock::now() + timeout_;
   auto promise = std::promise<Result<bool>>();
-  RETURN_NOT_OK(XClusterClient().IsXClusterBootstrapRequired(
+  RETURN_NOT_OK(XClusterClient().IsBootstrapRequired(
       deadline, replication_group_id, namespace_id,
       [&promise](Result<bool> result) { promise.set_value(std::move(result)); }));
   return promise.get_future().get();
 }
 
-Status ClusterAdminClient::CreateXClusterReplication(
-    const xcluster::ReplicationGroupId& replication_group_id,
-    const std::string& target_master_addresses) {
-  return XClusterClient().CreateXClusterReplication(replication_group_id, target_master_addresses);
-}
-
 Status ClusterAdminClient::WaitForCreateXClusterReplication(
     const xcluster::ReplicationGroupId& replication_group_id,
     const std::string& target_master_addresses) {
@@ -4570,24 +4561,20 @@ Status ClusterAdminClient::WaitForCreateXClusterReplication(
   }
 }
 
-Status ClusterAdminClient::DeleteXClusterOutboundReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id) {
+Status ClusterAdminClient::WaitForAlterXClusterReplication(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const std::string& target_master_addresses) {
   SCHECK(!replication_group_id.empty(), InvalidArgument, "Replication group id is empty");
 
-  return XClusterClient().XClusterDeleteOutboundReplicationGroup(replication_group_id);
-}
-
-Status ClusterAdminClient::RepairOutboundXClusterReplicationGroupAddTable(
-    const xcluster::ReplicationGroupId& replication_group_id, const TableId& table_id,
-    const xrepl::StreamId& stream_id) {
-  return XClusterClient().RepairOutboundXClusterReplicationGroupAddTable(
-      replication_group_id, table_id, stream_id);
-}
+  for (;;) {
+    auto result = XClusterClient().IsAlterXClusterReplicationDone(
+        replication_group_id, target_master_addresses);
+    if (result && result->done()) {
+      return result->status();
+    }
 
-Status ClusterAdminClient::RepairOutboundXClusterReplicationGroupRemoveTable(
-    const xcluster::ReplicationGroupId& replication_group_id, const TableId& table_id) {
-  return XClusterClient().RepairOutboundXClusterReplicationGroupRemoveTable(
-      replication_group_id, table_id);
+    std::this_thread::sleep_for(100ms);
+  }
 }
 
 client::XClusterClient ClusterAdminClient::XClusterClient() {
diff --git a/src/yb/tools/yb-admin_client.h b/src/yb/tools/yb-admin_client.h
index db2bf52931..899d9a4c7b 100644
--- a/src/yb/tools/yb-admin_client.h
+++ b/src/yb/tools/yb-admin_client.h
@@ -428,7 +428,8 @@ class ClusterAdminClient {
       const std::string& replication_group_id, const std::vector<std::string>& producer_addresses,
       const std::vector<TableId>& add_tables, const std::vector<TableId>& remove_tables,
       const std::vector<std::string>& producer_bootstrap_ids_to_add,
-      const std::string& new_replication_group_id, bool remove_table_ignore_errors = false);
+      const std::string& new_replication_group_id, const NamespaceId& source_namespace_to_remove,
+      bool remove_table_ignore_errors = false);
 
   Status RenameUniverseReplication(const std::string& old_universe_name,
                                    const std::string& new_universe_name);
@@ -456,23 +457,18 @@ class ClusterAdminClient {
 
   Result<rapidjson::Document> GetXClusterSafeTime(bool include_lag_and_skew = false);
 
-  Result<std::vector<NamespaceId>> CheckpointXClusterReplication(
-      const xcluster::ReplicationGroupId& replication_group_id,
-      const std::vector<NamespaceName> databases);
-
   Result<bool> IsXClusterBootstrapRequired(
       const xcluster::ReplicationGroupId& replication_group_id, const NamespaceId namespace_id);
 
-  Status CreateXClusterReplication(
+  Status WaitForCreateXClusterReplication(
       const xcluster::ReplicationGroupId& replication_group_id,
       const std::string& target_master_addresses);
 
-  Status WaitForCreateXClusterReplication(
+  Status WaitForAlterXClusterReplication(
       const xcluster::ReplicationGroupId& replication_group_id,
       const std::string& target_master_addresses);
 
-  Status DeleteXClusterOutboundReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id);
+  client::XClusterClient XClusterClient();
 
   Status RepairOutboundXClusterReplicationGroupAddTable(
       const xcluster::ReplicationGroupId& replication_group_id, const TableId& table_id,
@@ -560,8 +556,6 @@ class ClusterAdminClient {
   Result<master::IsTabletSplittingCompleteResponsePB> IsTabletSplittingCompleteInternal(
       bool wait_for_parent_deletion, const MonoDelta timeout = MonoDelta());
 
-  client::XClusterClient XClusterClient();
-
   std::string master_addr_list_;
   HostPort init_master_addr_;
   const MonoDelta timeout_;
