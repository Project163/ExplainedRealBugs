diff --git a/src/yb/master/catalog_entity_base.cc b/src/yb/master/catalog_entity_base.cc
index afdaa4ebab..bea902af28 100644
--- a/src/yb/master/catalog_entity_base.cc
+++ b/src/yb/master/catalog_entity_base.cc
@@ -80,13 +80,17 @@ bool CatalogEntityWithTasks::RemoveTask(const server::MonitoredTaskPtr& task) {
 
 // Aborts tasks which have their rpc in progress, rest of them are aborted and also erased
 // from the pending list.
-void CatalogEntityWithTasks::AbortTasks() { AbortTasksAndCloseIfRequested(/* close */ false); }
+void CatalogEntityWithTasks::AbortTasks(
+    const std::unordered_set<server::MonitoredTaskType>& tasks_to_ignore) {
+  AbortTasksAndCloseIfRequested(/* close */ false, tasks_to_ignore);
+}
 
 void CatalogEntityWithTasks::AbortTasksAndClose() {
   AbortTasksAndCloseIfRequested(/* close */ true);
 }
 
-void CatalogEntityWithTasks::AbortTasksAndCloseIfRequested(bool close) {
+void CatalogEntityWithTasks::AbortTasksAndCloseIfRequested(
+    bool close, const std::unordered_set<server::MonitoredTaskType>& tasks_to_ignore) {
   std::vector<server::MonitoredTaskPtr> abort_tasks;
   {
     std::lock_guard l(mutex_);
@@ -104,6 +108,9 @@ void CatalogEntityWithTasks::AbortTasksAndCloseIfRequested(bool close) {
   // We need to abort these tasks without holding the lock because when a task is destroyed it tries
   // to acquire the same lock to remove itself from pending_tasks_.
   for (const auto& task : abort_tasks) {
+    if (tasks_to_ignore.contains(task->type())) {
+      continue;
+    }
     VLOG_WITH_FUNC(1) << (close ? "Close and abort" : "Abort") << " task " << task.get() << " "
                       << task->description();
     task->AbortAndReturnPrevState(status);
diff --git a/src/yb/master/catalog_entity_base.h b/src/yb/master/catalog_entity_base.h
index 7026586f9a..903276a73a 100644
--- a/src/yb/master/catalog_entity_base.h
+++ b/src/yb/master/catalog_entity_base.h
@@ -135,7 +135,8 @@ class CatalogEntityWithTasks {
   // Returns true if no running tasks left.
   bool RemoveTask(const server::MonitoredTaskPtr& task) EXCLUDES(mutex_);
   // Abort all inflight tasks. New tasks can still be added.
-  void AbortTasks() EXCLUDES(mutex_);
+  void AbortTasks(const std::unordered_set<server::MonitoredTaskType>& tasks_to_ignore = {})
+      EXCLUDES(mutex_);
   // Abort all inflight tasks and prevent new tasks from being added.
   void AbortTasksAndClose() EXCLUDES(mutex_);
   // Wait for all inflight tasks to complete.
@@ -158,7 +159,9 @@ class CatalogEntityWithTasks {
   }
 
  private:
-  void AbortTasksAndCloseIfRequested(bool close) EXCLUDES(mutex_);
+  void AbortTasksAndCloseIfRequested(
+      bool close, const std::unordered_set<server::MonitoredTaskType>& tasks_to_ignore = {})
+      EXCLUDES(mutex_);
 
   scoped_refptr<TasksTracker> tasks_tracker_;
 
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index a79e0e0571..d83658a2f5 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -6719,7 +6719,9 @@ Status CatalogManager::DeleteTableInMemory(
 
   if (!hide_only) {
     // If table is being hidden we should not abort snapshot related tasks.
-    table->AbortTasks();
+    // Always ignore Table schema verification tasks since it may be the one that is initiating the
+    // deletes.
+    table->AbortTasks(/*tasks_to_ignore=*/{server::MonitoredTaskType::TableSchemaVerification});
   }
 
   // For regular (indexed) table, insert table info and lock in the front of the list. Else for
diff --git a/src/yb/master/multi_step_monitored_task.cc b/src/yb/master/multi_step_monitored_task.cc
index 3d0848508d..215e2f0b31 100644
--- a/src/yb/master/multi_step_monitored_task.cc
+++ b/src/yb/master/multi_step_monitored_task.cc
@@ -52,6 +52,8 @@ void MultiStepMonitoredTask::TaskCompleted(const Status& status) {
   // NoOp
 }
 
+void MultiStepMonitoredTask::PerformAbort() { AbortReactorTaskIfScheduled(); }
+
 void MultiStepMonitoredTask::Complete() {
   if (TrySetState(server::MonitoredTaskState::kComplete)) {
     EndTask(Status::OK());
@@ -63,7 +65,15 @@ server::MonitoredTaskState MultiStepMonitoredTask::AbortAndReturnPrevState(const
   DCHECK(!status.ok());
   auto old_state = state();
   if (TrySetState(server::MonitoredTaskState::kAborted)) {
-    AbortReactorTaskIfScheduled();
+    PerformAbort();
+    {
+      // After setting the state grab the mutex to wait for the current step to finish.
+      LongOperationTracker long_operation_tracker(
+          Format("Waiting for task $0 to finish in progress step", ToString()).c_str(),
+          MonoDelta::FromSeconds(1));
+      std::lock_guard l(step_execution_mutex_);
+    }
+
     EndTask(status);
   } else {
     LOG_WITH_PREFIX(WARNING) << this << ": Task already ended. Unable to abort it: " << status;
@@ -168,6 +178,13 @@ Status MultiStepMonitoredTask::RunInternal() {
   // Grab the step_execution_mutex_, since one step schedules the next step, and we dont want the
   // second one to start before the first once goes fully out of scope.
   std::lock_guard step_execution_l(step_execution_mutex_);
+
+  // Check the state after acquiring lock, since abort will set the state and then get lock.
+  SCHECK_EQ(
+      state(), server::MonitoredTaskState::kRunning, IllegalState, "Task in unexpected state");
+
+  // Grab the schedule_task_mutex_ to swap the next step and the next step description.
+  // This is done to avoid
   {
     std::lock_guard schedule_task_l(schedule_task_mutex_);
     reactor_task_id_ = rpc::kInvalidTaskId;
diff --git a/src/yb/master/multi_step_monitored_task.h b/src/yb/master/multi_step_monitored_task.h
index f51d38655d..14e5a76101 100644
--- a/src/yb/master/multi_step_monitored_task.h
+++ b/src/yb/master/multi_step_monitored_task.h
@@ -79,6 +79,7 @@ class MultiStepMonitoredTask : public server::RunnableMonitoredTask {
   // will be OK if the task succeeded and not OK if it failed. Note: Do not invoke this directly. It
   // will be invoked when any step returns a bad status.
   virtual void TaskCompleted(const Status& status);
+  virtual void PerformAbort();
 
   // ==================================================================
   // Helper methods that derived class steps can invoke.
diff --git a/src/yb/master/ysql_ddl_verification_task.cc b/src/yb/master/ysql_ddl_verification_task.cc
index ddc83d659a..252471bce8 100644
--- a/src/yb/master/ysql_ddl_verification_task.cc
+++ b/src/yb/master/ysql_ddl_verification_task.cc
@@ -492,20 +492,19 @@ PollTransactionStatusBase::PollTransactionStatusBase(
 }
 
 PollTransactionStatusBase::~PollTransactionStatusBase() {
-#ifndef NDEBUG
+  std::lock_guard l(rpc_mutex_);
   DCHECK(shutdown_) << "Shutdown not invoked";
-#endif
 }
 
 void PollTransactionStatusBase::Shutdown() {
+  std::lock_guard l(rpc_mutex_);
+
   rpcs_.Shutdown();
   // Shutdown times out after waiting a certain amount of time. The callback requires both this and
   // the Rpcs to be valid, so wait for it to complete.
   CHECK_OK(sync_.Wait());
 
-#ifndef NDEBUG
   shutdown_ = true;
-#endif
 }
 
 Status PollTransactionStatusBase::VerifyTransaction() {
@@ -527,6 +526,14 @@ Status PollTransactionStatusBase::VerifyTransaction() {
         "Shutting down. Cannot send GetTransactionStatus: $0", transaction_);
   }
 
+  RETURN_NOT_OK(sync_.Wait());
+  sync_.Reset();
+
+  std::lock_guard l(rpc_mutex_);
+  SCHECK(
+      !shutdown_, IllegalState, "Task has been shut down. Cannot send GetTransactionStatus: $0",
+      transaction_);
+
   // Prepare the rpc after checking if it is shutting down in case it returns because of
   // client is null and leave the reserved rpc as uninitialized.
   auto rpc_handle = rpcs_.Prepare();
@@ -536,8 +543,6 @@ Status PollTransactionStatusBase::VerifyTransaction() {
   }
   // We need to query the TransactionCoordinator here.  Can't use TransactionStatusResolver in
   // TransactionParticipant since this TransactionMetadata may not have any actual data flushed yet.
-  RETURN_NOT_OK(sync_.Wait());
-  sync_.Reset();
   auto sync_cb = sync_.AsStdStatusCallback();
   auto callback = [this, rpc_handle, user_cb = std::move(sync_cb)](
                       Status status, const tserver::GetTransactionStatusResponsePB& resp) {
@@ -671,6 +676,16 @@ Status NamespaceVerificationTask::ValidateRunnable() {
   return Status::OK();
 }
 
+void NamespaceVerificationTask::TaskCompleted(const Status& status) {
+  MultiStepNamespaceTaskBase::TaskCompleted(status);
+  Shutdown();
+}
+
+void NamespaceVerificationTask::PerformAbort() {
+  MultiStepNamespaceTaskBase::PerformAbort();
+  Shutdown();
+}
+
 TableSchemaVerificationTask::TableSchemaVerificationTask(
     CatalogManager& catalog_manager, scoped_refptr<TableInfo> table,
     const TransactionMetadata& transaction, std::function<void(Result<bool>)> complete_callback,
@@ -788,5 +803,15 @@ Status TableSchemaVerificationTask::CompareSchema(Status txn_rpc_success) {
   return FinishTask(PgSchemaChecker(sys_catalog_, table_info_));
 }
 
+void TableSchemaVerificationTask::TaskCompleted(const Status& status) {
+  MultiStepTableTaskBase::TaskCompleted(status);
+  Shutdown();
+}
+
+void TableSchemaVerificationTask::PerformAbort() {
+  MultiStepTableTaskBase::PerformAbort();
+  Shutdown();
+}
+
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/ysql_ddl_verification_task.h b/src/yb/master/ysql_ddl_verification_task.h
index 74bfee3832..9085443155 100644
--- a/src/yb/master/ysql_ddl_verification_task.h
+++ b/src/yb/master/ysql_ddl_verification_task.h
@@ -89,9 +89,9 @@ class PollTransactionStatusBase {
   rpc::Rpcs rpcs_;
   Synchronizer sync_;
 
-#ifndef NDEBUG
-  bool shutdown_ = false;
-#endif
+  std::mutex rpc_mutex_;
+
+  bool shutdown_ GUARDED_BY(rpc_mutex_) = false;
 };
 
 class NamespaceVerificationTask : public MultiStepNamespaceTaskBase,
@@ -135,7 +135,8 @@ class NamespaceVerificationTask : public MultiStepNamespaceTaskBase,
   Status ValidateRunnable() override;
   void FinishPollTransaction(Status s) override;
   Status CheckNsExists(Status status);
-  void TaskCompleted(const Status& status) override { Shutdown(); }
+  void TaskCompleted(const Status& status) override;
+  void PerformAbort() override;
 
   SysCatalogTable& sys_catalog_;
   bool entry_exists_ = false;
@@ -186,7 +187,8 @@ class TableSchemaVerificationTask : public MultiStepTableTaskBase,
   Status CompareSchema(Status s);
   Status FinishTask(Result<bool> is_committed);
   void FinishPollTransaction(Status s) override;
-  void TaskCompleted(const Status& status) override { Shutdown(); }
+  void TaskCompleted(const Status& status) override;
+  void PerformAbort() override;
 
   SysCatalogTable& sys_catalog_;
   bool ddl_atomicity_enabled_;
