diff --git a/src/yb/cdc/cdc_consumer.proto b/src/yb/cdc/cdc_consumer.proto
index b671467021..2c0961f4a1 100644
--- a/src/yb/cdc/cdc_consumer.proto
+++ b/src/yb/cdc/cdc_consumer.proto
@@ -45,16 +45,6 @@ message ProducerTabletListPB {
   repeated bytes end_key = 3;
 }
 
-message ProducerSchemaPB {
-  // The last Producer schema version that was EquivalentForDataCopy with this Consumer.
-  uint32 validated_schema_version = 1;
-  // The upcoming Producer schema for ingest.  If present, Consumer needs ALTER for compatibility.
-  uint32 pending_schema_version = 2;
-  SchemaPB pending_schema = 3;
-  // The last Consumer schema version that was EquivalentForDataCopy with this Producer
-  uint32 last_compatible_consumer_schema_version = 4;
-}
-
 message SchemaVersionsPB {
   uint32 current_producer_schema_version = 1;
   uint32 current_consumer_schema_version = 2;
@@ -68,7 +58,8 @@ message StreamEntryPB {
   string consumer_table_id = 2;
   string producer_table_id = 3;
   bool local_tserver_optimized = 4;
-  ProducerSchemaPB producer_schema = 5;
+  // ProducerSchemaPB producer_schema
+  reserved 5;
 
   // Producer consumer schema versions
   SchemaVersionsPB schema_versions = 6;
diff --git a/src/yb/integration-tests/xcluster/xcluster-test.cc b/src/yb/integration-tests/xcluster/xcluster-test.cc
index 288384b23b..4afa5bd248 100644
--- a/src/yb/integration-tests/xcluster/xcluster-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster-test.cc
@@ -132,7 +132,6 @@ DECLARE_int32(transaction_table_num_tablets);
 DECLARE_int32(tserver_heartbeat_metrics_interval_ms);
 DECLARE_bool(use_client_to_server_encryption);
 DECLARE_bool(use_node_to_node_encryption);
-DECLARE_bool(xcluster_wait_on_ddl_alter);
 DECLARE_bool(TEST_xcluster_disable_delete_old_pollers);
 DECLARE_bool(enable_log_retention_by_op_idx);
 DECLARE_bool(TEST_xcluster_disable_poller_term_check);
@@ -2208,8 +2207,6 @@ TEST_P(XClusterTest, TestProducerUniverseExpansion) {
 }
 
 TEST_P(XClusterTest, TestAlterDDLBasic) {
-  SetAtomicFlag(true, &FLAGS_xcluster_wait_on_ddl_alter);
-
   uint32_t replication_factor = 1;
   // Use just one tablet here to more easily catch lower-level write issues with this test.
   ASSERT_OK(SetUpWithParams({1}, replication_factor));
@@ -2283,8 +2280,6 @@ TEST_P(XClusterTest, TestAlterDDLBasic) {
 }
 
 TEST_P(XClusterTest, TestAlterDDLWithRestarts) {
-  SetAtomicFlag(true, &FLAGS_xcluster_wait_on_ddl_alter);
-
   uint32_t replication_factor = 3;
   ASSERT_OK(SetUpWithParams({1}, {1}, replication_factor, 2, 3));
 
@@ -3939,8 +3934,6 @@ TEST_F_EX(XClusterTest, DeleteWithoutStreamCleanup, XClusterTestNoParam) {
 }
 
 TEST_F_EX(XClusterTest, DeleteWhenSourceIsDown, XClusterTestNoParam) {
-  SetAtomicFlag(true, &FLAGS_xcluster_wait_on_ddl_alter);
-
   // Create 2 tables with 3 tablets each.
   ASSERT_OK(SetUpWithParams({3, 3}, /*replication_factor=*/3));
   ASSERT_OK(SetupReplication());
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc b/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
index bb66c5f291..9bb41025be 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
@@ -93,7 +93,6 @@ DECLARE_int32(replication_factor);
 DECLARE_int32(rpc_workers_limit);
 DECLARE_int32(tablet_server_svc_queue_length);
 DECLARE_int32(update_min_cdc_indices_interval_secs);
-DECLARE_bool(xcluster_wait_on_ddl_alter);
 DECLARE_bool(ysql_disable_index_backfill);
 DECLARE_bool(ysql_enable_packed_row);
 DECLARE_uint64(ysql_packed_row_size_limit);
@@ -1266,7 +1265,6 @@ TEST_F(XClusterYsqlTest, SimpleReplicationWithRangedPartitionsAndUnevenTabletCou
 }
 
 TEST_F(XClusterYsqlTest, ReplicationWithBasicDDL) {
-  SetAtomicFlag(true, &FLAGS_xcluster_wait_on_ddl_alter);
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_ysql_enable_packed_row) = true;
   // Used for faster VerifyReplicationError.
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_tserver_heartbeat_metrics_interval_ms) = 1000;
@@ -1464,7 +1462,6 @@ TEST_F(XClusterYsqlTest, ReplicationWithBasicDDL) {
 }
 
 TEST_F(XClusterYsqlTest, ReplicationWithCreateIndexDDL) {
-  SetAtomicFlag(true, &FLAGS_xcluster_wait_on_ddl_alter);
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_ysql_disable_index_backfill) = false;
   string new_column = "alt";
   constexpr auto kIndexName = "TestIndex";
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_colocated-test.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_colocated-test.cc
index 2146444b7f..e86c01f0d9 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_colocated-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_colocated-test.cc
@@ -26,7 +26,6 @@
 #include "yb/tserver/mini_tablet_server.h"
 #include "yb/util/backoff_waiter.h"
 
-DECLARE_bool(xcluster_wait_on_ddl_alter);
 DECLARE_bool(ysql_legacy_colocated_database_creation);
 DECLARE_bool(ysql_enable_packed_row);
 
@@ -72,7 +71,6 @@ class XClusterYsqlColocatedTest : public XClusterYsqlTestBase {
   }
 
   Status TestDatabaseReplication(bool compact = false, bool use_transaction = false) {
-    SetAtomicFlag(true, &FLAGS_xcluster_wait_on_ddl_alter);
     constexpr auto kRecordBatch = 5;
     auto count = 0;
     constexpr int kNTabletsPerColocatedTable = 1;
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 2b422c339c..36c11f520a 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -7422,10 +7422,6 @@ Status CatalogManager::AlterTable(const AlterTableRequestPB* req,
     SchemaToPB(new_schema, table_pb.mutable_schema());
   }
 
-  // If we're waiting for a Schema because we saw the a replication source with a change,
-  // ensure this alter is compatible with what we're expecting.
-  RETURN_NOT_OK(xcluster_manager_->ValidateNewSchema(*table, new_schema));
-
   // Only increment the version number if it is a schema change (AddTable change goes through a
   // different path and it's not processed here).
   if (!req->has_wal_retention_secs()) {
@@ -10930,8 +10926,6 @@ Status CatalogManager::HandleTabletSchemaVersionReport(
   // Clean up any DDL verification state that is waiting for this Alter to complete.
   RemoveDdlTransactionState(table->id(), table->EraseDdlTxnsWaitingForSchemaVersion(version));
 
-  RETURN_NOT_OK(xcluster_manager_->HandleTabletSchemaVersionReport(*table, version, epoch));
-
   return MultiStageAlterTable::LaunchNextTableInfoVersionIfNecessary(this, table, version, epoch);
 }
 
diff --git a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
index ed11efefab..441504b0c5 100644
--- a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
+++ b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
@@ -745,8 +745,7 @@ Status XClusterTableSetupTask::ProcessTable(
   schema_versions->set_current_producer_schema_version(source_info->schema.version());
   schema_versions->set_current_consumer_schema_version(target_schema.version());
 
-  RETURN_NOT_OK(
-      PopulateTableStreamEntry(target_schema.identifier().table_id(), target_schema.version()));
+  RETURN_NOT_OK(PopulateTableStreamEntry(target_schema.identifier().table_id()));
 
   return ValidateBootstrapAndSetupStreams();
 }
@@ -758,7 +757,7 @@ Status XClusterTableSetupTask::ProcessTableWithoutSchemaValidation() {
   schema_versions->set_current_producer_schema_version(0);
   schema_versions->set_current_consumer_schema_version(0);
 
-  RETURN_NOT_OK(PopulateTableStreamEntry(*target_table_id_, 0));
+  RETURN_NOT_OK(PopulateTableStreamEntry(*target_table_id_));
 
   return ValidateBootstrapAndSetupStreams();
 }
@@ -835,10 +834,7 @@ Status XClusterTableSetupTask::ProcessTablegroup(
                                           ? GetColocationParentTableId(target_tablegroup_id)
                                           : GetTablegroupParentTableId(target_tablegroup_id);
 
-  auto target_schema_version =
-      VERIFY_RESULT(parent_task_->catalog_manager_.GetTableSchemaVersion(target_parent_table_id));
-
-  RETURN_NOT_OK(PopulateTableStreamEntry(target_parent_table_id, target_schema_version));
+  RETURN_NOT_OK(PopulateTableStreamEntry(target_parent_table_id));
 
   return ValidateBootstrapAndSetupStreams();
 }
@@ -971,9 +967,8 @@ Result<GetTableSchemaResponsePB> XClusterTableSetupTask::ValidateSourceSchemaAnd
   return table_schema_resp;
 }
 
-Status XClusterTableSetupTask::PopulateTableStreamEntry(
-    const TableId& target_table_id, const SchemaVersion& target_schema_version) {
-  VLOG_WITH_PREFIX_AND_FUNC(1) << YB_STRUCT_TO_STRING(target_table_id, target_schema_version);
+Status XClusterTableSetupTask::PopulateTableStreamEntry(const TableId& target_table_id) {
+  VLOG_WITH_PREFIX_AND_FUNC(1) << YB_STRUCT_TO_STRING(target_table_id);
 
   SCHECK(
       !parent_task_->xcluster_manager_.IsTableReplicationConsumer(target_table_id), IllegalState,
@@ -985,15 +980,6 @@ Status XClusterTableSetupTask::PopulateTableStreamEntry(
   stream_entry.set_consumer_table_id(target_table_id);
   stream_entry.set_producer_table_id(source_table_id_);
 
-  RSTATUS_DCHECK_NE(
-      target_schema_version, cdc::kInvalidSchemaVersion, IllegalState,
-      Format(
-          "Invalid target schema version for source table $0, target table $1", source_table_id_,
-          target_table_id));
-
-  stream_entry.mutable_producer_schema()->set_last_compatible_consumer_schema_version(
-      target_schema_version);
-
   if (parent_task_->data_.automatic_ddl_mode) {
     // Mark this stream as special if it is for the ddl_queue table.
     auto stripped_target_table_id = xcluster::StripSequencesDataAliasIfPresent(target_table_id);
diff --git a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h
index dbb0459b3f..70ab98374b 100644
--- a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h
+++ b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h
@@ -127,8 +127,7 @@ class XClusterTableSetupTask : public MultiStepMonitoredTask {
 
   void SetupStreams();
 
-  Status PopulateTableStreamEntry(
-      const TableId& target_table_id, const SchemaVersion& target_schema_version);
+  Status PopulateTableStreamEntry(const TableId& target_table_id);
 
   void GetStreamCallback(
       std::shared_ptr<TableId> received_table_id,
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index 8d10a420d5..a340802ca9 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -764,11 +764,6 @@ Status XClusterManager::HandleTabletSplit(
   return XClusterTargetManager::HandleTabletSplit(consumer_table_id, split_tablet_ids, epoch);
 }
 
-Status XClusterManager::ValidateNewSchema(
-    const TableInfo& table_info, const Schema& consumer_schema) const {
-  return XClusterTargetManager::ValidateNewSchema(table_info, consumer_schema);
-}
-
 Status XClusterManager::ValidateSplitCandidateTable(const TableId& table_id) const {
   if (!FLAGS_enable_tablet_split_of_xcluster_replicated_tables && IsTableReplicated(table_id)) {
     return STATUS_FORMAT(
@@ -782,12 +777,6 @@ Status XClusterManager::ValidateSplitCandidateTable(const TableId& table_id) con
   return Status::OK();
 }
 
-Status XClusterManager::HandleTabletSchemaVersionReport(
-    const TableInfo& table_info, SchemaVersion consumer_schema_version, const LeaderEpoch& epoch) {
-  return XClusterTargetManager::ResumeStreamsAfterNewSchema(
-      table_info, consumer_schema_version, epoch);
-}
-
 Status XClusterManager::SetupUniverseReplication(
     const SetupUniverseReplicationRequestPB* req, SetupUniverseReplicationResponsePB* resp,
     rpc::RpcContext* rpc, const LeaderEpoch& epoch) {
diff --git a/src/yb/master/xcluster/xcluster_manager.h b/src/yb/master/xcluster/xcluster_manager.h
index 1663ab0195..f60924d9a2 100644
--- a/src/yb/master/xcluster/xcluster_manager.h
+++ b/src/yb/master/xcluster/xcluster_manager.h
@@ -266,13 +266,8 @@ class XClusterManager : public XClusterManagerIf,
       const TableId& consumer_table_id, const SplitTabletIds& split_tablet_ids,
       const LeaderEpoch& epoch) override;
 
-  Status ValidateNewSchema(const TableInfo& table_info, const Schema& consumer_schema) const;
-
   Status ValidateSplitCandidateTable(const TableId& table_id) const;
 
-  Status HandleTabletSchemaVersionReport(
-      const TableInfo& table_info, SchemaVersion consumer_schema_version, const LeaderEpoch& epoch);
-
   Status RegisterMonitoredTask(server::MonitoredTaskPtr task) EXCLUDES(monitored_tasks_mutex_);
   void UnRegisterMonitoredTask(server::MonitoredTaskPtr task) EXCLUDES(monitored_tasks_mutex_);
 
diff --git a/src/yb/master/xcluster/xcluster_target_manager.cc b/src/yb/master/xcluster/xcluster_target_manager.cc
index 947550d597..70d7d86ac3 100644
--- a/src/yb/master/xcluster/xcluster_target_manager.cc
+++ b/src/yb/master/xcluster/xcluster_target_manager.cc
@@ -41,9 +41,7 @@
 #include "yb/util/scope_exit.h"
 #include "yb/util/status.h"
 
-DEFINE_RUNTIME_bool(xcluster_wait_on_ddl_alter, true,
-    "When xCluster replication sends a DDL change, wait for the user to enter a "
-    "compatible/matching entry.  Note: Can also set at runtime to resume after stall.");
+DEPRECATE_FLAG(bool, xcluster_wait_on_ddl_alter, "11_2024");
 
 DEFINE_RUNTIME_uint32(add_new_index_to_bidirectional_xcluster_timeout_secs, 10 * 60,
     "Time in seconds within which index must be created on other universe when the indexed table "
@@ -338,9 +336,6 @@ void XClusterTargetManager::RunBgTasks(const LeaderEpoch& epoch) {
       "Failed to remove dropped tables from consumer replication groups");
 
   WARN_NOT_OK(RefreshLocalAutoFlagConfig(epoch), "Failed refreshing local AutoFlags config");
-
-  WARN_NOT_OK(
-      ProcessPendingSchemaChanges(epoch), "Failed processing xCluster Pending Schema Changes");
 }
 
 Status XClusterTargetManager::RemoveDroppedTablesFromReplication(const LeaderEpoch& epoch) {
@@ -981,161 +976,6 @@ Status XClusterTargetManager::HandleTabletSplit(
   return Status::OK();
 }
 
-Status XClusterTargetManager::ValidateNewSchema(
-    const TableInfo& table_info, const Schema& consumer_schema) const {
-  if (!FLAGS_xcluster_wait_on_ddl_alter) {
-    return Status::OK();
-  }
-
-  // Check if this table is consuming a stream.
-  auto stream_ids = GetStreamIdsForTable(table_info.id());
-  if (stream_ids.empty()) {
-    return Status::OK();
-  }
-
-  auto cluster_config = catalog_manager_.ClusterConfig();
-  auto l = cluster_config->LockForRead();
-  for (const auto& [replication_group_id, stream_id] : stream_ids) {
-    // Fetch the stream entry to get Schema information.
-    auto& replication_group_map = l.data().pb.consumer_registry().producer_map();
-    auto producer_entry = FindOrNull(replication_group_map, replication_group_id.ToString());
-    SCHECK(producer_entry, NotFound, Format("Missing universe $0", replication_group_id));
-    auto stream_entry = FindOrNull(producer_entry->stream_map(), stream_id.ToString());
-    SCHECK(stream_entry, NotFound, Format("Missing stream $0:$1", replication_group_id, stream_id));
-
-    // If we are halted on a Schema update as a Consumer...
-    auto& producer_schema_pb = stream_entry->producer_schema();
-    if (producer_schema_pb.has_pending_schema()) {
-      // Compare our new schema to the Producer's pending schema.
-      Schema producer_schema;
-      RETURN_NOT_OK(SchemaFromPB(producer_schema_pb.pending_schema(), &producer_schema));
-
-      // This new schema should allow us to consume data for the Producer's next schema.
-      // If we instead diverge, we will be unable to consume any more of the Producer's data.
-      bool can_apply = consumer_schema.EquivalentForDataCopy(producer_schema);
-      SCHECK(
-          can_apply, IllegalState,
-          Format(
-              "New Schema not compatible with XCluster Producer Schema:\n new={$0}\n producer={$1}",
-              consumer_schema.ToString(), producer_schema.ToString()));
-    }
-  }
-
-  return Status::OK();
-}
-
-Status XClusterTargetManager::ResumeStreamsAfterNewSchema(
-    const TableInfo& table_info, SchemaVersion consumer_schema_version, const LeaderEpoch& epoch) {
-  if (!FLAGS_xcluster_wait_on_ddl_alter) {
-    return Status::OK();
-  }
-
-  // With Replication Enabled, verify that we've finished applying the New Schema.
-  // If we're waiting for a Schema because we saw the a replication source with a change,
-  // resume replication now that the alter is complete.
-
-  auto stream_ids = GetStreamIdsForTable(table_info.id());
-  if (stream_ids.empty()) {
-    return Status::OK();
-  }
-
-  bool found_schema = false, resuming_replication = false;
-
-  // Now that we've applied the new schema: find pending replication, clear state, resume.
-  auto cluster_config = catalog_manager_.ClusterConfig();
-  auto l = cluster_config->LockForWrite();
-  for (const auto& [replication_group_id, stream_id] : stream_ids) {
-    // Fetch the stream entry to get Schema information.
-    auto replication_group_map =
-        l.mutable_data()->pb.mutable_consumer_registry()->mutable_producer_map();
-    auto producer_entry = FindOrNull(*replication_group_map, replication_group_id.ToString());
-    if (!producer_entry) {
-      continue;
-    }
-    auto stream_entry = FindOrNull(*producer_entry->mutable_stream_map(), stream_id.ToString());
-    if (!stream_entry) {
-      continue;
-    }
-
-    auto producer_schema_pb = stream_entry->mutable_producer_schema();
-    if (producer_schema_pb->has_pending_schema()) {
-      found_schema = true;
-      Schema consumer_schema, producer_schema;
-      RETURN_NOT_OK(table_info.GetSchema(&consumer_schema));
-      RETURN_NOT_OK(SchemaFromPB(producer_schema_pb->pending_schema(), &producer_schema));
-      if (consumer_schema.EquivalentForDataCopy(producer_schema)) {
-        resuming_replication = true;
-        auto pending_version = producer_schema_pb->pending_schema_version();
-        LOG(INFO) << "Consumer schema @ version " << consumer_schema_version
-                  << " is now data copy compatible with Producer: " << stream_id
-                  << " @ schema version " << pending_version;
-        // Clear meta we use to track progress on receiving all WAL entries with old schema.
-        producer_schema_pb->set_validated_schema_version(
-            std::max(producer_schema_pb->validated_schema_version(), pending_version));
-        producer_schema_pb->set_last_compatible_consumer_schema_version(consumer_schema_version);
-        producer_schema_pb->clear_pending_schema();
-        // Bump the ClusterConfig version so we'll broadcast new schema version & resume operation.
-        l.mutable_data()->pb.set_version(l.mutable_data()->pb.version() + 1);
-      } else {
-        LOG(INFO) << "Consumer schema not compatible for data copy of next Producer schema.";
-      }
-    }
-  }
-
-  if (resuming_replication) {
-    RETURN_NOT_OK_PREPEND(
-        sys_catalog_.Upsert(epoch, cluster_config.get()), "Failed updating cluster config");
-    l.Commit();
-    LOG(INFO) << "Resuming Replication on " << table_info.id() << " after Consumer ALTER.";
-  } else if (!found_schema) {
-    LOG(INFO) << "No pending schema change from Producer.";
-  }
-
-  return Status::OK();
-}
-
-Status XClusterTargetManager::ProcessPendingSchemaChanges(const LeaderEpoch& epoch) {
-  if (!GetAtomicFlag(&FLAGS_xcluster_wait_on_ddl_alter)) {
-    // See if any Streams are waiting on a pending_schema.
-    bool found_pending_schema = false;
-    auto cluster_config = catalog_manager_.ClusterConfig();
-    auto cl = cluster_config->LockForWrite();
-    auto replication_group_map =
-        cl.mutable_data()->pb.mutable_consumer_registry()->mutable_producer_map();
-    // For each user entry.
-    for (auto& replication_group_id_and_entry : *replication_group_map) {
-      // For each CDC stream in that Universe.
-      for (auto& stream_id_and_entry :
-           *replication_group_id_and_entry.second.mutable_stream_map()) {
-        auto& stream_entry = stream_id_and_entry.second;
-        if (stream_entry.has_producer_schema() &&
-            stream_entry.producer_schema().has_pending_schema()) {
-          // Force resume this stream.
-          auto schema = stream_entry.mutable_producer_schema();
-          schema->set_validated_schema_version(
-              std::max(schema->validated_schema_version(), schema->pending_schema_version()));
-          schema->clear_pending_schema();
-
-          found_pending_schema = true;
-          LOG(INFO) << "Force Resume Consumer schema: " << stream_id_and_entry.first
-                    << " @ schema version " << schema->pending_schema_version();
-        }
-      }
-    }
-
-    if (found_pending_schema) {
-      // Bump the ClusterConfig version so we'll broadcast new schema version & resume operation.
-      cl.mutable_data()->pb.set_version(cl.mutable_data()->pb.version() + 1);
-      RETURN_NOT_OK_PREPEND(
-          sys_catalog_.Upsert(epoch.leader_term, cluster_config.get()),
-          "Failed updating cluster config");
-      cl.Commit();
-    }
-  }
-
-  return Status::OK();
-}
-
 Status XClusterTargetManager::SetupUniverseReplication(
     const SetupUniverseReplicationRequestPB* req, SetupUniverseReplicationResponsePB* resp,
     const LeaderEpoch& epoch) {
diff --git a/src/yb/master/xcluster/xcluster_target_manager.h b/src/yb/master/xcluster/xcluster_target_manager.h
index fc55524aa6..d53496bdd4 100644
--- a/src/yb/master/xcluster/xcluster_target_manager.h
+++ b/src/yb/master/xcluster/xcluster_target_manager.h
@@ -164,13 +164,6 @@ class XClusterTargetManager {
       const TableId& consumer_table_id, const SplitTabletIds& split_tablet_ids,
       const LeaderEpoch& epoch) EXCLUDES(table_stream_ids_map_mutex_);
 
-  Status ValidateNewSchema(const TableInfo& table_info, const Schema& consumer_schema) const
-      EXCLUDES(table_stream_ids_map_mutex_);
-
-  Status ResumeStreamsAfterNewSchema(
-      const TableInfo& table_info, SchemaVersion consumer_schema_version, const LeaderEpoch& epoch)
-      EXCLUDES(table_stream_ids_map_mutex_);
-
   Status SetupUniverseReplication(
       const SetupUniverseReplicationRequestPB* req, SetupUniverseReplicationResponsePB* resp,
       const LeaderEpoch& epoch);
@@ -229,8 +222,6 @@ class XClusterTargetManager {
   std::unordered_map<xcluster::ReplicationGroupId, xrepl::StreamId> GetStreamIdsForTable(
       const TableId& table_id) const EXCLUDES(table_stream_ids_map_mutex_);
 
-  Status ProcessPendingSchemaChanges(const LeaderEpoch& epoch);
-
   Result<HybridTime> PrepareAndGetBackfillTimeForBiDirectionalIndex(
       const std::vector<TableId>& index_table_ids, const TableId& indexed_table,
       const LeaderEpoch& epoch) const;
diff --git a/src/yb/master/xrepl_catalog_manager.cc b/src/yb/master/xrepl_catalog_manager.cc
index 014a437f98..e8311f2807 100644
--- a/src/yb/master/xrepl_catalog_manager.cc
+++ b/src/yb/master/xrepl_catalog_manager.cc
@@ -3799,9 +3799,6 @@ Status CatalogManager::UpdateConsumerOnProducerMetadata(
   SCHECK(
       stream_entry, NotFound,
       Format("Missing replication group $0, stream $1", replication_group_id, stream_id));
-  auto schema_cached = stream_entry->mutable_producer_schema();
-  // Clear out any cached schema version
-  schema_cached->Clear();
 
   cdc::SchemaVersionsPB* schema_versions_pb = nullptr;
   bool schema_versions_updated = false;
diff --git a/src/yb/tserver/xcluster_consumer.cc b/src/yb/tserver/xcluster_consumer.cc
index 0f3654d297..76d6cabcd4 100644
--- a/src/yb/tserver/xcluster_consumer.cc
+++ b/src/yb/tserver/xcluster_consumer.cc
@@ -307,7 +307,6 @@ void XClusterConsumer::HandleMasterHeartbeatResponse(
   ddl_queue_streams_.clear();
   stream_schema_version_map_.clear();
   stream_colocated_schema_version_map_.clear();
-  stream_to_schema_version_.clear();
   min_schema_version_map_.clear();
 
   for (const auto& [replication_group_id_str, producer_entry_pb] :
@@ -353,11 +352,6 @@ void XClusterConsumer::UpdateReplicationGroupInMemState(
       LOG(INFO) << Format("Stream $0 is a ddl_queue stream", stream_id);
       ddl_queue_streams_.insert(stream_id);
     }
-    if (stream_entry_pb.has_producer_schema()) {
-      stream_to_schema_version_[stream_id] = std::make_pair(
-          stream_entry_pb.producer_schema().validated_schema_version(),
-          stream_entry_pb.producer_schema().last_compatible_consumer_schema_version());
-    }
 
     if (stream_entry_pb.has_schema_versions()) {
       auto& schema_version_map = stream_schema_version_map_[stream_id];
@@ -495,12 +489,6 @@ void XClusterConsumer::TriggerPollForNewTablets() {
           remote_clients_[replication_group_id] = std::move(*remote_client);
         }
 
-        SchemaVersion last_compatible_consumer_schema_version = cdc::kInvalidSchemaVersion;
-        auto schema_version = FindOrNull(stream_to_schema_version_, producer_tablet_info.stream_id);
-        if (schema_version) {
-          last_compatible_consumer_schema_version = schema_version->second;
-        }
-
         // Now create the poller.
         bool use_local_tserver =
             streams_with_local_tserver_optimization_.contains(producer_tablet_info.stream_id);
@@ -519,8 +507,7 @@ void XClusterConsumer::TriggerPollForNewTablets() {
             auto_flags_version_handler_->GetAutoFlagsCompatibleVersion(
                 producer_tablet_info.replication_group_id),
             thread_pool_.get(), rpcs_.get(), local_client_, remote_clients_[replication_group_id],
-            this, last_compatible_consumer_schema_version, leader_term, get_leader_term_func_,
-            entry.automatic_ddl_mode);
+            this, leader_term, get_leader_term_func_, entry.automatic_ddl_mode);
 
         if (ddl_queue_streams_.contains(producer_tablet_info.stream_id)) {
           xcluster_poller->InitDDLQueuePoller(
@@ -557,12 +544,6 @@ void XClusterConsumer::TriggerPollForNewTablets() {
 
 void XClusterConsumer::UpdatePollerSchemaVersionMaps(
     std::shared_ptr<XClusterPoller> xcluster_poller, const xrepl::StreamId& stream_id) const {
-  auto compatible_schema_version = FindOrNull(stream_to_schema_version_, stream_id);
-  if (compatible_schema_version) {
-    xcluster_poller->ScheduleSetSchemaVersionIfNeeded(
-        compatible_schema_version->first, compatible_schema_version->second);
-  }
-
   auto schema_versions = FindOrNull(stream_schema_version_map_, stream_id);
   if (schema_versions) {
     xcluster_poller->UpdateSchemaVersions(*schema_versions);
diff --git a/src/yb/tserver/xcluster_consumer.h b/src/yb/tserver/xcluster_consumer.h
index fdfe5aff7f..91bb5bc2cb 100644
--- a/src/yb/tserver/xcluster_consumer.h
+++ b/src/yb/tserver/xcluster_consumer.h
@@ -193,11 +193,6 @@ class XClusterConsumer : public XClusterConsumerIf {
       GUARDED_BY(master_data_mutex_);
   std::unordered_set<xrepl::StreamId> ddl_queue_streams_ GUARDED_BY(master_data_mutex_);
 
-  // Pair of validated_schema_version and last_compatible_consumer_schema_version.
-  using SchemaVersionMapping = std::pair<uint32_t, uint32_t>;
-  std::unordered_map<xrepl::StreamId, SchemaVersionMapping> stream_to_schema_version_
-      GUARDED_BY(master_data_mutex_);
-
   cdc::StreamSchemaVersionMap stream_schema_version_map_ GUARDED_BY(master_data_mutex_);
 
   cdc::StreamColocatedSchemaVersionMap stream_colocated_schema_version_map_
diff --git a/src/yb/tserver/xcluster_output_client.cc b/src/yb/tserver/xcluster_output_client.cc
index f096454e2d..b055e2c51c 100644
--- a/src/yb/tserver/xcluster_output_client.cc
+++ b/src/yb/tserver/xcluster_output_client.cc
@@ -156,16 +156,6 @@ void XClusterOutputClient::MarkFailedUnlocked(const std::string& reason, const S
   xcluster_poller_->MarkFailed(reason, status);
 }
 
-void XClusterOutputClient::SetLastCompatibleConsumerSchemaVersion(SchemaVersion schema_version) {
-  std::lock_guard lock(lock_);
-  if (schema_version != cdc::kInvalidSchemaVersion &&
-      schema_version > last_compatible_consumer_schema_version_) {
-    LOG_WITH_PREFIX(INFO) << "Last compatible consumer schema version updated to  "
-                          << schema_version;
-    last_compatible_consumer_schema_version_ = schema_version;
-  }
-}
-
 void XClusterOutputClient::UpdateSchemaVersionMappings(
     const cdc::XClusterSchemaVersionMap& schema_version_map,
     const cdc::ColocatedSchemaVersionMap& colocated_schema_version_map) {
@@ -200,7 +190,6 @@ void XClusterOutputClient::ApplyChanges(std::shared_ptr<cdc::GetChangesResponseP
     op_id_ = poller_resp->checkpoint().op_id();
     error_status_ = Status::OK();
     done_processing_ = false;
-    wait_for_version_ = 0;
     processed_record_count_ = 0;
     record_count_ = poller_resp->records_size();
     ResetWriteInterface(&write_strategy_);
@@ -412,8 +401,6 @@ Status XClusterOutputClient::ProcessRecord(
   for (const auto& tablet_id : tablet_ids) {
     SCHECK(!IsOffline(), Aborted, "$0$1", LogPrefix(), "xCluster output client went offline");
 
-    // Find the last_compatible_consumer_schema_version for each record as it may be different
-    // for different records depending on the colocation id.
     cdc::XClusterSchemaVersionMap schema_versions_map;
     if (PREDICT_TRUE(FLAGS_xcluster_enable_packed_rows_support) &&
         !record.changes().empty() &&
@@ -814,7 +801,6 @@ void XClusterOutputClient::HandleResponse() {
   if (response.status.ok()) {
     response.last_applied_op_id = op_id_;
     response.processed_record_count = processed_record_count_;
-    response.wait_for_version = wait_for_version_;
   }
   op_id_ = consensus::MinimumOpId();
   processed_record_count_ = 0;
diff --git a/src/yb/tserver/xcluster_output_client.h b/src/yb/tserver/xcluster_output_client.h
index 21f4e27059..0639647e8c 100644
--- a/src/yb/tserver/xcluster_output_client.h
+++ b/src/yb/tserver/xcluster_output_client.h
@@ -37,7 +37,6 @@ struct XClusterOutputClientResponse {
   Status status;
   OpIdPB last_applied_op_id;
   uint32_t processed_record_count;
-  uint32_t wait_for_version{0};
   std::shared_ptr<cdc::GetChangesResponsePB> get_changes_response;
 };
 
@@ -54,9 +53,6 @@ class XClusterOutputClient : public XClusterAsyncExecutor {
   void StartShutdown() override;
   void CompleteShutdown() override;
 
-  // Sets the last compatible consumer schema version
-  void SetLastCompatibleConsumerSchemaVersion(SchemaVersion schema_version);
-
   // Async call for applying changes. Will invoke the apply_changes_clbk when the changes are
   // applied, or when any error occurs.
   void ApplyChanges(std::shared_ptr<cdc::GetChangesResponsePB> resp);
@@ -147,13 +143,11 @@ class XClusterOutputClient : public XClusterAsyncExecutor {
   Status error_status_ GUARDED_BY(lock_);
   OpIdPB op_id_ GUARDED_BY(lock_) = consensus::MinimumOpId();
   bool done_processing_ GUARDED_BY(lock_) = false;
-  uint32_t wait_for_version_ GUARDED_BY(lock_) = 0;
   std::atomic<bool> shutdown_ = false;
 
   uint32_t processed_record_count_ GUARDED_BY(lock_) = 0;
   uint32_t record_count_ GUARDED_BY(lock_) = 0;
 
-  SchemaVersion last_compatible_consumer_schema_version_ GUARDED_BY(lock_) = 0;
   SchemaVersion producer_schema_version_ GUARDED_BY(lock_) = 0;
   ColocationId colocation_id_ GUARDED_BY(lock_) = 0;
 
diff --git a/src/yb/tserver/xcluster_poller.cc b/src/yb/tserver/xcluster_poller.cc
index 92f5c86e4b..506b4158f7 100644
--- a/src/yb/tserver/xcluster_poller.cc
+++ b/src/yb/tserver/xcluster_poller.cc
@@ -114,9 +114,8 @@ XClusterPoller::XClusterPoller(
     std::shared_ptr<const AutoFlagsCompatibleVersion> auto_flags_version, ThreadPool* thread_pool,
     rpc::Rpcs* rpcs, client::YBClient& local_client,
     const std::shared_ptr<client::XClusterRemoteClientHolder>& source_client,
-    XClusterConsumer* xcluster_consumer, SchemaVersion last_compatible_consumer_schema_version,
-    int64_t leader_term, std::function<int64_t(const TabletId&)> get_leader_term,
-    bool is_automatic_mode)
+    XClusterConsumer* xcluster_consumer, int64_t leader_term,
+    std::function<int64_t(const TabletId&)> get_leader_term, bool is_automatic_mode)
     : XClusterAsyncExecutor(thread_pool, local_client.messenger(), rpcs),
       producer_tablet_info_(producer_tablet_info),
       consumer_tablet_info_(consumer_tablet_info),
@@ -127,8 +126,6 @@ XClusterPoller::XClusterPoller(
       auto_flags_version_(std::move(auto_flags_version)),
       is_automatic_mode_(is_automatic_mode),
       op_id_(consensus::MinimumOpId()),
-      validated_schema_version_(0),
-      last_compatible_consumer_schema_version_(last_compatible_consumer_schema_version),
       get_leader_term_(std::move(get_leader_term)),
       local_client_(local_client),
       source_client_(source_client),
@@ -240,39 +237,6 @@ void XClusterPoller::UpdateColocatedSchemaVersionMap(
   }
 }
 
-void XClusterPoller::ScheduleSetSchemaVersionIfNeeded(
-    SchemaVersion cur_version, SchemaVersion last_compatible_consumer_schema_version) {
-  RETURN_WHEN_OFFLINE;
-
-  if (last_compatible_consumer_schema_version_ < last_compatible_consumer_schema_version ||
-      validated_schema_version_ < cur_version) {
-    ScheduleFunc(BIND_FUNCTION_AND_ARGS(
-        XClusterPoller::DoSetSchemaVersion, cur_version, last_compatible_consumer_schema_version));
-  }
-}
-
-void XClusterPoller::DoSetSchemaVersion(
-    SchemaVersion cur_version, SchemaVersion current_consumer_schema_version) {
-  ACQUIRE_MUTEX_IF_ONLINE_ELSE_RETURN;
-
-  if (last_compatible_consumer_schema_version_ < current_consumer_schema_version) {
-    last_compatible_consumer_schema_version_ = current_consumer_schema_version;
-  }
-
-  if (validated_schema_version_ < cur_version) {
-    validated_schema_version_ = cur_version;
-    // Re-enable polling. last_task_schedule_time_ is already current as it was set by the caller
-    // function ScheduleSetSchemaVersionIfNeeded.
-    if (!is_polling_.exchange(true)) {
-      LOG_WITH_PREFIX(INFO) << "Restarting polling on " << producer_tablet_info_.tablet_id
-                            << " Producer schema version : " << validated_schema_version_
-                            << " Consumer schema version : "
-                            << last_compatible_consumer_schema_version_;
-      ScheduleFunc(BIND_FUNCTION_AND_ARGS(XClusterPoller::DoPoll));
-    }
-  }
-}
-
 HybridTime XClusterPoller::GetSafeTime() const {
   SharedLock lock(safe_time_lock_);
   return producer_safe_time_;
@@ -398,7 +362,6 @@ void XClusterPoller::DoPoll() {
 
 void XClusterPoller::UpdateSchemaVersionsForApply() {
   SharedLock lock(schema_version_lock_);
-  output_client_->SetLastCompatibleConsumerSchemaVersion(last_compatible_consumer_schema_version_);
   output_client_->UpdateSchemaVersionMappings(schema_version_map_, colocated_schema_version_map_);
 }
 
@@ -568,16 +531,6 @@ void XClusterPoller::HandleApplyChangesResponse(XClusterOutputClientResponse res
 
     idle_polls_ = (response.processed_record_count == 0) ? idle_polls_ + 1 : 0;
 
-    if (validated_schema_version_ < response.wait_for_version) {
-      LOG_WITH_PREFIX(WARNING) << "Pausing Poller since producer schema version "
-                               << response.wait_for_version
-                               << " is higher than consumer schema version "
-                               << validated_schema_version_;
-      is_polling_ = false;
-      validated_schema_version_ = response.wait_for_version - 1;
-      return;
-    }
-
     if (response.get_changes_response->has_safe_hybrid_time()) {
       // Once all changes have been successfully applied we can update the safe time.
       UpdateSafeTime(response.get_changes_response->safe_hybrid_time());
@@ -635,14 +588,11 @@ bool XClusterPoller::IsLeaderTermValid() {
 }
 
 bool XClusterPoller::IsStuck() const {
-  if (is_polling_) {
-    const auto lag = MonoTime::Now() - last_task_schedule_time_;
-    if (lag > 1s * GetAtomicFlag(&FLAGS_xcluster_poller_task_delay_considered_stuck_secs)) {
-      LOG_WITH_PREFIX(ERROR) << "XCluster Poller has not executed any tasks for " << lag.ToString();
-      return true;
-    }
+  const auto lag = MonoTime::Now() - last_task_schedule_time_;
+  if (lag > 1s * GetAtomicFlag(&FLAGS_xcluster_poller_task_delay_considered_stuck_secs)) {
+    LOG_WITH_PREFIX(ERROR) << "XCluster Poller has not executed any tasks for " << lag.ToString();
+    return true;
   }
-
   return false;
 }
 
@@ -650,9 +600,6 @@ std::string XClusterPoller::State() const {
   if (is_failed_) {
     return "Failed";
   }
-  if (!is_polling_) {
-    return "Paused";
-  }
 
   return "Running";
 }
diff --git a/src/yb/tserver/xcluster_poller.h b/src/yb/tserver/xcluster_poller.h
index 66dde731a4..8a7a713732 100644
--- a/src/yb/tserver/xcluster_poller.h
+++ b/src/yb/tserver/xcluster_poller.h
@@ -60,9 +60,8 @@ class XClusterPoller : public XClusterAsyncExecutor {
       std::shared_ptr<const AutoFlagsCompatibleVersion> auto_flags_version, ThreadPool* thread_pool,
       rpc::Rpcs* rpcs, client::YBClient& local_client,
       const std::shared_ptr<client::XClusterRemoteClientHolder>& source_client,
-      XClusterConsumer* xcluster_consumer, SchemaVersion last_compatible_consumer_schema_version,
-      int64_t leader_term, std::function<int64_t(const TabletId&)> get_leader_term,
-      bool is_automatic_mode);
+      XClusterConsumer* xcluster_consumer, int64_t leader_term,
+      std::function<int64_t(const TabletId&)> get_leader_term, bool is_automatic_mode);
   ~XClusterPoller();
 
   void Init(bool use_local_tserver, rocksdb::RateLimiter* rate_limiter);
@@ -79,9 +78,6 @@ class XClusterPoller : public XClusterAsyncExecutor {
   // Begins poll process for a producer tablet.
   void SchedulePoll();
 
-  void ScheduleSetSchemaVersionIfNeeded(
-      SchemaVersion cur_version, SchemaVersion last_compatible_consumer_schema_version);
-
   void UpdateSchemaVersions(const cdc::XClusterSchemaVersionMap& schema_versions)
       EXCLUDES(schema_version_lock_);
 
@@ -125,9 +121,6 @@ class XClusterPoller : public XClusterAsyncExecutor {
 
   bool IsOffline() override;
 
-  void DoSetSchemaVersion(SchemaVersion cur_version, SchemaVersion current_consumer_schema_version)
-      EXCLUDES(data_mutex_);
-
   void DoPoll() EXCLUDES(data_mutex_);
 
   void HandleGetChangesResponse(Status status, std::shared_ptr<cdc::GetChangesResponsePB> resp)
@@ -162,8 +155,6 @@ class XClusterPoller : public XClusterAsyncExecutor {
   std::condition_variable shutdown_cv_;
 
   OpIdPB op_id_ GUARDED_BY(data_mutex_);
-  std::atomic<SchemaVersion> validated_schema_version_;
-  std::atomic<SchemaVersion> last_compatible_consumer_schema_version_;
   std::function<int64_t(const TabletId&)> get_leader_term_;
 
   client::YBClient& local_client_;
@@ -177,7 +168,6 @@ class XClusterPoller : public XClusterAsyncExecutor {
   mutable rw_spinlock safe_time_lock_;
   HybridTime producer_safe_time_ GUARDED_BY(safe_time_lock_);
 
-  std::atomic<bool> is_polling_ = true;
   std::atomic<uint32> poll_failures_ = 0;
   std::atomic<uint32> apply_failures_ = 0;
   std::atomic<uint32> idle_polls_ = 0;
