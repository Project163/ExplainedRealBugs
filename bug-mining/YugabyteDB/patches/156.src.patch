diff --git a/python/yugabyte/yb_dist_tests.py b/python/yugabyte/yb_dist_tests.py
index 3f0787d4d1..d143c6c6a8 100644
--- a/python/yugabyte/yb_dist_tests.py
+++ b/python/yugabyte/yb_dist_tests.py
@@ -193,6 +193,7 @@ ARCHIVED_PATHS_IN_BUILD_DIR = [
     'thirdparty_path.txt',
     'thirdparty_url.txt',
     'upgrade_test_builds',
+    'gflag_allowlist.txt',
     f'{POSTGRES_BUILD_SUBDIR}/contrib',
     f'{POSTGRES_BUILD_SUBDIR}/src/test/regress',
     f'{POSTGRES_BUILD_SUBDIR}/src/test/isolation',
diff --git a/src/yb/gflag_allowlist.txt b/src/yb/gflag_allowlist.txt
new file mode 100644
index 0000000000..997d917d69
--- /dev/null
+++ b/src/yb/gflag_allowlist.txt
@@ -0,0 +1,64 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+
+// This file contains the list of string gFlags that do not contain sensitive or PII data.
+// Each line should contain a single flag name.
+// Flags tagged as sensitive_info are not allowed.
+// If the flag does not exist, then it will be safely ignored.
+
+allowed_preview_flags_csv
+callhome_collection_level
+callhome_tag
+callhome_url
+cipher_list
+ciphersuites
+compression_type
+fromenv
+metric_node_name
+metrics_snapshotter_table_metrics_whitelist
+metrics_snapshotter_tserver_metrics_whitelist
+minicluster_daemon_id
+net_address_filter
+pg_mem_tracker_tcmalloc_gc_release_bytes
+pg_mem_tracker_update_consumption_interval_us
+placement_cloud
+placement_region
+placement_uuid
+placement_zone
+redis_passwords_separator
+ref_counted_debug_type_name_regex
+regular_tablets_data_block_key_value_encoding
+rocksdb_compact_flush_rate_limit_sharing_mode
+ssl_protocols
+trace_to_console
+tryfromenv
+undefok
+use_private_ip
+vmodule
+yb_backend_oom_score_adj
+yb_test_name
+yb_webserver_oom_score_adj
+ycql_audit_log_level
+ysql_datestyle
+ysql_default_transaction_isolation
+ysql_log_min_messages
+ysql_log_statement
+ysql_pg_conf
+ysql_pg_conf_csv
+ysql_sequence_cache_method
+ysql_timezone
+ysql_yb_default_replica_identity
+ysql_yb_read_after_commit_visibility
+ysql_yb_test_block_index_phase
+ysql_yb_xcluster_consistency_level
diff --git a/src/yb/master/master-test.cc b/src/yb/master/master-test.cc
index bd0db6bafc..a137c672f0 100644
--- a/src/yb/master/master-test.cc
+++ b/src/yb/master/master-test.cc
@@ -163,7 +163,7 @@ TEST_F(MasterTest, TestCallHome) {
   const auto webserver_dir = GetWebserverDir();
   CHECK_OK(env_->CreateDir(webserver_dir));
   TestCallHome<Master, MasterCallHome>(
-      webserver_dir, {"version_info", "masters", "tservers", "tables"}, mini_master_->master());
+      webserver_dir, {"masters", "tservers", "tables"}, mini_master_->master());
 }
 
 // This tests whether the enabling/disabling of callhome is happening dynamically
diff --git a/src/yb/master/master_call_home.cc b/src/yb/master/master_call_home.cc
index 5cd1f00816..15c50c98a5 100644
--- a/src/yb/master/master_call_home.cc
+++ b/src/yb/master/master_call_home.cc
@@ -10,13 +10,12 @@
 // or implied.  See the License for the specific language governing permissions and limitations
 // under the License.
 
-#include "yb/gutil/walltime.h"
 #include "yb/master/master_call_home.h"
 #include "yb/master/catalog_manager_if.h"
+#include "yb/master/master.h"
 #include "yb/master/master_ddl.pb.h"
 #include "yb/master/ts_descriptor.h"
 #include "yb/master/ts_manager.h"
-#include "yb/util/version_info.h"
 
 using std::string;
 using std::vector;
@@ -33,20 +32,12 @@ class BasicCollector : public MasterCollector {
   using MasterCollector::MasterCollector;
 
   void Collect(CollectionLevel collection_level) override {
+    AppendPairToJson("server_type", "master", &json_);
+
     auto config = master()->catalog_manager()->GetClusterConfig();
     if (config.ok()) {
       AppendPairToJson("cluster_uuid", config->cluster_uuid(), &json_);
     }
-    AppendPairToJson("node_uuid", master()->fs_manager()->uuid(), &json_);
-    AppendPairToJson("server_type", "master", &json_);
-
-    // Only collect hostname and username if collection level is medium or high.
-    if (collection_level != CollectionLevel::LOW) {
-      AppendPairToJson("hostname", master()->get_hostname(), &json_);
-      AppendPairToJson("current_user", GetCurrentUser(), &json_);
-    }
-    json_ += ",\"version_info\":" + VersionInfo::GetAllVersionInfoJson();
-    AppendPairToJson("timestamp", std::to_string(WallTime_Now()), &json_);
   }
 
   string collector_name() override { return "BasicCollector"; }
diff --git a/src/yb/master/master_call_home.h b/src/yb/master/master_call_home.h
index 868dc848ae..89c422a942 100644
--- a/src/yb/master/master_call_home.h
+++ b/src/yb/master/master_call_home.h
@@ -12,7 +12,6 @@
 
 #pragma once
 
-#include "yb/master/master.h"
 #include "yb/server/call_home.h"
 
 namespace yb {
diff --git a/src/yb/server/call_home-test-util.h b/src/yb/server/call_home-test-util.h
index c51f302272..53278525b6 100644
--- a/src/yb/server/call_home-test-util.h
+++ b/src/yb/server/call_home-test-util.h
@@ -15,8 +15,7 @@
 #include "yb/server/call_home.h"
 #include "yb/util/flags.h"
 #include "yb/util/jsonreader.h"
-#include "yb/util/test_util.h"
-#include "yb/common/wire_protocol.h"
+#include "yb/util/test_macros.h"
 #include "yb/util/tsan_util.h"
 #include "yb/util/user.h"
 #include <boost/asio/ip/tcp.hpp>
@@ -30,6 +29,7 @@ DECLARE_int32(callhome_interval_secs);
 DECLARE_string(ysql_pg_conf_csv);
 DECLARE_string(ysql_hba_conf_csv);
 DECLARE_bool(remote_bootstrap_from_leader_only);
+DECLARE_string(ysql_cron_database_name);
 
 DEFINE_test_flag(bool, call_home_dummy1, false, "Dummy test flag to test call home");
 DEFINE_test_flag(bool, call_home_dummy2, false, "Dummy test flag to test call home");
@@ -65,14 +65,13 @@ void TestCallHome(
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_callhome_tag) = tag_value;
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_callhome_url) = Format("http://$0/callhome", addr);
 
-  std::set<std::string> low{"cluster_uuid", "node_uuid", "server_type",
-                       "timestamp",    "tablets",   "gflags"};
+  std::set<std::string> low{"cluster_uuid", "node_uuid", "server_type", "timestamp",
+                            "tablets",      "gflags",    "version_info"};
   low.insert(additional_collections.begin(), additional_collections.end());
 
   std::unordered_map<std::string, std::set<std::string>> collection_levels;
   collection_levels["low"] = low;
   collection_levels["medium"] = low;
-  collection_levels["medium"].insert({"hostname", "current_user"});
   collection_levels["high"] = collection_levels["medium"];
   collection_levels["high"].insert({"metrics", "rpcs"});
 
@@ -95,12 +94,6 @@ void TestCallHome(
     ASSERT_OK(reader.ExtractString(reader.root(), "tag", &received_tag));
     ASSERT_EQ(received_tag, tag_value);
 
-    if (collection_level.second.find("hostname") != collection_level.second.end()) {
-      std::string received_hostname;
-      ASSERT_OK(reader.ExtractString(reader.root(), "hostname", &received_hostname));
-      ASSERT_EQ(received_hostname, server->get_hostname());
-    }
-
     if (collection_level.second.find("current_user") != collection_level.second.end()) {
       std::string received_user;
       ASSERT_OK(reader.ExtractString(reader.root(), "current_user", &received_user));
@@ -187,6 +180,8 @@ void TestGFlagsCallHome(ServerType* server) {
   ASSERT_OK(SET_FLAG(ysql_hba_conf_csv, kHbaValue));
   ASSERT_OK(SET_FLAG(remote_bootstrap_from_leader_only, true));
   ASSERT_OK(SET_FLAG(TEST_call_home_dummy1, true));
+  const auto kSecretDBname = "shhh_db";
+  ASSERT_OK(SET_FLAG(ysql_cron_database_name, kSecretDBname));
   std::string json;
   CallHomeType call_home(server);
   json = call_home.BuildJson();
@@ -208,6 +203,9 @@ void TestGFlagsCallHome(ServerType* server) {
   // TEST flags should only be included if they are non default.
   ASSERT_STR_CONTAINS(flags, "call_home_dummy1");
   ASSERT_STR_NOT_CONTAINS(flags, "call_home_dummy2");
+  // Secret db name should be masked.
+  ASSERT_STR_NOT_CONTAINS(flags, kSecretDBname);
+  ASSERT_STR_CONTAINS(flags, "ysql_cron_database_name=***");
 
   call_home.Shutdown();
 }
diff --git a/src/yb/server/call_home.cc b/src/yb/server/call_home.cc
index c4723a207b..0c9679cafc 100644
--- a/src/yb/server/call_home.cc
+++ b/src/yb/server/call_home.cc
@@ -11,7 +11,6 @@
 // under the License.
 
 #include <sstream>
-#include <thread>
 
 #include <boost/algorithm/string.hpp>
 #include <boost/optional.hpp>
@@ -25,7 +24,6 @@
 
 #include "yb/util/atomic.h"
 #include "yb/util/flags/flag_tags.h"
-#include "yb/util/monotime.h"
 #include "yb/util/net/net_fwd.h"
 #include "yb/util/flags.h"
 #include "yb/util/jsonwriter.h"
@@ -103,6 +101,22 @@ std::string GetCurrentUser() {
   }
 }
 
+class GenericServerCollector : public Collector {
+ public:
+  using Collector::Collector;
+
+  void Collect(CollectionLevel collection_level) {
+    AppendPairToJson("node_uuid", server_->fs_manager()->uuid(), &json_);
+    // GetAllVersionInfoJson is already a json object so cannot use AppendPairToJson.
+    json_ += ",\"version_info\":" + VersionInfo::GetAllVersionInfoJson();
+    AppendPairToJson("timestamp", std::to_string(WallTime_Now()), &json_);
+  }
+
+  string collector_name() { return "GenericServerCollector"; }
+
+  virtual CollectionLevel collection_level() { return CollectionLevel::LOW; }
+};
+
 class MetricsCollector : public Collector {
  public:
   using Collector::Collector;
@@ -183,7 +197,7 @@ class GFlagsCollector : public Collector {
         [webserver = server_->web_server()](const std::string& flag_name) {
           return webserver->ContainsAutoFlag(flag_name);
         },
-        /*default_flag_filter=*/nullptr, /*custom_varz=*/{});
+        /*default_flag_filter=*/nullptr, /*custom_varz=*/{}, /*mask_value_if_private=*/true);
 
     std::stringstream gflags;
     for (const auto& [tag, flags] : flag_infos) {
@@ -210,6 +224,7 @@ CallHome::CallHome(server::RpcAndWebServerBase* server) : server_(server), pool_
   scheduler_ = std::make_unique<yb::rpc::Scheduler>(&pool_.io_service());
   curl_.set_follow_redirects(true);
 
+  AddCollector<GenericServerCollector>();
   AddCollector<MetricsCollector>();
   AddCollector<RpcsCollector>();
   AddCollector<GFlagsCollector>();
diff --git a/src/yb/tserver/tserver_call_home.cc b/src/yb/tserver/tserver_call_home.cc
index 5806a42233..0f0f8e4e9f 100644
--- a/src/yb/tserver/tserver_call_home.cc
+++ b/src/yb/tserver/tserver_call_home.cc
@@ -12,7 +12,7 @@
 
 #include "yb/tserver/tserver_call_home.h"
 #include <boost/system/error_code.hpp>
-#include "yb/gutil/walltime.h"
+#include "yb/tserver/tablet_server.h"
 #include "yb/tserver/ts_tablet_manager.h"
 
 using std::string;
@@ -28,17 +28,8 @@ class BasicCollector : public TserverCollector {
   using TserverCollector::TserverCollector;
 
   void Collect(CollectionLevel collection_level) override {
-    AppendPairToJson("cluster_uuid", tserver()->cluster_uuid(), &json_);
-    AppendPairToJson("node_uuid", tserver()->permanent_uuid(), &json_);
     AppendPairToJson("server_type", "tserver", &json_);
-
-    // Only collect hostname and username if collection level is medium or high.
-    if (collection_level != CollectionLevel::LOW) {
-      AppendPairToJson("hostname", tserver()->get_hostname(), &json_);
-      AppendPairToJson("current_user", GetCurrentUser(), &json_);
-    }
-
-    AppendPairToJson("timestamp", std::to_string(WallTime_Now()), &json_);
+    AppendPairToJson("cluster_uuid", tserver()->cluster_uuid(), &json_);
   }
 
   string collector_name() override { return "BasicCollector"; }
diff --git a/src/yb/tserver/tserver_call_home.h b/src/yb/tserver/tserver_call_home.h
index 3186f22b14..b5d1cdcca9 100644
--- a/src/yb/tserver/tserver_call_home.h
+++ b/src/yb/tserver/tserver_call_home.h
@@ -13,12 +13,13 @@
 #pragma once
 
 #include "yb/server/call_home.h"
-#include "yb/tserver/tablet_server.h"
 
 namespace yb {
 
 namespace tserver {
 
+class TabletServer;
+
 class TserverCallHome : public CallHome {
  public:
   explicit TserverCallHome(TabletServer* server);
diff --git a/src/yb/util/CMakeLists.txt b/src/yb/util/CMakeLists.txt
index c67ec66a7f..424b04ed9a 100644
--- a/src/yb/util/CMakeLists.txt
+++ b/src/yb/util/CMakeLists.txt
@@ -302,6 +302,11 @@ ADD_YB_LIBRARY(yb_util
 
 add_dependencies(yb_util gen_version_info)
 
+configure_file(
+  ${CMAKE_SOURCE_DIR}/src/yb/gflag_allowlist.txt
+  ${CMAKE_BINARY_DIR}/gflag_allowlist.txt
+  COPYONLY)
+
 #######################################
 # yb_test_util
 #######################################
diff --git a/src/yb/util/flags.h b/src/yb/util/flags.h
index b65934041c..6ab6d02586 100644
--- a/src/yb/util/flags.h
+++ b/src/yb/util/flags.h
@@ -233,6 +233,6 @@ struct FlagInfo {
 std::unordered_map<FlagType, std::vector<FlagInfo>> GetFlagInfos(
     std::function<bool(const std::string&)> auto_flags_filter,
     std::function<bool(const std::string&)> default_flags_filter,
-    const std::map<std::string, std::string>& custom_varz);
+    const std::map<std::string, std::string>& custom_varz, bool mask_value_if_private = false);
 
 } // namespace yb
diff --git a/src/yb/util/flags/flags-test.cc b/src/yb/util/flags/flags-test.cc
index 22ae98bd2c..e8e15d47ef 100644
--- a/src/yb/util/flags/flags-test.cc
+++ b/src/yb/util/flags/flags-test.cc
@@ -51,6 +51,9 @@ bool ValidateSecretFlag(const char* flag_name, const std::string& new_val) {
 }
 DEFINE_validator(flagstest_secret_flag, &ValidateSecretFlag);
 
+DEFINE_NON_RUNTIME_string(ysql_cron_database_name, "",
+    "This is a duplicate flag used only for testing");
+
 namespace yb {
 
 class FlagsTest : public YBTest {
@@ -323,4 +326,25 @@ TEST_F(FlagsTest, NewInstallValue) {
   ASSERT_FALSE(new_install_value.has_value());
 }
 
+namespace flags_internal {
+bool IsFlagPrivate(const gflags::CommandLineFlagInfo& flag_info);
+}  // namespace flags_internal
+
+TEST_F(FlagsTest, AllowList) {
+  auto is_flag_private = [](const std::string& flag_name) {
+    gflags::CommandLineFlagInfo flag_info;
+    EXPECT_TRUE(google::GetCommandLineFlagInfo(flag_name.c_str(), &flag_info));
+    return flags_internal::IsFlagPrivate(flag_info);
+  };
+
+  // Non string flags should always be allowed.
+  ASSERT_FALSE(is_flag_private("flagstest_testflag"));
+
+  // Allowed string flag.
+  ASSERT_FALSE(is_flag_private("vmodule"));
+
+  // Not allowed string flag.
+  ASSERT_TRUE(is_flag_private("ysql_cron_database_name"));
+}
+
 } // namespace yb
diff --git a/src/yb/util/flags/flags.cc b/src/yb/util/flags/flags.cc
index d60bb19b7d..7fa11719e4 100644
--- a/src/yb/util/flags/flags.cc
+++ b/src/yb/util/flags/flags.cc
@@ -36,6 +36,8 @@
 #include <unordered_set>
 #include <vector>
 #include <boost/algorithm/string/replace.hpp>
+#include <boost/algorithm/string/trim.hpp>
+
 #include "yb/gutil/map-util.h"
 #include "yb/gutil/once.h"
 #include "yb/gutil/strings/split.h"
@@ -280,6 +282,7 @@ string GetStaticProgramName() {
 namespace flags_internal {
 Status ValidateFlagValue(const CommandLineFlagInfo& flag_info, const std::string& value);
 std::optional<std::string> GetFlagNewInstallValue(const std::string& flag_name);
+bool IsStringFlagAllowed(const std::string& flag_name);
 }  // namespace flags_internal
 
 namespace {
@@ -595,6 +598,57 @@ void UpdateVmodule() {
   }
 }
 
+// Read the flags text file and return the list of flag names.
+// Each line in the file should contain a single flag name.
+// Empty lines and lines starting with // are ignored.
+Result<std::unordered_set<std::string>> GetFlagNamesFromTxtFile(const std::string& flag_file_name) {
+  std::unordered_set<std::string> flag_names;
+
+  std::string build_path = yb::env_util::GetRootDir("bin");
+
+  auto full_path = JoinPathSegments(build_path, flag_file_name);
+  std::ifstream txt_file(full_path, std::ios_base::in);
+  SCHECK(txt_file, IOError, Format("Could not open text file $0: $1", full_path, strerror(errno)));
+
+  std::string line;
+  while (std::getline(txt_file, line)) {
+    boost::trim(line);
+    if (line.empty() || line.starts_with("//")) {
+      continue;
+    }
+
+    static std::regex valid_flag_re(R"#(^\s*([\w\d]+)\s*$)#");
+
+    std::smatch match;
+    SCHECK(
+        std::regex_search(line, match, valid_flag_re), Corruption,
+        "Invalid flag name '$0' in flag file $1", line, full_path);
+
+    flag_names.insert(match.str());
+  }
+
+  return flag_names;
+}
+
+std::mutex public_string_flags_mutex;
+std::unordered_set<std::string> public_string_flags GUARDED_BY(public_string_flags_mutex);
+
+Status LoadFlagsAllowlist() {
+  auto flags = VERIFY_RESULT(GetFlagNamesFromTxtFile("gflag_allowlist.txt"));
+
+  for (const auto& flag_name : flags) {
+    unordered_set<FlagTag> tags;
+    GetFlagTags(flag_name, &tags);
+    SCHECK_FORMAT(
+        !tags.contains(FlagTag::kSensitive_info), Corruption,
+        "Sensitive flag '$0' cannot be added to the allow list", flag_name);
+  }
+
+  std::lock_guard l(public_string_flags_mutex);
+  public_string_flags.swap(flags);
+  return Status::OK();
+}
+
 }  // anonymous namespace
 
 void ParseCommandLineFlags(int* argc, char*** argv, bool remove_flags) {
@@ -609,6 +663,8 @@ void ParseCommandLineFlags(int* argc, char*** argv, bool remove_flags) {
         &FLAGS_vmodule, "ValidateAndUpdateVmodule", &UpdateVmodule);
   });
 
+  CHECK_OK(LoadFlagsAllowlist());
+
   {
     std::vector<google::CommandLineFlagInfo> flag_infos;
     google::GetAllFlags(&flag_infos);
@@ -755,6 +811,14 @@ bool IsFlagSensitive(const std::string& flag_name) {
   return IsFlagSensitive(tags);
 }
 
+bool IsFlagPrivate(const CommandLineFlagInfo& flag_info) {
+  if (flag_info.type != "string") {
+    return false;
+  }
+  std::lock_guard l(public_string_flags_mutex);
+  return !public_string_flags.contains(flag_info.name);
+}
+
 std::string GetMaskedValueIfSensitive(
     const unordered_set<FlagTag>& tags, const std::string& value) {
   if (IsFlagSensitive(tags)) {
@@ -1007,7 +1071,7 @@ Result<std::unordered_set<std::string>> GetFlagNamesFromXmlFile(const std::strin
 std::unordered_map<FlagType, std::vector<FlagInfo>> GetFlagInfos(
     std::function<bool(const std::string&)> auto_flags_filter,
     std::function<bool(const std::string&)> default_flags_filter,
-    const std::map<std::string, std::string>& custom_varz) {
+    const std::map<std::string, std::string>& custom_varz, bool mask_value_if_private) {
   const std::set<string> node_info_flags{
       "log_filename",    "rpc_bind_addresses", "webserver_interface", "webserver_port",
       "placement_cloud", "placement_region",   "placement_zone"};
@@ -1021,6 +1085,9 @@ std::unordered_map<FlagType, std::vector<FlagInfo>> GetFlagInfos(
     FlagInfo flag_info;
     flag_info.name = flag.name;
     flag_info.value = flags_internal::GetMaskedValueIfSensitive(flag_tags, flag.current_value);
+    if (mask_value_if_private && flags_internal::IsFlagPrivate(flag)) {
+      flag_info.value = flags_internal::kMaskedFlagValue;
+    }
 
     auto type = FlagType::kDefault;
     if (node_info_flags.contains(flag.name)) {
