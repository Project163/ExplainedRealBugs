diff --git a/src/yb/master/CMakeLists.txt b/src/yb/master/CMakeLists.txt
index b9cda11fc8..eb4f70e294 100644
--- a/src/yb/master/CMakeLists.txt
+++ b/src/yb/master/CMakeLists.txt
@@ -77,6 +77,7 @@ set(MASTER_SRCS
   catalog_manager.cc
   catalog_manager_ext.cc
   catalog_manager_util.cc
+  catalog_entity_base.cc
   catalog_entity_info.cc
   catalog_manager_bg_tasks.cc
   catalog_loaders.cc
diff --git a/src/yb/master/catalog_entity_base.cc b/src/yb/master/catalog_entity_base.cc
new file mode 100644
index 0000000000..5ed2f7fa89
--- /dev/null
+++ b/src/yb/master/catalog_entity_base.cc
@@ -0,0 +1,147 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/master/catalog_entity_base.h"
+#include "yb/master/tasks_tracker.h"
+
+#include "yb/util/shared_lock.h"
+
+namespace yb::master {
+
+CatalogEntityWithTasks::CatalogEntityWithTasks(scoped_refptr<TasksTracker> tasks_tracker)
+    : tasks_tracker_(tasks_tracker) {}
+
+std::size_t CatalogEntityWithTasks::NumTasks() const {
+  SharedLock l(mutex_);
+  return pending_tasks_.size();
+}
+
+bool CatalogEntityWithTasks::HasTasks() const {
+  SharedLock l(mutex_);
+  VLOG_WITH_FUNC(3) << AsString(pending_tasks_);
+  return !pending_tasks_.empty();
+}
+
+bool CatalogEntityWithTasks::HasTasks(server::MonitoredTaskType type) const {
+  SharedLock l(mutex_);
+  for (const auto& task : pending_tasks_) {
+    if (task->type() == type) {
+      return true;
+    }
+  }
+  return false;
+}
+
+void CatalogEntityWithTasks::AddTask(server::MonitoredTaskPtr task) {
+  bool abort_task = false;
+  {
+    std::lock_guard l(mutex_);
+    if (!closing_) {
+      pending_tasks_.insert(task);
+      if (tasks_tracker_) {
+        tasks_tracker_->AddTask(task);
+      }
+    } else {
+      abort_task = true;
+    }
+  }
+  // We need to abort these tasks without holding the lock because when a task is destroyed it tries
+  // to acquire the same lock to remove itself from pending_tasks_.
+  if (abort_task) {
+    task->AbortAndReturnPrevState(STATUS(Expired, "Table closing"));
+  }
+}
+
+bool CatalogEntityWithTasks::RemoveTask(const server::MonitoredTaskPtr& task) {
+  bool result;
+  {
+    std::lock_guard l(mutex_);
+    pending_tasks_.erase(task);
+    result = pending_tasks_.empty();
+  }
+  VLOG(1) << "Removed task " << task.get() << " " << task->description();
+  return result;
+}
+
+// Aborts tasks which have their rpc in progress, rest of them are aborted and also erased
+// from the pending list.
+void CatalogEntityWithTasks::AbortTasks() { AbortTasksAndCloseIfRequested(/* close */ false); }
+
+void CatalogEntityWithTasks::AbortTasksAndClose() {
+  AbortTasksAndCloseIfRequested(/* close */ true);
+}
+
+void CatalogEntityWithTasks::AbortTasksAndCloseIfRequested(bool close) {
+  std::vector<server::MonitoredTaskPtr> abort_tasks;
+  {
+    std::lock_guard l(mutex_);
+    if (close) {
+      closing_ = true;
+    }
+    abort_tasks.reserve(pending_tasks_.size());
+    abort_tasks.assign(pending_tasks_.cbegin(), pending_tasks_.cend());
+  }
+
+  if (abort_tasks.empty()) {
+    return;
+  }
+  auto status = close ? STATUS(Expired, "Table closing") : STATUS(Aborted, "Table closing");
+  // We need to abort these tasks without holding the lock because when a task is destroyed it tries
+  // to acquire the same lock to remove itself from pending_tasks_.
+  for (const auto& task : abort_tasks) {
+    VLOG_WITH_FUNC(1) << (close ? "Close and abort" : "Abort") << " task " << task.get() << " "
+                      << task->description();
+    task->AbortAndReturnPrevState(status);
+  }
+}
+
+void CatalogEntityWithTasks::WaitTasksCompletion() {
+  const auto kMaxSleep = MonoDelta::FromSeconds(5);
+  const double kSleepMultiplier = 5.0 / 4;
+
+  auto sleep_time = MonoDelta::FromMilliseconds(5);
+  std::vector<server::MonitoredTaskPtr> waiting_list;
+  while (true) {
+    const bool should_log_info = sleep_time >= kMaxSleep;
+    {
+      SharedLock l(mutex_);
+      if (pending_tasks_.empty()) {
+        return;
+      }
+
+      if (VLOG_IS_ON(1) || should_log_info) {
+        waiting_list.clear();
+        waiting_list.reserve(pending_tasks_.size());
+        waiting_list.assign(pending_tasks_.cbegin(), pending_tasks_.cend());
+      }
+    }
+
+    for (const auto& task : waiting_list) {
+      if (should_log_info) {
+        LOG(WARNING) << "Long wait for aborting task " << task.get() << " " << task->description();
+      } else {
+        VLOG(1) << "Waiting for aborting task " << task.get() << " " << task->description();
+      }
+    }
+
+    SleepFor(sleep_time);
+    sleep_time = std::min(sleep_time * kSleepMultiplier, kMaxSleep);
+  }
+}
+
+std::unordered_set<server::MonitoredTaskPtr> CatalogEntityWithTasks::GetTasks() const {
+  SharedLock l(mutex_);
+  return pending_tasks_;
+}
+
+}  // namespace yb::master
diff --git a/src/yb/master/catalog_entity_base.h b/src/yb/master/catalog_entity_base.h
index 683e6e38ea..51d1e70bb1 100644
--- a/src/yb/master/catalog_entity_base.h
+++ b/src/yb/master/catalog_entity_base.h
@@ -13,11 +13,16 @@
 
 #pragma once
 
+#include <shared_mutex>
+
 #include "yb/master/master_types.pb.h"
+#include "yb/server/monitored_task.h"
 #include "yb/util/cow_object.h"
 
 namespace yb::master {
 
+class TasksTracker;
+
 // This class is a base wrapper around the protos that get serialized in the data column of the
 // sys_catalog. Subclasses of this will provide convenience getter/setter methods around the
 // protos and instances of these will be wrapped around CowObjects and locks for access and
@@ -98,4 +103,37 @@ class SingletonMetadataCowWrapper : public MetadataCowWrapper<PersistentDataEntr
   }
 };
 
+class CatalogEntityWithTasks {
+ public:
+  explicit CatalogEntityWithTasks(scoped_refptr<TasksTracker> tasks_tracker);
+  virtual ~CatalogEntityWithTasks() = default;
+
+  bool HasTasks() const EXCLUDES(mutex_);
+  bool HasTasks(server::MonitoredTaskType type) const EXCLUDES(mutex_);
+  std::size_t NumTasks() const EXCLUDES(mutex_);
+  std::unordered_set<server::MonitoredTaskPtr> GetTasks() const EXCLUDES(mutex_);
+
+  void AddTask(server::MonitoredTaskPtr task) EXCLUDES(mutex_);
+
+  // Returns true if no running tasks left.
+  bool RemoveTask(const server::MonitoredTaskPtr& task) EXCLUDES(mutex_);
+  // Abort all inflight tasks. New tasks can still be added.
+  void AbortTasks() EXCLUDES(mutex_);
+  // Abort all inflight tasks and prevent new tasks from being added.
+  void AbortTasksAndClose() EXCLUDES(mutex_);
+  // Wait for all inflight tasks to complete.
+  void WaitTasksCompletion() EXCLUDES(mutex_);
+
+ private:
+  void AbortTasksAndCloseIfRequested(bool close) EXCLUDES(mutex_);
+
+  scoped_refptr<TasksTracker> tasks_tracker_;
+
+  mutable std::shared_mutex mutex_;
+  std::unordered_set<server::MonitoredTaskPtr> pending_tasks_ GUARDED_BY(mutex_);
+
+  // If closing, requests to AddTask will be promptly aborted.
+  bool closing_ GUARDED_BY(mutex_) = false;
+};
+
 }  // namespace yb::master
diff --git a/src/yb/master/catalog_entity_info-test.cc b/src/yb/master/catalog_entity_info-test.cc
index 21a29a1888..48a56aed65 100644
--- a/src/yb/master/catalog_entity_info-test.cc
+++ b/src/yb/master/catalog_entity_info-test.cc
@@ -13,6 +13,7 @@
 #include <gtest/gtest.h>
 
 #include "yb/master/catalog_entity_info.h"
+#include "yb/util/test_thread_holder.h"
 #include "yb/util/test_util.h"
 
 namespace yb {
@@ -118,5 +119,137 @@ TEST_F(CatalogEntityInfoTest, TestTabletInfoCommit) {
   }
 }
 
+class MockMonitoredTask : public server::MonitoredTask {
+ public:
+  explicit MockMonitoredTask(server::MonitoredTaskType type) : type_(type) {}
+  virtual ~MockMonitoredTask() {}
+
+  // Abort this task and return its value before it was successfully aborted. If the task entered
+  // a different terminal state before we were able to abort it, return that state.
+  server::MonitoredTaskState AbortAndReturnPrevState(const Status& status) override {
+    auto prev_state = state_.load();
+    state_ = server::MonitoredTaskState::kAborted;
+    return prev_state;
+  }
+  server::MonitoredTaskType type() const override { return type_; }
+  std::string type_name() const override { return "dummy"; }
+  std::string description() const override { return "dummy"; }
+
+  server::MonitoredTaskState State() const { return state_.load(); }
+
+  const server::MonitoredTaskType type_;
+};
+
+TEST_F(CatalogEntityInfoTest, TestTasks) {
+  scoped_refptr<TasksTracker> tasks_tracker(new TasksTracker);
+  CatalogEntityWithTasks entity(tasks_tracker);
+
+  ASSERT_EQ(entity.NumTasks(), 0);
+
+  const auto type1 = server::MonitoredTaskType::kAddServer;
+  const auto type2 = server::MonitoredTaskType::kAddTableToTablet;
+
+  auto task1 = std::shared_ptr<server::MonitoredTask>(new MockMonitoredTask(type1));
+
+  entity.AddTask(task1);
+  ASSERT_TRUE(entity.HasTasks());
+  ASSERT_EQ(entity.NumTasks(), 1);
+  ASSERT_EQ(entity.HasTasks(type1), 1);
+  ASSERT_FALSE(entity.HasTasks(type2));
+  ASSERT_EQ(tasks_tracker->GetTasks().size(), 1);
+  ASSERT_TRUE(entity.GetTasks().contains(task1));
+
+  // Add more tasks.
+  auto task2 = std::shared_ptr<server::MonitoredTask>(new MockMonitoredTask(type2));
+  auto task3 = std::shared_ptr<server::MonitoredTask>(new MockMonitoredTask(type1));
+  entity.AddTask(task2);
+  entity.AddTask(task3);
+  ASSERT_TRUE(entity.HasTasks());
+  ASSERT_EQ(entity.NumTasks(), 3);
+  ASSERT_TRUE(entity.HasTasks(type1));
+  ASSERT_TRUE(entity.HasTasks(type2));
+  ASSERT_EQ(tasks_tracker->GetTasks().size(), 3);
+  ASSERT_TRUE(entity.GetTasks().contains(task1));
+  ASSERT_TRUE(entity.GetTasks().contains(task2));
+  ASSERT_TRUE(entity.GetTasks().contains(task3));
+
+  // Remove 1 task.
+  ASSERT_FALSE(entity.RemoveTask(task1));
+  // Remove is idempotent.
+  ASSERT_FALSE(entity.RemoveTask(task1));
+  ASSERT_TRUE(entity.HasTasks());
+  ASSERT_EQ(entity.NumTasks(), 2);
+  ASSERT_TRUE(entity.HasTasks(type1));
+  ASSERT_TRUE(entity.HasTasks(type2));
+  ASSERT_FALSE(entity.GetTasks().contains(task1));
+  ASSERT_TRUE(entity.GetTasks().contains(task2));
+  ASSERT_TRUE(entity.GetTasks().contains(task3));
+
+  // Abort all tasks but dont close.
+  entity.AbortTasks();
+  ASSERT_EQ(entity.NumTasks(), 2);
+  ASSERT_EQ(task2->state(), server::MonitoredTaskState::kAborted);
+  ASSERT_EQ(task3->state(), server::MonitoredTaskState::kAborted);
+  // Removed task should not get affected.
+  ASSERT_EQ(task1->state(), server::MonitoredTaskState::kWaiting);
+
+  const auto kDelay = MonoDelta::FromSeconds(2);
+  {
+    TestThreadHolder thread_holder;
+    thread_holder.AddThreadFunctor([&kDelay, &entity, &task2, &task3]() {
+      entity.RemoveTask(task2);
+      SleepFor(kDelay * 2);
+      entity.RemoveTask(task3);
+    });
+
+    auto start = MonoTime::Now();
+    // We should have waited for atleast kDelay before completion.
+    entity.WaitTasksCompletion();
+    auto elapsed = MonoTime::Now() - start;
+    ASSERT_GT(elapsed, kDelay);
+    ASSERT_EQ(entity.NumTasks(), 0);
+    ASSERT_FALSE(entity.HasTasks());
+
+    thread_holder.JoinAll();
+  }
+
+  // Enqueue more tasks.
+  auto task4 = std::shared_ptr<server::MonitoredTask>(new MockMonitoredTask(type1));
+  auto task5 = std::shared_ptr<server::MonitoredTask>(new MockMonitoredTask(type2));
+  entity.AddTask(task4);
+  entity.AddTask(task5);
+  ASSERT_EQ(entity.NumTasks(), 2);
+
+  // Abort all tasks and close.
+  entity.AbortTasksAndClose();
+  ASSERT_EQ(task4->state(), server::MonitoredTaskState::kAborted);
+  ASSERT_EQ(task5->state(), server::MonitoredTaskState::kAborted);
+
+  {
+    TestThreadHolder thread_holder;
+    thread_holder.AddThreadFunctor([&kDelay, &entity, &task4, &task5]() {
+      SleepFor(kDelay * 2);
+      entity.RemoveTask(task4);
+      entity.RemoveTask(task5);
+    });
+
+    auto start = MonoTime::Now();
+    // We should have waited for atleast kDelay before completion.
+    entity.WaitTasksCompletion();
+    auto elapsed = MonoTime::Now() - start;
+    ASSERT_GT(elapsed, kDelay);
+
+    thread_holder.JoinAll();
+  }
+
+  // We should no longer be able to add tasks.
+  auto task6 = std::shared_ptr<server::MonitoredTask>(new MockMonitoredTask(type1));
+  entity.AddTask(task6);
+  ASSERT_FALSE(entity.HasTasks());
+  ASSERT_EQ(task6->state(), server::MonitoredTaskState::kAborted);
+  entity.WaitTasksCompletion();
+  ASSERT_EQ(tasks_tracker->GetTasks().size(), 5);
+}
+
 } // namespace master
 } // namespace yb
diff --git a/src/yb/master/catalog_entity_info.cc b/src/yb/master/catalog_entity_info.cc
index 346ac97f47..c1f232f43d 100644
--- a/src/yb/master/catalog_entity_info.cc
+++ b/src/yb/master/catalog_entity_info.cc
@@ -408,13 +408,10 @@ void PersistentTabletInfo::set_state(SysTabletsEntryPB::State state, const strin
 // TableInfo
 // ================================================================================================
 
-TableInfo::TableInfo(TableId table_id,
-                     bool colocated,
-                     scoped_refptr<TasksTracker> tasks_tracker)
-    : table_id_(std::move(table_id)),
-      tasks_tracker_(tasks_tracker),
-      colocated_(colocated) {
-}
+TableInfo::TableInfo(TableId table_id, bool colocated, scoped_refptr<TasksTracker> tasks_tracker)
+    : CatalogEntityWithTasks(std::move(tasks_tracker)),
+      table_id_(std::move(table_id)),
+      colocated_(colocated) {}
 
 TableInfo::~TableInfo() {
 }
@@ -832,128 +829,9 @@ Status TableInfo::GetCreateTableErrorStatus() const {
 }
 
 std::size_t TableInfo::NumLBTasks() const {
-  SharedLock<decltype(lock_)> l(lock_);
-  return std::count_if(pending_tasks_.begin(),
-                       pending_tasks_.end(),
-                       [](auto task) { return task->started_by_lb(); });
-}
-
-std::size_t TableInfo::NumTasks() const {
-  SharedLock<decltype(lock_)> l(lock_);
-  return pending_tasks_.size();
-}
-
-bool TableInfo::HasTasks() const {
-  SharedLock<decltype(lock_)> l(lock_);
-  VLOG_WITH_PREFIX_AND_FUNC(3) << AsString(pending_tasks_);
-  return !pending_tasks_.empty();
-}
-
-bool TableInfo::HasTasks(server::MonitoredTaskType type) const {
-  SharedLock<decltype(lock_)> l(lock_);
-  for (auto task : pending_tasks_) {
-    if (task->type() == type) {
-      return true;
-    }
-  }
-  return false;
-}
-
-void TableInfo::AddTask(std::shared_ptr<server::MonitoredTask> task) {
-  bool abort_task = false;
-  {
-    std::lock_guard l(lock_);
-    if (!closing_) {
-      pending_tasks_.insert(task);
-      if (tasks_tracker_) {
-        tasks_tracker_->AddTask(task);
-      }
-    } else {
-      abort_task = true;
-    }
-  }
-  // We need to abort these tasks without holding the lock because when a task is destroyed it tries
-  // to acquire the same lock to remove itself from pending_tasks_.
-  if (abort_task) {
-    task->AbortAndReturnPrevState(STATUS(Expired, "Table closing"));
-  }
-}
-
-bool TableInfo::RemoveTask(const std::shared_ptr<server::MonitoredTask>& task) {
-  bool result;
-  {
-    std::lock_guard l(lock_);
-    pending_tasks_.erase(task);
-    result = pending_tasks_.empty();
-  }
-  VLOG(1) << "Removed task " << task.get() << " " << task->description();
-  return result;
-}
-
-// Aborts tasks which have their rpc in progress, rest of them are aborted and also erased
-// from the pending list.
-void TableInfo::AbortTasks() {
-  AbortTasksAndCloseIfRequested( /* close */ false);
-}
-
-void TableInfo::AbortTasksAndClose() {
-  AbortTasksAndCloseIfRequested( /* close */ true);
-}
-
-void TableInfo::AbortTasksAndCloseIfRequested(bool close) {
-  std::vector<std::shared_ptr<server::MonitoredTask>> abort_tasks;
-  {
-    std::lock_guard l(lock_);
-    if (close) {
-      closing_ = true;
-    }
-    abort_tasks.reserve(pending_tasks_.size());
-    abort_tasks.assign(pending_tasks_.cbegin(), pending_tasks_.cend());
-  }
-  if (abort_tasks.empty()) {
-    return;
-  }
-  auto status = close ? STATUS(Expired, "Table closing") : STATUS(Aborted, "Table closing");
-  // We need to abort these tasks without holding the lock because when a task is destroyed it tries
-  // to acquire the same lock to remove itself from pending_tasks_.
-  for (const auto& task : abort_tasks) {
-    VLOG_WITH_FUNC(1)
-        << (close ? "Close and abort" : "Abort") << " task " << task.get() << " "
-        << task->description();
-    task->AbortAndReturnPrevState(status);
-  }
-}
-
-void TableInfo::WaitTasksCompletion() {
-  const int kMaxWaitMs = 30000;
-  int wait_time_ms = 5;
-  while (1) {
-    std::vector<std::shared_ptr<server::MonitoredTask>> waiting_on_for_debug;
-    bool at_max_wait = wait_time_ms >= kMaxWaitMs;
-    {
-      SharedLock<decltype(lock_)> l(lock_);
-      if (pending_tasks_.empty()) {
-        break;
-      } else if (VLOG_IS_ON(1) || at_max_wait) {
-        waiting_on_for_debug.reserve(pending_tasks_.size());
-        waiting_on_for_debug.assign(pending_tasks_.cbegin(), pending_tasks_.cend());
-      }
-    }
-    for (const auto& task : waiting_on_for_debug) {
-      if (at_max_wait) {
-        LOG(WARNING) << "Long wait for aborting task " << task.get() << " " << task->description();
-      } else {
-        VLOG(1) << "Waiting for aborting task " << task.get() << " " << task->description();
-      }
-    }
-    base::SleepForMilliseconds(wait_time_ms);
-    wait_time_ms = std::min(wait_time_ms * 5 / 4, kMaxWaitMs);
-  }
-}
-
-std::unordered_set<std::shared_ptr<server::MonitoredTask>> TableInfo::GetTasks() const {
-  SharedLock<decltype(lock_)> l(lock_);
-  return pending_tasks_;
+  const auto tasks = GetTasks();
+  return std::count_if(
+      tasks.begin(), tasks.end(), [](const auto& task) { return task->started_by_lb(); });
 }
 
 std::size_t TableInfo::NumPartitions() const {
diff --git a/src/yb/master/catalog_entity_info.h b/src/yb/master/catalog_entity_info.h
index f21390797a..616dce4d5e 100644
--- a/src/yb/master/catalog_entity_info.h
+++ b/src/yb/master/catalog_entity_info.h
@@ -503,7 +503,8 @@ struct TabletWithSplitPartitions {
 // Currently indexed values:
 //     colocated
 class TableInfo : public RefCountedThreadSafe<TableInfo>,
-                  public MetadataCowWrapper<PersistentTableInfo> {
+                  public MetadataCowWrapper<PersistentTableInfo>,
+                  public CatalogEntityWithTasks {
  public:
   explicit TableInfo(
       TableId table_id, bool colocated, scoped_refptr<TasksTracker> tasks_tracker = nullptr);
@@ -708,20 +709,6 @@ class TableInfo : public RefCountedThreadSafe<TableInfo>,
   Status GetCreateTableErrorStatus() const;
 
   std::size_t NumLBTasks() const;
-  std::size_t NumTasks() const;
-  bool HasTasks() const;
-  bool HasTasks(server::MonitoredTaskType type) const;
-  void AddTask(std::shared_ptr<server::MonitoredTask> task);
-
-  // Returns true if no running tasks left.
-  bool RemoveTask(const std::shared_ptr<server::MonitoredTask>& task);
-
-  void AbortTasks();
-  void AbortTasksAndClose();
-  void WaitTasksCompletion();
-
-  // Allow for showing outstanding tasks in the master UI.
-  std::unordered_set<std::shared_ptr<server::MonitoredTask>> GetTasks() const;
 
   // Returns whether this is a type of table that will use tablespaces
   // for placement.
@@ -756,16 +743,12 @@ class TableInfo : public RefCountedThreadSafe<TableInfo>,
       const TableId& tablet_id,
       DeactivateOnly deactivate_only = DeactivateOnly::kFalse) REQUIRES(lock_);
 
-  void AbortTasksAndCloseIfRequested(bool close);
-
   std::string LogPrefix() const {
     return ToString() + ": ";
   }
 
   const TableId table_id_;
 
-  scoped_refptr<TasksTracker> tasks_tracker_;
-
   // Sorted index of tablet start partition-keys to TabletInfo.
   // The TabletInfo objects are owned by the CatalogManager.
   // At any point in time it contains only the active tablets (defined in the comment on tablets_).
@@ -777,12 +760,9 @@ class TableInfo : public RefCountedThreadSafe<TableInfo>,
   // 2) Tablets that are marked as HIDDEN for PITR.
   std::unordered_map<TabletId, TabletInfo*> tablets_ GUARDED_BY(lock_);
 
-  // Protects partitions_, tablets_ and pending_tasks_.
+  // Protects partitions_ and tablets_.
   mutable rw_spinlock lock_;
 
-  // If closing, requests to AddTask will be promptly aborted.
-  bool closing_ = false;
-
   // In memory state set during backfill to prevent multiple backfill jobs.
   bool is_backfilling_ = false;
 
@@ -790,9 +770,6 @@ class TableInfo : public RefCountedThreadSafe<TableInfo>,
 
   const bool colocated_;
 
-  // List of pending tasks (e.g. create/alter tablet requests).
-  std::unordered_set<std::shared_ptr<server::MonitoredTask>> pending_tasks_ GUARDED_BY(lock_);
-
   // The last error Status of the currently running CreateTable. Will be OK, if freshly constructed
   // object, or if the CreateTable was successful.
   Status create_table_error_;
diff --git a/src/yb/server/monitored_task.h b/src/yb/server/monitored_task.h
index 167ca70d7d..48286eb578 100644
--- a/src/yb/server/monitored_task.h
+++ b/src/yb/server/monitored_task.h
@@ -133,6 +133,8 @@ class MonitoredTask : public std::enable_shared_from_this<MonitoredTask> {
   std::atomic<server::MonitoredTaskState> state_{server::MonitoredTaskState::kWaiting};
 };
 
+using MonitoredTaskPtr = std::shared_ptr<MonitoredTask>;
+
 class RunnableMonitoredTask : public MonitoredTask {
  public:
   virtual Status Run() = 0;
