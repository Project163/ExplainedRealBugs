diff --git a/src/yb/integration-tests/CMakeLists.txt b/src/yb/integration-tests/CMakeLists.txt
index 059f84355a..eb8ac56864 100644
--- a/src/yb/integration-tests/CMakeLists.txt
+++ b/src/yb/integration-tests/CMakeLists.txt
@@ -91,15 +91,15 @@ set(INTEGRATION_TESTS_SRCS
   ts_itest-base.cc
   yb_mini_cluster_test_base.cc
   yb_table_test_base.cc
-  xcluster/xcluster_external_mini_cluster_base.cc
   xcluster/xcluster_test_base.cc
   cdcsdk_test_base.cc
   cdcsdk_ysql_test_base.cc
-  xcluster/xcluster_ysql_test_base.cc
-  xcluster/xcluster_ycql_test_base.cc
-  xcluster/xcluster_ddl_replication_test_base.cc
-  upgrade-tests/ysql_major_upgrade_test_base.cc
   upgrade-tests/upgrade_test_base.cc
+  upgrade-tests/ysql_major_upgrade_test_base.cc
+  xcluster/xcluster_ddl_replication_test_base.cc
+  xcluster/xcluster_test_utils.cc
+  xcluster/xcluster_ycql_test_base.cc
+  xcluster/xcluster_ysql_test_base.cc
 )
 
 ADD_YB_TEST_LIBRARY(integration-tests SRCS ${INTEGRATION_TESTS_SRCS})
@@ -276,8 +276,8 @@ ADD_YB_TEST(upgrade-tests/backup_upgrade-test)
 ADD_YB_TEST(upgrade-tests/basic_upgrade-test)
 ADD_YB_TEST(upgrade-tests/replication_info_upgrade-test)
 ADD_YB_TEST(upgrade-tests/pg_locks_v76_upgrade-test)
+ADD_YB_TEST(upgrade-tests/xcluster_upgrade-itest)
 ADD_YB_TEST(upgrade-tests/ycql_only_upgrade-test)
-
 ADD_YB_TEST(upgrade-tests/ysql_major_extension_upgrade-test)
 ADD_YB_TEST(upgrade-tests/ysql_major_upgrade_check-test)
 ADD_YB_TEST(upgrade-tests/ysql_major_upgrade_conn_mgr-test)
diff --git a/src/yb/integration-tests/external_mini_cluster-itest-base.cc b/src/yb/integration-tests/external_mini_cluster-itest-base.cc
index 07a8e08fab..eaf70975fb 100644
--- a/src/yb/integration-tests/external_mini_cluster-itest-base.cc
+++ b/src/yb/integration-tests/external_mini_cluster-itest-base.cc
@@ -46,26 +46,31 @@ Status ExternalMiniClusterITestBase::StartCluster(ExternalMiniClusterOptions opt
   return Status::OK();
 }
 
-void ExternalMiniClusterITestBase::TearDown() {
+void ExternalMiniClusterITestBase::TearDownCluster() {
   client_.reset();
-  if (cluster_) {
-    if (HasFatalFailure()) {
-      LOG(INFO) << "Found fatal failure";
-      for (size_t i = 0; i < cluster_->num_tablet_servers(); i++) {
-        if (!cluster_->tablet_server(i)->IsProcessAlive()) {
-          LOG(INFO) << "Tablet server " << i << " is not running. Cannot dump its stacks.";
-          continue;
-        }
-        LOG(INFO) << "Attempting to dump stacks of TS " << i << " with UUID "
-                  << cluster_->tablet_server(i)->uuid() << " and pid "
-                  << cluster_->tablet_server(i)->pid();
-        WARN_NOT_OK(
-            PstackWatcher::DumpPidStacks(cluster_->tablet_server(i)->pid()),
-            "Couldn't dump stacks");
+  if (!cluster_) {
+    return;
+  }
+  if (HasFatalFailure()) {
+    LOG(INFO) << "Found fatal failure";
+    for (size_t i = 0; i < cluster_->num_tablet_servers(); i++) {
+      if (!cluster_->tablet_server(i)->IsProcessAlive()) {
+        LOG(INFO) << "Tablet server " << i << " is not running. Cannot dump its stacks.";
+        continue;
       }
+      LOG(INFO) << "Attempting to dump stacks of TS " << i << " with UUID "
+                << cluster_->tablet_server(i)->uuid() << " and pid "
+                << cluster_->tablet_server(i)->pid();
+      WARN_NOT_OK(
+          PstackWatcher::DumpPidStacks(cluster_->tablet_server(i)->pid()), "Couldn't dump stacks");
     }
-    cluster_->Shutdown();
   }
+  cluster_->Shutdown();
+}
+
+void ExternalMiniClusterITestBase::TearDown() {
+  TearDownCluster();
+
   YBTest::TearDown();
   ts_map_.clear();
 }
diff --git a/src/yb/integration-tests/external_mini_cluster-itest-base.h b/src/yb/integration-tests/external_mini_cluster-itest-base.h
index 8d834f91af..86ea0858d9 100644
--- a/src/yb/integration-tests/external_mini_cluster-itest-base.h
+++ b/src/yb/integration-tests/external_mini_cluster-itest-base.h
@@ -72,6 +72,8 @@ class ExternalMiniClusterITestBase : public YBTest {
 
   Status StartCluster(ExternalMiniClusterOptions opts);
 
+  void TearDownCluster();
+
   std::unique_ptr<ExternalMiniCluster> cluster_;
   std::unique_ptr<itest::ExternalMiniClusterFsInspector> inspect_;
   std::unique_ptr<client::YBClient> client_;
diff --git a/src/yb/integration-tests/external_mini_cluster.cc b/src/yb/integration-tests/external_mini_cluster.cc
index 6e1480fa56..5842d54768 100644
--- a/src/yb/integration-tests/external_mini_cluster.cc
+++ b/src/yb/integration-tests/external_mini_cluster.cc
@@ -591,7 +591,7 @@ Result<ExternalMasterPtr> ExternalMiniCluster::StartMaster(
   }
 
   ExternalMasterPtr master = new ExternalMaster(
-      add_new_master_at_, messenger_, proxy_cache_.get(), exe,
+      add_new_master_at_, opts_.cluster_short_name, messenger_, proxy_cache_.get(), exe,
       GetDataPath(Format("master-$0", add_new_master_at_)),
       SubstituteInFlags(flags, add_new_master_at_), addr, http_port, peer_addrs);
 
@@ -1526,11 +1526,10 @@ Result<size_t> ExternalMiniCluster::LaunchTabletServer(
   }
 
   auto ts = make_scoped_refptr<ExternalTabletServer>(
-      idx, messenger_, proxy_cache_.get(), exe, GetDataPath(Format("ts-$0", idx + 1)),
-      num_drives, GetBindIpForTabletServer(idx), ts_rpc_port, ts_http_port, redis_rpc_port,
-      redis_http_port, cql_rpc_port, cql_http_port, pgsql_rpc_port,
-      ysql_conn_mgr_rpc_port, pgsql_http_port,
-      master_hostports, SubstituteInFlags(flags, idx));
+      idx, opts_.cluster_short_name, messenger_, proxy_cache_.get(), exe,
+      GetDataPath(Format("ts-$0", idx + 1)), num_drives, GetBindIpForTabletServer(idx), ts_rpc_port,
+      ts_http_port, redis_rpc_port, redis_http_port, cql_rpc_port, cql_http_port, pgsql_rpc_port,
+      ysql_conn_mgr_rpc_port, pgsql_http_port, master_hostports, SubstituteInFlags(flags, idx));
   RETURN_NOT_OK(ts->Launch(start_cql_proxy));
   tablet_servers_.push_back(ts);
 
@@ -2474,22 +2473,19 @@ ScopedResumeExternalDaemon::~ScopedResumeExternalDaemon() {
 // ExternalMaster
 //------------------------------------------------------------
 ExternalMaster::ExternalMaster(
-    size_t master_index,
-    rpc::Messenger* messenger,
-    rpc::ProxyCache* proxy_cache,
-    const string& exe,
-    const string& data_dir,
-    const std::vector<string>& extra_flags,
-    const string& rpc_bind_address,
-    uint16_t http_port,
+    size_t master_index, const std::string& cluster_short_name, rpc::Messenger* messenger,
+    rpc::ProxyCache* proxy_cache, const string& exe, const string& data_dir,
+    const std::vector<string>& extra_flags, const string& rpc_bind_address, uint16_t http_port,
     const string& master_addrs)
-    : ExternalDaemon(Format("m-$0", master_index + 1), messenger,
-                     proxy_cache, exe, data_dir,
-                     {GetServerTypeDataPath(data_dir, "master")}, extra_flags),
+    : ExternalDaemon(
+          Format(
+              "$0m-$1", cluster_short_name.empty() ? "" : cluster_short_name + "-",
+              master_index + 1),
+          messenger, proxy_cache, exe, data_dir, {GetServerTypeDataPath(data_dir, "master")},
+          extra_flags),
       rpc_bind_address_(rpc_bind_address),
       master_addrs_(master_addrs),
-      http_port_(http_port) {
-}
+      http_port_(http_port) {}
 
 ExternalMaster::~ExternalMaster() {
 }
@@ -2553,15 +2549,19 @@ Status ExternalMaster::Restart() {
 //------------------------------------------------------------
 
 ExternalTabletServer::ExternalTabletServer(
-    size_t tablet_server_index, rpc::Messenger* messenger, rpc::ProxyCache* proxy_cache,
-    const std::string& exe, const std::string& data_dir, uint16_t num_drives,
-    std::string bind_host, uint16_t rpc_port, uint16_t http_port, uint16_t redis_rpc_port,
-    uint16_t redis_http_port, uint16_t cql_rpc_port, uint16_t cql_http_port,
-    uint16_t pgsql_rpc_port, uint16_t ysql_conn_mgr_rpc_port, uint16_t pgsql_http_port,
-    const std::vector<HostPort>& master_addrs, const std::vector<std::string>& extra_flags)
-    : ExternalDaemon(Format("ts-$0", tablet_server_index + 1),
-                     messenger, proxy_cache, exe, data_dir,
-                     FsDataDirs(data_dir, "tserver", num_drives), extra_flags),
+    size_t tablet_server_index, const std::string& cluster_short_name, rpc::Messenger* messenger,
+    rpc::ProxyCache* proxy_cache, const std::string& exe, const std::string& data_dir,
+    uint16_t num_drives, std::string bind_host, uint16_t rpc_port, uint16_t http_port,
+    uint16_t redis_rpc_port, uint16_t redis_http_port, uint16_t cql_rpc_port,
+    uint16_t cql_http_port, uint16_t pgsql_rpc_port, uint16_t ysql_conn_mgr_rpc_port,
+    uint16_t pgsql_http_port, const std::vector<HostPort>& master_addrs,
+    const std::vector<std::string>& extra_flags)
+    : ExternalDaemon(
+          Format(
+              "$0ts-$1", cluster_short_name.empty() ? "" : cluster_short_name + "-",
+              tablet_server_index + 1),
+          messenger, proxy_cache, exe, data_dir, FsDataDirs(data_dir, "tserver", num_drives),
+          extra_flags),
       master_addrs_(HostPort::ToCommaSeparatedString(master_addrs)),
       bind_host_(std::move(bind_host)),
       rpc_port_(rpc_port),
diff --git a/src/yb/integration-tests/external_mini_cluster.h b/src/yb/integration-tests/external_mini_cluster.h
index a6e395891e..b4b158695b 100644
--- a/src/yb/integration-tests/external_mini_cluster.h
+++ b/src/yb/integration-tests/external_mini_cluster.h
@@ -210,6 +210,9 @@ struct ExternalMiniClusterOptions {
   // Cluster id used to create fs path when we create tests with multiple clusters.
   std::string cluster_id;
 
+  // Used to emit cluster identifier in the logs.
+  std::string cluster_short_name;
+
   // By default, we create max(2, num_tablet_servers) tablets per transaction table. If this is
   // set to a non-zero value, this value is used instead.
   int transaction_table_num_tablets = 0;
@@ -744,6 +747,7 @@ class ExternalMaster : public ExternalDaemon {
  public:
   ExternalMaster(
     size_t master_index,
+    const std::string& cluster_short_name,
     rpc::Messenger* messenger,
     rpc::ProxyCache* proxy_cache,
     const std::string& exe,
@@ -775,12 +779,12 @@ class ExternalMaster : public ExternalDaemon {
 class ExternalTabletServer : public ExternalDaemon {
  public:
   ExternalTabletServer(
-      size_t tablet_server_index, rpc::Messenger* messenger, rpc::ProxyCache* proxy_cache,
-      const std::string& exe, const std::string& data_dir, uint16_t num_drives,
-      std::string bind_host, uint16_t rpc_port, uint16_t http_port, uint16_t redis_rpc_port,
-      uint16_t redis_http_port, uint16_t cql_rpc_port, uint16_t cql_http_port,
-      uint16_t pgsql_rpc_port, uint16_t ysql_conn_mgr_rpc_port, uint16_t pgsql_http_port,
-      const std::vector<HostPort>& master_addrs,
+      size_t tablet_server_index, const std::string& cluster_short_name, rpc::Messenger* messenger,
+      rpc::ProxyCache* proxy_cache, const std::string& exe, const std::string& data_dir,
+      uint16_t num_drives, std::string bind_host, uint16_t rpc_port, uint16_t http_port,
+      uint16_t redis_rpc_port, uint16_t redis_http_port, uint16_t cql_rpc_port,
+      uint16_t cql_http_port, uint16_t pgsql_rpc_port, uint16_t ysql_conn_mgr_rpc_port,
+      uint16_t pgsql_http_port, const std::vector<HostPort>& master_addrs,
       const std::vector<std::string>& extra_flags);
 
   Status Start(
diff --git a/src/yb/integration-tests/upgrade-tests/xcluster_upgrade-itest.cc b/src/yb/integration-tests/upgrade-tests/xcluster_upgrade-itest.cc
new file mode 100644
index 0000000000..ad3a045faf
--- /dev/null
+++ b/src/yb/integration-tests/upgrade-tests/xcluster_upgrade-itest.cc
@@ -0,0 +1,320 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/client/xcluster_client.h"
+
+#include "yb/integration-tests/upgrade-tests/upgrade_test_base.h"
+#include "yb/integration-tests/xcluster/xcluster_test_utils.h"
+
+#include "yb/master/master_ddl.pb.h"
+
+#include "yb/master/master_replication.pb.h"
+
+#include "yb/server/clock.h"
+
+#include "yb/util/backoff_waiter.h"
+
+#include "yb/yql/pgwrapper/libpq_utils.h"
+
+DECLARE_int32(heartbeat_interval_ms);
+
+namespace yb {
+
+static constexpr auto kNamespaceName = "yugabyte";
+const auto kRpcTimeout = MonoDelta::FromSeconds(RegularBuildVsSanitizers(60, 120));
+static constexpr auto kTable = "tbl1";
+static constexpr auto kKeyCol = "key";
+static constexpr auto kCol2 = "c2";
+static constexpr auto kCol2MaxValue = 3;
+static const xcluster::ReplicationGroupId kReplicationGroupId("rg1");
+const auto kCountBaseRowsStmt = Format("SELECT COUNT(1) FROM $0", kTable);
+const auto kCountIdxRowsStmt = Format("SELECT COUNT(1) FROM $0 WHERE $1 IN (0,1,2)", kTable, kCol2);
+
+YB_STRONGLY_TYPED_BOOL(RangePartitioned);
+
+class XClusterUpgradeTest : public UpgradeTestBase {
+ public:
+  XClusterUpgradeTest() : UpgradeTestBase(kBuild_2_25_0_0) {}
+
+  void TearDown() override {
+    SwitchToConsumerCluster();
+    TearDownCluster();
+
+    SwitchToProducerCluster();
+    UpgradeTestBase::TearDown();
+  }
+
+  Status StartClustersInOldVersion(RangePartitioned ranged_partitioned = RangePartitioned::kFalse) {
+    ExternalMiniClusterOptions opts;
+    opts.num_masters = 3;
+    opts.num_tablet_servers = 3;
+
+    opts.cluster_id = "producer_cluster";
+    opts.cluster_short_name = "P";
+    RETURN_NOT_OK(StartClusterInOldVersion(opts));
+    producer_cluster_ = cluster_.get();
+    producer_client_ = client_.get();
+
+    SwitchToConsumerCluster();
+    opts.cluster_id = "consumer_cluster";
+    opts.cluster_short_name = "C";
+    RETURN_NOT_OK(StartClusterInOldVersion(opts));
+    consumer_cluster_ = cluster_.get();
+    consumer_client_ = client_.get();
+    SwitchToProducerCluster();
+
+    RETURN_NOT_OK(CreateTablesAndSetupXCluster(ranged_partitioned));
+    return Status::OK();
+  }
+
+  Status RunOnBothClusters(const std::function<Status(ExternalMiniCluster*)>& run_on_cluster) {
+    return XClusterTestUtils::RunOnBothClusters(
+        &producer_cluster(), &consumer_cluster(), run_on_cluster);
+  }
+
+  Status WaitForSafeTimeToAdvanceToNow() {
+    HybridTime now;
+    {
+      server::ClockPtr clock(new server::HybridClock());
+      RETURN_NOT_OK(clock->Init());
+      // Wait for at least 2x heartbeat interval to ensure that the safe time is propagated to all
+      // tservers.
+      now = clock->Now().AddDelta(2ms * FLAGS_heartbeat_interval_ms);
+    }
+
+    master::GetNamespaceInfoResponsePB resp;
+    RETURN_NOT_OK(consumer_client().GetNamespaceInfo(
+        std::string() /* namespace_id */, kNamespaceName, YQL_DATABASE_PGSQL, &resp));
+    if (resp.has_error()) {
+      return StatusFromPB(resp.error().status());
+    }
+    auto namespace_id = resp.namespace_().id();
+
+    return LoggedWaitFor(
+        [&]() -> Result<bool> {
+          auto safe_time = VERIFY_RESULT(consumer_client().GetXClusterSafeTimeForNamespace(
+              namespace_id, master::XClusterSafeTimeFilter::NONE));
+          if (safe_time.is_special()) {
+            return false;  // Safe time has not advanced yet.
+          }
+          LOG(INFO) << "Current xCluster safe time: " << safe_time.ToDebugString()
+                    << " vs now: " << now.ToDebugString();
+          return safe_time >= now;
+        },
+        kRpcTimeout, "Wait for xCluster safe time to advance to now + 2x heartbeat interval");
+  }
+
+  Status CreateTablesAndSetupXCluster(
+      RangePartitioned ranged_partitioned = RangePartitioned::kFalse) {
+    auto create_table = [&](ExternalMiniCluster* cluster) -> Status {
+      const auto query = Format(
+          "CREATE TABLE $0($1 int, $2 int, PRIMARY KEY ($1 $3)) ", kTable, kKeyCol, kCol2,
+          ranged_partitioned ? "ASC" : "HASH");
+      auto conn = VERIFY_RESULT(cluster->ConnectToDB(kNamespaceName));
+      RETURN_NOT_OK(conn.Execute(query));
+
+      return conn.ExecuteFormat(
+          "CREATE INDEX ON $0 ($1 $2) $3", kTable, kCol2, ranged_partitioned ? "ASC" : "HASH",
+          ranged_partitioned ? "SPLIT AT ((1),(2))" : "SPLIT INTO 3 TABLETS");
+    };
+
+    RETURN_NOT_OK(RunOnBothClusters(create_table));
+
+    RETURN_NOT_OK(XClusterTestUtils::CheckpointReplicationGroup(
+        producer_client(), kReplicationGroupId, kNamespaceName, kRpcTimeout));
+
+    RETURN_NOT_OK(XClusterTestUtils::CreateReplicationFromCheckpoint(
+        producer_client(), kReplicationGroupId, consumer_cluster().GetMasterAddresses(),
+        kRpcTimeout));
+
+    // Wait for the xcluster safe time to propagate to the tserver nodes.
+    return WaitForSafeTimeToAdvanceToNow();
+  }
+
+  Status InsertRows(pgwrapper::PGConn& conn, int64_t start, int64_t end) {
+    if (start == end) {
+      return conn.ExecuteFormat(
+          "INSERT INTO $0 VALUES ($1, $2)", kTable, start, start % kCol2MaxValue);
+    }
+    RETURN_NOT_OK(conn.ExecuteFormat("BEGIN"));
+    for (int64_t i = start; i < end; ++i) {
+      auto status =
+          conn.ExecuteFormat("INSERT INTO $0 VALUES ($1, $2)", kTable, i, i % kCol2MaxValue);
+    }
+    RETURN_NOT_OK(conn.Execute("COMMIT"));
+    return Status::OK();
+  }
+
+  void InsertRowsInProducer(std::atomic<bool>& stop_flag, std::atomic<int64_t>& rows_inserted) {
+    while (!stop_flag) {
+      auto conn_result = producer_cluster().ConnectToDB(kNamespaceName);
+      if (!conn_result) {
+        LOG(WARNING) << "Failed to connect to producer cluster: " << conn_result.status();
+        SleepFor(250ms);
+        continue;
+      }
+      while (!stop_flag) {
+        auto status = InsertRows(*conn_result, rows_inserted, rows_inserted);
+        if (!status.ok()) {
+          LOG(WARNING) << "Failed to insert single row: " << status;
+          break;
+        }
+        rows_inserted++;
+        status = InsertRows(*conn_result, rows_inserted, rows_inserted + 10);
+        if (!status.ok()) {
+          LOG(WARNING) << "Failed to insert batch of rows: " << status;
+          break;
+        }
+        rows_inserted += 10;
+        SleepFor(100ms);
+      }
+    }
+
+    LOG(INFO) << "Inserted " << rows_inserted << " rows in producer";
+  }
+
+  Status ValidateConsumerRows(pgwrapper::PGConn& conn, int16_t& min_expected_rows) {
+    RETURN_NOT_OK(conn.Execute("BEGIN"));
+    RETURN_NOT_OK(conn.Execute("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ"));
+    auto base_rows = VERIFY_RESULT(conn.FetchRow<int64_t>(kCountBaseRowsStmt));
+    CHECK_GE(base_rows, min_expected_rows) << "Row count on consumer cluster went backwards";
+    auto idx_rows = VERIFY_RESULT(conn.FetchRow<int64_t>(kCountIdxRowsStmt));
+    CHECK_EQ(base_rows, idx_rows) << "Row count mismatch on consumer cluster";
+
+    RETURN_NOT_OK(conn.Execute("COMMIT"));
+
+    min_expected_rows = base_rows;
+    return Status::OK();
+  }
+
+  void ValidateConsumerConsistency(std::atomic<bool>& stop_flag) {
+    int16_t min_expected_rows = 0;
+    while (!stop_flag) {
+      auto conn_result = consumer_cluster().ConnectToDB(kNamespaceName);
+      if (!conn_result) {
+        LOG(WARNING) << "Failed to connect to consumer cluster: " << conn_result.status();
+        SleepFor(250ms);
+        continue;
+      }
+      while (!stop_flag) {
+        auto status = ValidateConsumerRows(*conn_result, min_expected_rows);
+        if (!status.ok()) {
+          LOG(WARNING) << "Failed to read from consumer: " << status;
+          break;
+        }
+        SleepFor(100ms);
+      }
+    }
+  }
+
+  Status ValidateRows() {
+    auto p_conn = VERIFY_RESULT(producer_cluster().ConnectToDB(kNamespaceName));
+    auto c_conn = VERIFY_RESULT(consumer_cluster().ConnectToDB(kNamespaceName));
+    auto p_rows = VERIFY_RESULT(p_conn.FetchRow<int64_t>(kCountBaseRowsStmt));
+    auto c_rows = VERIFY_RESULT(c_conn.FetchRow<int64_t>(kCountBaseRowsStmt));
+    LOG(INFO) << "" << p_rows << " rows in producer and " << c_rows << " rows in consumer";
+
+    SCHECK_EQ(p_rows, c_rows, IllegalState, "Row count mismatch");
+
+    auto validate_idx = [&](pgwrapper::PGConn& conn) -> Status {
+      auto has_index_scan = VERIFY_RESULT(conn.HasIndexScan(kCountIdxRowsStmt));
+      SCHECK(
+          has_index_scan, IllegalState, "Query does not generate index scan: $0",
+          kCountIdxRowsStmt);
+      auto idx_rows = VERIFY_RESULT(conn.FetchRow<int64_t>(kCountIdxRowsStmt));
+      SCHECK_EQ(
+          idx_rows, p_rows, IllegalState,
+          Format("Invalid number of rows in index scan: $0", kCountIdxRowsStmt));
+      return Status::OK();
+    };
+
+    RETURN_NOT_OK_PREPEND(validate_idx(p_conn), "Failed to validate index on producer");
+    RETURN_NOT_OK_PREPEND(validate_idx(c_conn), "Failed to validate index on consumer");
+
+    return Status::OK();
+  }
+
+  void SimpleReplicationTest(RangePartitioned ranged_partitioned) {
+    ASSERT_OK(StartClustersInOldVersion());
+
+    TestThreadHolder thread_holder;
+    std::atomic<int64_t> rows_inserted = 0;
+    thread_holder.AddThread(
+        [&]() { InsertRowsInProducer(thread_holder.stop_flag(), rows_inserted); });
+    thread_holder.AddThread([&]() { ValidateConsumerConsistency(thread_holder.stop_flag()); });
+
+    SleepFor(3s);
+    ASSERT_GT(rows_inserted.load(), 5);
+
+    // Upgrade the consumer cluster first.
+    SwitchToConsumerCluster();
+    const auto delay_between_nodes = 5s;
+    ASSERT_OK(UpgradeClusterToCurrentVersion(delay_between_nodes));
+
+    // Upgrade the producer cluster.
+    SwitchToProducerCluster();
+    ASSERT_OK(UpgradeClusterToCurrentVersion(delay_between_nodes));
+
+    thread_holder.Stop();
+
+    ASSERT_GT(rows_inserted.load(), 10);
+
+    ASSERT_OK(WaitForSafeTimeToAdvanceToNow());
+
+    ASSERT_OK(ValidateRows());
+  }
+
+ private:
+  void SwapOtherCluster() {
+    other_cluster_.swap(cluster_);
+    other_client_.swap(client_);
+  }
+
+  void SwitchToProducerCluster() {
+    if (!is_using_producer_cluster_) {
+      SwapOtherCluster();
+      is_using_producer_cluster_ = true;
+    }
+  }
+
+  void SwitchToConsumerCluster() {
+    if (is_using_producer_cluster_) {
+      SwapOtherCluster();
+      is_using_producer_cluster_ = false;
+    }
+  }
+
+  ExternalMiniCluster& producer_cluster() { return *producer_cluster_; }
+  ExternalMiniCluster& consumer_cluster() { return *consumer_cluster_; }
+  client::YBClient& producer_client() { return *producer_client_; }
+  client::YBClient& consumer_client() { return *consumer_client_; }
+
+ private:
+  std::unique_ptr<ExternalMiniCluster> other_cluster_;
+  std::unique_ptr<client::YBClient> other_client_;
+  bool is_using_producer_cluster_ = true;
+  ExternalMiniCluster *producer_cluster_, *consumer_cluster_;
+  client::YBClient *producer_client_, *consumer_client_;
+};
+
+TEST_F(XClusterUpgradeTest, UpgradeHashPartitionedTable) {
+  ASSERT_NO_FATAL_FAILURE(SimpleReplicationTest(RangePartitioned::kFalse));
+}
+
+// #27380 added support for range partitioned tables in xCluster replication.
+// Enable this test once the from build with the fix is available.
+TEST_F(XClusterUpgradeTest, YB_DISABLE_TEST(UpgradeRangePartitionedTable)) {
+  ASSERT_NO_FATAL_FAILURE(SimpleReplicationTest(RangePartitioned::kTrue));
+}
+
+}  // namespace yb
diff --git a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
index 9d5f8cbb55..06463db597 100644
--- a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
@@ -17,6 +17,7 @@
 #include "yb/client/xcluster_client.h"
 #include "yb/client/yb_table_name.h"
 #include "yb/common/xcluster_util.h"
+#include "yb/integration-tests/xcluster/xcluster_test_utils.h"
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/mini_master.h"
@@ -519,8 +520,10 @@ class XClusterDBScopedTestWithTwoDBs : public XClusterDBScopedTest {
 
     source_namespace2_table_ = producer_tables_.back();
     target_namespace2_table_ = consumer_tables_.back();
-    source_namespace2_id_ = VERIFY_RESULT(GetNamespaceId(producer_client(), namespace_name2_));
-    target_namespace2_id_ = VERIFY_RESULT(GetNamespaceId(consumer_client(), namespace_name2_));
+    source_namespace2_id_ =
+        VERIFY_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), namespace_name2_));
+    target_namespace2_id_ =
+        VERIFY_RESULT(XClusterTestUtils::GetNamespaceId(*consumer_client(), namespace_name2_));
 
     return Status::OK();
   }
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
index dae4f8c11d..eaf51ad3c0 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
@@ -23,6 +23,7 @@
 
 #include "yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h"
 #include "yb/integration-tests/xcluster/xcluster_test_base.h"
+#include "yb/integration-tests/xcluster/xcluster_test_utils.h"
 
 #include "yb/master/catalog_manager.h"
 #include "yb/master/mini_master.h"
@@ -164,7 +165,8 @@ TEST_F(XClusterDDLReplicationTest, ExtensionRoleUpdating) {
   auto& catalog_manager =
       ASSERT_RESULT(producer_cluster_.mini_cluster_->GetLeaderMiniMaster())->catalog_manager_impl();
   auto* xcluster_manager = catalog_manager.GetXClusterManagerImpl();
-  const auto namespace_id = ASSERT_RESULT(GetNamespaceId(producer_client(), namespace_name));
+  const auto namespace_id =
+      ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), namespace_name));
   auto* tserver = producer_cluster_.mini_cluster_->mini_tablet_server(0);
   auto& xcluster_context = tserver->server()->GetXClusterContext();
   auto conn = ASSERT_RESULT(producer_cluster_.ConnectToDB(namespace_name));
@@ -313,7 +315,8 @@ TEST_F(XClusterDDLReplicationTest, BootstrappingEmptyTable) {
       /*idx=*/1, /*num_tablets=*/3, &producer_cluster_));
 
   ASSERT_OK(CheckpointReplicationGroupOnNamespaces({namespace_name}));
-  auto namespace_id = ASSERT_RESULT(GetNamespaceId(producer_client(), namespace_name));
+  auto namespace_id =
+      ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), namespace_name));
   auto bootstrap_required =
       ASSERT_RESULT(IsXClusterBootstrapRequired(kReplicationGroupId, namespace_id));
   EXPECT_EQ(bootstrap_required, true);
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
index 35e051d8bb..670477d23f 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
@@ -19,8 +19,11 @@
 #include "yb/client/table.h"
 #include "yb/client/xcluster_client.h"
 #include "yb/client/yb_table_name.h"
+
 #include "yb/integration-tests/xcluster/xcluster_test_base.h"
+#include "yb/integration-tests/xcluster/xcluster_test_utils.h"
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
+
 #include "yb/master/mini_master.h"
 #include "yb/tserver/mini_tablet_server.h"
 #include "yb/tserver/xcluster_ddl_queue_handler.h"
@@ -67,7 +70,8 @@ Status XClusterDDLReplicationTestBase::CheckpointReplicationGroupOnNamespaces(
     const std::vector<NamespaceName>& namespace_names) {
   std::vector<NamespaceId> namespace_ids;
   for (const auto& namespace_name : namespace_names) {
-    namespace_ids.push_back(VERIFY_RESULT(GetNamespaceId(producer_client(), namespace_name)));
+    namespace_ids.push_back(
+        VERIFY_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), namespace_name)));
   }
   RETURN_NOT_OK(
       client::XClusterClient(*producer_client())
diff --git a/src/yb/integration-tests/xcluster/xcluster_external_mini_cluster_base.cc b/src/yb/integration-tests/xcluster/xcluster_external_mini_cluster_base.cc
deleted file mode 100644
index 3b0a186979..0000000000
--- a/src/yb/integration-tests/xcluster/xcluster_external_mini_cluster_base.cc
+++ /dev/null
@@ -1,262 +0,0 @@
-// Copyright (c) YugabyteDB, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
-// in compliance with the License.  You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software distributed under the License
-// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
-// or implied.  See the License for the specific language governing permissions and limitations
-// under the License.
-//
-
-#include "yb/integration-tests/xcluster/xcluster_external_mini_cluster_base.h"
-
-#include "yb/client/schema.h"
-#include "yb/common/hybrid_time.h"
-#include "yb/client/client.h"
-#include "yb/util/backoff_waiter.h"
-
-#include "yb/master/master_cluster.proxy.h"
-
-namespace yb {
-
-static constexpr auto kValueColumnName = "value";
-
-static constexpr auto kNamespaceName = "yugabyte";
-static constexpr auto kTableName = "my_table";
-static const client::YBTableName kYBTableName(YQL_DATABASE_CQL, kNamespaceName, kTableName);
-
-void XClusterExternalMiniClusterBase::SetUp() {
-  HybridTime::TEST_SetPrettyToString(true);
-
-  YBTest::SetUp();
-}
-
-Status XClusterExternalMiniClusterBase::SetupClusters() {
-  AddCommonOptions();
-
-  auto source_master_flags = setup_opts_.master_flags;
-  std::move(
-      source_cluster_.setup_opts_.master_flags.begin(),
-      source_cluster_.setup_opts_.master_flags.end(), std::back_inserter(source_master_flags));
-  auto source_tserver_flags = setup_opts_.tserver_flags;
-  std::move(
-      source_cluster_.setup_opts_.tserver_flags.begin(),
-      source_cluster_.setup_opts_.tserver_flags.end(), std::back_inserter(source_tserver_flags));
-
-  source_cluster_ = VERIFY_RESULT(CreateCluster(
-      "source", "S", setup_opts_.num_masters, setup_opts_.num_tservers, source_master_flags,
-      source_tserver_flags));
-
-  auto target_master_flags = setup_opts_.master_flags;
-  std::move(
-      target_cluster_.setup_opts_.master_flags.begin(),
-      target_cluster_.setup_opts_.master_flags.end(), std::back_inserter(target_master_flags));
-  auto target_tserver_flags = setup_opts_.tserver_flags;
-  std::move(
-      target_cluster_.setup_opts_.tserver_flags.begin(),
-      target_cluster_.setup_opts_.tserver_flags.end(), std::back_inserter(target_tserver_flags));
-
-  target_cluster_ = VERIFY_RESULT(CreateCluster(
-      "target", "T", setup_opts_.num_masters, setup_opts_.num_tservers, target_master_flags,
-      target_tserver_flags));
-
-  RETURN_NOT_OK(RunOnBothClusters([&](Cluster* cluster) -> Status {
-    RETURN_NOT_OK(CreateTable(setup_opts_.num_tservers, cluster->client_.get(), kYBTableName));
-    std::shared_ptr<client::YBTable> table;
-    RETURN_NOT_OK(cluster->client_->OpenTable(kYBTableName, &table));
-    cluster->tables_.push_back(std::move(table));
-    return Status::OK();
-  }));
-
-  return Status::OK();
-}
-
-Status XClusterExternalMiniClusterBase::SetupClustersAndReplicationGroup() {
-  RETURN_NOT_OK(SetupClusters());
-  return SetupReplication();
-}
-
-void XClusterExternalMiniClusterBase::AddCommonOptions() {
-  // Because this test performs a lot of alter tables, we end up flushing
-  // and rewriting metadata files quite a bit. Globally disabling fsync
-  // speeds the test runtime up dramatically.
-  setup_opts_.tserver_flags.push_back("--never_fsync");
-}
-
-Result<XClusterExternalMiniClusterBase::Cluster> XClusterExternalMiniClusterBase::CreateCluster(
-    const std::string& cluster_id, const std::string& cluster_short_name, uint32_t num_masters,
-    uint32_t num_tservers, const std::vector<std::string>& master_flags,
-    const std::vector<std::string>& tserver_flags) {
-  ExternalMiniClusterOptions setup_opts_;
-  setup_opts_.num_tablet_servers = num_tservers;
-  setup_opts_.num_masters = num_masters;
-  setup_opts_.cluster_id = cluster_id;
-
-  for (const auto& flag : master_flags) {
-    setup_opts_.extra_master_flags.push_back(flag);
-  }
-  setup_opts_.extra_master_flags.emplace_back(Format("--replication_factor=$0", num_tservers));
-
-  for (const auto& flag : tserver_flags) {
-    setup_opts_.extra_tserver_flags.push_back(flag);
-  }
-
-  XClusterExternalMiniClusterBase::Cluster cluster;
-  cluster.cluster_.reset(new ExternalMiniCluster(setup_opts_));
-  RETURN_NOT_OK(cluster.cluster_->Start());
-
-  cluster.client_ = VERIFY_RESULT(cluster.cluster_->CreateClient());
-  cluster.master_proxy_ = std::make_unique<master::MasterReplicationProxy>(
-      cluster.cluster_->GetLeaderMasterProxy<master::MasterReplicationProxy>());
-
-  return cluster;
-}
-
-Status XClusterExternalMiniClusterBase::RunOnBothClusters(
-    std::function<Status(Cluster*)> run_on_cluster) {
-  auto source_future =
-      std::async(std::launch::async, [&] { return run_on_cluster(&source_cluster_); });
-  auto target_future =
-      std::async(std::launch::async, [&] { return run_on_cluster(&target_cluster_); });
-
-  auto source_status = source_future.get();
-  auto target_status = target_future.get();
-
-  RETURN_NOT_OK(source_status);
-  return target_status;
-}
-
-Result<client::TableHandle> XClusterExternalMiniClusterBase::CreateTable(
-    int num_tablets, client::YBClient* client, const client::YBTableName& table_name) {
-  client::TableHandle table;
-  RETURN_NOT_OK(
-      client->CreateNamespaceIfNotExists(table_name.namespace_name(), table_name.namespace_type()));
-
-  client::YBSchemaBuilder builder;
-  builder.AddColumn(kKeyColumnName)->Type(DataType::INT32)->HashPrimaryKey()->NotNull();
-  builder.AddColumn(kValueColumnName)->Type(DataType::INT32);
-  TableProperties table_properties;
-  table_properties.SetTransactional(true);
-  builder.SetTableProperties(table_properties);
-
-  RETURN_NOT_OK(table.Create(table_name, num_tablets, client, &builder));
-
-  return table;
-}
-
-Status XClusterExternalMiniClusterBase::SetupReplication(
-    xcluster::ReplicationGroupId replication_group_id,
-    std::vector<std::shared_ptr<client::YBTable>> source_tables) {
-  std::string table_ids;
-  if (source_tables.empty()) {
-    source_tables = SourceTables();
-  }
-  for (const auto& table : source_tables) {
-    if (!table_ids.empty()) {
-      table_ids += ",";
-    }
-    table_ids += table->id();
-  }
-
-  auto result = VERIFY_RESULT(RunYbAdmin(
-      &target_cluster_, "setup_universe_replication", replication_group_id.ToString(),
-      SourceCluster()->GetMasterAddresses(), table_ids));
-
-  SCHECK_NE(
-      result.find("Replication setup successfully"), std::string::npos, IllegalState,
-      Format("Failed to setup replication: $0", result));
-
-  return Status::OK();
-}
-
-Result<xrepl::StreamId> XClusterExternalMiniClusterBase::GetStreamId(client::YBTable* table) {
-  master::ListCDCStreamsRequestPB req;
-  master::ListCDCStreamsResponsePB resp;
-  req.set_id_type(yb::master::IdTypePB::TABLE_ID);
-  if (!table) {
-    table = SourceTable();
-  }
-  req.set_table_id(table->id());
-
-  rpc::RpcController rpc;
-  rpc.set_timeout(MonoDelta::FromSeconds(kRpcTimeout));
-  RETURN_NOT_OK(source_cluster_.master_proxy_->ListCDCStreams(req, &resp, &rpc));
-
-  if (resp.has_error()) {
-    return StatusFromPB(resp.error().status());
-  }
-
-  SCHECK_EQ(resp.streams_size(), 1, IllegalState, "Expected only one stream");
-
-  return xrepl::StreamId::FromString(resp.streams(0).stream_id());
-}
-
-Status XClusterExternalMiniClusterBase::VerifyReplicationError(
-    const client::YBTable* consumer_table, const xrepl::StreamId& stream_id,
-    const std::optional<ReplicationErrorPb> expected_replication_error) {
-  const auto consumer_table_id = consumer_table->id();
-  master::GetReplicationStatusRequestPB req;
-  master::GetReplicationStatusResponsePB resp;
-
-  req.set_replication_group_id(kReplicationGroupId.ToString());
-
-  rpc::RpcController rpc;
-  std::optional<ReplicationErrorPb> last_error = std::nullopt;
-  RETURN_NOT_OK_PREPEND(
-      LoggedWaitFor(
-          [&]() -> Result<bool> {
-            rpc.Reset();
-            rpc.set_timeout(MonoDelta::FromSeconds(kRpcTimeout));
-            if (!target_cluster_.master_proxy_->GetReplicationStatus(req, &resp, &rpc).ok()) {
-              return false;
-            }
-
-            if (resp.has_error()) {
-              return false;
-            }
-
-            if (resp.statuses_size() == 0 ||
-                (resp.statuses()[0].table_id() != consumer_table_id &&
-                 resp.statuses()[0].stream_id() != stream_id.ToString())) {
-              return false;
-            }
-
-            if (resp.statuses()[0].errors_size() == 1) {
-              last_error = resp.statuses()[0].errors()[0].error();
-            } else {
-              last_error = std::nullopt;
-            }
-
-            return expected_replication_error == last_error;
-          },
-          MonoDelta::FromSeconds(30 * kTimeMultiplier), "Waiting for replication error"),
-      Format("Last Replication error: $0,", (last_error ? ToString(*last_error) : "none")));
-
-  return Status::OK();
-}
-
-Result<uint32> XClusterExternalMiniClusterBase::PromoteAutoFlags(
-    ExternalMiniCluster* cluster, AutoFlagClass flag_class, bool force) {
-  auto proxy = cluster->GetLeaderMasterProxy<master::MasterClusterProxy>();
-
-  master::PromoteAutoFlagsRequestPB req;
-  master::PromoteAutoFlagsResponsePB resp;
-  req.set_max_flag_class(ToString(flag_class));
-  req.set_promote_non_runtime_flags(false);
-  req.set_force(force);
-
-  rpc::RpcController rpc;
-  rpc.set_timeout(MonoDelta::FromSeconds(kRpcTimeout));
-  RETURN_NOT_OK(proxy.PromoteAutoFlags(req, &resp, &rpc));
-
-  if (resp.has_error()) {
-    return StatusFromPB(resp.error().status());
-  }
-
-  return resp.new_config_version();
-}
-
-}  // namespace yb
diff --git a/src/yb/integration-tests/xcluster/xcluster_external_mini_cluster_base.h b/src/yb/integration-tests/xcluster/xcluster_external_mini_cluster_base.h
deleted file mode 100644
index 54bb28d87f..0000000000
--- a/src/yb/integration-tests/xcluster/xcluster_external_mini_cluster_base.h
+++ /dev/null
@@ -1,101 +0,0 @@
-// Copyright (c) YugabyteDB, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
-// in compliance with the License.  You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software distributed under the License
-// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
-// or implied.  See the License for the specific language governing permissions and limitations
-// under the License.
-//
-
-#pragma once
-
-#include "yb/cdc/cdc_types.h"
-#include "yb/client/table.h"
-#include "yb/client/yb_table_name.h"
-#include "yb/integration-tests/external_mini_cluster.h"
-#include "yb/integration-tests/xcluster/xcluster_test_base.h"
-#include "yb/master/master_replication.proxy.h"
-#include "yb/tools/admin-test-base.h"
-#include "yb/util/test_util.h"
-
-namespace yb {
-
-class XClusterExternalMiniClusterBase : public YBTest {
- public:
-  void SetUp() override;
-
-  ExternalMiniCluster* SourceCluster() { return source_cluster_.cluster_.get(); }
-  ExternalMiniCluster* TargetCluster() { return target_cluster_.cluster_.get(); }
-  client::YBClient* SourceClient() { return source_cluster_.client_.get(); }
-  client::YBClient* TargetClient() { return target_cluster_.client_.get(); }
-  const std::vector<std::shared_ptr<client::YBTable>>& SourceTables() {
-    return source_cluster_.tables_;
-  }
-  const std::vector<std::shared_ptr<client::YBTable>>& TargetTables() {
-    return target_cluster_.tables_;
-  }
-  client::YBTable* SourceTable() { return source_cluster_.tables_.front().get(); }
-  client::YBTable* TargetTable() { return target_cluster_.tables_.front().get(); }
-
-  virtual Status SetupClusters();
-  virtual Status SetupClustersAndReplicationGroup();
-
-  Status SetupReplication(
-      xcluster::ReplicationGroupId replication_group_id = kReplicationGroupId,
-      std::vector<std::shared_ptr<client::YBTable>> source_tables = {});
-
-  Status VerifyReplicationError(
-      const client::YBTable* consumer_table, const xrepl::StreamId& stream_id,
-      const std::optional<ReplicationErrorPb> expected_replication_error);
-
-  Result<uint32> PromoteAutoFlags(
-      ExternalMiniCluster* cluster, AutoFlagClass flag_class = AutoFlagClass::kExternal,
-      bool force = false);
-
- protected:
-  struct ClusterSetupOptions {
-    uint32_t num_tservers = 1;
-    uint32_t num_masters = 1;
-    std::vector<std::string> master_flags;
-    std::vector<std::string> tserver_flags;
-  };
-
-  struct Cluster {
-    std::unique_ptr<ExternalMiniCluster> cluster_;
-    std::unique_ptr<client::YBClient> client_;
-    std::unique_ptr<master::MasterReplicationProxy> master_proxy_;
-
-    std::vector<std::shared_ptr<client::YBTable>> tables_;
-    ClusterSetupOptions setup_opts_;  // Cluster specific setup options.
-  };
-
-  virtual void AddCommonOptions();
-
-  template <class... Args>
-  Result<std::string> RunYbAdmin(Cluster* cluster, Args&&... args) {
-    return tools::RunAdminToolCommand(
-        cluster->cluster_->GetMasterAddresses(), std::forward<Args>(args)...);
-  }
-
-  Status RunOnBothClusters(std::function<Status(Cluster*)> run_on_cluster);
-
-  Result<Cluster> CreateCluster(
-      const std::string& cluster_id, const std::string& cluster_short_name, uint32_t num_masters,
-      uint32_t num_tservers, const std::vector<std::string>& master_flags,
-      const std::vector<std::string>& tserver_flags);
-
-  Result<client::TableHandle> CreateTable(
-      int num_tablets, client::YBClient* client, const client::YBTableName& table_name);
-
-  Result<xrepl::StreamId> GetStreamId(client::YBTable* table = nullptr);
-
-  ClusterSetupOptions setup_opts_;
-  Cluster source_cluster_;
-  Cluster target_cluster_;
-};
-
-}  // namespace yb
diff --git a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
index ae7730027f..33f5405803 100644
--- a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
@@ -18,7 +18,10 @@
 #include "yb/client/yb_table_name.h"
 #include "yb/common/xcluster_util.h"
 #include "yb/consensus/log.h"
+
+#include "yb/integration-tests/xcluster/xcluster_test_utils.h"
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
+
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master_ddl.pb.h"
 #include "yb/master/mini_master.h"
@@ -59,7 +62,7 @@ class XClusterOutboundReplicationGroupTest : public XClusterYsqlTestBase {
   Result<NamespaceId> CreateYsqlNamespace(const NamespaceName& ns_name) {
     CreateNamespaceResponsePB resp;
     RETURN_NOT_OK(CreateDatabase(&producer_cluster_, ns_name));
-    return GetNamespaceId(client_, ns_name);
+    return XClusterTestUtils::GetNamespaceId(*client_, ns_name);
   }
 
   Result<TableId> CreateYsqlTable(
diff --git a/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc b/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
index 54ee943eca..2675b93013 100644
--- a/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_sequences-test.cc
@@ -17,6 +17,7 @@
 #include "yb/common/entity_ids_types.h"
 #include "yb/common/xcluster_util.h"
 #include "yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h"
+#include "yb/integration-tests/xcluster/xcluster_test_utils.h"
 #include "yb/util/flags.h"
 #include "yb/util/logging_test_util.h"
 
@@ -110,7 +111,7 @@ class XClusterAutomaticModeTest : public XClusterDDLReplicationTestBase {
     std::vector<NamespaceId> sequence_alias_ids;
     for (const auto& ns : namespace_names) {
       sequence_alias_ids.push_back(xcluster::GetSequencesDataAliasForNamespace(
-          VERIFY_RESULT(GetNamespaceId(producer_client(), ns))));
+          VERIFY_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), ns))));
     }
     return WaitForReplicationDrain(
         0, kRpcTimeout, /*target_time=*/std::nullopt, sequence_alias_ids);
@@ -134,8 +135,8 @@ TEST_F(XClusterAutomaticModeTest, StraightforwardSequenceReplication) {
   const std::string namespace1{"yugabyte"};
   ASSERT_OK(SetUpClusters(/*use_different_database_oids=*/false, namespace1));
   ASSERT_EQ(
-      ASSERT_RESULT(GetNamespaceId(producer_client(), namespace1)),
-      ASSERT_RESULT(GetNamespaceId(consumer_client(), namespace1)));
+      ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), namespace1)),
+      ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*consumer_client(), namespace1)));
 
   ASSERT_OK(SetUpSequences(&producer_cluster_, namespace1));
   ASSERT_OK(SetUpSequences(&consumer_cluster_, namespace1));
@@ -166,11 +167,11 @@ TEST_F(XClusterAutomaticModeTest, SequenceReplicationWithFiltering) {
   const std::string namespace2{"yugabyte2"};
   ASSERT_OK(SetUpClusters(/*use_different_database_oids=*/false, namespace1, namespace2));
   ASSERT_EQ(
-      ASSERT_RESULT(GetNamespaceId(producer_client(), namespace1)),
-      ASSERT_RESULT(GetNamespaceId(consumer_client(), namespace1)));
+      ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), namespace1)),
+      ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*consumer_client(), namespace1)));
   ASSERT_EQ(
-      ASSERT_RESULT(GetNamespaceId(producer_client(), namespace2)),
-      ASSERT_RESULT(GetNamespaceId(consumer_client(), namespace2)));
+      ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), namespace2)),
+      ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*consumer_client(), namespace2)));
 
   ASSERT_OK(SetUpSequences(&producer_cluster_, namespace1));
   ASSERT_OK(SetUpSequences(&consumer_cluster_, namespace1));
@@ -248,8 +249,8 @@ TEST_F(XClusterAutomaticModeTest, SequenceReplicationWithTransform) {
   const std::string namespace1{"db_with_differing_oids"};
   ASSERT_OK(SetUpClusters(/*use_different_database_oids=*/true, namespace1));
   ASSERT_NE(
-      ASSERT_RESULT(GetNamespaceId(producer_client(), namespace1)),
-      ASSERT_RESULT(GetNamespaceId(consumer_client(), namespace1)));
+      ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), namespace1)),
+      ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*consumer_client(), namespace1)));
 
   ASSERT_OK(SetUpSequences(&producer_cluster_, namespace1));
   ASSERT_OK(SetUpSequences(&consumer_cluster_, namespace1));
@@ -301,7 +302,7 @@ TEST_F(XClusterAutomaticModeTest, SequencePausingAndSafeTime) {
 
   auto sequences_stream_id =
       ASSERT_RESULT(GetCDCStreamID(xcluster::GetSequencesDataAliasForNamespace(
-          ASSERT_RESULT(GetNamespaceId(producer_client(), namespace_name)))));
+          ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), namespace_name)))));
   ASSERT_OK(PauseResumeXClusterProducerStreams({sequences_stream_id}, /*is_paused=*/true));
   ASSERT_OK(
       StringWaiterLogSink("Replication is paused from the producer for stream").WaitFor(300s));
@@ -329,7 +330,7 @@ TEST_F(XClusterAutomaticModeTest, SequencePausingIsolation) {
   auto pause_one_namespace_temporarily = [&](NamespaceName namespace_to_pause,
                                              NamespaceName other_namespace) {
     auto namespace_to_pause_id =
-        ASSERT_RESULT(GetNamespaceId(producer_client(), namespace_to_pause));
+        ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), namespace_to_pause));
     LOG(INFO) << "***** Pausing namespace: " << namespace_to_pause
               << " ID: " << namespace_to_pause_id;
     auto sequences_stream_id = ASSERT_RESULT(
@@ -456,7 +457,8 @@ TEST_F(XClusterAutomaticModeTest, SequenceReplicationBootstrappingAddingNamespac
   // sequences in the middle of the backup/restore step.
   ASSERT_OK(SetUpSequences(&producer_cluster_, namespace2));
   auto source_xcluster_client = client::XClusterClient(*producer_client());
-  auto source_db_id = ASSERT_RESULT(GetNamespaceId(producer_client(), namespace2));
+  auto source_db_id =
+      ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), namespace2));
   ASSERT_OK(source_xcluster_client.AddNamespaceToOutboundReplicationGroup(
       kReplicationGroupId, source_db_id));
   // Wait for checkpointing to finish.
@@ -465,7 +467,8 @@ TEST_F(XClusterAutomaticModeTest, SequenceReplicationBootstrappingAddingNamespac
   ASSERT_OK(BumpSequences(&producer_cluster_, namespace2));
   ASSERT_OK(RestoreToConsumer({namespace2}));
   // Note that RestoreToConsumer re-creates the namespace so we can't get the ID before now.
-  auto target_db_id = ASSERT_RESULT(GetNamespaceId(consumer_client(), namespace2));
+  auto target_db_id =
+      ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*consumer_client(), namespace2));
   ASSERT_OK(AddNamespaceToXClusterReplication(source_db_id, target_db_id));
 
   ASSERT_OK(VerifySequencesSameOnBothSides(namespace2));
@@ -518,7 +521,7 @@ class XClusterSequenceDDLOrdering : public XClusterDDLReplicationTestBase {
     // Wait for sequences_data replication to drain.
     std::vector<NamespaceId> sequence_alias_ids;
     sequence_alias_ids.push_back(xcluster::GetSequencesDataAliasForNamespace(
-        VERIFY_RESULT(GetNamespaceId(producer_client(), namespace_name))));
+        VERIFY_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), namespace_name))));
     RETURN_NOT_OK(
         WaitForReplicationDrain(0, kRpcTimeout, /*target_time=*/std::nullopt, sequence_alias_ids));
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_test_base.cc
index e918404cb7..9be5455f02 100644
--- a/src/yb/integration-tests/xcluster/xcluster_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_test_base.cc
@@ -12,6 +12,7 @@
 //
 
 #include "yb/integration-tests/xcluster/xcluster_test_base.h"
+#include "yb/integration-tests/xcluster/xcluster_test_utils.h"
 
 #include <string>
 
@@ -164,33 +165,13 @@ void XClusterTestBase::TearDown() {
 }
 
 Status XClusterTestBase::RunOnBothClusters(std::function<Status(MiniCluster*)> run_on_cluster) {
-  auto producer_future = std::async(std::launch::async, [&] {
-    return run_on_cluster(producer_cluster());
-  });
-  auto consumer_future = std::async(std::launch::async, [&] {
-    return run_on_cluster(consumer_cluster());
-  });
-
-  auto producer_status = producer_future.get();
-  auto consumer_status = consumer_future.get();
-
-  RETURN_NOT_OK(producer_status);
-  return consumer_status;
+  return XClusterTestUtils::RunOnBothClusters(
+      producer_cluster(), consumer_cluster(), run_on_cluster);
 }
 
 Status XClusterTestBase::RunOnBothClusters(std::function<Status(Cluster*)> run_on_cluster) {
-  auto producer_future = std::async(std::launch::async, [&] {
-    return run_on_cluster(&producer_cluster_);
-  });
-  auto consumer_future = std::async(std::launch::async, [&] {
-    return run_on_cluster(&consumer_cluster_);
-  });
-
-  auto producer_status = producer_future.get();
-  auto consumer_status = consumer_future.get();
-
-  RETURN_NOT_OK(producer_status);
-  return consumer_status;
+  return XClusterTestUtils::RunOnBothClusters(
+      &producer_cluster_, &consumer_cluster_, run_on_cluster);
 }
 
 Status XClusterTestBase::WaitForLoadBalancersToStabilize() {
diff --git a/src/yb/integration-tests/xcluster/xcluster_test_utils.cc b/src/yb/integration-tests/xcluster/xcluster_test_utils.cc
new file mode 100644
index 0000000000..5a66e1cd15
--- /dev/null
+++ b/src/yb/integration-tests/xcluster/xcluster_test_utils.cc
@@ -0,0 +1,72 @@
+// Copyright (c) YugaByte, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/integration-tests/xcluster/xcluster_test_utils.h"
+
+#include "yb/client/client.h"
+#include "yb/client/xcluster_client.h"
+
+#include "yb/master/master_ddl.pb.h"
+#include "yb/util/backoff_waiter.h"
+#include "yb/util/is_operation_done_result.h"
+#include "yb/util/status.h"
+
+namespace yb::XClusterTestUtils {
+
+Result<NamespaceId> GetNamespaceId(
+    client::YBClient& client, const NamespaceName& ns_name) {
+  master::GetNamespaceInfoResponsePB resp;
+  RETURN_NOT_OK(
+      client.GetNamespaceInfo({} /* namespace_id */, ns_name, YQL_DATABASE_PGSQL, &resp));
+  return resp.namespace_().id();
+}
+
+Result<bool> CheckpointReplicationGroup(
+    client::YBClient& producer_client, const xcluster::ReplicationGroupId& replication_group_id,
+    const NamespaceName& namespace_name, MonoDelta timeout, bool automatic_ddl_mode) {
+  auto namespace_id =
+      VERIFY_RESULT(XClusterTestUtils::GetNamespaceId(producer_client, namespace_name));
+  auto xcluster_client = client::XClusterClient(producer_client);
+  RETURN_NOT_OK(xcluster_client.CreateOutboundReplicationGroup(
+      replication_group_id, {namespace_id}, automatic_ddl_mode));
+
+  std::promise<Result<bool>> promise;
+  auto future = promise.get_future();
+  RETURN_NOT_OK(xcluster_client.IsBootstrapRequired(
+      CoarseMonoClock::now() + timeout, replication_group_id, namespace_id,
+      [&promise](Result<bool> res) { promise.set_value(res); }));
+  return future.get();
+}
+
+Status CreateReplicationFromCheckpoint(
+    client::YBClient& producer_client, const xcluster::ReplicationGroupId& replication_group_id,
+    const std::string& target_master_addr, MonoDelta timeout) {
+  auto xcluster_client = client::XClusterClient(producer_client);
+  RETURN_NOT_OK(xcluster_client.CreateXClusterReplicationFromCheckpoint(
+      replication_group_id, target_master_addr));
+
+  RETURN_NOT_OK(LoggedWaitFor(
+      [&]() -> Result<bool> {
+        auto result = VERIFY_RESULT(xcluster_client.IsCreateXClusterReplicationDone(
+            replication_group_id, target_master_addr));
+        if (!result.status().ok()) {
+          return result.status();
+        }
+        return result.done();
+      },
+      timeout, __func__));
+
+  return Status::OK();
+}
+
+}  // namespace yb::XClusterTestUtils
diff --git a/src/yb/integration-tests/xcluster/xcluster_test_utils.h b/src/yb/integration-tests/xcluster/xcluster_test_utils.h
new file mode 100644
index 0000000000..5909bb413c
--- /dev/null
+++ b/src/yb/integration-tests/xcluster/xcluster_test_utils.h
@@ -0,0 +1,56 @@
+// Copyright (c) YugaByte, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include "yb/common/entity_ids_types.h"
+#include "yb/cdc/xcluster_types.h"
+
+namespace yb {
+
+namespace client {
+class YBClient;
+}  // namespace client
+
+namespace XClusterTestUtils {
+
+template <typename Cluster>
+Status RunOnBothClusters(
+    Cluster* producer_cluster, Cluster* consumer_cluster,
+    const std::function<Status(Cluster*)>& run_on_cluster) {
+  auto producer_future =
+      std::async(std::launch::async, [&] { return run_on_cluster(producer_cluster); });
+  auto consumer_future =
+      std::async(std::launch::async, [&] { return run_on_cluster(consumer_cluster); });
+
+  auto producer_status = producer_future.get();
+  auto consumer_status = consumer_future.get();
+
+  RETURN_NOT_OK_PREPEND(producer_status, "Producer cluster operation failed");
+  RETURN_NOT_OK_PREPEND(consumer_status, "Consumer cluster operation failed");
+  return Status::OK();
+}
+
+Result<NamespaceId> GetNamespaceId(
+    client::YBClient& client, const NamespaceName& ns_name);
+
+Result<bool> CheckpointReplicationGroup(
+    client::YBClient& producer_client, const xcluster::ReplicationGroupId& replication_group_id,
+    const NamespaceName& namespace_name, MonoDelta timeout, bool automatic_ddl_mode = false);
+
+Status CreateReplicationFromCheckpoint(
+    client::YBClient& producer_client, const xcluster::ReplicationGroupId& replication_group_id,
+    const std::string& target_master_addr, MonoDelta timeout);
+
+}  // namespace XClusterTestUtils
+}  // namespace yb
diff --git a/src/yb/integration-tests/xcluster/xcluster_upgrade-test.cc b/src/yb/integration-tests/xcluster/xcluster_upgrade-test.cc
index 4c8bed9914..443520eefd 100644
--- a/src/yb/integration-tests/xcluster/xcluster_upgrade-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_upgrade-test.cc
@@ -12,14 +12,11 @@
 
 #include "yb/client/table.h"
 #include "yb/common/wire_protocol.h"
-#include "yb/integration-tests/xcluster/xcluster_external_mini_cluster_base.h"
 #include "yb/integration-tests/xcluster/xcluster_ycql_test_base.h"
-#include "yb/master/catalog_manager.h"
 #include "yb/master/master.h"
 #include "yb/master/master_auto_flags_manager.h"
 #include "yb/master/master_cluster.pb.h"
 #include "yb/master/mini_master.h"
-#include "yb/util/flags/auto_flags_util.h"
 
 DECLARE_int32(replication_factor);
 DECLARE_int32(limit_auto_flag_promote_for_new_universe);
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc b/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
index 6f84d80689..21fd5bfbff 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
@@ -23,6 +23,7 @@
 #include <gtest/gtest.h>
 
 #include "yb/client/yb_table_name.h"
+#include "yb/integration-tests/xcluster/xcluster_test_utils.h"
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
 
 #include "yb/common/common.pb.h"
@@ -2647,7 +2648,8 @@ TEST_F_EX(XClusterYsqlTest, DmlOperationsBlockedOnStandbyCluster, XClusterYsqlTe
 
   for (auto& conn : consumer_conns) {
     auto namespace_name = ASSERT_RESULT(conn.FetchRow<std::string>("SELECT current_database()"));
-    auto namespace_id = ASSERT_RESULT(GetNamespaceId(consumer_client(), namespace_name));
+    auto namespace_id =
+        ASSERT_RESULT(XClusterTestUtils::GetNamespaceId(*consumer_client(), namespace_name));
     ASSERT_OK(
         WaitForReadOnlyModeOnAllTServers(namespace_id, /*is_read_only=*/false, &consumer_cluster_));
   }
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
index 7c841b25ec..1eb1bb68f7 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
@@ -41,6 +41,8 @@
 
 #include "yb/yql/pgwrapper/libpq_utils.h"
 
+#include "yb/integration-tests/xcluster/xcluster_test_utils.h"
+
 DECLARE_bool(enable_ysql);
 DECLARE_bool(hide_pg_catalog_table_creation_logs);
 DECLARE_bool(master_auto_run_initdb);
@@ -270,17 +272,7 @@ std::string XClusterYsqlTestBase::GetCompleteTableName(const YBTableName& table)
 }
 
 Result<NamespaceId> XClusterYsqlTestBase::GetNamespaceId(YBClient* client) {
-  return GetNamespaceId(client, namespace_name);
-}
-
-Result<NamespaceId> XClusterYsqlTestBase::GetNamespaceId(
-    YBClient* client, const NamespaceName& ns_name) {
-  master::GetNamespaceInfoResponsePB resp;
-
-  RETURN_NOT_OK(
-      client->GetNamespaceInfo({} /* namespace_id */, ns_name, YQL_DATABASE_PGSQL, &resp));
-
-  return resp.namespace_().id();
+  return XClusterTestUtils::GetNamespaceId(*client, namespace_name);
 }
 
 Result<YBTableName> XClusterYsqlTestBase::CreateYsqlTable(
@@ -391,8 +383,8 @@ Result<std::pair<NamespaceId, NamespaceId>> XClusterYsqlTestBase::CreateDatabase
     return Status::OK();
   }));
   return std::make_pair(
-      VERIFY_RESULT(GetNamespaceId(producer_client(), db_name)),
-      VERIFY_RESULT(GetNamespaceId(consumer_client(), db_name)));
+      VERIFY_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), db_name)),
+      VERIFY_RESULT(XClusterTestUtils::GetNamespaceId(*consumer_client(), db_name)));
 }
 
 Result<YBTableName> XClusterYsqlTestBase::GetYsqlTable(
@@ -986,9 +978,9 @@ Status XClusterYsqlTestBase::SetUpClusters(const SetupParams& params) {
 
   if (params.use_different_database_oids) {
     SCHECK_NE(
-        VERIFY_RESULT(GetNamespaceId(producer_client(), namespace_name)),
-        VERIFY_RESULT(GetNamespaceId(consumer_client(), namespace_name)), InternalError,
-        "Unable to use different OIDs for the source and target databases");
+        VERIFY_RESULT(XClusterTestUtils::GetNamespaceId(*producer_client(), namespace_name)),
+        VERIFY_RESULT(XClusterTestUtils::GetNamespaceId(*consumer_client(), namespace_name)),
+        InternalError, "Unable to use different OIDs for the source and target databases");
   }
 
   return PostSetUp();
@@ -996,13 +988,9 @@ Status XClusterYsqlTestBase::SetUpClusters(const SetupParams& params) {
 
 Status XClusterYsqlTestBase::CheckpointReplicationGroup(
     const xcluster::ReplicationGroupId& replication_group_id, bool require_no_bootstrap_needed) {
-  auto producer_namespace_id = VERIFY_RESULT(GetNamespaceId(producer_client()));
-  RETURN_NOT_OK(client::XClusterClient(*producer_client())
-                    .CreateOutboundReplicationGroup(
-                        replication_group_id, {producer_namespace_id}, UseAutomaticMode()));
-
-  auto bootstrap_required =
-      VERIFY_RESULT(IsXClusterBootstrapRequired(replication_group_id, producer_namespace_id));
+  auto bootstrap_required = VERIFY_RESULT(XClusterTestUtils::CheckpointReplicationGroup(
+      *producer_client(), replication_group_id, namespace_name, MonoDelta::FromSeconds(kRpcTimeout),
+      UseAutomaticMode()));
   SCHECK(
       !require_no_bootstrap_needed || !bootstrap_required, IllegalState,
       "Bootstrap should not be required");
@@ -1045,25 +1033,6 @@ Status XClusterYsqlTestBase::AddNamespaceToXClusterReplication(
   return WaitForValidSafeTimeOnAllTServers(target_namespace_id);
 }
 
-Status XClusterYsqlTestBase::WaitForCreateReplicationToFinish(
-    const std::string& target_master_addresses, std::vector<NamespaceName> namespace_names,
-    xcluster::ReplicationGroupId replication_group_id) {
-  RETURN_NOT_OK(LoggedWaitFor(
-      [this, &target_master_addresses, replication_group_id]() -> Result<bool> {
-        auto result = VERIFY_RESULT(
-            client::XClusterClient(*producer_client())
-                .IsCreateXClusterReplicationDone(replication_group_id, target_master_addresses));
-        if (!result.status().ok()) {
-          return result.status();
-        }
-        return result.done();
-      },
-      MonoDelta::FromSeconds(kRpcTimeout), __func__));
-
-  // Wait for the xcluster safe time to propagate to the tserver nodes.
-  return WaitForSafeTimeToAdvanceToNow(namespace_names);
-}
-
 Status XClusterYsqlTestBase::CreateReplicationFromCheckpoint(
     const std::string& target_master_addresses,
     const xcluster::ReplicationGroupId& replication_group_id,
@@ -1078,10 +1047,10 @@ Status XClusterYsqlTestBase::CreateReplicationFromCheckpoint(
     namespace_names = {namespace_name};
   }
 
-  RETURN_NOT_OK(client::XClusterClient(*producer_client())
-                    .CreateXClusterReplicationFromCheckpoint(replication_group_id, master_addr));
+  RETURN_NOT_OK(XClusterTestUtils::CreateReplicationFromCheckpoint(
+      *producer_client(), replication_group_id, master_addr, MonoDelta::FromSeconds(kRpcTimeout)));
 
-  return WaitForCreateReplicationToFinish(master_addr, namespace_names, replication_group_id);
+  return WaitForSafeTimeToAdvanceToNow(namespace_names);
 }
 
 Status XClusterYsqlTestBase::DeleteOutboundReplicationGroup(
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
index f0b53c0dc8..0a9bcff107 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
@@ -73,7 +73,6 @@ class XClusterYsqlTestBase : public XClusterTestBase {
   static std::string GetCompleteTableName(const client::YBTableName& table);
 
   Result<NamespaceId> GetNamespaceId(YBClient* client);
-  Result<NamespaceId> GetNamespaceId(YBClient* client, const NamespaceName& ns_name);
   Result<std::string> GetUniverseId(Cluster* cluster);
   Result<master::SysClusterConfigEntryPB> GetClusterConfig(Cluster& cluster);
 
@@ -191,11 +190,6 @@ class XClusterYsqlTestBase : public XClusterTestBase {
       const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId,
       std::vector<NamespaceName> namespace_names = {});
 
-  // A empty list for namespace_names (the default) means just the namespace namespace_name.
-  Status WaitForCreateReplicationToFinish(
-      const std::string& target_master_addresses, std::vector<NamespaceName> namespace_names = {},
-      xcluster::ReplicationGroupId replication_group_id = kReplicationGroupId);
-
   Status DeleteOutboundReplicationGroup(
       const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId);
 
diff --git a/src/yb/integration-tests/yb_table_test_base.cc b/src/yb/integration-tests/yb_table_test_base.cc
index 28c61dd065..1c560903e0 100644
--- a/src/yb/integration-tests/yb_table_test_base.cc
+++ b/src/yb/integration-tests/yb_table_test_base.cc
@@ -131,6 +131,7 @@ void YBTableTestBase::SetUp() {
         .extra_tserver_flags = {},
         .extra_master_flags = {},
         .cluster_id = {},
+        .cluster_short_name = {},
     };
     CustomizeExternalMiniCluster(&opts);
 
diff --git a/src/yb/master/xcluster/xcluster_replication_group.cc b/src/yb/master/xcluster/xcluster_replication_group.cc
index 3680ab4909..16d49855eb 100644
--- a/src/yb/master/xcluster/xcluster_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_replication_group.cc
@@ -101,6 +101,9 @@ Status ValidateAutoFlagsInternal(
     } else if (
         !is_valid && old_compatible_auto_flag_config_version != kInvalidAutoFlagsConfigVersion) {
       // We are not compatible with the source universe anymore.
+      LOG(WARNING) << "xCluster replication group " << replication_group_id
+                   << " is not compatible with the source universe AutoFlags. Upgrade the universe "
+                      "to a version that is equal to or higher than the source universe";
       producer_entry->set_compatible_auto_flag_config_version(kInvalidAutoFlagsConfigVersion);
       cluster_config_changed = true;
     }
