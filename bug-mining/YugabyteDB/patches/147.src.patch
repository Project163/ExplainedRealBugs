diff --git a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
index 6e4f0a3cba..ae83d8e006 100644
--- a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
@@ -11,6 +11,9 @@
 // under the License.
 //
 
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
 #include "yb/client/xcluster_client.h"
 #include "yb/client/yb_table_name.h"
 #include "yb/consensus/log.h"
@@ -21,10 +24,13 @@
 #include "yb/tablet/tablet_peer.h"
 #include "yb/util/backoff_waiter.h"
 
+DECLARE_int32(update_min_cdc_indices_interval_secs);
 DECLARE_uint32(cdc_wal_retention_time_secs);
 DECLARE_uint32(max_xcluster_streams_to_checkpoint_in_parallel);
 DECLARE_bool(TEST_block_xcluster_checkpoint_namespace_task);
-DECLARE_int32(update_min_cdc_indices_interval_secs);
+DECLARE_bool(TEST_xcluster_enable_ddl_replication);
+DECLARE_bool(TEST_xcluster_enable_sequence_replication);
+
 namespace yb {
 namespace master {
 
@@ -38,6 +44,11 @@ class XClusterOutboundReplicationGroupTest : public XClusterYsqlTestBase {
  public:
   XClusterOutboundReplicationGroupTest() {}
   void SetUp() override {
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_enable_sequence_replication) =
+        UseAutomaticMode();
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_enable_ddl_replication) =
+        UseAutomaticMode();
+
     XClusterYsqlTestBase::SetUp();
     MiniClusterOptions opts;
     opts.num_tablet_servers = 1;
@@ -52,6 +63,21 @@ class XClusterOutboundReplicationGroupTest : public XClusterYsqlTestBase {
     namespace_id_ = ASSERT_RESULT(CreateYsqlNamespace(kNamespaceName));
   }
 
+  virtual bool UseAutomaticMode() {
+    // Except for parameterized tests, we currently default to semi-automatic mode.
+    return false;
+  }
+
+  // How many extra streams/tables a namespace has
+  int OverheadStreamsCount() {
+    if (!UseAutomaticMode()) {
+      return 0;
+    }
+    // So far automatic mode has one extra stream for each namespace: sequences_data.
+    // TODO(jhe): increment this when you add the DDL queue table
+    return 1;
+  }
+
   Result<NamespaceId> CreateYsqlNamespace(const NamespaceName& ns_name) {
     CreateNamespaceResponsePB resp;
     RETURN_NOT_OK(CreateDatabase(&producer_cluster_, ns_name));
@@ -79,28 +105,37 @@ class XClusterOutboundReplicationGroupTest : public XClusterYsqlTestBase {
 
   void VerifyNamespaceCheckpointInfo(
       const TableId& table_id1, const TableId& table_id2, size_t all_xcluster_streams_count,
-      const master::GetXClusterStreamsResponsePB& resp, bool skip_schema_name_check = false) {
+      const master::GetXClusterStreamsResponsePB& resp, bool sequences_data_included,
+      bool skip_schema_name_check = false) {
     ASSERT_FALSE(resp.initial_bootstrap_required());
-    ASSERT_EQ(resp.table_infos_size(), 2);
+    ASSERT_EQ(resp.table_infos_size(), sequences_data_included ? 3 : 2);
 
     auto all_xcluster_streams = CleanupAndGetAllXClusterStreams();
     ASSERT_EQ(all_xcluster_streams.size(), all_xcluster_streams_count);
 
     std::set<TableId> table_ids;
     for (const auto& table_info : resp.table_infos()) {
+      SCOPED_TRACE("table name: " + table_info.table_name());
       if (table_info.table_name() == kTableName1) {
         ASSERT_EQ(table_info.table_id(), table_id1);
       } else if (table_info.table_name() == kTableName2) {
         ASSERT_EQ(table_info.table_id(), table_id2);
+      } else if (table_info.table_name() == "sequences_data") {
+        ASSERT_EQ(table_info.table_id(), kPgSequencesDataTableId);
       } else {
         FAIL() << "Unexpected table name: " << table_info.table_name();
       }
-      if (skip_schema_name_check) {
-        // Make sure it is not empty.
-        ASSERT_FALSE(table_info.pg_schema_name().empty());
+      if (table_info.table_id() != kPgSequencesDataTableId) {
+        if (skip_schema_name_check) {
+          // Make sure it is not empty.
+          ASSERT_FALSE(table_info.pg_schema_name().empty());
+        } else {
+          ASSERT_EQ(table_info.pg_schema_name(), kPgSchemaName);
+        }
       } else {
-        ASSERT_EQ(table_info.pg_schema_name(), kPgSchemaName);
+        EXPECT_TRUE(table_info.pg_schema_name().empty());
       }
+
       ASSERT_FALSE(table_info.xrepl_stream_id().empty());
       auto stream_id = ASSERT_RESULT(xrepl::StreamId::FromString(table_info.xrepl_stream_id()));
       ASSERT_TRUE(all_xcluster_streams.contains(stream_id));
@@ -175,7 +210,18 @@ class XClusterOutboundReplicationGroupTest : public XClusterYsqlTestBase {
   NamespaceId namespace_id_;
 };
 
-TEST_F(XClusterOutboundReplicationGroupTest, TestMultipleTable) {
+class XClusterOutboundReplicationGroupParameterized : public XClusterOutboundReplicationGroupTest,
+                                                      public ::testing::WithParamInterface<bool> {
+ public:
+  bool UseAutomaticMode() override { return GetParam(); }
+};
+
+INSTANTIATE_TEST_CASE_P(
+    AutoMode, XClusterOutboundReplicationGroupParameterized, ::testing::Values(true));
+INSTANTIATE_TEST_CASE_P(
+    SemiMode, XClusterOutboundReplicationGroupParameterized, ::testing::Values(false));
+
+TEST_P(XClusterOutboundReplicationGroupParameterized, TestMultipleTable) {
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_max_xcluster_streams_to_checkpoint_in_parallel) = 1;
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_update_min_cdc_indices_interval_secs) = 5;
 
@@ -186,21 +232,32 @@ TEST_F(XClusterOutboundReplicationGroupTest, TestMultipleTable) {
 
   ASSERT_NOK(GetXClusterStreams(kReplicationGroupId, namespace_id_));
 
-  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
+      kReplicationGroupId, {namespace_id_}, UseAutomaticMode()));
 
   auto resp = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
 
-  // We should have 2 streams now.
-  size_t stream_count = 2;
+  if (UseAutomaticMode()) {
+    // In automatic mode, sequences_data should have been created.
+    ASSERT_TRUE(catalog_manager_->GetTableInfo(kPgSequencesDataTableId));
+  }
+
+  // We should have 2 normal streams now.
+  size_t stream_count = 2 + OverheadStreamsCount();
   ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(
-      table_id_1, table_id_2, stream_count, resp, /*skip_schema_name_check=*/true));
+      table_id_1, table_id_2, stream_count, resp, /*sequences_data_included=*/UseAutomaticMode(),
+      /*skip_schema_name_check=*/true));
 
   for (const auto& table_info : resp.table_infos()) {
     // Order is not deterministic so search with the table name.
     if (table_info.table_name() == kTableName1) {
       ASSERT_EQ(table_info.pg_schema_name(), kPgSchemaName);
-    } else {
+    } else if (table_info.table_name() == kTableName2) {
       ASSERT_EQ(table_info.pg_schema_name(), pg_schema_name2);
+    } else if (table_info.table_name() == "sequences_data") {
+      EXPECT_EQ(table_info.pg_schema_name(), "");
+    } else {
+      FAIL() << "unknown tablename " << table_info.table_name();
     }
   }
 
@@ -209,7 +266,8 @@ TEST_F(XClusterOutboundReplicationGroupTest, TestMultipleTable) {
       kReplicationGroupId, namespace_id_, {kTableName2, kTableName1},
       {pg_schema_name2, kPgSchemaName}));
   ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(
-      table_id_1, table_id_2, stream_count, resp, /*skip_schema_name_check=*/true));
+      table_id_1, table_id_2, stream_count, resp, /*sequences_data_included=*/false,
+      /*skip_schema_name_check=*/true));
   ASSERT_EQ(resp.table_infos(0).pg_schema_name(), pg_schema_name2);
   ASSERT_EQ(resp.table_infos(1).pg_schema_name(), kPgSchemaName);
   ASSERT_EQ(resp.table_infos(0).table_name(), kTableName2);
@@ -217,6 +275,9 @@ TEST_F(XClusterOutboundReplicationGroupTest, TestMultipleTable) {
 
   ASSERT_OK(VerifyWalRetentionOfTable(table_id_1));
   ASSERT_OK(VerifyWalRetentionOfTable(table_id_2));
+  if (UseAutomaticMode()) {
+    ASSERT_OK(VerifyWalRetentionOfTable(kPgSequencesDataTableId));
+  }
 
   ASSERT_OK(XClusterClient().DeleteOutboundReplicationGroup(
       kReplicationGroupId, /*target_master_addresses=*/{}));
@@ -227,7 +288,7 @@ TEST_F(XClusterOutboundReplicationGroupTest, TestMultipleTable) {
   ASSERT_TRUE(all_xcluster_streams.empty());
 }
 
-TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
+TEST_P(XClusterOutboundReplicationGroupParameterized, AddDeleteNamespaces) {
   auto ns1_table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
   auto ns1_table_id_2 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName2));
 
@@ -236,15 +297,16 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
   auto ns2_table_id_1 = ASSERT_RESULT(CreateYsqlTable(namespace_name_2, kTableName1));
   auto ns2_table_id_2 = ASSERT_RESULT(CreateYsqlTable(namespace_name_2, kTableName2));
 
-  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
+      kReplicationGroupId, {namespace_id_}, UseAutomaticMode()));
 
   // Wait for the new streams to be ready.
   auto ns1_info = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
 
-  // We should have 2 streams now.
-  size_t stream_count = 2;
+  // We should have 2 normal streams now.
+  size_t stream_count = 2 + OverheadStreamsCount();
   auto all_xcluster_streams_initial = CleanupAndGetAllXClusterStreams();
-  ASSERT_EQ(all_xcluster_streams_initial.size(), 2);
+  ASSERT_EQ(all_xcluster_streams_initial.size(), 2 + OverheadStreamsCount());
 
   // Make sure invalid namespace id is handled correctly.
   ASSERT_NOK(GetXClusterStreams(kReplicationGroupId, "BadId"));
@@ -252,15 +314,16 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
   // Make sure only the namespace that was added is returned.
   ASSERT_NOK(GetXClusterStreams(kReplicationGroupId, namespace_id_2));
 
-  ASSERT_NO_FATALS(
-      VerifyNamespaceCheckpointInfo(ns1_table_id_1, ns1_table_id_2, stream_count, ns1_info));
+  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(
+      ns1_table_id_1, ns1_table_id_2, stream_count, ns1_info,
+      /*sequences_data_included=*/UseAutomaticMode()));
 
   // Add the second namespace.
   ASSERT_OK(client::XClusterClient(*client_).AddNamespaceToOutboundReplicationGroup(
       kReplicationGroupId, namespace_id_2));
 
-  // We should have 4 streams now.
-  stream_count = 4;
+  // We should have 4 normal streams now.
+  stream_count = 4 + 2 * OverheadStreamsCount();
 
   // The info of the first namespace should not change.
   auto ns1_info_dup = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
@@ -268,8 +331,9 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
 
   // Validate the seconds namespace.
   auto ns2_info = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_2));
-  ASSERT_NO_FATALS(
-      VerifyNamespaceCheckpointInfo(ns2_table_id_1, ns2_table_id_2, stream_count, ns2_info));
+  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(
+      ns2_table_id_1, ns2_table_id_2, stream_count, ns2_info,
+      /*sequences_data_included=*/UseAutomaticMode()));
 
   ASSERT_OK(XClusterClient().RemoveNamespaceFromOutboundReplicationGroup(
       kReplicationGroupId, namespace_id_, /*target_master_addresses=*/{}));
@@ -278,7 +342,7 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
   // We should only have only the streams from second namespace.
   {
     auto new_xcluster_streams = CleanupAndGetAllXClusterStreams();
-    ASSERT_EQ(new_xcluster_streams.size(), 2);
+    ASSERT_EQ(new_xcluster_streams.size(), 2 + OverheadStreamsCount());
 
     // new_xcluster_streams and all_xcluster_streams should not overlap.
     for (const auto& stream : new_xcluster_streams) {
@@ -293,19 +357,20 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddDeleteNamespaces) {
   ASSERT_TRUE(final_xcluster_streams.empty());
 }
 
-TEST_F(XClusterOutboundReplicationGroupTest, AddTable) {
+TEST_P(XClusterOutboundReplicationGroupParameterized, AddTable) {
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_update_min_cdc_indices_interval_secs) = 5;
 
   auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
   ASSERT_OK(VerifyWalRetentionOfTable(table_id_1, 900));
 
-  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
+      kReplicationGroupId, {namespace_id_}, UseAutomaticMode()));
 
   // Wait for the new streams to be ready.
   ASSERT_OK(GetXClusterStreams(kReplicationGroupId, namespace_id_));
 
   auto all_xcluster_streams_initial = CleanupAndGetAllXClusterStreams();
-  ASSERT_EQ(all_xcluster_streams_initial.size(), 1);
+  ASSERT_EQ(all_xcluster_streams_initial.size(), 1 + OverheadStreamsCount());
 
   ASSERT_OK(VerifyWalRetentionOfTable(table_id_1));
 
@@ -313,8 +378,10 @@ TEST_F(XClusterOutboundReplicationGroupTest, AddTable) {
 
   auto ns1_info = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
 
-  size_t stream_count = 2;
-  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(table_id_1, table_id_2, stream_count, ns1_info));
+  size_t stream_count = 2 + OverheadStreamsCount();
+  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(
+      table_id_1, table_id_2, stream_count, ns1_info,
+      /*sequences_data_included=*/UseAutomaticMode()));
 
   ASSERT_OK(VerifyWalRetentionOfTable(table_id_2));
 }
@@ -323,7 +390,8 @@ TEST_F(XClusterOutboundReplicationGroupTest, IsBootstrapRequiredEmptyTable) {
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_max_xcluster_streams_to_checkpoint_in_parallel) = 1;
 
   auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
-  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
+      kReplicationGroupId, {namespace_id_}, UseAutomaticMode()));
 
   std::promise<Result<bool>> promise;
 
@@ -344,7 +412,8 @@ TEST_F(XClusterOutboundReplicationGroupTest, IsBootstrapRequiredTableWithData) {
   ASSERT_OK(producer_client()->OpenTable(table_id_2, &table_2));
   ASSERT_OK(InsertRowsInProducer(0, 10, table_2));
 
-  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
+      kReplicationGroupId, {namespace_id_}, UseAutomaticMode()));
 
   std::promise<Result<bool>> promise;
 
@@ -366,7 +435,8 @@ TEST_F(XClusterOutboundReplicationGroupTest, IsBootstrapRequiredTableWithDeleted
   ASSERT_OK(InsertRowsInProducer(0, 10, table_2));
   ASSERT_OK(DeleteRowsInProducer(0, 10, table_2));
 
-  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
+      kReplicationGroupId, {namespace_id_}, UseAutomaticMode()));
 
   std::promise<Result<bool>> promise;
 
@@ -378,14 +448,22 @@ TEST_F(XClusterOutboundReplicationGroupTest, IsBootstrapRequiredTableWithDeleted
   ASSERT_FALSE(is_bootstrap_required);
 }
 
-TEST_F(XClusterOutboundReplicationGroupTest, MasterRestartDuringCheckpoint) {
+TEST_P(XClusterOutboundReplicationGroupParameterized, MasterRestartDuringCheckpoint) {
+  // Temporarily disabling this during automatic mode because automatic mode does not yet
+  // successfully survive a master restart during a checkpoint.
+  // TODO(GitHub issue #23918): fix automatic mode so it passes this test then reenable this test.
+  if (UseAutomaticMode()) {
+    return;
+  }
+
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_max_xcluster_streams_to_checkpoint_in_parallel) = 1;
   auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
   auto table_id_2 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName2));
 
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_block_xcluster_checkpoint_namespace_task) = true;
 
-  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
+      kReplicationGroupId, {namespace_id_}, UseAutomaticMode()));
 
   std::promise<Result<master::GetXClusterStreamsResponsePB>> promise;
   auto future = promise.get_future();
@@ -395,26 +473,29 @@ TEST_F(XClusterOutboundReplicationGroupTest, MasterRestartDuringCheckpoint) {
 
   ASSERT_EQ(future.wait_for(5s), std::future_status::timeout);
 
+  LOG(INFO) << "***** Restarting Master now...";
   ASSERT_OK(RestartMaster());
 
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_block_xcluster_checkpoint_namespace_task) = false;
 
   auto resp = ASSERT_RESULT(future.get());
-  size_t stream_count = 2;
-  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(table_id_1, table_id_2, stream_count, resp));
+  size_t stream_count = 2 + OverheadStreamsCount();
+  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(
+      table_id_1, table_id_2, stream_count, resp, /*sequences_data_included=*/UseAutomaticMode()));
 
   auto all_xcluster_streams_initial = CleanupAndGetAllXClusterStreams();
   ASSERT_EQ(all_xcluster_streams_initial.size(), stream_count);
 }
 
-TEST_F(XClusterOutboundReplicationGroupTest, Repair) {
+TEST_P(XClusterOutboundReplicationGroupParameterized, Repair) {
   auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
   auto table_id_2 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName2));
 
-  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
+      kReplicationGroupId, {namespace_id_}, UseAutomaticMode()));
 
   auto resp = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
-  ASSERT_EQ(resp.table_infos_size(), 2);
+  ASSERT_EQ(resp.table_infos_size(), 2 + OverheadStreamsCount());
 
   ASSERT_NOK_STR_CONTAINS(
       XClusterClient().RepairOutboundXClusterReplicationGroupRemoveTable(
@@ -435,10 +516,16 @@ TEST_F(XClusterOutboundReplicationGroupTest, Repair) {
       "not found in xClusterOutboundReplicationGroup");
 
   resp = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
-  ASSERT_EQ(resp.table_infos_size(), 1);
-  ASSERT_EQ(resp.table_infos(0).table_id(), table_id_2);
+  ASSERT_EQ(resp.table_infos_size(), 1 + OverheadStreamsCount());
+  int found = -1;
+  for (int i = 0; i < resp.table_infos_size(); i++) {
+    if (resp.table_infos(i).table_id() == table_id_2) {
+       found = i;
+    }
+  }
+  ASSERT_NE(found, -1);
   const auto table2_stream_id =
-      ASSERT_RESULT(xrepl::StreamId::FromString(resp.table_infos(0).xrepl_stream_id()));
+      ASSERT_RESULT(xrepl::StreamId::FromString(resp.table_infos(found).xrepl_stream_id()));
 
   ASSERT_NOK_STR_CONTAINS(
       GetXClusterStreams(kReplicationGroupId, namespace_id_, {kTableName1}, {kPgSchemaName}),
@@ -478,33 +565,46 @@ TEST_F(XClusterOutboundReplicationGroupTest, Repair) {
       "already exists in");
 
   resp = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
-  ASSERT_EQ(resp.table_infos_size(), 2);
-  ASSERT_EQ(resp.table_infos(0).table_id(), table_id_2);
+  ASSERT_EQ(resp.table_infos_size(), 2 + OverheadStreamsCount());
+  found = -1;
+  for (int i = 0; i < resp.table_infos_size(); i++) {
+    if (resp.table_infos(i).table_id() == table_id_2) {
+      found = i;
+    }
+  }
+  ASSERT_NE(found, -1);
   for (const auto& table_info : resp.table_infos()) {
-    auto stream_id_str = new_stream_id.ToString();
-    if (table_info.table_id() == table_id_2) {
-      stream_id_str = table2_stream_id.ToString();
+    if (table_info.table_id() == table_id_1) {
+      auto stream_id_str = new_stream_id.ToString();
+      ASSERT_EQ(table_info.xrepl_stream_id(), stream_id_str);
+    } else if (table_info.table_id() == table_id_2) {
+      auto stream_id_str = table2_stream_id.ToString();
+      ASSERT_EQ(table_info.xrepl_stream_id(), stream_id_str);
     }
-    ASSERT_EQ(table_info.xrepl_stream_id(), stream_id_str);
   }
 }
 
-TEST_F(XClusterOutboundReplicationGroupTest, RepairWithYbAdmin) {
+TEST_P(XClusterOutboundReplicationGroupParameterized, RepairWithYbAdmin) {
   auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
   auto table_id_2 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName2));
 
-  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
+      kReplicationGroupId, {namespace_id_}, UseAutomaticMode()));
 
   auto resp = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
-  ASSERT_EQ(resp.table_infos_size(), 2);
+  ASSERT_EQ(resp.table_infos_size(), 2 + OverheadStreamsCount());
 
   ASSERT_OK(CallAdmin(
       producer_cluster(), "repair_xcluster_outbound_replication_remove_table", kReplicationGroupId,
       table_id_1));
 
   resp = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
-  ASSERT_EQ(resp.table_infos_size(), 1);
-  ASSERT_EQ(resp.table_infos(0).table_id(), table_id_2);
+  ASSERT_EQ(resp.table_infos_size(), 1 + OverheadStreamsCount());
+  std::vector<TableId> table_ids;
+  for (const auto& table_info : resp.table_infos()) {
+    table_ids.push_back(table_info.table_id());
+  }
+  EXPECT_THAT(table_ids, testing::Contains(table_id_2));
 
   const auto new_stream_ids =
       ASSERT_RESULT(BootstrapProducer(producer_cluster(), client_, {table_id_1}));
@@ -516,12 +616,12 @@ TEST_F(XClusterOutboundReplicationGroupTest, RepairWithYbAdmin) {
       table_id_1, new_stream_id.ToString()));
 
   resp = ASSERT_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
-  ASSERT_EQ(resp.table_infos_size(), 2);
+  ASSERT_EQ(resp.table_infos_size(), 2 + OverheadStreamsCount());
 }
 
 // Validate the GetXClusterOutboundReplicationGroupInfo, and
 // GetXClusterOutboundReplicationGroups RPCs.
-TEST_F(XClusterOutboundReplicationGroupTest, TestListAPIs) {
+TEST_P(XClusterOutboundReplicationGroupParameterized, TestListAPIs) {
   // Create two DBs with different table counts.
   ASSERT_OK(CreateYsqlTable(kNamespaceName, kTableName1));
 
@@ -532,7 +632,7 @@ TEST_F(XClusterOutboundReplicationGroupTest, TestListAPIs) {
 
   // Replication group 1 with two namespaces.
   ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
-      kReplicationGroupId, {namespace_id_, namespace_id_2}));
+      kReplicationGroupId, {namespace_id_, namespace_id_2}, UseAutomaticMode()));
   // Wait for checkpointing to complete.
   ASSERT_OK(GetXClusterStreams(kReplicationGroupId, namespace_id_));
   ASSERT_OK(GetXClusterStreams(kReplicationGroupId, namespace_id_2));
@@ -542,13 +642,14 @@ TEST_F(XClusterOutboundReplicationGroupTest, TestListAPIs) {
     ASSERT_EQ(group_info.size(), 2);
     ASSERT_TRUE(group_info.contains(namespace_id_));
     ASSERT_TRUE(group_info.contains(namespace_id_2));
-    ASSERT_EQ(group_info[namespace_id_].size(), 1);
-    ASSERT_EQ(group_info[namespace_id_2].size(), 2);
+    ASSERT_EQ(group_info[namespace_id_].size(), 1 + OverheadStreamsCount());
+    ASSERT_EQ(group_info[namespace_id_2].size(), 2 + OverheadStreamsCount());
   }
 
   // Replication group 2 with one namespace.
   const xcluster::ReplicationGroupId replication_group2("rg2");
-  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(replication_group2, {namespace_id_}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
+      replication_group2, {namespace_id_}, UseAutomaticMode()));
   ASSERT_OK(GetXClusterStreams(replication_group2, namespace_id_));
   // Wait for checkpointing to complete.
   {
@@ -556,7 +657,7 @@ TEST_F(XClusterOutboundReplicationGroupTest, TestListAPIs) {
         ASSERT_RESULT(XClusterClient().GetXClusterOutboundReplicationGroupInfo(replication_group2));
     ASSERT_EQ(group_info.size(), 1);
     ASSERT_TRUE(group_info.contains(namespace_id_));
-    ASSERT_EQ(group_info[namespace_id_].size(), 1);
+    ASSERT_EQ(group_info[namespace_id_].size(), 1 + OverheadStreamsCount());
   }
 
   // List groups for a namespace without any replication groups.
@@ -618,10 +719,11 @@ TEST_F(XClusterOutboundReplicationGroupTest, TestListAPIs) {
 }
 
 // Make sure we cleanup the streams of the failed table create.
-TEST_F(XClusterOutboundReplicationGroupTest, CleanupStreamsOfFailedTableCreate) {
+TEST_P(XClusterOutboundReplicationGroupParameterized, CleanupStreamsOfFailedTableCreate) {
   auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
-  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
-  int expected_stream_count = 1;
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
+      kReplicationGroupId, {namespace_id_}, UseAutomaticMode()));
+  int expected_stream_count = 1 + OverheadStreamsCount();
 
   auto check_streams = [&]() -> Status {
     auto resp = VERIFY_RESULT(GetXClusterStreams(kReplicationGroupId, namespace_id_));
@@ -656,10 +758,11 @@ TEST_F(XClusterOutboundReplicationGroupTest, CleanupStreamsOfFailedTableCreate)
   ASSERT_OK(check_streams());
 }
 
-TEST_F(XClusterOutboundReplicationGroupTest, TestGetStreamByTableId) {
+TEST_P(XClusterOutboundReplicationGroupParameterized, TestGetStreamByTableId) {
   auto table_id_1 = ASSERT_RESULT(CreateYsqlTable(kNamespaceName, kTableName1));
 
-  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(kReplicationGroupId, {namespace_id_}));
+  ASSERT_OK(XClusterClient().CreateOutboundReplicationGroup(
+      kReplicationGroupId, {namespace_id_}, UseAutomaticMode()));
 
   // Delete the table to put it into HIDDEN state.
   ASSERT_OK(DropYsqlTable(&producer_cluster_, kNamespaceName, kPgSchemaName, kTableName1));
@@ -683,6 +786,14 @@ TEST_F(XClusterOutboundReplicationGroupTest, TestGetStreamByTableId) {
   ASSERT_EQ(ns_info.table_infos(0).table_id(), table_id_1);
   ASSERT_EQ(ns_info.table_infos(1).table_id(), table_id_2);
 
+  if (UseAutomaticMode()) {
+    // Verify that we can request sequences_data by its table id.
+    auto ns_info = ASSERT_RESULT(
+        GetXClusterStreamsByTableId(kReplicationGroupId, namespace_id_, {kPgSequencesDataTableId}));
+    ASSERT_EQ(ns_info.table_infos_size(), 1);
+    ASSERT_EQ(ns_info.table_infos(0).table_id(), kPgSequencesDataTableId);
+  }
+
   // Verify that we can request a table that does not exist.
   ASSERT_NOK_STR_CONTAINS(
       GetXClusterStreamsByTableId(kReplicationGroupId, namespace_id_, {"bad_table_id"}),
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index a6676c307e..9408d8eb87 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -7864,11 +7864,11 @@ Status CatalogManager::ListTables(const ListTablesRequestPB* req,
   return Status::OK();
 }
 
-scoped_refptr<TableInfo> CatalogManager::GetTableInfoUnlocked(const TableId& table_id) {
+scoped_refptr<TableInfo> CatalogManager::GetTableInfoUnlocked(const TableId& table_id) const {
   return tables_->FindTableOrNull(table_id);
 }
 
-scoped_refptr<TableInfo> CatalogManager::GetTableInfo(const TableId& table_id) {
+scoped_refptr<TableInfo> CatalogManager::GetTableInfo(const TableId& table_id) const {
   SharedLock lock(mutex_);
   return GetTableInfoUnlocked(table_id);
 }
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index fc765a463e..bc5ff814f6 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -787,8 +787,8 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
   bool IsLoadBalancerEnabled() override;
 
   // Return the table info for the table with the specified UUID, if it exists.
-  TableInfoPtr GetTableInfo(const TableId& table_id) EXCLUDES(mutex_) override;
-  TableInfoPtr GetTableInfoUnlocked(const TableId& table_id) REQUIRES_SHARED(mutex_);
+  TableInfoPtr GetTableInfo(const TableId& table_id) const EXCLUDES(mutex_) override;
+  TableInfoPtr GetTableInfoUnlocked(const TableId& table_id) const REQUIRES_SHARED(mutex_);
 
   // Gets the table info for each table id, or sets it to null if the table id was not found.
   std::unordered_map<TableId, TableInfoPtr> GetTableInfos(const std::vector<TableId>& table_ids)
diff --git a/src/yb/master/catalog_manager_if.h b/src/yb/master/catalog_manager_if.h
index 8277459748..baf26b1b1d 100644
--- a/src/yb/master/catalog_manager_if.h
+++ b/src/yb/master/catalog_manager_if.h
@@ -147,7 +147,7 @@ class CatalogManagerIf {
 
   virtual bool IsUserIndex(const TableInfo& table) const = 0;
 
-  virtual TableInfoPtr GetTableInfo(const TableId& table_id) = 0;
+  virtual TableInfoPtr GetTableInfo(const TableId& table_id) const = 0;
 
   virtual Result<ReplicationInfoPB> GetTableReplicationInfo(
       const ReplicationInfoPB& table_replication_info,
diff --git a/src/yb/master/xcluster/master_xcluster_util.cc b/src/yb/master/xcluster/master_xcluster_util.cc
index fcca632763..1affc1c6cf 100644
--- a/src/yb/master/xcluster/master_xcluster_util.cc
+++ b/src/yb/master/xcluster/master_xcluster_util.cc
@@ -65,11 +65,19 @@ std::string GetFullTableName(const TableInfo& table_info) {
 }
 
 Result<std::vector<TableInfoPtr>> GetTablesEligibleForXClusterReplication(
-    const CatalogManager& catalog_manager, const NamespaceId& namespace_id) {
+    const CatalogManager& catalog_manager, const NamespaceId& namespace_id,
+    bool include_sequences_data) {
   auto table_infos = VERIFY_RESULT(catalog_manager.GetTableInfosForNamespace(namespace_id));
   EraseIf(
       [](const TableInfoPtr& table) { return !IsTableEligibleForXClusterReplication(*table); },
       &table_infos);
+
+  if (include_sequences_data) {
+    auto sequence_table_info = catalog_manager.GetTableInfo(kPgSequencesDataTableId);
+    if (sequence_table_info) {
+      table_infos.push_back(std::move(sequence_table_info));
+    }
+  }
   return table_infos;
 }
 
diff --git a/src/yb/master/xcluster/master_xcluster_util.h b/src/yb/master/xcluster/master_xcluster_util.h
index 0a6be86669..1265db8b9a 100644
--- a/src/yb/master/xcluster/master_xcluster_util.h
+++ b/src/yb/master/xcluster/master_xcluster_util.h
@@ -28,7 +28,8 @@ bool IsTableEligibleForXClusterReplication(const master::TableInfo& table);
 std::string GetFullTableName(const TableInfo& table_info);
 
 Result<std::vector<TableInfoPtr>> GetTablesEligibleForXClusterReplication(
-    const CatalogManager& catalog_manager, const NamespaceId& namespace_id);
+    const CatalogManager& catalog_manager, const NamespaceId& namespace_id,
+    bool include_sequences_data);
 
 bool IsDbScoped(const SysUniverseReplicationEntryPB& replication_info);
 
diff --git a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
index 5c1bab9dbd..19b8ed3897 100644
--- a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
+++ b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
@@ -54,6 +54,8 @@ DEFINE_test_flag(bool, exit_unfinished_merging, false,
 
 DECLARE_bool(enable_xcluster_auto_flag_validation);
 
+DECLARE_bool(TEST_xcluster_enable_sequence_replication);
+
 using namespace std::placeholders;
 
 namespace yb::master {
@@ -550,8 +552,10 @@ Status XClusterInboundReplicationGroupSetupTask::ValidateTableListForDbScoped()
 
   std::set<TableId> validated_tables;
   for (const auto& namespace_id : target_namespace_ids_) {
-    auto table_infos =
-        VERIFY_RESULT(GetTablesEligibleForXClusterReplication(catalog_manager_, namespace_id));
+    auto table_infos = VERIFY_RESULT(GetTablesEligibleForXClusterReplication(
+        catalog_manager_, namespace_id,
+        /*include_sequences_data=*/
+        (automatic_ddl_mode_ && FLAGS_TEST_xcluster_enable_sequence_replication)));
 
     std::vector<TableId> missing_tables;
 
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index e01ad15d84..7acde37ac8 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -46,6 +46,9 @@ DEFINE_RUNTIME_AUTO_bool(enable_tablet_split_of_xcluster_replicated_tables, kExt
 DEFINE_test_flag(bool, xcluster_enable_ddl_replication, false,
     "Enables xCluster automatic DDL replication.");
 
+DEFINE_test_flag(bool, xcluster_enable_sequence_replication, false,
+    "Enables xCluster automatic replication of sequences.");
+
 #define LOG_FUNC_AND_RPC \
   LOG_WITH_FUNC(INFO) << req->ShortDebugString() << ", from: " << RequestorString(rpc)
 
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
index 74d5154ef9..2e734c6dcb 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
@@ -29,6 +29,8 @@
 
 DECLARE_bool(TEST_enable_sync_points);
 DECLARE_bool(TEST_block_xcluster_checkpoint_namespace_task);
+DECLARE_bool(TEST_xcluster_enable_ddl_replication);
+DECLARE_bool(TEST_xcluster_enable_sequence_replication);
 
 using namespace std::placeholders;
 using testing::_;
@@ -62,11 +64,13 @@ class XClusterOutboundReplicationGroupTaskFactoryMocked
 class XClusterOutboundReplicationGroupMocked : public XClusterOutboundReplicationGroup {
  public:
   explicit XClusterOutboundReplicationGroupMocked(
-      const xcluster::ReplicationGroupId& replication_group_id, HelperFunctions helper_functions,
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const SysXClusterOutboundReplicationGroupEntryPB& outbound_replication_group_pb,
+      HelperFunctions helper_functions,
       XClusterOutboundReplicationGroupTaskFactoryMocked& task_factory)
       : XClusterOutboundReplicationGroup(
-            replication_group_id, {}, std::move(helper_functions), /*tasks_tracker=*/nullptr,
-            task_factory) {
+            replication_group_id, outbound_replication_group_pb, std::move(helper_functions),
+            /*tasks_tracker=*/nullptr, task_factory) {
     remote_client_ = std::make_shared<client::MockXClusterRemoteClientHolder>();
   }
 
@@ -168,6 +172,29 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
     }
   }
 
+  void SetUp() {
+    YBTest::SetUp();
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_enable_ddl_replication) =
+        UseAutomaticMode();
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_enable_sequence_replication) =
+        UseAutomaticMode();
+  }
+
+  virtual bool UseAutomaticMode() {
+    // Except for parameterized tests, we currently default to semi-automatic mode.
+    return false;
+  }
+
+  // How many extra streams/tables a namespace has
+  int OverheadStreamsCount() {
+    if (!UseAutomaticMode()) {
+      return 0;
+    }
+    // So far automatic mode has one extra stream for each namespace: sequences_data.
+    // TODO(jhe): increment this when you add the DDL queue table
+    return 1;
+  }
+
   void CreateNamespace(const NamespaceName& namespace_name, const NamespaceId& namespace_id) {
     scoped_refptr<NamespaceInfo> ns = new NamespaceInfo(namespace_id, /*tasks_tracker=*/nullptr);
     auto l = ns->LockForWrite();
@@ -190,11 +217,13 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
     pb.set_table_type(PGSQL_TABLE_TYPE);
     l.Commit();
 
+    std::lock_guard l2(mutex_);
     namespace_tables[namespace_id].push_back(table_info);
     return table_info;
   }
 
   void DropTable(const NamespaceId& namespace_id, const TableId& table_id) {
+    std::lock_guard l(mutex_);
     auto it = std::find_if(
         namespace_tables[namespace_id].begin(), namespace_tables[namespace_id].end(),
         [&table_id](const auto& table_info) { return table_info->id() == table_id; });
@@ -205,8 +234,10 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
   }
 
   std::shared_ptr<XClusterOutboundReplicationGroupMocked> CreateReplicationGroup() {
+    SysXClusterOutboundReplicationGroupEntryPB outbound_replication_group_pb{};
+    outbound_replication_group_pb.set_automatic_ddl_mode(UseAutomaticMode());
     return std::make_shared<XClusterOutboundReplicationGroupMocked>(
-        kReplicationGroupId, helper_functions, *task_factory);
+        kReplicationGroupId, outbound_replication_group_pb, helper_functions, *task_factory);
   }
 
   scoped_refptr<CDCStreamInfo> CreateXClusterStream(const TableId& table_id) {
@@ -215,7 +246,8 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
     return make_scoped_refptr<CDCStreamInfo>(stream_id);
   }
 
-  std::unordered_map<NamespaceId, std::vector<TableInfoPtr>> namespace_tables;
+  mutable std::shared_mutex mutex_;
+  std::unordered_map<NamespaceId, std::vector<TableInfoPtr>> namespace_tables GUARDED_BY(mutex_);
   std::unordered_map<NamespaceId, scoped_refptr<NamespaceInfo>> namespace_infos;
   std::unordered_set<xrepl::StreamId> xcluster_streams;
   std::unique_ptr<ThreadPool> thread_pool;
@@ -223,10 +255,26 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
   std::unique_ptr<XClusterOutboundReplicationGroupTaskFactoryMocked> task_factory;
 
   XClusterOutboundReplicationGroup::HelperFunctions helper_functions = {
+      .create_sequences_data_table_func =
+          [this]() {
+            (void)CreateTable(
+                kPgSequencesDataNamespaceId, kPgSequencesDataTableId, "sequences_data", "");
+            return Status::OK();
+          },
       .get_namespace_func =
           std::bind(&XClusterOutboundReplicationGroupMockedTest::GetNamespace, this, _1),
       .get_tables_func =
-          [this](const NamespaceId& namespace_id) { return namespace_tables[namespace_id]; },
+          [this](const NamespaceId& namespace_id, bool include_sequences_data) {
+            std::lock_guard l(mutex_);
+            auto tables = namespace_tables[namespace_id];
+            if (include_sequences_data) {
+              auto sequences_tables = namespace_tables[kPgSequencesDataNamespaceId];
+              if (sequences_tables.size() > 0) {
+                tables.push_back(sequences_tables.back());
+              }
+            }
+            return tables;
+          },
       .create_xcluster_streams_func =
           [this](const std::vector<TableId>& table_ids, const LeaderEpoch&) {
             auto create_context = std::make_unique<XClusterCreateStreamsContext>();
@@ -277,35 +325,54 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
 
   void VerifyNamespaceCheckpointInfo(
       const TableId& table_id1, const TableId& table_id2, const NamespaceCheckpointInfo& ns_info,
-      bool skip_schema_name_check = false) {
-    ASSERT_FALSE(ns_info.initial_bootstrap_required);
-    ASSERT_EQ(ns_info.table_infos.size(), 2);
+      bool sequences_data_included, bool skip_schema_name_check = false) {
+    EXPECT_FALSE(ns_info.initial_bootstrap_required);
+    ASSERT_EQ(ns_info.table_infos.size(), sequences_data_included ? 3 : 2);
     std::set<TableId> table_ids;
     for (const auto& table_info : ns_info.table_infos) {
+      SCOPED_TRACE("table name: " + table_info.table_name);
       if (table_info.table_name == kTableName1) {
         ASSERT_EQ(table_info.table_id, table_id1);
       } else if (table_info.table_name == kTableName2) {
         ASSERT_EQ(table_info.table_id, table_id2);
+      } else if (table_info.table_name == "sequences_data") {
+        ASSERT_EQ(table_info.table_id, kPgSequencesDataTableId);
       } else {
         FAIL() << "Unexpected table name: " << table_info.table_name;
       }
-      if (skip_schema_name_check) {
-        // Make sure it is not empty.
-        ASSERT_FALSE(table_info.pg_schema_name.empty());
+      if (table_info.table_id != kPgSequencesDataTableId) {
+        if (skip_schema_name_check) {
+          // Make sure it is not empty.
+          EXPECT_FALSE(table_info.pg_schema_name.empty());
+        } else {
+          EXPECT_EQ(table_info.pg_schema_name, kPgSchemaName);
+        }
       } else {
-        ASSERT_EQ(table_info.pg_schema_name, kPgSchemaName);
+        EXPECT_TRUE(table_info.pg_schema_name.empty());
       }
-      ASSERT_FALSE(table_info.stream_id.IsNil());
-      ASSERT_TRUE(xcluster_streams.contains(table_info.stream_id));
+      EXPECT_FALSE(table_info.stream_id.IsNil());
+      EXPECT_TRUE(xcluster_streams.contains(table_info.stream_id));
 
       table_ids.insert(table_info.table_id);
     }
-    ASSERT_TRUE(table_ids.contains(table_id1));
-    ASSERT_TRUE(table_ids.contains(table_id2));
+    EXPECT_TRUE(table_ids.contains(table_id1));
+    EXPECT_TRUE(table_ids.contains(table_id2));
   }
 };
 
-TEST_F(XClusterOutboundReplicationGroupMockedTest, TestMultipleTable) {
+class XClusterOutboundReplicationGroupMockedParameterized
+    : public XClusterOutboundReplicationGroupMockedTest,
+      public ::testing::WithParamInterface<bool> {
+ public:
+  bool UseAutomaticMode() override { return GetParam(); }
+};
+
+INSTANTIATE_TEST_CASE_P(
+    AutoMode, XClusterOutboundReplicationGroupMockedParameterized, ::testing::Values(true));
+INSTANTIATE_TEST_CASE_P(
+    SemiMode, XClusterOutboundReplicationGroupMockedParameterized, ::testing::Values(false));
+
+TEST_P(XClusterOutboundReplicationGroupMockedParameterized, TestMultipleTable) {
   CreateTable(kNamespaceId, kTableId1, kTableName1, kPgSchemaName);
   CreateTable(kNamespaceId, kTableId2, kTableName2, kPgSchemaName2);
   auto outbound_rg_ptr = CreateReplicationGroup();
@@ -318,17 +385,28 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, TestMultipleTable) {
   auto ns_info_opt = ASSERT_RESULT(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
   ASSERT_TRUE(ns_info_opt.has_value());
 
-  // We should have 2 streams now.
-  ASSERT_EQ(xcluster_streams.size(), 2);
+  if (UseAutomaticMode()) {
+    std::lock_guard l(mutex_);
+    // In automatic mode, sequences_data should have been created.
+    ASSERT_GT(namespace_tables[kPgSequencesDataNamespaceId].size(), 0);
+  }
+
+  // We should have 2 streams for normal tables now.
+  ASSERT_EQ(xcluster_streams.size(), 2 + OverheadStreamsCount());
 
   ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(
-      kTableId1, kTableId2, *ns_info_opt, /*skip_schema_name_check=*/true));
+      kTableId1, kTableId2, *ns_info_opt, /*sequences_data_included=*/UseAutomaticMode(),
+      /*skip_schema_name_check=*/true));
   for (const auto& table_info : ns_info_opt->table_infos) {
     // Order is not deterministic so search with the table name.
     if (table_info.table_name == kTableName1) {
-      ASSERT_EQ(table_info.pg_schema_name, kPgSchemaName);
+      EXPECT_EQ(table_info.pg_schema_name, kPgSchemaName);
+    } else if (table_info.table_name == kTableName2) {
+      EXPECT_EQ(table_info.pg_schema_name, kPgSchemaName2);
+    } else if (table_info.table_name == "sequences_data") {
+      EXPECT_EQ(table_info.pg_schema_name, "");
     } else {
-      ASSERT_EQ(table_info.pg_schema_name, kPgSchemaName2);
+      FAIL() << "unknown tablename " << table_info.table_name;
     }
   }
 
@@ -338,7 +416,8 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, TestMultipleTable) {
   ASSERT_TRUE(ns_info_opt.has_value());
 
   ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(
-      kTableId1, kTableId2, *ns_info_opt, /*skip_schema_name_check=*/true));
+      kTableId1, kTableId2, *ns_info_opt, /*sequences_data_included=*/false,
+      /*skip_schema_name_check=*/true));
   ASSERT_EQ(ns_info_opt->table_infos[0].pg_schema_name, kPgSchemaName2);
   ASSERT_EQ(ns_info_opt->table_infos[1].pg_schema_name, kPgSchemaName);
   ASSERT_EQ(ns_info_opt->table_infos[0].table_name, kTableName2);
@@ -355,7 +434,7 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, TestMultipleTable) {
   ASSERT_TRUE(xcluster_streams.empty());
 }
 
-TEST_F(XClusterOutboundReplicationGroupMockedTest, AddDeleteNamespaces) {
+TEST_P(XClusterOutboundReplicationGroupMockedParameterized, AddDeleteNamespaces) {
   CreateTable(kNamespaceId, kTableId1, kTableName1, kPgSchemaName);
   CreateTable(kNamespaceId, kTableId2, kTableName2, kPgSchemaName);
 
@@ -389,8 +468,8 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddDeleteNamespaces) {
 
   ASSERT_OK(outbound_rg.AddNamespacesSync(kEpoch, {kNamespaceId}, kTimeout));
 
-  // We should have 2 streams now.
-  ASSERT_EQ(xcluster_streams.size(), 2);
+  // We should have 2 normal streams now.
+  EXPECT_EQ(xcluster_streams.size(), 2 + OverheadStreamsCount());
   auto xcluster_streams_initial = xcluster_streams;
 
   // Make sure invalid namespace id is handled correctly.
@@ -401,13 +480,14 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddDeleteNamespaces) {
 
   auto ns1_info_opt = ASSERT_RESULT(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
   ASSERT_TRUE(ns1_info_opt.has_value());
-  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(kTableId1, kTableId2, *ns1_info_opt));
+  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(
+      kTableId1, kTableId2, *ns1_info_opt, /*sequences_data_included=*/UseAutomaticMode()));
 
   // Add the second namespace.
   ASSERT_OK(outbound_rg.AddNamespaceSync(kEpoch, namespace_id_2, kTimeout));
 
-  // We should have 4 streams now.
-  ASSERT_EQ(xcluster_streams.size(), 4);
+  // We should have 4 normal streams now.
+  ASSERT_EQ(xcluster_streams.size(), 4 + 2 * OverheadStreamsCount());
 
   // The info of the first namespace should not change.
   auto ns1_info_dup = ASSERT_RESULT(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
@@ -417,16 +497,18 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddDeleteNamespaces) {
   // Validate the seconds namespace.
   auto ns2_info_opt = ASSERT_RESULT(outbound_rg.GetNamespaceCheckpointInfo(namespace_id_2));
   ASSERT_TRUE(ns2_info_opt.has_value());
-  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(ns2_table_id_1, ns2_table_id_2, *ns2_info_opt));
+  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(
+      ns2_table_id_1, ns2_table_id_2, *ns2_info_opt,
+      /*sequences_data_included=*/UseAutomaticMode()));
 
   ASSERT_OK(outbound_rg.RemoveNamespace(kEpoch, kNamespaceId, /*target_master_addresses=*/{}));
   ASSERT_FALSE(outbound_rg.HasNamespace(kNamespaceId));
   ASSERT_NOK(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
 
   // We should only have only the streams from second namespace.
-  ASSERT_EQ(xcluster_streams.size(), 2);
+  ASSERT_EQ(xcluster_streams.size(), 2 + OverheadStreamsCount());
 
-  // new_xcluster_streams and all_xcluster_streams should not overlap.
+  // New_xcluster_streams and all_xcluster_streams should not overlap.
   for (const auto& stream : xcluster_streams) {
     ASSERT_FALSE(xcluster_streams_initial.contains(stream));
   }
@@ -443,7 +525,7 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddDeleteNamespaces) {
   ASSERT_TRUE(xcluster_streams.empty());
 }
 
-TEST_F(XClusterOutboundReplicationGroupMockedTest, CreateTargetReplicationGroup) {
+TEST_P(XClusterOutboundReplicationGroupMockedParameterized, CreateTargetReplicationGroup) {
   CreateTable(kNamespaceId, kTableId1, kTableName1, kPgSchemaName);
 
   auto outbound_rg_ptr = CreateReplicationGroup();
@@ -452,12 +534,18 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, CreateTargetReplicationGroup)
 
   ASSERT_OK(outbound_rg.AddNamespaceSync(kEpoch, kNamespaceId, kTimeout));
 
-  std::vector<xrepl::StreamId> streams{xcluster_streams.begin(), xcluster_streams.end()};
+  std::vector<xrepl::StreamId> expected_streams{xcluster_streams.begin(), xcluster_streams.end()};
+  std::vector<TableId> expected_tables{kTableId1};
+  if (UseAutomaticMode()) {
+    expected_tables.push_back(kPgSequencesDataTableId);
+  }
   EXPECT_CALL(
-      xcluster_client, SetupDbScopedUniverseReplication(
-                           kReplicationGroupId, _, std::vector<NamespaceName>{kNamespaceName},
-                           std::vector<NamespaceId>{kNamespaceId}, std::vector<TableId>{kTableId1},
-                           streams, /*automatic_ddl_mode=*/false))
+      xcluster_client,
+      SetupDbScopedUniverseReplication(
+          kReplicationGroupId, _, std::vector<NamespaceName>{kNamespaceName},
+          std::vector<NamespaceId>{kNamespaceId},
+          ::testing::UnorderedElementsAreArray(expected_tables),
+          ::testing::UnorderedElementsAreArray(expected_streams), UseAutomaticMode()))
       .Times(AtLeast(1));
 
   ASSERT_OK(outbound_rg.CreateXClusterReplication({}, {}, kEpoch));
@@ -512,7 +600,7 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, CreateTargetReplicationGroup)
       SysXClusterOutboundReplicationGroupEntryPB::TargetUniverseInfoPB::REPLICATING);
 }
 
-TEST_F(XClusterOutboundReplicationGroupMockedTest, AddTable) {
+TEST_P(XClusterOutboundReplicationGroupMockedParameterized, AddTable) {
   auto table_info1 = CreateTable(kNamespaceId, kTableId1, kTableName1, kPgSchemaName);
   CreateTable(kNamespaceId, kTableId2, kTableName2, kPgSchemaName2);
 
@@ -520,15 +608,15 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddTable) {
 
   ASSERT_OK(outbound_rg->AddNamespaceSync(kEpoch, kNamespaceId, kTimeout));
   ASSERT_TRUE(outbound_rg->HasNamespace(kNamespaceId));
-  ASSERT_EQ(xcluster_streams.size(), 2);
+  EXPECT_EQ(xcluster_streams.size(), 2 + OverheadStreamsCount());
 
   auto ns_info = ASSERT_RESULT(outbound_rg->GetNamespaceCheckpointInfo(kNamespaceId));
-  ASSERT_EQ(ns_info->table_infos.size(), 2);
+  EXPECT_EQ(ns_info->table_infos.size(), 2 + OverheadStreamsCount());
 
   // Same table should not get added twice.
   ASSERT_OK(outbound_rg->AddTable(table_info1, kEpoch));
 
-  ASSERT_EQ(ns_info->table_infos.size(), 2);
+  ASSERT_EQ(ns_info->table_infos.size(), 2 + OverheadStreamsCount());
 
   const TableName table_3 = "table3";
   const TableId table_id_3 = "table_id_3";
@@ -536,10 +624,10 @@ TEST_F(XClusterOutboundReplicationGroupMockedTest, AddTable) {
 
   ASSERT_OK(outbound_rg->AddTable(table_info3, kEpoch));
 
-  ASSERT_EQ(xcluster_streams.size(), 3);
+  ASSERT_EQ(xcluster_streams.size(), 3 + OverheadStreamsCount());
   ns_info = ASSERT_RESULT(outbound_rg->GetNamespaceCheckpointInfo(kNamespaceId));
   ASSERT_TRUE(ns_info.has_value());
-  ASSERT_EQ(ns_info->table_infos.size(), 3);
+  ASSERT_EQ(ns_info->table_infos.size(), 3 + OverheadStreamsCount());
 }
 
 // If we create a table during checkpoint, it should fail.
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
index df581c84a2..054f408b85 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
@@ -12,9 +12,10 @@
 //
 
 #include "yb/master/xcluster/xcluster_outbound_replication_group.h"
-#include "yb/common/xcluster_util.h"
+
 #include "yb/client/xcluster_client.h"
 #include "yb/common/colocated_util.h"
+#include "yb/common/xcluster_util.h"
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/xcluster/xcluster_outbound_replication_group_tasks.h"
 #include "yb/util/is_operation_done_result.h"
@@ -24,6 +25,8 @@
 DEFINE_RUNTIME_uint32(max_xcluster_streams_to_checkpoint_in_parallel, 200,
     "Maximum number of xCluster streams to checkpoint in parallel");
 
+DECLARE_bool(TEST_xcluster_enable_sequence_replication);
+
 using namespace std::placeholders;
 
 namespace yb::master {
@@ -77,6 +80,7 @@ XClusterOutboundReplicationGroup::XClusterOutboundReplicationGroup(
     : CatalogEntityWithTasks(std::move(tasks_tracker)),
       helper_functions_(std::move(helper_functions)),
       task_factory_(task_factory) {
+  automatic_ddl_mode_ = outbound_replication_group_pb.automatic_ddl_mode();
   outbound_rg_info_ = std::make_unique<XClusterOutboundReplicationGroupInfo>(replication_group_id);
   outbound_rg_info_->Load(outbound_replication_group_pb);
 }
@@ -263,7 +267,9 @@ Result<bool> XClusterOutboundReplicationGroup::MarkBootstrapTablesAsCheckpointed
       "Namespace in unexpected state");
 
   if (table_ids.empty()) {
-    auto table_infos = VERIFY_RESULT(helper_functions_.get_tables_func(namespace_id));
+    auto table_infos = VERIFY_RESULT(helper_functions_.get_tables_func(
+        namespace_id, /*include_sequences_data=*/(
+            AutomaticDDLMode() && FLAGS_TEST_xcluster_enable_sequence_replication)));
     std::set<TableId> tables;
     std::transform(
         table_infos.begin(), table_infos.end(), std::inserter(tables, tables.begin()),
@@ -342,7 +348,9 @@ Result<NamespaceName> XClusterOutboundReplicationGroup::GetNamespaceName(
 Result<XClusterOutboundReplicationGroup::NamespaceInfoPB>
 XClusterOutboundReplicationGroup::CreateNamespaceInfo(
     const NamespaceId& namespace_id, const LeaderEpoch& epoch) {
-  auto table_infos = VERIFY_RESULT(helper_functions_.get_tables_func(namespace_id));
+  auto table_infos = VERIFY_RESULT(helper_functions_.get_tables_func(
+      namespace_id, /*include_sequences_data=*/(
+          AutomaticDDLMode() && FLAGS_TEST_xcluster_enable_sequence_replication)));
   VLOG_WITH_PREFIX_AND_FUNC(1) << "Tables: " << yb::ToString(table_infos);
 
   SCHECK(
@@ -378,6 +386,23 @@ XClusterOutboundReplicationGroup::CreateNamespaceInfo(
   return ns_info;
 }
 
+Status XClusterOutboundReplicationGroup::AddTableToInitialBootstrapMapping(
+    const NamespaceId& namespace_id, const TableId& table_id, const LeaderEpoch& epoch) {
+  std::lock_guard mutex_lock(mutex_);
+  auto l = VERIFY_RESULT(LockForWrite());
+
+  auto* ns_info = VERIFY_RESULT(GetNamespaceInfo(namespace_id));
+  if (ns_info->mutable_table_infos()->count(table_id) > 0) {
+    return Status::OK();
+  }
+  SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB::TableInfoPB table_info;
+  table_info.set_is_checkpointing(true);
+  table_info.set_is_part_of_initial_bootstrap(true);
+  ns_info->mutable_table_infos()->insert({table_id, std::move(table_info)});
+
+  return Upsert(l, epoch);
+}
+
 Result<bool> XClusterOutboundReplicationGroup::AddNamespaceInternal(
     const NamespaceId& namespace_id, XClusterOutboundReplicationGroupInfo::WriteLock& l,
     const LeaderEpoch& epoch) {
@@ -576,7 +601,9 @@ XClusterOutboundReplicationGroup::GetNamespaceCheckpointInfo(
   NamespaceCheckpointInfo ns_info;
   ns_info.initial_bootstrap_required = namespace_info->initial_bootstrap_required();
 
-  auto all_tables = VERIFY_RESULT(helper_functions_.get_tables_func(namespace_id));
+  auto all_tables = VERIFY_RESULT(helper_functions_.get_tables_func(
+      namespace_id, /*include_sequences_data=*/(
+          AutomaticDDLMode() && FLAGS_TEST_xcluster_enable_sequence_replication)));
   std::vector<scoped_refptr<TableInfo>> table_infos;
 
   if (!table_names.empty()) {
@@ -1147,10 +1174,8 @@ Result<std::string> XClusterOutboundReplicationGroup::GetStreamId(
   return table_info->stream_id();
 }
 
-Result<bool> XClusterOutboundReplicationGroup::AutomaticDDLMode() const {
-  SharedLock mutex_lock(mutex_);
-  auto l = VERIFY_RESULT(LockForRead());
-  return l->pb.automatic_ddl_mode();
+bool XClusterOutboundReplicationGroup::AutomaticDDLMode() const {
+  return automatic_ddl_mode_;
 }
 
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.h b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
index 62c46b1ecd..bfd0459048 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.h
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
@@ -13,13 +13,13 @@
 
 #pragma once
 
-#include "yb/master/xcluster/master_xcluster_types.h"
-#include "yb/master/xcluster/xcluster_catalog_entity.h"
-
 #include "yb/cdc/xcluster_types.h"
 
 #include "yb/gutil/thread_annotations.h"
 
+#include "yb/master/xcluster/master_xcluster_types.h"
+#include "yb/master/xcluster/xcluster_catalog_entity.h"
+
 namespace yb {
 
 class IsOperationDoneResult;
@@ -37,9 +37,12 @@ class XClusterOutboundReplicationGroup
       public CatalogEntityWithTasks {
  public:
   struct HelperFunctions {
+    const std::function<Status()> create_sequences_data_table_func;
     const std::function<Result<scoped_refptr<NamespaceInfo>>(const NamespaceIdentifierPB&)>
         get_namespace_func;
-    const std::function<Result<std::vector<TableInfoPtr>>(const NamespaceId&)> get_tables_func;
+    const std::function<Result<std::vector<TableInfoPtr>>(
+        const NamespaceId&, bool include_sequences_data)>
+        get_tables_func;
     const std::function<Result<std::unique_ptr<XClusterCreateStreamsContext>>(
         const std::vector<TableId>&, const LeaderEpoch&)>
         create_xcluster_streams_func;
@@ -138,7 +141,7 @@ class XClusterOutboundReplicationGroup
   Result<std::string> GetStreamId(const NamespaceId& namespace_id, const TableId& table_id) const
       EXCLUDES(mutex_);
 
-  Result<bool> AutomaticDDLMode() const EXCLUDES(mutex_);
+  bool AutomaticDDLMode() const;
 
  private:
   friend class XClusterOutboundReplicationGroupMocked;
@@ -185,6 +188,10 @@ class XClusterOutboundReplicationGroup
   Result<NamespaceInfoPB> CreateNamespaceInfo(
       const NamespaceId& namespace_id, const LeaderEpoch& epoch) REQUIRES(mutex_);
 
+  Status AddTableToInitialBootstrapMapping(
+      const NamespaceId& namespace_id, const TableId& table_id, const LeaderEpoch& epoch)
+      EXCLUDES(mutex_);
+
   // Returns the NamespaceInfoPB for the given namespace_id. If its not found returns a NotFound
   // status. Caller must hold the WriteLock.
   Result<NamespaceInfoPB*> GetNamespaceInfo(const NamespaceId& namespace_id) REQUIRES(mutex_);
@@ -251,6 +258,8 @@ class XClusterOutboundReplicationGroup
 
   XClusterOutboundReplicationGroupTaskFactory& task_factory_;
 
+  bool automatic_ddl_mode_;
+
   DISALLOW_COPY_AND_ASSIGN(XClusterOutboundReplicationGroup);
 };
 
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
index fc95c4902c..c090980a10 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
@@ -19,6 +19,8 @@
 DEFINE_test_flag(bool, block_xcluster_checkpoint_namespace_task, false,
     "When enabled XClusterCheckpointNamespaceTask will be blocked");
 
+DECLARE_bool(TEST_xcluster_enable_sequence_replication);
+
 using namespace std::placeholders;
 
 namespace yb::master {
@@ -63,6 +65,21 @@ std::string XClusterCheckpointNamespaceTask::description() const {
 }
 
 Status XClusterCheckpointNamespaceTask::FirstStep() {
+  if (outbound_replication_group_.AutomaticDDLMode() &&
+      FLAGS_TEST_xcluster_enable_sequence_replication) {
+    // Ensure sequences_data table has been created and added to our tables to checkpoint.
+    // TODO: Consider making this async  so we don't have to burn a thread waiting.
+    RETURN_NOT_OK(outbound_replication_group_.helper_functions_.create_sequences_data_table_func());
+    RETURN_NOT_OK(outbound_replication_group_.AddTableToInitialBootstrapMapping(
+        namespace_id_, kPgSequencesDataTableId, epoch_));
+  }
+
+  ScheduleNextStep(
+      std::bind(&XClusterCheckpointNamespaceTask::CreateStreams, this), "CreateStreams");
+  return Status::OK();
+}
+
+Status XClusterCheckpointNamespaceTask::CreateStreams() {
   RETURN_NOT_OK(
       outbound_replication_group_.CreateStreamsForInitialBootstrap(namespace_id_, epoch_));
   ScheduleNextStep(
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.h b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.h
index c74d83bc00..9ced3b6efc 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.h
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.h
@@ -45,6 +45,7 @@ class XClusterCheckpointNamespaceTask : public MultiStepCatalogEntityTask {
   Status FirstStep() override;
 
  private:
+  Status CreateStreams();
   Status CheckpointStreams();
   void CheckpointStreamsCallback(XClusterCheckpointStreamsResult result);
   Status MarkTablesAsCheckpointed(XClusterCheckpointStreamsResult result);
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index 96b6b3e2c6..61391bb02e 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -17,24 +17,29 @@
 #include "yb/cdc/cdc_service.proxy.h"
 #include "yb/cdc/cdc_state_table.h"
 #include "yb/cdc/xcluster_types.h"
+
 #include "yb/client/xcluster_client.h"
 #include "yb/common/xcluster_util.h"
+
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master.h"
-#include "yb/master/xcluster/master_xcluster_util.h"
-#include "yb/master/xcluster/xcluster_status.h"
-#include "yb/util/is_operation_done_result.h"
 #include "yb/master/xcluster/add_table_to_xcluster_source_task.h"
+#include "yb/master/xcluster/master_xcluster_util.h"
 #include "yb/master/xcluster/xcluster_catalog_entity.h"
 #include "yb/master/xcluster/xcluster_outbound_replication_group.h"
 #include "yb/master/xcluster/xcluster_outbound_replication_group_tasks.h"
+#include "yb/master/xcluster/xcluster_status.h"
+
+#include "yb/tserver/pg_create_table.h"
 
+#include "yb/util/is_operation_done_result.h"
 #include "yb/util/scope_exit.h"
 
 DEFINE_RUNTIME_bool(enable_tablet_split_of_xcluster_bootstrapping_tables, false,
     "When set, it enables automatic tablet splitting for tables that are part of an "
     "xCluster replication setup and are currently being bootstrapped for xCluster.");
 
+DECLARE_int32(master_yb_client_default_timeout_ms);
 DECLARE_uint32(cdc_wal_retention_time_secs);
 DECLARE_bool(TEST_disable_cdc_state_insert_on_setup);
 
@@ -185,13 +190,22 @@ XClusterSourceManager::InitOutboundReplicationGroup(
     const xcluster::ReplicationGroupId& replication_group_id,
     const SysXClusterOutboundReplicationGroupEntryPB& metadata) {
   XClusterOutboundReplicationGroup::HelperFunctions helper_functions = {
+      .create_sequences_data_table_func =
+          [client = master_.client_future()]() {
+            return tserver::CreateSequencesDataTable(
+                client.get(),
+                CoarseMonoClock::now() +
+                    MonoDelta::FromMilliseconds(FLAGS_master_yb_client_default_timeout_ms));
+          },
       .get_namespace_func =
           [&catalog_manager = catalog_manager_](const NamespaceIdentifierPB& ns_identifier) {
             return catalog_manager.FindNamespace(ns_identifier);
           },
       .get_tables_func =
-          [&catalog_manager = catalog_manager_](const NamespaceId& namespace_id) {
-            return GetTablesEligibleForXClusterReplication(catalog_manager, namespace_id);
+          [&catalog_manager = catalog_manager_](
+              const NamespaceId& namespace_id, bool include_sequences_data) {
+            return GetTablesEligibleForXClusterReplication(
+                catalog_manager, namespace_id, include_sequences_data);
           },
       .create_xcluster_streams_func =
           std::bind(&XClusterSourceManager::CreateStreamsForDbScoped, this, _1, _2),
@@ -1158,7 +1172,7 @@ XClusterSourceManager::GetXClusterOutboundReplicationGroupInfo(
     }
     result.namespace_table_map[namespace_id] = std::move(ns_info);
   }
-  result.automatic_ddl_mode = VERIFY_RESULT(outbound_replication_group->AutomaticDDLMode());
+  result.automatic_ddl_mode = outbound_replication_group->AutomaticDDLMode();
 
   return result;
 }
