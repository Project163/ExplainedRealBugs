diff --git a/src/yb/cdc/xcluster_producer.cc b/src/yb/cdc/xcluster_producer.cc
index a300a8d3a5..999c9087b9 100644
--- a/src/yb/cdc/xcluster_producer.cc
+++ b/src/yb/cdc/xcluster_producer.cc
@@ -14,16 +14,15 @@
 #include "yb/cdc/xrepl_stream_metadata.h"
 
 #include "yb/cdc/cdc_service.pb.h"
-#include "yb/common/schema.h"
 #include "yb/common/transaction.h"
 #include "yb/common/wire_protocol.h"
 
 #include "yb/consensus/consensus.messages.h"
+#include "yb/consensus/log_cache.h"
 #include "yb/consensus/raft_consensus.h"
 #include "yb/consensus/replicate_msgs_holder.h"
 
 #include "yb/dockv/doc_key.h"
-#include "yb/docdb/docdb.pb.h"
 #include "yb/dockv/primitive_value.h"
 #include "yb/dockv/value.h"
 #include "yb/dockv/value_type.h"
@@ -35,11 +34,7 @@
 #include "yb/tablet/tablet_peer.h"
 #include "yb/tablet/transaction_participant.h"
 
-#include "yb/tserver/tablet_server.h"
-#include "yb/tserver/ts_tablet_manager.h"
-
 #include "yb/util/flags.h"
-#include "yb/util/logging.h"
 #include "yb/gutil/stl_util.h"
 
 DEPRECATE_FLAG(int32, cdc_transaction_timeout_ms, "05_2021");
@@ -68,34 +63,12 @@ using dockv::PrimitiveValue;
 using tablet::TransactionParticipant;
 
 namespace {
-template <typename Value>
-void AddColumnToMap(
-    const ColumnSchema& col_schema, const Value& col, cdc::KeyValuePairPB* kv_pair) {
-  kv_pair->set_key(col_schema.name());
-  col.ToQLValuePB(col_schema.type(), kv_pair->mutable_value());
-}
-
-void AddPrimaryKey(
-    const dockv::SubDocKey& decoded_key, const Schema& tablet_schema, CDCRecordPB* record) {
-  size_t i = 0;
-  for (const auto& col : decoded_key.doc_key().hashed_group()) {
-    AddColumnToMap(tablet_schema.column(i), col, record->add_key());
-    i++;
-  }
-  for (const auto& col : decoded_key.doc_key().range_group()) {
-    AddColumnToMap(tablet_schema.column(i), col, record->add_key());
-    i++;
-  }
-}
 
 Status PopulateWriteRecord(
-    const consensus::LWReplicateMsg& msg,
-    const StreamMetadata& metadata,
-    const std::shared_ptr<tablet::TabletPeer>& tablet_peer,
+    const consensus::LWReplicateMsg& msg, const std::shared_ptr<tablet::TabletPeer>& tablet_peer,
     GetChangesResponsePB* resp) {
   const auto& batch = msg.write().write_batch();
   auto tablet = VERIFY_RESULT(tablet_peer->shared_tablet_safe());
-  const auto& schema = *tablet->schema();
   // Write batch may contain records from different rows.
   // For xCluster, we need to split the batch into 1 CDC record per row of the table.
   // We'll use DocDB key hash to identify the records that belong to the same row.
@@ -120,21 +93,17 @@ Status PopulateWriteRecord(
       dockv::SubDocKey decoded_key;
       RETURN_NOT_OK(decoded_key.DecodeFrom(&sub_doc_key, dockv::HybridTimeRequired::kFalse));
 
-      if (metadata.GetRecordFormat() == CDCRecordFormat::WAL) {
-        // For xCluster, populate serialized data from WAL, to avoid unnecessary deserializing on
-        // producer and re-serializing on consumer.
-        auto kv_pair = record->add_key();
-        if (decoded_key.doc_key().has_hash()) {
-          // TODO: is there another way of getting this? Perhaps using kUpToHashOrFirstRange?
-          kv_pair->set_key(
-              dockv::PartitionSchema::EncodeMultiColumnHashValue(decoded_key.doc_key().hash()));
-        } else {
-          kv_pair->set_key(decoded_key.doc_key().Encode().ToStringBuffer());
-        }
-        kv_pair->mutable_value()->set_binary_value(write_pair.key().ToBuffer());
+      // For xCluster, populate serialized data from WAL, to avoid unnecessary deserializing on
+      // producer and re-serializing on consumer.
+      auto kv_pair = record->add_key();
+      if (decoded_key.doc_key().has_hash()) {
+        // TODO: is there another way of getting this? Perhaps using kUpToHashOrFirstRange?
+        kv_pair->set_key(
+            dockv::PartitionSchema::EncodeMultiColumnHashValue(decoded_key.doc_key().hash()));
       } else {
-        AddPrimaryKey(decoded_key, schema, record);
+        kv_pair->set_key(decoded_key.doc_key().Encode().ToStringBuffer());
       }
+      kv_pair->mutable_value()->set_binary_value(write_pair.key().ToBuffer());
 
       // Check whether operation is WRITE or DELETE.
       if (value_type == dockv::ValueEntryType::kTombstone && decoded_key.num_subkeys() == 0) {
@@ -158,24 +127,9 @@ Status PopulateWriteRecord(
     prev_key = primary_key;
     DCHECK(record);
 
-    if (metadata.GetRecordFormat() == CDCRecordFormat::WAL) {
-      auto kv_pair = record->add_changes();
-      kv_pair->set_key(write_pair.key().ToBuffer());
-      kv_pair->mutable_value()->set_binary_value(write_pair.value().ToBuffer());
-    } else if (record->operation() == CDCRecordPB_OperationType_WRITE) {
-      dockv::KeyEntryValue column_id;
-      Slice key_column = write_pair.key().WithoutPrefix(key_size);
-      RETURN_NOT_OK(column_id.DecodeFromKey(&key_column));
-      if (column_id.type() == dockv::KeyEntryType::kColumnId) {
-        dockv::Value decoded_value;
-        RETURN_NOT_OK(decoded_value.Decode(write_pair.value()));
-
-        const ColumnSchema& col = VERIFY_RESULT(schema.column_by_id(column_id.GetColumnId()));
-        AddColumnToMap(col, decoded_value.primitive_value(), record->add_changes());
-      } else if (column_id.type() != dockv::KeyEntryType::kSystemColumnId) {
-        LOG(DFATAL) << "Unexpected value type in key: " << column_id.type();
-      }
-    }
+    auto kv_pair = record->add_changes();
+    kv_pair->set_key(write_pair.key().ToBuffer());
+    kv_pair->mutable_value()->set_binary_value(write_pair.value().ToBuffer());
   }
   return Status::OK();
 }
@@ -297,6 +251,10 @@ Status GetChangesForXCluster(
     GetChangesResponsePB* resp,
     int64_t* last_readable_opid_index) {
   SCHECK(tablet_peer, NotFound, Format("Tablet id $0 not found", tablet_id));
+  RSTATUS_DCHECK_EQ(
+      stream_metadata->GetRecordFormat(), CDCRecordFormat::WAL, IllegalState,
+      "xCluster only supports WAL record format");
+
   auto tablet = VERIFY_RESULT(tablet_peer->shared_tablet_safe());
 
   auto leader_safe_time = VERIFY_RESULT(tablet_peer->LeaderSafeTime());
@@ -383,7 +341,7 @@ Status GetChangesForXCluster(
         RETURN_NOT_OK(PopulateTransactionRecord(msg, tablet_peer, resp));
         break;
       case consensus::OperationType::WRITE_OP:
-        RETURN_NOT_OK(PopulateWriteRecord(msg, *stream_metadata, tablet_peer, resp));
+        RETURN_NOT_OK(PopulateWriteRecord(msg, tablet_peer, resp));
         break;
       case consensus::OperationType::SPLIT_OP:
         RETURN_NOT_OK(
diff --git a/src/yb/integration-tests/cdcsdk_ysql-test.cc b/src/yb/integration-tests/cdcsdk_ysql-test.cc
index bd9ce3db04..6e1bcb5bca 100644
--- a/src/yb/integration-tests/cdcsdk_ysql-test.cc
+++ b/src/yb/integration-tests/cdcsdk_ysql-test.cc
@@ -2849,24 +2849,19 @@ TEST_F(CDCSDKYsqlTest, YB_DISABLE_TEST_IN_TSAN(TestXClusterLogGCedWithTabletBoot
   ASSERT_OK(test_client()->GetTablets(table, 0, &tablets, /* partition_list_version=*/nullptr));
   ASSERT_EQ(tablets.size(), num_tablets);
 
-  RpcController rpc;
-  CreateCDCStreamRequestPB create_req;
-  CreateCDCStreamResponsePB create_resp;
-  create_req.set_table_id(table_id);
-  create_req.set_source_type(XCLUSTER);
-  ASSERT_OK(cdc_proxy_->CreateCDCStream(create_req, &create_resp, &rpc));
+  auto stream_id = ASSERT_RESULT(cdc::CreateCDCStream(cdc_proxy_, table_id));
 
   // Insert some records.
   ASSERT_OK(WriteRows(0 /* start */, 100 /* end */, &test_cluster_));
-  rpc.Reset();
 
   GetChangesRequestPB change_req;
   GetChangesResponsePB change_resp_1;
-  change_req.set_stream_id(create_resp.stream_id());
+  change_req.set_stream_id(stream_id.ToString());
   change_req.set_tablet_id(tablets[0].tablet_id());
   change_req.mutable_from_checkpoint()->mutable_op_id()->set_index(0);
   change_req.mutable_from_checkpoint()->mutable_op_id()->set_term(0);
   change_req.set_serve_as_proxy(true);
+  RpcController rpc;
   rpc.set_timeout(MonoDelta::FromSeconds(kRpcTimeout));
   ASSERT_OK(cdc_proxy_->GetChanges(change_req, &change_resp_1, &rpc));
   ASSERT_FALSE(change_resp_1.has_error());
@@ -2896,7 +2891,7 @@ TEST_F(CDCSDKYsqlTest, YB_DISABLE_TEST_IN_TSAN(TestXClusterLogGCedWithTabletBoot
 
   GetChangesResponsePB change_resp_2;
   rpc.Reset();
-  change_req.set_stream_id(create_resp.stream_id());
+  change_req.set_stream_id(stream_id.ToString());
   change_req.set_tablet_id(tablets[0].tablet_id());
   change_req.mutable_from_checkpoint()->mutable_op_id()->set_index(
       0);
diff --git a/src/yb/tools/yb-admin-xcluster-test.cc b/src/yb/tools/yb-admin-xcluster-test.cc
index 209885f62f..2a46e49b88 100644
--- a/src/yb/tools/yb-admin-xcluster-test.cc
+++ b/src/yb/tools/yb-admin-xcluster-test.cc
@@ -899,16 +899,6 @@ TEST_F(XClusterAdminCliTest, TestDeleteCDCStreamWithBootstrap) {
   ASSERT_OK(RunAdminToolCommand("delete_universe_replication", kProducerClusterId));
 }
 
-TEST_F(XClusterAdminCliTest, TestDeleteCDCStreamWithCreateCDCStream) {
-  // Create CDC stream
-  ASSERT_OK(RunAdminToolCommand("create_cdc_stream", table_->id()));
-
-  string stream_id = ASSERT_RESULT(GetRecentStreamId(cluster_.get()));
-
-  // Should be deleted.
-  ASSERT_OK(RunAdminToolCommand("delete_cdc_stream", stream_id));
-}
-
 TEST_F(XClusterAdminCliTest, TestFailedSetupUniverseWithDeletion) {
   client::TableHandle producer_cluster_table;
 
diff --git a/src/yb/tools/yb-admin_cli.cc b/src/yb/tools/yb-admin_cli.cc
index d0fa5e32f3..963b55e257 100644
--- a/src/yb/tools/yb-admin_cli.cc
+++ b/src/yb/tools/yb-admin_cli.cc
@@ -1801,19 +1801,6 @@ Status write_universe_key_to_file_action(
   return Status::OK();
 }
 
-const auto create_cdc_stream_args = "<table_id>";
-Status create_cdc_stream_action(
-    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
-  if (args.size() < 1) {
-    return ClusterAdminCli::kInvalidArguments;
-  }
-  const string table_id = args[0];
-  RETURN_NOT_OK_PREPEND(
-      client->CreateCDCStream(table_id),
-      Format("Unable to create CDC stream for table $0", table_id));
-  return Status::OK();
-}
-
 const auto create_change_data_stream_args =
    "<namespace> [<checkpoint_type>] [<record_type>] [<consistent_snapshot_option>]";
 Status create_change_data_stream_action(
@@ -2622,27 +2609,29 @@ void ClusterAdminCli::RegisterCommandHandlers() {
   REGISTER_COMMAND(rotate_universe_key_in_memory);
   REGISTER_COMMAND(disable_encryption_in_memory);
   REGISTER_COMMAND(write_universe_key_to_file);
-  // CDC commands
-  REGISTER_COMMAND(create_cdc_stream);
+  // CDCSDK commands
   REGISTER_COMMAND(create_change_data_stream);
-  REGISTER_COMMAND(delete_cdc_stream);
   REGISTER_COMMAND(delete_change_data_stream);
-  REGISTER_COMMAND(list_cdc_streams);
   REGISTER_COMMAND(list_change_data_streams);
   REGISTER_COMMAND(get_change_data_stream_info);
   REGISTER_COMMAND(ysql_backfill_change_data_stream_with_replication_slot);
-  // xCluster commands
+  // xCluster Source commands
+  REGISTER_COMMAND(bootstrap_cdc_producer);
+  REGISTER_COMMAND(list_cdc_streams);
+  REGISTER_COMMAND(delete_cdc_stream);
+  REGISTER_COMMAND(pause_producer_xcluster_streams);
+  REGISTER_COMMAND(wait_for_replication_drain);
+  // xCluster Target commands
   REGISTER_COMMAND(setup_universe_replication);
   REGISTER_COMMAND(delete_universe_replication);
   REGISTER_COMMAND(alter_universe_replication);
-  REGISTER_COMMAND(change_xcluster_role);
-  REGISTER_COMMAND(set_universe_replication_enabled);
-  REGISTER_COMMAND(pause_producer_xcluster_streams);
-  REGISTER_COMMAND(bootstrap_cdc_producer);
-  REGISTER_COMMAND(wait_for_replication_drain);
   REGISTER_COMMAND(setup_namespace_universe_replication);
+  REGISTER_COMMAND(set_universe_replication_enabled);
   REGISTER_COMMAND(get_replication_status);
   REGISTER_COMMAND(get_xcluster_safe_time);
+  // xCluster common commands
+  REGISTER_COMMAND(change_xcluster_role);
+
   // xCluster V2 commands
   REGISTER_COMMAND(create_xcluster_checkpoint);
   REGISTER_COMMAND(is_xcluster_bootstrap_required);
diff --git a/src/yb/tools/yb-admin_client.cc b/src/yb/tools/yb-admin_client.cc
index 4b3ffbad78..5b108e8b90 100644
--- a/src/yb/tools/yb-admin_client.cc
+++ b/src/yb/tools/yb-admin_client.cc
@@ -3852,37 +3852,6 @@ Status ClusterAdminClient::CreateCDCSDKDBStream(
   return Status::OK();
 }
 
-Status ClusterAdminClient::CreateCDCStream(const TableId& table_id) {
-  master::CreateCDCStreamRequestPB req;
-  master::CreateCDCStreamResponsePB resp;
-  req.set_table_id(table_id);
-  req.mutable_options()->Reserve(3);
-
-  auto record_type_option = req.add_options();
-  record_type_option->set_key(cdc::kRecordType);
-  record_type_option->set_value(CDCRecordType_Name(cdc::CDCRecordType::CHANGE));
-
-  auto record_format_option = req.add_options();
-  record_format_option->set_key(cdc::kRecordFormat);
-  record_format_option->set_value(CDCRecordFormat_Name(cdc::CDCRecordFormat::JSON));
-
-  auto source_type_option = req.add_options();
-  source_type_option->set_key(cdc::kSourceType);
-  source_type_option->set_value(CDCRequestSource_Name(cdc::CDCRequestSource::XCLUSTER));
-
-  RpcController rpc;
-  rpc.set_timeout(timeout_);
-  RETURN_NOT_OK(master_replication_proxy_->CreateCDCStream(req, &resp, &rpc));
-
-  if (resp.has_error()) {
-        cout << "Error creating stream: " << resp.error().status().message() << endl;
-        return StatusFromPB(resp.error().status());
-  }
-
-  cout << "CDC Stream ID: " << resp.stream_id() << endl;
-  return Status::OK();
-}
-
 Status ClusterAdminClient::DeleteCDCSDKDBStream(const std::string& db_stream_id) {
   master::DeleteCDCStreamRequestPB req;
   master::DeleteCDCStreamResponsePB resp;
diff --git a/src/yb/tools/yb-admin_client.h b/src/yb/tools/yb-admin_client.h
index 899d9a4c7b..508eade660 100644
--- a/src/yb/tools/yb-admin_client.h
+++ b/src/yb/tools/yb-admin_client.h
@@ -390,8 +390,6 @@ class ClusterAdminClient {
 
   Status WriteUniverseKeyToFile(const std::string& key_id, const std::string& file_name);
 
-  Status CreateCDCStream(const TableId& table_id);
-
   Status CreateCDCSDKDBStream(
       const TypedNamespaceName& ns, const std::string& CheckPointType,
       const cdc::CDCRecordType RecordType,
