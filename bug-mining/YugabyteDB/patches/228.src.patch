diff --git a/src/postgres/src/backend/catalog/pg_enum.c b/src/postgres/src/backend/catalog/pg_enum.c
index efde34964a..ce54a9f833 100644
--- a/src/postgres/src/backend/catalog/pg_enum.c
+++ b/src/postgres/src/backend/catalog/pg_enum.c
@@ -33,6 +33,7 @@
 #include "utils/syscache.h"
 
 /*  YB includes. */
+#include "catalog/yb_oid_assignment.h"
 #include "pg_yb_utils.h"
 
 /* Potentially set by pg_upgrade_support functions */
@@ -83,35 +84,48 @@ EnumValuesCreate(Oid enumTypeOid, List *vals)
 
 	pg_enum = table_open(EnumRelationId, RowExclusiveLock);
 
-	/*
-	 * Allocate OIDs for the enum's members.
-	 *
-	 * While this method does not absolutely guarantee that we generate no
-	 * duplicate OIDs (since we haven't entered each oid into the table before
-	 * allocating the next), trouble could only occur if the OID counter wraps
-	 * all the way around before we finish. Which seems unlikely.
-	 */
 	oids = (Oid *) palloc(num_elems * sizeof(Oid));
 
-	for (elemno = 0; elemno < num_elems; elemno++)
+	if (YbUsingEnumLabelOidAssignment())
+	{
+		elemno = 0;
+		foreach(lc, vals)
+		{
+			char *label = strVal(lfirst(lc));
+			oids[elemno] = YbLookupOidAssignmentForEnumLabel(enumTypeOid, label);
+			elemno++;
+		}
+	}
+	else
 	{
 		/*
-		 * We assign even-numbered OIDs to all the new enum labels.  This
-		 * tells the comparison functions the OIDs are in the correct sort
-		 * order and can be compared directly.
+		 * Allocate OIDs for the enum's members.
+		 *
+		 * While this method does not absolutely guarantee that we generate no
+		 * duplicate OIDs (since we haven't entered each oid into the table before
+		 * allocating the next), trouble could only occur if the OID counter wraps
+		 * all the way around before we finish. Which seems unlikely.
 		 */
-		Oid			new_oid;
-
-		do
+		for (elemno = 0; elemno < num_elems; elemno++)
 		{
-			new_oid = GetNewOidWithIndex(pg_enum, EnumOidIndexId,
-										 Anum_pg_enum_oid);
-		} while (new_oid & 1);
-		oids[elemno] = new_oid;
-	}
+			/*
+			 * We assign even-numbered OIDs to all the new enum labels.  This
+			 * tells the comparison functions the OIDs are in the correct sort
+			 * order and can be compared directly.
+			 */
+			Oid			new_oid;
 
-	/* sort them, just in case OID counter wrapped from high to low */
-	qsort(oids, num_elems, sizeof(Oid), oid_cmp);
+			do
+			{
+				new_oid = GetNewOidWithIndex(pg_enum, EnumOidIndexId,
+											 Anum_pg_enum_oid);
+			} while (new_oid & 1);
+			oids[elemno] = new_oid;
+		}
+
+		/* sort them, just in case OID counter wrapped from high to low */
+		qsort(oids, num_elems, sizeof(Oid), oid_cmp);
+	}
 
 	/* and make the entries */
 	memset(nulls, false, sizeof(nulls));
@@ -394,6 +408,8 @@ restart:
 		newOid = binary_upgrade_next_pg_enum_oid;
 		binary_upgrade_next_pg_enum_oid = InvalidOid;
 	}
+	else if (YbUsingEnumLabelOidAssignment())
+		newOid = YbLookupOidAssignmentForEnumLabel(enumTypeOid, newVal);
 	else
 	{
 		/*
diff --git a/src/postgres/src/backend/catalog/yb_catalog/Makefile b/src/postgres/src/backend/catalog/yb_catalog/Makefile
index fdbe52e443..030c0bcc81 100644
--- a/src/postgres/src/backend/catalog/yb_catalog/Makefile
+++ b/src/postgres/src/backend/catalog/yb_catalog/Makefile
@@ -12,6 +12,6 @@ subdir = src/backend/catalog/yb_catalog
 top_builddir = ../../../..
 include $(top_builddir)/src/Makefile.global
 
-OBJS = yb_type.o yb_catalog_version.o
+OBJS = yb_type.o yb_catalog_version.o yb_oid_assignment.o
 
 include $(top_srcdir)/src/backend/common.mk
diff --git a/src/postgres/src/backend/catalog/yb_catalog/yb_oid_assignment.c b/src/postgres/src/backend/catalog/yb_catalog/yb_oid_assignment.c
new file mode 100644
index 0000000000..3c5fbcd38a
--- /dev/null
+++ b/src/postgres/src/backend/catalog/yb_catalog/yb_oid_assignment.c
@@ -0,0 +1,225 @@
+/*--------------------------------------------------------------------------------------------------
+ *
+ * yb_oid_assignment.c
+ *        Functions for controlling assigning OIDs in xCluster target universes.
+ *
+ * Copyright (c) YugabyteDB, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied.  See the License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ * IDENTIFICATION
+ *        src/backend/catalog/yb_catalog/yb_oid_assignment.c
+ *
+ *--------------------------------------------------------------------------------------------------
+ */
+
+
+#include "postgres.h"
+
+#include "utils/builtins.h"
+#include "utils/hsearch.h"
+#include "utils/jsonfuncs.h"
+
+
+static HTAB *yb_enum_label_assignment_map = NULL;
+static bool yb_enum_label_assignment_exists = false;
+
+/*
+ * yb_enum_label_assignment_map key format is <oid>.<label>\0
+ * Oid's are uint_32_t so take up at most 10 decimal digits.
+ * <label>\0 is guaranteed to fit in NAMEDATALEN characters.
+ */
+#define YB_ENUM_LABEL_ASSIGNMENT_MAP_KEY_SIZE (10 + 1 + NAMEDATALEN)
+
+typedef struct YbEnumLabelAssignmentMapEntry {
+	/* encodes enum_oid, label */
+	char key[YB_ENUM_LABEL_ASSIGNMENT_MAP_KEY_SIZE];
+	Oid label_oid;
+} YbEnumLabelAssignmentMapEntry;
+
+static void
+YbClearEnumLabelMap(void)
+{
+	HASHCTL ctl;
+
+	if (yb_enum_label_assignment_map != NULL)
+		hash_destroy(yb_enum_label_assignment_map);
+	memset(&ctl, 0, sizeof(ctl));
+	ctl.keysize = YB_ENUM_LABEL_ASSIGNMENT_MAP_KEY_SIZE;
+	ctl.entrysize = sizeof(YbEnumLabelAssignmentMapEntry);
+	yb_enum_label_assignment_map = hash_create("YB enum label map",
+											   /*initial size*/ 20, &ctl,
+											   HASH_ELEM | HASH_STRINGS);
+}
+
+static void
+YbCreateEnumLabelMapKey(Oid enum_oid, const char *label, char *key_buffer)
+{
+	/*
+	 * For now ignore enum OID field.  See YbLookupOidAssignmentForEnumLabel
+	 * for why.
+	 */
+	enum_oid = 42;
+
+	int written_bytes = snprintf(key_buffer,
+								 YB_ENUM_LABEL_ASSIGNMENT_MAP_KEY_SIZE, "%u.%s",
+								 enum_oid, label);
+	if (written_bytes >= YB_ENUM_LABEL_ASSIGNMENT_MAP_KEY_SIZE)
+		elog(ERROR,
+			 "unexpectedly large OID/label size in OID assignment (OID %u, "
+			 "label '%s')",
+			 enum_oid, label);
+}
+
+static void
+YbInsertEnumLabel(Oid enum_oid, const char *label, Oid label_oid)
+{
+	char key[YB_ENUM_LABEL_ASSIGNMENT_MAP_KEY_SIZE];
+	YbCreateEnumLabelMapKey(enum_oid, label, key);
+
+	bool found;
+	YbEnumLabelAssignmentMapEntry *entry =
+		hash_search(yb_enum_label_assignment_map, key, HASH_ENTER, &found);
+	if (!found)
+		entry->label_oid = label_oid;
+	else if (entry->label_oid != label_oid)
+		elog(ERROR,
+			 "attempt to provide multiple OIDs for enum label %u.%s: %u vs "
+			 "%u",
+			 enum_oid, label, entry->label_oid, label_oid);
+}
+
+/* Returns InvalidOid on not found. */
+static Oid
+YbLookupOidForEnumLabel(Oid enum_oid, const char *label)
+{
+	char key[YB_ENUM_LABEL_ASSIGNMENT_MAP_KEY_SIZE];
+	YbCreateEnumLabelMapKey(enum_oid, label, key);
+	bool found;
+	YbEnumLabelAssignmentMapEntry *entry =
+		hash_search(yb_enum_label_assignment_map, key, HASH_FIND, &found);
+	if (found)
+		return entry->label_oid;
+	return InvalidOid;
+}
+
+/* Returns InvalidOid on bad input. */
+static Oid
+YbGetOidFromText(const text *input)
+{
+	if (!input)
+		return InvalidOid;
+	const char *cstring = text_to_cstring(input);
+	char *end_ptr;
+	Oid result = strtoul(cstring, &end_ptr, 10);
+	if (result == 0 || result > UINT32_MAX || *end_ptr != '\0')
+		return InvalidOid;
+	return result;
+}
+
+PG_FUNCTION_INFO_V1(yb_xcluster_set_next_oid_assignments);
+
+/*
+ * New Yugabyte-specific Postgres function,
+ * pg_catalog.yb_xcluster_set_next_oid_assignments.
+ *
+ * It is used by xCluster to control the assignment of OIDs for some objects
+ * in the next DDL.  It is passed a JSON string with the assignment
+ * information.
+ *
+ * Example:
+ *    SELECT pg_catalog.yb_xcluster_set_next_oid_assignments(
+ *       '{"enum_label_info":['                                        ||
+ *            '{"label":"red","enum_oid":16405,"label_oid":16406},'    ||
+ *            '{"label":"orange","enum_oid":16405,"label_oid":16408}'  ||
+ *            ']}');
+ *
+ * This indicates that the label named red of the enum that has/will have OID
+ * 16405 should be assigned the OID 16406.  Likewise, the same enum's orange
+ * label should be assigned OID 16408.
+ *
+ * The enum_label_info key is optional; if it is present then all enum labels
+ * created until the assignment is changed are expected to be covered by the
+ * assignment.  In the example this means that if the DDL attempts to create a
+ * label blue then an error will occur.  It is not an error if the DDL does
+ * not create all the labels mentioned in the assignment.
+ *
+ *
+ * You can remove the current assignment if any by using
+ *
+ *     SELECT pg_catalog.yb_xcluster_set_next_oid_assignments('{}');
+ */
+
+Datum
+yb_xcluster_set_next_oid_assignments(PG_FUNCTION_ARGS)
+{
+	text *json_text = PG_GETARG_TEXT_P(0);
+
+	YbClearEnumLabelMap();
+	yb_enum_label_assignment_exists = false;
+
+	text *enum_label_info = json_get_value(json_text, "enum_label_info");
+	if (enum_label_info != NULL)
+	{
+		yb_enum_label_assignment_exists = true;
+		int length = get_json_array_length(enum_label_info);
+		for (int i = 0; i < length; i++)
+		{
+			text *label_info_entry = get_json_array_element(enum_label_info, i);
+			char *label = text_to_cstring(json_get_denormalized_value(label_info_entry, "label"));
+			text *label_oid_text = json_get_value(label_info_entry,
+												  "label_oid");
+			text *enum_oid_text = json_get_value(label_info_entry,
+												 "enum_oid");
+
+			Oid label_oid = YbGetOidFromText(label_oid_text);
+			Oid enum_oid = YbGetOidFromText(enum_oid_text);
+			if (label_oid == InvalidOid || enum_oid == InvalidOid)
+			{
+				elog(ERROR,
+					 "corrupted JSON passed to "
+					 "yb_xcluster_set_next_oid_assignments: '%s'",
+					 text_to_cstring(json_text));
+			}
+
+			YbInsertEnumLabel(enum_oid, label, label_oid);
+		}
+	}
+
+	PG_RETURN_VOID();
+}
+
+bool
+YbUsingEnumLabelOidAssignment(void)
+{
+	return yb_enum_label_assignment_exists;
+}
+
+Oid
+YbLookupOidAssignmentForEnumLabel(Oid enum_oid, const char *label)
+{
+	/*----------
+	 * Currently we do not ensure that enums have the same *pg_type*
+	 * OIDs.  We will fix that later, but in the meantime we take
+	 * advantage of the fact that we currently never have a
+	 * replicating DDL that refers to two different enums to ignore
+	 * the actual enum OID field when comparing labels.
+	 *
+	 * See YbCreateEnumLabelMapKey for the temporary code to ignore the enum
+	 * OID field.
+	 *----------
+	 */
+	Oid label_oid = YbLookupOidForEnumLabel(enum_oid, label);
+	if (label_oid == InvalidOid)
+		elog(ERROR, "no OID assignment for enum label %u.%s in OID assignment",
+			 enum_oid, label);
+	return label_oid;
+}
diff --git a/src/postgres/src/include/catalog/pg_proc.dat b/src/postgres/src/include/catalog/pg_proc.dat
index 072ab329a7..fbc5c2858a 100644
--- a/src/postgres/src/include/catalog/pg_proc.dat
+++ b/src/postgres/src/include/catalog/pg_proc.dat
@@ -12074,6 +12074,11 @@
   proparallel => 'r', prorettype => 'void', proargtypes => 'bool',
   prosrc => 'binary_upgrade_set_next_tablegroup_default' },
 
+{ oid => '8079', descr => 'private function used by xCluster to control OID assignment',
+  proname => 'yb_xcluster_set_next_oid_assignments', provolatile => 'v',
+  proparallel => 'r', prorettype => 'void', proargtypes => 'text',
+  prosrc => 'yb_xcluster_set_next_oid_assignments' },
+
 { oid => '8072',
   descr => 'Get metrics of all nodes',
   proname => 'yb_servers_metrics', prorows => '10',
diff --git a/src/postgres/src/include/catalog/pg_yb_migration.dat b/src/postgres/src/include/catalog/pg_yb_migration.dat
index 4a32b4efb3..3c813b8b42 100644
--- a/src/postgres/src/include/catalog/pg_yb_migration.dat
+++ b/src/postgres/src/include/catalog/pg_yb_migration.dat
@@ -12,7 +12,7 @@
 [
 
 # For better version control conflict detection, list latest migration filename
-# here: V65__24108__yb_lsn_type_in_pg_replication_slots.sql
-{ major => '65', minor => '0', name => '<baseline>', time_applied => '_null_' }
+# here: V66__24077__yb_support_oid_assignment.sql
+{ major => '66', minor => '0', name => '<baseline>', time_applied => '_null_' }
 
 ]
diff --git a/src/postgres/src/include/catalog/yb_oid_assignment.h b/src/postgres/src/include/catalog/yb_oid_assignment.h
new file mode 100644
index 0000000000..492262f6e9
--- /dev/null
+++ b/src/postgres/src/include/catalog/yb_oid_assignment.h
@@ -0,0 +1,31 @@
+/*--------------------------------------------------------------------------------------------------
+ *
+ * yb_oid_assignment.c
+ *    prototypes for yb_oid_assignment.c
+ *
+ * Copyright (c) YugabyteDB, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied.  See the License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ * src/include/catalog/yb_oid_assignment.h
+ *
+ *--------------------------------------------------------------------------------------------------
+ */
+
+#pragma once
+
+#include <stdbool.h>
+
+#include "postgres_ext.h"
+
+extern bool YbUsingEnumLabelOidAssignment(void);
+
+extern Oid YbLookupOidAssignmentForEnumLabel(Oid enum_oid, const char *label);
diff --git a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/source_ddl_end_handler.c b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/source_ddl_end_handler.c
index 6148157580..45b00f70c2 100644
--- a/src/postgres/yb-extensions/yb_xcluster_ddl_replication/source_ddl_end_handler.c
+++ b/src/postgres/yb-extensions/yb_xcluster_ddl_replication/source_ddl_end_handler.c
@@ -1,5 +1,4 @@
-/*-----------------------------------------------------------------------------
- * Copyright (c) YugabyteDB, Inc.
+/* Copyright (c) YugabyteDB, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not
  * use this file except in compliance with the License.  You may obtain a copy
@@ -55,6 +54,7 @@
 #include "tcop/cmdtag.h"
 #include "tcop/deparse_utility.h"
 #include "utils/jsonb.h"
+#include "utils/lsyscache.h"
 #include "utils/palloc.h"
 #include "utils/rel.h"
 
@@ -99,7 +99,6 @@ static List *rewritten_table_oid_list = NIL;
 	X(CMDTAG_CREATE_TEXT_SEARCH_PARSER) \
 	X(CMDTAG_CREATE_TEXT_SEARCH_TEMPLATE) \
 	X(CMDTAG_CREATE_TRIGGER) \
-	X(CMDTAG_CREATE_TYPE) \
 	X(CMDTAG_CREATE_USER_MAPPING) \
 	X(CMDTAG_CREATE_VIEW) \
 	X(CMDTAG_ALTER_AGGREGATE) \
@@ -122,7 +121,6 @@ static List *rewritten_table_oid_list = NIL;
 	X(CMDTAG_ALTER_TEXT_SEARCH_PARSER) \
 	X(CMDTAG_ALTER_TEXT_SEARCH_TEMPLATE) \
 	X(CMDTAG_ALTER_TRIGGER) \
-	X(CMDTAG_ALTER_TYPE) \
 	X(CMDTAG_ALTER_VIEW) \
 	X(CMDTAG_DROP_ACCESS_METHOD) \
 	X(CMDTAG_DROP_AGGREGATE) \
@@ -162,6 +160,13 @@ typedef struct YbNewRelMapEntry
 	char	   *rel_name;
 } YbNewRelMapEntry;
 
+typedef struct YbEnumLabelMapEntry
+{
+	Oid enum_oid;
+	Oid label_oid;
+	char *label_name;
+} YbEnumLabelMapEntry;
+
 Oid
 SPI_GetOid(HeapTuple spi_tuple, int column_id)
 {
@@ -174,7 +179,7 @@ SPI_GetOid(HeapTuple spi_tuple, int column_id)
 	return oid;
 }
 
-const char *
+char *
 SPI_GetText(HeapTuple spi_tuple, int column_id)
 {
 	return SPI_getvalue(spi_tuple, SPI_tuptable->tupdesc, column_id);
@@ -389,6 +394,36 @@ ShouldReplicateAlterReplication(Oid rel_oid)
 	return true;
 }
 
+static void
+GetEnumLabels(Oid enum_oid, List **enum_label_list)
+{
+	StringInfoData query;
+	initStringInfo(&query);
+	appendStringInfo(&query,
+					 "SELECT enumlabel, oid FROM pg_catalog.pg_enum WHERE "
+					 "enumtypid = %u",
+					 enum_oid);
+	int exec_result = SPI_execute(query.data, /* readonly */ true, /* tcount */ 0);
+	if (exec_result != SPI_OK_SELECT)
+		elog(ERROR, "SPI_exec failed (error %d): %s", exec_result, query.data);
+	pfree(query.data);
+
+	for (int i = 0; i < SPI_processed; i++)
+	{
+		HeapTuple tuple = SPI_tuptable->vals[i];
+		TupleDesc tupdesc = SPI_tuptable->tupdesc;
+
+		YbEnumLabelMapEntry *enum_label_entry =
+			palloc(sizeof(YbEnumLabelMapEntry));
+		enum_label_entry->enum_oid = enum_oid;
+		enum_label_entry->label_name =
+			SPI_GetText(tuple, SPI_fnumber(tupdesc, "enumlabel"));
+		enum_label_entry->label_oid =
+			SPI_GetOid(tuple, SPI_fnumber(tupdesc, "oid"));
+		*enum_label_list = lappend(*enum_label_list, enum_label_entry);
+	}
+}
+
 bool
 ProcessSourceEventTriggerDDLCommands(JsonbParseState *state)
 {
@@ -403,16 +438,19 @@ ProcessSourceEventTriggerDDLCommands(JsonbParseState *state)
 	if (exec_res != SPI_OK_SELECT)
 		elog(ERROR, "SPI_exec failed (error %d): %s", exec_res, query_buf.data);
 
+	List	   *new_rel_list = NIL;
+	List       *enum_label_list = NIL;
 	/*
 	 * As long as there is at least one command that needs to be replicated, we
 	 * will set this to true and replicate the entire query string.
 	 */
-	List	   *new_rel_list = NIL;
 	bool		should_replicate_ddl = false;
-
-	for (int row = 0; row < SPI_processed; row++)
+	int         num_of_rows = SPI_processed;
+	/* Save SPI_tuptable so the routines we call can call SPI_execute. */
+	SPITupleTable *saved_SPI_tuptable = SPI_tuptable;
+	for (int row = 0; row < num_of_rows; row++)
 	{
-		HeapTuple	spi_tuple = SPI_tuptable->vals[row];
+		HeapTuple	spi_tuple = saved_SPI_tuptable->vals[row];
 		Oid			obj_id = SPI_GetOid(spi_tuple, DDL_END_OBJID_COLUMN_ID);
 		const char *command_tag_name = SPI_GetText(spi_tuple,
 												   DDL_END_COMMAND_TAG_COLUMN_ID);
@@ -424,6 +462,13 @@ ProcessSourceEventTriggerDDLCommands(JsonbParseState *state)
 			should_replicate_ddl |=
 				ShouldReplicateNewRelation(obj_id, &new_rel_list);
 		}
+		else if (command_tag == CMDTAG_CREATE_TYPE ||
+				 command_tag == CMDTAG_ALTER_TYPE)
+		{
+			if (type_is_enum(obj_id))
+				GetEnumLabels(obj_id, &enum_label_list);
+			should_replicate_ddl |= true;
+		}
 		else if (command_tag == CMDTAG_ALTER_TABLE &&
 				 list_member_oid(rewritten_table_oid_list, obj_id))
 		{
@@ -489,8 +534,8 @@ ProcessSourceEventTriggerDDLCommands(JsonbParseState *state)
 			YbNewRelMapEntry *entry = (YbNewRelMapEntry *) lfirst(l);
 
 			(void) pushJsonbValue(&state, WJB_BEGIN_OBJECT, NULL);
-			AddNumericJsonEntry(state, "relfile_oid", entry->relfile_oid);
 			AddStringJsonEntry(state, "rel_name", entry->rel_name);
+			AddNumericJsonEntry(state, "relfile_oid", entry->relfile_oid);
 			(void) pushJsonbValue(&state, WJB_END_OBJECT, NULL);
 
 			pfree(entry->rel_name);
@@ -499,6 +544,36 @@ ProcessSourceEventTriggerDDLCommands(JsonbParseState *state)
 
 		(void) pushJsonbValue(&state, WJB_END_ARRAY, NULL);
 	}
+	if (enum_label_list)
+	{
+		/*----------
+		 * Add the enum_label_list to the JSON output.  We use a flat array of
+		 * entries because JSON doesn't allow maps on composite values.
+		 *
+		 * If two entries have the same enum and label OIDs, then the
+		 * remaining fields are guaranteed to be the same.
+		 *----------
+		 */
+		AddJsonKey(state, "enum_label_info");
+		(void) pushJsonbValue(&state, WJB_BEGIN_ARRAY, NULL);
+
+		ListCell *l;
+		foreach (l, enum_label_list)
+		{
+			YbEnumLabelMapEntry *entry = (YbEnumLabelMapEntry *) lfirst(l);
+
+			(void) pushJsonbValue(&state, WJB_BEGIN_OBJECT, NULL);
+			AddNumericJsonEntry(state, "enum_oid", entry->enum_oid);
+			AddStringJsonEntry(state, "label", entry->label_name);
+			AddNumericJsonEntry(state, "label_oid", entry->label_oid);
+			(void) pushJsonbValue(&state, WJB_END_OBJECT, NULL);
+
+			pfree(entry->label_name);
+			pfree(entry);
+		}
+
+		(void) pushJsonbValue(&state, WJB_END_ARRAY, NULL);
+	}
 
 	return should_replicate_ddl;
 }
diff --git a/src/yb/integration-tests/xcluster/sql/create_enum.sql b/src/yb/integration-tests/xcluster/sql/create_enum.sql
index cdf7083f71..36d8d45c12 100644
--- a/src/yb/integration-tests/xcluster/sql/create_enum.sql
+++ b/src/yb/integration-tests/xcluster/sql/create_enum.sql
@@ -157,3 +157,21 @@ ALTER TYPE bogus3 RENAME TO bogon3;
 ALTER TYPE bogon3 ADD VALUE 'bad';
 ALTER TYPE bogon3 ADD VALUE 'ugly';
 -- ROLLBACK;
+
+
+--
+-- Test for handling to enums with overlapping labels
+--
+
+-- BEGIN;
+CREATE TYPE colors AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
+CREATE TYPE paint_color AS ENUM ('red', 'orange', 'white');
+-- COMMIT;
+
+
+-- Test empty enum
+
+CREATE TYPE empty_enum AS ENUM ();
+
+
+CREATE TYPE huge_label AS ENUM ('exactly_63_character_identifier_1234567890abcdefghijklmnopqrstu');
diff --git a/src/yb/integration-tests/xcluster/sql/drop_enum.sql b/src/yb/integration-tests/xcluster/sql/drop_enum.sql
index 8741290f27..5cb34b06dd 100644
--- a/src/yb/integration-tests/xcluster/sql/drop_enum.sql
+++ b/src/yb/integration-tests/xcluster/sql/drop_enum.sql
@@ -18,3 +18,10 @@ DROP TYPE bogon3;
 
 -- this also drops DOMAIN rgb and TABLE enumtest.
 DROP TYPE rainbow CASCADE;
+
+DROP TYPE colors;
+DROP TYPE paint_color;
+
+DROP TYPE empty_enum;
+
+DROP TYPE huge_label;
diff --git a/src/yb/integration-tests/xcluster/sql/pgonly_extensions_create.sql b/src/yb/integration-tests/xcluster/sql/pgonly_extensions_create.sql
index 8359f158b0..93d075538f 100644
--- a/src/yb/integration-tests/xcluster/sql/pgonly_extensions_create.sql
+++ b/src/yb/integration-tests/xcluster/sql/pgonly_extensions_create.sql
@@ -20,21 +20,33 @@ CREATE EXTENSION pg_stat_monitor;
 
 CREATE EXTENSION pgaudit;
 
+
+--
 -- Extensions that create new types
+--
+-- Commented out because we do not currently support extensions that
+-- use CREATE TYPE during their creation.
+--
+
+-- CREATE EXTENSION hll;
 
-CREATE EXTENSION hll;
+-- CREATE EXTENSION hstore;
 
-CREATE EXTENSION hstore;
+-- CREATE EXTENSION pg_trgm;
 
-CREATE EXTENSION pg_trgm;
+-- CREATE EXTENSION pgtap;
 
-CREATE EXTENSION pgtap;
+-- CREATE EXTENSION tablefunc;
 
-CREATE EXTENSION tablefunc;
+-- CREATE EXTENSION vector;
 
-CREATE EXTENSION vector;
 
+--
 -- Extensions that create tables
+--
+-- Commented out because we do not currently support extensions that
+-- use CREATE TABLE during their creation.
+--
 
 -- CREATE EXTENSION orafce;
 
diff --git a/src/yb/integration-tests/xcluster/sql/pgonly_extensions_drop.sql b/src/yb/integration-tests/xcluster/sql/pgonly_extensions_drop.sql
index 269226675a..1b7fa0c5f1 100644
--- a/src/yb/integration-tests/xcluster/sql/pgonly_extensions_drop.sql
+++ b/src/yb/integration-tests/xcluster/sql/pgonly_extensions_drop.sql
@@ -18,17 +18,17 @@ DROP EXTENSION pgaudit;
 
 -- Extensions that create new types
 
-DROP EXTENSION hll;
+-- DROP EXTENSION hll;
 
-DROP EXTENSION hstore;
+-- DROP EXTENSION hstore;
 
-DROP EXTENSION pg_trgm;
+-- DROP EXTENSION pg_trgm;
 
-DROP EXTENSION pgtap;
+-- DROP EXTENSION pgtap;
 
-DROP EXTENSION tablefunc;
+-- DROP EXTENSION tablefunc;
 
-DROP EXTENSION vector;
+-- DROP EXTENSION vector;
 
 -- Extensions that create tables
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
index f4d8f48b81..43577a29a0 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
@@ -260,6 +260,46 @@ TEST_F(XClusterDDLReplicationTest, CreateTable) {
   InsertRowsIntoProducerTableAndVerifyConsumer(producer_table_name_new_user);
 }
 
+TEST_F(XClusterDDLReplicationTest, CreateTableWithEnum) {
+  ASSERT_OK(SetUpClusters());
+  {
+    // Perturb OIDs on consumer side to make sure we don't accidentally preserve OIDs.
+    auto conn = ASSERT_RESULT(consumer_cluster_.ConnectToDB(namespace_name));
+    ASSERT_OK(
+        conn.Execute("CREATE TYPE gratuitous_enum AS ENUM ('red', 'orange', 'yellow', 'green', "
+                     "'blue', 'purple');"));
+    ASSERT_OK(conn.Execute("DROP TYPE gratuitous_enum;"));
+  }
+
+  ASSERT_OK(CheckpointReplicationGroup());
+  ASSERT_OK(CreateReplicationFromCheckpoint());
+
+  std::string expected;
+  {
+    auto conn = ASSERT_RESULT(producer_cluster_.ConnectToDB(namespace_name));
+    ASSERT_OK(conn.Execute("CREATE TYPE color AS ENUM ('red', 'blue', 'green');"));
+    ASSERT_OK(conn.Execute("CREATE TABLE t (paint_color color, amount INT);"));
+    ASSERT_OK(
+        conn.Execute("INSERT INTO t (paint_color, amount) VALUES "
+                     "('red', 10), "
+                     "('blue', 20), "
+                     "('green', 30), "
+                     "('red', 15), "
+                     "('blue', 25);"));
+    // PGConn can't handle enum values so have Postgres convert them to TEXT names.
+    expected = ASSERT_RESULT(conn.FetchAllAsString("SELECT paint_color::TEXT, amount FROM t;"));
+    LOG(INFO) << "expected table contents are: " << expected;
+  }
+
+  ASSERT_OK(WaitForSafeTimeToAdvanceToNow({namespace_name}));
+  {
+    auto conn = ASSERT_RESULT(consumer_cluster_.ConnectToDB(namespace_name));
+    auto actual = ASSERT_RESULT(conn.FetchAllAsString("SELECT paint_color::TEXT, amount FROM t;"));
+    ASSERT_EQ(expected, actual);
+  }
+
+}
+
 TEST_F(XClusterDDLReplicationTest, BlockMultistatementQuery) {
   ASSERT_OK(SetUpClusters());
   ASSERT_OK(CheckpointReplicationGroup());
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc
index b53a8f710e..f162fa1b23 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_pgregress-test.cc
@@ -203,7 +203,7 @@ TEST_F(XClusterPgRegressDDLReplicationTest, PgRegressCreateDropExtensions) {
   ASSERT_OK(TestPgRegress("pgonly_extensions_create.sql", "pgonly_extensions_drop.sql"));
 }
 
-TEST_F(XClusterPgRegressDDLReplicationTest, YB_DISABLE_TEST(PgRegressCreateDropEnum)) {
+TEST_F(XClusterPgRegressDDLReplicationTest, PgRegressCreateDropEnum) {
   ASSERT_OK(TestPgRegress("create_enum.sql", "drop_enum.sql"));
 }
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
index ff96747820..3f5e6a5029 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
@@ -209,7 +209,8 @@ Status XClusterDDLReplicationTestBase::PrintDDLQueue(Cluster& cluster) {
   std::stringstream ss;
   ss << "DDL Queue Table:" << std::endl;
   for (const auto& [start_time, query_id, raw_json_data] : rows) {
-    ss << start_time << "\t" << query_id << "\t" << raw_json_data.substr(0, kMaxJsonStrLen)
+    // Serialized JSON string has an extra character at the front.
+    ss << start_time << "\t" << query_id << "\t" << raw_json_data.substr(1, kMaxJsonStrLen)
        << std::endl;
   }
   LOG(INFO) << ss.str();
diff --git a/src/yb/tserver/xcluster_ddl_queue_handler.cc b/src/yb/tserver/xcluster_ddl_queue_handler.cc
index 0412865e78..b9d256c544 100644
--- a/src/yb/tserver/xcluster_ddl_queue_handler.cc
+++ b/src/yb/tserver/xcluster_ddl_queue_handler.cc
@@ -15,6 +15,8 @@
 
 #include <rapidjson/document.h>
 #include <rapidjson/error/en.h>
+#include <rapidjson/stringbuffer.h>
+#include <rapidjson/writer.h>
 
 #include "yb/cdc/xcluster_types.h"
 #include "yb/client/client.h"
@@ -73,8 +75,9 @@ const char* kDDLJsonVersion = "version";
 const char* kDDLJsonSchema = "schema";
 const char* kDDLJsonUser = "user";
 const char* kDDLJsonNewRelMap = "new_rel_map";
-const char* kDDLJsonRelFileOid = "relfile_oid";
 const char* kDDLJsonRelName = "rel_name";
+const char* kDDLJsonRelFileOid = "relfile_oid";
+const char* kDDLJsonEnumLabelInfo = "enum_label_info";
 const char* kDDLJsonManualReplication = "manual_replication";
 const char* kDDLPrepStmtManualInsert = "manual_replication_insert";
 const char* kDDLPrepStmtAlreadyProcessed = "already_processed_row";
@@ -83,12 +86,14 @@ const std::unordered_set<std::string> kSupportedCommandTags {
     // Relations
     "CREATE TABLE",
     "CREATE INDEX",
+    "CREATE TYPE",
     "DROP TABLE",
     "DROP INDEX",
+    "DROP TYPE",
     "ALTER TABLE",
     "ALTER INDEX",
+    "ALTER TYPE",
     // Pass thru DDLs
-    "ALTER TYPE", // Pass-through for now
     "CREATE ACCESS METHOD",
     "CREATE AGGREGATE",
     "CREATE CAST",
@@ -113,7 +118,6 @@ const std::unordered_set<std::string> kSupportedCommandTags {
     "CREATE TEXT SEARCH PARSER",
     "CREATE TEXT SEARCH TEMPLATE",
     "CREATE TRIGGER",
-    "CREATE TYPE", // Pass-through for now
     "CREATE USER MAPPING",
     "CREATE VIEW",
     "COMMENT",
@@ -161,7 +165,6 @@ const std::unordered_set<std::string> kSupportedCommandTags {
     "DROP TEXT SEARCH PARSER",
     "DROP TEXT SEARCH TEMPLATE",
     "DROP TRIGGER",
-    "DROP TYPE", // Pass-through for now
     "DROP USER MAPPING",
     "DROP VIEW",
     "IMPORT FOREIGN SCHEMA",
@@ -300,6 +303,15 @@ Result<XClusterDDLQueueHandler::DDLQueryInfo> XClusterDDLQueueHandler::GetDDLQue
   query_info.user =
       HAS_MEMBER_OF_TYPE(doc, kDDLJsonUser, IsString) ? doc[kDDLJsonUser].GetString() : "";
 
+  rapidjson::StringBuffer assignment_buffer;
+  rapidjson::Writer<rapidjson::StringBuffer> writer(assignment_buffer);
+  writer.StartObject();
+  if (HAS_MEMBER_OF_TYPE(doc, kDDLJsonEnumLabelInfo, IsArray)) {
+    writer.Key(kDDLJsonEnumLabelInfo);
+    doc[kDDLJsonEnumLabelInfo].Accept(writer);
+  }
+  writer.EndObject();
+  query_info.json_for_oid_assignment = assignment_buffer.GetString();
   return query_info;
 }
 
@@ -343,11 +355,19 @@ Status XClusterDDLQueueHandler::ProcessDDLQuery(const DDLQueryInfo& query_info)
     setup_query << Format("SET ROLE $0;", query_info.user);
   }
 
+  // Pass information needed to assign OIDs that need to be preserved across the universes.
+  setup_query << Format(
+      "SELECT pg_catalog.yb_xcluster_set_next_oid_assignments('$0');",
+      query_info.json_for_oid_assignment);
+
   setup_query << "SET yb_skip_data_insert_for_table_rewrite=true;";
 
   RETURN_NOT_OK(RunAndLogQuery(setup_query.str()));
   RETURN_NOT_OK(RunAndLogQuery(query_info.query));
-  RETURN_NOT_OK(RunAndLogQuery("SET yb_skip_data_insert_for_table_rewrite=false"));
+  RETURN_NOT_OK(
+      // The SELECT here can't be last; otherwise, RunAndLogQuery complains that rows are returned.
+      RunAndLogQuery("SELECT pg_catalog.yb_xcluster_set_next_oid_assignments('{}');"
+                     "SET yb_skip_data_insert_for_table_rewrite=false;"));
   return Status::OK();
 }
 
diff --git a/src/yb/tserver/xcluster_ddl_queue_handler.h b/src/yb/tserver/xcluster_ddl_queue_handler.h
index ddc631763f..d7bccaa5d9 100644
--- a/src/yb/tserver/xcluster_ddl_queue_handler.h
+++ b/src/yb/tserver/xcluster_ddl_queue_handler.h
@@ -54,6 +54,7 @@ class XClusterDDLQueueHandler {
     std::string command_tag;
     std::string schema = "";
     std::string user = "";
+    std::string json_for_oid_assignment;
 
     std::string ToString() const {
       return YB_STRUCT_TO_STRING(query, start_time, query_id, version, command_tag, schema, user);
diff --git a/src/yb/yql/pgwrapper/ysql_migrations/V66__24077__yb_support_oid_assignment.sql b/src/yb/yql/pgwrapper/ysql_migrations/V66__24077__yb_support_oid_assignment.sql
new file mode 100644
index 0000000000..5e88b573d0
--- /dev/null
+++ b/src/yb/yql/pgwrapper/ysql_migrations/V66__24077__yb_support_oid_assignment.sql
@@ -0,0 +1,26 @@
+BEGIN;
+  SET LOCAL yb_non_ddl_txn_for_sys_tables_allowed TO true;
+
+  INSERT INTO pg_catalog.pg_proc (
+    oid, proname, pronamespace, proowner, prolang,
+    procost, prorows, provariadic, prosupport, prokind,
+    prosecdef, proleakproof, proisstrict, proretset, provolatile,
+    proparallel, pronargs, pronargdefaults, prorettype, proargtypes,
+    proallargtypes, proargmodes, proargnames, proargdefaults, protrftypes,
+    prosrc, probin, proconfig, proacl
+  ) VALUES
+    -- implementation of yb_xcluster_set_next_oid_assignments
+    (8079, 'yb_xcluster_set_next_oid_assignments', 11, 10, 12,
+    1, 0, 0, '-', 'f',
+    false, false, true, false, 'v',
+     'r', 1, 0, 2278, '25',
+     NULL, NULL, NULL, NULL, NULL,
+    'yb_xcluster_set_next_oid_assignments', NULL, NULL, NULL)
+  ON CONFLICT DO NOTHING;
+
+  INSERT INTO pg_catalog.pg_description (
+    objoid, classoid, objsubid, description
+  ) VALUES (
+    8079, 1255, 0, 'private function used by xCluster to control OID assignment'
+  ) ON CONFLICT DO NOTHING;
+COMMIT;
