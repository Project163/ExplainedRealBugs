diff --git a/src/yb/common/CMakeLists.txt b/src/yb/common/CMakeLists.txt
index c3e1ad877b..7c9324e8a4 100644
--- a/src/yb/common/CMakeLists.txt
+++ b/src/yb/common/CMakeLists.txt
@@ -86,6 +86,7 @@ set(COMMON_SRCS
   id_mapping.cc
   key_encoder.cc
   pgsql_error.cc
+  path-handler-util.cc
   placement_info.cc
   pg_types.cc
   ql_protocol_util.cc
diff --git a/src/yb/common/path-handler-util.cc b/src/yb/common/path-handler-util.cc
new file mode 100644
index 0000000000..43155386d3
--- /dev/null
+++ b/src/yb/common/path-handler-util.cc
@@ -0,0 +1,125 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/common/path-handler-util.h"
+
+#include "yb/util/format.h"
+
+namespace yb {
+
+namespace {
+
+const char* const kSortAndFilterTableScript = R"(
+<script>
+function sortTable(table_id, n) {
+  var asc_symb = ' <span style="color: grey">\u25B2</span>';
+  var desc_symb = ' <span style="color: grey">\u25BC</span>';
+  var i, swapCount = 0;
+  var table = document.getElementById(table_id);
+  if (table.rows.length < 3) {
+    return;
+  }
+  var switching = true;
+  var asc = true;
+  if (table.rows[0].getElementsByTagName("TH")[n].innerHTML.includes(asc_symb)) {
+    asc = false;
+  }
+
+  for(var j = 0; j < table.rows[0].getElementsByTagName("TH").length; j++) {
+   table.rows[0].getElementsByTagName("TH")[j].innerHTML =
+    table.rows[0].getElementsByTagName("TH")[j].innerHTML.replace(asc_symb, "").replace(desc_symb,
+      "");
+    if (j == n) {
+      sort_symb = asc ? asc_symb : desc_symb;
+      table.rows[0].getElementsByTagName("TH")[j].innerHTML =
+        table.rows[0].getElementsByTagName("TH")[j].innerHTML.concat(sort_symb);
+    }
+  }
+
+  while (switching) {
+    switching = false;
+    // Ignore header row.
+    for (i = 1; i < (table.rows.length - 1); i++) {
+      var swap = false;
+      var x = table.rows[i].getElementsByTagName("TD")[n];
+      var y = table.rows[i + 1].getElementsByTagName("TD")[n];
+      var cmpX = x.innerHTML.length?
+        isNaN(Number(x.innerHTML))? x.innerHTML.toLowerCase():Number(x.innerHTML):
+        "~";
+      var cmpY = y.innerHTML.length?
+        isNaN(Number(y.innerHTML))?y.innerHTML.toLowerCase():Number(y.innerHTML):
+        "~";
+
+      if (asc) {
+        if (cmpX > cmpY) {
+          swap= true;
+          break;
+        }
+      } else {
+        if (cmpX < cmpY) {
+          swap = true;
+          break;
+        }
+      }
+    }
+
+    if (swap) {
+      table.rows[i].parentNode.insertBefore(table.rows[i + 1], table.rows[i]);
+      switching = true;
+    }
+  }
+}
+
+function filterTableFunction(input_id, table_id) {
+  var filter = document.getElementById(input_id).value.toLowerCase();
+  var table = document.getElementById(table_id);
+  var tr = table.getElementsByTagName("tr");
+  for (var i = 0; i < tr.length; i++) {
+    if (tr[i].getElementsByTagName("th").length > 0) {
+     // Ignore header rows.
+      continue;
+    }
+    var row = tr[i].getElementsByTagName("td");
+    var found = false;
+    for (const td of row) {
+      if (td) {
+        var value = td.textContent || td.innerText;
+        if (value.toLowerCase().indexOf(filter) > -1) {
+          found = true;
+          break;
+        }
+      }
+    }
+
+    if(found) {
+      tr[i].style.display = "";
+    } else {
+      tr[i].style.display = "none";
+    }
+  }
+}
+</script>
+)";
+
+}  // namespace
+
+std::string GenerateTableFilterBox(const std::string& input_id, const std::string& table_id) {
+  return Format(
+      "<input type='text' id='$0' onkeyup='filterTableFunction(\"$0\", \"$1\")' "
+      "placeholder='Search for ...' title='Type in a text'>\n",
+      input_id, table_id);
+}
+
+std::string GetSortAndFilterTableScript() { return kSortAndFilterTableScript; }
+
+}  // namespace yb
diff --git a/src/yb/common/path-handler-util.h b/src/yb/common/path-handler-util.h
new file mode 100644
index 0000000000..8bd8321971
--- /dev/null
+++ b/src/yb/common/path-handler-util.h
@@ -0,0 +1,77 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include <string>
+
+#include "yb/util/tostring.h"
+
+// Printing Tables which can be sorted and filtered.
+// The filter box is displayed just above the table.
+// Clicking on any column name will sort the table on that column value. The header row will display
+// the sort direction using the symbol ▲ to indicate descending and ▼ to indicate ascending. All non
+// numerical columns (isNaN) are sorted as lowercase strings.
+//
+// Usage:
+// 1. Print the table header using HTML_PRINT_TABLE_WITH_HEADER_ROW(table_type, column_names...). Or
+// HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(table_type, type_id, ...) when multiple tables have same
+// type (this happens when this is called inside loops).
+// 2. Print each row using HTML_PRINT_TABLE_ROW(column_values...)
+// 3. End the table using HTML_END_TABLE
+// 4. Follow the above sequence for each table in the page.
+// 5. At the end of the page add the javascript to perform the sort and filter functions using
+//      HTML_ADD_SORT_AND_FILTER_TABLE_SCRIPT
+
+#define INTERNAL_HTML_INTERNAL_PRINT_HEADER_FIELDS(i, table_name, field) \
+  output << "<th onclick=\"sortTable('" << table_name << "', " << _header_cnt << ")\">" \
+         << ::yb::AsString(field) << "</th>"; \
+  ++_header_cnt;
+
+#define INTERNAL_HTML_PRINT_TABLE_WITH_HEADER_ROW(table_id, ...) \
+  do { \
+    const auto table_name = table_id + "_table"; \
+    const auto table_filter = table_id + "_filter"; \
+    output << GenerateTableFilterBox(table_filter, table_name); \
+    uint32 _header_cnt = 0; \
+    output << "<table class='table table-striped' id='" << table_name << "'>\n"; \
+    output << "<tr>"; \
+    BOOST_PP_SEQ_FOR_EACH( \
+        INTERNAL_HTML_INTERNAL_PRINT_HEADER_FIELDS, table_name, \
+        BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__)) \
+    output << "</tr>\n"; \
+  } while (0)
+
+#define HTML_PRINT_TABLE_WITH_HEADER_ROW(table_type, ...) \
+  HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(table_type, 0, __VA_ARGS__)
+
+#define HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(table_type, type_id, ...) \
+  INTERNAL_HTML_PRINT_TABLE_WITH_HEADER_ROW( \
+      (std::string(BOOST_PP_STRINGIZE(table_type)) + ::yb::AsString(type_id)), __VA_ARGS__)
+
+#define HTML_INTERNAL_PRINT_ROW_FIELDS(i, data, field) "<td>" << ::yb::AsString(field) << "</td>" <<
+#define HTML_PRINT_TABLE_ROW(...) \
+  output << "<tr>" \
+          << BOOST_PP_SEQ_FOR_EACH( \
+                 HTML_INTERNAL_PRINT_ROW_FIELDS, ~, \
+                 BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__)) "</tr>\n"
+
+#define HTML_END_TABLE output << "</table>\n"
+
+#define HTML_ADD_SORT_AND_FILTER_TABLE_SCRIPT output << GetSortAndFilterTableScript()
+
+namespace yb {
+
+std::string GenerateTableFilterBox(const std::string& input_id, const std::string& table_id);
+
+std::string GetSortAndFilterTableScript();
+
+}  // namespace yb
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index cb25fa6756..159b88287c 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -1428,6 +1428,8 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
       GetReplicationStatusResponsePB* resp,
       rpc::RpcContext* rpc);
 
+  std::vector<SysUniverseReplicationEntryPB> GetAllXClusterUniverseReplicationInfos();
+
   typedef std::unordered_map<TableId, std::list<CDCStreamInfoPtr>> TableStreamIdsMap;
 
   // Find all CDCSDK streams which do not have metadata for the newly added tables.
diff --git a/src/yb/master/master-path-handlers.cc b/src/yb/master/master-path-handlers.cc
index 0ef94d76f9..a575accbc5 100644
--- a/src/yb/master/master-path-handlers.cc
+++ b/src/yb/master/master-path-handlers.cc
@@ -44,6 +44,7 @@
 
 #include "yb/common/common_types_util.h"
 #include "yb/common/hybrid_time.h"
+#include "yb/common/path-handler-util.h"
 #include "yb/dockv/partition.h"
 #include "yb/common/schema_pbutil.h"
 #include "yb/common/schema.h"
@@ -136,6 +137,8 @@ std::optional<HostPortPB> GetPublicHttpHostPort(const ServerRegistrationPB& regi
   return public_http_hp;
 }
 
+std::string BoolToString(bool val) { return val ? "true" : "false"; }
+
 }  // namespace
 
 using consensus::RaftPeerPB;
@@ -2800,44 +2803,33 @@ void MasterPathHandlers::HandleGetClusterConfigJSON(
   jw.Protobuf(config);
 }
 
-Status MasterPathHandlers::GetClusterAndXClusterConfigStatus(
-    SysXClusterConfigEntryPB* xcluster_config, SysClusterConfigEntryPB* cluster_config) {
+Status MasterPathHandlers::GetXClusterConfigs(
+    SysXClusterConfigEntryPB* xcluster_config, SysClusterConfigEntryPB* cluster_config,
+    GetReplicationStatusResponsePB* xcluster_status,
+    std::vector<SysUniverseReplicationEntryPB>* replication_infos) {
   RETURN_NOT_OK(master_->xcluster_manager()->GetXClusterConfigEntryPB(xcluster_config));
-  return master_->catalog_manager()->GetClusterConfig(cluster_config);
-}
 
-void MasterPathHandlers::HandleGetXClusterConfig(
-    const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
-  std::stringstream* output = &resp->output;
-  master_->catalog_manager()->AssertLeaderLockAcquiredForReading();
+  GetReplicationStatusRequestPB req;
+  RETURN_NOT_OK(master_->catalog_manager_impl()->GetReplicationStatus(
+      &req, xcluster_status, /*rpc=*/nullptr));
 
-  *output << "<h1>Current XCluster Config</h1>\n";
-  SysXClusterConfigEntryPB xcluster_config;
-  SysClusterConfigEntryPB cluster_config;
-  Status s = GetClusterAndXClusterConfigStatus(&xcluster_config, &cluster_config);
+  *replication_infos = master_->catalog_manager_impl()->GetAllXClusterUniverseReplicationInfos();
 
-  if (!s.ok()) {
-    *output << "<div class=\"alert alert-warning\">"
-            << EscapeForHtmlToString(s.ToString()) << "</div>";
-    return;
-  }
-  *output << "<div class=\"alert alert-success\">Successfully got xcluster config!</div>"
-          << "<pre class=\"prettyprint\">" << EscapeForHtmlToString(xcluster_config.DebugString())
-          << "consumer_registry {\n"
-          << EscapeForHtmlToString(cluster_config.consumer_registry().DebugString())
-          << "}</pre>";
-}
+  RETURN_NOT_OK(master_->catalog_manager()->GetClusterConfig(cluster_config));
 
-void MasterPathHandlers::HandleGetXClusterConfigJSON(
-    const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
-  std::stringstream* output = &resp->output;
-  JsonWriter jw(output, JsonWriter::COMPACT);
+  return Status::OK();
+}
 
+void MasterPathHandlers::GetXClusterJSON(std::stringstream& output, bool pretty) {
+  JsonWriter jw(&output, pretty ? JsonWriter::PRETTY : JsonWriter::COMPACT);
   master_->catalog_manager()->AssertLeaderLockAcquiredForReading();
 
   SysXClusterConfigEntryPB xcluster_config;
   SysClusterConfigEntryPB cluster_config;
-  Status s = GetClusterAndXClusterConfigStatus(&xcluster_config, &cluster_config);
+  GetReplicationStatusResponsePB xcluster_status;
+  std::vector<SysUniverseReplicationEntryPB> replication_infos;
+  Status s =
+      GetXClusterConfigs(&xcluster_config, &cluster_config, &xcluster_status, &replication_infos);
   if (!s.ok()) {
     jw.StartObject();
     jw.String("error");
@@ -2851,11 +2843,162 @@ void MasterPathHandlers::HandleGetXClusterConfigJSON(
   jw.Int64(xcluster_config.version());
   jw.String("xcluster_producer_registry");
   jw.Protobuf(xcluster_config.xcluster_producer_registry());
+  jw.String("replication_status");
+  jw.Protobuf(xcluster_status);
+
+  jw.String("replication_infos");
+  jw.StartArray();
+  for (auto const& replication_info : replication_infos) {
+    jw.Protobuf(replication_info);
+  }
+  jw.EndArray();
+
   jw.String("consumer_registry");
   jw.Protobuf(cluster_config.consumer_registry());
   jw.EndObject();
 }
 
+void MasterPathHandlers::HandleGetXClusterConfigJSON(
+    const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
+  GetXClusterJSON(resp->output, /*pretty=*/false);
+}
+
+void MasterPathHandlers::HandleGetXClusterConfig(
+    const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
+  std::stringstream& output = resp->output;
+
+  output << "<h1>xCluster state</h1>\n";
+  std::stringstream json_output;
+  GetXClusterJSON(json_output, /*pretty=*/true);
+  output << EscapeForHtmlToString(json_output.str());
+}
+
+void MasterPathHandlers::HandleXCluster(
+    const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
+  std::stringstream& output = resp->output;
+  master_->catalog_manager()->AssertLeaderLockAcquiredForReading();
+
+  SysXClusterConfigEntryPB xcluster_config;
+  SysClusterConfigEntryPB cluster_config;
+  GetReplicationStatusResponsePB replication_status;
+  std::vector<SysUniverseReplicationEntryPB> replication_infos;
+  Status s = GetXClusterConfigs(
+      &xcluster_config, &cluster_config, &replication_status, &replication_infos);
+
+  if (!s.ok()) {
+    output << "<div class=\"alert alert-warning\">" << EscapeForHtmlToString(s.ToString())
+           << "</div>";
+    return;
+  }
+  const auto& consumer_registry = cluster_config.consumer_registry();
+
+  if (!xcluster_config.has_xcluster_producer_registry() &&
+      consumer_registry.producer_map_size() == 0 && replication_infos.empty()) {
+    output << "<h3>xCluster replication is not enabled</h3 >\n";
+    return;
+  }
+
+  std::unordered_map<std::string, std::string> stream_status;
+
+  for (const auto& table_stream_status : replication_status.statuses()) {
+    if (!table_stream_status.errors_size()) {
+      continue;
+    }
+    std::stringstream errors;
+    bool first = true;
+    for (const auto& error : table_stream_status.errors()) {
+      errors << (first ? "" : ";") << error.ShortDebugString();
+      first = false;
+    }
+
+    stream_status[table_stream_status.stream_id()] = errors.str();
+  }
+
+  output << "<h1>xCluster state</h1>\n";
+
+  if (replication_infos.empty()) {
+    return;
+  }
+
+  output << "<h3>xCluster inbound ReplicationGroups</h3>\n";
+  output << "<pre class=\"prettyprint\">"
+         << "XClusterRole: " << XClusterRole_Name(consumer_registry.role())
+         << "\ntransactional: " << consumer_registry.transactional() << "</pre>";
+
+  for (size_t i = 0; i < replication_infos.size(); i++) {
+    const auto& replication_info = replication_infos[i];
+    auto* producer_map =
+        FindOrNull(consumer_registry.producer_map(), replication_info.replication_group_id());
+
+    output << "\n\n<h4>ReplicationGroup: " << replication_info.replication_group_id() << "</h4>\n";
+    output << "<pre class=\"prettyprint\">"
+           << "state: " << SysUniverseReplicationEntryPB::State_Name(replication_info.state())
+           << "\ntransactional: " << BoolToString(replication_info.transactional())
+           << "\nvalidated_local_auto_flags_config_version: "
+           << replication_info.validated_local_auto_flags_config_version();
+    if (producer_map) {
+      output << "\nmaster_addrs: ";
+      bool first = true;
+      for (const auto& add : producer_map->master_addrs()) {
+        output << (first ? "" : ",") << add.ShortDebugString();
+        first = false;
+      }
+      output << "\ndisable_stream: " << BoolToString(producer_map->disable_stream());
+      output << "\ncompatible_auto_flag_config_version: "
+             << producer_map->compatible_auto_flag_config_version();
+      output << "\nvalidated_auto_flags_config_version: "
+             << producer_map->validated_auto_flags_config_version();
+    }
+    output << "</pre>";
+    yb::ToString(1);
+
+    HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(
+        inbound_replication_group, i, "Producer Table Id", "Stream Id", "Consumer Table Id",
+        "Producer Tablet Count", "Consumer Tablet Count", "Local tserver optimized",
+        "Producer schema version", "Consumer schema version", "Status");
+
+    for (int j = 0; j < replication_info.tables_size(); j++) {
+      auto& producer_table_id = replication_info.tables(j);
+      std::string status, stream_id, consumer_table_id;
+      uint32 producer_tablet_count = 0, consumer_tablet_count = 0, producer_schema_version = 0,
+             consumer_schema_version = 0;
+      bool local_tserver_optimized = false;
+      auto* stream_id_it = FindOrNull(replication_info.table_streams(), producer_table_id);
+      if (stream_id_it) {
+        stream_id = *stream_id_it;
+        auto it = FindOrNull(stream_status, stream_id);
+        status = it ? *it : "OK";
+
+        if (producer_map) {
+          auto* stream_info = FindOrNull(producer_map->stream_map(), stream_id);
+          if (stream_info) {
+            consumer_table_id = stream_info->consumer_table_id();
+            consumer_tablet_count = stream_info->consumer_producer_tablet_map_size();
+            local_tserver_optimized = stream_info->local_tserver_optimized();
+            producer_schema_version =
+                stream_info->schema_versions().current_producer_schema_version();
+            consumer_schema_version =
+                stream_info->schema_versions().current_consumer_schema_version();
+            for (const auto& [_, producer_tablets] : stream_info->consumer_producer_tablet_map()) {
+              producer_tablet_count += producer_tablets.tablets_size();
+            }
+          }
+        }
+      } else {
+        status = "Not Ready";
+      }
+
+      HTML_PRINT_TABLE_ROW(
+          producer_table_id, stream_id, consumer_table_id, producer_tablet_count,
+          consumer_tablet_count, BoolToString(local_tserver_optimized), producer_schema_version,
+          consumer_schema_version, status);
+    }
+    HTML_END_TABLE;
+  }
+
+  HTML_ADD_SORT_AND_FILTER_TABLE_SCRIPT;
+}
+
 void MasterPathHandlers::HandleVersionInfoDump(
     const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
   std::stringstream *output = &resp->output;
@@ -3121,11 +3264,11 @@ Status MasterPathHandlers::Register(Webserver* server) {
       "/xcluster-config", "XCluster Config",
       std::bind(&MasterPathHandlers::CallIfLeaderOrPrintRedirect, this, _1, _2, cb), is_styled,
       false);
-  cb = std::bind(&MasterPathHandlers::HandleGetXClusterConfigJSON, this, _1, _2);
+  cb = std::bind(&MasterPathHandlers::HandleXCluster, this, _1, _2);
   server->RegisterPathHandler(
-      "/api/v1/xcluster-config", "XCluster Config JSON",
-      std::bind(&MasterPathHandlers::CallIfLeaderOrPrintRedirect, this, _1, _2, cb), false, false);
-  cb = std::bind(&MasterPathHandlers::HandleTasksPage, this, _1, _2);
+      "/xcluster", "XCluster",
+      std::bind(&MasterPathHandlers::CallIfLeaderOrPrintRedirect, this, _1, _2, cb), is_styled,
+      false);
   server->RegisterPathHandler(
       "/tasks", "Tasks",
       std::bind(&MasterPathHandlers::CallIfLeaderOrPrintRedirect, this, _1, _2, cb), is_styled,
@@ -3145,6 +3288,11 @@ Status MasterPathHandlers::Register(Webserver* server) {
       "/load-distribution", "Load balancer View",
       std::bind(&MasterPathHandlers::CallIfLeaderOrPrintRedirect, this, _1, _2, cb), is_styled,
       false);
+  cb = std::bind(&MasterPathHandlers::HandleGetXClusterConfigJSON, this, _1, _2);
+  server->RegisterPathHandler(
+      "/api/v1/xcluster-config", "XCluster Config JSON",
+      std::bind(&MasterPathHandlers::CallIfLeaderOrPrintRedirect, this, _1, _2, cb), false, false);
+  cb = std::bind(&MasterPathHandlers::HandleTasksPage, this, _1, _2);
 
   // JSON Endpoints
   cb = std::bind(&MasterPathHandlers::HandleGetTserverStatus, this, _1, _2);
diff --git a/src/yb/master/master-path-handlers.h b/src/yb/master/master-path-handlers.h
index fe2f8e2fdc..05d7ae3756 100644
--- a/src/yb/master/master-path-handlers.h
+++ b/src/yb/master/master-path-handlers.h
@@ -232,6 +232,8 @@ class MasterPathHandlers {
   void HandleGetClusterConfigJSON(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
   void HandleGetXClusterConfig(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
   void HandleGetXClusterConfigJSON(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
+  void GetXClusterJSON(std::stringstream& output, bool pretty);
+  void HandleXCluster(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
   void HandleHealthCheck(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
   void HandleCheckIfLeader(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
   void HandleGetMastersStatus(const Webserver::WebRequest& req, Webserver::WebResponse* resp);
@@ -281,8 +283,10 @@ class MasterPathHandlers {
 
   std::string GetHttpHostPortFromServerRegistration(const ServerRegistrationPB& reg) const;
 
-  Status GetClusterAndXClusterConfigStatus(
-      SysXClusterConfigEntryPB* xcluster_config, SysClusterConfigEntryPB* cluster_config);
+  Status GetXClusterConfigs(
+      SysXClusterConfigEntryPB* xcluster_config, SysClusterConfigEntryPB* cluster_config,
+      GetReplicationStatusResponsePB* xcluster_status,
+      std::vector<SysUniverseReplicationEntryPB>* replication_infos);
 
   Master* master_;
 
diff --git a/src/yb/master/xrepl_catalog_manager.cc b/src/yb/master/xrepl_catalog_manager.cc
index 5f69df4700..2cad00971e 100644
--- a/src/yb/master/xrepl_catalog_manager.cc
+++ b/src/yb/master/xrepl_catalog_manager.cc
@@ -5935,6 +5935,18 @@ Status CatalogManager::YsqlBackfillReplicationSlotNameToCDCSDKStream(
   return Status::OK();
 }
 
+std::vector<SysUniverseReplicationEntryPB>
+CatalogManager::GetAllXClusterUniverseReplicationInfos() {
+  SharedLock lock(mutex_);
+  std::vector<SysUniverseReplicationEntryPB> result;
+  for (const auto& [_, universe_info] : universe_replication_map_) {
+    auto l = universe_info->LockForRead();
+    result.push_back(l->pb);
+  }
+
+  return result;
+}
+
 // Validate that the given replication slot name is valid.
 // This function is a duplicate of the ReplicationSlotValidateName function from
 // src/postgres/src/backend/replication/slot.c
diff --git a/src/yb/tserver/tserver-path-handlers.cc b/src/yb/tserver/tserver-path-handlers.cc
index 1512304efd..c7c03c010f 100644
--- a/src/yb/tserver/tserver-path-handlers.cc
+++ b/src/yb/tserver/tserver-path-handlers.cc
@@ -41,6 +41,9 @@
 
 #include "yb/cdc/cdc_service.h"
 #include "yb/cdc/xrepl_stream_stats.h"
+
+#include "yb/common/path-handler-util.h"
+
 #include "yb/consensus/consensus.h"
 #include "yb/consensus/consensus.pb.h"
 #include "yb/consensus/log_anchor_registry.h"
@@ -158,121 +161,6 @@ struct TableInfo {
   }
 };
 
-#define PRINT_HEADER_FIELDS(i, table_id, field) \
-  << "<th onclick=\"sortTable('" << #table_id << "_table', " << table_id##_hd_cnt++ << ")\">" \
-  << ::yb::AsString(field) << "</th>"
-#define PRINT_TABLE_WITH_HEADER_ROW(table_id, ...) \
-  *output << GenerateTableFilterBox(#table_id "_filter", #table_id "_table"); \
-  uint32 table_id##_hd_cnt = 0; \
-  *output << "<table class='table table-striped' id='" << #table_id << "_table'>\n"; \
-  *output << "<tr>" BOOST_PP_SEQ_FOR_EACH( \
-                 PRINT_HEADER_FIELDS, table_id, BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__)) \
-          << "</tr>\n"
-
-#define PRINT_ROW_FIELDS(i, data, field) "<td>" << ::yb::AsString(field) << "</td>" <<
-#define PRINT_TABLE_ROW(...) \
-  *output << "<tr>" \
-          << BOOST_PP_SEQ_FOR_EACH( \
-                 PRINT_ROW_FIELDS, ~, BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__)) "</tr>\n"
-
-const char* const kSortAndFilterTableScript = R"(
-<script>
-function sortTable(table_id, n) {
-  var asc_symb = ' <span style="color: grey">\u25B2</span>';
-  var desc_symb = ' <span style="color: grey">\u25BC</span>';
-  var i, swapCount = 0;
-  var table = document.getElementById(table_id);
-  if (table.rows.length < 3) {
-    return;
-  }
-  var switching = true;
-  var asc = true;
-  if (table.rows[0].getElementsByTagName("TH")[n].innerHTML.includes(asc_symb)) {
-    asc = false;
-  }
-
-  for(var j = 0; j < table.rows[0].getElementsByTagName("TH").length; j++) {
-   table.rows[0].getElementsByTagName("TH")[j].innerHTML =
-    table.rows[0].getElementsByTagName("TH")[j].innerHTML.replace(asc_symb, "").replace(desc_symb,
-      "");
-    if (j == n) {
-      sort_symb = asc ? asc_symb : desc_symb;
-      table.rows[0].getElementsByTagName("TH")[j].innerHTML =
-        table.rows[0].getElementsByTagName("TH")[j].innerHTML.concat(sort_symb);
-    }
-  }
-
-  while (switching) {
-    switching = false;
-    // Ignore header row.
-    for (i = 1; i < (table.rows.length - 1); i++) {
-      var swap = false;
-      var x = table.rows[i].getElementsByTagName("TD")[n];
-      var y = table.rows[i + 1].getElementsByTagName("TD")[n];
-      var cmpX = x.innerHTML.length?
-        isNaN(Number(x.innerHTML))? x.innerHTML.toLowerCase():Number(x.innerHTML):
-        "~";
-      var cmpY = y.innerHTML.length?
-        isNaN(Number(y.innerHTML))?y.innerHTML.toLowerCase():Number(y.innerHTML):
-        "~";
-
-      if (asc) {
-        if (cmpX > cmpY) {
-          swap= true;
-          break;
-        }
-      } else {
-        if (cmpX < cmpY) {
-          swap = true;
-          break;
-        }
-      }
-    }
-
-    if (swap) {
-      table.rows[i].parentNode.insertBefore(table.rows[i + 1], table.rows[i]);
-      switching = true;
-    }
-  }
-}
-
-function filterTableFunction(input_id, table_id) {
-  var filter = document.getElementById(input_id).value.toLowerCase();
-  var table = document.getElementById(table_id);
-  var tr = table.getElementsByTagName("tr");
-  for (var i = 0; i < tr.length; i++) {
-    if (tr[i].getElementsByTagName("th").length > 0) {
-     // Ignore header rows.
-      continue;
-    }
-    var row = tr[i].getElementsByTagName("td");
-    var found = false;
-    for (const td of row) {
-      if (td) {
-        var value = td.textContent || td.innerText;
-        if (value.toLowerCase().indexOf(filter) > -1) {
-          found = true;
-          break;
-        }
-      }
-    }
-
-    if(found) {
-      tr[i].style.display = "";
-    } else {
-      tr[i].style.display = "none";
-    }
-  }
-}
-</script>
-)";
-
-std::string GenerateTableFilterBox(const std::string& input_id, const std::string& table_id) {
-  return Substitute(
-      "<input type='text' id='$0' onkeyup='filterTableFunction(\"$0\", \"$1\")' "
-      "placeholder='Search for ...' title='Type in a text'>\n",
-      input_id, table_id);
-}
 }  // anonymous namespace
 
 namespace std {
@@ -1168,10 +1056,10 @@ std::vector<XClusterPollerStats> GetXClusterInboundStreamStats(TabletServer* con
 
 void TabletServerPathHandlers::HandleXClusterPage(
     const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
-  std::stringstream* output = &resp->output;
+  std::stringstream& output = resp->output;
 
   if (!FLAGS_enable_xcluster_stat_collection) {
-    *output << "<h3>xCluster stats collection is not enabled. Set enable_xcluster_stat_collection "
+    output << "<h3>xCluster stats collection is not enabled. Set enable_xcluster_stat_collection "
                "to enable it.</h3 >\n";
     return;
   }
@@ -1179,35 +1067,35 @@ void TabletServerPathHandlers::HandleXClusterPage(
   const auto xcluster_outbound_stream_stats = GetXClusterOutboundStreamStats(tserver_);
   const auto xcluster_inbound_stream_stats = GetXClusterInboundStreamStats(tserver_);
   if (xcluster_outbound_stream_stats.empty() && xcluster_inbound_stream_stats.empty()) {
-    *output << "<h3>xCluster replication is not enabled</h3 >\n";
+    output << "<h3>xCluster replication is not enabled</h3 >\n";
     return;
   }
 
-  *output << "<h1>xCluster state</h1>\n";
+  output << "<h1>xCluster state</h1>\n";
 
   if (!xcluster_outbound_stream_stats.empty()) {
-    *output << "<h3>xCluster outbound streams</h3>\n";
+    output << "<h3>xCluster outbound streams</h3>\n";
 
-    PRINT_TABLE_WITH_HEADER_ROW(
+    HTML_PRINT_TABLE_WITH_HEADER_ROW(
         xcluster_streams, "Stream Id", "Produce Table Id", "Producer Tablet Id", "State",
         "Avg poll delay (ms)", "Throughput (KiBps)", "Data sent (MiB)", "Records sent",
         "Avg GetChanges latency (ms)", "WAL index sent", "WAL end index", "Last poll at", "Status");
 
     for (const auto& stat : xcluster_outbound_stream_stats) {
-      PRINT_TABLE_ROW(
+      HTML_PRINT_TABLE_ROW(
           stat.stream_id_str, stat.producer_table_id, stat.producer_tablet_id, stat.state,
           stat.avg_poll_delay_ms, StringPrintf("%.3f", stat.avg_throughput_kbps),
           StringPrintf("%.3f", stat.mbs_sent), stat.records_sent, stat.avg_get_changes_latency_ms,
           stat.sent_index, stat.latest_index, stat.last_poll_time.ToFormattedString(), stat.status);
     }
 
-    *output << "</table>\n\n";
+    HTML_END_TABLE;
   }
 
   if (!xcluster_inbound_stream_stats.empty()) {
-    *output << "<h3>xCluster inbound streams</h3>\n";
+    output << "<h3>xCluster inbound streams</h3>\n";
 
-    PRINT_TABLE_WITH_HEADER_ROW(
+    HTML_PRINT_TABLE_WITH_HEADER_ROW(
         xcluster_pollers, "ReplicationGroup Id", "Stream Id", "Consumer Table Id",
         "Consumer Tablet Id", "Producer Tablet Id", "State", "Avg poll delay (ms)",
         "Throughput (KiBps)", "Data received (MiB)", "Records received",
@@ -1215,7 +1103,7 @@ void TabletServerPathHandlers::HandleXClusterPage(
         "Last poll At", "Status");
 
     for (const auto& stat : xcluster_inbound_stream_stats) {
-      PRINT_TABLE_ROW(
+      HTML_PRINT_TABLE_ROW(
           stat.replication_group_id, stat.stream_id_str, stat.consumer_table_id,
           stat.consumer_tablet_id, stat.producer_tablet_id, stat.state, stat.avg_poll_delay_ms,
           StringPrintf("%.3f", stat.avg_throughput_kbps), StringPrintf("%.3f", stat.mbs_received),
@@ -1223,12 +1111,12 @@ void TabletServerPathHandlers::HandleXClusterPage(
           stat.received_index, stat.last_poll_time.ToFormattedString(), stat.status);
     }
 
-    *output << "</table>\n";
+    HTML_END_TABLE;
   }
 
-  *output << "\n<aside><h5>Note:</h5><p>This data is collected over the last few polls. Check "
+  output << "\n<aside><h5>Note:</h5><p>This data is collected over the last few polls. Check "
              "metrics or logs for older and detailed information.</p></aside>";
-  *output << kSortAndFilterTableScript;
+  HTML_ADD_SORT_AND_FILTER_TABLE_SCRIPT;
 }
 
 void TabletServerPathHandlers::HandleXClusterJSON(
