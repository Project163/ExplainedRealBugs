diff --git a/src/yb/client/async_rpc.cc b/src/yb/client/async_rpc.cc
index 366048eb8d..aeb962a998 100644
--- a/src/yb/client/async_rpc.cc
+++ b/src/yb/client/async_rpc.cc
@@ -399,7 +399,7 @@ void AsyncRpc::SendRpcToTserver(int attempt_num) {
     CallRemoteMethod();
   };
 
-  batcher_->WaitForAsyncWrites(tablet().tablet_id(), std::move(callback));
+  callback(Status::OK());
 }
 
 template <class Req, class Resp>
@@ -409,6 +409,9 @@ AsyncRpcBase<Req, Resp>::AsyncRpcBase(
   // TODO(#26139): this set_allocated_* call is not safe.
   req_.set_allocated_tablet_id(const_cast<std::string*>(&tablet_invoker_.tablet()->tablet_id()));
   req_.set_include_trace(IsTracingEnabled());
+  if (data.leader_term != OpId::kUnknownTerm) {
+    req_.set_leader_term(data.leader_term);
+  }
   const ConsistentReadPoint* read_point = batcher_->read_point();
   bool has_read_time = false;
   if (read_point) {
diff --git a/src/yb/client/async_rpc.h b/src/yb/client/async_rpc.h
index 1d5a1c040d..22b60b0eb0 100644
--- a/src/yb/client/async_rpc.h
+++ b/src/yb/client/async_rpc.h
@@ -65,6 +65,7 @@ struct AsyncRpcData {
   InFlightOps ops;
   bool need_metadata = false;
   bool use_async_write = false;
+  int64_t leader_term = OpId::kUnknownTerm;
 };
 
 struct FlushExtraResult {
diff --git a/src/yb/client/batcher.cc b/src/yb/client/batcher.cc
index 88e0651dfc..87c21e9dc4 100644
--- a/src/yb/client/batcher.cc
+++ b/src/yb/client/batcher.cc
@@ -86,9 +86,9 @@ DEFINE_test_flag(double, simulate_tablet_lookup_does_not_match_partition_key_pro
                  "range of the resolved tablet's partition.");
 DEFINE_test_flag(bool, fail_batcher_rpc, false, "Fail batcher RPCs for testing purposes.");
 
-DEFINE_RUNTIME_PREVIEW_bool(ysql_enable_async_writes, false,
-    "Enable asynchronous quorum commit for writes. When enabled, multiple write statements in a "
-    "transaction can execute concurrently, reducing overall latency.");
+DEFINE_RUNTIME_PREVIEW_bool(ysql_enable_write_pipelining, false,
+    "Enable pipelining of write statements within a transaction. When enabled, multiple read and "
+    "write statements in a transaction are executed concurrently, reducing overall latency.");
 
 using std::pair;
 using std::shared_ptr;
@@ -112,7 +112,7 @@ const auto kGeneralErrorStatus = STATUS(IOError, Batcher::kErrorReachingOutToTSe
 
 bool UseAsyncWrites(YBTableType table_type, TransactionId txn_id) {
   // Use async writes for transactional writes in YSQL, or if the test flag is enabled.
-  return FLAGS_ysql_enable_async_writes && table_type == YBTableType::PGSQL_TABLE_TYPE &&
+  return FLAGS_ysql_enable_write_pipelining && table_type == YBTableType::PGSQL_TABLE_TYPE &&
          !txn_id.IsNil();
 }
 
@@ -675,8 +675,12 @@ std::shared_ptr<AsyncRpc> Batcher::CreateRpc(
 
   const auto& first_op = group.begin->yb_op;
   auto transaction = this->transaction();
-  if (!data.need_metadata && transaction && transaction->HasPendingAsyncWrites(tablet_id)) {
-    data.need_metadata = true;
+  if (transaction) {
+    auto term_opt = transaction->GetPendingAsyncWriteTerm(tablet_id);
+    if (term_opt) {
+      data.leader_term = *term_opt;
+      data.need_metadata = true;
+    }
   }
 
   const auto op_group = first_op->group();
diff --git a/src/yb/client/transaction.cc b/src/yb/client/transaction.cc
index 17ec91df14..c6583aeef3 100644
--- a/src/yb/client/transaction.cc
+++ b/src/yb/client/transaction.cc
@@ -1210,7 +1210,11 @@ class YBTransaction::Impl final : public internal::TxnBatcherIf {
     VLOG_WITH_PREFIX_AND_FUNC(4) << YB_STRUCT_TO_STRING(tablet_id, op_id);
 
     std::lock_guard l(async_write_query_mutex_);
-    return InsertIfNotPresent(&inflight_async_writes_[tablet_id].op_ids, op_id);
+    auto& write_query = inflight_async_writes_[tablet_id];
+    DCHECK(write_query.op_ids.empty() || write_query.op_ids.begin()->term == op_id.term)
+        << "Received async write op_id with different term. OpId: " << op_id
+        << ", expected term: " << write_query.op_ids.begin()->term;
+    return InsertIfNotPresent(&write_query.op_ids, op_id);
   }
 
   void RecordAsyncWriteCompletion(
@@ -1221,30 +1225,30 @@ class YBTransaction::Impl final : public internal::TxnBatcherIf {
     std::vector<StdStatusCallback> waiters;
     {
       std::lock_guard l(async_write_query_mutex_);
-      auto table_it = inflight_async_writes_.find(tablet_id);
-      if (table_it == inflight_async_writes_.end()) {
+      auto write_query = inflight_async_writes_.find(tablet_id);
+      if (write_query == inflight_async_writes_.end()) {
         // Maybe we got stale responses from multiple retries on the rpc. We dont care about the
         // status in such cases.
         return;
       }
 
-      auto& tablet_data = table_it->second;
+      auto& tablet_data = write_query->second;
 
       if (status.ok()) {
         // Partition key is not needed for searching.
         tablet_data.op_ids.erase(op_id);
         if (tablet_data.op_ids.empty()) {
           waiters = std::move(tablet_data.waiters_);
-          inflight_async_writes_.erase(table_it);
+          inflight_async_writes_.erase(write_query);
         }
       } else if (async_write_status_.ok()) {
         async_write_status_ = status;
       }
 
       if (!async_write_status_.ok() || inflight_async_writes_.empty()) {
-        for (auto& [_, tablet_data] : inflight_async_writes_) {
-          MoveCollection(&tablet_data.waiters_, &waiters);
-          tablet_data.waiters_.clear();
+        for (auto& [_, write_query] : inflight_async_writes_) {
+          MoveCollection(&write_query.waiters_, &waiters);
+          write_query.waiters_.clear();
         }
 
         if (async_write_commit_waiter_) {
@@ -1259,9 +1263,11 @@ class YBTransaction::Impl final : public internal::TxnBatcherIf {
     }
   }
 
-  bool HasPendingAsyncWrites(const TabletId& tablet_id) const EXCLUDES(async_write_query_mutex_) {
+  std::optional<int64_t> GetPendingAsyncWriteTerm(const TabletId& tablet_id) const
+      EXCLUDES(async_write_query_mutex_) {
     std::lock_guard l(async_write_query_mutex_);
-    return inflight_async_writes_.contains(tablet_id);
+    auto write_query = FindOrNull(inflight_async_writes_, tablet_id);
+    return write_query ? std::optional<int64_t>(write_query->op_ids.begin()->term) : std::nullopt;
   }
 
   void WaitForAsyncWrites(const TabletId& tablet_id, StdStatusCallback&& callback) {
@@ -1272,9 +1278,9 @@ class YBTransaction::Impl final : public internal::TxnBatcherIf {
       if (status.ok()) {
         // If the tablet has a pending write then we are guaranteed that its parent tablets do not
         // have pending writes, since new writes wait for the parent tablets writes to complete.
-        auto tablet_it = FindOrNull(inflight_async_writes_, tablet_id);
-        if (tablet_it) {
-          tablet_it->waiters_.emplace_back(std::move(callback));
+        auto write_query = FindOrNull(inflight_async_writes_, tablet_id);
+        if (write_query) {
+          write_query->waiters_.emplace_back(std::move(callback));
           VLOG_WITH_PREFIX_AND_FUNC(4)
               << "Waiting for async writes: " << YB_STRUCT_TO_STRING(tablet_id, status);
           return;
@@ -2840,8 +2846,8 @@ void YBTransaction::RecordAsyncWriteCompletion(
   return impl_->RecordAsyncWriteCompletion(tablet_id, op_id, status);
 }
 
-bool YBTransaction::HasPendingAsyncWrites(const TabletId& tablet_id) const {
-  return impl_->HasPendingAsyncWrites(tablet_id);
+std::optional<int64_t> YBTransaction::GetPendingAsyncWriteTerm(const TabletId& tablet_id) const {
+  return impl_->GetPendingAsyncWriteTerm(tablet_id);
 }
 
 void YBTransaction::WaitForAsyncWrites(const TabletId& tablet_id, StdStatusCallback&& callback) {
diff --git a/src/yb/client/transaction.h b/src/yb/client/transaction.h
index b046a6c930..659ce41ef0 100644
--- a/src/yb/client/transaction.h
+++ b/src/yb/client/transaction.h
@@ -221,7 +221,7 @@ class YBTransaction : public std::enable_shared_from_this<YBTransaction> {
   bool RecordAsyncWrite(const TabletId& tablet_id, const OpId& op_id);
   void RecordAsyncWriteCompletion(
       const TabletId& tablet_id, const OpId& op_id, const Status& status);
-  bool HasPendingAsyncWrites(const TabletId& tablet_id) const;
+  std::optional<int64_t> GetPendingAsyncWriteTerm(const TabletId& tablet_id) const;
   void WaitForAsyncWrites(const TabletId& tablet_id, StdStatusCallback&& callback);
 
  private:
diff --git a/src/yb/integration-tests/async_writes-test.cc b/src/yb/integration-tests/async_writes-test.cc
index 4207975d70..ffb587abfd 100644
--- a/src/yb/integration-tests/async_writes-test.cc
+++ b/src/yb/integration-tests/async_writes-test.cc
@@ -30,7 +30,7 @@ DECLARE_bool(enable_load_balancing);
 DECLARE_bool(TEST_do_not_replicate_async_writes);
 DECLARE_bool(use_create_table_leader_hint);
 DECLARE_bool(yb_enable_read_committed_isolation);
-DECLARE_bool(ysql_enable_async_writes);
+DECLARE_bool(ysql_enable_write_pipelining);
 DECLARE_double(leader_failure_max_missed_heartbeat_periods);
 DECLARE_double(transaction_max_missed_heartbeat_periods);
 DECLARE_int32(raft_heartbeat_interval_ms);
@@ -45,7 +45,7 @@ class YSqlAsyncWriteTest : public pgwrapper::PgMiniTestBase {
  public:
   void SetUp() override {
     ANNOTATE_UNPROTECTED_WRITE(FLAGS_yb_enable_read_committed_isolation) = true;
-    ANNOTATE_UNPROTECTED_WRITE(FLAGS_ysql_enable_async_writes) = true;
+    ANNOTATE_UNPROTECTED_WRITE(FLAGS_ysql_enable_write_pipelining) = true;
 
     // These tests stepdown the leader, so we need to disable load balancing.
     ANNOTATE_UNPROTECTED_WRITE(FLAGS_enable_load_balancing) = false;
@@ -563,9 +563,8 @@ END $$$$;)",
   ASSERT_OK(ValidateData(expected_value));
 }
 
-// Make sure async writes are not blocked by follower network delay, but reads are blocked by the
-// async writes.
-TEST_F(YSqlAsyncWriteTest, ReadsBlockedByAsyncWrites) {
+// Make sure async writes and subsequent reads are not blocked by follower network delay.
+TEST_F(YSqlAsyncWriteTest, ReadsNotBlockedByAsyncWrites) {
   ASSERT_OK(
       conn_->ExecuteFormat("CREATE TABLE $0 (a INT PRIMARY KEY) SPLIT INTO 1 TABLETS", kTableName));
   ASSERT_OK(conn_->Execute("BEGIN TRANSACTION"));
@@ -586,24 +585,20 @@ TEST_F(YSqlAsyncWriteTest, ReadsBlockedByAsyncWrites) {
   LOG(INFO) << "Insert time: " << MonoDelta(now - insert_start_time);
   ASSERT_LT(now - insert_start_time, 5s);
 
-  Synchronizer sync;
-  TestThreadHolder thread_holder;
-  std::string result;
-  thread_holder.AddThread([this, callback = sync.AsStdStatusCallback(), &result]() {
-    result = ASSERT_RESULT(conn_->FetchAllAsString(Format("SELECT * FROM $0", kTableName)));
-    callback(Status::OK());
-  });
-
-  // Read should be blocked by the delay.
-  ASSERT_NOK(sync.WaitFor(10s));
+  // Read should be unblocked by the delay.
+  const auto read_start_time = CoarseMonoClock::now();
+  auto result = ASSERT_RESULT(conn_->FetchAllAsString(Format("SELECT * FROM $0", kTableName)));
+  now = CoarseMonoClock::now();
+  LOG(INFO) << "Read time: " << MonoDelta(now - read_start_time);
+  ASSERT_LT(now - read_start_time, 5s);
+  ASSERT_EQ(result, "1");
 
   for (auto& peer : follower_peers) {
     ASSERT_RESULT(peer->GetRaftConsensus())->TEST_DelayUpdate(0s);
   }
 
-  // Read should be unblocked.
-  ASSERT_OK(sync.WaitFor(delay_duration + 10s));
-  ASSERT_EQ(result, "1");
+  // Wait for the heartbeats to resume.
+  SleepFor(delay_duration + 5s);
 
   ASSERT_OK(conn_->CommitTransaction());
 
diff --git a/src/yb/tablet/operations/write_operation.cc b/src/yb/tablet/operations/write_operation.cc
index 853028a7de..6e6bee68af 100644
--- a/src/yb/tablet/operations/write_operation.cc
+++ b/src/yb/tablet/operations/write_operation.cc
@@ -71,13 +71,22 @@ Status WriteOperation::DoAborted(const Status& status) {
   return status;
 }
 
-void WriteOperation::SetAsyncWrite(boost::function<void(OpId)> callback) {
+void WriteOperation::SetAsyncWrite(AsyncWriteCallback callback) {
   added_to_leader_callback_ = std::move(callback);
 }
 
 void WriteOperation::AddedAsPending(const TabletPtr& tablet) {
   if (added_to_leader_callback_) {
-    added_to_leader_callback_(op_id());
+    Status complete_status;
+    auto status = DoReplicated(op_id().term, &complete_status);
+    if (!status.ok()) {
+      complete_status = status;
+    }
+    if (complete_status.ok()) {
+      added_to_leader_callback_(op_id());
+    } else {
+      added_to_leader_callback_(complete_status);
+    }
     added_to_leader_callback_ = {};
   }
 }
@@ -85,6 +94,11 @@ void WriteOperation::AddedAsPending(const TabletPtr& tablet) {
 // FIXME: Since this is called as a void in a thread-pool callback,
 // it seems pointless to return a Status!
 Status WriteOperation::DoReplicated(int64_t leader_term, Status* complete_status) {
+  if (do_replicated_completed_) {
+    *complete_status = Status::OK();
+    return Status::OK();
+  }
+
   TRACE_EVENT0("txn", "WriteOperation::Complete");
   TRACE("APPLY: Starting");
 
@@ -106,6 +120,8 @@ Status WriteOperation::DoReplicated(int64_t leader_term, Status* complete_status
   // make the changes visible to readers.
   TRACE("FINISH: making edits visible");
 
+  do_replicated_completed_ = true;
+
   return Status::OK();
 }
 
diff --git a/src/yb/tablet/operations/write_operation.h b/src/yb/tablet/operations/write_operation.h
index 5d0a3e1ad6..7048673086 100644
--- a/src/yb/tablet/operations/write_operation.h
+++ b/src/yb/tablet/operations/write_operation.h
@@ -44,6 +44,8 @@
 namespace yb {
 namespace tablet {
 
+using AsyncWriteCallback = boost::function<void(Result<OpId>)>;
+
 // An operation for a batch of inserts/mutates. This class holds and
 // owns most everything related to a transaction, including the Replicate and Commit PB messages
 //
@@ -69,7 +71,7 @@ class WriteOperation : public OperationBase<OperationType::kWrite, LWWritePB>  {
     return true;
   }
 
-  void SetAsyncWrite(boost::function<void(OpId)> callback);
+  void SetAsyncWrite(AsyncWriteCallback callback);
 
   void AddedAsPending(const TabletPtr& tablet) override;
 
@@ -106,7 +108,9 @@ class WriteOperation : public OperationBase<OperationType::kWrite, LWWritePB>  {
 
   HybridTime WriteHybridTime() const override;
 
-  boost::function<void(OpId)> added_to_leader_callback_;
+  AsyncWriteCallback added_to_leader_callback_;
+
+  bool do_replicated_completed_ = false;
 };
 
 }  // namespace tablet
diff --git a/src/yb/tablet/write_query.cc b/src/yb/tablet/write_query.cc
index 9778fdc89d..965ac031b5 100644
--- a/src/yb/tablet/write_query.cc
+++ b/src/yb/tablet/write_query.cc
@@ -303,15 +303,19 @@ void WriteQuery::DoStartSynchronization(const Status& status) {
   if (client_request_ && client_request_->use_async_write()) {
     VLOG(2) << "Performing Async write: " << client_request_->ShortDebugString();
     operation_->SetAsyncWrite(
-        [query = this](OpId opid) -> void {
+        [query = this](Result<OpId> opid) -> void {
           // TODO: Add metrics for async writes.
           // Query is still pending, but we are ready to invoke the callback.
 
-          query->context_->RegisterAsyncWrite(opid);
-          opid.ToPB(query->response_->mutable_async_write_op_id());
+          Status status;
+          if (opid.ok()) {
+            query->context_->RegisterAsyncWrite(*opid);
+            opid->ToPB(query->response_->mutable_async_write_op_id());
+          } else {
+            status = std::move(opid.status());
+          }
 
           TEST_SYNC_POINT("WriteQuery::BeforeCallbackInvoke");
-          Status status;
           TEST_SYNC_POINT_CALLBACK("WriteQuery::SetCallbackStatus", &status);
           query->InvokeCallback(status);
           TEST_SYNC_POINT("WriteQuery::AfterCallbackInvoke");
diff --git a/src/yb/tserver/read_query.cc b/src/yb/tserver/read_query.cc
index 20969d8074..a341de7b92 100644
--- a/src/yb/tserver/read_query.cc
+++ b/src/yb/tserver/read_query.cc
@@ -279,21 +279,29 @@ Status ReadQuery::DoPerform() {
   const auto has_row_mark = IsValidRowMarkType(batch_row_mark);
 
   LeaderTabletPeer leader_peer;
-  auto tablet_peer = peer_tablet.tablet_peer;
 
-  if (serializable_isolation || has_row_mark) {
+  if (serializable_isolation || has_row_mark || req_->has_leader_term()) {
     // At this point we expect that we don't have pure read serializable transactions, and
     // always write read intents to detect conflicts with other writes.
     leader_peer = VERIFY_RESULT(LookupLeaderTablet(
         server_.tablet_peer_lookup(), req_->tablet_id(), resp_, std::move(peer_tablet)));
-    // Serializable read adds intents, i.e. writes data.
-    // We should check for memory pressure in this case.
-    RETURN_NOT_OK(CheckWriteThrottling(req_->rejection_score(), leader_peer.peer.get()));
     abstract_tablet_ = VERIFY_RESULT(leader_peer.peer->shared_tablet());
+
+    if (serializable_isolation || has_row_mark) {
+      // Serializable read adds intents, i.e. writes data.
+      // We should check for memory pressure in this case.
+      RETURN_NOT_OK(CheckWriteThrottling(req_->rejection_score(), leader_peer.peer.get()));
+    }
+
+    if (req_->has_leader_term()) {
+      SCHECK_EQ(
+          req_->leader_term(), leader_peer.leader_term, InvalidArgument,
+          Format("Tablet $0 leader changed during async write", req_->tablet_id()));
+    }
   } else {
     abstract_tablet_ = VERIFY_RESULT(read_tablet_provider_.GetTabletForRead(
-        req_->tablet_id(), std::move(peer_tablet.tablet_peer),
-        req_->consistency_level(), AllowSplitTablet::kFalse, resp_));
+        req_->tablet_id(), std::move(peer_tablet.tablet_peer), req_->consistency_level(),
+        AllowSplitTablet::kFalse, resp_));
     leader_peer.leader_term = OpId::kUnknownTerm;
   }
 
@@ -310,6 +318,7 @@ Status ReadQuery::DoPerform() {
   }
 
   // For virtual tables held at master the tablet peer may not be found.
+  auto tablet_peer = peer_tablet.tablet_peer;
   if (!tablet_peer) {
     tablet_peer = ResultToValue(
         server_.tablet_peer_lookup()->GetServingTablet(req_->tablet_id()), {});
diff --git a/src/yb/tserver/tablet_service.cc b/src/yb/tserver/tablet_service.cc
index a9cd9c8124..b81bba433b 100644
--- a/src/yb/tserver/tablet_service.cc
+++ b/src/yb/tserver/tablet_service.cc
@@ -2629,9 +2629,16 @@ Status TabletServiceImpl::PerformWrite(
 
   auto context_ptr = std::make_shared<RpcContext>(std::move(*context));
 
-  const auto leader_term = req->has_leader_term() && req->leader_term() != OpId::kUnknownTerm
-                               ? req->leader_term()
-                               : tablet.leader_term;
+  auto leader_term = tablet.leader_term;
+  if (req->has_leader_term() && req->leader_term() != OpId::kUnknownTerm) {
+    leader_term = req->leader_term();
+    if (leader_term != tablet.leader_term) {
+      auto status =
+          STATUS_FORMAT(InvalidArgument, "Tablet $0 Leader term changed", req->tablet_id());
+      SetupErrorAndRespond(resp->mutable_error(), std::move(status), context_ptr.get());
+      return Status::OK();
+    }
+  }
 
   auto query = std::make_unique<tablet::WriteQuery>(
       leader_term, context_ptr->GetClientDeadline(), tablet.peer.get(), tablet.tablet,
diff --git a/src/yb/tserver/tserver.proto b/src/yb/tserver/tserver.proto
index d6069bdb9f..69d8480e4c 100644
--- a/src/yb/tserver/tserver.proto
+++ b/src/yb/tserver/tserver.proto
@@ -264,6 +264,8 @@ message ReadRequestPB {
   reserved 17; // ASH metadata is now passed in RequestHeader PB
 
   optional int64 raft_config_opid_index = 18;
+
+  optional int64 leader_term = 19;
 }
 
 message ReadResponsePB {
diff --git a/src/yb/yql/pgwrapper/pg_read_time-test.cc b/src/yb/yql/pgwrapper/pg_read_time-test.cc
index b6cecb235b..fbcf2d64f4 100644
--- a/src/yb/yql/pgwrapper/pg_read_time-test.cc
+++ b/src/yb/yql/pgwrapper/pg_read_time-test.cc
@@ -36,7 +36,7 @@
 
 DECLARE_bool(enable_wait_queues);
 DECLARE_bool(yb_enable_read_committed_isolation);
-DECLARE_bool(ysql_enable_async_writes);
+DECLARE_bool(ysql_enable_write_pipelining);
 DECLARE_bool(ysql_enable_auto_analyze);
 DECLARE_string(ysql_pg_conf_csv);
 DECLARE_uint64(max_clock_skew_usec);
@@ -313,7 +313,7 @@ TEST_F(PgReadTimeTest, CheckReadTimePickingLocation) {
   ASSERT_OK(conn.StartTransaction(IsolationLevel::READ_COMMITTED));
   // Disable async writes, since the metrics are only updated after the entire write query including
   // the quorum commit completes. The client conn wont wait for these until the final commit.
-  ANNOTATE_UNPROTECTED_WRITE(FLAGS_ysql_enable_async_writes) = false;
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_ysql_enable_write_pipelining) = false;
   CheckReadTimePickedOnDocdb(
       [&conn, kTable]() {
         ASSERT_OK(conn.FetchFormat("SELECT * FROM $0 WHERE k=1", kTable));
@@ -340,7 +340,7 @@ TEST_F(PgReadTimeTest, CheckReadTimePickingLocation) {
       }, 2 /* expected_num_picked_read_time_on_doc_db_metric */);
 
   ASSERT_OK(conn.CommitTransaction());
-  ANNOTATE_UNPROTECTED_WRITE(FLAGS_ysql_enable_async_writes) = true;
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_ysql_enable_write_pipelining) = true;
 
   // 10. Pipeline, copy a file to a table by fast-path transation. Only single tserver is involved
   // during copy.
