diff --git a/src/yb/client/CMakeLists.txt b/src/yb/client/CMakeLists.txt
index ba7b4d4ca4..12c54cc577 100644
--- a/src/yb/client/CMakeLists.txt
+++ b/src/yb/client/CMakeLists.txt
@@ -50,9 +50,7 @@ set(CLIENT_SRCS
   permissions.cc
   session.cc
   schema.cc
-  stateful_services/pg_auto_analyze_service_client.cc
   stateful_services/stateful_service_client_base.cc
-  stateful_services/test_echo_service_client.cc
   table.cc
   table_alterer.cc
   table_creator.cc
diff --git a/src/yb/client/stateful_services/pg_auto_analyze_service_client.cc b/src/yb/client/stateful_services/pg_auto_analyze_service_client.cc
deleted file mode 100644
index aa53b4bd08..0000000000
--- a/src/yb/client/stateful_services/pg_auto_analyze_service_client.cc
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright (c) YugaByte, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
-// in compliance with the License.  You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software distributed under the License
-// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
-// or implied.  See the License for the specific language governing permissions and limitations
-// under the License.
-//
-
-#include "yb/client/stateful_services/pg_auto_analyze_service_client.h"
-
-namespace yb {
-namespace client {
-
-PgAutoAnalyzeServiceClient::PgAutoAnalyzeServiceClient()
-    : StatefulServiceClientBase(StatefulServiceKind::PG_AUTO_ANALYZE) {}
-
-}  // namespace client
-}  // namespace yb
diff --git a/src/yb/client/stateful_services/pg_auto_analyze_service_client.h b/src/yb/client/stateful_services/pg_auto_analyze_service_client.h
index 776342616a..2c2296a880 100644
--- a/src/yb/client/stateful_services/pg_auto_analyze_service_client.h
+++ b/src/yb/client/stateful_services/pg_auto_analyze_service_client.h
@@ -17,14 +17,10 @@
 #include "yb/tserver/stateful_services/pg_auto_analyze_service.pb.h"
 #include "yb/tserver/stateful_services/pg_auto_analyze_service.proxy.h"
 
-namespace yb {
-namespace client {
+namespace yb::client {
 
-class PgAutoAnalyzeServiceClient : public StatefulServiceClientBase {
- public:
-  PgAutoAnalyzeServiceClient();
+// PgAutoAnalyzeServiceClient(client::YBClient & yb_client);
+DEFINE_STATEFUL_SERVICE_CLIENT(PgAutoAnalyze, PG_AUTO_ANALYZE,
+    IncreaseMutationCounters);
 
-  STATEFUL_SERVICE_RPCS(PgAutoAnalyze, (IncreaseMutationCounters));
-};
-}  // namespace client
-}  // namespace yb
+}  // namespace yb::client
diff --git a/src/yb/client/stateful_services/stateful_service_client_base.cc b/src/yb/client/stateful_services/stateful_service_client_base.cc
index 9a999a17d7..7e3f43791f 100644
--- a/src/yb/client/stateful_services/stateful_service_client_base.cc
+++ b/src/yb/client/stateful_services/stateful_service_client_base.cc
@@ -15,12 +15,10 @@
 
 #include <chrono>
 
-#include "yb/master/master_client.proxy.h"
-#include "yb/rpc/messenger.h"
-#include "yb/rpc/secure.h"
-#include "yb/rpc/secure_stream.h"
-#include "yb/tserver/tablet_server.h"
 #include "yb/client/client-internal.h"
+#include "yb/master/master_client.pb.h"
+#include "yb/rpc/proxy_base.h"
+#include "yb/rpc/rpc_header.pb.h"
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/status_format.h"
 #include "yb/util/sync_point.h"
@@ -36,71 +34,11 @@ namespace yb {
 using namespace std::chrono_literals;
 namespace client {
 
-StatefulServiceClientBase::StatefulServiceClientBase(StatefulServiceKind service_kind)
-    : service_kind_(service_kind), service_name_(StatefulServiceKind_Name(service_kind)) {}
-
-StatefulServiceClientBase::~StatefulServiceClientBase() { Shutdown(); }
-
-Status StatefulServiceClientBase::Init(
-    const std::string& local_hosts, const std::vector<std::vector<HostPort>>& masters,
-    const std::string& root_dir) {
-  std::vector<std::string> addresses;
-  for (const auto& address : masters) {
-    for (const auto& host_port : address) {
-      addresses.push_back(host_port.ToString());
-    }
-  }
-  SCHECK(!addresses.empty(), InvalidArgument, "No master address found to StatefulServiceClient.");
-
-  const auto master_addresses = JoinStrings(addresses, ",");
-
-  std::lock_guard lock(mutex_);
-  rpc::MessengerBuilder messenger_builder(service_name_ + "_Client");
-  secure_context_ =
-      VERIFY_RESULT(rpc::SetupInternalSecureContext(local_hosts, root_dir, &messenger_builder));
-
-  messenger_ = VERIFY_RESULT(messenger_builder.Build());
-
-  if (PREDICT_FALSE(FLAGS_TEST_running_test)) {
-    std::vector<HostPort> host_ports;
-    RETURN_NOT_OK(HostPort::ParseStrings(local_hosts, 0 /* default_port */, &host_ports));
-    messenger_->TEST_SetOutboundIpBase(VERIFY_RESULT(HostToAddress(host_ports[0].host())));
-  }
-
-  master_client_ = VERIFY_RESULT(
-      yb::client::YBClientBuilder()
-          .add_master_server_addr(master_addresses)
-          .default_admin_operation_timeout(FLAGS_stateful_service_operation_timeout_sec * 1s)
-          .Build(messenger_.get()));
-
-  proxy_cache_ = std::make_unique<rpc::ProxyCache>(messenger_.get());
-
-  return Status::OK();
-}
-
-Status StatefulServiceClientBase::TEST_Init(
-    const std::string& local_host, const std::string& master_addresses) {
-  std::lock_guard lock(mutex_);
-  rpc::MessengerBuilder messenger_builder(service_name_ + "Client");
-  secure_context_ = VERIFY_RESULT(rpc::SetupSecureContext(
-      FLAGS_certs_dir, local_host, rpc::SecureContextType::kInternal, &messenger_builder));
-
-  messenger_ = VERIFY_RESULT(messenger_builder.Build());
-
-  if (PREDICT_FALSE(FLAGS_TEST_running_test)) {
-    messenger_->TEST_SetOutboundIpBase(VERIFY_RESULT(HostToAddress(local_host)));
-  }
-
-  master_client_ = VERIFY_RESULT(
-      yb::client::YBClientBuilder()
-          .add_master_server_addr(master_addresses)
-          .default_admin_operation_timeout(FLAGS_stateful_service_operation_timeout_sec * 1s)
-          .Build(messenger_.get()));
-
-  proxy_cache_ = std::make_unique<rpc::ProxyCache>(messenger_.get());
-
-  return Status::OK();
-}
+StatefulServiceClientBase::StatefulServiceClientBase(
+    client::YBClient& yb_client, StatefulServiceKind service_kind)
+    : service_kind_(service_kind),
+      service_name_(StatefulServiceKind_Name(service_kind)),
+      yb_client_(yb_client) {}
 
 namespace {
 bool IsRetryableStatus(const Status& status) {
@@ -184,7 +122,6 @@ return InvokeRpcSync(
 
 void StatefulServiceClientBase::ResetServiceLocation() {
   std::lock_guard lock(mutex_);
-  service_hp_.reset();
   proxy_.reset();
 }
 
@@ -195,31 +132,18 @@ Result<std::shared_ptr<rpc::ProxyBase>> StatefulServiceClientBase::GetProxy(
     return proxy_;
   }
 
-  if (!service_hp_) {
-    auto location = VERIFY_RESULT(master_client_->GetStatefulServiceLocation(service_kind_));
+    auto location = VERIFY_RESULT(yb_client_.GetStatefulServiceLocation(service_kind_));
     auto* host_port = GetHostPort(&location);
     SCHECK(
         host_port && host_port->has_host(), IllegalState, "Service host is invalid: $0",
         location.DebugString());
-    service_hp_ = std::make_shared<HostPort>(HostPort::FromPB(*host_port));
-  }
+    auto service_hp = HostPort::FromPB(*host_port);
 
-  VLOG(3) << "Connecting to " << service_name_ << " at " << *service_hp_;
+    VLOG(3) << "Connecting to " << service_name_ << " at " << service_hp;
 
-  proxy_.reset(make_proxy(proxy_cache_.get(), *service_hp_));
-  return proxy_;
+    proxy_.reset(make_proxy(&yb_client_.proxy_cache(), service_hp));
+    return proxy_;
 }
 
-void StatefulServiceClientBase::Shutdown() {
-  std::lock_guard lock(mutex_);
-
-  if (master_client_) {
-    master_client_->Shutdown();
-  }
-
-  if (messenger_) {
-    messenger_->Shutdown();
-  }
-}
 }  // namespace client
 }  // namespace yb
diff --git a/src/yb/client/stateful_services/stateful_service_client_base.h b/src/yb/client/stateful_services/stateful_service_client_base.h
index 3e435dff08..6b80f5d7b9 100644
--- a/src/yb/client/stateful_services/stateful_service_client_base.h
+++ b/src/yb/client/stateful_services/stateful_service_client_base.h
@@ -49,25 +49,30 @@ class YBClient;
     return resp; \
   }
 
+// Input: service name, csv list of RPC methods.
 // Creates functions with these signature:
 // Result<[RpcMethod]ResponsePB> [RpcMethod](const CoarseTimePoint&, const [RpcMethod]RequestPB&);
 // Result<[RpcMethod]ResponsePB> [RpcMethod](const MonoDelta&, const [RpcMethod]RequestPB&);
-#define STATEFUL_SERVICE_RPCS(service, methods) \
-  BOOST_PP_SEQ_FOR_EACH(STATEFUL_SERVICE_RPC, service, methods)
+#define STATEFUL_SERVICE_RPCS(service, ...) \
+  BOOST_PP_SEQ_FOR_EACH(STATEFUL_SERVICE_RPC, service, BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))
+
+// Input: service_name, service_kind and csv list of rpc methods.
+// Creates a service client with constructor of type:
+// [service_name]ServiceClient(client::YBClient & yb_client);
+#define DEFINE_STATEFUL_SERVICE_CLIENT(service_name, service_kind, ...) \
+  class BOOST_PP_CAT(service_name, ServiceClient) : public StatefulServiceClientBase { \
+   public: \
+    BOOST_PP_CAT(service_name, ServiceClient) \
+    (client::YBClient & yb_client) \
+        : StatefulServiceClientBase(yb_client, StatefulServiceKind::service_kind) {} \
+    STATEFUL_SERVICE_RPCS(service_name, __VA_ARGS__); \
+  }
 
 class StatefulServiceClientBase {
  public:
-  explicit StatefulServiceClientBase(StatefulServiceKind service_kind);
-
-  virtual ~StatefulServiceClientBase();
-
-  Status Init(
-      const std::string& local_hosts, const std::vector<std::vector<HostPort>>& master_addresses,
-      const std::string& root_dir);
-
-  Status TEST_Init(const std::string& local_host, const std::string& master_addresses);
+  StatefulServiceClientBase(client::YBClient& yb_client, StatefulServiceKind service_kind);
 
-  void Shutdown();
+  virtual ~StatefulServiceClientBase() = default;
 
   Status InvokeRpcSync(
       const CoarseTimePoint& deadline,
@@ -103,13 +108,9 @@ class StatefulServiceClientBase {
  private:
   const StatefulServiceKind service_kind_;
   const std::string service_name_;
-  std::unique_ptr<rpc::SecureContext> secure_context_;
-  std::unique_ptr<rpc::Messenger> messenger_;
-  std::shared_ptr<client::YBClient> master_client_;
-  std::unique_ptr<rpc::ProxyCache> proxy_cache_;
+  YBClient& yb_client_;
 
   mutable std::mutex mutex_;
-  std::shared_ptr<HostPort> service_hp_ GUARDED_BY(mutex_);
   std::shared_ptr<rpc::ProxyBase> proxy_ GUARDED_BY(mutex_);
 };
 }  // namespace client
diff --git a/src/yb/client/stateful_services/test_echo_service_client.cc b/src/yb/client/stateful_services/test_echo_service_client.cc
deleted file mode 100644
index abbca9e5d2..0000000000
--- a/src/yb/client/stateful_services/test_echo_service_client.cc
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright (c) YugaByte, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
-// in compliance with the License.  You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software distributed under the License
-// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
-// or implied.  See the License for the specific language governing permissions and limitations
-// under the License.
-//
-
-#include "yb/client/stateful_services/test_echo_service_client.h"
-
-namespace yb {
-namespace client {
-
-TestEchoServiceClient::TestEchoServiceClient()
-    : StatefulServiceClientBase(StatefulServiceKind::TEST_ECHO) {}
-
-}  // namespace client
-}  // namespace yb
diff --git a/src/yb/client/stateful_services/test_echo_service_client.h b/src/yb/client/stateful_services/test_echo_service_client.h
index 63feab6c84..5505662769 100644
--- a/src/yb/client/stateful_services/test_echo_service_client.h
+++ b/src/yb/client/stateful_services/test_echo_service_client.h
@@ -17,14 +17,11 @@
 #include "yb/tserver/stateful_services/test_echo_service.pb.h"
 #include "yb/tserver/stateful_services/test_echo_service.proxy.h"
 
-namespace yb {
-namespace client {
+namespace yb::client {
 
-class TestEchoServiceClient : public StatefulServiceClientBase {
- public:
-  TestEchoServiceClient();
+// TestEchoServiceClient(client::YBClient & yb_client);
+DEFINE_STATEFUL_SERVICE_CLIENT(TestEcho, TEST_ECHO,
+    GetEcho,
+    GetEchoCount);
 
-  STATEFUL_SERVICE_RPCS(TestEcho, (GetEcho)(GetEchoCount));
-};
-}  // namespace client
-}  // namespace yb
+}  // namespace yb::client
diff --git a/src/yb/integration-tests/mini_cluster_base.cc b/src/yb/integration-tests/mini_cluster_base.cc
index d9ba7925a4..28de71a3cf 100644
--- a/src/yb/integration-tests/mini_cluster_base.cc
+++ b/src/yb/integration-tests/mini_cluster_base.cc
@@ -82,8 +82,4 @@ Result<HostPort> MiniClusterBase::GetLeaderMasterBoundRpcAddr() {
   return DoGetLeaderMasterBoundRpcAddr();
 }
 
-Status MiniClusterBase::InitStatefulServiceClient(client::StatefulServiceClientBase* client) {
-  auto host_port = VERIFY_RESULT(GetLeaderMasterBoundRpcAddr());
-  return client->TEST_Init("127.0.0.52", host_port.ToString());
-}
 }  // namespace yb
diff --git a/src/yb/integration-tests/mini_cluster_base.h b/src/yb/integration-tests/mini_cluster_base.h
index 9a23486330..f3afe12984 100644
--- a/src/yb/integration-tests/mini_cluster_base.h
+++ b/src/yb/integration-tests/mini_cluster_base.h
@@ -55,13 +55,6 @@ class MiniClusterBase {
 
   bool running() const { return running_.load(std::memory_order_acquire); }
 
-  template <class T>
-  Result<std::unique_ptr<T>> CreateStatefulServiceClient() {
-    auto client = std::make_unique<T>();
-    RETURN_NOT_OK(InitStatefulServiceClient(client.get()));
-    return client;
-  }
-
  protected:
   virtual ~MiniClusterBase() = default;
 
@@ -79,7 +72,6 @@ class MiniClusterBase {
   virtual void ConfigureClientBuilder(client::YBClientBuilder* builder) = 0;
 
   virtual Result<HostPort> DoGetLeaderMasterBoundRpcAddr() = 0;
-  Status InitStatefulServiceClient(client::StatefulServiceClientBase* client);
 };
 
 }  // namespace yb
diff --git a/src/yb/integration-tests/stateful_services/stateful_service-itest.cc b/src/yb/integration-tests/stateful_services/stateful_service-itest.cc
index 596bd4704b..0ab6c5cd67 100644
--- a/src/yb/integration-tests/stateful_services/stateful_service-itest.cc
+++ b/src/yb/integration-tests/stateful_services/stateful_service-itest.cc
@@ -13,25 +13,22 @@
 
 #include <chrono>
 
-#include "yb/client/client-internal.h"
-#include "yb/client/session.h"
 #include "yb/client/stateful_services/test_echo_service_client.h"
 #include "yb/client/table_handle.h"
 #include "yb/client/yb_table_name.h"
 #include "yb/integration-tests/cluster_itest_util.h"
 #include "yb/integration-tests/mini_cluster.h"
 #include "yb/integration-tests/yb_mini_cluster_test_base.h"
-#include "yb/master/catalog_manager.h"
 #include "yb/master/master_cluster.proxy.h"
 #include "yb/master/master_defaults.h"
-#include "yb/master/master.h"
 #include "yb/master/mini_master.h"
-#include "yb/tablet/tablet_metadata.h"
 #include "yb/tablet/tablet.h"
+#include "yb/tablet/tablet_metadata.h"
 #include "yb/tserver/mini_tablet_server.h"
 #include "yb/tserver/service_util.h"
 #include "yb/tserver/stateful_services/stateful_service_base.h"
 #include "yb/tserver/tablet_server.h"
+#include "yb/util/backoff_waiter.h"
 #include "yb/util/monotime.h"
 #include "yb/util/sync_point.h"
 #include "yb/util/test_thread_holder.h"
@@ -72,6 +69,7 @@ class StatefulServiceTest : public MiniClusterTestWithClient<MiniCluster> {
     ASSERT_EQ(tablet_ids.size(), 1);
     tablet_id_.swap(tablet_ids[0]);
     ASSERT_OK(cluster_->WaitForLoadBalancerToStabilize(kTimeout));
+    service_client_ = std::make_unique<client::TestEchoServiceClient>(*client_);
   }
 
   Status VerifyEchoServiceHostedOnAllPeers() {
@@ -91,6 +89,7 @@ class StatefulServiceTest : public MiniClusterTestWithClient<MiniCluster> {
   }
 
   TabletId tablet_id_;
+  std::unique_ptr<client::TestEchoServiceClient> service_client_;
 };
 
 TEST_F(StatefulServiceTest, TestRemoteBootstrap) {
@@ -213,9 +212,6 @@ Status ValidateRowsFromServiceTable(
 }  // namespace
 
 TEST_F(StatefulServiceTest, TestEchoService) {
-  auto service_client =
-      ASSERT_RESULT(cluster_->CreateStatefulServiceClient<client::TestEchoServiceClient>());
-
   auto service_table = std::make_unique<client::TableHandle>();
   ASSERT_OK(service_table->Open(service_table_name, client_.get()));
   auto session = client_->NewSession(kTimeout);
@@ -225,7 +221,7 @@ TEST_F(StatefulServiceTest, TestEchoService) {
   auto message = "Hello World!";
   echo_req.set_message(message);
 
-  auto echo_resp = ASSERT_RESULT(service_client->GetEcho(echo_req, kTimeout));
+  auto echo_resp = ASSERT_RESULT(service_client_->GetEcho(echo_req, kTimeout));
 
   ASSERT_EQ(echo_resp.message(), "Hello World! World! World!");
   auto initial_node_id = echo_resp.node_id();
@@ -236,14 +232,14 @@ TEST_F(StatefulServiceTest, TestEchoService) {
   ASSERT_EQ(echo_resp.node_id(), initial_leader_uuid);
   ASSERT_OK(ValidateRowsFromServiceTable(*service_table, 1, message, initial_leader_uuid));
 
-  auto count_resp = ASSERT_RESULT(service_client->GetEchoCount(count_req, kTimeout));
+  auto count_resp = ASSERT_RESULT(service_client_->GetEchoCount(count_req, kTimeout));
   ASSERT_EQ(count_resp.count(), 1);
 
   initial_leader->Shutdown();
 
   message = "Hungry shark doo";
   echo_req.set_message(message);
-  echo_resp = ASSERT_RESULT(service_client->GetEcho(echo_req, CoarseMonoClock::Now() + kTimeout));
+  echo_resp = ASSERT_RESULT(service_client_->GetEcho(echo_req, CoarseMonoClock::Now() + kTimeout));
 
   ASSERT_EQ(echo_resp.message(), "Hungry shark doo doo doo");
   ASSERT_NE(echo_resp.node_id(), initial_leader_uuid);
@@ -263,19 +259,19 @@ TEST_F(StatefulServiceTest, TestEchoService) {
 
   // We cannot test ValidateRowsFromServiceTable as we dont know which leader which processed the
   // request. Load balancer could have moved the leader before we can find it.
-  count_resp = ASSERT_RESULT(service_client->GetEchoCount(count_req, kTimeout));
+  count_resp = ASSERT_RESULT(service_client_->GetEchoCount(count_req, kTimeout));
   ASSERT_EQ(count_resp.count(), 2);
 
   message = "Anybody there?";
   echo_req.set_message(message);
-  echo_resp = ASSERT_RESULT(service_client->GetEcho(echo_req, kTimeout));
+  echo_resp = ASSERT_RESULT(service_client_->GetEcho(echo_req, kTimeout));
 
   // Make sure the new tablet leader is the one serving the request.
   ASSERT_EQ(echo_resp.message(), "Anybody there? there? there?");
   ASSERT_EQ(echo_resp.node_id(), final_leader_uuid);
   ASSERT_OK(ValidateRowsFromServiceTable(*service_table, 3, message, final_leader_uuid));
 
-  count_resp = ASSERT_RESULT(service_client->GetEchoCount(count_req, kTimeout));
+  count_resp = ASSERT_RESULT(service_client_->GetEchoCount(count_req, kTimeout));
   ASSERT_EQ(count_resp.count(), 3);
 
   ASSERT_OK(initial_leader->Start());
@@ -295,14 +291,13 @@ TEST_F(StatefulServiceTest, TestLeadershipChange) {
   // This is needed for the Batcher to propagate back the errors to the caller.
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_combine_batcher_errors) = true;
 
-  auto service_client =
-      ASSERT_RESULT(cluster_->CreateStatefulServiceClient<client::TestEchoServiceClient>());
+  auto service_client = client::TestEchoServiceClient(*client_);
   auto service_table = std::make_unique<client::TableHandle>();
   ASSERT_OK(service_table->Open(service_table_name, client_.get()));
 
   stateful_service::GetEchoCountRequestPB count_req;
   stateful_service::GetEchoCountResponsePB count_resp;
-  count_resp = ASSERT_RESULT(service_client->GetEchoCount(count_req, kTimeout));
+  count_resp = ASSERT_RESULT(service_client_->GetEchoCount(count_req, kTimeout));
   ASSERT_EQ(count_resp.count(), 0);
 
   yb::SyncPoint::GetInstance()->LoadDependency(
@@ -326,9 +321,8 @@ TEST_F(StatefulServiceTest, TestLeadershipChange) {
   echo_req.set_message(message);
   auto test_thread_holder = TestThreadHolder();
   Result<stateful_service::GetEchoResponsePB> result = kUninitializedStatus;
-  test_thread_holder.AddThread([&service_client, &echo_req, &result]() {
-    result = service_client->GetEcho(echo_req, kTimeout);
-  });
+  test_thread_holder.AddThread(
+      [this, &echo_req, &result]() { result = service_client_->GetEcho(echo_req, kTimeout); });
 
   TEST_SYNC_POINT("StatefulServiceTest::TestLeadershipChange::BeforeLeaderChange");
   ASSERT_OK(StepDown(leader_peer, std::string() /* new_leader_uuid */, ForceStepDown::kTrue));
@@ -343,7 +337,7 @@ TEST_F(StatefulServiceTest, TestLeadershipChange) {
   ASSERT_GT(attempts, 1);
 
   // We should have logged to the table twice.
-  count_resp = ASSERT_RESULT(service_client->GetEchoCount(count_req, kTimeout));
+  count_resp = ASSERT_RESULT(service_client_->GetEchoCount(count_req, kTimeout));
   ASSERT_EQ(count_resp.count(), 2);
 }
 
@@ -377,8 +371,6 @@ TEST_F(StatefulServiceTest, TestWriteDuringLeadershipChange) {
       });
   yb::SyncPoint::GetInstance()->EnableProcessing();
 
-  auto service_client =
-      ASSERT_RESULT(cluster_->CreateStatefulServiceClient<client::TestEchoServiceClient>());
   auto service_table = std::make_unique<client::TableHandle>();
   ASSERT_OK(service_table->Open(service_table_name, client_.get()));
 
@@ -389,9 +381,8 @@ TEST_F(StatefulServiceTest, TestWriteDuringLeadershipChange) {
   echo_req.set_message("Hello World!");
   auto test_thread_holder = TestThreadHolder();
   Result<stateful_service::GetEchoResponsePB> result = kUninitializedStatus;
-  test_thread_holder.AddThread([&service_client, &echo_req, &result]() {
-    result = service_client->GetEcho(echo_req, kTimeout);
-  });
+  test_thread_holder.AddThread(
+      [this, &echo_req, &result]() { result = service_client_->GetEcho(echo_req, kTimeout); });
 
   TEST_SYNC_POINT("StatefulServiceTest::TestWriteDuringLeadershipChange::BeforeLeaderChange");
   ASSERT_OK(StepDown(leader_peer, std::string() /* new_leader_uuid */, ForceStepDown::kTrue));
diff --git a/src/yb/tserver/pg_table_mutation_count_sender.cc b/src/yb/tserver/pg_table_mutation_count_sender.cc
index 53fc00f7df..91a73a3345 100644
--- a/src/yb/tserver/pg_table_mutation_count_sender.cc
+++ b/src/yb/tserver/pg_table_mutation_count_sender.cc
@@ -15,6 +15,8 @@
 
 #include <chrono>
 
+#include "yb/client/stateful_services/pg_auto_analyze_service_client.h"
+
 #include "yb/tserver/pg_mutation_counter.h"
 #include "yb/tserver/tablet_server.h"
 
@@ -80,11 +82,7 @@ Status TableMutationCountSender::DoSendMutationCounts() {
   }
 
   if (!client_) {
-    auto client = std::make_unique<client::PgAutoAnalyzeServiceClient>();
-    RETURN_NOT_OK(client->Init(
-        server_.options().HostsString(), *server_.options().GetMasterAddresses(),
-        server_.fs_manager()->GetDefaultRootDir()));
-    client_.swap(client);
+    client_ = std::make_unique<client::PgAutoAnalyzeServiceClient>(*server_.client_future().get());
   }
 
   stateful_service::IncreaseMutationCountersRequestPB req;
diff --git a/src/yb/tserver/pg_table_mutation_count_sender.h b/src/yb/tserver/pg_table_mutation_count_sender.h
index 99a0bb1c6e..3bb644163e 100644
--- a/src/yb/tserver/pg_table_mutation_count_sender.h
+++ b/src/yb/tserver/pg_table_mutation_count_sender.h
@@ -17,18 +17,18 @@
 #include <memory>
 #include <mutex>
 
-#include "yb/client/client.h"
-#include "yb/client/stateful_services/pg_auto_analyze_service_client.h"
-
 #include "yb/gutil/macros.h"
-#include "yb/gutil/strings/join.h"
 #include "yb/gutil/thread_annotations.h"
 
 #include "yb/util/status_fwd.h"
 #include "yb/util/thread.h"
-#include "yb/util/unique_lock.h"
 
 namespace yb {
+
+namespace client {
+class PgAutoAnalyzeServiceClient;
+}  // namespace client
+
 namespace tserver {
 
 class TabletServer;
diff --git a/src/yb/tserver/stateful_services/pg_auto_analyze_service.h b/src/yb/tserver/stateful_services/pg_auto_analyze_service.h
index 1b8585487c..7bd1f28e90 100644
--- a/src/yb/tserver/stateful_services/pg_auto_analyze_service.h
+++ b/src/yb/tserver/stateful_services/pg_auto_analyze_service.h
@@ -32,7 +32,8 @@ class PgAutoAnalyzeService : public StatefulRpcServiceBase<PgAutoAnalyzeServiceI
   virtual Result<bool> RunPeriodicTask() override;
   Status UpdateMutationsSinceLastAnalyze();
 
-  STATEFUL_SERVICE_IMPL_METHODS((IncreaseMutationCounters));
+  STATEFUL_SERVICE_IMPL_METHODS(
+      IncreaseMutationCounters);
 
   tserver::PgMutationCounter pg_cluster_level_mutation_counter_;
 };
diff --git a/src/yb/tserver/stateful_services/stateful_service_base.h b/src/yb/tserver/stateful_services/stateful_service_base.h
index 19a0fe874f..2feeaa363f 100644
--- a/src/yb/tserver/stateful_services/stateful_service_base.h
+++ b/src/yb/tserver/stateful_services/stateful_service_base.h
@@ -34,11 +34,17 @@ class TSTabletManager;
 
 namespace stateful_service {
 
-// Macro to ensure stateful service rpc methods are only served when the service is ready.
-// This requires the service to be in active mode and the serving tablet peer to be a leader and
-// have the lease. resp->mutable_error() will be set if the service is not ready.
-#define STATEFUL_SERVICE_IMPL_METHODS(methods) \
-  BOOST_PP_SEQ_FOR_EACH(STATEFUL_SERVICE_IMPL_METHOD_HELPER, ~, methods)
+// Input: csv list of RPC methods.
+// Creates stateful service rpc method wrappers to ensure requests are only served when the service
+// is ready. This requires the service to be in active mode and the serving tablet peer to be a
+// leader and have the lease. Also handles leadership changes during the processing of the request.
+// resp->mutable_error() will be set if the service is not ready.
+//
+// The following method is declared. It must be defined by the service.
+// Status [RpcMethod]Impl(const [RpcMethod]RequestPB&, [RpcMethod]ResponsePB*);
+#define STATEFUL_SERVICE_IMPL_METHODS(...) \
+  BOOST_PP_SEQ_FOR_EACH( \
+      STATEFUL_SERVICE_IMPL_METHOD_HELPER, ~, BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))
 
 #define STATEFUL_SERVICE_IMPL_METHOD_HELPER(i, data, method_name) \
   Status BOOST_PP_CAT(method_name, Impl)( \
diff --git a/src/yb/tserver/stateful_services/test_echo_service.h b/src/yb/tserver/stateful_services/test_echo_service.h
index 38a3508fd4..25c0099028 100644
--- a/src/yb/tserver/stateful_services/test_echo_service.h
+++ b/src/yb/tserver/stateful_services/test_echo_service.h
@@ -33,7 +33,9 @@ class TestEchoService : public StatefulRpcServiceBase<TestEchoServiceIf> {
   Status RecordRequestInTable(const std::string& message);
   Status ReloadEchoCountFromTable();
 
-  STATEFUL_SERVICE_IMPL_METHODS((GetEcho)(GetEchoCount));
+  STATEFUL_SERVICE_IMPL_METHODS(
+      GetEcho,
+      GetEchoCount);
 
  private:
   const std::string node_uuid_;
