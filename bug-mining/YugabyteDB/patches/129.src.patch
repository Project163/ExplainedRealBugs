diff --git a/src/yb/master/CMakeLists.txt b/src/yb/master/CMakeLists.txt
index 6f78ade89e..52bdc4590c 100644
--- a/src/yb/master/CMakeLists.txt
+++ b/src/yb/master/CMakeLists.txt
@@ -223,7 +223,8 @@ ADD_YB_LIBRARY(master_error
   DEPS ${MASTER_RPC_LIBS})
 
 set(MASTER_UTIL_SRCS
-  master_util.cc)
+  master_util.cc
+  catalog_entity_parser.cc)
 ADD_YB_LIBRARY(master_util
   SRCS ${MASTER_UTIL_SRCS}
   DEPS master_error ${MASTER_RPC_LIBS})
diff --git a/src/yb/master/catalog_entity_base.h b/src/yb/master/catalog_entity_base.h
index 903276a73a..7cbc8b88fd 100644
--- a/src/yb/master/catalog_entity_base.h
+++ b/src/yb/master/catalog_entity_base.h
@@ -15,6 +15,7 @@
 
 #include <shared_mutex>
 
+#include "yb/master/catalog_entity_types.h"
 #include "yb/master/master_types.pb.h"
 #include "yb/server/monitored_task.h"
 #include "yb/util/cow_object.h"
@@ -44,7 +45,7 @@ class TasksTracker;
 // sys_catalog. Subclasses of this will provide convenience getter/setter methods around the
 // protos and instances of these will be wrapped around CowObjects and locks for access and
 // modifications.
-template <class DataEntryPB, SysRowEntryType entry_type>
+template <class DataEntryPB>
 struct Persistent {
   // Type declaration to be used in templated read/write methods. We are using typename
   // Class::data_type in templated methods for figuring out the type we need.
@@ -52,7 +53,7 @@ struct Persistent {
 
   // Subclasses of this need to provide a valid value of the entry type through
   // the template class argument.
-  static SysRowEntryType type() { return entry_type; }
+  static SysRowEntryType type() { return GetCatalogEntityType<DataEntryPB>::value; }
 
   // The proto that is persisted in the sys_catalog.
   DataEntryPB pb;
diff --git a/src/yb/master/catalog_entity_info.h b/src/yb/master/catalog_entity_info.h
index 1ac00cb7a9..c7c35ec950 100644
--- a/src/yb/master/catalog_entity_info.h
+++ b/src/yb/master/catalog_entity_info.h
@@ -188,7 +188,7 @@ struct TabletReplica {
 // The data related to a tablet which is persisted on disk.
 // This portion of TabletInfo is managed via CowObject.
 // It wraps the underlying protobuf to add useful accessors.
-struct PersistentTabletInfo : public Persistent<SysTabletsEntryPB, SysRowEntryType::TABLET> {
+struct PersistentTabletInfo : public Persistent<SysTabletsEntryPB> {
   bool is_running() const {
     return pb.state() == SysTabletsEntryPB::RUNNING;
   }
@@ -372,7 +372,7 @@ class TabletInfo : public MetadataCowWrapper<PersistentTabletInfo> {
 // The data related to a table which is persisted on disk.
 // This portion of TableInfo is managed via CowObject.
 // It wraps the underlying protobuf to add useful accessors.
-struct PersistentTableInfo : public Persistent<SysTablesEntryPB, SysRowEntryType::TABLE> {
+struct PersistentTableInfo : public Persistent<SysTablesEntryPB> {
   bool started_deleting() const {
     return pb.state() == SysTablesEntryPB::DELETING ||
            pb.state() == SysTablesEntryPB::DELETED;
@@ -831,8 +831,7 @@ class TableInfo : public RefCountedThreadSafe<TableInfo>,
 // The data related to a namespace which is persisted on disk.
 // This portion of NamespaceInfo is managed via CowObject.
 // It wraps the underlying protobuf to add useful accessors.
-struct PersistentNamespaceInfo : public Persistent<
-    SysNamespaceEntryPB, SysRowEntryType::NAMESPACE> {
+struct PersistentNamespaceInfo : public Persistent<SysNamespaceEntryPB> {
   // Get the namespace name.
   const NamespaceName& name() const {
     return pb.name();
@@ -884,7 +883,7 @@ class NamespaceInfo : public RefCountedThreadSafe<NamespaceInfo>,
 // The data related to a User-Defined Type which is persisted on disk.
 // This portion of UDTypeInfo is managed via CowObject.
 // It wraps the underlying protobuf to add useful accessors.
-struct PersistentUDTypeInfo : public Persistent<SysUDTypeEntryPB, SysRowEntryType::UDTYPE> {
+struct PersistentUDTypeInfo : public Persistent<SysUDTypeEntryPB> {
   // Return the type's name.
   const UDTypeName& name() const {
     return pb.name();
@@ -946,16 +945,13 @@ class UDTypeInfo : public RefCountedThreadSafe<UDTypeInfo>,
 
 // This wraps around the proto containing cluster level config information. It will be used for
 // CowObject managed access.
-struct PersistentClusterConfigInfo : public Persistent<SysClusterConfigEntryPB,
-                                                       SysRowEntryType::CLUSTER_CONFIG> {
-};
+struct PersistentClusterConfigInfo : public Persistent<SysClusterConfigEntryPB> {};
 
 // This is the in memory representation of the cluster config information serialized proto data,
 // using metadata() for CowObject access.
 class ClusterConfigInfo : public SingletonMetadataCowWrapper<PersistentClusterConfigInfo> {};
 
-struct PersistentRedisConfigInfo
-    : public Persistent<SysRedisConfigEntryPB, SysRowEntryType::REDIS_CONFIG> {};
+struct PersistentRedisConfigInfo : public Persistent<SysRedisConfigEntryPB> {};
 
 class RedisConfigInfo : public RefCountedThreadSafe<RedisConfigInfo>,
                         public MetadataCowWrapper<PersistentRedisConfigInfo> {
@@ -973,7 +969,7 @@ class RedisConfigInfo : public RefCountedThreadSafe<RedisConfigInfo>,
   DISALLOW_COPY_AND_ASSIGN(RedisConfigInfo);
 };
 
-struct PersistentRoleInfo : public Persistent<SysRoleEntryPB, SysRowEntryType::ROLE> {};
+struct PersistentRoleInfo : public Persistent<SysRoleEntryPB> {};
 
 class RoleInfo : public RefCountedThreadSafe<RoleInfo>,
                  public MetadataCowWrapper<PersistentRoleInfo> {
@@ -990,8 +986,7 @@ class RoleInfo : public RefCountedThreadSafe<RoleInfo>,
   DISALLOW_COPY_AND_ASSIGN(RoleInfo);
 };
 
-struct PersistentSysConfigInfo
-    : public Persistent<SysConfigEntryPB, SysRowEntryType::SYS_CONFIG> {};
+struct PersistentSysConfigInfo : public Persistent<SysConfigEntryPB> {};
 
 class SysConfigInfo : public RefCountedThreadSafe<SysConfigInfo>,
                       public MetadataCowWrapper<PersistentSysConfigInfo> {
@@ -1103,8 +1098,7 @@ struct SplitTabletIds {
 
 // This wraps around the proto containing CDC stream information. It will be used for
 // CowObject managed access.
-struct PersistentCDCStreamInfo : public Persistent<
-    SysCDCStreamEntryPB, SysRowEntryType::CDC_STREAM> {
+struct PersistentCDCStreamInfo : public Persistent<SysCDCStreamEntryPB> {
   const google::protobuf::RepeatedPtrField<std::string>& table_id() const {
     return pb.table_id();
   }
@@ -1202,7 +1196,7 @@ class UniverseReplicationInfoBase {
 // This wraps around the proto containing universe replication information. It will be used for
 // CowObject managed access.
 struct PersistentUniverseReplicationInfo
-    : public Persistent<SysUniverseReplicationEntryPB, SysRowEntryType::UNIVERSE_REPLICATION> {
+    : public Persistent<SysUniverseReplicationEntryPB> {
   bool is_deleted_or_failed() const {
     return pb.state() == SysUniverseReplicationEntryPB::DELETED
       || pb.state() == SysUniverseReplicationEntryPB::DELETED_ERROR
@@ -1251,8 +1245,7 @@ class UniverseReplicationInfo : public UniverseReplicationInfoBase,
 // This wraps around the proto containing universe replication information. It will be used for
 // CowObject managed access.
 struct PersistentUniverseReplicationBootstrapInfo
-    : public Persistent<
-          SysUniverseReplicationBootstrapEntryPB, SysRowEntryType::UNIVERSE_REPLICATION_BOOTSTRAP> {
+    : public Persistent<SysUniverseReplicationBootstrapEntryPB> {
   bool is_deleted_or_failed() const {
     return pb.state() == SysUniverseReplicationBootstrapEntryPB::DELETED ||
            pb.state() == SysUniverseReplicationBootstrapEntryPB::DELETED_ERROR ||
@@ -1343,7 +1336,7 @@ class UniverseReplicationBootstrapInfo
 // The data related to a snapshot which is persisted on disk.
 // This portion of SnapshotInfo is managed via CowObject.
 // It wraps the underlying protobuf to add useful accessors.
-struct PersistentSnapshotInfo : public Persistent<SysSnapshotEntryPB, SysRowEntryType::SNAPSHOT> {
+struct PersistentSnapshotInfo : public Persistent<SysSnapshotEntryPB> {
   SysSnapshotEntryPB::State state() const {
     return pb.state();
   }
diff --git a/src/yb/master/catalog_entity_parser.cc b/src/yb/master/catalog_entity_parser.cc
new file mode 100644
index 0000000000..fb313c493e
--- /dev/null
+++ b/src/yb/master/catalog_entity_parser.cc
@@ -0,0 +1,87 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/master/catalog_entity_parser.h"
+
+#include "google/protobuf/text_format.h"
+
+#include "yb/master/catalog_entity_info.pb.h"
+#include "yb/master/master_backup.pb.h"
+#include "yb/master/catalog_entity_types.h"
+
+#include "yb/util/pb_util.h"
+
+namespace yb::master {
+
+// -----------------------------------------------------------------------------
+// SWITCH_FOR_EACH_CATALOG_ENTITY_TYPE
+// -----------------------------------------------------------------------------
+//
+// Macro to switch case over all the SysRowEntryType and call the provided macro for each case.
+//
+// Ex:
+// void PrintPBType(SysRowEntryType type) {
+// #define HANDLE_CASE(entry_type, pb_type)
+//   LOG(INFO) << "PB type for " << SysRowEntryType_Name(entry_type) << " is " << \'
+//   BOOST_PP_STRINGIZE(pb_type);
+//
+//  SWITCH_FOR_EACH_CATALOG_ENTITY_TYPE(HANDLE_CASE, type);
+//
+// #undef HANDLE_CASE
+// }
+//
+#define SWITCH_FOR_EACH_CATALOG_ENTITY_TYPE(_macro, _input_type) \
+  static_assert( \
+      std::is_same<decltype(_input_type), SysRowEntryType>::value, \
+      "Expecting a SysRowEntryType type"); \
+  switch (_input_type) { \
+    BOOST_PP_SEQ_FOR_EACH(_SWITCH_CASE_FOR_CATALOG_ENTITY_TYPE, _macro, CATALOG_ENTITY_TYPE_MAP) \
+    case SysRowEntryType::UNKNOWN: \
+      return STATUS_FORMAT( \
+          InvalidArgument, "Unsupported catalog entry type $0", \
+          SysRowEntryType_Name(SysRowEntryType::UNKNOWN)); \
+  } \
+  return STATUS(InvalidArgument, Format("Unkown catalog entry type: $0", _input_type))
+
+#define _GET_CATALOG_ENTITY_TYPE_FROM_ELEM(_entry_type, _pb_type) _entry_type
+
+#define _SWITCH_CASE_FOR_CATALOG_ENTITY_TYPE(r, macro, elem) \
+  case SysRowEntryType::_GET_CATALOG_ENTITY_TYPE_FROM_ELEM elem: { \
+    macro elem \
+  } break;
+
+Result<std::unique_ptr<google::protobuf::Message>> DebugStringToCatalogEntityPB(
+    SysRowEntryType type, const std::string& debug_string) {
+#define HANDLE_CASE(entry_type, pb_type) \
+  auto new_pb = std::make_unique<pb_type>(); \
+  SCHECK_FORMAT( \
+      google::protobuf::TextFormat::ParseFromString(debug_string, new_pb.get()), InvalidArgument, \
+      "Failed to parse debug string into type $0", SysRowEntryType_Name(entry_type)); \
+  return new_pb;
+
+  SWITCH_FOR_EACH_CATALOG_ENTITY_TYPE(HANDLE_CASE, type);
+
+#undef HANDLE_CASE
+}
+
+Result<std::unique_ptr<google::protobuf::Message>> SliceToCatalogEntityPB(
+    SysRowEntryType type, const Slice& data) {
+#define HANDLE_CASE(_entry_type, _pb_type) \
+  return std::make_unique<_pb_type>(VERIFY_RESULT(pb_util::ParseFromSlice<_pb_type>(data)));
+
+  SWITCH_FOR_EACH_CATALOG_ENTITY_TYPE(HANDLE_CASE, type);
+
+#undef HANDLE_CASE
+}
+
+}  // namespace yb::master
diff --git a/src/yb/master/catalog_entity_parser.h b/src/yb/master/catalog_entity_parser.h
new file mode 100644
index 0000000000..c1afbf6bc8
--- /dev/null
+++ b/src/yb/master/catalog_entity_parser.h
@@ -0,0 +1,34 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include <google/protobuf/message.h>
+
+#include "yb/master/master_types.pb.h"
+
+#include "yb/util/result.h"
+#include "yb/util/slice.h"
+
+namespace yb::master {
+
+// Converts a debug string (produced by pb.DebugString(), or pb.ShortDebugString()) into a catalog
+// entity protobuf of the given type.
+Result<std::unique_ptr<google::protobuf::Message>> DebugStringToCatalogEntityPB(
+    SysRowEntryType type, const std::string& debug_string);
+
+// Converts a slice into a catalog entity protobuf of the given type.
+Result<std::unique_ptr<google::protobuf::Message>> SliceToCatalogEntityPB(
+    SysRowEntryType type, const Slice& data);
+
+}  // namespace yb::master
diff --git a/src/yb/master/catalog_entity_types.h b/src/yb/master/catalog_entity_types.h
new file mode 100644
index 0000000000..2256d9c0c2
--- /dev/null
+++ b/src/yb/master/catalog_entity_types.h
@@ -0,0 +1,86 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include <boost/preprocessor/list/for_each.hpp>
+#include <boost/preprocessor/seq/for_each.hpp>
+#include <boost/preprocessor/seq/to_list.hpp>
+
+#include "yb/master/master_types.pb.h"
+
+#pragma once
+
+namespace yb::master {
+
+class SysRowEntry;
+
+// -----------------------------------------------------------------------------
+// CATALOG_ENTITY_TYPE_MAP
+// -----------------------------------------------------------------------------
+//
+// SysRowEntryType to SysCatalog entity PB type mapping
+// Add new entries to the end of the list.
+
+#define CATALOG_ENTITY_TYPE_MAP \
+  ((TABLE, SysTablesEntryPB)) \
+  ((TABLET, SysTabletsEntryPB)) \
+  ((CLUSTER_CONFIG, SysClusterConfigEntryPB)) \
+  ((NAMESPACE, SysNamespaceEntryPB)) \
+  ((UDTYPE, SysUDTypeEntryPB)) \
+  ((ROLE, SysRoleEntryPB)) \
+  ((SNAPSHOT, SysSnapshotEntryPB)) \
+  ((REDIS_CONFIG, SysRedisConfigEntryPB)) \
+  ((SYS_CONFIG, SysConfigEntryPB)) \
+  ((CDC_STREAM, SysCDCStreamEntryPB)) \
+  ((UNIVERSE_REPLICATION, SysUniverseReplicationEntryPB)) \
+  ((SNAPSHOT_SCHEDULE, SnapshotScheduleOptionsPB)) \
+  ((DDL_LOG_ENTRY, DdlLogEntryPB)) \
+  ((SNAPSHOT_RESTORATION, SysRestorationEntryPB)) \
+  ((XCLUSTER_SAFE_TIME, XClusterSafeTimePB)) \
+  ((XCLUSTER_CONFIG, SysXClusterConfigEntryPB)) \
+  ((UNIVERSE_REPLICATION_BOOTSTRAP, SysUniverseReplicationBootstrapEntryPB)) \
+  ((XCLUSTER_OUTBOUND_REPLICATION_GROUP, SysXClusterOutboundReplicationGroupEntryPB)) \
+  ((CLONE_STATE, SysCloneStatePB)) \
+
+// We should have an entry for each SysRowEntryType in the map except for UNKNOWN.
+static_assert(
+    BOOST_PP_SEQ_SIZE(CATALOG_ENTITY_TYPE_MAP) == (yb::master::SysRowEntryType_ARRAYSIZE - 1),
+    "CATALOG_ENTITY_TYPE_MAP must contain all SysRowEntryType entries");
+
+// -----------------------------------------------------------------------------
+// GetCatalogEntityType
+// -----------------------------------------------------------------------------
+//
+// Template types to retrieve the SysRowEntryType from a catalog entity PB.
+// Ex:
+//  GetCatalogEntityType<SysTablesEntryPB>::value will return yb::master::SysRowEntryType::TABLE
+
+template <class PB>
+struct GetCatalogEntityType;
+
+#define DO_CATALOG_ENTITY_TYPE_OF(entry_type, pb_type) \
+  class pb_type; \
+  template <> \
+  struct GetCatalogEntityType<pb_type> \
+      : public std::integral_constant< \
+            yb::master::SysRowEntryType, yb::master::SysRowEntryType::entry_type> {};
+
+#define CATALOG_ENTITY_TYPE_OF(r, data, elem) DO_CATALOG_ENTITY_TYPE_OF elem
+
+// Generate type specializations for all the catalog entity types.
+// Ex:
+//    GetCatalogEntityType<SysTablesEntryPB> :
+//      public std::integral_constant<yb::master::SysRowEntryType,
+//        yb::master::SysRowEntryType::TABLE> {};
+BOOST_PP_SEQ_FOR_EACH(CATALOG_ENTITY_TYPE_OF, ~, CATALOG_ENTITY_TYPE_MAP);
+
+}  // namespace yb::master
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 58b109fd1f..07a42f3dde 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -120,6 +120,7 @@
 #include "yb/master/async_rpc_tasks.h"
 #include "yb/master/backfill_index.h"
 #include "yb/master/catalog_entity_info.h"
+#include "yb/master/catalog_entity_parser.h"
 #include "yb/master/catalog_loaders.h"
 #include "yb/master/catalog_manager-internal.h"
 #include "yb/master/catalog_manager_bg_tasks.h"
@@ -580,6 +581,11 @@ DEFINE_RUNTIME_uint32(initial_tserver_registration_duration_secs,
     "registered.");
 TAG_FLAG(initial_tserver_registration_duration_secs, advanced);
 
+DEFINE_NON_RUNTIME_bool(emergency_repair_mode, false,
+    "Starts yb-master in emergency repair mode where CatalogManager is not started.");
+TAG_FLAG(emergency_repair_mode, advanced);
+TAG_FLAG(emergency_repair_mode, unsafe);
+
 DECLARE_bool(ysql_yb_enable_replica_identity);
 
 DECLARE_bool(enable_pg_cron);
@@ -864,6 +870,22 @@ bool IsPgCronJobTable(const CreateTableRequestPB& req) {
          req.schema().pgschema_name() == "cron" && req.name() == "job";
 }
 
+Result<QLWriteRequestPB::QLStmtType> ToQLStmtType(
+    WriteSysCatalogEntryRequestPB::WriteOp pb_op_type) {
+  switch (pb_op_type) {
+    case WriteSysCatalogEntryRequestPB::SYS_CATALOG_INSERT:
+      return QLWriteRequestPB::QL_STMT_INSERT;
+    case WriteSysCatalogEntryRequestPB::SYS_CATALOG_UPDATE:
+      return QLWriteRequestPB::QL_STMT_UPDATE;
+    case WriteSysCatalogEntryRequestPB::SYS_CATALOG_DELETE:
+      return QLWriteRequestPB::QL_STMT_DELETE;
+  }
+
+  return STATUS_FORMAT(
+      InvalidArgument, "Unsupported type $0",
+      WriteSysCatalogEntryRequestPB::WriteOp_Name(pb_op_type));
+}
+
 }  // anonymous namespace
 
 ////////////////////////////////////////////////////////////
@@ -1038,6 +1060,12 @@ XClusterManagerIf* CatalogManager::GetXClusterManager() {
 }
 
 Status CatalogManager::ElectedAsLeaderCb() {
+  if (FLAGS_emergency_repair_mode) {
+    // In this mode the sys_catalog leader will not start CatalogManager. The only operations that
+    // can be performed in this mode are DumpSysCatalogEntries and WriteSysCatalogEntry.
+    return Status::OK();
+  }
+
   time_elected_leader_.store(MonoTime::Now());
   return leader_initialization_pool_->SubmitClosure(
       Bind(&CatalogManager::LoadSysCatalogDataTask, Unretained(this)));
@@ -12931,5 +12959,83 @@ Status CatalogManager::GetTableGroupAndColocationInfo(
   return Status::OK();
 }
 
+Result<std::vector<SysCatalogEntryDumpPB>> CatalogManager::FetchFromSysCatalog(
+    SysRowEntryType type, const std::string& item_id_filter) {
+  SCHECK_NOTNULL(sys_catalog_);
+  SCHECK_NOTNULL(tablet_peer());
+  auto tablet = VERIFY_RESULT(tablet_peer()->shared_tablet_safe());
+
+  std::vector<SysCatalogEntryDumpPB> result;
+
+  RETURN_NOT_OK(EnumerateSysCatalog(
+      tablet.get(), schema(), type,
+      [&item_id_filter, &result, &type](const Slice& id, const Slice& data) -> Status {
+        if (!item_id_filter.empty() && item_id_filter != id.ToString()) {
+          return Status::OK();
+        }
+
+        auto entry_pb = VERIFY_RESULT(SliceToCatalogEntityPB(type, data));
+        auto& entry = result.emplace_back();
+        entry.set_entry_type(type);
+        entry.set_entity_id(id.ToString());
+        entry.set_pb_debug_string(entry_pb->DebugString());
+
+        return Status::OK();
+      }));
+
+  return result;
+}
+
+Status CatalogManager::WriteToSysCatalog(
+    SysRowEntryType type, const std::string& item_id, const std::string& debug_string,
+    QLWriteRequestPB::QLStmtType op_type) {
+  auto pb = VERIFY_RESULT(DebugStringToCatalogEntityPB(type, debug_string));
+  LOG_WITH_FUNC(WARNING) << "Updating Sys Catalog. OpType: "
+                         << QLWriteRequestPB::QLStmtType_Name(op_type)
+                         << ", EntryType: " << SysRowEntryType_Name(type)
+                         << ", EntryId: " << item_id << ", EntryData: " << pb->DebugString();
+
+  SCHECK_NOTNULL(sys_catalog_);
+
+  // We need to lookup the consensus object for the current term because the leader_ready_term_
+  // field is only set upon sys catalog load. We cannot use LeaderEpoch either as that is set
+  // through the scoped leader shared lock which we cannot when in emergency_repair_mode.
+  auto consensus = VERIFY_RESULT(tablet_peer()->GetConsensus());
+  consensus::ConsensusStatePB consensus_state;
+  RETURN_NOT_OK(GetCurrentConfig(&consensus_state));
+
+  return sys_catalog_->ForceWrite(
+      type, item_id, *pb.get(), op_type, consensus_state.current_term());
+}
+
+Status CatalogManager::DumpSysCatalogEntries(
+    const DumpSysCatalogEntriesRequestPB* req, DumpSysCatalogEntriesResponsePB* resp,
+    rpc::RpcContext* rpc) {
+  LOG_WITH_FUNC(INFO) << req->ShortDebugString() << ", from: " << RequestorString(rpc);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, entry_type);
+
+  auto entries = VERIFY_RESULT(FetchFromSysCatalog(req->entry_type(), req->entity_id_filter()));
+  for (auto& entry : entries) {
+    *resp->add_entries() = std::move(entry);
+  }
+
+  return Status::OK();
+}
+
+Status CatalogManager::WriteSysCatalogEntry(
+    const WriteSysCatalogEntryRequestPB* req, WriteSysCatalogEntryResponsePB* resp,
+    rpc::RpcContext* rpc) {
+  LOG_WITH_FUNC(INFO) << req->ShortDebugString() << ", from: " << RequestorString(rpc);
+  SCHECK_PB_FIELDS_NOT_EMPTY(*req, entry_type);
+  SCHECK_PB_FIELDS_SET(*req, op_type);
+  SCHECK(
+      FLAGS_emergency_repair_mode, IllegalState,
+      "Updating sys_catalog is only allowed in emergency repair mode");
+
+  auto statement_type = VERIFY_RESULT(ToQLStmtType(req->op_type()));
+  return WriteToSysCatalog(
+      req->entry_type(), req->entity_id(), req->pb_debug_string(), statement_type);
+}
+
 }  // namespace master
 }  // namespace yb
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index 2a34a50563..e8933cda81 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -1088,6 +1088,14 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
       const SplitTabletRequestPB* req, SplitTabletResponsePB* resp, rpc::RpcContext* rpc,
       const LeaderEpoch& epoch);
 
+  Status DumpSysCatalogEntries(
+      const DumpSysCatalogEntriesRequestPB* req, DumpSysCatalogEntriesResponsePB* resp,
+      rpc::RpcContext* rpc);
+
+  Status WriteSysCatalogEntry(
+      const WriteSysCatalogEntryRequestPB* req, WriteSysCatalogEntryResponsePB* resp,
+      rpc::RpcContext* rpc);
+
   // Deletes a tablet that is no longer serving user requests. This would require that the tablet
   // has been split and both of its children are now in RUNNING state and serving user requests
   // instead.
@@ -1617,6 +1625,13 @@ class CatalogManager : public tserver::TabletPeerLookupIf,
   Status CreateTransactionAwareSnapshot(
       const CreateSnapshotRequestPB& req, CreateSnapshotResponsePB* resp, CoarseTimePoint deadline);
 
+  Result<std::vector<SysCatalogEntryDumpPB>> FetchFromSysCatalog(
+      SysRowEntryType type, const std::string& item_id_filter);
+
+  Status WriteToSysCatalog(
+      SysRowEntryType type, const std::string& item_id, const std::string& debug_string,
+      QLWriteRequestPB::QLStmtType op_type);
+
  protected:
   // TODO Get rid of these friend classes and introduce formal interface.
   friend class TableLoader;
diff --git a/src/yb/master/clone/clone_state_entity.h b/src/yb/master/clone/clone_state_entity.h
index bc61239a5c..a0902af5e2 100644
--- a/src/yb/master/clone/clone_state_entity.h
+++ b/src/yb/master/clone/clone_state_entity.h
@@ -21,8 +21,7 @@
 
 namespace yb::master {
 
-struct PersistentCloneStateInfo : public Persistent<SysCloneStatePB, SysRowEntryType::CLONE_STATE>
-  {};
+struct PersistentCloneStateInfo : public Persistent<SysCloneStatePB> {};
 
 struct CloneStateInfoHelpers {
   static bool IsDone(const SysCloneStatePB& pb) {
diff --git a/src/yb/master/master_admin.proto b/src/yb/master/master_admin.proto
index 43b8448e16..15e1ac715a 100644
--- a/src/yb/master/master_admin.proto
+++ b/src/yb/master/master_admin.proto
@@ -258,6 +258,40 @@ message GetMasterHeartbeatDelaysResponsePB {
   repeated MasterHeartbeatDelay heartbeat_delay = 2;
 }
 
+message DumpSysCatalogEntriesRequestPB {
+  optional SysRowEntryType entry_type = 1;
+  optional string entity_id_filter = 2;
+}
+
+message SysCatalogEntryDumpPB {
+  optional SysRowEntryType entry_type = 1;
+  optional string entity_id = 2;
+  optional string pb_debug_string = 3;
+}
+
+message DumpSysCatalogEntriesResponsePB {
+  optional MasterErrorPB error = 1;
+  repeated SysCatalogEntryDumpPB entries = 2;
+}
+
+message WriteSysCatalogEntryRequestPB {
+  optional SysRowEntryType entry_type = 1;
+  optional string entity_id = 2;
+  optional string pb_debug_string = 3;
+
+  enum WriteOp {
+    SYS_CATALOG_INSERT = 1;
+    SYS_CATALOG_UPDATE = 2;
+    SYS_CATALOG_DELETE = 3;
+  }
+
+  optional WriteOp op_type = 4;
+}
+
+message WriteSysCatalogEntryResponsePB {
+  optional MasterErrorPB error = 1;
+}
+
 service MasterAdmin {
   option (yb.rpc.custom_service_name) = "yb.master.MasterService";
 
@@ -305,4 +339,9 @@ service MasterAdmin {
       returns (AccessYsqlBackendsManagerTestRegisterResponsePB);
   rpc WaitForYsqlBackendsCatalogVersion(WaitForYsqlBackendsCatalogVersionRequestPB)
       returns (WaitForYsqlBackendsCatalogVersionResponsePB);
+
+  rpc DumpSysCatalogEntries(DumpSysCatalogEntriesRequestPB)
+      returns (DumpSysCatalogEntriesResponsePB);
+  rpc WriteSysCatalogEntry(WriteSysCatalogEntryRequestPB)
+      returns (WriteSysCatalogEntryResponsePB);
 }
diff --git a/src/yb/master/master_admin_service.cc b/src/yb/master/master_admin_service.cc
index 23748b73ec..ca4bf75f2a 100644
--- a/src/yb/master/master_admin_service.cc
+++ b/src/yb/master/master_admin_service.cc
@@ -41,6 +41,34 @@ class MasterAdminServiceImpl : public MasterServiceBase, public MasterAdminIf {
     HANDLE_ON_LEADER_WITHOUT_LOCK(CatalogManager, IsInitDbDone);
   }
 
+  void DumpSysCatalogEntries(
+      const DumpSysCatalogEntriesRequestPB* req, DumpSysCatalogEntriesResponsePB* resp,
+      rpc::RpcContext rpc) override {
+    // We cannot use HANDLE_ON_LEADER since leader_status may be bad.
+
+    SCOPED_LEADER_SHARED_LOCK(l, server_->catalog_manager_impl());
+    if (!l.CheckIsInitializedOrRespond(resp, &rpc)) {
+      return;
+    }
+    auto s = server_->catalog_manager_impl()->DumpSysCatalogEntries(req, resp, &rpc);
+    CheckRespErrorOrSetUnknown(s, resp);
+    rpc.RespondSuccess();
+  }
+
+  void WriteSysCatalogEntry(
+      const WriteSysCatalogEntryRequestPB* req, WriteSysCatalogEntryResponsePB* resp,
+      rpc::RpcContext rpc) override {
+    // We cannot use HANDLE_ON_LEADER since leader_status may be bad.
+
+    SCOPED_LEADER_SHARED_LOCK(l, server_->catalog_manager_impl());
+    if (!l.CheckIsInitializedOrRespond(resp, &rpc)) {
+      return;
+    }
+    auto s = server_->catalog_manager_impl()->WriteSysCatalogEntry(req, resp, &rpc);
+    CheckRespErrorOrSetUnknown(s, resp);
+    rpc.RespondSuccess();
+  }
+
   MASTER_SERVICE_IMPL_ON_LEADER_WITH_LOCK(
       CatalogManager,
       (AddTransactionStatusTablet)
diff --git a/src/yb/master/master_cluster_service.cc b/src/yb/master/master_cluster_service.cc
index a35ba2f282..9190ecd675 100644
--- a/src/yb/master/master_cluster_service.cc
+++ b/src/yb/master/master_cluster_service.cc
@@ -36,6 +36,8 @@ DEFINE_UNKNOWN_double(master_slow_get_registration_probability, 0,
               "Probability of injecting delay in GetMasterRegistration.");
 DECLARE_bool(enable_ysql_tablespaces_for_placement);
 
+DECLARE_bool(emergency_repair_mode);
+
 using namespace std::literals;
 
 namespace yb {
@@ -236,7 +238,10 @@ class MasterClusterServiceImpl : public MasterServiceBase, public MasterClusterI
     Status s = server_->GetMasterRegistration(resp->mutable_registration());
     CheckRespErrorOrSetUnknown(s, resp);
     auto role = server_->catalog_manager_impl()->Role();
-    if (role == PeerRole::LEADER) {
+    if (role == PeerRole::LEADER && !FLAGS_emergency_repair_mode) {
+      // When in emergency_repair_mode the CatalogManager is not fully loaded and leader_state will
+      // be invalid. We need to allow the leader to respond to the GetMasterRegistration request so
+      // that the client can then invoke DumpSysCatalogEntries and WriteSysCatalogEntry RPCs.
       if (!l.leader_status().ok()) {
         YB_LOG_EVERY_N_SECS(INFO, 1)
             << "Patching role from leader to follower because of: " << l.leader_status()
diff --git a/src/yb/master/master_types.proto b/src/yb/master/master_types.proto
index 595a3b6342..4008fbcb66 100644
--- a/src/yb/master/master_types.proto
+++ b/src/yb/master/master_types.proto
@@ -48,6 +48,9 @@ enum SysRowEntryType {
   UNIVERSE_REPLICATION_BOOTSTRAP = 17;
   XCLUSTER_OUTBOUND_REPLICATION_GROUP = 18;
   CLONE_STATE = 19;
+
+  // Each value must have a corresponding entry in CATALOG_ENTITY_TYPE_MAP of
+  // catalog_entity_types.h
 }
 
 // Master specific errors use this protobuf.
diff --git a/src/yb/master/restore_sys_catalog_state.cc b/src/yb/master/restore_sys_catalog_state.cc
index 5d40e64885..6807db5679 100644
--- a/src/yb/master/restore_sys_catalog_state.cc
+++ b/src/yb/master/restore_sys_catalog_state.cc
@@ -140,18 +140,6 @@ Result<bool> MatchTable(
   return false;
 }
 
-template <class PB>
-struct GetEntryType;
-
-template<> struct GetEntryType<SysNamespaceEntryPB>
-    : public std::integral_constant<SysRowEntryType, SysRowEntryType::NAMESPACE> {};
-
-template<> struct GetEntryType<SysTablesEntryPB>
-    : public std::integral_constant<SysRowEntryType, SysRowEntryType::TABLE> {};
-
-template<> struct GetEntryType<SysTabletsEntryPB>
-    : public std::integral_constant<SysRowEntryType, SysRowEntryType::TABLET> {};
-
 Status ValidateSysCatalogTables(
     const std::unordered_set<TableId>& restoring_tables,
     const std::unordered_map<TableId, TableName>& existing_tables) {
@@ -530,7 +518,7 @@ Status RestoreSysCatalogState::AddRestoringEntry(
 template <class PB>
 Status RestoreSysCatalogState::PatchAndAddRestoringEntry(
     const std::string& id, PB* pb, faststring* buffer) {
-  auto type = GetEntryType<PB>::value;
+  auto type = GetCatalogEntityType<PB>::value;
   VLOG_WITH_FUNC(1) << SysRowEntryType_Name(type) << ": " << id << ", " << pb->ShortDebugString();
 
   if (!VERIFY_RESULT(PatchRestoringEntry(id, pb))) {
@@ -759,7 +747,7 @@ Status RestoreSysCatalogState::IterateSysCatalog(
       projection, doc_read_context, TransactionOperationContext(), doc_db,
       docdb::ReadOperationData::FromSingleReadTime(read_time), pending_op, nullptr);
   return EnumerateSysCatalog(
-      &iter, doc_read_context.schema(), GetEntryType<PB>::value, [map, sequences_data_map](
+      &iter, doc_read_context.schema(), GetCatalogEntityType<PB>::value, [map, sequences_data_map](
           const Slice& id, const Slice& data) -> Status {
     auto pb = VERIFY_RESULT(pb_util::ParseFromSlice<PB>(data));
     if (!ShouldLoadObject(pb)) {
@@ -768,12 +756,12 @@ Status RestoreSysCatalogState::IterateSysCatalog(
     if (IsSequencesDataObject(id.ToBuffer(), pb)) {
       if (!sequences_data_map->emplace(id.ToBuffer(), pb).second) {
         return STATUS_FORMAT(IllegalState, "Duplicate $0: $1",
-                             SysRowEntryType_Name(GetEntryType<PB>::value), id.ToBuffer());
+                             SysRowEntryType_Name(GetCatalogEntityType<PB>::value), id.ToBuffer());
       }
     }
     if (!map->emplace(id.ToBuffer(), std::move(pb)).second) {
       return STATUS_FORMAT(IllegalState, "Duplicate $0: $1",
-                           SysRowEntryType_Name(GetEntryType<PB>::value), id.ToBuffer());
+                           SysRowEntryType_Name(GetCatalogEntityType<PB>::value), id.ToBuffer());
     }
     return Status::OK();
   });
diff --git a/src/yb/master/sys_catalog.cc b/src/yb/master/sys_catalog.cc
index fbafec4c39..3132413a1b 100644
--- a/src/yb/master/sys_catalog.cc
+++ b/src/yb/master/sys_catalog.cc
@@ -2020,6 +2020,14 @@ Result<PgTableReadData> SysCatalogTable::TableReadData(
   return TableReadData(GetPgsqlTableId(database_oid, table_oid), read_ht);
 }
 
+Status SysCatalogTable::ForceWrite(
+    int8_t type, const std::string& item_id, const google::protobuf::Message& pb,
+    QLWriteRequestPB::QLStmtType op_type, int64_t leader_term) {
+  auto writer = NewWriter(leader_term);
+  RETURN_NOT_OK(writer->Mutate(type, item_id, pb, op_type));
+  return SyncWrite(writer.get());
+}
+
 const Schema& PgTableReadData::schema() const {
   return table_info->schema();
 }
diff --git a/src/yb/master/sys_catalog.h b/src/yb/master/sys_catalog.h
index 9465cf8129..655a9c89a1 100644
--- a/src/yb/master/sys_catalog.h
+++ b/src/yb/master/sys_catalog.h
@@ -170,6 +170,10 @@ class SysCatalogTable {
   Status ForceMutate(
       QLWriteRequestPB::QLStmtType op_type, int64_t leader_term, Items&&... items);
 
+  Status ForceWrite(
+      int8_t type, const std::string& item_id, const google::protobuf::Message& new_pb,
+      QLWriteRequestPB::QLStmtType op_type, int64_t leader_term);
+
   // ==================================================================
   // Static schema related methods.
   // ==================================================================
diff --git a/src/yb/master/sys_catalog_writer.cc b/src/yb/master/sys_catalog_writer.cc
index e0de2062f2..aff235f0bc 100644
--- a/src/yb/master/sys_catalog_writer.cc
+++ b/src/yb/master/sys_catalog_writer.cc
@@ -116,6 +116,13 @@ Status SysCatalogWriter::DoMutateItem(
       type, item_id, new_pb, op_type, schema_with_ids_, req_->add_ql_write_batch());
 }
 
+Status SysCatalogWriter::Mutate(
+    int8_t type, const std::string& item_id, const google::protobuf::Message& new_pb,
+    QLWriteRequestPB::QLStmtType op_type) {
+  return FillSysCatalogWriteRequest(
+      type, item_id, new_pb, op_type, schema_with_ids_, req_->add_ql_write_batch());
+}
+
 Status SysCatalogWriter::InsertPgsqlTableRow(const Schema& source_schema,
                                              const qlexpr::QLTableRow& source_row,
                                              const TableId& target_table_id,
diff --git a/src/yb/master/sys_catalog_writer.h b/src/yb/master/sys_catalog_writer.h
index ccc4edfd0b..a4fdf67ac5 100644
--- a/src/yb/master/sys_catalog_writer.h
+++ b/src/yb/master/sys_catalog_writer.h
@@ -55,6 +55,10 @@ class SysCatalogWriter {
     return Mutate<require_check>(op_type, std::forward<Items>(items)...);
   }
 
+  Status Mutate(
+      int8_t type, const std::string& item_id, const google::protobuf::Message& new_pb,
+      QLWriteRequestPB::QLStmtType op_type);
+
   Status ForceMutate(QLWriteRequestPB::QLStmtType op_type) {
     return Status::OK();
   }
diff --git a/src/yb/master/xcluster/xcluster_catalog_entity.h b/src/yb/master/xcluster/xcluster_catalog_entity.h
index 20de7ace62..6edac7769a 100644
--- a/src/yb/master/xcluster/xcluster_catalog_entity.h
+++ b/src/yb/master/xcluster/xcluster_catalog_entity.h
@@ -37,15 +37,13 @@
 
 namespace yb::master {
 
-struct PersistentXClusterConfigInfo
-    : public Persistent<SysXClusterConfigEntryPB, SysRowEntryType::XCLUSTER_CONFIG> {};
+struct PersistentXClusterConfigInfo : public Persistent<SysXClusterConfigEntryPB> {};
 
 class XClusterConfigInfo : public SingletonMetadataCowWrapper<PersistentXClusterConfigInfo> {};
 
 DECLARE_SINGLETON_LOADER_CLASS(XClusterConfig, std::string, SysXClusterConfigEntryPB);
 
-struct PersistentXClusterSafeTimeInfo
-    : public Persistent<XClusterSafeTimePB, SysRowEntryType::XCLUSTER_SAFE_TIME> {};
+struct PersistentXClusterSafeTimeInfo : public Persistent<XClusterSafeTimePB> {};
 
 class XClusterSafeTimeInfo : public SingletonMetadataCowWrapper<PersistentXClusterSafeTimeInfo> {
  public:
@@ -55,9 +53,7 @@ class XClusterSafeTimeInfo : public SingletonMetadataCowWrapper<PersistentXClust
 DECLARE_SINGLETON_LOADER_CLASS(XClusterSafeTime, std::string, XClusterSafeTimePB);
 
 struct PersistentXClusterOutboundReplicationGroupInfo
-    : public Persistent<
-          SysXClusterOutboundReplicationGroupEntryPB,
-          SysRowEntryType::XCLUSTER_OUTBOUND_REPLICATION_GROUP> {};
+    : public Persistent<SysXClusterOutboundReplicationGroupEntryPB> {};
 
 class XClusterOutboundReplicationGroupInfo
     : public MetadataCowWrapper<PersistentXClusterOutboundReplicationGroupInfo> {
diff --git a/src/yb/tools/CMakeLists.txt b/src/yb/tools/CMakeLists.txt
index df31ed755f..b35468eabf 100644
--- a/src/yb/tools/CMakeLists.txt
+++ b/src/yb/tools/CMakeLists.txt
@@ -61,6 +61,7 @@ add_executable(yb-admin
 target_link_libraries(yb-admin
   yb-admin_lib
   master_error
+  master_util
   ${LINK_LIBS})
 
 add_library(yb-admin_lib
diff --git a/src/yb/tools/yb-admin-test.cc b/src/yb/tools/yb-admin-test.cc
index b8c2158416..39e98624b5 100644
--- a/src/yb/tools/yb-admin-test.cc
+++ b/src/yb/tools/yb-admin-test.cc
@@ -52,19 +52,17 @@
 #include "yb/integration-tests/cluster_itest_util.h"
 #include "yb/integration-tests/test_workload.h"
 
-#include "yb/master/catalog_entity_info.h"
 #include "yb/master/master_defaults.h"
 #include "yb/master/master_client.pb.h"
 
 #include "yb/tools/admin-test-base.h"
 
+#include "yb/tools/tools_test_utils.h"
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/date_time.h"
 #include "yb/util/format.h"
 #include "yb/util/jsonreader.h"
 #include "yb/util/net/net_util.h"
-#include "yb/util/port_picker.h"
-#include "yb/util/random_util.h"
 #include "yb/util/status_format.h"
 #include "yb/util/subprocess.h"
 
@@ -155,12 +153,58 @@ class BlacklistChecker {
   vector<string> args_;
 };
 
+Result<std::string> ReadFileToString(const std::string& file_path) {
+  faststring contents;
+  RETURN_NOT_OK(yb::ReadFileToString(Env::Default(), file_path, &contents));
+  return contents.ToString();
+  std::string file_contents;
+}
+
 } // namespace
 
 const auto kRollbackAutoFlagsCmd = "rollback_auto_flags";
 const auto kPromoteAutoFlagsCmd = "promote_auto_flags";
+const auto kClusterConfigEntryTypeName =
+    master::SysRowEntryType_Name(master::SysRowEntryType::CLUSTER_CONFIG);
+
+YB_STRONGLY_TYPED_BOOL(EmergencyRepairMode);
 
 class AdminCliTest : public AdminTestBase {
+ public:
+  Result<std::string> GetClusterUuid() {
+    master::GetMasterClusterConfigRequestPB config_req;
+    master::GetMasterClusterConfigResponsePB config_resp;
+    rpc::RpcController rpc;
+    rpc.set_timeout(30s);
+    RETURN_NOT_OK(
+        cluster_->GetLeaderMasterProxy<master::MasterClusterProxy>().GetMasterClusterConfig(
+            config_req, &config_resp, &rpc));
+    if (config_resp.has_error()) {
+      return StatusFromPB(config_resp.error().status());
+    }
+    return config_resp.cluster_config().cluster_uuid();
+  }
+
+  Status RestartMaster(EmergencyRepairMode mode) {
+    const auto kEmergencyRepairModeFlag = "emergency_repair_mode";
+    auto* leader_master = cluster_->GetLeaderMaster();
+    if (mode) {
+      leader_master->AddExtraFlag(kEmergencyRepairModeFlag, "true");
+    } else {
+      leader_master->RemoveExtraFlag(kEmergencyRepairModeFlag);
+    }
+
+    leader_master->Shutdown();
+    return leader_master->Restart();
+  }
+
+  std::string GetTempDir() { return *tmp_dir_; }
+
+  // Dump the cluster config catalog_entry and verify that the dump contains the correct
+  // cluster_uuid.
+  Status TestDumpSysCatalogEntry(const std::string& cluster_uuid);
+
+  TmpDirProvider tmp_dir_;
 };
 
 // Test yb-admin config change while running a workload.
@@ -1450,5 +1494,154 @@ TEST_F(AdminCliTest, TestCompactionStatusAfterCompactionFinishes) {
   ASSERT_GT(last_request_time, time_before_compaction);
 }
 
+Status AdminCliTest::TestDumpSysCatalogEntry(const std::string& cluster_uuid) {
+  const auto dump_file_path = tmp_dir_ / Format("$0-", kClusterConfigEntryTypeName);
+
+  // We should be able to dump the data while not in emergency_repair_mode.
+  auto output =
+      VERIFY_RESULT(CallAdmin("dump_sys_catalog_entries", kClusterConfigEntryTypeName, *tmp_dir_));
+  SCHECK_STR_CONTAINS(output, dump_file_path);
+
+  auto file_contents = VERIFY_RESULT(ReadFileToString(dump_file_path));
+  SCHECK_STR_CONTAINS(file_contents, cluster_uuid);
+  return Status::OK();
+}
+
+TEST_F(AdminCliTest, TestDumpSysCatalogEntryInNonEmergencyMode) {
+  BuildAndStart();
+  const auto cluster_uuid = ASSERT_RESULT(GetClusterUuid());
+  ASSERT_OK(TestDumpSysCatalogEntry(cluster_uuid));
+}
+
+TEST_F(AdminCliTest, TestDumpSysCatalogEntryInEmergencyMode) {
+  BuildAndStart();
+  const auto cluster_uuid = ASSERT_RESULT(GetClusterUuid());
+  ASSERT_OK(RestartMaster(EmergencyRepairMode::kTrue));
+  ASSERT_OK(TestDumpSysCatalogEntry(cluster_uuid));
+  ASSERT_OK(RestartMaster(EmergencyRepairMode::kFalse));
+}
+
+// Make sure we cannot write to sys catalog when not in emergency repair mode.
+TEST_F(AdminCliTest, BlockWriteToSysCatalogEntryInNonEmergencyMode) {
+  BuildAndStart();
+
+  auto env = Env::Default();
+  const auto dump_file_path = tmp_dir_ / Format("$0-", kClusterConfigEntryTypeName);
+
+  master::SysClusterConfigEntryPB dummy_cluster_config;
+  dummy_cluster_config.set_cluster_uuid(Uuid::Generate().ToString());
+
+  ASSERT_OK(WriteStringToFileSync(env, dummy_cluster_config.DebugString(), dump_file_path));
+
+  const auto kExpectedError = "Updating sys_catalog is only allowed in emergency repair mode";
+
+  ASSERT_NOK_STR_CONTAINS(
+      CallAdmin("write_sys_catalog_entry", "delete", kClusterConfigEntryTypeName, "", "", "force"),
+      kExpectedError);
+
+  ASSERT_NOK_STR_CONTAINS(
+      CallAdmin(
+          "write_sys_catalog_entry", "insert", kClusterConfigEntryTypeName, "dummy", dump_file_path,
+          "force"),
+      kExpectedError);
+
+  ASSERT_NOK_STR_CONTAINS(
+      CallAdmin(
+          "write_sys_catalog_entry", "update", kClusterConfigEntryTypeName, "", dump_file_path,
+          "force"),
+      kExpectedError);
+}
+
+// Test insert and delete of CatalogEntity.
+TEST_F(AdminCliTest, TestInsertDeleteSysCatalogEntry) {
+  BuildAndStart();
+  ASSERT_OK(RestartMaster(EmergencyRepairMode::kTrue));
+
+  auto env = Env::Default();
+  const auto second_cluster_config_id = "second_cc";
+
+  master::SysClusterConfigEntryPB second_cluster_config;
+  second_cluster_config.set_cluster_uuid(Uuid::Generate().ToString());
+  const auto file_path =
+      tmp_dir_ / Format("$0-$1", kClusterConfigEntryTypeName, second_cluster_config_id);
+
+  ASSERT_OK(WriteStringToFileSync(env, second_cluster_config.DebugString(), file_path));
+
+  ASSERT_OK(CallAdmin(
+      "write_sys_catalog_entry", "insert", kClusterConfigEntryTypeName, second_cluster_config_id,
+      file_path, "force"));
+
+  auto validate_dump_cluster_config = [&]() -> Status {
+    RETURN_NOT_OK(env->DeleteFile(file_path));
+    auto output = VERIFY_RESULT(CallAdmin(
+        "dump_sys_catalog_entries", kClusterConfigEntryTypeName, *tmp_dir_,
+        second_cluster_config_id));
+    SCHECK_STR_CONTAINS(output, file_path);
+    auto file_contents = VERIFY_RESULT(ReadFileToString(file_path));
+    SCHECK_STR_CONTAINS(file_contents, second_cluster_config.cluster_uuid());
+    return Status::OK();
+  };
+
+  // Dump the new entry to make sure it was updated.
+  ASSERT_OK(validate_dump_cluster_config());
+
+  // Restart the master and dump the new entry to make sure it was persisted.
+  auto* leader_master = cluster_->GetLeaderMaster();
+  leader_master->Shutdown();
+  ASSERT_OK(leader_master->Restart());
+
+  ASSERT_OK(validate_dump_cluster_config());
+
+  // Delete the second entry.
+  ASSERT_OK(CallAdmin(
+      "write_sys_catalog_entry", "delete", kClusterConfigEntryTypeName, second_cluster_config_id,
+      "", "force"));
+
+  auto output = ASSERT_RESULT(CallAdmin(
+      "dump_sys_catalog_entries", kClusterConfigEntryTypeName, *tmp_dir_,
+      second_cluster_config_id));
+  ASSERT_STR_CONTAINS(output, "Found 0 entries of type CLUSTER_CONFIG");
+
+  // Restart the master to make sure it starts correctly. If the delete did not succeed the master
+  // would crash and fail to start.
+  ASSERT_OK(RestartMaster(EmergencyRepairMode::kFalse));
+  ASSERT_OK(cluster_->WaitForTabletServerCount(cluster_->num_tablet_servers(), 30s));
+}
+
+// Update the ClusterConfig entry in the sys catalog and verify that the change is persisted across
+// master restarts.
+TEST_F(AdminCliTest, TestUpdateSysCatalogEntry) {
+  BuildAndStart();
+  const auto old_cluster_uuid = ASSERT_RESULT(GetClusterUuid());
+  ASSERT_OK(RestartMaster(EmergencyRepairMode::kTrue));
+
+  auto env = Env::Default();
+  const auto file_path = tmp_dir_ / Format("$0-", kClusterConfigEntryTypeName);
+
+  auto new_cluster_uuid = Uuid::Generate().ToString();
+  LOG(INFO) << "Replacing cluster_uuid " << old_cluster_uuid << " with " << new_cluster_uuid;
+
+  master::SysClusterConfigEntryPB new_cluster_config;
+  new_cluster_config.set_cluster_uuid(new_cluster_uuid);
+  ASSERT_OK(WriteStringToFileSync(env, new_cluster_config.DebugString(), file_path));
+
+  auto output = ASSERT_RESULT(CallAdmin(
+      "write_sys_catalog_entry", "update", kClusterConfigEntryTypeName, "", file_path, "force"));
+  ASSERT_STR_CONTAINS(output, new_cluster_uuid);
+
+  ASSERT_OK(RestartMaster(EmergencyRepairMode::kFalse));
+
+  const auto cluster_uuid = ASSERT_RESULT(GetClusterUuid());
+  ASSERT_EQ(cluster_uuid, new_cluster_uuid);
+
+  ASSERT_OK(env->DeleteFile(file_path));
+  output =
+      ASSERT_RESULT(CallAdmin("dump_sys_catalog_entries", kClusterConfigEntryTypeName, *tmp_dir_));
+  ASSERT_STR_CONTAINS(output, file_path);
+  auto file_contents = ASSERT_RESULT(ReadFileToString(file_path));
+  ASSERT_STR_NOT_CONTAINS(file_contents, old_cluster_uuid);
+  ASSERT_STR_CONTAINS(file_contents, new_cluster_uuid);
+}
+
 }  // namespace tools
 }  // namespace yb
diff --git a/src/yb/tools/yb-admin_cli.cc b/src/yb/tools/yb-admin_cli.cc
index 568946ab0d..b2dd849d47 100644
--- a/src/yb/tools/yb-admin_cli.cc
+++ b/src/yb/tools/yb-admin_cli.cc
@@ -55,6 +55,7 @@
 #include "yb/util/flags.h"
 #include "yb/util/logging.h"
 #include "yb/util/monotime.h"
+#include "yb/util/path_util.h"
 #include "yb/util/pb_util.h"
 #include "yb/util/result.h"
 #include "yb/util/status_format.h"
@@ -498,9 +499,10 @@ Status ClusterAdminCli::Run(int argc, char** argv) {
   return RunCommand(command, command_args, args[0]);
 }
 
-void ClusterAdminCli::Register(string&& cmd_name, const std::string& cmd_args, Action&& action) {
+void ClusterAdminCli::Register(
+    string&& cmd_name, const std::string& cmd_args, Action&& action, bool hidden) {
   command_indexes_[cmd_name] = commands_.size();
-  commands_.push_back({std::move(cmd_name), cmd_args, std::move(action)});
+  commands_.push_back({std::move(cmd_name), cmd_args, std::move(action), hidden});
 }
 
 void ClusterAdminCli::SetUsage(const string& prog_name) {
@@ -511,9 +513,12 @@ void ClusterAdminCli::SetUsage(const string& prog_name) {
       << "<operation> must be one of:" << endl;
 
   for (size_t i = 0; i < commands_.size(); ++i) {
-    str << ' ' << i + 1 << ". " << commands_[i].name_
-        << (commands_[i].usage_arguments_.empty() ? "" : " ") << commands_[i].usage_arguments_
-        << endl;
+    const auto& command = commands_[i];
+    if (command.hidden_) {
+      continue;
+    }
+    str << ' ' << i + 1 << ". " << command.name_ << (command.usage_arguments_.empty() ? "" : " ")
+        << command.usage_arguments_ << endl;
   }
 
   str << endl;
@@ -956,6 +961,9 @@ Status change_master_config_action(
   return Status::OK();
 }
 
+// Dump subset of info stored on yb-master in a user friendly format.
+// Requires yb-master and CatalogManager to be running and healthy.
+// Use `dump_sys_catalog_entries` to get on-disk data, or if master is unhealthy.
 const auto dump_masters_state_args = "[CONSOLE]";
 Status dump_masters_state_action(
     const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
@@ -2625,6 +2633,99 @@ Status get_universe_replication_info_action(
   return Status::OK();
 }
 
+// Dump on-disk Catalog Entry infos stored in sys_catalog tablet of yb-master.
+// This can be used even when CatalogManager is unhealthy or completely turned off (yb-master
+// --emergency_repair_mode).
+//
+// If no entry_id is provided all entries of the given type will be dumped
+// out. entry_id can be an empty string. Ex:
+// ./bin/yb-admin -master_addresses 127.0.0.1.9:7100 dump_sys_catalog_entries
+//    UNIVERSE_REPLICATION  /tmp/catalog_dump "rg1"
+//
+// ./bin/yb-admin -master_addresses 127.0.0.1.9:7100 dump_sys_catalog_entries
+//    CLUSTER_CONFIG /tmp/catalog_dump ""
+const auto dump_sys_catalog_entries_args = "<entry_type> <folder_path> [entry_id]";
+Status dump_sys_catalog_entries_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  if (args.size() < 2 || args.size() > 3) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  master::SysRowEntryType entry_type;
+  SCHECK(
+      master::SysRowEntryType_Parse(args[0], &entry_type), InvalidArgument, "Invalid entry type");
+  SCHECK_NE(entry_type, master::SysRowEntryType::UNKNOWN, InvalidArgument, "Invalid entry type");
+
+  std::string folder_path = args[1];
+
+  std::string entry_id_filter;
+  if (args.size() > 2) {
+    entry_id_filter = args[2];
+  }
+
+  return client->DumpSysCatalogEntriesAction(entry_type, /*folder_path=*/args[1], entry_id_filter);
+}
+
+namespace {
+Result<master::WriteSysCatalogEntryRequestPB::WriteOp> ToCatalogEntryWriteOp(
+    const std::string& operation) {
+  if (IsEqCaseInsensitive(operation, "insert")) {
+    return master::WriteSysCatalogEntryRequestPB::SYS_CATALOG_INSERT;
+  }
+  if (IsEqCaseInsensitive(operation, "update")) {
+    return master::WriteSysCatalogEntryRequestPB::SYS_CATALOG_UPDATE;
+  }
+  if (IsEqCaseInsensitive(operation, "delete")) {
+    return master::WriteSysCatalogEntryRequestPB::SYS_CATALOG_DELETE;
+  }
+
+  return STATUS(InvalidArgument, "Invalid operation", operation);
+}
+
+}  // namespace
+// WARNING!! Use with caution! Incorrect usage may result in unavailability, data loss, and/or
+// corruption.
+// - yb-master must be in --emergency_repair_mode.
+//
+// - entry_id can be an empty string. This is because singleton catalog_entity types like
+//   CLUSTER_CONFIG, and XCLUSTER_CONFIG use empty strings as ids.
+// - file_path is not required for DELETE operation.
+// - force will bypass the confirmation prompt.
+// Ex:
+// ./bin/yb-admin -master_addresses 127.0.0.1.9:7100 write_sys_catalog_entry INSERT
+//    UNIVERSE_REPLICATION "rg1" /tmp/catalog_dump/UNIVERSE_REPLICATION-rg1
+//
+// ./bin/yb-admin -master_addresses 127.0.0.1.9:7100 write_sys_catalog_entry DELETE
+//    XCLUSTER_CONFIG ""
+//
+// ./bin/yb-admin -master_addresses 127.0.0.1.9:7100 write_sys_catalog_entry UPDATE
+//    UNIVERSE_REPLICATION "rg1" /tmp/catalog_dump/UNIVERSE_REPLICATION-rg1
+const auto write_sys_catalog_entry_args =
+    "<insert/update/delete> <entry_type> <entry_id> [file_path] [force]";
+Status write_sys_catalog_entry_action(
+    const ClusterAdminCli::CLIArguments& args, ClusterAdminClient* client) {
+  if (args.size() < 3 || args.size() > 5) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  auto operation = VERIFY_RESULT(ToCatalogEntryWriteOp(args[0]));
+  if (operation != master::WriteSysCatalogEntryRequestPB::SYS_CATALOG_DELETE && args.size() < 4) {
+    return ClusterAdminCli::kInvalidArguments;
+  }
+
+  master::SysRowEntryType entry_type;
+  SCHECK(
+      master::SysRowEntryType_Parse(args[1], &entry_type), InvalidArgument, "Invalid entry type");
+  SCHECK_NE(entry_type, master::SysRowEntryType::UNKNOWN, InvalidArgument, "Invalid entry type");
+
+  std::string entry_id = args[2];
+
+  bool force = (args.size() > 3 && IsEqCaseInsensitive(args[args.size() - 1], "force"));
+
+  return client->WriteSysCatalogEntryAction(
+      operation, entry_type, /*entry_id=*/args[2], /*file_path=*/args[3], force);
+}
+
 }  // namespace
 
 void ClusterAdminCli::RegisterCommandHandlers() {
@@ -2758,6 +2859,10 @@ void ClusterAdminCli::RegisterCommandHandlers() {
   REGISTER_COMMAND(repair_xcluster_outbound_replication_remove_table);
   REGISTER_COMMAND(list_xcluster_outbound_replication_groups);
   REGISTER_COMMAND(get_xcluster_outbound_replication_group_info);
+
+  // SysCatalog util commands
+  REGISTER_COMMAND(dump_sys_catalog_entries);
+  REGISTER_COMMAND(write_sys_catalog_entry);
 }
 
 Result<std::vector<client::YBTableName>> ResolveTableNames(
diff --git a/src/yb/tools/yb-admin_cli.h b/src/yb/tools/yb-admin_cli.h
index 39c658992e..d25e622495 100644
--- a/src/yb/tools/yb-admin_cli.h
+++ b/src/yb/tools/yb-admin_cli.h
@@ -69,9 +69,11 @@ class ClusterAdminCli {
     std::string name_;
     std::string usage_arguments_;
     Action action_;
+    bool hidden_;
   };
 
-  void Register(std::string&& cmd_name, const std::string& cmd_args, Action&& action);
+  void Register(
+      std::string&& cmd_name, const std::string& cmd_args, Action&& action, bool hidden = false);
   void SetUsage(const std::string& prog_name);
 
   virtual void RegisterCommandHandlers();
diff --git a/src/yb/tools/yb-admin_client.cc b/src/yb/tools/yb-admin_client.cc
index ec0a3d2536..0beaf8aa88 100644
--- a/src/yb/tools/yb-admin_client.cc
+++ b/src/yb/tools/yb-admin_client.cc
@@ -67,6 +67,7 @@
 #include "yb/gutil/strings/numbers.h"
 #include "yb/gutil/strings/split.h"
 
+#include "yb/master/catalog_entity_parser.h"
 #include "yb/master/master_admin.proxy.h"
 #include "yb/master/master_backup.proxy.h"
 #include "yb/master/master_client.proxy.h"
@@ -4400,6 +4401,129 @@ Status ClusterAdminClient::WaitForAlterXClusterReplication(
   }
 }
 
+Result<master::DumpSysCatalogEntriesResponsePB> ClusterAdminClient::DumpSysCatalogEntries(
+    master::SysRowEntryType entry_type, const std::string& entity_id_filter) {
+  master::DumpSysCatalogEntriesRequestPB req;
+  master::DumpSysCatalogEntriesResponsePB resp;
+  req.set_entry_type(entry_type);
+  req.set_entity_id_filter(entity_id_filter);
+
+  RpcController rpc;
+  rpc.set_timeout(timeout_);
+
+  RETURN_NOT_OK(master_admin_proxy_->DumpSysCatalogEntries(req, &resp, &rpc));
+
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+
+  return resp;
+}
+
+Status ClusterAdminClient::DumpSysCatalogEntriesAction(
+    master::SysRowEntryType entry_type, const std::string& folder_path,
+    const std::string& entry_id_filter) {
+  auto env = Env::Default();
+  if (!env->DirExists(folder_path)) {
+    RETURN_NOT_OK(env->CreateDir(folder_path));
+  }
+
+  const auto resp = VERIFY_RESULT(DumpSysCatalogEntries(entry_type, entry_id_filter));
+
+  std::cout << "Found " << resp.entries().size() << " entries of type "
+            << master::SysRowEntryType_Name(entry_type) << std::endl;
+
+  for (const auto& entry : resp.entries()) {
+    const auto entity_type = master::SysRowEntryType_Name(entry.entry_type());
+    auto file_path = JoinPathSegments(folder_path, Format("$0-$1", entity_type, entry.entity_id()));
+
+    std::cout << std::endl << "Entry Type: " << entity_type << std::endl;
+    std::cout << "Entry ID: " << entry.entity_id() << std::endl;
+    std::cout << "Path to entry data: " << file_path << std::endl;
+
+    if (env->FileExists(file_path)) {
+      RETURN_NOT_OK(env->DeleteFile(file_path));
+    }
+
+    RETURN_NOT_OK(WriteStringToFileSync(env, entry.pb_debug_string(), file_path));
+  }
+
+  return Status::OK();
+}
+
+Status ClusterAdminClient::WriteSysCatalogEntry(
+    master::WriteSysCatalogEntryRequestPB::WriteOp operation, master::SysRowEntryType entry_type,
+    const std::string& entity_id, const std::string& pb_debug_string) {
+  master::WriteSysCatalogEntryRequestPB req;
+  master::WriteSysCatalogEntryResponsePB resp;
+  req.set_entry_type(entry_type);
+  req.set_entity_id(entity_id);
+  req.set_pb_debug_string(pb_debug_string);
+  req.set_op_type(operation);
+
+  RpcController rpc;
+  rpc.set_timeout(timeout_);
+
+  RETURN_NOT_OK(master_admin_proxy_->WriteSysCatalogEntry(req, &resp, &rpc));
+
+  if (resp.has_error()) {
+    return StatusFromPB(resp.error().status());
+  }
+
+  return Status::OK();
+}
+
+Status ClusterAdminClient::WriteSysCatalogEntryAction(
+    master::WriteSysCatalogEntryRequestPB::WriteOp operation, master::SysRowEntryType entry_type,
+    const std::string& entry_id, const std::string& file_path, bool force) {
+  std::cout << "Operation: " << master::WriteSysCatalogEntryRequestPB::WriteOp_Name(operation)
+            << std::endl;
+  std::cout << "Entry Type: " << master::SysRowEntryType_Name(entry_type) << std::endl;
+  std::cout << "Entry Id: " << entry_id << std::endl;
+
+  std::string entity_data;
+  if (operation != master::WriteSysCatalogEntryRequestPB::SYS_CATALOG_DELETE) {
+    faststring contents;
+    RETURN_NOT_OK(ReadFileToString(Env::Default(), file_path, &contents));
+    entity_data = contents.ToString();
+
+    auto new_pb = VERIFY_RESULT(master::DebugStringToCatalogEntityPB(entry_type, entity_data));
+
+    if (operation == master::WriteSysCatalogEntryRequestPB::SYS_CATALOG_INSERT) {
+      std::cout << "Entry Data: " << std::endl << new_pb->DebugString() << std::endl << std::endl;
+    } else {
+      const auto resp = VERIFY_RESULT(DumpSysCatalogEntries(entry_type, entry_id));
+      SCHECK_EQ(
+          resp.entries().size(), 1, InvalidArgument,
+          "Invalid number of entries match the entity id");
+
+      auto old_pb = VERIFY_RESULT(
+          master::DebugStringToCatalogEntityPB(entry_type, resp.entries(0).pb_debug_string()));
+
+      string diff_str;
+      SCHECK(!pb_util::ArePBsEqual(*old_pb, *new_pb, &diff_str), InvalidArgument, "No changes");
+
+      std::cout << "Entity diff: " << std::endl << diff_str << std::endl;
+    }
+  }
+  std::cout << std::endl;
+
+  if (!force) {
+    std::cout << "WARNING: Incorrect modifications to the YugabyteDB system catalog can lead to "
+                 "outages, corruptions or data loss!"
+              << std::endl;
+    std::cout << "Are you sure you want to proceed? (y/N)" << std::endl;
+    std::string answer;
+    std::cin >> answer;
+    SCHECK(answer == "y" || answer == "Y", InvalidArgument, "Aborted");
+  }
+
+  RETURN_NOT_OK(WriteSysCatalogEntry(operation, entry_type, entry_id, entity_data));
+
+  std::cout << std::endl << "Successfully updated the YugabyteDB system catalog." << std::endl;
+  return Status::OK();
+}
+
 client::XClusterClient ClusterAdminClient::XClusterClient() {
   return client::XClusterClient(*yb_client_);
 }
diff --git a/src/yb/tools/yb-admin_client.h b/src/yb/tools/yb-admin_client.h
index e41b57c6ce..725d58056f 100644
--- a/src/yb/tools/yb-admin_client.h
+++ b/src/yb/tools/yb-admin_client.h
@@ -481,6 +481,21 @@ class ClusterAdminClient {
   using NamespaceMap = std::unordered_map<NamespaceId, client::NamespaceInfo>;
   Result<const NamespaceMap&> GetNamespaceMap(bool include_nonrunning = false);
 
+  Result<master::DumpSysCatalogEntriesResponsePB> DumpSysCatalogEntries(
+      master::SysRowEntryType entry_type, const std::string& entity_id_filter);
+
+  Status DumpSysCatalogEntriesAction(
+      master::SysRowEntryType entry_type, const std::string& folder_path,
+      const std::string& entry_id_filter);
+
+  Status WriteSysCatalogEntry(
+      master::WriteSysCatalogEntryRequestPB::WriteOp operation, master::SysRowEntryType entry_type,
+      const std::string& entity_id, const std::string& pb_debug_string);
+
+  Status WriteSysCatalogEntryAction(
+      master::WriteSysCatalogEntryRequestPB::WriteOp operation, master::SysRowEntryType entry_type,
+      const std::string& entry_id, const std::string& file_path, bool force);
+
  protected:
   // Fetch the locations of the replicas for a given tablet from the Master.
   Status GetTabletLocations(const TabletId& tablet_id,
diff --git a/src/yb/util/status_format.h b/src/yb/util/status_format.h
index 52b4f946b4..1d5aa18ced 100644
--- a/src/yb/util/status_format.h
+++ b/src/yb/util/status_format.h
@@ -82,6 +82,11 @@
       SCHECK_LE(var1, rbound, status_type, msg); \
     } while(false)
 
+#define SCHECK_STR_CONTAINS(str, substr) \
+  SCHECK_NE( \
+      str.find(substr), std::string::npos, NotFound, \
+      Format("'$0' does not contain '$1'", str, substr))
+
 #ifndef NDEBUG
 
 // Debug mode ("not defined NDEBUG (non-debug-mode)" means "debug mode").
