diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
index e4f78f2801..6556705bd1 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
@@ -146,6 +146,26 @@ TEST_F(XClusterDDLReplicationTest, BasicSetupAlterTeardown) {
   ASSERT_OK(VerifyDDLExtensionTablesDeletion(namespace_name2));
 }
 
+// We have a temporary fix for this test that we are applying only in non-debug builds.  We do this
+// so we will catch other tests that need the same permanent fix.  See #27622.
+TEST_F(XClusterDDLReplicationTest, YB_NEVER_DEBUG_TEST(CheckpointMultipleDatabases)) {
+  ASSERT_OK(SetUpClusters());
+
+  std::vector<NamespaceName> namespaces{namespace_name};
+  for (int i = 0; i < base::NumCPUs() * 2; i++) {
+    auto name = Format("db_$0", i);
+    ASSERT_OK(CreateDatabase(&producer_cluster_, name, false));
+    auto conn = ASSERT_RESULT(producer_cluster_.ConnectToDB(name));
+    ASSERT_OK(conn.Execute("CREATE TABLE tbl2(a int)"));
+    namespaces.push_back(name);
+  }
+
+  google::SetVLOGLevel("catalog_manager", 2);
+  google::SetVLOGLevel("async_rpc_tests", 1);
+  google::SetVLOGLevel("async_rpc_tests_base", 4);
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces(namespaces));
+}
+
 TEST_F(XClusterDDLReplicationTest, YB_DISABLE_TEST_ON_MACOS(SurviveRestarts)) {
   ASSERT_OK(SetUpClustersAndCheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 0a2d38ae8e..0460aa0389 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -980,7 +980,17 @@ CatalogManager::CatalogManager(Master* master, SysCatalogTable* sys_catalog)
                .set_max_threads(1)
                .Build(&leader_initialization_pool_));
   CHECK_OK(ThreadPoolBuilder("CatalogManagerBGTasks").Build(&background_tasks_thread_pool_));
+  // Temporarily allow unlimited threads on the async_task_pool_ to avoid the bug of #26617.
+  // Continue to allow only a limited number of threads (equal to the number of CPUs) in debug mode
+  // so we can find similar bugs.
+  //
+  // TODO(#27622): longer-term, fix our use of thread pools so we don't run into thread pool
+  // "deadlocks".
+#ifndef NDEBUG
   CHECK_OK(ThreadPoolBuilder("async-tasks").Build(&async_task_pool_));
+#else
+  CHECK_OK(ThreadPoolBuilder("async-tasks").unlimited_threads().Build(&async_task_pool_));
+#endif
   CHECK_OK(sys_catalog_->Start(Bind(&CatalogManager::ElectedAsLeaderCb, Unretained(this))));
   xcluster_manager_ = std::make_unique<XClusterManager>(*master_, *this, *sys_catalog_);
   ysql_manager_ = std::make_unique<YsqlManager>(*master_, *this, *sys_catalog_);
@@ -1786,7 +1796,7 @@ Status CatalogManager::PrepareSysCatalogTable(const LeaderEpoch& epoch) {
   // Prepare sys catalog table info.
   auto sys_catalog_table = tables_->FindTableOrNull(kSysCatalogTableId);
   if (sys_catalog_table == nullptr) {
-    scoped_refptr<TableInfo> table = NewTableInfo(kSysCatalogTableId, false);
+    scoped_refptr<TableInfo> table = NewTableInfo(kSysCatalogTableId, /*colocated=*/false);
     table->mutable_metadata()->StartMutation();
     SysTablesEntryPB& metadata = table->mutable_metadata()->mutable_dirty()->pb;
     metadata.set_state(SysTablesEntryPB::RUNNING);
@@ -3187,7 +3197,7 @@ Status CatalogManager::XReplValidateSplitCandidateTableUnlocked(const TableId& t
   }
 
   if (!FLAGS_enable_tablet_split_of_replication_slot_streamed_tables &&
-      IsTablePartOfCDCSDK(table_id, true /* require_replication_slot */)) {
+      IsTablePartOfCDCSDK(table_id, /*require_replication_slot=*/true)) {
     return STATUS_FORMAT(
         NotSupported,
         "Tablet splitting is not supported for tables that are a part of a replication slot, "
@@ -6487,7 +6497,7 @@ Status CatalogManager::DeleteTable(
                              indexed_table->GetTableType() == PGSQL_TABLE_TYPE;
     if (!is_pg_table && IsIndexBackfillEnabled(index_table_type, is_transactional)) {
       return MarkIndexInfoFromTableForDeletion(
-          indexed_table_id, table_id, /* multi_stage */ true, epoch, resp, nullptr,
+          indexed_table_id, table_id, /*multi_stage=*/true, epoch, resp, /*data_map_ptr=*/nullptr,
           ns_info);
     }
 
@@ -8469,7 +8479,7 @@ Status CatalogManager::DeleteTablegroup(const DeleteTablegroupRequestPB* req,
         }
 
         if (!table->IsBeingDroppedDueToDdlTxn(req->transaction().transaction_id(),
-                                              true /* txn_success */)) {
+                                              /*txn_success=*/true)) {
           return SetupError(
               resp->mutable_error(),
               MasterErrorPB::INVALID_REQUEST,
@@ -9945,12 +9955,13 @@ Status CatalogManager::DeleteUDType(const DeleteUDTypeRequestPB* req,
       for (int i = 0; i < ltm->field_types_size(); i++) {
         // Only need to check direct (non-transitive) type dependencies here.
         // This also means we report more precise errors for in-use types.
-        if (QLType::DoesUserDefinedTypeIdExist(ltm->field_types(i),
-                                      false /* transitive */,
-                                      tp->id())) {
-          Status s = STATUS(QLError,
-              Substitute("Cannot delete type '$0.$1'. It is used in field $2 of type '$3'",
-                  ns->name(), tp->name(), ltm->field_names(i), ltm->name()));
+        if (QLType::DoesUserDefinedTypeIdExist(
+                ltm->field_types(i),
+                /*transitive=*/false, tp->id())) {
+          Status s = STATUS(
+              QLError, Substitute(
+                           "Cannot delete type '$0.$1'. It is used in field $2 of type '$3'",
+                           ns->name(), tp->name(), ltm->field_names(i), ltm->name()));
           return SetupError(resp->mutable_error(), MasterErrorPB::INVALID_REQUEST, s);
         }
       }
@@ -12674,7 +12685,7 @@ void CatalogManager::RebuildYQLSystemPartitions() {
 Status CatalogManager::SysCatalogRespectLeaderAffinity() {
   auto l = ClusterConfig()->LockForRead();
 
-  auto blacklist = ToBlacklistSet(GetBlacklist(l->pb, /*leader_blacklist=*/true));
+  auto blacklist = ToBlacklistSet(GetBlacklist(l->pb, /*blacklist_leader=*/true));
   bool i_am_blacklisted = IsBlacklisted(server_registration_, blacklist);
 
   vector<AffinitizedZonesSet> affinitized_zones;
diff --git a/src/yb/util/test_macros.h b/src/yb/util/test_macros.h
index 8c796418c8..05b020e5e2 100644
--- a/src/yb/util/test_macros.h
+++ b/src/yb/util/test_macros.h
@@ -42,12 +42,10 @@
 #include "yb/gutil/stl_util.h"  // For VectorToSet
 
 #include "yb/util/result.h"
-#include "yb/util/status.h"
-#include "yb/util/string_trim.h"
+#include "yb/util/string_trim.h"  // For ApplyEagerLineContinuation
 #include "yb/util/tostring.h"
 
-namespace yb {
-namespace util {
+namespace yb::util {
 
 template<typename T>
 std::string TEST_SetDifferenceStr(const std::set<T>& expected, const std::set<T>& actual) {
@@ -80,8 +78,7 @@ std::string TEST_SetDifferenceStr(const std::set<T>& expected, const std::set<T>
   return result.str();
 }
 
-}  // namespace util
-}  // namespace yb
+} // namespace yb::util
 
 // ASSERT_NO_FATAL_FAILURE is just too long to type.
 #define NO_FATALS(expr) \
@@ -148,7 +145,7 @@ std::string TEST_SetDifferenceStr(const std::set<T>& expected, const std::set<T>
     if (!_ec) { \
       SUCCEED(); \
     } else { \
-      FAIL() << "Unexpected error: " << ec.message(); \
+      FAIL() << "Unexpected error: " << (ec).message(); \
     } \
   } while (false)
 
@@ -158,7 +155,7 @@ std::string TEST_SetDifferenceStr(const std::set<T>& expected, const std::set<T>
     if (!_ec) { \
       SUCCEED(); \
     } else { \
-      ADD_FAILURE() << "Unexpected error: " << ec.message(); \
+      ADD_FAILURE() << "Unexpected error: " << (ec).message(); \
     } \
   } while (false)
 
@@ -218,13 +215,13 @@ inline std::string FindFirstDiff(const std::string& lhs, const std::string& rhs)
 
 #define ASSERT_FILE_EXISTS(env, path) do { \
   std::string _s = (path); \
-  ASSERT_TRUE(env->FileExists(_s)) \
+  ASSERT_TRUE((env)->FileExists(_s)) \
     << "Expected file to exist: " << _s; \
   } while (0)
 
 #define ASSERT_FILE_NOT_EXISTS(env, path) do { \
   std::string _s = (path); \
-  ASSERT_FALSE(env->FileExists(_s)) \
+  ASSERT_FALSE((env)->FileExists(_s)) \
     << "Expected file not to exist: " << _s; \
   } while (0)
 
@@ -435,6 +432,12 @@ inline std::string FindFirstDiff(const std::string& lhs, const std::string& rhs)
 #define YB_DEBUG_ONLY_TEST(test_name) YB_DISABLE_TEST(test_name)
 #endif
 
+#if defined(NDEBUG)
+#define YB_NEVER_DEBUG_TEST(test_name) test_name
+#else
+#define YB_NEVER_DEBUG_TEST(test_name) YB_DISABLE_TEST(test_name)
+#endif
+
 #if !defined(NDEBUG) && defined(__linux__)
 #define YB_LINUX_DEBUG_ONLY_TEST(test_name) test_name
 #else
