diff --git a/src/yb/cdc/cdc_service.cc b/src/yb/cdc/cdc_service.cc
index 21a183b4fb..6ecccb116a 100644
--- a/src/yb/cdc/cdc_service.cc
+++ b/src/yb/cdc/cdc_service.cc
@@ -43,10 +43,11 @@
 #include "yb/client/table_handle.h"
 #include "yb/client/yb_table_name.h"
 
+#include "yb/common/colocated_util.h"
 #include "yb/common/pg_system_attr.h"
 #include "yb/common/schema.h"
 #include "yb/common/wire_protocol.h"
-#include "yb/common/colocated_util.h"
+#include "yb/common/xcluster_util.h"
 
 #include "yb/consensus/log.h"
 #include "yb/consensus/log_reader.h"
@@ -1301,7 +1302,8 @@ void CDCServiceImpl::GetTabletListToPollForCDC(
 
   client::YBTableName table_name;
   google::protobuf::RepeatedPtrField<master::TabletLocationsPB> tablets;
-  table_name.set_table_id(table_id);
+  auto stripped_table_id = xcluster::StripSequencesDataAliasIfPresent(table_id);
+  table_name.set_table_id(stripped_table_id);
   RPC_STATUS_RETURN_ERROR(
       client()->GetTablets(
           table_name, 0, &tablets, /* partition_list_version =*/nullptr,
@@ -1483,7 +1485,8 @@ Result<google::protobuf::RepeatedPtrField<master::TabletLocationsPB>> CDCService
 
   for (const auto& table_id : table_ids) {
     google::protobuf::RepeatedPtrField<master::TabletLocationsPB> tablets;
-    table_name.set_table_id(table_id);
+    auto stripped_table_id = xcluster::StripSequencesDataAliasIfPresent(table_id);
+    table_name.set_table_id(stripped_table_id);
     Status s = client()->GetTablets(
         table_name, 0, &tablets, /* partition_list_version =*/nullptr,
         RequireTabletsRunning::kFalse, master::IncludeInactive::kTrue);
diff --git a/src/yb/common/entity_ids_types.h b/src/yb/common/entity_ids_types.h
index 67fc914d9f..c246b41e4b 100644
--- a/src/yb/common/entity_ids_types.h
+++ b/src/yb/common/entity_ids_types.h
@@ -25,6 +25,7 @@ using NamespaceName = std::string;
 using TableName = std::string;
 using UDTypeName = std::string;
 using RoleName = std::string;
+using PgSchemaName = std::string;
 
 using NamespaceId = std::string;
 using ObjectId = std::string;
diff --git a/src/yb/common/schema.h b/src/yb/common/schema.h
index 0b6b9b623f..c421c9bec1 100644
--- a/src/yb/common/schema.h
+++ b/src/yb/common/schema.h
@@ -516,8 +516,6 @@ class TableProperties {
   std::optional<PgReplicaIdentity> ysql_replica_identity_;
 };
 
-using PgSchemaName = std::string;
-
 // Provides missing, i.e. default, value for specified column if present.
 class MissingValueProvider {
  public:
diff --git a/src/yb/common/xcluster_util.cc b/src/yb/common/xcluster_util.cc
index 3112d23647..a66b0c66d4 100644
--- a/src/yb/common/xcluster_util.cc
+++ b/src/yb/common/xcluster_util.cc
@@ -13,12 +13,20 @@
 
 #include "yb/common/xcluster_util.h"
 
+#include "yb/common/entity_ids.h"
+#include "yb/common/ysql_utils.h"
 #include "yb/gutil/strings/util.h"
+#include "yb/util/result.h"
 
 namespace yb::xcluster {
 
 namespace {
 constexpr char kAlterReplicationGroupSuffix[] = ".ALTER";
+
+constexpr char kSequencesDataAliasTableIdMid[] = ".sequences_data_for.";
+
+// How many characters a normal TableId (e.g., no suffixes) takes up.
+constexpr int kTableIdSize = 32;
 }  // namespace
 
 ReplicationGroupId GetAlterReplicationGroupId(const ReplicationGroupId& replication_group_id) {
@@ -44,4 +52,27 @@ std::string ShortReplicationType(XClusterReplicationType type) {
       /*replace_all=*/false);
 }
 
+TableId GetSequencesDataAliasForNamespace(const NamespaceId& namespace_id) {
+  DCHECK(kPgSequencesDataTableId.size() == kTableIdSize);
+  return kPgSequencesDataTableId + kSequencesDataAliasTableIdMid + namespace_id;
+}
+
+bool IsSequencesDataAlias(const TableId& table_id) {
+  return table_id.find(kSequencesDataAliasTableIdMid) == kTableIdSize;
+}
+
+TableId StripSequencesDataAliasIfPresent(const TableId& table_id) {
+  if (!IsSequencesDataAlias(table_id)) {
+    return table_id;
+  }
+  return kPgSequencesDataTableId;
+}
+
+Result<NamespaceId> GetReplicationNamespaceBelongsTo(const TableId& table_id) {
+  if (!IsSequencesDataAlias(table_id)) {
+    return GetNamespaceIdFromYsqlTableId(table_id);
+  }
+  return table_id.substr(kTableIdSize + strlen(kSequencesDataAliasTableIdMid));
+}
+
 }  // namespace yb::xcluster
diff --git a/src/yb/common/xcluster_util.h b/src/yb/common/xcluster_util.h
index 98c6154008..80e27f3f43 100644
--- a/src/yb/common/xcluster_util.h
+++ b/src/yb/common/xcluster_util.h
@@ -25,4 +25,15 @@ ReplicationGroupId GetOriginalReplicationGroupId(const ReplicationGroupId& repli
 
 std::string ShortReplicationType(XClusterReplicationType type);
 
+
+TableId GetSequencesDataAliasForNamespace(const NamespaceId& namespace_id);
+
+bool IsSequencesDataAlias(const TableId& table_id);
+
+TableId StripSequencesDataAliasIfPresent(const TableId& table_id);
+
+// Returns the namespace a sequences_data alias is for; if table_id is not a sequences_data alias,
+// instead returns the ID's namespace as usual.
+Result<NamespaceId> GetReplicationNamespaceBelongsTo(const TableId& table_id);
+
 }  // namespace yb::xcluster
diff --git a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
index 17e16c4b76..4b0f703637 100644
--- a/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_db_scoped-test.cc
@@ -11,16 +11,19 @@
 // under the License.
 //
 
-#include "yb/common/xcluster_util.h"
+#include <gmock/gmock.h>
+
 #include "yb/client/table.h"
 #include "yb/client/xcluster_client.h"
 #include "yb/client/yb_table_name.h"
+#include "yb/common/xcluster_util.h"
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/mini_master.h"
 
 DECLARE_int32(cdc_parent_tablet_deletion_task_retry_secs);
 DECLARE_string(certs_for_cdc_dir);
+DECLARE_bool(TEST_force_automatic_ddl_replication_mode);
 DECLARE_bool(disable_xcluster_db_scoped_new_table_processing);
 
 using namespace std::chrono_literals;
@@ -34,8 +37,20 @@ class XClusterDBScopedTest : public XClusterYsqlTestBase {
   XClusterDBScopedTest() = default;
   ~XClusterDBScopedTest() = default;
 
-  virtual void SetUp() override {
+  void SetUp() override {
     XClusterYsqlTestBase::SetUp();
+    // Make sure we use new databases so the database OIDs will differ in automatic mode.
+    // This ensures that the sequence_data aliases will be different in the two universes.
+    // See XClusterYsqlTestBase::SetUpClusters() for the code that does this.
+    namespace_name = "new_db";
+  }
+
+  std::vector<TableId> ExtractTableIds(const master::GetUniverseReplicationResponsePB& resp) {
+    std::vector<TableId> results;
+    for (const auto& table_id : resp.entry().tables()) {
+      results.push_back(table_id);
+    }
+    return results;
   }
 
   Result<master::GetXClusterStreamsResponsePB> GetXClusterStreams(
@@ -57,7 +72,19 @@ class XClusterDBScopedTest : public XClusterYsqlTestBase {
   }
 };
 
-TEST_F(XClusterDBScopedTest, TestCreateWithCheckpoint) {
+class XClusterDBScopedParameterized
+    : public XClusterDBScopedTest,
+      public ::testing::WithParamInterface<bool> {
+ public:
+  bool UseAutomaticMode() override { return GetParam(); }
+};
+
+INSTANTIATE_TEST_CASE_P(
+    AutoMode, XClusterDBScopedParameterized, ::testing::Values(true));
+INSTANTIATE_TEST_CASE_P(
+    SemiMode, XClusterDBScopedParameterized, ::testing::Values(false));
+
+TEST_P(XClusterDBScopedParameterized, TestCreateWithCheckpoint) {
   SetupParams param;
   param.num_producer_tablets = {};
   param.num_consumer_tablets = {};
@@ -79,12 +106,12 @@ TEST_F(XClusterDBScopedTest, TestCreateWithCheckpoint) {
   ASSERT_OK(ClearFailedUniverse(consumer_cluster_));
 
   ASSERT_NOK_STR_CONTAINS(
-      CreateReplicationFromCheckpoint(), "Could not find matching table for yugabyte.test_table_0");
+      CreateReplicationFromCheckpoint(), "Could not find matching table for new_db.test_table_0");
   ASSERT_OK(ClearFailedUniverse(consumer_cluster_));
 
   auto consumer_table_name = ASSERT_RESULT(CreateYsqlTable(
       /*idx=*/0, /*num_tablets=*/3, &consumer_cluster_));
-  ASSERT_OK(producer_client()->OpenTable(consumer_table_name, &consumer_table_));
+  ASSERT_OK(consumer_client()->OpenTable(consumer_table_name, &consumer_table_));
 
   auto consumer_extra_table_name = ASSERT_RESULT(CreateYsqlTable(
       /*idx=*/1, /*num_tablets=*/3, &consumer_cluster_));
@@ -104,8 +131,8 @@ TEST_F(XClusterDBScopedTest, TestCreateWithCheckpoint) {
   master::GetUniverseReplicationResponsePB resp;
   ASSERT_OK(VerifyUniverseReplication(&resp));
   ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
-  ASSERT_EQ(resp.entry().tables_size(), 1);
-  ASSERT_EQ(resp.entry().tables(0), producer_table_->id());
+  ASSERT_EQ(resp.entry().tables_size(), 1 + OverheadStreamsCount());
+  ASSERT_THAT(ExtractTableIds(resp), testing::Contains(producer_table_->id()));
 
   // Verify the groups shows up in GetUniverseReplications and GetUniverseReplicationInfo client
   // APIs.
@@ -114,7 +141,7 @@ TEST_F(XClusterDBScopedTest, TestCreateWithCheckpoint) {
   ASSERT_EQ(replication_groups.size(), 1);
   ASSERT_EQ(replication_groups.front(), kReplicationGroupId);
   replication_groups = ASSERT_RESULT(
-      target_xcluster_client.GetUniverseReplications(producer_table_->name().namespace_id()));
+      target_xcluster_client.GetUniverseReplications(consumer_table_->name().namespace_id()));
   ASSERT_EQ(replication_groups.size(), 1);
   ASSERT_EQ(replication_groups.front(), kReplicationGroupId);
   auto replication_info =
@@ -122,12 +149,27 @@ TEST_F(XClusterDBScopedTest, TestCreateWithCheckpoint) {
   ASSERT_EQ(replication_info.replication_type, XClusterReplicationType::XCLUSTER_YSQL_DB_SCOPED);
   ASSERT_EQ(replication_info.db_scope_namespace_id_map.size(), 1);
   const auto& source_namespace_id = producer_table_->name().namespace_id();
-  ASSERT_TRUE(replication_info.db_scope_namespace_id_map.contains(source_namespace_id));
   const auto& target_namespace_id = consumer_table_->name().namespace_id();
-  ASSERT_EQ(replication_info.db_scope_namespace_id_map[source_namespace_id], target_namespace_id);
-  ASSERT_EQ(replication_info.table_infos.size(), 1);
-  ASSERT_EQ(replication_info.table_infos[0].source_table_id, producer_table_->id());
-  ASSERT_EQ(replication_info.table_infos[0].target_table_id, consumer_table_->id());
+  EXPECT_THAT(
+      replication_info.db_scope_namespace_id_map,
+      testing::Contains(testing::Key(target_namespace_id)));
+  ASSERT_EQ(replication_info.db_scope_namespace_id_map[target_namespace_id], source_namespace_id);
+  ASSERT_EQ(replication_info.table_infos.size(), 1 + OverheadStreamsCount());
+  bool found = false;
+  for (const auto& table_info : replication_info.table_infos) {
+    if (table_info.source_table_id == producer_table_->id() &&
+        table_info.target_table_id == consumer_table_->id()) {
+      found = true;
+    }
+  }
+  ASSERT_TRUE(found) << "Unable to find normal table in replication_info.table_infos";
+
+  if (UseAutomaticMode()) {
+    // In automatic mode, sequences_data should have been created on the target universe.
+    ASSERT_TRUE(ASSERT_RESULT(consumer_cluster()->GetLeaderMiniMaster())
+                    ->catalog_manager_impl()
+                    .GetTableInfo(kPgSequencesDataTableId));
+  }
 
   ASSERT_OK(InsertRowsInProducer(50, 100));
 
@@ -161,7 +203,7 @@ TEST_F(XClusterDBScopedTest, CreateTable) {
   master::GetUniverseReplicationResponsePB resp;
   ASSERT_OK(VerifyUniverseReplication(&resp));
   ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
-  ASSERT_EQ(resp.entry().tables_size(), 2);
+  ASSERT_EQ(resp.entry().tables_size(), 2 + OverheadStreamsCount());
 
   ASSERT_OK(VerifyWrittenRecords(new_producer_table, new_consumer_table));
 
@@ -201,12 +243,18 @@ TEST_F(XClusterDBScopedTest, DropTableOnProducerThenConsumer) {
   ASSERT_STR_CONTAINS(result.status().ToString(), "test_table_0 not found in namespace");
 
   auto get_streams_resp = ASSERT_RESULT(GetAllXClusterStreams(namespace_id));
-  ASSERT_EQ(get_streams_resp.table_infos_size(), 1);
-  ASSERT_EQ(get_streams_resp.table_infos(0).table_id(), producer_tables_[1]->id());
+  ASSERT_EQ(get_streams_resp.table_infos_size(), 1 + OverheadStreamsCount());
+  bool found = false;
+  for (const auto& table_info : get_streams_resp.table_infos()) {
+    if (table_info.table_id() == producer_tables_[1]->id()) {
+      found = true;
+    }
+  }
+  ASSERT_TRUE(found) << "Unable to find producer table in get_streams_resp.table_infos";
 }
 
 // Test dropping all tables and then creating new tables.
-TEST_F(XClusterDBScopedTest, DropAllTables) {
+TEST_P(XClusterDBScopedParameterized, DropAllTables) {
   // Drop bg task timer to speed up test.
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_cdc_parent_tablet_deletion_task_retry_secs) = 1;
   // Setup replication with one table
@@ -223,10 +271,10 @@ TEST_F(XClusterDBScopedTest, DropAllTables) {
 
   auto namespace_id = ASSERT_RESULT(GetNamespaceId(producer_client()));
   auto outbound_streams = ASSERT_RESULT(GetAllXClusterStreams(namespace_id));
-  ASSERT_EQ(outbound_streams.table_infos_size(), 0);
+  ASSERT_EQ(outbound_streams.table_infos_size(), 0 + OverheadStreamsCount());
 
   auto resp = ASSERT_RESULT(GetUniverseReplicationInfo(consumer_cluster_, kReplicationGroupId));
-  ASSERT_EQ(resp.entry().tables_size(), 0);
+  ASSERT_EQ(resp.entry().tables_size(), 0 + OverheadStreamsCount());
 
   // Add a new table.
   auto producer_table2_name = ASSERT_RESULT(CreateYsqlTable(
@@ -239,7 +287,7 @@ TEST_F(XClusterDBScopedTest, DropAllTables) {
   auto consumer_table2_name = ASSERT_RESULT(CreateYsqlTable(
       /*idx=*/2, /*num_tablets=*/3, &consumer_cluster_));
   std::shared_ptr<client::YBTable> consumer_table2;
-  ASSERT_OK(producer_client()->OpenTable(consumer_table2_name, &consumer_table2));
+  ASSERT_OK(consumer_client()->OpenTable(consumer_table2_name, &consumer_table2));
 
   ASSERT_OK(VerifyWrittenRecords(producer_table2, consumer_table2));
 }
@@ -288,7 +336,7 @@ TEST_F(XClusterDBScopedTest, ColocatedDB) {
   // Make sure we only colocated parent table and one non-colocated table
   master::GetUniverseReplicationResponsePB resp;
   ASSERT_OK(VerifyUniverseReplication(&resp));
-  ASSERT_EQ(resp.entry().tables_size(), 2);
+  ASSERT_EQ(resp.entry().tables_size(), 2 + OverheadStreamsCount());
 
   auto producer_table2_name = ASSERT_RESULT(CreateYsqlTable(
       /*idx=*/2, /*num_tablets=*/3, &producer_cluster_));
@@ -300,7 +348,7 @@ TEST_F(XClusterDBScopedTest, ColocatedDB) {
   auto consumer_table2_name = ASSERT_RESULT(CreateYsqlTable(
       /*idx=*/2, /*num_tablets=*/3, &consumer_cluster_));
   std::shared_ptr<client::YBTable> consumer_table2;
-  ASSERT_OK(producer_client()->OpenTable(consumer_table2_name, &consumer_table2));
+  ASSERT_OK(consumer_client()->OpenTable(consumer_table2_name, &consumer_table2));
 
   ASSERT_OK(VerifyWrittenRecords(producer_table2, consumer_table2));
 
@@ -324,7 +372,7 @@ TEST_F(XClusterDBScopedTest, ColocatedDB) {
   ASSERT_OK(DropYsqlTable(consumer_cluster_, *consumer_colocated_table));
 
   ASSERT_OK(VerifyUniverseReplication(&resp));
-  ASSERT_EQ(resp.entry().tables_size(), 3);
+  ASSERT_EQ(resp.entry().tables_size(), 3 + OverheadStreamsCount());
 
   // Insert some rows to the initial table.
   ASSERT_OK(InsertRowsInProducer(10, 20, producer_table_));
@@ -339,7 +387,7 @@ TEST_F(XClusterDBScopedTest, ColocatedDB) {
   ASSERT_OK(DropYsqlTable(consumer_cluster_, *consumer_table2));
 
   ASSERT_OK(VerifyUniverseReplication(&resp));
-  ASSERT_EQ(resp.entry().tables_size(), 2);
+  ASSERT_EQ(resp.entry().tables_size(), 2 + OverheadStreamsCount());
 }
 
 // When disable_xcluster_db_scoped_new_table_processing is set make sure we do not checkpoint new
@@ -361,8 +409,8 @@ TEST_F(XClusterDBScopedTest, DisableAutoTableProcessing) {
   master::GetUniverseReplicationResponsePB resp;
   ASSERT_OK(VerifyUniverseReplication(&resp));
   ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
-  ASSERT_EQ(resp.entry().tables_size(), 1);
-  ASSERT_EQ(resp.entry().tables(0), producer_table_->id());
+  ASSERT_EQ(resp.entry().tables_size(), 1 + OverheadStreamsCount());
+  ASSERT_THAT(ExtractTableIds(resp), testing::Contains(producer_table_->id()));
 
   auto producer_table2_name = ASSERT_RESULT(CreateYsqlTable(
       /*idx=*/1, /*num_tablets=*/3, &producer_cluster_));
@@ -371,8 +419,14 @@ TEST_F(XClusterDBScopedTest, DisableAutoTableProcessing) {
 
   auto namespace_id = ASSERT_RESULT(GetNamespaceId(producer_client()));
   auto get_streams_resp = ASSERT_RESULT(GetAllXClusterStreams(namespace_id));
-  ASSERT_EQ(get_streams_resp.table_infos_size(), 1);
-  ASSERT_EQ(get_streams_resp.table_infos(0).table_id(), producer_table_->id());
+  ASSERT_EQ(get_streams_resp.table_infos_size(), 1 + OverheadStreamsCount());
+  bool found = false;
+  for (const auto& table_info : get_streams_resp.table_infos()) {
+    if (table_info.table_id() == producer_table_->id()) {
+      found = true;
+    }
+  }
+  ASSERT_TRUE(found) << "Unable to find producer table in get_streams_resp.table_infos";
 
   ASSERT_OK(InsertRowsInProducer(0, 100, producer_table2));
   ASSERT_NOK(VerifyWrittenRecords(producer_table2, consumer_table2));
@@ -426,8 +480,20 @@ class XClusterDBScopedTestWithTwoDBs : public XClusterDBScopedTest {
   std::shared_ptr<client::YBTable> source_namespace2_table_, target_namespace2_table_;
 };
 
+class XClusterDBScopedTestWithTwoDBsParameterized
+    : public XClusterDBScopedTestWithTwoDBs,
+      public ::testing::WithParamInterface<bool> {
+ public:
+  bool UseAutomaticMode() override { return GetParam(); }
+};
+
+INSTANTIATE_TEST_CASE_P(
+    AutoMode, XClusterDBScopedTestWithTwoDBsParameterized, ::testing::Values(true));
+INSTANTIATE_TEST_CASE_P(
+    SemiMode, XClusterDBScopedTestWithTwoDBsParameterized, ::testing::Values(false));
+
 // Testing adding and removing namespaces to replication.
-TEST_F_EX(XClusterDBScopedTest, AddRemoveNamespace, XClusterDBScopedTestWithTwoDBs) {
+TEST_P(XClusterDBScopedTestWithTwoDBsParameterized, AddRemoveNamespace) {
   ASSERT_OK(SetUpClusters());
   ASSERT_OK(CheckpointReplicationGroup());
   ASSERT_OK(CreateReplicationFromCheckpoint());
@@ -444,9 +510,15 @@ TEST_F_EX(XClusterDBScopedTest, AddRemoveNamespace, XClusterDBScopedTestWithTwoD
 
   // Validate streams on source.
   auto streams = ASSERT_RESULT(GetAllXClusterStreams(source_namespace2_id_));
-  ASSERT_EQ(streams.table_infos_size(), 1);
-  ASSERT_EQ(streams.table_infos(0).table_name(), namespace2_table_name_);
-  ASSERT_EQ(streams.table_infos(0).table_id(), source_namespace2_table_->id());
+  ASSERT_EQ(streams.table_infos_size(), 1 + OverheadStreamsCount());
+  bool found = false;
+  for (const auto& table_info : streams.table_infos()) {
+    if (table_info.table_name() == namespace2_table_name_ &&
+        table_info.table_id() == source_namespace2_table_->id()) {
+      found = true;
+    }
+  }
+  ASSERT_TRUE(found) << "Unable to find source_namespace2_table in streams.table_infos";
 
   // Add the namespace to the target.
   ASSERT_OK(AddNamespaceToXClusterReplication(source_namespace2_id_, target_namespace2_id_));
@@ -455,7 +527,7 @@ TEST_F_EX(XClusterDBScopedTest, AddRemoveNamespace, XClusterDBScopedTestWithTwoD
   master::GetUniverseReplicationResponsePB resp;
   ASSERT_OK(VerifyUniverseReplication(&resp));
   ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
-  ASSERT_EQ(resp.entry().tables_size(), 2);
+  EXPECT_EQ(resp.entry().tables_size(), 2 + 2 * OverheadStreamsCount());
 
   auto replication_info = ASSERT_RESULT(consumer_cluster()->GetLeaderMiniMaster())
                               ->catalog_manager_impl()
@@ -475,9 +547,9 @@ TEST_F_EX(XClusterDBScopedTest, AddRemoveNamespace, XClusterDBScopedTestWithTwoD
   // Check the target side.
   ASSERT_OK(VerifyUniverseReplication(&resp));
   ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
-  ASSERT_EQ(resp.entry().tables_size(), 1);
+  ASSERT_EQ(resp.entry().tables_size(), 1 + OverheadStreamsCount());
   // Only the first table should be left.
-  ASSERT_EQ(resp.entry().tables(0), producer_table_->id());
+  ASSERT_THAT(ExtractTableIds(resp), testing::Contains(producer_table_->id()));
 
   replication_info = ASSERT_RESULT(consumer_cluster()->GetLeaderMiniMaster())
                          ->catalog_manager_impl()
@@ -532,7 +604,7 @@ TEST_F_EX(XClusterDBScopedTest, RemoveNamespaceWhenTargetIsDown, XClusterDBScope
   master::GetUniverseReplicationResponsePB resp;
   ASSERT_OK(VerifyUniverseReplication(&resp));
   ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
-  ASSERT_EQ(resp.entry().tables_size(), 2);
+  EXPECT_EQ(resp.entry().tables_size(), 2 + 2 * OverheadStreamsCount());
 
   auto target_xcluster_client = client::XClusterClient(*consumer_client());
 
@@ -546,8 +618,8 @@ TEST_F_EX(XClusterDBScopedTest, RemoveNamespaceWhenTargetIsDown, XClusterDBScope
       kReplicationGroupId, source_namespace2_id_, UniverseUuid::Nil()));
   ASSERT_OK(VerifyUniverseReplication(&resp));
   ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
-  ASSERT_EQ(resp.entry().tables_size(), 1);
-  ASSERT_EQ(resp.entry().tables(0), producer_table_->id());
+  ASSERT_EQ(resp.entry().tables_size(), 1 + OverheadStreamsCount());
+  ASSERT_THAT(ExtractTableIds(resp), testing::Contains(producer_table_->id()));
 }
 
 // Remove a namespaces from replication when the source side is down.
@@ -575,8 +647,8 @@ TEST_F_EX(XClusterDBScopedTest, RemoveNamespaceWhenSourceIsDown, XClusterDBScope
   master::GetUniverseReplicationResponsePB resp;
   ASSERT_OK(VerifyUniverseReplication(&resp));
   ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
-  ASSERT_EQ(resp.entry().tables_size(), 1);
-  ASSERT_EQ(resp.entry().tables(0), producer_table_->id());
+  ASSERT_EQ(resp.entry().tables_size(), 1 + OverheadStreamsCount());
+  ASSERT_THAT(ExtractTableIds(resp), testing::Contains(producer_table_->id()));
 
   // Bring the source back up.
   {
@@ -586,7 +658,7 @@ TEST_F_EX(XClusterDBScopedTest, RemoveNamespaceWhenSourceIsDown, XClusterDBScope
 
   // Source should still have the namespace and stream.
   auto streams = ASSERT_RESULT(GetAllXClusterStreams(source_namespace2_id_));
-  ASSERT_EQ(streams.table_infos_size(), 1);
+  ASSERT_EQ(streams.table_infos_size(), 1 + OverheadStreamsCount());
 
   // Remove the namespace from source side.
   ASSERT_OK(source_xcluster_client.RemoveNamespaceFromOutboundReplicationGroup(
@@ -657,7 +729,7 @@ TEST_F(XClusterDBScopedTest, DeleteWhenTargetIsDown) {
   master::GetUniverseReplicationResponsePB resp;
   ASSERT_OK(VerifyUniverseReplication(&resp));
   ASSERT_EQ(resp.entry().replication_group_id(), kReplicationGroupId);
-  ASSERT_EQ(resp.entry().tables_size(), 1);
+  EXPECT_EQ(resp.entry().tables_size(), 1 + OverheadStreamsCount());
 
   auto target_xcluster_client = client::XClusterClient(*consumer_client());
 
@@ -706,7 +778,7 @@ TEST_F(XClusterDBScopedTest, DeleteWhenSourceIsDown) {
   auto source_namespace_id = ASSERT_RESULT(GetNamespaceId(producer_client()));
   // Source should still have the replication group and streams.
   auto streams = ASSERT_RESULT(GetAllXClusterStreams(source_namespace_id));
-  ASSERT_EQ(streams.table_infos_size(), 1);
+  ASSERT_EQ(streams.table_infos_size(), 1 + OverheadStreamsCount());
 
   auto source_xcluster_client = client::XClusterClient(*producer_client());
 
@@ -732,6 +804,9 @@ TEST_F(XClusterDBScopedTest, MultipleInboundReplications) {
 }
 
 TEST_F_EX(XClusterDBScopedTest, TestYbAdmin, XClusterDBScopedTestWithTwoDBs) {
+  // TODO: replace this once there is a way to use automatic mode with ybadmin.
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_force_automatic_ddl_replication_mode) = UseAutomaticMode();
+
   ASSERT_OK(SetUpClusters());
 
   // Create replication with 1 db.
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
index 5bc576aa0d..856185999e 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
@@ -209,7 +209,7 @@ TEST_F(XClusterDDLReplicationTest, CreateIndex) {
   {
     master::GetUniverseReplicationResponsePB resp;
     ASSERT_OK(VerifyUniverseReplication(&resp));
-    ASSERT_EQ(resp.entry().tables_size(), 3);  // ddl_queue + base_table + index
+    EXPECT_EQ(resp.entry().tables_size(), 4);  // ddl_queue + base_table + index + sequences_data
   }
   ASSERT_TRUE(ASSERT_RESULT(c_conn.HasIndexScan(kCol2CountStmt)));
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
index 4c0d276bbd..85d5771180 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.cc
@@ -22,7 +22,6 @@
 
 DECLARE_bool(enable_xcluster_api_v2);
 
-DECLARE_bool(TEST_xcluster_enable_ddl_replication);
 DECLARE_bool(TEST_xcluster_ddl_queue_handler_log_queries);
 
 using namespace std::chrono_literals;
@@ -32,7 +31,6 @@ namespace yb {
 void XClusterDDLReplicationTestBase::SetUp() {
   XClusterYsqlTestBase::SetUp();
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_enable_xcluster_api_v2) = true;
-  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_enable_ddl_replication) = true;
   ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_ddl_queue_handler_log_queries) = true;
 }
 
@@ -74,7 +72,7 @@ Status XClusterDDLReplicationTestBase::EnableDDLReplicationExtension() {
       auto yb_table_name = VERIFY_RESULT(
           GetYsqlTable(cluster, namespace_name, xcluster::kDDLQueuePgSchemaName, table_name));
       std::shared_ptr<client::YBTable> table;
-      RETURN_NOT_OK(producer_client()->OpenTable(yb_table_name, &table));
+      RETURN_NOT_OK(cluster->client_->OpenTable(yb_table_name, &table));
       SCHECK_EQ(table->GetPartitionCount(), 1, IllegalState, "Expected 1 tablet");
     }
     return Status::OK();
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h
index 7323b36e50..c7a35caa4e 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication_test_base.h
@@ -24,16 +24,18 @@ class XClusterDDLReplicationTestBase : public XClusterYsqlTestBase {
 
   virtual void SetUp() override;
 
+  bool UseAutomaticMode() override {
+    // All these tests use automatic.
+    return true;
+  }
+
   Status SetUpClusters(bool is_colocated = false);
 
   Status EnableDDLReplicationExtension();
 
-  // Set automatic_ddl_mode to true by default.
   virtual Status CheckpointReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId,
-      bool automatic_ddl_mode = true) override {
-    return XClusterYsqlTestBase::CheckpointReplicationGroup(
-        replication_group_id, automatic_ddl_mode);
+      const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId) override {
+    return XClusterYsqlTestBase::CheckpointReplicationGroup(replication_group_id);
   }
 
   Result<std::shared_ptr<client::YBTable>> GetProducerTable(
diff --git a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
index ae83d8e006..8cad3ad691 100644
--- a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
@@ -16,6 +16,7 @@
 
 #include "yb/client/xcluster_client.h"
 #include "yb/client/yb_table_name.h"
+#include "yb/common/xcluster_util.h"
 #include "yb/consensus/log.h"
 #include "yb/integration-tests/xcluster/xcluster_ysql_test_base.h"
 #include "yb/master/catalog_manager.h"
@@ -28,8 +29,6 @@ DECLARE_int32(update_min_cdc_indices_interval_secs);
 DECLARE_uint32(cdc_wal_retention_time_secs);
 DECLARE_uint32(max_xcluster_streams_to_checkpoint_in_parallel);
 DECLARE_bool(TEST_block_xcluster_checkpoint_namespace_task);
-DECLARE_bool(TEST_xcluster_enable_ddl_replication);
-DECLARE_bool(TEST_xcluster_enable_sequence_replication);
 
 namespace yb {
 namespace master {
@@ -44,11 +43,6 @@ class XClusterOutboundReplicationGroupTest : public XClusterYsqlTestBase {
  public:
   XClusterOutboundReplicationGroupTest() {}
   void SetUp() override {
-    ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_enable_sequence_replication) =
-        UseAutomaticMode();
-    ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_enable_ddl_replication) =
-        UseAutomaticMode();
-
     XClusterYsqlTestBase::SetUp();
     MiniClusterOptions opts;
     opts.num_tablet_servers = 1;
@@ -63,21 +57,6 @@ class XClusterOutboundReplicationGroupTest : public XClusterYsqlTestBase {
     namespace_id_ = ASSERT_RESULT(CreateYsqlNamespace(kNamespaceName));
   }
 
-  virtual bool UseAutomaticMode() {
-    // Except for parameterized tests, we currently default to semi-automatic mode.
-    return false;
-  }
-
-  // How many extra streams/tables a namespace has
-  int OverheadStreamsCount() {
-    if (!UseAutomaticMode()) {
-      return 0;
-    }
-    // So far automatic mode has one extra stream for each namespace: sequences_data.
-    // TODO(jhe): increment this when you add the DDL queue table
-    return 1;
-  }
-
   Result<NamespaceId> CreateYsqlNamespace(const NamespaceName& ns_name) {
     CreateNamespaceResponsePB resp;
     RETURN_NOT_OK(CreateDatabase(&producer_cluster_, ns_name));
@@ -121,11 +100,11 @@ class XClusterOutboundReplicationGroupTest : public XClusterYsqlTestBase {
       } else if (table_info.table_name() == kTableName2) {
         ASSERT_EQ(table_info.table_id(), table_id2);
       } else if (table_info.table_name() == "sequences_data") {
-        ASSERT_EQ(table_info.table_id(), kPgSequencesDataTableId);
+        ASSERT_TRUE(xcluster::IsSequencesDataAlias(table_info.table_id()));
       } else {
         FAIL() << "Unexpected table name: " << table_info.table_name();
       }
-      if (table_info.table_id() != kPgSequencesDataTableId) {
+      if (!xcluster::IsSequencesDataAlias(table_info.table_id())) {
         if (skip_schema_name_check) {
           // Make sure it is not empty.
           ASSERT_FALSE(table_info.pg_schema_name().empty());
@@ -787,11 +766,12 @@ TEST_P(XClusterOutboundReplicationGroupParameterized, TestGetStreamByTableId) {
   ASSERT_EQ(ns_info.table_infos(1).table_id(), table_id_2);
 
   if (UseAutomaticMode()) {
-    // Verify that we can request sequences_data by its table id.
+    // Verify that we can request sequences_data by its table id alias.
+    TableId sequence_table_alias_id = xcluster::GetSequencesDataAliasForNamespace(namespace_id_);
     auto ns_info = ASSERT_RESULT(
-        GetXClusterStreamsByTableId(kReplicationGroupId, namespace_id_, {kPgSequencesDataTableId}));
+        GetXClusterStreamsByTableId(kReplicationGroupId, namespace_id_, {sequence_table_alias_id}));
     ASSERT_EQ(ns_info.table_infos_size(), 1);
-    ASSERT_EQ(ns_info.table_infos(0).table_id(), kPgSequencesDataTableId);
+    ASSERT_EQ(ns_info.table_infos(0).table_id(), sequence_table_alias_id);
   }
 
   // Verify that we can request a table that does not exist.
diff --git a/src/yb/integration-tests/xcluster/xcluster_test_base.h b/src/yb/integration-tests/xcluster/xcluster_test_base.h
index 113d0d4e6d..7eca577c34 100644
--- a/src/yb/integration-tests/xcluster/xcluster_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_test_base.h
@@ -36,11 +36,12 @@
 #include "yb/yql/pgwrapper/libpq_utils.h"
 #include "yb/yql/pgwrapper/pg_wrapper.h"
 
-DECLARE_bool(TEST_check_broadcast_address);
 DECLARE_bool(TEST_allow_ycql_transactional_xcluster);
+DECLARE_bool(TEST_check_broadcast_address);
+DECLARE_bool(flush_rocksdb_on_shutdown);
+
 DECLARE_int32(cdc_read_rpc_timeout_ms);
 DECLARE_int32(cdc_write_rpc_timeout_ms);
-DECLARE_bool(flush_rocksdb_on_shutdown);
 DECLARE_int32(xcluster_safe_time_update_interval_secs);
 
 namespace yb {
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_index-test.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_index-test.cc
index 0ffe22e092..9b2da66827 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_index-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_index-test.cc
@@ -470,6 +470,7 @@ TEST_F(XClusterColocatedNonTransactionalIndexTest, CreateIndexWithWorkload) {
 }
 
 class XClusterDbScopedYsqlIndexTest : public XClusterYsqlIndexTest {
+ protected:
   Status SetupUniverseReplication(
       MiniCluster* producer_cluster, MiniCluster* consumer_cluster, YBClient* consumer_client,
       const xcluster::ReplicationGroupId& replication_group_id,
@@ -541,9 +542,21 @@ class XClusterYsqlIndexProducerOnlyTest : public XClusterYsqlIndexTest {
   }
 };
 
+class XClusterDbScopedYsqlIndexProducerOnlyTest : public XClusterYsqlIndexProducerOnlyTest {
+ protected:
+  Status SetupUniverseReplication(
+      MiniCluster* producer_cluster, MiniCluster* consumer_cluster, YBClient* consumer_client,
+      const xcluster::ReplicationGroupId& replication_group_id,
+      const std::vector<TableId>& producer_table_ids,
+      const std::vector<xrepl::StreamId>& bootstrap_ids, SetupReplicationOptions opts) override {
+    RETURN_NOT_OK(CheckpointReplicationGroup());
+    RETURN_NOT_OK(CreateReplicationFromCheckpoint());
+    return Status::OK();
+  }
+};
+
 // Make sure indexes are checkpointed to the End of WAL.
-TEST_F_EX(
-    XClusterDbScopedYsqlIndexTest, IndexCheckpointLocation, XClusterYsqlIndexProducerOnlyTest) {
+TEST_F(XClusterDbScopedYsqlIndexProducerOnlyTest, IndexCheckpointLocation) {
   ASSERT_OK(CheckpointReplicationGroup());
 
   for (; row_count_ < 100; row_count_++) {
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
index 9408958f84..561bf148e3 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.cc
@@ -41,6 +41,8 @@ DECLARE_int32(replication_factor);
 DECLARE_bool(enable_tablet_split_of_xcluster_replicated_tables);
 
 DECLARE_bool(TEST_create_table_with_empty_pgschema_name);
+DECLARE_bool(TEST_xcluster_enable_ddl_replication);
+DECLARE_bool(TEST_xcluster_enable_sequence_replication);
 DECLARE_uint64(TEST_pg_auth_key);
 
 namespace yb {
@@ -51,6 +53,12 @@ using client::YBTableName;
 void XClusterYsqlTestBase::SetUp() {
   YB_SKIP_TEST_IN_TSAN();
   XClusterTestBase::SetUp();
+
+  LOG(INFO) << "DB-scoped replication will use automatic mode: " << UseAutomaticMode();
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_enable_ddl_replication) =
+      UseAutomaticMode();
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_enable_sequence_replication) =
+      UseAutomaticMode();
 }
 
 Status XClusterYsqlTestBase::Initialize(uint32_t replication_factor, uint32_t num_masters) {
@@ -856,6 +864,13 @@ Status XClusterYsqlTestBase::SetUpClusters(const SetupParams& params) {
           "Num consumer tables: $0 num producer tables: $1 must be equal.",
           params.num_consumer_tablets.size(), params.num_producer_tablets.size()));
 
+  if (UseAutomaticMode()) {
+    // For automatic mode tests, create an extra universe on the consumer before creating the test
+    // universe so the databases will have different OIDs and thus namespace IDs between the
+    // consumer and producer universes.
+    RETURN_NOT_OK(CreateDatabase(&consumer_cluster_, "gratuitous_db", false));
+  }
+
   RETURN_NOT_OK(RunOnBothClusters([&](Cluster* cluster) -> Status {
     master::GetNamespaceInfoResponsePB resp;
     auto namespace_status = cluster->client_->GetNamespaceInfo(
@@ -888,11 +903,11 @@ Status XClusterYsqlTestBase::SetUpClusters(const SetupParams& params) {
 }
 
 Status XClusterYsqlTestBase::CheckpointReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id, bool automatic_ddl_mode) {
+    const xcluster::ReplicationGroupId& replication_group_id) {
   auto producer_namespace_id = VERIFY_RESULT(GetNamespaceId(producer_client()));
   RETURN_NOT_OK(client::XClusterClient(*producer_client())
                     .CreateOutboundReplicationGroup(
-                        replication_group_id, {producer_namespace_id}, automatic_ddl_mode));
+                        replication_group_id, {producer_namespace_id}, UseAutomaticMode()));
 
   auto bootstrap_required =
       VERIFY_RESULT(IsXClusterBootstrapRequired(replication_group_id, producer_namespace_id));
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
index fc21f8e5b5..72b6be8449 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql_test_base.h
@@ -30,6 +30,22 @@ class XClusterYsqlTestBase : public XClusterTestBase {
   };
 
   void SetUp() override;
+
+  virtual bool UseAutomaticMode() {
+    // Except for parameterized tests, we currently default to semi-automatic mode.
+    return false;
+  }
+
+  // How many extra streams/tables a namespace has in DB-scoped replication
+  int OverheadStreamsCount() {
+    if (!UseAutomaticMode()) {
+      return 0;
+    }
+    // So far automatic mode has one extra stream for each namespace: sequences_data.
+    // TODO(jhe): increment this when you add the DDL queue table
+    return 1;
+  }
+
   Status InitClusters(const MiniClusterOptions& opts) override;
 
   Status SetUpWithParams(
@@ -136,8 +152,7 @@ class XClusterYsqlTestBase : public XClusterTestBase {
       bool delete_op = false, bool use_transaction = false);
 
   virtual Status CheckpointReplicationGroup(
-      const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId,
-      bool automatic_ddl_mode = false);
+      const xcluster::ReplicationGroupId& replication_group_id = kReplicationGroupId);
   Result<bool> IsXClusterBootstrapRequired(
       const xcluster::ReplicationGroupId& replication_group_id,
       const NamespaceId& source_namespace_id);
diff --git a/src/yb/master/catalog_entity_info.cc b/src/yb/master/catalog_entity_info.cc
index bd79a5a219..06a91793e2 100644
--- a/src/yb/master/catalog_entity_info.cc
+++ b/src/yb/master/catalog_entity_info.cc
@@ -1315,6 +1315,10 @@ Result<std::shared_ptr<XClusterRpcTasks>> UniverseReplicationInfoBase::GetOrCrea
 
 bool PersistentUniverseReplicationInfo::IsDbScoped() const { return yb::master::IsDbScoped(pb); }
 
+bool PersistentUniverseReplicationInfo::IsAutomaticDdlMode() const {
+  return yb::master::IsAutomaticDdlMode(pb);
+}
+
 // ================================================================================================
 // UniverseReplicationInfo
 // ================================================================================================
diff --git a/src/yb/master/catalog_entity_info.h b/src/yb/master/catalog_entity_info.h
index 07ebf95d76..759a0820d7 100644
--- a/src/yb/master/catalog_entity_info.h
+++ b/src/yb/master/catalog_entity_info.h
@@ -1230,6 +1230,7 @@ struct PersistentUniverseReplicationInfo
   }
 
   bool IsDbScoped() const;
+  bool IsAutomaticDdlMode() const;
 };
 
 class UniverseReplicationInfo : public UniverseReplicationInfoBase,
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index ded858b422..9ef61e22f0 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -82,13 +82,13 @@
 #include "yb/common/common_util.h"
 #include "yb/common/constants.h"
 #include "yb/common/key_encoder.h"
-#include "yb/common/pgsql_error.h"
 #include "yb/common/pg_catversions.h"
+#include "yb/common/pgsql_error.h"
 #include "yb/common/ql_type.h"
 #include "yb/common/ql_type_util.h"
-#include "yb/common/schema_pbutil.h"
 #include "yb/common/roles_permissions.h"
 #include "yb/common/schema.h"
+#include "yb/common/schema_pbutil.h"
 #include "yb/common/transaction.h"
 #include "yb/common/wire_protocol.h"
 
diff --git a/src/yb/master/xcluster/master_xcluster_util.cc b/src/yb/master/xcluster/master_xcluster_util.cc
index 1affc1c6cf..646fa0ae6c 100644
--- a/src/yb/master/xcluster/master_xcluster_util.cc
+++ b/src/yb/master/xcluster/master_xcluster_util.cc
@@ -12,7 +12,9 @@
 //
 
 #include "yb/master/xcluster/master_xcluster_util.h"
+
 #include "yb/common/common_types.pb.h"
+#include "yb/common/xcluster_util.h"
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/catalog_manager.h"
 
@@ -43,7 +45,7 @@ bool IsTableEligibleForXClusterReplication(const master::TableInfo& table) {
   }
 
   if (table.IsSequencesSystemTable()) {
-    // xCluster does not yet support replication of sequences.
+    // The sequences_data table is treated specially elsewhere.
     return false;
   }
 
@@ -64,25 +66,49 @@ std::string GetFullTableName(const TableInfo& table_info) {
   return Format("$0.$1", schema_name, table_info.name());
 }
 
-Result<std::vector<TableInfoPtr>> GetTablesEligibleForXClusterReplication(
+std::string TableDesignator::ToString() const {
+  return strings::Substitute("$0.$1 [id=$2]", pgschema_name, name, id);
+}
+
+TableDesignator GetDesignatorFromTableInfo(const TableInfo& table_info) {
+  TableDesignator designator;
+  designator.id = table_info.id();
+  designator.name = table_info.name();
+  designator.pgschema_name = table_info.pgschema_name();
+  return designator;
+}
+
+Result<std::vector<TableDesignator>> GetTablesEligibleForXClusterReplication(
     const CatalogManager& catalog_manager, const NamespaceId& namespace_id,
     bool include_sequences_data) {
   auto table_infos = VERIFY_RESULT(catalog_manager.GetTableInfosForNamespace(namespace_id));
-  EraseIf(
-      [](const TableInfoPtr& table) { return !IsTableEligibleForXClusterReplication(*table); },
-      &table_infos);
+
+  std::vector<TableDesignator> table_designators{};
+  for (const auto& table_info : table_infos) {
+    if (IsTableEligibleForXClusterReplication(*table_info)) {
+      table_designators.push_back(GetDesignatorFromTableInfo(*table_info));
+    }
+  }
 
   if (include_sequences_data) {
     auto sequence_table_info = catalog_manager.GetTableInfo(kPgSequencesDataTableId);
     if (sequence_table_info) {
-      table_infos.push_back(std::move(sequence_table_info));
+      TableDesignator designator = GetDesignatorFromTableInfo(*sequence_table_info);
+      designator.id = xcluster::GetSequencesDataAliasForNamespace(namespace_id);
+      table_designators.push_back(designator);
     }
   }
-  return table_infos;
+  return table_designators;
 }
 
 bool IsDbScoped(const SysUniverseReplicationEntryPB& replication_info) {
   return replication_info.has_db_scoped_info() &&
          replication_info.db_scoped_info().namespace_infos_size() > 0;
 }
+
+bool IsAutomaticDdlMode(const SysUniverseReplicationEntryPB& replication_info) {
+  return replication_info.has_db_scoped_info() &&
+         replication_info.db_scoped_info().automatic_ddl_mode();
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/master_xcluster_util.h b/src/yb/master/xcluster/master_xcluster_util.h
index 1265db8b9a..d4f65cd175 100644
--- a/src/yb/master/xcluster/master_xcluster_util.h
+++ b/src/yb/master/xcluster/master_xcluster_util.h
@@ -27,10 +27,22 @@ bool IsTableEligibleForXClusterReplication(const master::TableInfo& table);
 // Get the table name along with the YSQL schema name if this is a YSQL table.
 std::string GetFullTableName(const TableInfo& table_info);
 
-Result<std::vector<TableInfoPtr>> GetTablesEligibleForXClusterReplication(
+struct TableDesignator {
+  TableId id;
+  TableName name;
+  PgSchemaName pgschema_name;
+
+  std::string ToString() const;
+};
+
+TableDesignator GetDesignatorFromTableInfo(const TableInfo& table_info);
+
+Result<std::vector<TableDesignator>> GetTablesEligibleForXClusterReplication(
     const CatalogManager& catalog_manager, const NamespaceId& namespace_id,
     bool include_sequences_data);
 
 bool IsDbScoped(const SysUniverseReplicationEntryPB& replication_info);
 
+bool IsAutomaticDdlMode(const SysUniverseReplicationEntryPB& replication_info);
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
index 19b8ed3897..7b7b5000ac 100644
--- a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
+++ b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.cc
@@ -34,6 +34,8 @@
 #include "yb/master/xcluster/xcluster_manager.h"
 #include "yb/master/xcluster/xcluster_replication_group.h"
 
+#include "yb/tserver/pg_create_table.h"
+
 #include "yb/util/flags/auto_flags_util.h"
 #include "yb/util/status.h"
 #include "yb/util/status_format.h"
@@ -56,6 +58,8 @@ DECLARE_bool(enable_xcluster_auto_flag_validation);
 
 DECLARE_bool(TEST_xcluster_enable_sequence_replication);
 
+DECLARE_int32(master_yb_client_default_timeout_ms);
+
 using namespace std::placeholders;
 
 namespace yb::master {
@@ -126,7 +130,6 @@ XClusterInboundReplicationGroupSetupTask::XClusterInboundReplicationGroupSetupTa
       is_alter_replication_(xcluster::IsAlterReplicationGroupId(replication_group_id_)),
       stream_ids_provided_(!stream_ids_.empty()),
       transactional_(transactional),
-      is_db_scoped_(!source_namespace_ids_.empty()),
       automatic_ddl_mode_(automatic_ddl_mode) {
   log_prefix_ = Format(
       "xCluster InboundReplicationGroup [$0] $1: ", replication_group_id_,
@@ -204,11 +207,31 @@ bool XClusterInboundReplicationGroupSetupTask::TryCancel() {
 
 Status XClusterInboundReplicationGroupSetupTask::ValidateInputArguments() {
   SCHECK(!replication_group_id_.empty(), InvalidArgument, "Invalid Replication Group Id");
-  SCHECK(!source_table_ids_.empty(), InvalidArgument, "No tables provided");
+  auto universe_replication = catalog_manager_.GetUniverseReplication(
+      xcluster::GetOriginalReplicationGroupId(replication_group_id_));
+  if (is_alter_replication_) {
+    SCHECK(universe_replication, NotFound, "Replication group $0 not found", replication_group_id_);
+    auto l = universe_replication->LockForRead();
+    is_db_scoped_ = l->IsDbScoped();
+    SCHECK_EQ(
+        automatic_ddl_mode_, l->IsAutomaticDdlMode(), InvalidArgument,
+        "Automatic DDL mode setting passed differs from existing replication group's");
+  } else {
+    SCHECK(
+        !universe_replication, AlreadyPresent, "Replication group $0 already present",
+        replication_group_id_);
+    is_db_scoped_ = !source_namespace_ids_.empty();
+  }
 
   SCHECK(
       !automatic_ddl_mode_ || is_db_scoped_, InvalidArgument,
-      "Automatic DDL mode is only valid for DB scoped replication groups");
+      "Automatic DDL mode is only valid for DB-scoped replication groups");
+
+  SCHECK(
+      !is_db_scoped_ || transactional_, InvalidArgument,
+      "Transactional flag must be set for DB-scoped replication groups");
+
+  SCHECK(!source_table_ids_.empty(), InvalidArgument, "No tables provided");
 
   for (const auto& source_table_id : source_table_ids_) {
     SCHECK(!source_table_id.empty(), InvalidArgument, "Invalid Table Id");
@@ -237,24 +260,10 @@ Status XClusterInboundReplicationGroupSetupTask::ValidateInputArguments() {
 
   RETURN_NOT_OK(ValidateMasterAddressesBelongToDifferentCluster(master_, source_masters_));
 
-  SCHECK(
-      source_namespace_ids_.empty() || transactional_, InvalidArgument,
-      "Transactional flag must be set for Db scoped replication groups");
-
   SCHECK_EQ(
       source_namespace_ids_.size(), target_namespace_ids_.size(), InvalidArgument,
       "Source and target namespace ids must be of the same size");
 
-  auto universe_replication = catalog_manager_.GetUniverseReplication(
-      xcluster::GetOriginalReplicationGroupId(replication_group_id_));
-  if (is_alter_replication_) {
-    SCHECK(universe_replication, NotFound, "Replication group $0 not found", replication_group_id_);
-  } else {
-    SCHECK(
-        !universe_replication, AlreadyPresent, "Replication group $0 already present",
-        replication_group_id_);
-  }
-
   RETURN_NOT_OK(ValidateNamespaceListForDbScoped());
 
   IF_DEBUG_MODE(argument_validation_done_ = true);
@@ -277,6 +286,15 @@ Status XClusterInboundReplicationGroupSetupTask::FirstStep() {
     RETURN_NOT_OK(GetAutoFlagConfigVersionIfCompatible());
   }
 
+  if (automatic_ddl_mode_ && FLAGS_TEST_xcluster_enable_sequence_replication) {
+    // Ensure sequences_data table has been created.
+    auto local_client = master_.client_future();
+    RETURN_NOT_OK(tserver::CreateSequencesDataTable(
+        local_client.get(),
+        CoarseMonoClock::now() +
+            MonoDelta::FromMilliseconds(FLAGS_master_yb_client_default_timeout_ms)));
+  }
+
   LOG_WITH_PREFIX(INFO) << "Started schema validation for " << source_table_ids_.size()
                         << " table(s)";
 
@@ -524,7 +542,7 @@ Result<uint32> XClusterInboundReplicationGroupSetupTask::GetAutoFlagConfigVersio
 }
 
 Status XClusterInboundReplicationGroupSetupTask::ValidateNamespaceListForDbScoped() {
-  if (!is_db_scoped_) {
+  if (source_namespace_ids_.empty()) {
     return Status::OK();
   }
 
@@ -541,7 +559,7 @@ Status XClusterInboundReplicationGroupSetupTask::ValidateNamespaceListForDbScope
 }
 
 Status XClusterInboundReplicationGroupSetupTask::ValidateTableListForDbScoped() {
-  if (!is_db_scoped_) {
+  if (source_namespace_ids_.empty()) {
     return Status::OK();
   }
 
@@ -552,15 +570,15 @@ Status XClusterInboundReplicationGroupSetupTask::ValidateTableListForDbScoped()
 
   std::set<TableId> validated_tables;
   for (const auto& namespace_id : target_namespace_ids_) {
-    auto table_infos = VERIFY_RESULT(GetTablesEligibleForXClusterReplication(
+    auto table_designators = VERIFY_RESULT(GetTablesEligibleForXClusterReplication(
         catalog_manager_, namespace_id,
         /*include_sequences_data=*/
         (automatic_ddl_mode_ && FLAGS_TEST_xcluster_enable_sequence_replication)));
 
     std::vector<TableId> missing_tables;
 
-    for (const auto& table_info : table_infos) {
-      const auto& table_id = table_info->id();
+    for (const auto& designator : table_designators) {
+      auto table_id = designator.id;
       if (target_table_ids.contains(table_id)) {
         validated_tables.insert(table_id);
       } else {
@@ -674,8 +692,9 @@ Status XClusterTableSetupTask::FirstStep() {
   }
 
   auto table_info = std::make_shared<client::YBTableInfo>();
+  auto stripped_source_table_id = xcluster::StripSequencesDataAliasIfPresent(source_table_id_);
   return parent_task_->GetYbClient().GetTableSchemaById(
-      source_table_id_, table_info,
+      stripped_source_table_id, table_info,
       Bind(&XClusterTableSetupTask::GetTableSchemaCallback, shared_from(this), table_info));
 }
 
@@ -697,6 +716,10 @@ Status XClusterTableSetupTask::ProcessTable(
       source_info->table_name.namespace_name(), master::kSystemNamespaceName, NotSupported,
       "Cannot replicate system tables");
 
+  // Restore alias if any for sequences_data.  (We called GetTableSchemaById with the stripped table
+  // ID so it returns that one, not the alias ID.)
+  source_info->table_id = source_table_id_;
+
   auto target_schema = VERIFY_RESULT(ValidateSourceSchemaAndGetTargetSchema(*source_info));
 
   const auto& target_table_id = target_schema.identifier().table_id();
@@ -910,6 +933,12 @@ Result<GetTableSchemaResponsePB> XClusterTableSetupTask::ValidateSourceSchemaAnd
             target_clc_id));
   }
 
+  if (table_schema_resp.identifier().table_id() == kPgSequencesDataTableId) {
+    table_schema_resp.mutable_identifier()->set_table_id(
+        xcluster::GetSequencesDataAliasForNamespace(
+            VERIFY_RESULT(parent_task_->ConvertSourceToTargetNamespace(
+                VERIFY_RESULT(xcluster::GetReplicationNamespaceBelongsTo(source_table_id_))))));
+  }
   return table_schema_resp;
 }
 
@@ -938,7 +967,11 @@ Status XClusterTableSetupTask::PopulateTableStreamEntry(
 
   if (parent_task_->automatic_ddl_mode_) {
     // Mark this stream as special if it is for the ddl_queue table.
-    auto yb_table_info = parent_task_->catalog_manager_.GetTableInfo(target_table_id);
+    auto stripped_target_table_id = xcluster::StripSequencesDataAliasIfPresent(target_table_id);
+    auto yb_table_info = parent_task_->catalog_manager_.GetTableInfo(stripped_target_table_id);
+    SCHECK(
+        yb_table_info, NotFound,
+        Format("Table unexpectedly missing during replication: $0", stripped_target_table_id));
     stream_entry.set_is_ddl_queue_table(
         yb_table_info->GetTableType() == PGSQL_TABLE_TYPE &&
         yb_table_info->name() == xcluster::kDDLQueueTableName &&
@@ -1055,8 +1088,9 @@ Status XClusterTableSetupTask::ProcessNewStream(const Result<xrepl::StreamId>& s
 void XClusterTableSetupTask::PopulateTabletMapping() {
   VLOG_WITH_PREFIX_AND_FUNC(1);
 
+  auto stripped_source_table_id = xcluster::StripSequencesDataAliasIfPresent(source_table_id_);
   parent_task_->GetYbClient().GetTableLocations(
-      source_table_id_, /* max_tablets = */ std::numeric_limits<int32_t>::max(),
+      stripped_source_table_id, /* max_tablets = */ std::numeric_limits<int32_t>::max(),
       RequireTabletsRunning::kTrue, PartitionsOnly::kTrue,
       std::bind(&XClusterTableSetupTask::PopulateTabletMappingCallback, shared_from(this), _1),
       IncludeInactive::kFalse);
@@ -1093,8 +1127,10 @@ Status XClusterTableSetupTask::ProcessTabletMapping(
 
   auto& tablets = resp.tablet_locations();
 
-  auto target_tablet_keys = VERIFY_RESULT(
-      parent_task_->catalog_manager_.GetTableKeyRanges(table_setup_info_.target_table_id));
+  auto stripped_target_table_id =
+      xcluster::StripSequencesDataAliasIfPresent(table_setup_info_.target_table_id);
+  auto target_tablet_keys =
+      VERIFY_RESULT(parent_task_->catalog_manager_.GetTableKeyRanges(stripped_target_table_id));
 
   RETURN_NOT_OK(PopulateXClusterStreamEntryTabletMapping(
       source_table_id_, table_setup_info_.target_table_id, target_tablet_keys,
@@ -1135,4 +1171,16 @@ Status ValidateMasterAddressesBelongToDifferentCluster(
   return Status::OK();
 }
 
+Result<NamespaceId> XClusterInboundReplicationGroupSetupTask::ConvertSourceToTargetNamespace(
+    const NamespaceId& source_namespace) {
+  for (size_t i = 0; i < source_namespace_ids_.size(); i++) {
+    if (source_namespace_ids_[i] == source_namespace) {
+      return target_namespace_ids_[i];
+    }
+  }
+  return STATUS_FORMAT(
+      NotFound, "Couldn't find source namespace $0 in replication group's namespace mapping",
+      source_namespace);
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h
index deaf1b2e8c..1de187dad3 100644
--- a/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h
+++ b/src/yb/master/xcluster/xcluster_inbound_replication_group_setup_task.h
@@ -233,6 +233,8 @@ class XClusterInboundReplicationGroupSetupTask : public XClusterInboundReplicati
       REQUIRES(mutex_);
   void PopulateUniverseReplication(SysUniverseReplicationEntryPB& universe_pb) REQUIRES(mutex_);
 
+  Result<NamespaceId> ConvertSourceToTargetNamespace(const NamespaceId& source_namespace);
+
   Master& master_;
   CatalogManager& catalog_manager_;
   SysCatalogTable& sys_catalog_;
@@ -250,8 +252,8 @@ class XClusterInboundReplicationGroupSetupTask : public XClusterInboundReplicati
   const bool is_alter_replication_;
   const bool stream_ids_provided_;
   const bool transactional_;  // Not used in ALTER.
-  const bool is_db_scoped_;  // Not used in ALTER.
-  const bool automatic_ddl_mode_;  // Not used in ALTER.
+  bool is_db_scoped_;  // Computed in ValidateInputArguments.
+  const bool automatic_ddl_mode_;
 
   std::string log_prefix_;
 
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index 7acde37ac8..c4ab60b2d7 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -47,7 +47,12 @@ DEFINE_test_flag(bool, xcluster_enable_ddl_replication, false,
     "Enables xCluster automatic DDL replication.");
 
 DEFINE_test_flag(bool, xcluster_enable_sequence_replication, false,
-    "Enables xCluster automatic replication of sequences.");
+    "Enable xCluster automatic replication of sequences (requires automatic DB-scoped "
+    "replication).");
+
+DEFINE_test_flag(bool, force_automatic_ddl_replication_mode, false,
+    "Make XClusterCreateOutboundReplicationGroup always use automatic instead of semi-automatic "
+    "xCluster replication mode.");
 
 #define LOG_FUNC_AND_RPC \
   LOG_WITH_FUNC(INFO) << req->ShortDebugString() << ", from: " << RequestorString(rpc)
@@ -288,8 +293,10 @@ Status XClusterManager::XClusterCreateOutboundReplicationGroup(
   LOG_FUNC_AND_RPC;
   SCHECK(FLAGS_enable_xcluster_api_v2, IllegalState, "xCluster API v2 is not enabled.");
   SCHECK_PB_FIELDS_NOT_EMPTY(*req, replication_group_id, namespace_ids);
+  bool automatic_ddl_mode =
+      req->automatic_ddl_mode() || FLAGS_TEST_force_automatic_ddl_replication_mode;
   SCHECK(
-      !req->automatic_ddl_mode() || FLAGS_TEST_xcluster_enable_ddl_replication, InvalidArgument,
+      !automatic_ddl_mode || FLAGS_TEST_xcluster_enable_ddl_replication, InvalidArgument,
       "Automatic DDL replication (TEST_xcluster_enable_ddl_replication) is not enabled.");
 
   std::vector<NamespaceId> namespace_ids;
@@ -299,7 +306,7 @@ Status XClusterManager::XClusterCreateOutboundReplicationGroup(
 
   RETURN_NOT_OK(CreateOutboundReplicationGroup(
       xcluster::ReplicationGroupId(req->replication_group_id()), namespace_ids,
-      req->automatic_ddl_mode(), epoch));
+      automatic_ddl_mode, epoch));
 
   return Status::OK();
 }
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
index 2e734c6dcb..8228e8d810 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
@@ -16,6 +16,7 @@
 #include <gmock/gmock.h>
 
 #include "yb/client/xcluster_client_mock.h"
+#include "yb/common/xcluster_util.h"
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/xcluster/xcluster_outbound_replication_group_tasks.h"
 
@@ -174,6 +175,7 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
 
   void SetUp() {
     YBTest::SetUp();
+    LOG(INFO) << "Test uses automatic mode: " << UseAutomaticMode();
     ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_enable_ddl_replication) =
         UseAutomaticMode();
     ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_xcluster_enable_sequence_replication) =
@@ -267,13 +269,21 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
           [this](const NamespaceId& namespace_id, bool include_sequences_data) {
             std::lock_guard l(mutex_);
             auto tables = namespace_tables[namespace_id];
+            std::vector<TableDesignator> table_designators;
+            for (const auto& table_info : tables) {
+              table_designators.push_back(GetDesignatorFromTableInfo(*table_info));
+            }
             if (include_sequences_data) {
               auto sequences_tables = namespace_tables[kPgSequencesDataNamespaceId];
               if (sequences_tables.size() > 0) {
-                tables.push_back(sequences_tables.back());
+                TableDesignator table_designator;
+                table_designator.id = xcluster::GetSequencesDataAliasForNamespace(namespace_id);
+                table_designator.name = "sequences_data";
+                table_designator.pgschema_name = "";
+                table_designators.push_back(table_designator);
               }
             }
-            return tables;
+            return table_designators;
           },
       .create_xcluster_streams_func =
           [this](const std::vector<TableId>& table_ids, const LeaderEpoch&) {
@@ -336,11 +346,11 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
       } else if (table_info.table_name == kTableName2) {
         ASSERT_EQ(table_info.table_id, table_id2);
       } else if (table_info.table_name == "sequences_data") {
-        ASSERT_EQ(table_info.table_id, kPgSequencesDataTableId);
+        ASSERT_TRUE(xcluster::IsSequencesDataAlias(table_info.table_id));
       } else {
         FAIL() << "Unexpected table name: " << table_info.table_name;
       }
-      if (table_info.table_id != kPgSequencesDataTableId) {
+      if (!xcluster::IsSequencesDataAlias(table_info.table_id)) {
         if (skip_schema_name_check) {
           // Make sure it is not empty.
           EXPECT_FALSE(table_info.pg_schema_name.empty());
@@ -537,7 +547,7 @@ TEST_P(XClusterOutboundReplicationGroupMockedParameterized, CreateTargetReplicat
   std::vector<xrepl::StreamId> expected_streams{xcluster_streams.begin(), xcluster_streams.end()};
   std::vector<TableId> expected_tables{kTableId1};
   if (UseAutomaticMode()) {
-    expected_tables.push_back(kPgSequencesDataTableId);
+    expected_tables.push_back(xcluster::GetSequencesDataAliasForNamespace(kNamespaceId));
   }
   EXPECT_CALL(
       xcluster_client,
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
index 054f408b85..a1e1adbf62 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
@@ -267,13 +267,13 @@ Result<bool> XClusterOutboundReplicationGroup::MarkBootstrapTablesAsCheckpointed
       "Namespace in unexpected state");
 
   if (table_ids.empty()) {
-    auto table_infos = VERIFY_RESULT(helper_functions_.get_tables_func(
+    auto table_designators = VERIFY_RESULT(helper_functions_.get_tables_func(
         namespace_id, /*include_sequences_data=*/(
             AutomaticDDLMode() && FLAGS_TEST_xcluster_enable_sequence_replication)));
     std::set<TableId> tables;
     std::transform(
-        table_infos.begin(), table_infos.end(), std::inserter(tables, tables.begin()),
-        [](const auto& table_info) { return table_info->id(); });
+        table_designators.begin(), table_designators.end(), std::inserter(tables, tables.begin()),
+        [](const auto& table_designator) { return table_designator.id; });
 
     std::set<TableId> checkpointed_tables;
     std::transform(
@@ -348,13 +348,13 @@ Result<NamespaceName> XClusterOutboundReplicationGroup::GetNamespaceName(
 Result<XClusterOutboundReplicationGroup::NamespaceInfoPB>
 XClusterOutboundReplicationGroup::CreateNamespaceInfo(
     const NamespaceId& namespace_id, const LeaderEpoch& epoch) {
-  auto table_infos = VERIFY_RESULT(helper_functions_.get_tables_func(
+  auto table_designators = VERIFY_RESULT(helper_functions_.get_tables_func(
       namespace_id, /*include_sequences_data=*/(
           AutomaticDDLMode() && FLAGS_TEST_xcluster_enable_sequence_replication)));
-  VLOG_WITH_PREFIX_AND_FUNC(1) << "Tables: " << yb::ToString(table_infos);
+  VLOG_WITH_PREFIX_AND_FUNC(1) << "Tables: " << yb::ToString(table_designators);
 
   SCHECK(
-      !table_infos.empty(), InvalidArgument,
+      !table_designators.empty(), InvalidArgument,
       "Database should have at least one table in order to be part of xCluster replication");
 
   auto yb_ns_info = VERIFY_RESULT(GetYbNamespaceInfo(namespace_id));
@@ -363,9 +363,10 @@ XClusterOutboundReplicationGroup::CreateNamespaceInfo(
       "Only YSQL databases are supported in xCluster DB Scoped replication");
 
   if (yb_ns_info->colocated()) {
-    bool has_any_colocated_table =
-        std::any_of(table_infos.begin(), table_infos.end(), [](const TableInfoPtr& table_info) {
-          return IsColocatedDbTablegroupParentTableId(table_info->id());
+    bool has_any_colocated_table = std::any_of(
+        table_designators.begin(), table_designators.end(),
+        [](const TableDesignator& table_designator) {
+          return IsColocatedDbTablegroupParentTableId(table_designator.id);
         });
     SCHECK(
         has_any_colocated_table, InvalidArgument,
@@ -376,11 +377,11 @@ XClusterOutboundReplicationGroup::CreateNamespaceInfo(
   NamespaceInfoPB ns_info;
   ns_info.set_state(NamespaceInfoPB::CHECKPOINTING);
 
-  for (size_t i = 0; i < table_infos.size(); ++i) {
+  for (size_t i = 0; i < table_designators.size(); ++i) {
     NamespaceInfoPB::TableInfoPB table_info;
     table_info.set_is_checkpointing(true);
     table_info.set_is_part_of_initial_bootstrap(true);
-    ns_info.mutable_table_infos()->insert({table_infos[i]->id(), std::move(table_info)});
+    ns_info.mutable_table_infos()->insert({table_designators[i].id, std::move(table_info)});
   }
 
   return ns_info;
@@ -604,13 +605,14 @@ XClusterOutboundReplicationGroup::GetNamespaceCheckpointInfo(
   auto all_tables = VERIFY_RESULT(helper_functions_.get_tables_func(
       namespace_id, /*include_sequences_data=*/(
           AutomaticDDLMode() && FLAGS_TEST_xcluster_enable_sequence_replication)));
-  std::vector<scoped_refptr<TableInfo>> table_infos;
+  std::vector<TableDesignator> table_descriptors;
 
   if (!table_names.empty()) {
-    std::unordered_map<TableSchemaNamePair, scoped_refptr<TableInfo>, TableSchemaNamePairHash>
+    std::unordered_map<TableSchemaNamePair, TableDesignator, TableSchemaNamePairHash>
         table_names_map;
-    for (auto& table_info : all_tables) {
-      table_names_map[{table_info->name(), table_info->pgschema_name()}] = table_info;
+    for (auto& table_descriptor : all_tables) {
+      table_names_map[{table_descriptor.name, table_descriptor.pgschema_name}] =
+          table_descriptor;
     }
 
     for (auto& table : table_names) {
@@ -619,14 +621,14 @@ XClusterOutboundReplicationGroup::GetNamespaceCheckpointInfo(
           Format("Table $0.$1 not found in namespace $2", table.second, table.first, namespace_id));
 
       // Order of elements in table_infos should match the order in input table_names.
-      table_infos.push_back(table_names_map[table]);
+      table_descriptors.push_back(table_names_map[table]);
     }
   } else {
-    table_infos = std::move(all_tables);
+    table_descriptors = std::move(all_tables);
   }
 
-  for (const auto& table_info : table_infos) {
-    const auto& table_id = table_info->id();
+  for (const auto& table_descriptor : table_descriptors) {
+    const auto& table_id = table_descriptor.id;
     if (namespace_info->table_infos().count(table_id) == 0) {
       // We do not have this table! It has been manually removed using the repair APIs.
       // If user explicitly requested this table then fail the request.
@@ -651,8 +653,8 @@ XClusterOutboundReplicationGroup::GetNamespaceCheckpointInfo(
     NamespaceCheckpointInfo::TableInfo ns_table_info{
         .table_id = table_id,
         .stream_id = std::move(stream_id),
-        .table_name = table_info->name(),
-        .pg_schema_name = table_info->pgschema_name()};
+        .table_name = table_descriptor.name,
+        .pg_schema_name = table_descriptor.pgschema_name};
 
     ns_info.table_infos.emplace_back(std::move(ns_table_info));
   }
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.h b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
index bfd0459048..d9d4fd0914 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.h
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
@@ -18,6 +18,7 @@
 #include "yb/gutil/thread_annotations.h"
 
 #include "yb/master/xcluster/master_xcluster_types.h"
+#include "yb/master/xcluster/master_xcluster_util.h"
 #include "yb/master/xcluster/xcluster_catalog_entity.h"
 
 namespace yb {
@@ -40,7 +41,7 @@ class XClusterOutboundReplicationGroup
     const std::function<Status()> create_sequences_data_table_func;
     const std::function<Result<scoped_refptr<NamespaceInfo>>(const NamespaceIdentifierPB&)>
         get_namespace_func;
-    const std::function<Result<std::vector<TableInfoPtr>>(
+    const std::function<Result<std::vector<TableDesignator>>(
         const NamespaceId&, bool include_sequences_data)>
         get_tables_func;
     const std::function<Result<std::unique_ptr<XClusterCreateStreamsContext>>(
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
index c090980a10..e31d5d6c4b 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
@@ -13,6 +13,7 @@
 
 #include "yb/master/xcluster/xcluster_outbound_replication_group_tasks.h"
 
+#include "yb/common/xcluster_util.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/xcluster/xcluster_outbound_replication_group.h"
 
@@ -70,8 +71,9 @@ Status XClusterCheckpointNamespaceTask::FirstStep() {
     // Ensure sequences_data table has been created and added to our tables to checkpoint.
     // TODO: Consider making this async  so we don't have to burn a thread waiting.
     RETURN_NOT_OK(outbound_replication_group_.helper_functions_.create_sequences_data_table_func());
+    TableId sequence_table_alias_id = xcluster::GetSequencesDataAliasForNamespace(namespace_id_);
     RETURN_NOT_OK(outbound_replication_group_.AddTableToInitialBootstrapMapping(
-        namespace_id_, kPgSequencesDataTableId, epoch_));
+        namespace_id_, sequence_table_alias_id, epoch_));
   }
 
   ScheduleNextStep(
diff --git a/src/yb/master/xcluster/xcluster_replication_group.cc b/src/yb/master/xcluster/xcluster_replication_group.cc
index 503728070e..ecc54a696e 100644
--- a/src/yb/master/xcluster/xcluster_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_replication_group.cc
@@ -17,17 +17,19 @@
 #include "yb/client/client.h"
 #include "yb/client/xcluster_client.h"
 #include "yb/common/wire_protocol.pb.h"
+#include "yb/common/xcluster_util.h"
+
 #include "yb/master/catalog_entity_info.h"
 #include "yb/master/catalog_manager-internal.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/catalog_manager_util.h"
+#include "yb/master/sys_catalog.h"
 #include "yb/master/xcluster/master_xcluster_util.h"
+#include "yb/master/xcluster/xcluster_manager_if.h"
+#include "yb/master/xcluster_rpc_tasks.h"
+
 #include "yb/util/flags/auto_flags_util.h"
 #include "yb/util/is_operation_done_result.h"
-#include "yb/master/xcluster_rpc_tasks.h"
-#include "yb/master/xcluster/xcluster_manager_if.h"
-#include "yb/common/xcluster_util.h"
-#include "yb/master/sys_catalog.h"
 #include "yb/util/result.h"
 
 DEFINE_RUNTIME_bool(xcluster_skip_health_check_on_replication_setup, false,
@@ -484,11 +486,11 @@ Status RemoveNamespaceFromReplicationGroup(
     return Status::OK();
   }
 
-  auto consumer_tables =
-      VERIFY_RESULT(catalog_manager.GetTableInfosForNamespace(consumer_namespace_id));
+  auto consumer_designators = VERIFY_RESULT(GetTablesEligibleForXClusterReplication(
+      catalog_manager, consumer_namespace_id, /*include_sequences_data=*/true));
   std::unordered_set<TableId> consumer_table_ids;
-  for (const auto& table_info : consumer_tables) {
-    consumer_table_ids.insert(table_info->id());
+  for (const auto& table_designator : consumer_designators) {
+    consumer_table_ids.insert(table_designator.id);
   }
 
   std::vector<TableId> producer_table_ids;
diff --git a/src/yb/master/xcluster/xcluster_safe_time_service.cc b/src/yb/master/xcluster/xcluster_safe_time_service.cc
index 090e5d4d8d..20fa7d6194 100644
--- a/src/yb/master/xcluster/xcluster_safe_time_service.cc
+++ b/src/yb/master/xcluster/xcluster_safe_time_service.cc
@@ -19,6 +19,7 @@
 #include "yb/client/yb_op.h"
 
 #include "yb/common/schema_pbutil.h"
+#include "yb/common/xcluster_util.h"
 
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master_ddl.pb.h"
@@ -602,8 +603,10 @@ Status XClusterSafeTimeService::RefreshProducerTabletToNamespaceMap() {
 
         for (const auto& [_, stream_entry] : producer_entry.stream_map()) {
           const auto& consumer_table_id = stream_entry.consumer_table_id();
+          auto stripped_consumer_table_id =
+              xcluster::StripSequencesDataAliasIfPresent(consumer_table_id);
           auto consumer_namespace_id =
-              VERIFY_RESULT(catalog_manager_->GetTableNamespaceId(consumer_table_id));
+              VERIFY_RESULT(catalog_manager_->GetTableNamespaceId(stripped_consumer_table_id));
           for (const auto& [_, producer_tablets] : stream_entry.consumer_producer_tablet_map()) {
             for (const auto& tablet_id : producer_tablets.tablets()) {
               producer_tablet_namespace_map_[{replication_group_id, tablet_id}] =
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index 61391bb02e..5b822822a2 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -469,9 +469,11 @@ Result<std::unique_ptr<XClusterCreateStreamsContext>> XClusterSourceManager::Cre
   auto create_context = std::make_unique<XClusterCreateStreamContextImpl>(catalog_manager_, *this);
 
   for (const auto& table_id : table_ids) {
-    auto table_info = VERIFY_RESULT(catalog_manager_.FindTableById(table_id));
+    auto stripped_table_id = xcluster::StripSequencesDataAliasIfPresent(table_id);
+    auto table_info = VERIFY_RESULT(catalog_manager_.FindTableById(stripped_table_id));
     SCHECK(
-        table_info->LockForRead()->visible_to_client(), NotFound, "Table does not exist", table_id);
+        table_info->LockForRead()->visible_to_client(), NotFound, "Table does not exist",
+        stripped_table_id);
 
     VLOG(1) << "Creating xcluster streams for table: " << table_id;
 
@@ -522,7 +524,8 @@ Status XClusterSourceManager::CheckpointStreamsToOp0(
     StdStatusCallback user_callback) {
   std::vector<cdc::CDCStateTableEntry> entries;
   for (const auto& [table_id, stream_id] : table_streams) {
-    auto table = VERIFY_RESULT(catalog_manager_.FindTableById(table_id));
+    auto stripped_table_id = xcluster::StripSequencesDataAliasIfPresent(table_id);
+    auto table = VERIFY_RESULT(catalog_manager_.FindTableById(stripped_table_id));
     for (const auto& tablet : VERIFY_RESULT(table->GetTablets())) {
       cdc::CDCStateTableEntry entry(tablet->id(), stream_id);
       entry.checkpoint = OpId().Min();
@@ -547,7 +550,8 @@ Status XClusterSourceManager::CheckpointStreamsToEndOfWAL(
     // Set WAL retention here instead of during stream creation as we are processing smaller batches
     // of tables during the checkpoint phase whereas we create all streams in one batch to reduce
     // master IOs.
-    auto table_info = VERIFY_RESULT(catalog_manager_.FindTableById(table_id));
+    auto stripped_table_id = xcluster::StripSequencesDataAliasIfPresent(table_id);
+    auto table_info = VERIFY_RESULT(catalog_manager_.FindTableById(stripped_table_id));
     SCHECK(
         table_info->LockForRead()->visible_to_client(), NotFound, "Table does not exist", table_id);
 
@@ -720,7 +724,8 @@ Status XClusterSourceManager::DoProcessHiddenTablets() {
     TableHideInfo table_hide_info;
     table_hide_info.outbound_streams = GetStreamsForTable(table_id);
 
-    auto table = VERIFY_RESULT(catalog_manager_.GetTableById(table_id));
+    auto stripped_table_id = xcluster::StripSequencesDataAliasIfPresent(table_id);
+    auto table = VERIFY_RESULT(catalog_manager_.GetTableById(stripped_table_id));
     auto table_lock = table->LockForRead();
 
     if (table_lock->started_deleting()) {
@@ -900,7 +905,8 @@ std::vector<CDCStreamInfoPtr> XClusterSourceManager::GetStreamsForTable(
 Result<xrepl::StreamId> XClusterSourceManager::CreateNewXClusterStreamForTable(
     const TableId& table_id, cdc::StreamModeTransactional transactional,
     const std::optional<SysCDCStreamEntryPB::State>& initial_state, const LeaderEpoch& epoch) {
-  auto table_info = VERIFY_RESULT(catalog_manager_.FindTableById(table_id));
+  auto stripped_table_id = xcluster::StripSequencesDataAliasIfPresent(table_id);
+  auto table_info = VERIFY_RESULT(catalog_manager_.FindTableById(stripped_table_id));
 
   RETURN_NOT_OK(catalog_manager_.BackfillMetadataForXRepl(table_info, epoch));
 
@@ -954,7 +960,8 @@ Status XClusterSourceManager::PopulateXClusterStatus(
   for (const auto& [table_id, streams] : GetAllStreams()) {
     for (const auto& stream : streams) {
       XClusterOutboundTableStreamStatus table_stream_status;
-      auto table_info_res = catalog_manager_.GetTableById(table_id);
+      auto stripped_table_id = xcluster::StripSequencesDataAliasIfPresent(table_id);
+      auto table_info_res = catalog_manager_.GetTableById(stripped_table_id);
       if (table_info_res) {
         table_stream_status.full_table_name = GetFullTableName(*table_info_res.get());
       }
@@ -1115,7 +1122,8 @@ Status XClusterSourceManager::MarkIndexBackfillCompleted(
 Status XClusterSourceManager::RepairOutboundReplicationGroupAddTable(
     const xcluster::ReplicationGroupId& replication_group_id, const TableId& table_id,
     const xrepl::StreamId& stream_id, const LeaderEpoch& epoch) {
-  auto table_info = VERIFY_RESULT(catalog_manager_.FindTableById(table_id));
+  auto stripped_table_id = xcluster::StripSequencesDataAliasIfPresent(table_id);
+  auto table_info = VERIFY_RESULT(catalog_manager_.FindTableById(stripped_table_id));
 
   auto stream_info = VERIFY_RESULT(catalog_manager_.GetXReplStreamInfo(stream_id));
   auto stream_table_ids = stream_info->table_id();
diff --git a/src/yb/master/xcluster/xcluster_target_manager.cc b/src/yb/master/xcluster/xcluster_target_manager.cc
index 07c8fe1f37..effc6dfd65 100644
--- a/src/yb/master/xcluster/xcluster_target_manager.cc
+++ b/src/yb/master/xcluster/xcluster_target_manager.cc
@@ -13,13 +13,14 @@
 
 #include "yb/master/xcluster/xcluster_target_manager.h"
 
+#include "yb/common/xcluster_util.h"
+
 #include "yb/gutil/strings/util.h"
-#include "yb/master/catalog_entity_info.pb.h"
+
 #include "yb/master/catalog_entity_info.h"
+#include "yb/master/catalog_entity_info.pb.h"
 #include "yb/master/catalog_manager.h"
 #include "yb/master/master.h"
-
-#include "yb/master/xcluster_consumer_registry_service.h"
 #include "yb/master/xcluster/add_table_to_xcluster_target_task.h"
 #include "yb/master/xcluster/master_xcluster_util.h"
 #include "yb/master/xcluster/xcluster_bootstrap_helper.h"
@@ -28,6 +29,7 @@
 #include "yb/master/xcluster/xcluster_status.h"
 #include "yb/master/xcluster/xcluster_universe_replication_alter_helper.h"
 #include "yb/master/xcluster/xcluster_universe_replication_setup_helper.h"
+#include "yb/master/xcluster_consumer_registry_service.h"
 
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/is_operation_done_result.h"
@@ -338,7 +340,8 @@ Status XClusterTargetManager::RemoveDroppedTablesFromReplication(const LeaderEpo
   {
     SharedLock table_stream_l(table_stream_ids_map_mutex_);
     for (const auto& [table_id, _] : table_stream_ids_map_) {
-      auto table_info = catalog_manager_.GetTableInfo(table_id);
+      auto stripped_table_id = xcluster::StripSequencesDataAliasIfPresent(table_id);
+      auto table_info = catalog_manager_.GetTableInfo(stripped_table_id);
       if (!table_info || !table_info->LockForRead()->visible_to_client()) {
         tables_to_remove.insert(table_id);
         continue;
@@ -489,7 +492,9 @@ Result<XClusterInboundReplicationGroupStatus> XClusterTargetManager::GetUniverse
         if (stream_info) {
           table_status.target_table_id = stream_info->consumer_table_id();
 
-          auto table_info_res = catalog_manager_.GetTableById(table_status.target_table_id);
+          auto stripped_target_table_id =
+              xcluster::StripSequencesDataAliasIfPresent(table_status.target_table_id);
+          auto table_info_res = catalog_manager_.GetTableById(stripped_target_table_id);
           if (table_info_res) {
             const auto& table_info = table_info_res.get();
             namespace_name = table_info->namespace_name();
diff --git a/src/yb/master/xcluster/xcluster_universe_replication_alter_helper.cc b/src/yb/master/xcluster/xcluster_universe_replication_alter_helper.cc
index e8e4ffc873..ab57c6fa99 100644
--- a/src/yb/master/xcluster/xcluster_universe_replication_alter_helper.cc
+++ b/src/yb/master/xcluster/xcluster_universe_replication_alter_helper.cc
@@ -243,6 +243,7 @@ Status AlterUniverseReplicationHelper::AddTablesToReplication(
   setup_req.mutable_producer_master_addresses()->CopyFrom(
       original_universe_pb.producer_master_addresses());
   setup_req.set_transactional(original_universe_pb.transactional());
+  setup_req.set_automatic_ddl_mode(original_universe_pb.db_scoped_info().automatic_ddl_mode());
 
   if (req->has_producer_namespace_to_add()) {
     *setup_req.add_producer_namespaces() = req->producer_namespace_to_add();
