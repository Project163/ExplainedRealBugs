diff --git a/src/yb/common/CMakeLists.txt b/src/yb/common/CMakeLists.txt
index 5828acf201..79f0cfc6d7 100644
--- a/src/yb/common/CMakeLists.txt
+++ b/src/yb/common/CMakeLists.txt
@@ -89,7 +89,6 @@ set(COMMON_SRCS
   key_encoder.cc
   opid.cc
   pgsql_error.cc
-  path-handler-util.cc
   placement_info.cc
   pg_types.cc
   ql_protocol_util.cc
diff --git a/src/yb/common/path-handler-util.cc b/src/yb/common/path-handler-util.cc
deleted file mode 100644
index 89ba8f2939..0000000000
--- a/src/yb/common/path-handler-util.cc
+++ /dev/null
@@ -1,129 +0,0 @@
-// Copyright (c) YugabyteDB, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
-// in compliance with the License.  You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software distributed under the License
-// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
-// or implied.  See the License for the specific language governing permissions and limitations
-// under the License.
-//
-
-#include "yb/common/path-handler-util.h"
-
-#include "yb/util/format.h"
-
-namespace yb {
-
-namespace {
-
-const char* const kSortAndFilterTableScript = R"(
-<script>
-function castIfNumber(elem) {
- return elem.length ?
-          (elem.length > 14 || isNaN(Number(elem)) ?
-            elem.toLowerCase() :
-            Number(elem)) :
-          "~";
-}
-
-function sortTable(table_id, n) {
-  var asc_symb = ' <span style="color: grey">\u25B2</span>';
-  var desc_symb = ' <span style="color: grey">\u25BC</span>';
-  var i, swapCount = 0;
-  var table = document.getElementById(table_id);
-  if (table.rows.length < 3) {
-    return;
-  }
-  var switching = true;
-  var asc = true;
-  if (table.rows[0].getElementsByTagName("TH")[n].innerHTML.includes(asc_symb)) {
-    asc = false;
-  }
-
-  for(var j = 0; j < table.rows[0].getElementsByTagName("TH").length; j++) {
-   table.rows[0].getElementsByTagName("TH")[j].innerHTML =
-    table.rows[0].getElementsByTagName("TH")[j].innerHTML.replace(asc_symb, "").replace(desc_symb,
-      "");
-    if (j == n) {
-      sort_symb = asc ? asc_symb : desc_symb;
-      table.rows[0].getElementsByTagName("TH")[j].innerHTML =
-        table.rows[0].getElementsByTagName("TH")[j].innerHTML.concat(sort_symb);
-    }
-  }
-
-  while (switching) {
-    switching = false;
-    // Ignore header row.
-    for (i = 1; i < (table.rows.length - 1); i++) {
-      var swap = false;
-      var x = table.rows[i].getElementsByTagName("TD")[n];
-      var y = table.rows[i + 1].getElementsByTagName("TD")[n];
-      var cmpX = castIfNumber(x.innerHTML);
-      var cmpY = castIfNumber(y.innerHTML);
-
-      if (asc) {
-        if (cmpX > cmpY) {
-          swap= true;
-          break;
-        }
-      } else {
-        if (cmpX < cmpY) {
-          swap = true;
-          break;
-        }
-      }
-    }
-
-    if (swap) {
-      table.rows[i].parentNode.insertBefore(table.rows[i + 1], table.rows[i]);
-      switching = true;
-    }
-  }
-}
-
-function filterTableFunction(input_id, table_id) {
-  var filter = document.getElementById(input_id).value.toLowerCase();
-  var table = document.getElementById(table_id);
-  var tr = table.getElementsByTagName("tr");
-  for (var i = 0; i < tr.length; i++) {
-    if (tr[i].getElementsByTagName("th").length > 0) {
-     // Ignore header rows.
-      continue;
-    }
-    var row = tr[i].getElementsByTagName("td");
-    var found = false;
-    for (const td of row) {
-      if (td) {
-        var value = td.textContent || td.innerText;
-        if (value.toLowerCase().indexOf(filter) > -1) {
-          found = true;
-          break;
-        }
-      }
-    }
-
-    if(found) {
-      tr[i].style.display = "";
-    } else {
-      tr[i].style.display = "none";
-    }
-  }
-}
-</script>
-)";
-
-}  // namespace
-
-std::string GenerateTableFilterBox(const std::string& input_id, const std::string& table_id) {
-  return Format(
-      "<input type='text' id='$0' onkeyup='filterTableFunction(\"$0\", \"$1\")' "
-      "placeholder='Search for ...' title='Type in a text'>\n",
-      input_id, table_id);
-}
-
-std::string GetSortAndFilterTableScript() { return kSortAndFilterTableScript; }
-
-}  // namespace yb
diff --git a/src/yb/common/path-handler-util.h b/src/yb/common/path-handler-util.h
deleted file mode 100644
index c15ada4db6..0000000000
--- a/src/yb/common/path-handler-util.h
+++ /dev/null
@@ -1,79 +0,0 @@
-// Copyright (c) YugabyteDB, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
-// in compliance with the License.  You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software distributed under the License
-// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
-// or implied.  See the License for the specific language governing permissions and limitations
-// under the License.
-//
-
-#include <string>
-
-#include "yb/util/tostring.h"
-
-// Printing Tables which can be sorted and filtered.
-// The filter box is displayed just above the table.
-// Clicking on any column name will sort the table on that column value. The header row will display
-// the sort direction using the symbol ▲ to indicate descending and ▼ to indicate ascending. All non
-// numerical columns (isNaN) are sorted as lowercase strings.
-//
-// Usage:
-// 1. Print the table header using HTML_PRINT_TABLE_WITH_HEADER_ROW(table_type, column_names...). Or
-// HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(table_type, type_id, ...) when multiple tables have same
-// type (this happens when this is called inside loops).
-// 2. Print each row using HTML_PRINT_TABLE_ROW(column_values...)
-// 3. End the table using HTML_END_TABLE
-// 4. Follow the above sequence for each table in the page.
-// 5. At the end of the page add the javascript to perform the sort and filter functions using
-//      HTML_ADD_SORT_AND_FILTER_TABLE_SCRIPT
-
-#define INTERNAL_HTML_INTERNAL_PRINT_HEADER_FIELDS(i, table_name, field) \
-  output << "<th onclick=\"sortTable('" << table_name << "', " << _header_cnt << ")\">" \
-         << ::yb::AsString(field) << "</th>"; \
-  ++_header_cnt;
-
-#define INTERNAL_HTML_PRINT_TABLE_WITH_HEADER_ROW(table_id, ...) \
-  do { \
-    const auto table_name = table_id + "_table"; \
-    const auto table_filter = table_id + "_filter"; \
-    output << GenerateTableFilterBox(table_filter, table_name); \
-    uint32 _header_cnt = 0; \
-    output << "<table class='table table-striped' id='" << table_name \
-           << "' style='border: solid; border-width: thin;padding: 10px 10px;border-color:  " \
-              "#a8a8a8;'>\n"; \
-    output << "<tr>"; \
-    BOOST_PP_SEQ_FOR_EACH( \
-        INTERNAL_HTML_INTERNAL_PRINT_HEADER_FIELDS, table_name, \
-        BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__)) \
-    output << "</tr>\n"; \
-  } while (0)
-
-#define HTML_PRINT_TABLE_WITH_HEADER_ROW(table_type, ...) \
-  HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(table_type, 0, __VA_ARGS__)
-
-#define HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(table_type, type_id, ...) \
-  INTERNAL_HTML_PRINT_TABLE_WITH_HEADER_ROW( \
-      (std::string(BOOST_PP_STRINGIZE(table_type)) + ::yb::AsString(type_id)), __VA_ARGS__)
-
-#define HTML_INTERNAL_PRINT_ROW_FIELDS(i, data, field) "<td>" << ::yb::AsString(field) << "</td>" <<
-#define HTML_PRINT_TABLE_ROW(...) \
-  output << "<tr>" \
-          << BOOST_PP_SEQ_FOR_EACH( \
-                 HTML_INTERNAL_PRINT_ROW_FIELDS, ~, \
-                 BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__)) "</tr>\n"
-
-#define HTML_END_TABLE output << "</table>\n"
-
-#define HTML_ADD_SORT_AND_FILTER_TABLE_SCRIPT output << GetSortAndFilterTableScript()
-
-namespace yb {
-
-std::string GenerateTableFilterBox(const std::string& input_id, const std::string& table_id);
-
-std::string GetSortAndFilterTableScript();
-
-}  // namespace yb
diff --git a/src/yb/master/master-path-handlers.cc b/src/yb/master/master-path-handlers.cc
index 67d03324c4..40a9907402 100644
--- a/src/yb/master/master-path-handlers.cc
+++ b/src/yb/master/master-path-handlers.cc
@@ -43,9 +43,9 @@
 #include <boost/date_time/posix_time/time_formatters.hpp>
 
 #include "yb/cdc/xcluster_util.h"
+
 #include "yb/common/common_types_util.h"
 #include "yb/common/hybrid_time.h"
-#include "yb/common/path-handler-util.h"
 #include "yb/common/schema.h"
 #include "yb/common/schema_pbutil.h"
 #include "yb/common/tablet_limits.h"
@@ -79,6 +79,7 @@
 #include "yb/master/xcluster/xcluster_manager_if.h"
 #include "yb/master/xcluster/xcluster_status.h"
 
+#include "yb/server/html_print_helper.h"
 #include "yb/server/webserver.h"
 #include "yb/server/webui_util.h"
 
@@ -95,7 +96,7 @@
 #include "yb/util/version_info.h"
 #include "yb/util/version_info.pb.h"
 
-DEFINE_UNKNOWN_int32(
+DEFINE_RUNTIME_int32(
     hide_dead_node_threshold_mins, 60 * 24,
     "After this many minutes of no heartbeat from a node, hide it from the UI "
     "(we presume it has been removed from the cluster). If -1, this flag is ignored and node is "
@@ -152,26 +153,6 @@ std::optional<HostPortPB> GetRpcBindAddress(const ServerRegistrationPB& reg) {
 
 std::string BoolToString(bool val) { return val ? "true" : "false"; }
 
-class AutoFieldsetScope {
- public:
-  explicit AutoFieldsetScope(std::stringstream& output, const std::string& name) : output_(output) {
-    output_ << kFieldsetStart;
-    output << kFieldsetLegendStart << name << kFieldsetLegendEnd;
-  }
-  ~AutoFieldsetScope() { output_ << kFieldsetEnd; }
-
- private:
-  static constexpr auto kFieldsetStart =
-      "<br><fieldset style=\"border: solid; border-width: thin;padding: 10px 10px;border-color:  "
-      "#a8a8a8;\">\n";
-  static constexpr auto kFieldsetEnd = "</fieldset>\n";
-  static constexpr auto kFieldsetLegendStart =
-      "<legend visible=\"true\" style=\"width:auto;padding: 0px 10px;\">";
-  static constexpr auto kFieldsetLegendEnd = "</legend>\n";
-
-  std::stringstream& output_;
-};
-
 std::optional<uint64_t> ToUnsignedOrNullopt(int64_t val) {
   if (val == std::numeric_limits<int64_t>::max()) {
     return std::nullopt;
@@ -1123,6 +1104,8 @@ string GetOnDiskSizeInHtml(const TabletReplicaDriveInfo &info) {
 void MasterPathHandlers::HandleAllTables(
     const Webserver::WebRequest& req, Webserver::WebResponse* resp, bool only_user_tables) {
   std::stringstream* output = &resp->output;
+  HtmlPrintHelper html_print_helper(*output);
+
   master_->catalog_manager()->AssertLeaderLockAcquiredForReading();
 
   auto tables = master_->catalog_manager()->GetTables(GetTablesMode::kAll);
@@ -1162,8 +1145,10 @@ void MasterPathHandlers::HandleAllTables(
     string href_table_id = table_uuid;
     string table_name = table_locked->name();
     table_row[kState] = SysTablesEntryPB_State_Name(table_locked->pb.state());
-    table_row[kHidden] = table_locked->is_hidden() ? "true" : "false";
     Capitalize(&table_row[kState]);
+    if (table_locked->is_hidden()) {
+      table_row[kState] += " (HIDDEN)";
+    }
     table_row[kMessage] = EscapeForHtmlToString(table_locked->pb.state_msg());
 
     if (table->GetTableType() == PGSQL_TABLE_TYPE && table_cat != kParentTable) {
@@ -1236,82 +1221,62 @@ void MasterPathHandlers::HandleAllTables(
       continue;
     }
 
-    (*output) << "<div class='panel panel-default'>\n"
-              << "<div class='panel-heading'><h2 class='panel-title'>" << table_type_[type_index]
-              << " tables</h2></div>\n";
-    (*output) << "<div class='panel-body table-responsive'>";
+    auto fs = html_print_helper.CreateFieldset(table_type_[type_index] + " tables");
 
     if (ordered_tables[type_index].empty()) {
       (*output) << "There are no " << static_cast<char>(tolower(table_type_[type_index][0]))
                 << table_type_[type_index].substr(1) << " tables.\n";
     } else {
-      (*output) << "<table class='table table-responsive'>\n";
-      (*output) << "  <tr><th>Keyspace</th>\n"
-                << "  <th>Table Name</th>\n"
-                << "  <th>State</th>\n"
-                << "  <th>Message</th>\n"
-                << "  <th>UUID</th>\n"
-                << "  <th>YSQL OID</th>\n"
-                << "  <th>Hidden</th>\n";
+      std::vector<std::string> columns = {"Keyspace", "Table Name", "State",
+                                          "Message",  "UUID",       "YSQL OID"};
 
       if (type_index == kUserTable || type_index == kUserIndex) {
         if (has_tablegroups[type_index]) {
-          (*output) << "  <th>Parent OID</th>\n";
+          columns.push_back("Parent OID");
         }
 
         if (has_colocated_tables[type_index]) {
-          (*output) << "  <th>Colocation ID</th>\n";
+          columns.push_back("Colocation ID");
         }
       }
 
       if (type_index != kSystemTable) {
-        (*output) << "  <th>On-disk size</th></tr>\n";
+        columns.push_back("On-disk size");
       }
 
+      auto html_table = html_print_helper.CreateTablePrinter("table", type_index, columns);
+
       for (const StringMap::value_type& table : ordered_tables[type_index]) {
-        (*output) << Format(
-            "<tr>"
-            "<td>$0</td>"
-            "<td>$1</td>"
-            "<td>$2</td>"
-            "<td>$3</td>"
-            "<td>$4</td>"
-            "<td>$5</td>"
-            "<td>$6</td>",
-            table.second[kKeyspace],
-            table.second[kTableName],
-            table.second[kState],
-            table.second[kMessage],
-            table.second[kUuid],
-            table.second[kYsqlOid],
-            table.second[kHidden]);
+        auto& row = html_table.AddRow();
+
+        row.AddColumn(table.second[kKeyspace]);
+        row.AddColumn(table.second[kTableName]);
+        row.AddColumn(table.second[kState]);
+        row.AddColumn(table.second[kMessage]);
+        row.AddColumn(table.second[kUuid]);
+        row.AddColumn(table.second[kYsqlOid]);
 
         if (type_index == kUserTable || type_index == kUserIndex) {
           if (has_tablegroups[type_index]) {
-            (*output) << Format("<td>$0</td>", table.second[kParentOid]);
+            row.AddColumn(table.second[kParentOid]);
           }
 
           if (has_colocated_tables[type_index]) {
-            (*output) << Format("<td>$0</td>", table.second[kColocationId]);
+            row.AddColumn(table.second[kColocationId]);
           }
         }
 
         if (type_index != kSystemTable) {
-          (*output) << Format("<td>$0</td>", table.second[kOnDiskSize]);
+          row.AddColumn(table.second[kOnDiskSize]);
         }
-
-        (*output) << "</tr>\n";
       }
-
-      (*output) << "</table>\n";
+      html_table.Print();
 
       if (show_missing_size_footer[type_index]) {
         (*output) << "<p>* Some tablets did not provide disk size estimates,"
                   << " and were not added to the displayed totals.</p>";
       }
     }
-    (*output) << "</div> <!-- panel-body -->\n";
-    (*output) << "</div> <!-- panel -->\n";
   }
 }
 
@@ -2950,6 +2915,8 @@ void MasterPathHandlers::HandleGetXClusterJSON(
 void MasterPathHandlers::HandleXCluster(
     const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
   std::stringstream& output = resp->output;
+  HtmlPrintHelper html_print_helper(output);
+
   master_->catalog_manager()->AssertLeaderLockAcquiredForReading();
   auto xcluster_status_result = master_->xcluster_manager()->GetXClusterStatus();
 
@@ -2971,8 +2938,8 @@ void MasterPathHandlers::HandleXCluster(
     output << "<br><h3>Outbound Replication Groups</h3>\n";
     for (const auto& outbound_replication_group :
          xcluster_status.outbound_replication_group_statuses) {
-      auto group_fs = AutoFieldsetScope(
-          output, Format("Group: $0", outbound_replication_group.replication_group_id));
+      auto group_fs = html_print_helper.CreateFieldset(
+          Format("Group: $0", outbound_replication_group.replication_group_id));
 
       output << "<pre class=\"prettyprint\">" << "state: " << outbound_replication_group.state;
       if (!outbound_replication_group.target_universe_info.empty()) {
@@ -2981,8 +2948,8 @@ void MasterPathHandlers::HandleXCluster(
       output << "</pre>";
 
       for (const auto& namespace_status : outbound_replication_group.namespace_statuses) {
-        auto namespace_fs =
-            AutoFieldsetScope(output, Format("Namespace: $0", namespace_status.namespace_name));
+        auto namespace_fs = html_print_helper.CreateFieldset(
+            Format("Namespace: $0", namespace_status.namespace_name));
 
         output << "<pre class=\"prettyprint\">";
         output << "NamespaceId: " << namespace_status.namespace_id
@@ -2991,40 +2958,41 @@ void MasterPathHandlers::HandleXCluster(
                << "\nstatus: " << namespace_status.status;
         output << "</pre>";
 
-        HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(
-            outbound_replication_group, outbound_group_table_id, "Table name", "Table Id",
-            "Stream Id", "State", "Checkpointing", "Part of initial bootstrap");
+        auto outbound_replication_group = html_print_helper.CreateTablePrinter(
+            "outbound_replication_group", outbound_group_table_id,
+            {"Table name", "Table Id", "Stream Id", "State", "Checkpointing",
+             "Part of initial bootstrap"});
         outbound_group_table_id++;
 
         for (const auto& table_status : namespace_status.table_statuses) {
-          HTML_PRINT_TABLE_ROW(
+          outbound_replication_group.AddRow(
               table_status.full_table_name, table_status.table_id, table_status.stream_id,
               table_status.state, BoolToString(table_status.is_checkpointing),
               BoolToString(table_status.is_part_of_initial_bootstrap));
         }
-        HTML_END_TABLE;
+        outbound_replication_group.Print();
       }
     }
   }
 
   if (!xcluster_status.outbound_table_stream_statuses.empty()) {
     output << "<br><h3>Outbound table streams</h3>\n";
-    HTML_PRINT_TABLE_WITH_HEADER_ROW(
-        outbound_table_streams, "Table name", "Table Id", "Stream Id", "State");
+    auto outbound_streams = html_print_helper.CreateTablePrinter(
+        "outbound_table_streams", {"Table name", "Table Id", "Stream Id", "State"});
     for (const auto& table_status : xcluster_status.outbound_table_stream_statuses) {
-      HTML_PRINT_TABLE_ROW(
+      outbound_streams.AddRow(
           table_status.full_table_name, table_status.table_id, table_status.stream_id,
           table_status.state);
     }
-    HTML_END_TABLE;
+    outbound_streams.Print();
   }
 
   output << "<br><h3>Inbound Replication Groups</h3>\n";
 
   uint32 inbound_group_table_id = 0;
   for (const auto& inbound_replication_group : xcluster_status.inbound_replication_group_statuses) {
-    auto group_fs = AutoFieldsetScope(
-        output, Format("Group: $0", inbound_replication_group.replication_group_id));
+    auto group_fs = html_print_helper.CreateFieldset(
+        Format("Group: $0", inbound_replication_group.replication_group_id));
 
     output << "<pre class=\"prettyprint\">"
            << "state: " << inbound_replication_group.state
@@ -3045,27 +3013,25 @@ void MasterPathHandlers::HandleXCluster(
 
     for (const auto& [namespace_name, table_statuses] :
          inbound_replication_group.table_statuses_by_namespace) {
-      auto namespace_fs = AutoFieldsetScope(output, Format("Namespace: $0", namespace_name));
+      auto namespace_fs = html_print_helper.CreateFieldset(Format("Namespace: $0", namespace_name));
 
-      HTML_PRINT_TABLE_WITH_HEADER_ROW_WITH_ID(
-          inbound_replication_group, inbound_group_table_id, "Table name", "Producer Table Id",
-          "Stream Id", "Consumer Table Id", "Producer Tablet Count", "Consumer Tablet Count",
-          "Local tserver optimized", "Producer schema version", "Consumer schema version",
-          "Status");
+      auto inbound_replication_group = html_print_helper.CreateTablePrinter(
+          "inbound_replication_group", inbound_group_table_id,
+          {"Table name", "Producer Table Id", "Stream Id", "Consumer Table Id",
+           "Producer Tablet Count", "Consumer Tablet Count", "Local tserver optimized",
+           "Producer schema version", "Consumer schema version", "Status"});
       inbound_group_table_id++;
       for (const auto& table_status : table_statuses) {
-        HTML_PRINT_TABLE_ROW(
+        inbound_replication_group.AddRow(
             table_status.full_table_name, table_status.source_table_id, table_status.stream_id,
             table_status.target_table_id, table_status.source_tablet_count,
             table_status.target_tablet_count, BoolToString(table_status.local_tserver_optimized),
             table_status.source_schema_version, table_status.target_schema_version,
             table_status.status);
       }
-      HTML_END_TABLE;
+      inbound_replication_group.Print();
     }
   }
-
-  HTML_ADD_SORT_AND_FILTER_TABLE_SCRIPT;
 }
 
 void MasterPathHandlers::HandleVersionInfoDump(
@@ -3274,6 +3240,8 @@ void MasterPathHandlers::HandleLoadBalancer(
 void MasterPathHandlers::HandleStatefulServices(
     const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
   std::stringstream& output = resp->output;
+  HtmlPrintHelper html_print_helper(output);
+
   master_->catalog_manager()->AssertLeaderLockAcquiredForReading();
   auto stateful_service_result = master_->catalog_manager_impl()->GetStatefulServicesStatus();
 
@@ -3284,8 +3252,9 @@ void MasterPathHandlers::HandleStatefulServices(
   }
 
   output << "<h1>Stateful Services</h1>\n";
-  HTML_PRINT_TABLE_WITH_HEADER_ROW(
-      stateful_services, "Service Name", "Hosting server", "Table Id", "Tablet ID");
+  auto stateful_services = html_print_helper.CreateTablePrinter(
+      "stateful_services", {"Service Name", "Hosting server", "Table Id", "Tablet ID"});
+
   for (const auto& service : *stateful_service_result) {
     const auto& reg = service.hosting_node->GetRegistration();
     const auto& host_port = GetHttpHostPortFromServerRegistration(reg.common());
@@ -3297,13 +3266,12 @@ void MasterPathHandlers::HandleStatefulServices(
             "$0.$1.$2", cloud_info.placement_cloud(), cloud_info.placement_region(),
             cloud_info.placement_zone())));
 
-    HTML_PRINT_TABLE_ROW(
+    stateful_services.AddRow(
         service.service_name, host_server,
         Format("<a href=\"/table?id=$0\">$0</a>", service.service_table_id),
         service.service_tablet_id);
   }
-  HTML_END_TABLE;
-  HTML_ADD_SORT_AND_FILTER_TABLE_SCRIPT;
+  stateful_services.Print();
 }
 
 void MasterPathHandlers::HandleStatefulServicesJson(
diff --git a/src/yb/server/CMakeLists.txt b/src/yb/server/CMakeLists.txt
index 05b12aa447..4aa9bb9038 100644
--- a/src/yb/server/CMakeLists.txt
+++ b/src/yb/server/CMakeLists.txt
@@ -88,6 +88,7 @@ set(SERVER_PROCESS_SRCS
   default-path-handlers.cc
   generic_service.cc
   glog_metrics.cc
+  html_print_helper.cc
   monitored_task.cc
   pprof-path-handlers.cc
   rpc_server.cc
diff --git a/src/yb/server/html_print_helper.cc b/src/yb/server/html_print_helper.cc
new file mode 100644
index 0000000000..2bf6b85e11
--- /dev/null
+++ b/src/yb/server/html_print_helper.cc
@@ -0,0 +1,235 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/server/html_print_helper.h"
+#include "yb/util/format.h"
+#include "yb/util/logging.h"
+
+namespace yb {
+
+namespace {
+
+// This script is used to sort and filter tables in the html page.
+const char* const kSortAndFilterTableScript = R"(
+<script>
+function castIfNumber(elem) {
+ return elem.length ?
+          (elem.length > 14 || isNaN(Number(elem)) ?
+            elem.toLowerCase() :
+            Number(elem)) :
+          "~";
+}
+
+function sortTable(table_id, n) {
+  var asc_symb = ' <span style="color: grey">\u25B2</span>';
+  var desc_symb = ' <span style="color: grey">\u25BC</span>';
+  var i, swapCount = 0;
+  var table = document.getElementById(table_id);
+  if (table.rows.length < 3) {
+    return;
+  }
+  var switching = true;
+  var asc = true;
+  if (table.rows[0].getElementsByTagName("TH")[n].innerHTML.includes(asc_symb)) {
+    asc = false;
+  }
+
+  for(var j = 0; j < table.rows[0].getElementsByTagName("TH").length; j++) {
+   table.rows[0].getElementsByTagName("TH")[j].innerHTML =
+    table.rows[0].getElementsByTagName("TH")[j].innerHTML.replace(asc_symb, "").replace(desc_symb,
+      "");
+    if (j == n) {
+      sort_symb = asc ? asc_symb : desc_symb;
+      table.rows[0].getElementsByTagName("TH")[j].innerHTML =
+        table.rows[0].getElementsByTagName("TH")[j].innerHTML.concat(sort_symb);
+    }
+  }
+
+  while (switching) {
+    switching = false;
+    // Ignore header row.
+    for (i = 1; i < (table.rows.length - 1); i++) {
+      var swap = false;
+      var x = table.rows[i].getElementsByTagName("TD")[n];
+      var y = table.rows[i + 1].getElementsByTagName("TD")[n];
+      var cmpX = castIfNumber(x.innerHTML);
+      var cmpY = castIfNumber(y.innerHTML);
+
+      if (asc) {
+        if (cmpX > cmpY) {
+          swap= true;
+          break;
+        }
+      } else {
+        if (cmpX < cmpY) {
+          swap = true;
+          break;
+        }
+      }
+    }
+
+    if (swap) {
+      table.rows[i].parentNode.insertBefore(table.rows[i + 1], table.rows[i]);
+      switching = true;
+    }
+  }
+}
+
+function filterTableFunction(input_id, table_id) {
+  var filter = document.getElementById(input_id).value.toLowerCase();
+  var table = document.getElementById(table_id);
+  var tr = table.getElementsByTagName("tr");
+  for (var i = 0; i < tr.length; i++) {
+    if (tr[i].getElementsByTagName("th").length > 0) {
+     // Ignore header rows.
+      continue;
+    }
+    var row = tr[i].getElementsByTagName("td");
+    var found = false;
+    for (const td of row) {
+      if (td) {
+        var value = td.textContent || td.innerText;
+        if (value.toLowerCase().indexOf(filter) > -1) {
+          found = true;
+          break;
+        }
+      }
+    }
+
+    if(found) {
+      tr[i].style.display = "";
+    } else {
+      tr[i].style.display = "none";
+    }
+  }
+}
+</script>
+)";
+
+}  // namespace
+
+// ================================================================================
+// HtmlPrintHelper
+// ================================================================================
+
+HtmlPrintHelper::HtmlPrintHelper(std::stringstream& output) : output_(output) {}
+
+HtmlPrintHelper::~HtmlPrintHelper() {
+  if (has_tables_) {
+    // Include the script to sort and filter tables if we have any tables.
+    output_ << kSortAndFilterTableScript;
+  }
+}
+
+HtmlTablePrintHelper HtmlPrintHelper::CreateTablePrinter(
+    std::string table_name, std::vector<std::string> column_names) {
+  has_tables_ = true;
+
+  return HtmlTablePrintHelper(output_, std::move(table_name), std::move(column_names));
+}
+
+HtmlTablePrintHelper HtmlPrintHelper::CreateTablePrinter(
+    const std::string& table_name, uint32 table_id, std::vector<std::string> column_names) {
+  return CreateTablePrinter(Format("$0_$1", table_name, table_id), std::move(column_names));
+}
+
+HtmlFieldsetScope HtmlPrintHelper::CreateFieldset(const std::string& name) {
+  return HtmlFieldsetScope(output_, name);
+}
+
+// ================================================================================
+// HtmlTablePrintHelper
+// ================================================================================
+
+HtmlTablePrintHelper::HtmlTablePrintHelper(
+    std::stringstream& output, std::string table_name, std::vector<std::string> column_names)
+    : output_(output), table_name_(std::move(table_name)), column_names_(std::move(column_names)) {
+  DCHECK_GT(column_names_.size(), 0);
+}
+
+HtmlTablePrintHelper::~HtmlTablePrintHelper() {}
+
+HtmlTablePrintHelper::TableRow& HtmlTablePrintHelper::AddRow() {
+  table_rows_.emplace_back();
+  return table_rows_.back();
+}
+
+void HtmlTablePrintHelper::TableRow::AddColumn(const char* cell_value) {
+  column_values_.emplace_back(cell_value);
+}
+
+void HtmlTablePrintHelper::TableRow::AddColumn(const std::string& cell_value) {
+  AddColumn(cell_value.c_str());
+}
+void HtmlTablePrintHelper::TableRow::AddColumn(bool cell_value) {
+  AddColumn(cell_value ? "true" : "false");
+}
+
+void HtmlTablePrintHelper::Print() {
+  // Print the search box.
+  const auto table_filter = table_name_ + "_filter";
+  output_ << "<input type='text' id='" << table_filter << "' onkeyup='filterTableFunction(\""
+          << table_filter << "\", \"" << table_name_
+          << "\")' placeholder='Search for ...' title='Type in a text'>\n";
+
+  // Print the table definition.
+  output_ << "<table class='table table-striped' id='" << table_name_
+          << "' style='border: solid; border-width: thin;padding: 10px 10px;border-color:  "
+             "#a8a8a8;'>\n";
+  output_ << "<tr>";
+
+  // Print the table header row.
+  uint32 _header_cnt = 0;
+  for (const auto& column : column_names_) {
+    output_ << "<th onclick=\"sortTable('" << table_name_ << "', " << _header_cnt << ")\">"
+            << column << "</th>";
+    ++_header_cnt;
+  }
+
+  output_ << "</tr>\n";
+
+  // Print the table rows.
+  for (const auto& row : table_rows_) {
+    DCHECK_EQ(row.column_values_.size(), column_names_.size());
+    output_ << "<tr>";
+    for (const auto& column : row.column_values_) {
+      output_ << "<td>" << column << "</td>";
+    }
+    output_ << "</tr>\n";
+  }
+
+  output_ << "</table>\n";
+}
+
+// ================================================================================
+// HtmlFieldsetScope
+// ================================================================================
+
+namespace {
+static constexpr auto kFieldsetStart =
+    "<br><fieldset style=\"border: solid; border-width: thin;padding: 10px 10px;border-color:  "
+    "#a8a8a8;\">\n";
+static constexpr auto kFieldsetEnd = "</fieldset>\n";
+static constexpr auto kFieldsetLegendStart =
+    "<legend visible=\"true\" style=\"width:auto;padding: 0px 10px;\">";
+static constexpr auto kFieldsetLegendEnd = "</legend>\n";
+}  // namespace
+
+HtmlFieldsetScope::HtmlFieldsetScope(std::stringstream& output, const std::string& name)
+    : output_(output) {
+  output_ << kFieldsetStart;
+  output_ << kFieldsetLegendStart << name << kFieldsetLegendEnd;
+}
+HtmlFieldsetScope::~HtmlFieldsetScope() { output_ << kFieldsetEnd; }
+
+}  // namespace yb
diff --git a/src/yb/server/html_print_helper.h b/src/yb/server/html_print_helper.h
new file mode 100644
index 0000000000..03add6f08f
--- /dev/null
+++ b/src/yb/server/html_print_helper.h
@@ -0,0 +1,117 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include <sstream>
+
+#include "yb/util/tostring.h"
+
+namespace yb {
+
+class HtmlTablePrintHelper;
+class HtmlFieldsetScope;
+
+// Helper class to print HTML.
+class HtmlPrintHelper {
+ public:
+  explicit HtmlPrintHelper(std::stringstream& output);
+
+  HtmlTablePrintHelper CreateTablePrinter(
+      std::string table_name, std::vector<std::string> column_names);
+  HtmlTablePrintHelper CreateTablePrinter(
+      const std::string& table_name, uint32 table_id, std::vector<std::string> column_names);
+
+  HtmlFieldsetScope CreateFieldset(const std::string& name);
+
+  ~HtmlPrintHelper();
+
+ private:
+  friend class HtmlTablePrintHelper;
+
+  std::stringstream& output_;
+  bool has_tables_ = false;
+};
+
+// Helper class to print HTML tables.
+// Table can be sorted by clicking on the column header.
+// Table will have a search box to filter rows.
+// Table is closed when the object goes out of scope.
+// Usage:
+// Create using the HtmlPrintHelper::CreateTablePrinter method.
+// Ex:
+//  HtmlPrintHelper print_helper(output);
+// HtmlTablePrintHelper table_printer = print_helper.CreateTablePrinter("Table name",
+//    {"Column1","Column2"});
+// table_printer.AddRow("Value1","Value2");
+// table_printer.Print();
+class HtmlTablePrintHelper {
+ public:
+  struct TableRow {
+    std::vector<std::string> column_values_;
+
+    template <typename T>
+    void AddColumn(const T& cell_value) {
+      AddColumn(yb::AsString(cell_value));
+    }
+
+    void AddColumn(const char* cell_value);
+    void AddColumn(const std::string& cell_value);
+    void AddColumn(bool cell_value);
+
+    template <typename... Ts>
+    void AddColumns(const Ts&... values) {
+      (AddColumn(values), ...);
+    }
+  };
+
+  template <typename... Ts>
+  void AddRow(const Ts&... column_values) {
+    auto& row = AddRow();
+    row.AddColumns(column_values...);
+  }
+
+  HtmlTablePrintHelper::TableRow& AddRow();
+
+  void Print();
+
+  ~HtmlTablePrintHelper();
+
+ private:
+  friend class HtmlPrintHelper;
+
+  HtmlTablePrintHelper(
+      std::stringstream& output, std::string table_name, std::vector<std::string> column_names);
+
+  size_t ColumnCount() const { return column_names_.size(); }
+
+  std::stringstream& output_;
+  const std::string table_name_;
+  const std::vector<std::string> column_names_;
+  std::vector<TableRow> table_rows_;
+};
+
+// Helper class to print HTML fieldset in the current scope.
+// Fieldset is closed when the object goes out of scope.
+class HtmlFieldsetScope {
+ public:
+  ~HtmlFieldsetScope();
+
+ private:
+  friend class HtmlPrintHelper;
+  explicit HtmlFieldsetScope(std::stringstream& output, const std::string& name);
+
+  std::stringstream& output_;
+};
+
+}  // namespace yb
diff --git a/src/yb/server/pprof-path-handlers.cc b/src/yb/server/pprof-path-handlers.cc
index 14a60a4a0c..fdb95f9f90 100644
--- a/src/yb/server/pprof-path-handlers.cc
+++ b/src/yb/server/pprof-path-handlers.cc
@@ -64,6 +64,7 @@
 #include "yb/gutil/sysinfo.h"
 
 #include "yb/server/webserver.h"
+#include "yb/server/html_print_helper.h"
 
 #include "yb/util/callsite_profiling.h"
 #include "yb/util/env.h"
@@ -77,8 +78,6 @@
 #include "yb/util/tcmalloc_util.h"
 #include "yb/util/url-coding.h"
 
-#include "yb/common/path-handler-util.h"
-
 DECLARE_bool(enable_process_lifetime_heap_profiling);
 DECLARE_string(heap_profile_path);
 DECLARE_string(tmp_dir);
@@ -401,7 +400,7 @@ static void PprofSymbolHandler(const Webserver::WebRequest& req,
 static void PprofCallsiteProfileHandler(
     const Webserver::WebRequest& req,
     Webserver::WebResponse* resp) {
-  std::stringstream& output = resp->output;
+  HtmlPrintHelper html_print_helper(resp->output);
 
   bool reset = ParseLeadingBoolValue(FindWithDefault(req.parsed_args, "reset", ""), false);
   if (req.request_method == "GET") {
@@ -415,33 +414,27 @@ static void PprofCallsiteProfileHandler(
          [](const auto& a, const auto& b) {
            return a.count > b.count;
          });
-    HTML_PRINT_TABLE_WITH_HEADER_ROW(
-        timing_stats,
-        "File",
-        "Line number",
-        "Function",
-        "Code",
-        "Count",
-        "Cycles",
-        "Average Cycles",
-        "Microseconds",
-        "Avg Microseconds");
+
+    auto timing_stats = html_print_helper.CreateTablePrinter(
+        "timing_stats",
+          {"File",
+          "Line number",
+          "Function",
+          "Code",
+          "Count",
+          "Cycles",
+          "Average Cycles",
+          "Microseconds",
+          "Avg Microseconds"});
 
     for (const auto& entry : profile) {
-      HTML_PRINT_TABLE_ROW(
-          EscapeForHtmlToString(entry.file_path),
-          entry.line_number,
-          EscapeForHtmlToString(entry.function_name),
-          EscapeForHtmlToString(entry.code_line),
-          entry.count,
-          entry.total_cycles,
-          StringPrintf("%.3f", entry.avg_cycles),
-          entry.total_usec,
+      timing_stats.AddRow(
+          EscapeForHtmlToString(entry.file_path), entry.line_number,
+          EscapeForHtmlToString(entry.function_name), EscapeForHtmlToString(entry.code_line),
+          entry.count, entry.total_cycles, StringPrintf("%.3f", entry.avg_cycles), entry.total_usec,
           StringPrintf("%.3f", entry.avg_usec));
     }
-
-    HTML_END_TABLE;
-    HTML_ADD_SORT_AND_FILTER_TABLE_SCRIPT;
+    timing_stats.Print();
   }
 }
 
diff --git a/src/yb/tserver/tserver-path-handlers.cc b/src/yb/tserver/tserver-path-handlers.cc
index 24aeb38d2c..c80d9605b5 100644
--- a/src/yb/tserver/tserver-path-handlers.cc
+++ b/src/yb/tserver/tserver-path-handlers.cc
@@ -42,8 +42,6 @@
 #include "yb/cdc/cdc_service.h"
 #include "yb/cdc/xrepl_stream_stats.h"
 
-#include "yb/common/path-handler-util.h"
-
 #include "yb/consensus/consensus.h"
 #include "yb/consensus/consensus.pb.h"
 #include "yb/consensus/log_anchor_registry.h"
@@ -58,6 +56,7 @@
 #include "yb/rocksdb/db.h"
 #include "yb/rocksdb/util/options_parser.h"
 
+#include "yb/server/html_print_helper.h"
 #include "yb/server/webui_util.h"
 
 #include "yb/tablet/maintenance_manager.h"
@@ -721,17 +720,14 @@ std::map<TableIdentifier, TableInfo> GetTablesInfo(
 void TabletServerPathHandlers::HandleTablesPage(const Webserver::WebRequest& req,
                                                 Webserver::WebResponse* resp) {
   std::stringstream *output = &resp->output;
+  HtmlPrintHelper html_print_helper(*output);
   auto peers = tserver_->tablet_manager()->GetTabletPeers();
   auto table_map = GetTablesInfo(peers);
   bool show_missing_size_footer = false;
 
-  *output << "<h1>Tables</h1>\n"
-          << "<table class='table table-striped'>\n"
-          << "  <tr>\n"
-          << "    <th>Namespace</th><th>Table name</th><th>Table UUID</th>\n"
-          << "    <th>State</th><th>Hidden</th><th>Num SST Files</th>\n"
-          << "    <th>On-disk size</th><th>Raft roles</th>\n"
-          << "  </tr>\n";
+  auto html_table = html_print_helper.CreateTablePrinter(
+      "table", {"Namespace", "Table name", "Table UUID", "State", "Num SST Files", "On-disk size",
+                "Raft roles"});
 
   for (const auto& table_iter : table_map) {
     const auto& identifier = table_iter.first;
@@ -751,20 +747,14 @@ void TabletServerPathHandlers::HandleTablesPage(const Webserver::WebRequest& req
     }
     role_counts_html << "</ul>";
 
-    *output << Substitute(
-        "<tr><td>$0</td><td>$1</td><td>$2</td><td>$3</td><td>$4</td>"
-        "<td>$5</td><td>$6</td><td>$7</td></tr>\n",
-        EscapeForHtmlToString(info.namespace_name),
-        EscapeForHtmlToString(info.name),
+    html_table.AddRow(
+        EscapeForHtmlToString(info.namespace_name), EscapeForHtmlToString(info.name),
         EscapeForHtmlToString(identifier.uuid),
-        EscapeForHtmlToString(identifier.state),
-        info.is_hidden,
-        info.num_sst_files,
-        tables_disk_size_html,
-        role_counts_html.str());
+        Format("$0$1", identifier.state, (info.is_hidden ? " (HIDDEN)" : "")), info.num_sst_files,
+        tables_disk_size_html, role_counts_html.str());
   }
 
-  *output << "</table>\n";
+  html_table.Print();
 
   if (show_missing_size_footer) {
     *output << "<p>* Some tablets did not provide disk size estimates,"
@@ -1061,6 +1051,7 @@ std::vector<XClusterPollerStats> GetXClusterInboundStreamStats(TabletServer* con
 void TabletServerPathHandlers::HandleXClusterPage(
     const Webserver::WebRequest& req, Webserver::WebResponse* resp) {
   std::stringstream& output = resp->output;
+  HtmlPrintHelper html_print_helper(output);
 
   if (!FLAGS_enable_xcluster_stat_collection) {
     output << "<h3>xCluster stats collection is not enabled. Set enable_xcluster_stat_collection "
@@ -1080,47 +1071,45 @@ void TabletServerPathHandlers::HandleXClusterPage(
   if (!xcluster_outbound_stream_stats.empty()) {
     output << "<h3>xCluster outbound streams</h3>\n";
 
-    HTML_PRINT_TABLE_WITH_HEADER_ROW(
-        xcluster_streams, "Stream Id", "Produce Table Id", "Producer Tablet Id", "State",
-        "Avg poll delay (ms)", "Throughput (KiBps)", "Data sent (MiB)", "Records sent",
-        "Avg GetChanges latency (ms)", "WAL index sent", "WAL end index", "Last poll at", "Status");
+    auto xcluster_streams = html_print_helper.CreateTablePrinter(
+        "xcluster_streams",
+        {"Stream Id", "Produce Table Id", "Producer Tablet Id", "State", "Avg poll delay (ms)",
+         "Throughput (KiBps)", "Data sent (MiB)", "Records sent", "Avg GetChanges latency (ms)",
+         "WAL index sent", "WAL end index", "Last poll at", "Status"});
 
     for (const auto& stat : xcluster_outbound_stream_stats) {
-      HTML_PRINT_TABLE_ROW(
+      xcluster_streams.AddRow(
           stat.stream_id_str, stat.producer_table_id, stat.producer_tablet_id, stat.state,
           stat.avg_poll_delay_ms, StringPrintf("%.3f", stat.avg_throughput_kbps),
           StringPrintf("%.3f", stat.mbs_sent), stat.records_sent, stat.avg_get_changes_latency_ms,
           stat.sent_index, stat.latest_index, stat.last_poll_time.ToFormattedString(), stat.status);
     }
-
-    HTML_END_TABLE;
+    xcluster_streams.Print();
   }
 
   if (!xcluster_inbound_stream_stats.empty()) {
     output << "<h3>xCluster inbound streams</h3>\n";
 
-    HTML_PRINT_TABLE_WITH_HEADER_ROW(
-        xcluster_pollers, "ReplicationGroup Id", "Stream Id", "Consumer Table Id",
-        "Consumer Tablet Id", "Producer Tablet Id", "State", "Avg poll delay (ms)",
-        "Throughput (KiBps)", "Data received (MiB)", "Records received",
-        "Avg GetChanges latency (ms)", "Avg apply latency (ms)", "WAL index received",
-        "Last poll At", "Status");
+    auto xcluster_pollers = html_print_helper.CreateTablePrinter(
+        "xcluster_pollers",
+        {"ReplicationGroup Id", "Stream Id", "Consumer Table Id", "Consumer Tablet Id",
+         "Producer Tablet Id", "State", "Avg poll delay (ms)", "Throughput (KiBps)",
+         "Data received (MiB)", "Records received", "Avg GetChanges latency (ms)",
+         "Avg apply latency (ms)", "WAL index received", "Last poll At", "Status"});
 
     for (const auto& stat : xcluster_inbound_stream_stats) {
-      HTML_PRINT_TABLE_ROW(
+      xcluster_pollers.AddRow(
           stat.replication_group_id, stat.stream_id_str, stat.consumer_table_id,
           stat.consumer_tablet_id, stat.producer_tablet_id, stat.state, stat.avg_poll_delay_ms,
           StringPrintf("%.3f", stat.avg_throughput_kbps), StringPrintf("%.3f", stat.mbs_received),
           stat.records_received, stat.avg_get_changes_latency_ms, stat.avg_apply_latency_ms,
           stat.received_index, stat.last_poll_time.ToFormattedString(), stat.status);
     }
-
-    HTML_END_TABLE;
+    xcluster_pollers.Print();
   }
 
   output << "\n<aside><h5>Note:</h5><p>This data is collected over the last few polls. Check "
-             "metrics or logs for older and detailed information.</p></aside>";
-  HTML_ADD_SORT_AND_FILTER_TABLE_SCRIPT;
+            "metrics or logs for older and detailed information.</p></aside>";
 }
 
 void TabletServerPathHandlers::HandleXClusterJSON(
