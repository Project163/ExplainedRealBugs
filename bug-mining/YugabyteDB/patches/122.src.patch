diff --git a/src/yb/util/flags/flags-test.cc b/src/yb/util/flags/flags-test.cc
index 5c822be791..1a63d80a84 100644
--- a/src/yb/util/flags/flags-test.cc
+++ b/src/yb/util/flags/flags-test.cc
@@ -278,6 +278,34 @@ TEST_F(FlagsTest, ValidateFlagValue) {
   ASSERT_OK(flags_internal::ValidateFlagValue("vmodule", "files=1"));
   ASSERT_NOK(flags_internal::ValidateFlagValue("vmodule", "files="));
   ASSERT_EQ(FLAGS_vmodule, kVmoduleValue);
+
+  // Test Preview flags.
+  // When not in allow list we should only be able to set to the default value.
+  ASSERT_OK(flags_internal::ValidateFlagValue("preview_flag", "false"));
+  constexpr auto kPreviewFlagMissingError =
+      "Flag 'preview_flag' protects a feature that is currently in preview. In order for it to be "
+      "modified, you must acknowledge the risks by adding 'preview_flag' to the flag "
+      "'allowed_preview_flags_csv'";
+  ASSERT_NOK_STR_CONTAINS(
+      flags_internal::ValidateFlagValue("preview_flag", "true"), kPreviewFlagMissingError);
+
+  // Test the allowed_preview_flags_csv flag.
+  ASSERT_OK(flags_internal::ValidateFlagValue("allowed_preview_flags_csv", "na_flag"));
+  ASSERT_OK(flags_internal::ValidateFlagValue("allowed_preview_flags_csv", "preview_flag"));
+  std::string old_value, output_msg;
+  ASSERT_EQ(
+      SetFlag(
+          "allowed_preview_flags_csv", "preview_flag", flags_internal::SetFlagForce::kFalse,
+          &old_value, &output_msg),
+      flags_internal::SetFlagResult::SUCCESS);
+  ASSERT_OK(flags_internal::ValidateFlagValue("preview_flag", "true"));
+
+  ASSERT_EQ(
+      SetFlag(
+          "preview_flag", "true", flags_internal::SetFlagForce::kFalse, &old_value, &output_msg),
+      flags_internal::SetFlagResult::SUCCESS);
+  ASSERT_NOK_STR_CONTAINS(
+      flags_internal::ValidateFlagValue("allowed_preview_flags_csv", ""), kPreviewFlagMissingError);
 }
 
 } // namespace yb
diff --git a/src/yb/util/flags/flags.cc b/src/yb/util/flags/flags.cc
index 4573c0564c..f93f81c35d 100644
--- a/src/yb/util/flags/flags.cc
+++ b/src/yb/util/flags/flags.cc
@@ -272,6 +272,11 @@ string GetStaticProgramName() {
   return program_name;
 }
 
+// Forward declarations.
+namespace flags_internal {
+Status ValidateFlagValue(const CommandLineFlagInfo& flag_info, const std::string& value);
+}  // namespace flags_internal
+
 namespace {
 
 void AppendXMLTag(const char* tag, const string& txt, string* r) {
@@ -368,7 +373,7 @@ Status ValidateFlagsRequiringDelayedValidation() {
   for (const auto& flag_name : FlagsWithDelayedValidation()) {
     auto flag_info = google::GetCommandLineFlagInfoOrDie(flag_name.c_str());
     // Flag was already set without any validation. Check if the current value is valid.
-    RETURN_NOT_OK(flags_internal::ValidateFlagValue(flag_name, flag_info.current_value));
+    RETURN_NOT_OK(flags_internal::ValidateFlagValue(flag_info, flag_info.current_value));
   }
   FlagsWithDelayedValidation().clear();
 
@@ -435,35 +440,61 @@ void InvokeAllCallbacks(const std::vector<google::CommandLineFlagInfo>& flag_inf
   }
 }
 
-bool ValidateAllPreviewFlags(string* err_msg, const string& allowed_flags_csv) {
-  std::unordered_set<string> allowed_flags = strings::Split(allowed_flags_csv, ",");
+// If this is a preview flag and is being overridden to a non default value, then only allow it if
+// it is in allowed_preview_flags.
+// Returns true if this is not a preview flag, or if the new_value is the default.
+// 'err_msg' is set any time false is returned.
+bool IsPreviewFlagUpdateAllowed(
+    const CommandLineFlagInfo& flag_info, const unordered_set<FlagTag>& tags,
+    const std::string& new_value, const std::string& allowed_preview_flags, std::string* err_msg) {
+  if (!ContainsKey(tags, FlagTag::kPreview) || new_value == flag_info.default_value) {
+    return true;
+  }
+
+  const std::unordered_set<string> allowed_flags = strings::Split(allowed_preview_flags, ",");
+
+  if (!ContainsKey(allowed_flags, flag_info.name)) {
+    (*err_msg) = Format(
+        "Flag '$0' protects a feature that is currently in preview. In order for it to be "
+        "modified, you must acknowledge the risks by adding '$0' to the flag "
+        "'allowed_preview_flags_csv'",
+        flag_info.name);
+    return false;
+  }
+
+  return true;
+}
+
+// Makes sure that all preview flags which have been overridden are part of the list.
+// Allows non-existant flags, so that the allow list can be set in preparation for a yb upgrade.
+// Returns false and sets err_msg if the check fails.
+// We cannot set this as a validator for FLAGS_allowed_preview_flags_csv since gflags does not allow
+// calling 'GetAllFlags' from within a flag validator function.
+bool ValidateAllowedPreviewFlagsCsv(std::string* err_msg, const string& allowed_flags_csv) {
   std::vector<google::CommandLineFlagInfo> flag_infos;
   google::GetAllFlags(&flag_infos);
 
   for (const auto& flag : flag_infos) {
     unordered_set<FlagTag> tags;
     GetFlagTags(flag.name, &tags);
-
-    if (ContainsKey(tags, FlagTag::kPreview) && (flag.current_value != flag.default_value)) {
-      if (!ContainsKey(allowed_flags, flag.name)) {
-        (*err_msg) = Format(
-            "Flag '$0' protects a feature that is currently in preview. In order for it to be "
-            "modified, '$0' must be set in flag 'allowed_preview_flags_csv'",
-            flag.name);
-        return false;
-      }
+    if (!IsPreviewFlagUpdateAllowed(flag, tags, flag.current_value, allowed_flags_csv, err_msg)) {
+      return false;
     }
   }
 
   return true;
 }
 
-bool IsPreviewFlagAllowed(const CommandLineFlagInfo& flag_info, const string& new_value) {
-  if (new_value != flag_info.default_value) {
-    std::unordered_set<string> allowed_flags = strings::Split(FLAGS_allowed_preview_flags_csv, ",");
-    return ContainsKey(allowed_flags, flag_info.name);
+// Runs special validations for flag 'allowed_preview_flags_csv', and preview flags.
+bool IsFlagUpdateAllowed(
+    const CommandLineFlagInfo& flag_info, const unordered_set<FlagTag>& tags,
+    const std::string& new_value, std::string* err_msg) {
+  if (flag_info.name == "allowed_preview_flags_csv") {
+    return ValidateAllowedPreviewFlagsCsv(err_msg, new_value);
   }
-  return true;
+
+  return IsPreviewFlagUpdateAllowed(
+      flag_info, tags, new_value, FLAGS_allowed_preview_flags_csv, err_msg);
 }
 
 // Validates that the requested updates to vmodule can be made.
@@ -583,9 +614,8 @@ void ParseCommandLineFlags(int* argc, char*** argv, bool remove_flags) {
     // Run validation that were previously ignored due to DELAY_FLAG_VALIDATION_ON_STARTUP.
     CHECK_OK(ValidateFlagsRequiringDelayedValidation());
 
-    // Ensure all preview flags overridden are in allow list before invoking any callbacks.
     string err_msg;
-    if (!ValidateAllPreviewFlags(&err_msg, FLAGS_allowed_preview_flags_csv)) {
+    if (!ValidateAllowedPreviewFlagsCsv(&err_msg, FLAGS_allowed_preview_flags_csv)) {
       LOG(FATAL) << err_msg;
       return;
     }
@@ -729,21 +759,29 @@ std::string GetMaskedValueIfSensitive(const std::string& flag_name, const std::s
   return GetMaskedValueIfSensitive(tags, value);
 }
 
-Status ValidateFlagValue(const std::string& flag_name, const std::string& value) {
+Status ValidateFlagValue(const CommandLineFlagInfo& flag_info, const std::string& value) {
+  unordered_set<FlagTag> tags;
+  GetFlagTags(flag_info.name, &tags);
+  std::string output_msg;
+  // Preview flags require extra validations.
+  if (!IsFlagUpdateAllowed(flag_info, tags, value, &output_msg)) {
+    return STATUS_FORMAT(InvalidArgument, output_msg);
+  }
+
   // Clear previous errors if any.
   GetFlagValidatorSink().GetMessagesAndClear();
 
   std::string error_msg;
-  if (google::ValidateCommandLineOption(flag_name.c_str(), value.c_str(), &error_msg)) {
+  if (google::ValidateCommandLineOption(flag_info.name.c_str(), value.c_str(), &error_msg)) {
     return Status::OK();
   }
 
   auto validation_msgs = GetFlagValidatorSink().GetMessagesAndClear();
 
-  // error_msg originates from gflags, which may contain the value. Therefore, if it is sensitive,
-  // mask it.
+  // error_msg originates from gflags, which may contain the value. Therefore, if it is
+  // sensitive, mask it.
   // Ex: ERROR: failed validation of new value '1000' for flag 'ysql_conn_mgr_port'
-  if (!value.empty() && IsFlagSensitive(flag_name)) {
+  if (!value.empty() && IsFlagSensitive(flag_info.name)) {
     boost::replace_all(error_msg, Format("'$0'", value), Format("'$0'", kMaskedFlagValue));
   }
 
@@ -752,6 +790,14 @@ Status ValidateFlagValue(const std::string& flag_name, const std::string& value)
       validation_msgs.empty() ? "Bad value" : JoinStrings(validation_msgs, ";"));
 }
 
+Status ValidateFlagValue(const std::string& flag_name, const std::string& value) {
+  CommandLineFlagInfo flag_info;
+  SCHECK_FORMAT(
+      google::GetCommandLineFlagInfo(flag_name.c_str(), &flag_info), NotFound,
+      "Flag '$0' does not exist", flag_name);
+  return ValidateFlagValue(flag_info, value);
+}
+
 SetFlagResult SetFlag(
     const string& flag_name, const string& new_value, const SetFlagForce force, string* old_value,
     string* output_msg) {
@@ -775,20 +821,8 @@ SetFlagResult SetFlag(
     }
   }
 
-  // Only allowed preview flags can be changed.
-  if (flag_name == "allowed_preview_flags_csv") {
-    string err_msg;
-    if (!ValidateAllPreviewFlags(&err_msg, new_value)) {
-      *output_msg = err_msg;
-      return SetFlagResult::BAD_VALUE;
-    }
-  } else if (ContainsKey(tags, FlagTag::kPreview)) {
-    if (!IsPreviewFlagAllowed(flag_info, new_value)) {
-      *output_msg =
-          "Cannot modify Preview flag unless you acknowledge the risks by adding it to flag "
-          "'allowed_preview_flags_csv'";
-      return SetFlagResult::BAD_VALUE;
-    }
+  if (!IsFlagUpdateAllowed(flag_info, tags, new_value, output_msg)) {
+    return SetFlagResult::BAD_VALUE;
   }
 
   // Clear previous errors if any.
