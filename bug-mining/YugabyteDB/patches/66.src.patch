diff --git a/src/yb/integration-tests/tablet_health_manager-itest.cc b/src/yb/integration-tests/tablet_health_manager-itest.cc
index e4d6c2426a..dbb2a14b6d 100644
--- a/src/yb/integration-tests/tablet_health_manager-itest.cc
+++ b/src/yb/integration-tests/tablet_health_manager-itest.cc
@@ -33,6 +33,7 @@
 #include "yb/util/test_macros.h"
 #include "yb/util/tsan_util.h"
 
+DECLARE_int32(are_nodes_safe_to_take_down_timeout_buffer_ms);
 DECLARE_double(leader_failure_max_missed_heartbeat_periods);
 DECLARE_int32(raft_heartbeat_interval_ms);
 
@@ -84,7 +85,8 @@ class AreNodesSafeToTakeDownItest : public YBTableTestBase {
       const vector<string>& tserver_uuids, const vector<string>& master_uuids) {
     auto status = client_->AreNodesSafeToTakeDown(tserver_uuids, master_uuids, kFollowerLagBoundMs);
     ASSERT_NOK(status);
-    ASSERT_TRUE(status.IsTimedOut());
+    ASSERT_STR_CONTAINS(status.message().ToBuffer(), "Timed out");
+    ASSERT_STR_CONTAINS(status.message().ToBuffer(), "tablet(s) would be under-replicated");
   }
 
   const int kFollowerLagBoundMs = 1000 * kTimeMultiplier;
@@ -120,7 +122,12 @@ TEST_F(AreNodesSafeToTakeDownItest, MasterUnresponsive) {
   }, 30s, "Wait for master election if needed"));
 
   // Should time out trying to remove one of the 2 remaining masters.
+  // We should return within the actual deadline so we can provide the client with a readable error.
+  auto expected_deadline = CoarseMonoClock::Now() + client_->default_admin_operation_timeout();
   AssertCallTimesOut({} /* tserver_uuids */, {good_master->uuid()});
+  ASSERT_GT(CoarseMonoClock::Now(),
+            expected_deadline - FLAGS_are_nodes_safe_to_take_down_timeout_buffer_ms * 1ms);
+  ASSERT_LT(CoarseMonoClock::Now(), expected_deadline);
 
   // Should be able to remove the bad master.
   ASSERT_OK(client_->AreNodesSafeToTakeDown({}, {bad_master->uuid()}, kFollowerLagBoundMs));
@@ -134,7 +141,12 @@ TEST_F(AreNodesSafeToTakeDownItest, TserverUnresponsive) {
 
   // Should time out waiting to hear from bad_tserver when trying to remove one of the 2 tservers
   // that are not being taken down.
+  // We should return within the actual deadline so we can provide the client with a readable error.
+  auto expected_deadline = CoarseMonoClock::Now() + client_->default_admin_operation_timeout();
   AssertCallTimesOut({good_tserver->uuid()}, {} /* master_uuids */);
+  ASSERT_GT(CoarseMonoClock::Now(),
+            expected_deadline - FLAGS_are_nodes_safe_to_take_down_timeout_buffer_ms * 1ms);
+  ASSERT_LT(CoarseMonoClock::Now(), expected_deadline);
 
   // Should be able to remove the bad tserver once the leaders move to the other tservers.
   ASSERT_OK(WaitFor([&]() {
diff --git a/src/yb/master/tablet_health_manager.cc b/src/yb/master/tablet_health_manager.cc
index 28e8c1ac02..a61e1d9f8b 100644
--- a/src/yb/master/tablet_health_manager.cc
+++ b/src/yb/master/tablet_health_manager.cc
@@ -50,6 +50,7 @@
 #include "yb/tserver/tserver.pb.h"
 
 #include "yb/util/callsite_profiling.h"
+#include "yb/util/flags.h"
 #include "yb/util/flags/flag_tags.h"
 #include "yb/util/logging.h"
 #include "yb/util/monotime.h"
@@ -65,6 +66,10 @@ using std::vector;
 
 using namespace std::chrono_literals;
 
+DEFINE_RUNTIME_int32(are_nodes_safe_to_take_down_timeout_buffer_ms, 2000, "How much earlier than "
+    "the deadline to return from AreNodesSafeToTakeDown. This allows the caller to receive a "
+    "more readable error instead of a generic timeout error.");
+
 namespace yb {
 namespace master {
 
@@ -87,7 +92,7 @@ void AreNodesSafeToTakeDownCallbackHandler::ProcessHealthyReplica(const TabletId
 bool AreNodesSafeToTakeDownCallbackHandler::DoneProcessing() {
   // Wake up the main thread if we have processed all RPCs or all tablets have been removed from the
   // map (i.e., all tablets have enough replicas).
-  return outstanding_rpcs_.size() == 0 || required_replicas_.size() == 0;
+  return returned_ || outstanding_rpcs_.size() == 0 || required_replicas_.size() == 0;
 }
 
 template <typename T>
@@ -168,15 +173,13 @@ AreNodesSafeToTakeDownCallbackHandler::MakeHandler(
   return std::shared_ptr<AreNodesSafeToTakeDownCallbackHandler>(handler_ptr);
 }
 
-Result<ReplicaCountMap> AreNodesSafeToTakeDownCallbackHandler::WaitForResponses(
+std::pair<bool, ReplicaCountMap> AreNodesSafeToTakeDownCallbackHandler::WaitForResponses(
     CoarseTimePoint deadline) {
   UniqueLock lock(mutex_);
   bool finished_processing = cv_.wait_until(
       lock, deadline, std::bind(&AreNodesSafeToTakeDownCallbackHandler::DoneProcessing, this));
-  if (!finished_processing) {
-    return STATUS_FORMAT(TimedOut, "Timed out waiting for responses");
-  }
-  return std::move(required_replicas_);
+  returned_ = true;
+  return {finished_processing, std::move(required_replicas_)};
 }
 
 Result<unordered_map<TabletServerId, vector<TabletId>>>
@@ -259,6 +262,7 @@ Status AreNodesSafeToTakeDownDriver::ScheduleTServerTasks(
     std::unordered_map<TabletServerId, std::vector<TabletId>>&& tservers_to_tablets,
     std::shared_ptr<AreNodesSafeToTakeDownCallbackHandler> cb_handler) {
   for (auto& [ts_uuid, tablets] : tservers_to_tablets) {
+    VLOG(1) << "Scheduling AsyncTserverTabletHealthTask for tserver " << ts_uuid;
     auto call = std::make_shared<AsyncTserverTabletHealthTask>(
         master_, catalog_manager_->AsyncTaskPool(), ts_uuid, std::move(tablets), cb_handler);
     auto s = catalog_manager_->ScheduleTask(std::move(call));
@@ -274,6 +278,7 @@ Status AreNodesSafeToTakeDownDriver::ScheduleMasterTasks(
     std::vector<consensus::RaftPeerPB>&& masters,
     std::shared_ptr<AreNodesSafeToTakeDownCallbackHandler> cb_handler) {
   for (auto& master : masters) {
+    VLOG(1) << "Scheduling AsyncMasterTabletHealthTask for master " << master.permanent_uuid();
     auto call = std::make_shared<AsyncMasterTabletHealthTask>(
         master_, catalog_manager_->AsyncTaskPool(), std::move(master), cb_handler);
     auto s = catalog_manager_->ScheduleTask(std::move(call));
@@ -296,14 +301,14 @@ Status AreNodesSafeToTakeDownDriver::StartCallAndWait(CoarseTimePoint deadline)
   RETURN_NOT_OK(ScheduleTServerTasks(std::move(tservers_to_tablets), cb_handler));
   RETURN_NOT_OK(ScheduleMasterTasks(std::move(masters_to_contact), cb_handler));
 
-  auto tablets_missing_replicas = VERIFY_RESULT(cb_handler->WaitForResponses(deadline));
+  auto [finished, tablets_missing_replicas] = (cb_handler->WaitForResponses(deadline));
   if (!tablets_missing_replicas.empty()) {
     auto& [tablet_id, missing_replicas] = *tablets_missing_replicas.begin();
-    return STATUS_FORMAT(
-        IllegalState,
+    std::string msg = finished ? "" : "Timed out waiting for responses. ";
+    msg += Format(
         "$0 tablet(s) would be under-replicated. Example: tablet $1 would be under-replicated by "
-        "$2 replicas",
-        tablets_missing_replicas, tablet_id, missing_replicas);
+        "$2 replicas", tablets_missing_replicas.size(), tablet_id, missing_replicas);
+    return STATUS(IllegalState, msg);
   }
 
   return Status::OK();
@@ -314,7 +319,20 @@ Status TabletHealthManager::AreNodesSafeToTakeDown(
     rpc::RpcContext* rpc) {
   LOG(INFO) << "Processing AreNodesSafeToTakeDown call";
   AreNodesSafeToTakeDownDriver driver(*req, master_, catalog_manager_);
-  auto status = driver.StartCallAndWait(rpc->GetClientDeadline());
+
+  // Exit a bit earlier than the actual deadline so we can provide the caller with a readable
+  // explanation, instead of them just getting a generic timeout error.
+  auto adjusted_deadline =
+      rpc->GetClientDeadline() - FLAGS_are_nodes_safe_to_take_down_timeout_buffer_ms * 1ms;
+
+  if (CoarseMonoClock::Now() > adjusted_deadline) {
+    return SetupError(
+        resp->mutable_error(), MasterErrorPB::INTERNAL_ERROR,
+        STATUS(TimedOut, "Adjusted deadline (deadline minus buffer time) has already been exceeded "
+            " before starting AreNodesSafeToTakeDown check."));
+  }
+
+  auto status = driver.StartCallAndWait(adjusted_deadline);
   if (!status.ok()) {
     return SetupError(resp->mutable_error(), MasterErrorPB::INTERNAL_ERROR, status);
   }
diff --git a/src/yb/master/tablet_health_manager.h b/src/yb/master/tablet_health_manager.h
index b551a24dbc..187438a8e0 100644
--- a/src/yb/master/tablet_health_manager.h
+++ b/src/yb/master/tablet_health_manager.h
@@ -42,12 +42,20 @@ class AreNodesSafeToTakeDownCallbackHandler {
   template <typename T>
   void ReportHealthCheck(const T& resp, const std::string& uuid);
 
-  Result<ReplicaCountMap> WaitForResponses(CoarseTimePoint deadline);
+  // Returns whether we completed within the deadline, and a list of replicas that are still
+  // outstanding.
+  std::pair<bool, ReplicaCountMap> WaitForResponses(CoarseTimePoint deadline);
 
  private:
   const int64_t follower_lag_bound_ms_;
+
+  // The number of replicas that must heartbeat as healthy for this tablet to have quorum.
   ReplicaCountMap required_replicas_ GUARDED_BY(mutex_);
+
+  // The set of servers that have not yet responded to the health check RPCs.
   ServerUuidSet outstanding_rpcs_ GUARDED_BY(mutex_);
+
+  bool returned_ GUARDED_BY(mutex_) = false;
   std::mutex mutex_;
   std::condition_variable_any cv_;
 
