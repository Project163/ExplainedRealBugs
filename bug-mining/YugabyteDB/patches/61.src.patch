diff --git a/src/yb/client/ql-tablet-test.cc b/src/yb/client/ql-tablet-test.cc
index d4a216a8d1..d0081dbeee 100644
--- a/src/yb/client/ql-tablet-test.cc
+++ b/src/yb/client/ql-tablet-test.cc
@@ -70,6 +70,7 @@
 #include "yb/tserver/tserver_error.h"
 #include "yb/tserver/tserver_service.proxy.h"
 
+#include "yb/tserver/tserver_xcluster_context_if.h"
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/logging_test_util.h"
 #include "yb/util/random_util.h"
@@ -1396,7 +1397,7 @@ TEST_F(QLTabletTest, HistoryCutoff) {
         std::this_thread::sleep_for(100ms);
         continue;
       }
-      if (!tserver->GetXClusterSafeTimeMap()
+      if (!tserver->GetXClusterContext()
                .GetSafeTime(peers[0]->tablet()->metadata()->namespace_id())
                .ok()) {
         std::this_thread::sleep_for(100ms);
diff --git a/src/yb/integration-tests/xcluster/xcluster_consistency-test.cc b/src/yb/integration-tests/xcluster/xcluster_consistency-test.cc
index 385e7b9195..3cd33b02fa 100644
--- a/src/yb/integration-tests/xcluster/xcluster_consistency-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_consistency-test.cc
@@ -25,6 +25,7 @@
 #include "yb/tablet/tablet_peer.h"
 #include "yb/tserver/mini_tablet_server.h"
 #include "yb/tserver/tablet_server.h"
+#include "yb/tserver/tserver_xcluster_context_if.h"
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/flags.h"
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_safe_time-itest.cc b/src/yb/integration-tests/xcluster/xcluster_safe_time-itest.cc
index 13336e0a1a..91d31fa465 100644
--- a/src/yb/integration-tests/xcluster/xcluster_safe_time-itest.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_safe_time-itest.cc
@@ -35,6 +35,7 @@
 #include "yb/tserver/mini_tablet_server.h"
 #include "yb/tserver/tablet_server.h"
 #include "yb/tserver/ts_tablet_manager.h"
+#include "yb/tserver/tserver_xcluster_context_if.h"
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/flags.h"
 #include "yb/util/tsan_util.h"
diff --git a/src/yb/integration-tests/xcluster/xcluster_test_base.cc b/src/yb/integration-tests/xcluster/xcluster_test_base.cc
index c997707de3..23d62aaed6 100644
--- a/src/yb/integration-tests/xcluster/xcluster_test_base.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_test_base.cc
@@ -37,6 +37,7 @@
 #include "yb/master/master_replication.proxy.h"
 #include "yb/master/mini_master.h"
 #include "yb/rpc/rpc_controller.h"
+#include "yb/tserver/tserver_xcluster_context_if.h"
 #include "yb/tserver/xcluster_consumer_if.h"
 #include "yb/tserver/mini_tablet_server.h"
 #include "yb/tserver/tablet_server.h"
@@ -691,16 +692,14 @@ Status XClusterTestBase::WaitForValidSafeTimeOnAllTServers(
   for (auto& tserver : cluster->mini_cluster_->mini_tablet_servers()) {
     RETURN_NOT_OK(Wait(
         [&]() -> Result<bool> {
-          auto safe_time_result =
-              tserver->server()->GetXClusterSafeTimeMap().GetSafeTime(namespace_id);
+          auto safe_time_result = tserver->server()->GetXClusterContext().GetSafeTime(namespace_id);
           if (!safe_time_result || !*safe_time_result) {
             return false;
           }
           CHECK(safe_time_result.get()->is_valid());
           return true;
         },
-        *deadline,
-        description));
+        *deadline, description));
   }
 
   return Status::OK();
@@ -905,8 +904,7 @@ Status XClusterTestBase::WaitForSafeTime(
     }
     RETURN_NOT_OK(WaitFor(
         [&]() -> Result<bool> {
-          auto safe_time_result =
-              tserver->server()->GetXClusterSafeTimeMap().GetSafeTime(namespace_id);
+          auto safe_time_result = tserver->server()->GetXClusterContext().GetSafeTime(namespace_id);
           if (!safe_time_result) {
             CHECK(safe_time_result.status().IsTryAgain());
 
diff --git a/src/yb/integration-tests/xcluster/xcluster_test_base.h b/src/yb/integration-tests/xcluster/xcluster_test_base.h
index 3495857ea8..7ae3a21208 100644
--- a/src/yb/integration-tests/xcluster/xcluster_test_base.h
+++ b/src/yb/integration-tests/xcluster/xcluster_test_base.h
@@ -55,7 +55,7 @@ static const uint32_t kRangePartitionInterval = 500;
 
 template <typename TabletServer>
 auto GetSafeTime(const TabletServer* tserver, const NamespaceId& namespace_id) {
-  return tserver->GetXClusterSafeTimeMap().GetSafeTime(namespace_id);
+  return tserver->GetXClusterContext().GetSafeTime(namespace_id);
 }
 
 class XClusterTestBase : public YBTest {
diff --git a/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc b/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
index 199b5f588e..362d2af9dd 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ysql-test.cc
@@ -2541,6 +2541,11 @@ class XClusterYsqlTestReadOnly : public XClusterYsqlTest {
 
   static const std::string kTableName;
 
+  static Status CreateTable(Cluster* cluster, const NamespaceName& namespace_name) {
+    auto conn = VERIFY_RESULT(cluster->ConnectToDB(namespace_name));
+    return conn.ExecuteFormat("CREATE TABLE $0(id INT PRIMARY KEY, balance INT)", kTableName);
+  }
+
   Result<Connections> PrepareClusters() {
     RETURN_NOT_OK(Initialize(3 /* replication factor */));
     const auto namespace_2 = "test_namespace2";
@@ -2552,8 +2557,7 @@ class XClusterYsqlTestReadOnly : public XClusterYsqlTest {
 
     for (const auto& namespace_name : namespaces) {
       RETURN_NOT_OK(RunOnBothClusters([&namespace_name](Cluster* cluster) -> Status {
-        auto conn = VERIFY_RESULT(cluster->ConnectToDB(namespace_name));
-        return conn.ExecuteFormat("CREATE TABLE $0(id INT PRIMARY KEY, balance INT)", kTableName);
+        return CreateTable(cluster, namespace_name);
       }));
     }
     auto table_names = VERIFY_RESULT(producer_client()->ListTables(kTableName));
@@ -2601,6 +2605,12 @@ const std::string XClusterYsqlTestReadOnly::kTableName{"test_table"};
 
 TEST_F_EX(XClusterYsqlTest, DmlOperationsBlockedOnStandbyCluster, XClusterYsqlTestReadOnly) {
   auto consumer_conns = ASSERT_RESULT(PrepareClusters());
+
+  const auto namespace_3 = "namespace_3";
+  ASSERT_OK(CreateDatabase(&consumer_cluster_, namespace_3));
+  ASSERT_OK(CreateTable(&consumer_cluster_, namespace_3));
+  auto non_replicated_db_conn = ASSERT_RESULT(consumer_cluster_.ConnectToDB(namespace_3));
+
   auto query_patterns = {
       "INSERT INTO $0 VALUES($1, 100)", "UPDATE $0 SET balance = 0 WHERE id = $1",
       "DELETE FROM $0 WHERE id = $1"};
@@ -2616,6 +2626,10 @@ TEST_F_EX(XClusterYsqlTest, DmlOperationsBlockedOnStandbyCluster, XClusterYsqlTe
     }
   }
 
+  for (const auto& query : queries) {
+    ASSERT_OK(non_replicated_db_conn.Execute(query));
+  }
+
   ASSERT_OK(SetRoleToStandbyAndWaitForValidSafeTime());
 
   // Test that INSERT, UPDATE, and DELETE operations fail while the cluster is on STANDBY mode.
@@ -2625,7 +2639,9 @@ TEST_F_EX(XClusterYsqlTest, DmlOperationsBlockedOnStandbyCluster, XClusterYsqlTe
       const auto status = conn.Execute(query);
       ASSERT_NOK(status);
       ASSERT_STR_CONTAINS(
-          status.ToString(), "Data modification by DML is forbidden with STANDBY xCluster role");
+          status.ToString(),
+          "Data modification is forbidden on database that is the target of a transactional "
+          "xCluster replication");
 
       // Writes should be allowed when yb_non_ddl_txn_for_sys_tables_allowed is set
       // which happens during ysql_upgrades
@@ -2634,6 +2650,10 @@ TEST_F_EX(XClusterYsqlTest, DmlOperationsBlockedOnStandbyCluster, XClusterYsqlTe
     ASSERT_OK(conn.FetchFormat("SELECT * FROM $0", kTableName));
   }
 
+  for (const auto& query : queries) {
+    ASSERT_OK(non_replicated_db_conn.Execute(query));
+  }
+
   ASSERT_OK(SetRoleToActive());
 
   // Test that DML operations are allowed again once the cluster is set to ACTIVE mode.
@@ -2642,6 +2662,10 @@ TEST_F_EX(XClusterYsqlTest, DmlOperationsBlockedOnStandbyCluster, XClusterYsqlTe
       ASSERT_OK(conn.Execute(query));
     }
   }
+
+  for (const auto& query : queries) {
+    ASSERT_OK(non_replicated_db_conn.Execute(query));
+  }
 }
 
 TEST_F_EX(XClusterYsqlTest, DdlAndReadOperationsAllowedOnStandbyCluster, XClusterYsqlTestReadOnly) {
diff --git a/src/yb/master/master.cc b/src/yb/master/master.cc
index 96b84f0984..ff580922b8 100644
--- a/src/yb/master/master.cc
+++ b/src/yb/master/master.cc
@@ -310,8 +310,8 @@ Status Master::RegisterServices() {
       FLAGS_master_svc_queue_length,
       std::make_shared<tserver::PgClientServiceImpl>(
           *master_tablet_server_, client_future(), clock(),
-          std::bind(&Master::TransactionPool, this), mem_tracker(), metric_entity(),
-          messenger(), fs_manager_->uuid(), &options(), std::nullopt /* xcluster_context */)));
+          std::bind(&Master::TransactionPool, this), mem_tracker(), metric_entity(), messenger(),
+          fs_manager_->uuid(), &options(), nullptr /* xcluster_context */)));
 
   return Status::OK();
 }
diff --git a/src/yb/tserver/CMakeLists.txt b/src/yb/tserver/CMakeLists.txt
index a8fa8055ec..ce6c3a5487 100644
--- a/src/yb/tserver/CMakeLists.txt
+++ b/src/yb/tserver/CMakeLists.txt
@@ -222,6 +222,7 @@ set(TSERVER_SRCS
   pg_sequence_cache.cc
   pg_table_cache.cc
   pg_table_mutation_count_sender.cc
+  tserver_xcluster_context.cc
   read_query.cc
   remote_bootstrap_anchor_client.cc
   remote_client_base.cc
diff --git a/src/yb/tserver/heartbeater.cc b/src/yb/tserver/heartbeater.cc
index 27182c85be..26140259ff 100644
--- a/src/yb/tserver/heartbeater.cc
+++ b/src/yb/tserver/heartbeater.cc
@@ -613,8 +613,6 @@ Status Heartbeater::Thread::TryHeartbeat() {
     server_->UpdateTransactionTablesVersion(last_hb_response_.transaction_tables_version());
   }
 
-  server_->UpdateXClusterSafeTime(last_hb_response_.xcluster_namespace_to_safe_time());
-
   std::optional<AutoFlagsConfigPB> new_config;
   if (last_hb_response_.has_auto_flags_config()) {
     new_config = last_hb_response_.auto_flags_config();
diff --git a/src/yb/tserver/pg_client_service.cc b/src/yb/tserver/pg_client_service.cc
index 35d814450a..49c1fd192d 100644
--- a/src/yb/tserver/pg_client_service.cc
+++ b/src/yb/tserver/pg_client_service.cc
@@ -401,14 +401,10 @@ class PgClientServiceImpl::Impl {
   explicit Impl(
       std::reference_wrapper<const TabletServerIf> tablet_server,
       const std::shared_future<client::YBClient*>& client_future,
-      const scoped_refptr<ClockBase>& clock,
-      TransactionPoolProvider transaction_pool_provider,
-      rpc::Messenger* messenger,
-      const std::optional<XClusterContext>& xcluster_context,
-      PgMutationCounter* pg_node_level_mutation_counter,
-      MetricEntity* metric_entity,
-      const std::shared_ptr<MemTracker>& parent_mem_tracker,
-      const std::string& permanent_uuid,
+      const scoped_refptr<ClockBase>& clock, TransactionPoolProvider transaction_pool_provider,
+      rpc::Messenger* messenger, const TserverXClusterContextIf* xcluster_context,
+      PgMutationCounter* pg_node_level_mutation_counter, MetricEntity* metric_entity,
+      const std::shared_ptr<MemTracker>& parent_mem_tracker, const std::string& permanent_uuid,
       const server::ServerBaseOptions* tablet_server_opts)
       : tablet_server_(tablet_server.get()),
         client_future_(client_future),
@@ -1792,7 +1788,7 @@ class PgClientServiceImpl::Impl {
   std::unique_ptr<yb::client::AsyncClientInitializer> cdc_state_client_init_;
   std::shared_ptr<cdc::CDCStateTable> cdc_state_table_;
 
-  const std::optional<XClusterContext> xcluster_context_;
+  const TserverXClusterContextIf* xcluster_context_;
 
   PgMutationCounter* pg_node_level_mutation_counter_;
 
@@ -1818,14 +1814,11 @@ class PgClientServiceImpl::Impl {
 PgClientServiceImpl::PgClientServiceImpl(
     std::reference_wrapper<const TabletServerIf> tablet_server,
     const std::shared_future<client::YBClient*>& client_future,
-    const scoped_refptr<ClockBase>& clock,
-    TransactionPoolProvider transaction_pool_provider,
+    const scoped_refptr<ClockBase>& clock, TransactionPoolProvider transaction_pool_provider,
     const std::shared_ptr<MemTracker>& parent_mem_tracker,
-    const scoped_refptr<MetricEntity>& entity,
-    rpc::Messenger* messenger,
-    const std::string& permanent_uuid,
-    const server::ServerBaseOptions* tablet_server_opts,
-    const std::optional<XClusterContext>& xcluster_context,
+    const scoped_refptr<MetricEntity>& entity, rpc::Messenger* messenger,
+    const std::string& permanent_uuid, const server::ServerBaseOptions* tablet_server_opts,
+    const TserverXClusterContextIf* xcluster_context,
     PgMutationCounter* pg_node_level_mutation_counter)
     : PgClientServiceIf(entity),
       impl_(new Impl(
diff --git a/src/yb/tserver/pg_client_service.h b/src/yb/tserver/pg_client_service.h
index 27db2a28f7..7f58567dc7 100644
--- a/src/yb/tserver/pg_client_service.h
+++ b/src/yb/tserver/pg_client_service.h
@@ -28,7 +28,6 @@
 
 #include "yb/tserver/tserver_fwd.h"
 #include "yb/tserver/pg_client.service.h"
-#include "yb/tserver/xcluster_context.h"
 
 namespace yb {
 
@@ -37,6 +36,7 @@ class MemTracker;
 namespace tserver {
 
 class PgMutationCounter;
+class TserverXClusterContextIf;
 
 // Forwards call to corresponding PgClientSession sync method (see PG_CLIENT_SESSION_METHODS).
 #define YB_PG_CLIENT_METHODS \
@@ -100,14 +100,11 @@ class PgClientServiceImpl : public PgClientServiceIf {
   explicit PgClientServiceImpl(
       std::reference_wrapper<const TabletServerIf> tablet_server,
       const std::shared_future<client::YBClient*>& client_future,
-      const scoped_refptr<ClockBase>& clock,
-      TransactionPoolProvider transaction_pool_provider,
+      const scoped_refptr<ClockBase>& clock, TransactionPoolProvider transaction_pool_provider,
       const std::shared_ptr<MemTracker>& parent_mem_tracker,
-      const scoped_refptr<MetricEntity>& entity,
-      rpc::Messenger* messenger,
-      const std::string& permanent_uuid,
-      const server::ServerBaseOptions* tablet_server_opts,
-      const std::optional<XClusterContext>& xcluster_context = std::nullopt,
+      const scoped_refptr<MetricEntity>& entity, rpc::Messenger* messenger,
+      const std::string& permanent_uuid, const server::ServerBaseOptions* tablet_server_opts,
+      const TserverXClusterContextIf* xcluster_context = nullptr,
       PgMutationCounter* pg_node_level_mutation_counter = nullptr);
 
   ~PgClientServiceImpl();
diff --git a/src/yb/tserver/pg_client_session.cc b/src/yb/tserver/pg_client_session.cc
index eca3bad547..b45f094dab 100644
--- a/src/yb/tserver/pg_client_session.cc
+++ b/src/yb/tserver/pg_client_session.cc
@@ -47,7 +47,7 @@
 #include "yb/tserver/pg_response_cache.h"
 #include "yb/tserver/pg_sequence_cache.h"
 #include "yb/tserver/pg_table_cache.h"
-#include "yb/tserver/xcluster_safe_time_map.h"
+#include "yb/tserver/tserver_xcluster_context_if.h"
 
 #include "yb/util/backoff_waiter.h"
 #include "yb/util/flags.h"
@@ -579,7 +579,7 @@ Status Commit(client::YBTransaction* txn, PgResponseCache::Disabler disabler) {
 PgClientSession::PgClientSession(
     TransactionBuilder&& transaction_builder, SharedThisSource shared_this_source, uint64_t id,
     client::YBClient* client, const scoped_refptr<ClockBase>& clock, PgTableCache* table_cache,
-    const std::optional<XClusterContext>& xcluster_context,
+    const TserverXClusterContextIf* xcluster_context,
     PgMutationCounter* pg_node_level_mutation_counter, PgResponseCache* response_cache,
     PgSequenceCache* sequence_cache)
     : shared_this_(std::shared_ptr<PgClientSession>(std::move(shared_this_source), this)),
@@ -1063,15 +1063,19 @@ Status PgClientSession::DoPerform(const DataPtr& data, CoarseTimePoint deadline,
     }
   }
   auto ddl_mode = options.ddl_mode() || options.yb_non_ddl_txn_for_sys_tables_allowed();
-  if (!ddl_mode && xcluster_context_ && xcluster_context_->is_xcluster_read_only_mode()) {
+  if (!ddl_mode && xcluster_context_ &&
+      xcluster_context_->IsXClusterReadOnlyMode(options.namespace_id())) {
     for (const auto& op : data->req.ops()) {
       if (op.has_write() && !op.write().is_backfill()) {
         // Only DDLs and index backfill is allowed in xcluster read only mode.
         return STATUS(
-            InvalidArgument, "Data modification by DML is forbidden with STANDBY xCluster role");
+            IllegalState,
+            "Data modification is forbidden on database that is the target of a transactional "
+            "xCluster replication");
       }
     }
   }
+
   if (options.has_caching_info()) {
     data->cache_setter = VERIFY_RESULT(response_cache_.Get(
         options.mutable_caching_info(), &data->resp, &data->sidecars, deadline));
@@ -1168,8 +1172,7 @@ Status PgClientSession::UpdateReadPointForXClusterConsistentReads(
     return Status::OK();
   }
 
-  auto xcluster_safe_time =
-      VERIFY_RESULT(xcluster_context_->safe_time_map().GetSafeTime(namespace_id));
+  auto xcluster_safe_time = VERIFY_RESULT(xcluster_context_->GetSafeTime(namespace_id));
   if (!xcluster_safe_time) {
     // No xCluster safe time for this namespace.
       return Status::OK();
@@ -1191,8 +1194,7 @@ Status PgClientSession::UpdateReadPointForXClusterConsistentReads(
   // If read_point is set to a time ahead of the xcluster safe time then we wait.
   return WaitFor(
       [&requested_read_time, &namespace_id, this]() -> Result<bool> {
-        auto safe_time =
-            VERIFY_RESULT(xcluster_context_->safe_time_map().GetSafeTime(namespace_id));
+        auto safe_time = VERIFY_RESULT(xcluster_context_->GetSafeTime(namespace_id));
         if (!safe_time) {
           // We dont have a safe time anymore so no need to wait.
           return true;
diff --git a/src/yb/tserver/pg_client_session.h b/src/yb/tserver/pg_client_session.h
index 94208c0e9e..f543f15ddc 100644
--- a/src/yb/tserver/pg_client_session.h
+++ b/src/yb/tserver/pg_client_session.h
@@ -39,7 +39,6 @@
 #include "yb/tserver/tserver_fwd.h"
 #include "yb/tserver/pg_client.pb.h"
 #include "yb/tserver/tserver_shared_mem.h"
-#include "yb/tserver/xcluster_context.h"
 
 #include "yb/util/coding_consts.h"
 #include "yb/util/enums.h"
@@ -56,6 +55,7 @@ class ConsistentReadPoint;
 namespace tserver {
 
 class PgMutationCounter;
+class TserverXClusterContextIf;
 
 #define PG_CLIENT_SESSION_METHODS \
     (AlterDatabase) \
@@ -119,9 +119,8 @@ class PgClientSession {
 
   PgClientSession(
       TransactionBuilder&& transaction_builder, SharedThisSource shared_this_source, uint64_t id,
-      client::YBClient* client,
-      const scoped_refptr<ClockBase>& clock, PgTableCache* table_cache,
-      const std::optional<XClusterContext>& xcluster_context,
+      client::YBClient* client, const scoped_refptr<ClockBase>& clock, PgTableCache* table_cache,
+      const TserverXClusterContextIf* xcluster_context,
       PgMutationCounter* pg_node_level_mutation_counter, PgResponseCache* response_cache,
       PgSequenceCache* sequence_cache);
 
@@ -272,7 +271,7 @@ class PgClientSession {
   scoped_refptr<ClockBase> clock_;
   const TransactionBuilder transaction_builder_;
   PgTableCache& table_cache_;
-  const std::optional<XClusterContext> xcluster_context_;
+  const TserverXClusterContextIf* xcluster_context_;
   PgMutationCounter* pg_node_level_mutation_counter_;
   PgResponseCache& response_cache_;
   PgSequenceCache& sequence_cache_;
diff --git a/src/yb/tserver/tablet_server.cc b/src/yb/tserver/tablet_server.cc
index 97929421d9..b07d53082b 100644
--- a/src/yb/tserver/tablet_server.cc
+++ b/src/yb/tserver/tablet_server.cc
@@ -85,6 +85,7 @@
 #include "yb/tserver/tserver-path-handlers.h"
 #include "yb/tserver/tserver_auto_flags_manager.h"
 #include "yb/tserver/tserver_service.proxy.h"
+#include "yb/tserver/tserver_xcluster_context.h"
 #include "yb/tserver/xcluster_consumer_if.h"
 #include "yb/tserver/backup_service.h"
 
@@ -307,7 +308,8 @@ TabletServer::TabletServer(const TabletServerOptions& opts)
       tablet_manager_(new TSTabletManager(fs_manager_.get(), this, metric_registry())),
       path_handlers_(new TabletServerPathHandlers(this)),
       maintenance_manager_(new MaintenanceManager(MaintenanceManager::DEFAULT_OPTIONS)),
-      master_config_index_(0) {
+      master_config_index_(0),
+      xcluster_context_(new TserverXClusterContext()) {
   SetConnectionContextFactory(rpc::CreateConnectionContextFactory<rpc::YBInboundConnectionContext>(
       FLAGS_inbound_rpc_memory_limit, mem_tracker()));
   if (FLAGS_ysql_enable_db_catalog_version_mode) {
@@ -600,10 +602,8 @@ Status TabletServer::RegisterServices() {
       FLAGS_ts_remote_bootstrap_svc_queue_length, std::move(remote_bootstrap_service)));
   auto pg_client_service = std::make_shared<PgClientServiceImpl>(
       *this, tablet_manager_->client_future(), clock(),
-      std::bind(&TabletServer::TransactionPool, this), mem_tracker(), metric_entity(),
-      messenger(), permanent_uuid(), &options(),
-      XClusterContext(xcluster_safe_time_map_, xcluster_read_only_mode_),
-      &pg_node_level_mutation_counter_);
+      std::bind(&TabletServer::TransactionPool, this), mem_tracker(), metric_entity(), messenger(),
+      permanent_uuid(), &options(), xcluster_context_.get(), &pg_node_level_mutation_counter_);
   pg_client_service_ = pg_client_service;
   LOG(INFO) << "yb::tserver::PgClientServiceImpl created at " << pg_client_service.get();
   RETURN_NOT_OK(RegisterService(FLAGS_pg_client_svc_queue_length, std::move(pg_client_service)));
@@ -1070,18 +1070,10 @@ void TabletServer::SetPublisher(rpc::Publisher service) {
   publish_service_ptr_.reset(new rpc::Publisher(std::move(service)));
 }
 
-const XClusterSafeTimeMap& TabletServer::GetXClusterSafeTimeMap() const {
-  return xcluster_safe_time_map_;
-}
-
 PgMutationCounter& TabletServer::GetPgNodeLevelMutationCounter() {
   return pg_node_level_mutation_counter_;
 }
 
-void TabletServer::UpdateXClusterSafeTime(const XClusterNamespaceToSafeTimePBMap& safe_time_map) {
-  xcluster_safe_time_map_.Update(safe_time_map);
-}
-
 Result<cdc::XClusterRole> TabletServer::TEST_GetXClusterRole() const {
   auto xcluster_consumer_ptr = GetXClusterConsumer();
   if (!xcluster_consumer_ptr) {
@@ -1209,6 +1201,8 @@ Status TabletServer::CreateXClusterConsumer() {
 
 Status TabletServer::XClusterHandleMasterHeartbeatResponse(
     const master::TSHeartbeatResponsePB& resp) {
+  xcluster_context_->UpdateSafeTime(resp.xcluster_namespace_to_safe_time());
+
   auto* xcluster_consumer = GetXClusterConsumer();
 
   // Only create a xcluster consumer if consumer_registry is not null.
@@ -1221,7 +1215,7 @@ Status TabletServer::XClusterHandleMasterHeartbeatResponse(
       xcluster_consumer = GetXClusterConsumer();
     }
 
-    SetXClusterDDLOnlyMode(consumer_registry->role() != cdc::XClusterRole::ACTIVE);
+    xcluster_context_->SetDDLOnlyMode(consumer_registry->role() != cdc::XClusterRole::ACTIVE);
   }
 
   if (xcluster_consumer) {
@@ -1351,8 +1345,8 @@ Status TabletServer::SetCDCServiceEnabled() {
   return Status::OK();
 }
 
-void TabletServer::SetXClusterDDLOnlyMode(bool is_xcluster_read_only_mode) {
-  xcluster_read_only_mode_.store(is_xcluster_read_only_mode, std::memory_order_release);
+const TserverXClusterContextIf& TabletServer::GetXClusterContext() const {
+  return *xcluster_context_;
 }
 
 void TabletServer::SetCQLServer(yb::server::RpcAndWebServerBase* server) {
diff --git a/src/yb/tserver/tablet_server.h b/src/yb/tserver/tablet_server.h
index 6722a8ab2e..d4e8350d96 100644
--- a/src/yb/tserver/tablet_server.h
+++ b/src/yb/tserver/tablet_server.h
@@ -62,8 +62,6 @@
 #include "yb/tserver/tserver_shared_mem.h"
 #include "yb/tserver/tablet_server_interface.h"
 #include "yb/tserver/tablet_server_options.h"
-#include "yb/tserver/xcluster_safe_time_map.h"
-#include "yb/tserver/xcluster_context.h"
 
 #include "yb/util/locks.h"
 #include "yb/util/net/net_util.h"
@@ -94,6 +92,8 @@ class CDCServiceImpl;
 namespace tserver {
 
 class TserverAutoFlagsManager;
+class TserverXClusterContext;
+class TserverXClusterContextIf;
 class PgClientServiceImpl;
 class XClusterConsumerIf;
 
@@ -293,12 +293,10 @@ class TabletServer : public DbServerBase, public TabletServerIf {
 
   void RegisterCertificateReloader(CertificateReloader reloader) override;
 
-  const XClusterSafeTimeMap& GetXClusterSafeTimeMap() const;
+  const TserverXClusterContextIf& GetXClusterContext() const;
 
   PgMutationCounter& GetPgNodeLevelMutationCounter();
 
-  void UpdateXClusterSafeTime(const XClusterNamespaceToSafeTimePBMap& safe_time_map);
-
   Result<cdc::XClusterRole> TEST_GetXClusterRole() const;
 
   Status ListMasterServers(const ListMasterServersRequestPB* req,
@@ -331,8 +329,6 @@ class TabletServer : public DbServerBase, public TabletServerIf {
     return nullptr;
   }
 
-  void SetXClusterDDLOnlyMode(bool is_xcluster_read_only_mode);
-
   std::optional<uint64_t> GetCatalogVersionsFingerprint() const {
     return catalog_versions_fingerprint_.load(std::memory_order_acquire);
   }
@@ -455,9 +451,7 @@ class TabletServer : public DbServerBase, public TabletServerIf {
   // Bind address of postgres proxy under this tserver.
   HostPort pgsql_proxy_bind_address_;
 
-  XClusterSafeTimeMap xcluster_safe_time_map_;
-
-  std::atomic<bool> xcluster_read_only_mode_{false};
+  std::unique_ptr<TserverXClusterContext> xcluster_context_;
 
   PgMutationCounter pg_node_level_mutation_counter_;
 
diff --git a/src/yb/tserver/ts_tablet_manager.cc b/src/yb/tserver/ts_tablet_manager.cc
index 010dead216..91bc324ae5 100644
--- a/src/yb/tserver/ts_tablet_manager.cc
+++ b/src/yb/tserver/ts_tablet_manager.cc
@@ -112,6 +112,7 @@
 #include "yb/tserver/tablet_validator.h"
 #include "yb/tserver/tserver.pb.h"
 
+#include "yb/tserver/tserver_xcluster_context_if.h"
 #include "yb/util/debug/long_operation_tracker.h"
 #include "yb/util/debug/trace_event.h"
 #include "yb/util/debug-util.h"
@@ -3123,7 +3124,7 @@ docdb::HistoryCutoff TSTabletManager::AllowedHistoryCutoff(
   }
 
   auto xcluster_safe_time_result =
-      server_->GetXClusterSafeTimeMap().GetSafeTime(metadata->namespace_id());
+      server_->GetXClusterContext().GetSafeTime(metadata->namespace_id());
   if (!xcluster_safe_time_result) {
     VLOG(1) << "XCluster GetSafeTime call failed with " << xcluster_safe_time_result.status()
             << " for namespace: " << metadata->namespace_id();
diff --git a/src/yb/tserver/tserver_xcluster_context.cc b/src/yb/tserver/tserver_xcluster_context.cc
new file mode 100644
index 0000000000..d66e10da87
--- /dev/null
+++ b/src/yb/tserver/tserver_xcluster_context.cc
@@ -0,0 +1,43 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/tserver/tserver_xcluster_context.h"
+
+#include "yb/util/result.h"
+#include "yb/tserver/xcluster_safe_time_map.h"
+
+namespace yb::tserver {
+
+Result<std::optional<HybridTime>> TserverXClusterContext::GetSafeTime(
+    const NamespaceId& namespace_id) const {
+  return safe_time_map_.GetSafeTime(namespace_id);
+}
+
+bool TserverXClusterContext::IsXClusterReadOnlyMode(const NamespaceId namespace_id) const {
+  if (!read_only_mode_.load(std::memory_order_acquire)) {
+    return false;
+  }
+
+  // Only namespaces that are part of the safe time computation belong to xCluster replication.
+  return safe_time_map_.HasNamespace(namespace_id);
+}
+
+void TserverXClusterContext::UpdateSafeTime(const XClusterNamespaceToSafeTimePBMap& safe_time_map) {
+  safe_time_map_.Update(safe_time_map);
+}
+
+void TserverXClusterContext::SetDDLOnlyMode(bool is_xcluster_read_only_mode) {
+  read_only_mode_.store(is_xcluster_read_only_mode, std::memory_order_release);
+}
+
+}  // namespace yb::tserver
diff --git a/src/yb/tserver/tserver_xcluster_context.h b/src/yb/tserver/tserver_xcluster_context.h
new file mode 100644
index 0000000000..aff6862b7c
--- /dev/null
+++ b/src/yb/tserver/tserver_xcluster_context.h
@@ -0,0 +1,47 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include <atomic>
+#include <optional>
+
+#include "yb/common/entity_ids_types.h"
+#include "yb/tserver/tserver_xcluster_context_if.h"
+#include "yb/tserver/xcluster_safe_time_map.h"
+#include "yb/util/status_fwd.h"
+
+namespace yb {
+class HybridTime;
+class XClusterSafeTimeMap;
+
+namespace tserver {
+class TserverXClusterContext : public TserverXClusterContextIf {
+ public:
+  TserverXClusterContext() {}
+
+  Result<std::optional<HybridTime>> GetSafeTime(const NamespaceId& namespace_id) const override;
+
+  bool IsXClusterReadOnlyMode(const NamespaceId namespace_id) const override;
+
+  void UpdateSafeTime(const XClusterNamespaceToSafeTimePBMap& safe_time_map);
+
+  void SetDDLOnlyMode(bool is_xcluster_read_only_mode);
+
+ private:
+  XClusterSafeTimeMap safe_time_map_;
+  std::atomic<bool> read_only_mode_{false};
+};
+
+}  // namespace tserver
+}  // namespace yb
diff --git a/src/yb/tserver/tserver_xcluster_context_if.h b/src/yb/tserver/tserver_xcluster_context_if.h
new file mode 100644
index 0000000000..19e5f48300
--- /dev/null
+++ b/src/yb/tserver/tserver_xcluster_context_if.h
@@ -0,0 +1,36 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include <optional>
+
+#include "yb/common/entity_ids_types.h"
+#include "yb/util/status_fwd.h"
+
+namespace yb {
+class HybridTime;
+
+namespace tserver {
+class TserverXClusterContextIf {
+ public:
+  TserverXClusterContextIf() = default;
+  virtual ~TserverXClusterContextIf() = default;
+
+  virtual Result<std::optional<HybridTime>> GetSafeTime(const NamespaceId& namespace_id) const = 0;
+
+  virtual bool IsXClusterReadOnlyMode(const NamespaceId namespace_id) const = 0;
+};
+
+}  // namespace tserver
+}  // namespace yb
diff --git a/src/yb/tserver/xcluster_context.h b/src/yb/tserver/xcluster_context.h
deleted file mode 100644
index 3cda8de9da..0000000000
--- a/src/yb/tserver/xcluster_context.h
+++ /dev/null
@@ -1,41 +0,0 @@
-// Copyright (c) YugaByte, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
-// in compliance with the License.  You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software distributed under the License
-// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
-// or implied.  See the License for the specific language governing permissions and limitations
-// under the License.
-//
-
-#pragma once
-
-#include <atomic>
-#include <functional>
-
-#include "yb/tserver/xcluster_safe_time_map.h"
-
-namespace yb {
-
-class XClusterContext {
- public:
-  XClusterContext(
-      std::reference_wrapper<const XClusterSafeTimeMap> safe_time_map,
-      std::reference_wrapper<const std::atomic<bool>> is_xcluster_read_only_mode)
-      : safe_time_map_(safe_time_map), is_xcluster_read_only_mode_(is_xcluster_read_only_mode) {}
-
-  [[nodiscard]] const XClusterSafeTimeMap& safe_time_map() const { return safe_time_map_; }
-
-  [[nodiscard]] bool is_xcluster_read_only_mode() const {
-    return is_xcluster_read_only_mode_.load(std::memory_order_acquire);
-  }
-
- private:
-  const XClusterSafeTimeMap& safe_time_map_;
-  const std::atomic<bool>& is_xcluster_read_only_mode_;
-};
-
-}  // namespace yb
diff --git a/src/yb/tserver/xcluster_safe_time_map.cc b/src/yb/tserver/xcluster_safe_time_map.cc
index 99905b057b..c091f02c68 100644
--- a/src/yb/tserver/xcluster_safe_time_map.cc
+++ b/src/yb/tserver/xcluster_safe_time_map.cc
@@ -38,6 +38,11 @@
 namespace yb {
 XClusterSafeTimeMap::XClusterSafeTimeMap() : map_initialized_(false) {}
 
+bool XClusterSafeTimeMap::HasNamespace(const NamespaceId& namespace_id) const {
+  SharedLock l(xcluster_safe_time_map_mutex_);
+  return ContainsKey(xcluster_safe_time_map_, namespace_id);
+}
+
 Result<std::optional<HybridTime>> XClusterSafeTimeMap::GetSafeTime(
     const NamespaceId& namespace_id) const {
   SharedLock l(xcluster_safe_time_map_mutex_);
diff --git a/src/yb/tserver/xcluster_safe_time_map.h b/src/yb/tserver/xcluster_safe_time_map.h
index de83e4944f..e0c6a3b15e 100644
--- a/src/yb/tserver/xcluster_safe_time_map.h
+++ b/src/yb/tserver/xcluster_safe_time_map.h
@@ -37,6 +37,8 @@ class XClusterSafeTimeMap {
   Result<std::optional<HybridTime>> GetSafeTime(const NamespaceId& namespace_id) const
       EXCLUDES(xcluster_safe_time_map_mutex_);
 
+  bool HasNamespace(const NamespaceId& namespace_id) const;
+
   void Update(XClusterNamespaceToSafeTimePBMap safe_time_map)
       EXCLUDES(xcluster_safe_time_map_mutex_);
 
