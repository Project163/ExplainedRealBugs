diff --git a/src/yb/client/client.cc b/src/yb/client/client.cc
index 7f43ea0014..d8926f708c 100644
--- a/src/yb/client/client.cc
+++ b/src/yb/client/client.cc
@@ -34,13 +34,11 @@
 
 #include <algorithm>
 #include <limits>
-#include <map>
 #include <memory>
 #include <mutex>
 #include <set>
 #include <string>
 #include <unordered_map>
-#include <unordered_set>
 #include <vector>
 
 #include <boost/container/small_vector.hpp>
@@ -49,9 +47,9 @@
 
 #include "yb/cdc/cdc_types.h"
 
-#include "yb/client/client_fwd.h"
 #include "yb/client/client-internal.h"
 #include "yb/client/client_builder-internal.h"
+#include "yb/client/client_fwd.h"
 #include "yb/client/client_utils.h"
 #include "yb/client/meta_cache.h"
 #include "yb/client/namespace_alterer.h"
@@ -64,23 +62,21 @@
 #include "yb/client/tablet_server.h"
 #include "yb/client/yb_table_name.h"
 
+#include "yb/common/common.pb.h"
 #include "yb/common/common_flags.h"
 #include "yb/common/common_util.h"
-#include "yb/common/common.pb.h"
 #include "yb/common/entity_ids.h"
 #include "yb/common/init.h"
 #include "yb/common/pg_types.h"
 #include "yb/common/ql_type.h"
-#include "yb/common/roles_permissions.h"
-#include "yb/common/schema_pbutil.h"
 #include "yb/common/schema.h"
+#include "yb/common/schema_pbutil.h"
 #include "yb/common/transaction.h"
 #include "yb/common/wire_protocol.h"
 
 #include "yb/dockv/partition.h"
 
 #include "yb/gutil/bind.h"
-#include "yb/gutil/map-util.h"
 #include "yb/gutil/strings/substitute.h"
 
 #include "yb/master/master_admin.proxy.h"
@@ -90,9 +86,10 @@
 #include "yb/master/master_cluster.proxy.h"
 #include "yb/master/master_dcl.proxy.h"
 #include "yb/master/master_ddl.proxy.h"
+#include "yb/master/master_encryption.pb.h"
 #include "yb/master/master_encryption.proxy.h"
-#include "yb/master/master_replication.proxy.h"
 #include "yb/master/master_error.h"
+#include "yb/master/master_replication.proxy.h"
 #include "yb/master/master_util.h"
 
 #include "yb/rpc/messenger.h"
@@ -100,14 +97,10 @@
 #include "yb/rpc/proxy.h"
 #include "yb/rpc/rpc.h"
 
-#include "yb/tools/yb-admin_util.h"
 #include "yb/tserver/pg_client.pb.h"
-#include "yb/util/atomic.h"
-#include "yb/util/debug-util.h"
-#include "yb/util/flags.h"
+
 #include "yb/util/format.h"
 #include "yb/util/logging.h"
-#include "yb/util/logging_callback.h"
 #include "yb/util/mem_tracker.h"
 #include "yb/util/metric_entity.h"
 #include "yb/util/monotime.h"
@@ -115,16 +108,13 @@
 #include "yb/util/physical_time.h"
 #include "yb/util/result.h"
 #include "yb/util/scope_exit.h"
-#include "yb/util/size_literals.h"
 #include "yb/util/slice.h"
 #include "yb/util/status.h"
 #include "yb/util/status_format.h"
 #include "yb/util/status_log.h"
-#include "yb/util/trace.h"
 #include "yb/util/strongly_typed_bool.h"
 #include "yb/util/tsan_util.h"
 
-#include "yb/yql/cql/ql/ptree/pt_option.h"
 #include "yb/yql/pggate/ybc_pg_typedefs.h"
 
 using namespace std::literals;
@@ -300,8 +290,7 @@ DEFINE_test_flag(int32, create_namespace_if_not_exist_inject_delay_ms, 0,
                  "After checking a namespace does not exist, inject delay "
                  "before creating the namespace.");
 
-namespace yb {
-namespace client {
+namespace yb::client {
 
 using internal::MetaCache;
 using std::shared_ptr;
@@ -1139,8 +1128,8 @@ Status YBClient::ListClones(master::ListClonesResponsePB* ret) {
 }
 
 Status YBClient::ReservePgsqlOids(
-    const std::string& namespace_id, uint32_t next_oid, uint32_t count, uint32_t* begin_oid,
-    uint32_t* end_oid, bool use_secondary_space, uint32_t* oid_cache_invalidations_count) {
+    const std::string& namespace_id, uint32_t next_oid, uint32_t count, bool use_secondary_space,
+    uint32_t* begin_oid, uint32_t* end_oid, uint32_t* oid_cache_invalidations_count) {
   ReservePgsqlOidsRequestPB req;
   ReservePgsqlOidsResponsePB resp;
   req.set_namespace_id(namespace_id);
@@ -3081,5 +3070,4 @@ void YBClient::RequestAbortAllRpcs() {
   data_->rpcs_.RequestAbortAll();
 }
 
-}  // namespace client
-}  // namespace yb
+} // namespace yb::client
diff --git a/src/yb/client/client.h b/src/yb/client/client.h
index 6d79de5afe..c65c8f4ad8 100644
--- a/src/yb/client/client.h
+++ b/src/yb/client/client.h
@@ -498,9 +498,8 @@ class YBClient {
   // For Postgres: reserve oids for a Postgres database.
   // use_secondary_space is used by xCluster when a database is a target.
   Status ReservePgsqlOids(
-      const std::string& namespace_id, uint32_t next_oid, uint32_t count, uint32_t* begin_oid,
-      uint32_t* end_oid, bool use_secondary_space,
-      uint32_t* oid_cache_invalidations_count = nullptr);
+      const std::string& namespace_id, uint32_t next_oid, uint32_t count, bool use_secondary_space,
+      uint32_t* begin_oid, uint32_t* end_oid, uint32_t* oid_cache_invalidations_count = nullptr);
 
   Status GetYsqlCatalogMasterVersion(uint64_t *ysql_catalog_version);
 
diff --git a/src/yb/common/entity_ids.h b/src/yb/common/entity_ids.h
index af5c156ccb..9dd56460e1 100644
--- a/src/yb/common/entity_ids.h
+++ b/src/yb/common/entity_ids.h
@@ -36,7 +36,7 @@ static const uint32_t kPgUpperBoundNormalObjectId = 2'199'999'999; // upper boun
 // Secondary OID space is used by xCluster when a database is a target.  Starting point has been
 // chosen so it starts at a nice human readable number, 2'200'000'000 = 0x83'21'56'00.
 static const uint32_t kPgFirstSecondarySpaceObjectId = kPgUpperBoundNormalObjectId + 1;
-static const uint32_t kPgUpperBoundSecondarySpaceObjectId = 0xff'ff'ff'ff;
+static const uint32_t kPgUpperBoundSecondarySpaceObjectId = 0xff'ff'ff'ff; // exclusive
 static const uint32_t kPgYbTablegroupTableOid = 8036;  // Hardcoded in pg_yb_tablegroup.h
 static const uint32_t kPgSequencesTableOid = 2224;  // Hardcoded for pg_sequence. (in pg_sequence.h)
 static const uint32_t kPgYbMigrationTableOid = 8027;  // Hardcoded for pg_yb_migration.
diff --git a/src/yb/integration-tests/sys_catalog-itest.cc b/src/yb/integration-tests/sys_catalog-itest.cc
index 7298a743a3..1c5c1d1e3a 100644
--- a/src/yb/integration-tests/sys_catalog-itest.cc
+++ b/src/yb/integration-tests/sys_catalog-itest.cc
@@ -40,13 +40,22 @@ class SysCatalogITest : public pgwrapper::PgMiniTestBase {
   NamespaceId namespace_id_;
 };
 
-TEST_F(SysCatalogITest, ReadHighestNormalPreservableOid) {
+TEST_F(SysCatalogITest, ReadHighestPreservableOidForNormalSpace) {
   auto conn = ASSERT_RESULT(ConnectToDB(namespace_name));
   auto database_oid = ASSERT_RESULT(GetPgsqlDatabaseOid(namespace_id_));
   auto sys_catalog = ASSERT_RESULT(catalog_manager())->sys_catalog();
 
-  auto original_highest_oid =
-      ASSERT_RESULT(sys_catalog->ReadHighestNormalPreservableOid(database_oid));
+  auto ReadHighestPreservableOidForNormalSpace = [&sys_catalog, database_oid]() -> uint32_t {
+    auto maximum_oids = sys_catalog->ReadHighestPreservableOids(database_oid);
+    EXPECT_OK(maximum_oids);
+    uint32_t oid = 0;
+    if (maximum_oids) {
+      oid = maximum_oids->for_normal_space_;
+    }
+    return oid;
+  };
+
+  auto original_highest_oid = ReadHighestPreservableOidForNormalSpace();
   // Make sure all the OIDs we are going to use are higher than any of the starting OIDs.
   ASSERT_LT(original_highest_oid, 20'000);
 
@@ -68,7 +77,7 @@ TEST_F(SysCatalogITest, ReadHighestNormalPreservableOid) {
       )";
     ASSERT_OK(conn.Execute(std::regex_replace(
         command, std::regex{"@"}, std::to_string(kPgFirstSecondarySpaceObjectId))));
-    auto oid = ASSERT_RESULT(sys_catalog->ReadHighestNormalPreservableOid(database_oid));
+    auto oid = ReadHighestPreservableOidForNormalSpace();
     // The addition of these OIDs should not have changed the highest normal space OID at all.
     ASSERT_EQ(oid, original_highest_oid);
   }
@@ -89,7 +98,7 @@ TEST_F(SysCatalogITest, ReadHighestNormalPreservableOid) {
        SELECT pg_catalog.yb_binary_upgrade_set_next_pg_enum_sortorder('2'::real);
        ALTER TYPE new_enum ADD VALUE 'orange';
       )"));
-    auto oid = ASSERT_RESULT(sys_catalog->ReadHighestNormalPreservableOid(database_oid));
+    auto oid = ReadHighestPreservableOidForNormalSpace();
     EXPECT_EQ(oid, 50'001);
   }
 
@@ -103,7 +112,7 @@ TEST_F(SysCatalogITest, ReadHighestNormalPreservableOid) {
 
        CREATE SEQUENCE new_sequence;
       )"));
-    auto oid = ASSERT_RESULT(sys_catalog->ReadHighestNormalPreservableOid(database_oid));
+    auto oid = ReadHighestPreservableOidForNormalSpace();
     EXPECT_EQ(oid, 60000);
   }
 
@@ -118,7 +127,7 @@ TEST_F(SysCatalogITest, ReadHighestNormalPreservableOid) {
 
        CREATE TYPE new_composite AS (x int);
       )"));
-    auto oid = ASSERT_RESULT(sys_catalog->ReadHighestNormalPreservableOid(database_oid));
+    auto oid = ReadHighestPreservableOidForNormalSpace();
     EXPECT_EQ(oid, 70'001);
   }
 
@@ -135,16 +144,84 @@ TEST_F(SysCatalogITest, ReadHighestNormalPreservableOid) {
        CREATE TABLE my_table (x integer);
       )"));
 
-    // TODO(yhaddad): fix Postgres to honor binary_upgrade_set_next_heap_relfilenode directive then
-    // update this test to expect 80'000.
+    // TODO(yhaddad): fix Postgres to honor binary_upgrade_set_next_heap_relfilenode directive
+    // then update this test to expect 80'000.
     //
     // (Currently this directive is not honored, which prevents this test from testing the
     // relfilenode case.)
     LOG(INFO) << ASSERT_RESULT(conn.FetchAllAsString("SELECT oid, relfilenode FROM pg_class;"));
-    auto oid = ASSERT_RESULT(sys_catalog->ReadHighestNormalPreservableOid(database_oid));
+    auto oid = ReadHighestPreservableOidForNormalSpace();
     // EXPECT_EQ(oid, 80'000);
     EXPECT_EQ(oid, 70'001);
   }
 }
 
+TEST_F(SysCatalogITest, ReadHighestPreservableOidForSecondarySpace) {
+  auto conn = ASSERT_RESULT(ConnectToDB(namespace_name));
+  auto database_oid = ASSERT_RESULT(GetPgsqlDatabaseOid(namespace_id_));
+  auto sys_catalog = ASSERT_RESULT(catalog_manager())->sys_catalog();
+
+  auto ReadHighestPreservableOidForSecondarySpace = [&sys_catalog, database_oid]() -> uint32_t {
+    auto maximum_oids = sys_catalog->ReadHighestPreservableOids(database_oid);
+    EXPECT_OK(maximum_oids);
+    uint32_t oid = 0;
+    if (maximum_oids) {
+      oid = maximum_oids->for_secondary_space_;
+    }
+    return oid;
+  };
+
+  const uint32_t base_oid = kPgFirstSecondarySpaceObjectId + 100;
+  // Here @ in statement will be replaced by base_oid.
+  auto MyExecute = [&conn](const std::string& statement) {
+    const std::string prefix =
+        "SET yb_binary_restore = true; SET yb_ignore_pg_class_oids = false; ";
+    return conn.Execute(
+        prefix + std::regex_replace(statement, std::regex{"@"}, std::to_string(base_oid)));
+  };
+
+  {
+    auto oid = ReadHighestPreservableOidForSecondarySpace();
+    EXPECT_EQ(oid, kPgFirstSecondarySpaceObjectId);
+  }
+
+  // Create secondary space OIDs of each of the kinds we preserve.
+
+  {
+    ASSERT_OK(MyExecute(R"(
+       SELECT pg_catalog.binary_upgrade_set_next_pg_type_oid((@)::pg_catalog.oid);
+       SELECT pg_catalog.binary_upgrade_set_next_array_pg_type_oid((@+1)::pg_catalog.oid);
+       CREATE TYPE high_enum AS ENUM ();
+       )"));
+    auto oid = ReadHighestPreservableOidForSecondarySpace();
+    ASSERT_EQ(oid, base_oid + 1);
+  }
+
+  {
+    ASSERT_OK(MyExecute(R"(
+       SELECT pg_catalog.binary_upgrade_set_next_pg_enum_oid((@+2)::pg_catalog.oid);
+       SELECT pg_catalog.yb_binary_upgrade_set_next_pg_enum_sortorder('1'::real);
+       ALTER TYPE high_enum ADD VALUE 'red';
+       )"));
+    auto oid = ReadHighestPreservableOidForSecondarySpace();
+    ASSERT_EQ(oid, base_oid + 2);
+  }
+
+  {
+    ASSERT_OK(MyExecute(R"(
+       SELECT pg_catalog.binary_upgrade_set_next_heap_pg_class_oid((@+3)::pg_catalog.oid);
+       SELECT pg_catalog.binary_upgrade_set_next_heap_relfilenode((@+4)::pg_catalog.oid);
+       CREATE SEQUENCE high_sequence;
+       )"));
+    auto oid = ReadHighestPreservableOidForSecondarySpace();
+    // TODO(yhaddad): fix Postgres to honor binary_upgrade_set_next_heap_relfilenode directive
+    // then update this test to expect base_oid + 4.
+    //
+    // (Currently this directive is not honored, which prevents this test from testing the
+    // relfilenode case.)
+    // ASSERT_EQ(oid, base_oid + 4);
+    ASSERT_EQ(oid, base_oid + 3);
+  }
+}
+
 }  // namespace yb::master
diff --git a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
index b2ee7a517b..dabd150901 100644
--- a/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_ddl_replication-test.cc
@@ -26,6 +26,7 @@
 #include "yb/integration-tests/xcluster/xcluster_test_utils.h"
 
 #include "yb/master/catalog_manager.h"
+#include "yb/master/master_ddl.pb.h"
 #include "yb/master/mini_master.h"
 #include "yb/master/xcluster/xcluster_manager.h"
 
@@ -46,10 +47,11 @@ DECLARE_int32(ysql_sequence_cache_minval);
 DECLARE_uint32(xcluster_consistent_wal_safe_time_frequency_ms);
 DECLARE_uint32(ysql_oid_cache_prefetch_size);
 
+DECLARE_bool(TEST_skip_oid_advance_on_restore);
 DECLARE_bool(TEST_xcluster_ddl_queue_handler_fail_at_end);
 DECLARE_bool(TEST_xcluster_ddl_queue_handler_fail_at_start);
-DECLARE_bool(TEST_xcluster_ddl_queue_handler_fail_ddl);
 DECLARE_bool(TEST_xcluster_ddl_queue_handler_fail_before_incremental_safe_time_bump);
+DECLARE_bool(TEST_xcluster_ddl_queue_handler_fail_ddl);
 DECLARE_int32(TEST_xcluster_producer_modify_sent_apply_safe_time_ms);
 DECLARE_int32(TEST_xcluster_simulated_lag_ms);
 DECLARE_string(TEST_xcluster_simulated_lag_tablet_filter);
@@ -1948,8 +1950,8 @@ TEST_F(XClusterDDLReplicationFailoverTest, FailoverWithPendingAlterDDLs) {
 
   auto& sync_point = *SyncPoint::GetInstance();
   sync_point.LoadDependency(
-      {{"XClusterDDLQueueHandler::DDLQueryProcessed",
-        "FailoverWithPendingAlterDDLs::WaitForDDLToExecute"}});
+      {{.predecessor = "XClusterDDLQueueHandler::DDLQueryProcessed",
+        .successor = "FailoverWithPendingAlterDDLs::WaitForDDLToExecute"}});
 
   ASSERT_OK(EnablePITROnClusters());
 
@@ -2063,11 +2065,15 @@ TEST_F(XClusterDDLReplicationSetupTest, ReplicationSetUpBumpsOidCounter) {
     ASSERT_OK(conn.Execute("CREATE TABLE my_table (x INT);"));
   }
 
-  // Reset OID counters on A by backing up then restoring the database on cluster A.
+  // Simulate a legacy database that was backed up and restored before we added the code for
+  // advancing OIDs counters on restore.  Here we reset OID counters on A by backing up then
+  // restoring the database on cluster A without advancing the OID counters.
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_skip_oid_advance_on_restore) = true;
   ASSERT_OK(BackupFromProducer());
   SetReplicationDirection(ReplicationDirection::BToA);
   ASSERT_OK(RestoreToConsumer());
   SetReplicationDirection(ReplicationDirection::AToB);
+  ANNOTATE_UNPROTECTED_WRITE(FLAGS_TEST_skip_oid_advance_on_restore) = false;
 
   // Allocate a few OIDs on A to force caching of normal space OIDs.
   {
@@ -2105,6 +2111,69 @@ TEST_F(XClusterDDLReplicationSetupTest, ReplicationSetUpBumpsOidCounter) {
   }
 }
 
+TEST_F(XClusterDDLReplicationSetupTest, CheckpointingSetUpBumpsOidCounters) {
+  ASSERT_OK(SetUpClusters());
+
+  auto CreateTableWithOid = [&](std::string tablename, uint32_t oid) -> Status {
+    auto conn = VERIFY_RESULT(cluster_A_->ConnectToDB(namespace_name));
+    return conn.ExecuteFormat(
+        "SET yb_binary_restore = true;"
+        "SET yb_ignore_pg_class_oids = false;"
+        "SET yb_ignore_relfilenode_ids = false;"
+        "SELECT pg_catalog.binary_upgrade_set_next_heap_pg_class_oid('$0'::pg_catalog.oid);"
+        "SELECT pg_catalog.binary_upgrade_set_next_heap_relfilenode('$0'::pg_catalog.oid);"
+        "SELECT pg_catalog.binary_upgrade_set_next_pg_type_oid('$1'::pg_catalog.oid);"
+        "SELECT pg_catalog.binary_upgrade_set_next_array_pg_type_oid('$2'::pg_catalog.oid);"
+        "CREATE TABLE $3 (x INT);",
+        oid, oid + 1, oid + 2, tablename);
+  };
+
+  auto GetTableOid = [&](std::string tablename) -> Result<uint32_t> {
+    auto conn = VERIFY_RESULT(cluster_A_->ConnectToDB(namespace_name));
+    return conn.FetchRow<pgwrapper::PGOid>(
+        Format("SELECT oid FROM pg_class WHERE relname = '$0'", tablename));
+  };
+
+  google::SetVLOGLevel("catalog_manager*", 1);
+
+  // Create a hidden normal table above where the normal OID counter points.
+  ASSERT_OK(EnablePITROnClusters());
+  const uint32_t normal_table_oid = 50'000;
+  ASSERT_OK(CreateTableWithOid("normal_table", normal_table_oid));
+  {
+    auto conn = ASSERT_RESULT(cluster_A_->ConnectToDB(namespace_name));
+    ASSERT_OK(conn.Execute("DROP TABLE normal_table;"));
+  }
+  // Create a non-hidden secondary space table above where the secondary OID counter points.
+  const uint32_t secondary_table_oid = kPgFirstSecondarySpaceObjectId + 70'000;
+  ASSERT_OK(CreateTableWithOid("secondary_table", secondary_table_oid));
+
+  // Checkpoint the namespace for xCluster automatic replication; this should advance both OID
+  // counters as needed.
+  ASSERT_OK(CheckpointReplicationGroupOnNamespaces({namespace_name}));
+
+  // Verify the normal space OID counter has advanced by creating a probe table.
+  auto conn = ASSERT_RESULT(cluster_A_->ConnectToDB(namespace_name));
+  ASSERT_OK(conn.Execute("CREATE TABLE probe_table (y INT);"));
+  auto probe_oid = ASSERT_RESULT(GetTableOid("probe_table"));
+  ASSERT_GE(probe_oid, normal_table_oid);
+  ASSERT_LT(probe_oid, kPgUpperBoundNormalObjectId);
+
+  // Verify the secondary space OID counter has advanced by directly reserving the next (uncached)
+  // secondary space OID.
+  {
+    master::GetNamespaceInfoResponsePB resp;
+    ASSERT_OK(producer_client()->GetNamespaceInfo(
+        /*namespace_id=*/std::string(), namespace_name, YQL_DATABASE_PGSQL, &resp));
+    NamespaceId namespace_id = resp.namespace_().id();
+    uint32_t begin_oid, end_oid;
+    ASSERT_OK(producer_client()->ReservePgsqlOids(
+        namespace_id, /*next_oid=*/0, /*count=*/1, /*use_secondary_space=*/true, &begin_oid,
+        &end_oid));
+        ASSERT_GE(begin_oid, secondary_table_oid);
+  }
+}
+
 class XClusterDDLReplicationAddDropColumnTest : public XClusterDDLReplicationTest {
  public:
   void SetUp() override {
diff --git a/src/yb/integration-tests/xcluster/xcluster_secondary_oid_space-test.cc b/src/yb/integration-tests/xcluster/xcluster_secondary_oid_space-test.cc
index d633f650e0..a3e227750f 100644
--- a/src/yb/integration-tests/xcluster/xcluster_secondary_oid_space-test.cc
+++ b/src/yb/integration-tests/xcluster/xcluster_secondary_oid_space-test.cc
@@ -24,7 +24,7 @@ namespace yb {
 
 class OidAllocationTest : public pgwrapper::PgMiniTestBase {
  public:
-  void SetUp() {
+  void SetUp() override {
     pgwrapper::PgMiniTestBase::SetUp();
 
     master::GetNamespaceInfoResponsePB resp;
@@ -44,7 +44,7 @@ TEST_F(OidAllocationTest, SimpleOidAllocation) {
 
   auto ReservePgsqlOids = [&](uint32_t next_oid, uint32_t count, bool use_secondary_space) {
     return client_->ReservePgsqlOids(
-        namespace_id_, next_oid, count, &begin_oid, &end_oid, use_secondary_space);
+        namespace_id_, next_oid, count, use_secondary_space, &begin_oid, &end_oid);
   };
 
   const uint32_t num_of_oids_to_request = 100;
@@ -83,7 +83,7 @@ TEST_F(OidAllocationTest, OidAllocationLimits) {
 
   auto ReservePgsqlOids = [&](uint32_t next_oid, uint32_t count, bool use_secondary_space) {
     return client_->ReservePgsqlOids(
-        namespace_id_, next_oid, count, &begin_oid, &end_oid, use_secondary_space);
+        namespace_id_, next_oid, count, use_secondary_space, &begin_oid, &end_oid);
   };
 
   const uint32_t num_of_oids_to_request = 100;
@@ -112,7 +112,7 @@ TEST_F(OidAllocationTest, OidAllocationOverlappingLimits) {
 
   auto ReservePgsqlOids = [&](uint32_t next_oid, uint32_t count, bool use_secondary_space) {
     return client_->ReservePgsqlOids(
-        namespace_id_, next_oid, count, &begin_oid, &end_oid, use_secondary_space);
+        namespace_id_, next_oid, count, use_secondary_space, &begin_oid, &end_oid);
   };
 
   // Close enough to limit that we get fewer than the OIDs we asked for.
@@ -147,7 +147,7 @@ TEST_F(OidAllocationTest, CacheInvalidation) {
   uint32_t oid_cache_invalidations_count;
   auto ReservePgsqlOids = [&](uint32_t next_oid, uint32_t count) {
     return client_->ReservePgsqlOids(
-        namespace_id_, next_oid, count, &begin_oid, &end_oid, /*use_secondary_space=*/false,
+        namespace_id_, next_oid, count, /*use_secondary_space=*/false, &begin_oid, &end_oid,
         &oid_cache_invalidations_count);
   };
 
diff --git a/src/yb/master/catalog_manager.cc b/src/yb/master/catalog_manager.cc
index 54f0ced357..364f454286 100644
--- a/src/yb/master/catalog_manager.cc
+++ b/src/yb/master/catalog_manager.cc
@@ -4588,7 +4588,7 @@ Result<TabletInfos> CatalogManager::CreateTabletsFromTable(const vector<Partitio
     tablet_id_and_partition.emplace_back(GenerateIdUnlocked(SysRowEntryType::TABLET), &partition);
   }
   // Order tablets by id to guarantee same lock order in all scenarios.
-  std::sort(tablet_id_and_partition.begin(), tablet_id_and_partition.end());
+  std::ranges::sort(tablet_id_and_partition);
   for (const auto& [tablet_id, partition] : tablet_id_and_partition) {
     PartitionPB partition_pb;
     partition->ToPB(&partition_pb);
@@ -10089,18 +10089,37 @@ Status CatalogManager::ListUDTypes(const ListUDTypesRequestPB* req,
   return Status::OK();
 }
 
-Status CatalogManager::AdvanceOidCounters(NamespaceId namespace_id) {
+Status CatalogManager::AdvanceOidCounters(const NamespaceId& namespace_id) {
   auto database_oid = VERIFY_RESULT(GetPgsqlDatabaseOid(namespace_id));
-  VLOG(1) << "Calling ReadHighestNormalPreservableOid on database OID " << database_oid;
-  auto highest_oid = VERIFY_RESULT(sys_catalog_->ReadHighestNormalPreservableOid(database_oid));
+  VLOG(1) << "Calling AdvanceOidCounters on database ID " << namespace_id << ", which has OID "
+          << database_oid;
+  auto highest_oids = VERIFY_RESULT(sys_catalog_->ReadHighestPreservableOids(database_oid));
+
+  // The above does not see hidden DocDB tables (they have no record in the PG catalogs) so we need
+  // to walk the list of DocDB tables separately to find those.
+  auto table_infos = VERIFY_RESULT(GetTableInfosForNamespace(namespace_id));
+  for (const auto& table_info : table_infos) {
+    TableId table_id = table_info->id();
+    auto table_oid = GetPgsqlTableOid(table_id);
+    if (table_oid) {
+      highest_oids.UpdateWithOid(*table_oid);
+    }
+  }
+
+  VLOG(1) << "Bumping normal space OID for database OID " << database_oid << " above "
+          << highest_oids.for_normal_space_;
   auto* yb_client = master_->client_future().get();
   SCHECK(yb_client, IllegalState, "Client not initialized or shutting down");
-  VLOG(1) << "Bumping normal space OID for database OID " << database_oid << " above "
-          << highest_oid;
   uint32_t begin_oid, end_oid;
   RETURN_NOT_OK(yb_client->ReservePgsqlOids(
-      namespace_id, /*next_oid=*/highest_oid, /*count=*/1, &begin_oid, &end_oid,
-      /*use_secondary_space=*/false));
+      namespace_id, /*next_oid=*/highest_oids.for_normal_space_, /*count=*/1,
+      /*use_secondary_space=*/false, &begin_oid, &end_oid));
+
+  VLOG(1) << "Bumping secondary space OID for database OID " << database_oid << " above "
+          << highest_oids.for_secondary_space_;
+  RETURN_NOT_OK(yb_client->ReservePgsqlOids(
+      namespace_id, /*next_oid=*/highest_oids.for_secondary_space_, /*count=*/1,
+      /*use_secondary_space=*/true, &begin_oid, &end_oid));
   return Status::OK();
 }
 
diff --git a/src/yb/master/catalog_manager.h b/src/yb/master/catalog_manager.h
index 92c57c134f..b6a0cca29b 100644
--- a/src/yb/master/catalog_manager.h
+++ b/src/yb/master/catalog_manager.h
@@ -206,7 +206,7 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
 
  public:
   explicit CatalogManager(Master *master, SysCatalogTable* sys_catalog);
-  virtual ~CatalogManager();
+  ~CatalogManager() override;
 
   Status Init();
 
@@ -757,10 +757,13 @@ class CatalogManager : public CatalogManagerIf, public SnapshotCoordinatorContex
 
   // Advance OID counters as needed to ensure future OID allocations do not run into trouble.
   //
-  // So far this just ensures the normal-space OID counter is beyond any normal-space OID we need to
-  // preserve.
-  // TODO(#27944): also handle reserved space and OIDs used by hidden tables.
-  Status AdvanceOidCounters(NamespaceId namespace_id);
+  // After this function returns, the following will hold:
+  //   * All the in-use OIDs that xCluster needs to preserve are below the associated OID counter.
+  //   * There are no DocDB hidden tables whose OIDs are at or above the associated OID counter.
+  //
+  // Remember that OIDs are cached at TServers so you may want to use InvalidateTserverOidCaches()
+  // after calling this function.
+  Status AdvanceOidCounters(const NamespaceId& namespace_id);
 
   // Invalidate all the TServer OID caches in this universe.  After this returns, each TServer cache
   // will be effectively invalidated when that TServer receives a heartbeat response from master.
diff --git a/src/yb/master/catalog_manager_ext.cc b/src/yb/master/catalog_manager_ext.cc
index d8bbbd7c30..6d54e21f58 100644
--- a/src/yb/master/catalog_manager_ext.cc
+++ b/src/yb/master/catalog_manager_ext.cc
@@ -12,113 +12,79 @@
 
 #include <memory>
 #include <queue>
-#include <regex>
-#include <set>
 #include <unordered_set>
+
 #include <google/protobuf/repeated_field.h>
 #include <google/protobuf/util/message_differencer.h>
 
+#include "yb/client/meta_cache.h"
+#include "yb/client/session.h"
+#include "yb/client/table_info.h"
+#include "yb/client/yb_op.h"
+#include "yb/client/yb_table_name.h"
+
 #include "yb/common/colocated_util.h"
+#include "yb/common/common.pb.h"
 #include "yb/common/common_fwd.h"
 #include "yb/common/common_types.pb.h"
-#include "yb/common/constants.h"
-#include "yb/common/common.pb.h"
 #include "yb/common/entity_ids.h"
 #include "yb/common/entity_ids_types.h"
-#include "yb/common/pg_system_attr.h"
-#include "yb/common/snapshot.h"
-#include "yb/master/ts_manager.h"
-#include "yb/qlexpr/ql_name.h"
 #include "yb/common/ql_type.h"
 #include "yb/common/ql_type_util.h"
-#include "yb/common/schema_pbutil.h"
 #include "yb/common/schema.h"
-
-#include "yb/master/catalog_entity_info.h"
-#include "yb/master/catalog_entity_info.pb.h"
-#include "yb/master/catalog_manager-internal.h"
-#include "yb/master/catalog_manager.h"
-#include "yb/master/xcluster_consumer_registry_service.h"
-#include "yb/master/cluster_balance.h"
-#include "yb/master/master.h"
-#include "yb/master/master_backup.pb.h"
-#include "yb/master/master_error.h"
-#include "yb/master/master_snapshot_coordinator.h"
-#include "yb/master/snapshot_state.h"
-#include "yb/master/tablet_split_manager.h"
-#include "yb/master/ysql_tablegroup_manager.h"
-
-#include "yb/client/client-internal.h"
-#include "yb/client/meta_cache.h"
-#include "yb/client/schema.h"
-#include "yb/client/session.h"
-#include "yb/client/table.h"
-#include "yb/client/table_alterer.h"
-#include "yb/client/table_handle.h"
-#include "yb/client/table_info.h"
-#include "yb/client/yb_op.h"
-#include "yb/client/yb_table_name.h"
+#include "yb/common/schema_pbutil.h"
+#include "yb/common/snapshot.h"
 
 #include "yb/consensus/consensus.h"
 
-#include "yb/docdb/consensus_frontier.h"
 #include "yb/docdb/doc_rowwise_iterator.h"
 #include "yb/docdb/doc_write_batch.h"
-#include "yb/docdb/docdb_pgapi.h"
 
-#include "yb/gutil/bind.h"
 #include "yb/gutil/casts.h"
-#include "yb/gutil/strings/join.h"
 #include "yb/gutil/strings/substitute.h"
-#include "yb/master/master_client.pb.h"
+
+#include "yb/master/async_rpc_tasks.h"
+#include "yb/master/async_snapshot_tasks.h"
+#include "yb/master/catalog_entity_info.h"
+#include "yb/master/catalog_entity_info.pb.h"
+#include "yb/master/catalog_manager-internal.h"
+#include "yb/master/catalog_manager.h"
+#include "yb/master/encryption_manager.h"
+#include "yb/master/master.h"
+#include "yb/master/master_backup.pb.h"
 #include "yb/master/master_ddl.pb.h"
-#include "yb/master/master_defaults.h"
+#include "yb/master/master_error.h"
 #include "yb/master/master_heartbeat.pb.h"
 #include "yb/master/master_replication.pb.h"
+#include "yb/master/master_snapshot_coordinator.h"
 #include "yb/master/master_util.h"
-#include "yb/master/sys_catalog.h"
-#include "yb/master/sys_catalog-internal.h"
-#include "yb/master/async_snapshot_tasks.h"
-#include "yb/master/async_rpc_tasks.h"
-#include "yb/master/encryption_manager.h"
 #include "yb/master/restore_sys_catalog_state.h"
-#include "yb/master/scoped_leader_shared_lock.h"
-#include "yb/master/scoped_leader_shared_lock-internal.h"
+#include "yb/master/sys_catalog.h"
+#include "yb/master/tablet_split_manager.h"
+#include "yb/master/ts_manager.h"
+#include "yb/master/xcluster_consumer_registry_service.h"
 #include "yb/master/ysql/ysql_manager_if.h"
+#include "yb/master/ysql_tablegroup_manager.h"
 
 #include "yb/rpc/messenger.h"
 
-#include "yb/tablet/operations/snapshot_operation.h"
 #include "yb/tablet/tablet_metadata.h"
+#include "yb/tablet/tablet_peer.h"
 #include "yb/tablet/tablet_snapshots.h"
 
-#include "yb/tserver/backup.proxy.h"
-#include "yb/tserver/service_util.h"
-#include "yb/tserver/tserver_admin.pb.h"
-
-#include "yb/util/cast.h"
-#include "yb/util/date_time.h"
-#include "yb/util/file_util.h"
 #include "yb/util/flags.h"
 #include "yb/util/format.h"
 #include "yb/util/logging.h"
 #include "yb/util/monotime.h"
 #include "yb/util/oid_generator.h"
-#include "yb/util/random_util.h"
 #include "yb/util/scope_exit.h"
-#include "yb/util/service_util.h"
 #include "yb/util/status.h"
 #include "yb/util/status_format.h"
 #include "yb/util/status_log.h"
 #include "yb/util/std_util.h"
 #include "yb/util/tostring.h"
-#include "yb/util/string_util.h"
 #include "yb/util/trace.h"
 
-#include "yb/yql/cql/ql/util/statement_result.h"
-
-#include "ybgate/ybgate_api.h"
-
 using namespace std::literals;
 using namespace std::placeholders;
 
@@ -140,10 +106,12 @@ DEPRECATE_FLAG(bool, allow_consecutive_restore, "10_2022");
 DEFINE_test_flag(double, crash_during_sys_catalog_restoration, 0.0,
                  "Probability of crash during the RESTORE_SYS_CATALOG phase.");
 
-DEFINE_test_flag(
-    bool, import_snapshot_failed, false,
+DEFINE_test_flag(bool, import_snapshot_failed, false,
     "Return a error from ImportSnapshotMeta RPC for testing the RPC failure.");
 
+DEFINE_test_flag(bool, skip_oid_advance_on_restore, false,
+    "Skip advancing OID counters on restore if true.");
+
 DEFINE_RUNTIME_uint64(import_snapshot_max_concurrent_create_table_requests, 20,
     "Maximum number of create table requests to the master that can be outstanding "
     "during the import snapshot metadata phase of restore.");
@@ -742,9 +710,11 @@ Status CatalogManager::DoImportSnapshotMeta(
   ImportSnapshotRemoveInvalidTables(use_relfilenode, tables_data);
 
   // PHASE 6: Adjust OID counters.
-  for (const auto& [_old_namespace_id, external_namespace_snapshot_data] : *namespace_map) {
-    if (external_namespace_snapshot_data.db_type == YQL_DATABASE_PGSQL) {
-      RETURN_NOT_OK(AdvanceOidCounters(external_namespace_snapshot_data.new_namespace_id));
+  if (!FLAGS_TEST_skip_oid_advance_on_restore) {
+    for (const auto& [_old_namespace_id, external_namespace_snapshot_data] : *namespace_map) {
+      if (external_namespace_snapshot_data.db_type == YQL_DATABASE_PGSQL) {
+        RETURN_NOT_OK(AdvanceOidCounters(external_namespace_snapshot_data.new_namespace_id));
+      }
     }
   }
 
diff --git a/src/yb/master/sys_catalog.cc b/src/yb/master/sys_catalog.cc
index 18c9aa1aa0..c7e6cf7723 100644
--- a/src/yb/master/sys_catalog.cc
+++ b/src/yb/master/sys_catalog.cc
@@ -32,6 +32,7 @@
 
 #include "yb/master/sys_catalog.h"
 
+#include <algorithm>
 #include <cmath>
 #include <memory>
 
@@ -166,6 +167,18 @@ const std::string kLogPrefix = "system tablet: ";
 
 }
 
+void MaxOidPerSpace::UpdateWithOid(uint32_t oid) {
+  if (oid < kPgUpperBoundNormalObjectId) {
+    for_normal_space_ = std::max(for_normal_space_, oid);
+  } else if (oid >= kPgFirstSecondarySpaceObjectId && oid < kPgUpperBoundSecondarySpaceObjectId) {
+    for_secondary_space_ = std::max(for_secondary_space_, oid);
+  }
+}
+
+std::string MaxOidPerSpace::ToString() const {
+  return YB_CLASS_TO_STRING(for_normal_space, for_secondary_space);
+}
+
 std::string SysCatalogTable::schema_column_type() { return kSysCatalogTableColType; }
 
 std::string SysCatalogTable::schema_column_id() { return kSysCatalogTableColId; }
@@ -241,7 +254,7 @@ Status SysCatalogTable::ConvertConfigToMasterAddresses(
       break;
     }
 
-    loaded_master_addresses->push_back({});
+    loaded_master_addresses->emplace_back();
     auto& list = loaded_master_addresses->back();
     for (const auto& hp : peer.last_known_private_addr()) {
       list.push_back(HostPortFromPB(hp));
@@ -813,8 +826,8 @@ Status SysCatalogTable::GetTableSchema(
   QLAddInt8Condition(&cond, schema.column_id(type_col_idx), QL_OP_EQUAL, SysRowEntryType::TABLE);
   const dockv::KeyEntryValues empty_hash_components;
   docdb::DocQLScanSpec spec(
-      schema, boost::none /* hash_code */, boost::none /* max_hash_code */, empty_hash_components,
-      &cond, nullptr /* if_req */, rocksdb::kDefaultQueryId);
+      schema, /*hash_code=*/boost::none, /*max_hash_code=*/boost::none, empty_hash_components,
+      &cond, /*if_req=*/nullptr, rocksdb::kDefaultQueryId);
   auto request_scope = VERIFY_RESULT(tablet->CreateRequestScope());
   RETURN_NOT_OK(doc_iter->Init(spec));
 
@@ -828,7 +841,6 @@ Status SysCatalogTable::GetTableSchema(
         "Found wrong entry type");
     RETURN_NOT_OK(value_map.GetValue(schema.column_id(entry_id_col_idx), &entry_id));
     const Slice& entry_id_value = entry_id.binary_value();
-    string entry_id_name;
 
     if (table_id == entry_id_value.ToBuffer()) {
       RETURN_NOT_OK(value_map.GetValue(schema.column_id(metadata_col_idx), &metadata));
@@ -943,28 +955,29 @@ Status SysCatalogTable::ReadWithRestarts(
 }
 
 // TODO (Sanket): Change this function to use ExtractPgYbCatalogVersionRow.
-Status SysCatalogTable::ReadYsqlCatalogVersion(const TableId& ysql_catalog_table_id,
-                                               uint64_t* catalog_version,
-                                               uint64_t* last_breaking_version) {
+Status SysCatalogTable::ReadYsqlCatalogVersion(
+    const TableId& ysql_catalog_table_id, uint64_t* catalog_version,
+    uint64_t* last_breaking_version) {
   TRACE_EVENT0("master", "ReadYsqlCatalogVersion");
   return ReadYsqlDBCatalogVersionImpl(
-      ysql_catalog_table_id, kInvalidOid, catalog_version, last_breaking_version, nullptr);
+      ysql_catalog_table_id, kInvalidOid, catalog_version, last_breaking_version,
+      /*versions=*/nullptr);
 }
 
-Status SysCatalogTable::ReadYsqlDBCatalogVersion(const TableId& ysql_catalog_table_id,
-                                                 uint32_t db_oid,
-                                                 uint64_t* catalog_version,
-                                                 uint64_t* last_breaking_version) {
+Status SysCatalogTable::ReadYsqlDBCatalogVersion(
+    const TableId& ysql_catalog_table_id, uint32_t db_oid, uint64_t* catalog_version,
+    uint64_t* last_breaking_version) {
   TRACE_EVENT0("master", "ReadYsqlCatalogVersion");
   return ReadYsqlDBCatalogVersionImpl(
-      ysql_catalog_table_id, db_oid, catalog_version, last_breaking_version, nullptr);
+      ysql_catalog_table_id, db_oid, catalog_version, last_breaking_version, /*versions=*/nullptr);
 }
 
 Status SysCatalogTable::ReadYsqlAllDBCatalogVersions(
     const TableId& ysql_catalog_table_id, DbOidToCatalogVersionMap* versions) {
   TRACE_EVENT0("master", "ReadYsqlAllDBCatalogVersions");
   return ReadYsqlDBCatalogVersionImpl(
-      ysql_catalog_table_id, kInvalidOid, nullptr, nullptr, versions);
+      ysql_catalog_table_id, kInvalidOid, /*catalog_version=*/nullptr,
+      /*last_breaking_version=*/nullptr, versions);
 }
 
 Status SysCatalogTable::ReadYsqlDBCatalogVersionImpl(
@@ -1058,9 +1071,9 @@ Status SysCatalogTable::ReadYsqlDBCatalogVersionImplWithReadTime(
     if (versions) {
       // When 'versions' is set we read all rows.
       const uint32_t db_oid = db_oid_value->uint32_value();
-      const uint64_t current_version =
+      const auto current_version =
         static_cast<uint64_t>(version_col_value->int64_value());
-      const uint64_t last_breaking_version =
+      const auto last_breaking_version =
         static_cast<uint64_t>(last_breaking_version_col_value->int64_value());
       if (FLAGS_TEST_check_catalog_version_overflow) {
         CHECK_GE(static_cast<int64_t>(current_version), 0)
@@ -1391,7 +1404,7 @@ Result<PgOidToOidMap> SysCatalogTable::ReadPgClassColumnWithOidValueMap(
     const dockv::KeyEntryValues empty_key_components;
     docdb::DocPgsqlScanSpec spec(
         schema, rocksdb::kDefaultQueryId, empty_key_components, empty_key_components,
-        nullptr /* condition */, std::nullopt /* hash_code */, std::nullopt /* max_hash_code */);
+        /*condition=*/nullptr, /*hash_code=*/std::nullopt, /*max_hash_code=*/std::nullopt);
 
     RETURN_NOT_OK(iter->Init(spec));
   }
@@ -1481,7 +1494,7 @@ Result<PgOidToStringMap> SysCatalogTable::ReadPgNamespaceNspnameMap(const PgOid
     const dockv::KeyEntryValues empty_key_components;
     docdb::DocPgsqlScanSpec spec(
         schema, rocksdb::kDefaultQueryId, empty_key_components, empty_key_components,
-        nullptr /* condition */, std::nullopt /* hash_code */, std::nullopt /* max_hash_code */);
+        /*condition=*/nullptr, /*hash_code=*/std::nullopt, /*max_hash_code=*/std::nullopt);
     RETURN_NOT_OK(iter->Init(spec));
   }
 
@@ -1639,7 +1652,7 @@ Result<std::unordered_map<uint32_t, string>> SysCatalogTable::ReadPgEnum(
     const dockv::KeyEntryValues empty_key_components;
     docdb::DocPgsqlScanSpec spec(
         schema, rocksdb::kDefaultQueryId, empty_key_components, empty_key_components,
-        nullptr /* cond */, std::nullopt /* hash_code */, std::nullopt /* max_hash_code */);
+        /*condition=*/nullptr, /*hash_code=*/std::nullopt, /*max_hash_code=*/std::nullopt);
     RETURN_NOT_OK(iter->Init(spec));
   }
 
@@ -1686,7 +1699,7 @@ Result<std::unordered_map<uint32_t, PgTypeInfo>> SysCatalogTable::ReadPgTypeInfo
     PgsqlConditionPB cond;
     cond.add_operands()->set_column_id(oid_col_id);
     cond.set_op(QL_OP_IN);
-    std::sort(type_oids->begin(), type_oids->end());
+    std::ranges::sort(*type_oids);
     auto seq_value = cond.add_operands()->mutable_value()->mutable_list_value();
     for (auto const type_oid : *type_oids) {
       seq_value->add_elems()->set_uint32_value(type_oid);
@@ -1772,14 +1785,14 @@ Result<uint32_t> SysCatalogTable::ReadPgYbTablegroupOid(const uint32_t database_
   return kPgInvalidOid;
 }
 
-Result<uint32_t> SysCatalogTable::ReadHighestNormalPreservableOid(uint32_t database_oid) {
+Result<MaxOidPerSpace> SysCatalogTable::ReadHighestPreservableOids(uint32_t database_oid) {
   auto request_scope = VERIFY_RESULT(VERIFY_RESULT(Tablet())->CreateRequestScope());
-  LongOperationTracker long_operation_tracker("ReadHighestNormalPreservableOid", 3s);
+  LongOperationTracker long_operation_tracker("ReadHighestPreservableOids", 3s);
 
   // XCluster needs to be able preserve OIDs for pg_enum, pg_type, and pg_class; pg_class's
   // relfilenodes needs to be kept distinct from its OIDs so we include those as well.
   const std::vector<uint32_t> table_oids = {kPgEnumTableOid, kPgTypeTableOid, kPgClassTableOid};
-  uint32_t maximum_normal_oid = 0;
+  MaxOidPerSpace maximum_oids;
   for (const auto table_oid : table_oids) {
     auto read_data = VERIFY_RESULT(TableReadData(database_oid, table_oid, ReadHybridTime()));
     const auto& schema = read_data.schema();
@@ -1814,16 +1827,7 @@ Result<uint32_t> SysCatalogTable::ReadHighestNormalPreservableOid(uint32_t datab
           oid_col, IllegalState,
           "Could not read oid column from table ID $0 from database ID $1:", read_data.table_id,
           database_oid);
-      const uint32_t oid = oid_col->uint32_value();
-      if (oid < kPgUpperBoundNormalObjectId) {
-        maximum_normal_oid = std::max(maximum_normal_oid, oid);
-      } else if (!relfilenode_present) {
-        // Because OID is the primary key (ascending) for these tables, if we do not need to look at
-        // relfilenode, then we can exit as soon as we have seen an OID at or above
-        // kPgUpperBoundNormalObjectId.
-        break;
-      }
-
+      maximum_oids.UpdateWithOid(oid_col->uint32_value());
       if (!relfilenode_present) {
         continue;
       }
@@ -1832,13 +1836,10 @@ Result<uint32_t> SysCatalogTable::ReadHighestNormalPreservableOid(uint32_t datab
           relfilenode_col, IllegalState,
           "Could not read relfilenode column from table ID $0 from database ID $1:",
           read_data.table_id, database_oid);
-      const uint32_t relfilenode = relfilenode_col->uint32_value();
-      if (relfilenode < kPgUpperBoundNormalObjectId) {
-        maximum_normal_oid = std::max(maximum_normal_oid, relfilenode);
-      }
+      maximum_oids.UpdateWithOid(relfilenode_col->uint32_value());
     }
   }
-  return maximum_normal_oid;
+  return maximum_oids;
 }
 
 Result<DbOidVersionToMessageListMap>
@@ -1894,7 +1895,7 @@ Status SysCatalogTable::ReadYsqlCatalogInvalationMessagesImpl(
     const auto& current_version_col = source_row.GetValue(current_version_col_id);
     SCHECK(current_version_col, IllegalState,
            "Could not read current_version from pg_yb_invalidation_messages");
-    const uint64_t current_version = static_cast<uint64_t>(current_version_col->int64_value());
+    const auto current_version = static_cast<uint64_t>(current_version_col->int64_value());
 
     // Fetch the messages.
     const auto& messages_col = source_row.GetValue(messages_col_id);
@@ -2212,8 +2213,8 @@ Result<RelTypeOIDMap> SysCatalogTable::ReadCompositeTypeFromPgClass(
   {
     const dockv::KeyEntryValues empty_key_components;
     docdb::DocPgsqlScanSpec spec(
-        schema, rocksdb::kDefaultQueryId, empty_key_components, empty_key_components, nullptr,
-        std::nullopt /* hash_code */, std::nullopt /* max_hash_code */);
+        schema, rocksdb::kDefaultQueryId, empty_key_components, empty_key_components,
+        /*condition=*/nullptr, /*hash_code=*/std::nullopt, /*max_hash_code=*/std::nullopt);
     RETURN_NOT_OK(iter->Init(spec));
   }
 
diff --git a/src/yb/master/sys_catalog.h b/src/yb/master/sys_catalog.h
index 36020dc862..d5d12a15c6 100644
--- a/src/yb/master/sys_catalog.h
+++ b/src/yb/master/sys_catalog.h
@@ -32,8 +32,8 @@
 #pragma once
 
 #include <string>
-#include <vector>
 #include <unordered_map>
+#include <vector>
 
 #include "yb/common/pg_types.h"
 #include "yb/common/ql_protocol.pb.h"
@@ -53,12 +53,11 @@
 
 #include "yb/tserver/tablet_memory_manager.h"
 
-#include "yb/rpc/thread_pool.h"
-
 #include "yb/util/mem_tracker.h"
 #include "yb/util/metrics_fwd.h"
 #include "yb/util/pb_util.h"
 #include "yb/util/status_fwd.h"
+#include "yb/util/tostring.h"
 #include "yb/util/unique_lock.h"
 
 namespace yb {
@@ -96,6 +95,17 @@ struct PgTableReadData {
       const dockv::ReaderProjection& projection) const;
 };
 
+// Instances of this are used to accumulate the maximum OID simultaneously for both OID spaces.
+class MaxOidPerSpace {
+ public:
+  void UpdateWithOid(uint32_t oid);
+
+  uint32_t for_normal_space_ = kPgFirstNormalObjectId;
+  uint32_t for_secondary_space_ = kPgFirstSecondarySpaceObjectId;
+
+  std::string ToString() const;
+};
+
 // SysCatalogTable is a YB table that keeps track of table and
 // tablet metadata.
 // - SysCatalogTable has only one tablet.
@@ -312,9 +322,9 @@ class SysCatalogTable {
   Result<uint32_t> ReadPgYbTablegroupOid(const uint32_t database_oid,
                                          const std::string& grpname);
 
-  // Scan database database_oid's catalog tables to find the highest normal space OID that xCluster
-  // needs to preserve and return it.
-  Result<uint32_t> ReadHighestNormalPreservableOid(uint32_t database_oid);
+  // Scan database database_oid's catalog tables to find the highest normal and secondary space OIDs
+  // that xCluster needs to preserve and return them.
+  Result<MaxOidPerSpace> ReadHighestPreservableOids(uint32_t database_oid);
 
   // Copy the content of co-located tables in sys catalog as a batch.
   Status CopyPgsqlTables(const std::vector<TableId>& source_table_ids,
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
index bcda194e96..69e6aad133 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
@@ -312,10 +312,10 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
 
         return Status::OK();
       },
-      .set_normal_oid_counter_above_all_normal_oids_func =
-          [](NamespaceId namespace_id) -> Status { return Status::OK(); },
+      .advance_oid_counters_func =
+          [](const NamespaceId& namespace_id) -> Status { return Status::OK(); },
       .get_normal_oid_higher_than_any_used_normal_oid_func =
-          [](NamespaceId namespace_id) -> Result<uint32_t> { return 100'000; },
+          [](const NamespaceId& namespace_id) -> Result<uint32_t> { return 100'000; },
       .get_namespace_func =
           std::bind(&XClusterOutboundReplicationGroupMockedTest::GetNamespace, this, _1),
       .get_tables_func =
@@ -344,7 +344,7 @@ class XClusterOutboundReplicationGroupMockedTest : public YBTest {
             }
             return table_designators;
           },
-      .is_automatic_mode_switchover_func = [](NamespaceId) { return false; },
+      .is_automatic_mode_switchover_func = [](const NamespaceId&) { return false; },
       .create_xcluster_streams_func =
           [this](const std::vector<TableId>& table_ids, const LeaderEpoch&) {
             auto create_context = std::make_unique<XClusterCreateStreamsContext>();
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.h b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
index 6acdd027a1..6e1152e795 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.h
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
@@ -39,16 +39,15 @@ class XClusterOutboundReplicationGroup
  public:
   struct HelperFunctions {
     const std::function<Status()> create_sequences_data_table_func;
-    const std::function<Status(NamespaceId namespace_id)>
-        set_normal_oid_counter_above_all_normal_oids_func;
-    const std::function<Result<uint32_t>(NamespaceId namespace_id)>
+    const std::function<Status(const NamespaceId& namespace_id)> advance_oid_counters_func;
+    const std::function<Result<uint32_t>(const NamespaceId& namespace_id)>
         get_normal_oid_higher_than_any_used_normal_oid_func;
     const std::function<Result<scoped_refptr<NamespaceInfo>>(const NamespaceIdentifierPB&)>
         get_namespace_func;
     const std::function<Result<std::vector<TableDesignator>>(
         const NamespaceId&, bool include_sequences_data)>
         get_tables_func;
-    const std::function<bool(NamespaceId namespace_id)> is_automatic_mode_switchover_func;
+    const std::function<bool(const NamespaceId& namespace_id)> is_automatic_mode_switchover_func;
     const std::function<Result<std::unique_ptr<XClusterCreateStreamsContext>>(
         const std::vector<TableId>&, const LeaderEpoch&)>
         create_xcluster_streams_func;
@@ -79,7 +78,7 @@ class XClusterOutboundReplicationGroup
       HelperFunctions helper_functions, scoped_refptr<TasksTracker> tasks_tracker,
       XClusterOutboundReplicationGroupTaskFactory& task_factory);
 
-  virtual ~XClusterOutboundReplicationGroup() = default;
+  ~XClusterOutboundReplicationGroup() override = default;
 
   const xcluster::ReplicationGroupId& Id() const { return outbound_rg_info_->ReplicationGroupId(); }
 
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
index efb167f902..d1c321bfe9 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group_tasks.cc
@@ -79,8 +79,8 @@ Status XClusterCheckpointNamespaceTask::FirstStep() {
 
 Status XClusterCheckpointNamespaceTask::BumpOidCounter() {
   if (outbound_replication_group_.AutomaticDDLMode()) {
-    RETURN_NOT_OK(outbound_replication_group_.helper_functions_
-                      .set_normal_oid_counter_above_all_normal_oids_func(namespace_id_));
+    RETURN_NOT_OK(
+        outbound_replication_group_.helper_functions_.advance_oid_counters_func(namespace_id_));
   }
 
   ScheduleNextStep(
diff --git a/src/yb/master/xcluster/xcluster_source_manager.cc b/src/yb/master/xcluster/xcluster_source_manager.cc
index 74caa4b21b..870e440bef 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.cc
+++ b/src/yb/master/xcluster/xcluster_source_manager.cc
@@ -212,12 +212,14 @@ XClusterSourceManager::InitOutboundReplicationGroup(
                 CoarseMonoClock::now() +
                     MonoDelta::FromSeconds(FLAGS_xcluster_ysql_statement_timeout_sec));
           },
-      .set_normal_oid_counter_above_all_normal_oids_func =
-          [this](NamespaceId namespace_id) {
-            return SetNormalOidCounterAboveAllNormalOids(namespace_id);
+      .advance_oid_counters_func =
+          [&catalog_manager = catalog_manager_](const NamespaceId& namespace_id) {
+            RETURN_NOT_OK(catalog_manager.AdvanceOidCounters(namespace_id));
+            return catalog_manager.InvalidateTserverOidCaches();
           },
       .get_normal_oid_higher_than_any_used_normal_oid_func =
-          [client_future = master_.client_future()](NamespaceId namespace_id) -> Result<uint32_t> {
+          [client_future =
+               master_.client_future()](const NamespaceId& namespace_id) -> Result<uint32_t> {
         auto* yb_client = client_future.get();
         SCHECK(yb_client, IllegalState, "Client not initialized or shutting down");
         // While automatic mode xCluster replication is running, we have an invariant that all
@@ -227,8 +229,8 @@ XClusterSourceManager::InitOutboundReplicationGroup(
         uint32_t begin_oid;
         uint32_t end_oid;
         RETURN_NOT_OK(yb_client->ReservePgsqlOids(
-            namespace_id, /*next_oid=*/0, /*count=*/1, &begin_oid, &end_oid,
-            /*use_secondary_space=*/false));
+            namespace_id, /*next_oid=*/0, /*count=*/1, /*use_secondary_space=*/false, &begin_oid,
+            &end_oid));
         return begin_oid;
       },
       .get_namespace_func =
@@ -242,7 +244,7 @@ XClusterSourceManager::InitOutboundReplicationGroup(
                 catalog_manager, namespace_id, include_sequences_data);
           },
       .is_automatic_mode_switchover_func =
-          [xcluster_manager = master_.xcluster_manager()](NamespaceId namespace_id) {
+          [xcluster_manager = master_.xcluster_manager()](const NamespaceId& namespace_id) {
             // If a namespace under automatic replication mode is both a source and target at the
             // same time, then it is currently undergoing automatic mode switchover.
             return xcluster_manager->IsNamespaceInAutomaticModeSource(namespace_id) &&
@@ -540,11 +542,6 @@ class XClusterCreateStreamContextImpl : public XClusterCreateStreamsContext {
   std::vector<TableId> table_ids;
 };
 
-Status XClusterSourceManager::SetNormalOidCounterAboveAllNormalOids(NamespaceId namespace_id) {
-  RETURN_NOT_OK(catalog_manager_.AdvanceOidCounters(namespace_id));
-  return catalog_manager_.InvalidateTserverOidCaches();
-}
-
 Result<std::unique_ptr<XClusterCreateStreamsContext>>
 XClusterSourceManager::CreateStreamsForDbScoped(
     const std::vector<TableId>& table_ids, const LeaderEpoch& epoch) {
diff --git a/src/yb/master/xcluster/xcluster_source_manager.h b/src/yb/master/xcluster/xcluster_source_manager.h
index 2dbbff0cb4..ca2f3a3a20 100644
--- a/src/yb/master/xcluster/xcluster_source_manager.h
+++ b/src/yb/master/xcluster/xcluster_source_manager.h
@@ -207,8 +207,6 @@ class XClusterSourceManager {
       const xcluster::ReplicationGroupId& replication_group_id) const
       EXCLUDES(outbound_replication_group_map_mutex_);
 
-  Status SetNormalOidCounterAboveAllNormalOids(NamespaceId namespace_id);
-
   Result<std::unique_ptr<XClusterCreateStreamsContext>> CreateStreamsForDbScoped(
       const std::vector<TableId>& table_ids, const LeaderEpoch& epoch);
   Result<xrepl::StreamId> CreateNonTxnStreamForNewTable(
diff --git a/src/yb/master/xcluster/xcluster_target_manager.cc b/src/yb/master/xcluster/xcluster_target_manager.cc
index 39d1e05b19..14d848c455 100644
--- a/src/yb/master/xcluster/xcluster_target_manager.cc
+++ b/src/yb/master/xcluster/xcluster_target_manager.cc
@@ -1271,8 +1271,8 @@ Status XClusterTargetManager::DeleteUniverseReplication(
         uint32_t begin_oid;
         uint32_t end_oid;
         RETURN_NOT_OK(yb_client->ReservePgsqlOids(
-            target_namespace_id, oid_to_bump, /*count=*/1, &begin_oid, &end_oid,
-            /*use_secondary_space=*/false));
+            target_namespace_id, oid_to_bump, /*count=*/1, /*use_secondary_space=*/false,
+            &begin_oid, &end_oid));
       }
       RETURN_NOT_OK(master_.catalog_manager()->InvalidateTserverOidCaches());
     }
diff --git a/src/yb/tserver/pg_client_service.cc b/src/yb/tserver/pg_client_service.cc
index feb1b9d698..7d4bada114 100644
--- a/src/yb/tserver/pg_client_service.cc
+++ b/src/yb/tserver/pg_client_service.cc
@@ -76,14 +76,12 @@
 #include "yb/tserver/ts_local_lock_manager.h"
 #include "yb/tserver/ysql_advisory_lock_table.h"
 
-#include "yb/util/debug.h"
 #include "yb/util/flags/flag_tags.h"
 #include "yb/util/logging.h"
 #include "yb/util/net/net_util.h"
 #include "yb/util/random_util.h"
 #include "yb/util/result.h"
 #include "yb/util/shared_lock.h"
-#include "yb/util/size_literals.h"
 #include "yb/util/status.h"
 #include "yb/util/status_format.h"
 #include "yb/util/status_log.h"
@@ -590,7 +588,7 @@ class PgClientServiceImpl::Impl : public SessionProvider {
     shared_mem_pool_.Start(messenger->scheduler());
   }
 
-  ~Impl() {
+  ~Impl() override {
     cdc_state_table_.reset();
     std::vector<SessionInfoPtr> sessions;
     {
@@ -823,7 +821,8 @@ class PgClientServiceImpl::Impl : public SessionProvider {
 
     uint32_t begin_oid, end_oid;
     RETURN_NOT_OK(client().ReservePgsqlOids(
-        namespace_id, req.next_oid(), req.count(), &begin_oid, &end_oid, false));
+        namespace_id, req.next_oid(), req.count(), /*use_secondary_space=*/false, &begin_oid,
+        &end_oid));
     resp->set_begin_oid(begin_oid);
     resp->set_end_oid(end_oid);
 
@@ -856,8 +855,8 @@ class PgClientServiceImpl::Impl : public SessionProvider {
           oid_chunk.next_oid + static_cast<uint32_t>(FLAGS_TEST_ysql_oid_prefetch_adjustment);
       uint32_t begin_oid, end_oid, oid_cache_invalidations_count;
       RETURN_NOT_OK(client().ReservePgsqlOids(
-          namespace_id, next_oid, FLAGS_ysql_oid_cache_prefetch_size, &begin_oid, &end_oid,
-          use_secondary_space, &oid_cache_invalidations_count));
+          namespace_id, next_oid, FLAGS_ysql_oid_cache_prefetch_size, use_secondary_space,
+          &begin_oid, &end_oid, &oid_cache_invalidations_count));
       oid_chunk.next_oid = begin_oid;
       oid_chunk.oid_count = end_oid - begin_oid;
       oid_chunk.oid_cache_invalidations_count = oid_cache_invalidations_count;
