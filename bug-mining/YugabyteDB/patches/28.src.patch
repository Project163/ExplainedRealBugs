diff --git a/src/yb/integration-tests/CMakeLists.txt b/src/yb/integration-tests/CMakeLists.txt
index c80104cef8..1fcb9df586 100644
--- a/src/yb/integration-tests/CMakeLists.txt
+++ b/src/yb/integration-tests/CMakeLists.txt
@@ -215,7 +215,7 @@ ADD_YB_TEST(xcluster/xcluster_ysql_index-test)
 ADD_YB_TEST(xcluster/xcluster_ysql-test)
 ADD_YB_TEST(xcluster/xcluster-tablet-split-itest)
 ADD_YB_TEST(xcluster/xcluster-test)
-ADD_YB_TEST(xcluster/xcluster_outbound_replication_group-test)
+ADD_YB_TEST(xcluster/xcluster_outbound_replication_group-itest)
 ADD_YB_TEST(retryable_request-test)
 
 set(YB_TEST_LINK_LIBS_SAVED ${YB_TEST_LINK_LIBS})
diff --git a/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-test.cc b/src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
similarity index 100%
rename from src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-test.cc
rename to src/yb/integration-tests/xcluster/xcluster_outbound_replication_group-itest.cc
diff --git a/src/yb/master/CMakeLists.txt b/src/yb/master/CMakeLists.txt
index 38ec349381..d099bd26d0 100644
--- a/src/yb/master/CMakeLists.txt
+++ b/src/yb/master/CMakeLists.txt
@@ -245,6 +245,7 @@ ADD_YB_TEST(sys_catalog_xrepl-test)
 ADD_YB_TEST(table_index_test)
 ADD_YB_TEST(tablet_limits_test)
 ADD_YB_TEST(xcluster/xcluster_safe_time_service-test)
+ADD_YB_TEST(xcluster/xcluster_outbound_replication_group-test)
 
 # Actual master executable. In LTO mode, can also act as the tablet server if executed through a
 # symlink named as the tablet server executable.
diff --git a/src/yb/master/xcluster/master_xcluster_types.h b/src/yb/master/xcluster/master_xcluster_types.h
new file mode 100644
index 0000000000..8d6c40d7d0
--- /dev/null
+++ b/src/yb/master/xcluster/master_xcluster_types.h
@@ -0,0 +1,41 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#pragma once
+
+#include "yb/cdc/xrepl_types.h"
+#include "yb/common/schema.h"
+
+namespace yb::master {
+
+struct NamespaceCheckpointInfo {
+  bool initial_bootstrap_required = false;
+  struct TableInfo {
+    TableId table_id;
+    xrepl::StreamId stream_id;
+    TableName table_name;
+    PgSchemaName pg_schema_name;
+    bool operator==(const TableInfo& rhs) const {
+      return table_id == rhs.table_id && stream_id == rhs.stream_id &&
+             table_name == rhs.table_name && pg_schema_name == rhs.pg_schema_name;
+    }
+  };
+  std::vector<TableInfo> table_infos;
+
+  bool operator==(const NamespaceCheckpointInfo& rhs) const {
+    return initial_bootstrap_required == rhs.initial_bootstrap_required &&
+           table_infos == rhs.table_infos;
+  }
+};
+
+}  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_manager.cc b/src/yb/master/xcluster/xcluster_manager.cc
index 98693124f1..7ebdbe918b 100644
--- a/src/yb/master/xcluster/xcluster_manager.cc
+++ b/src/yb/master/xcluster/xcluster_manager.cc
@@ -19,6 +19,7 @@
 
 #include "yb/master/master.h"
 #include "yb/master/master_cluster.pb.h"
+#include "yb/master/ts_descriptor.h"
 #include "yb/master/xcluster/xcluster_config.h"
 #include "yb/master/xcluster/xcluster_safe_time_service.h"
 
@@ -27,6 +28,8 @@
 #include "yb/util/logging.h"
 #include "yb/util/result.h"
 
+#include "yb/cdc/cdc_service.proxy.h"
+
 DEFINE_test_flag(bool, enable_xcluster_api_v2, false, "Allow the usage of new xCluster APIs");
 
 using namespace std::placeholders;
@@ -103,22 +106,40 @@ Status XClusterManager::InsertOutboundReplicationGroup(
 XClusterOutboundReplicationGroup XClusterManager::InitOutboundReplicationGroup(
     const xcluster::ReplicationGroupId& replication_group_id,
     const SysXClusterOutboundReplicationGroupEntryPB& metadata) {
-  return XClusterOutboundReplicationGroup(
-      replication_group_id, metadata, sys_catalog_,
-      [catalog_manager = catalog_manager_](const NamespaceId& namespace_id) {
-        return catalog_manager->GetTableInfosForNamespace(namespace_id);
+  XClusterOutboundReplicationGroup::HelperFunctions helper_functions = {
+      .get_namespace_id_func =
+          [catalog_manager = catalog_manager_](
+              YQLDatabase db_type, const NamespaceName& namespace_name) {
+            return catalog_manager->GetNamespaceId(db_type, namespace_name);
+          },
+      .get_tables_func =
+          [this](const NamespaceId& namespace_id) { return GetTablesToReplicate(namespace_id); },
+      .bootstrap_tables_func =
+          [this](const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline)
+          -> Result<std::vector<xrepl::StreamId>> {
+        return BootstrapTables(table_infos, deadline);
       },
-      [catalog_manager = catalog_manager_](
-          YQLDatabase db_type, const NamespaceName& namespace_name) {
-        return catalog_manager->GetNamespaceId(db_type, namespace_name);
-      },
-      [catalog_manager = catalog_manager_](
-          const DeleteCDCStreamRequestPB& req,
-          const LeaderEpoch& epoch) -> Result<DeleteCDCStreamResponsePB> {
+      .delete_cdc_stream_func = [catalog_manager = catalog_manager_](
+                                    const DeleteCDCStreamRequestPB& req,
+                                    const LeaderEpoch& epoch) -> Result<DeleteCDCStreamResponsePB> {
         DeleteCDCStreamResponsePB resp;
         RETURN_NOT_OK(catalog_manager->DeleteCDCStream(&req, &resp, nullptr));
         return resp;
-      });
+      },
+      .upsert_to_sys_catalog_func =
+          [sys_catalog = sys_catalog_](
+              const LeaderEpoch& epoch, XClusterOutboundReplicationGroupInfo* info) {
+            return sys_catalog->Upsert(epoch.leader_term, info);
+          },
+      .delete_from_sys_catalog_func =
+          [sys_catalog = sys_catalog_](
+              const LeaderEpoch& epoch, XClusterOutboundReplicationGroupInfo* info) {
+            return sys_catalog->Delete(epoch.leader_term, info);
+          },
+  };
+
+  return XClusterOutboundReplicationGroup(
+      replication_group_id, metadata, std::move(helper_functions));
 }
 
 Result<XClusterOutboundReplicationGroup*> XClusterManager::GetOutboundReplicationGroup(
@@ -465,4 +486,74 @@ Status XClusterManager::GetXClusterStreams(
   return Status::OK();
 }
 
+namespace {
+// Should the table be part of xCluster replication?
+bool ShouldReplicateTable(const TableInfoPtr& table) {
+  if (table->GetTableType() != PGSQL_TABLE_TYPE || table->is_system()) {
+    // Limited to ysql databases.
+    // System tables are not replicated. DDLs statements will be replicated and executed on the
+    // target universe to handle catalog changes.
+    return false;
+  }
+
+  if (table->is_matview()) {
+    // Materialized views need not be replicated, since they are not modified. Every time the view
+    // is refreshed, new tablets are created. The same refresh can just run on the target universe.
+    return false;
+  }
+
+  if (table->IsColocatedUserTable()) {
+    // Only the colocated parent table needs to be replicated.
+    return false;
+  }
+
+  return true;
+}
+
+}  // namespace
+
+Result<std::vector<TableInfoPtr>> XClusterManager::GetTablesToReplicate(
+    const NamespaceId& namespace_id) {
+  auto table_infos = VERIFY_RESULT(catalog_manager_->GetTableInfosForNamespace(namespace_id));
+  EraseIf([](const TableInfoPtr& table) { return !ShouldReplicateTable(table); }, &table_infos);
+  return table_infos;
+}
+
+Result<std::vector<xrepl::StreamId>> XClusterManager::BootstrapTables(
+    const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline) {
+  cdc::BootstrapProducerRequestPB bootstrap_req;
+  master::TSDescriptor* ts = nullptr;
+  for (const auto& table_info : table_infos) {
+    bootstrap_req.add_table_ids(table_info->id());
+
+    if (!ts) {
+      ts = VERIFY_RESULT(table_info->GetTablets().front()->GetLeader());
+    }
+  }
+  SCHECK(ts, IllegalState, "No valid tserver found to bootstrap from");
+
+  std::shared_ptr<cdc::CDCServiceProxy> proxy;
+  RETURN_NOT_OK(ts->GetProxy(&proxy));
+
+  cdc::BootstrapProducerResponsePB bootstrap_resp;
+  rpc::RpcController bootstrap_rpc;
+  bootstrap_rpc.set_deadline(deadline);
+
+  // TODO(Hari): DB-9416 Make this async and atomic with upsert of the outbound replication group.
+  RETURN_NOT_OK(proxy->BootstrapProducer(bootstrap_req, &bootstrap_resp, &bootstrap_rpc));
+  if (bootstrap_resp.has_error()) {
+    RETURN_NOT_OK(StatusFromPB(bootstrap_resp.error().status()));
+  }
+
+  SCHECK_EQ(
+      table_infos.size(), bootstrap_resp.cdc_bootstrap_ids_size(), IllegalState,
+      "Number of tables to bootstrap and number of bootstrap ids do not match");
+
+  std::vector<xrepl::StreamId> stream_ids;
+  for (const auto& bootstrap_id : bootstrap_resp.cdc_bootstrap_ids()) {
+    stream_ids.emplace_back(VERIFY_RESULT(xrepl::StreamId::FromString(bootstrap_id)));
+  }
+  return stream_ids;
+}
+
 }  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_manager.h b/src/yb/master/xcluster/xcluster_manager.h
index d34a464af7..d54bf79dc4 100644
--- a/src/yb/master/xcluster/xcluster_manager.h
+++ b/src/yb/master/xcluster/xcluster_manager.h
@@ -146,6 +146,11 @@ class XClusterManager : public XClusterManagerIf {
       const xcluster::ReplicationGroupId& replication_group_id) const
       REQUIRES_SHARED(outbound_replication_group_map_mutex_);
 
+  Result<std::vector<TableInfoPtr>> GetTablesToReplicate(const NamespaceId& namespace_id);
+
+  Result<std::vector<xrepl::StreamId>> BootstrapTables(
+      const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline);
+
   Master* const master_;
   CatalogManager* const catalog_manager_;
   SysCatalogTable* const sys_catalog_;
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
new file mode 100644
index 0000000000..032d337b9a
--- /dev/null
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group-test.cc
@@ -0,0 +1,249 @@
+// Copyright (c) YugabyteDB, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+// in compliance with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied.  See the License for the specific language governing permissions and limitations
+// under the License.
+//
+
+#include "yb/master/xcluster/xcluster_outbound_replication_group.h"
+
+#include "yb/master/catalog_entity_info.h"
+
+#include "yb/util/test_util.h"
+
+namespace yb::master {
+
+class XClusterOutboundReplicationGroupMockedTest : public YBTest {
+ public:
+  const NamespaceName kNamespaceName = "db1";
+  const NamespaceId kNamespaceId = "db1_id";
+  const PgSchemaName kPgSchemaName = "public", kPgSchemaName2 = "public2";
+  const xcluster::ReplicationGroupId kReplicationGroupId = xcluster::ReplicationGroupId("rg1");
+  const TableName kTableName1 = "table1", kTableName2 = "table2";
+  const TableId kTableId1 = "table_id_1", kTableId2 = "table_id_2";
+  const LeaderEpoch kEpoch = LeaderEpoch(1, 1);
+  const CoarseTimePoint kDeadline = CoarseTimePoint::max();
+
+  XClusterOutboundReplicationGroupMockedTest() {
+    google::SetVLOGLevel("xcluster*", 4);
+
+    CreateNamespace(kNamespaceName, kNamespaceId);
+  }
+
+  void CreateNamespace(const NamespaceName& namespace_name, const NamespaceId& namespace_id) {
+    namespace_ids[namespace_name] = namespace_id;
+  }
+
+  TableInfoPtr CreateTable(
+      const NamespaceId& namespace_id, const TableId& table_id, const TableName& table_name,
+      const PgSchemaName& pg_schema_name) {
+    auto table_info = TableInfoPtr(new TableInfo(table_id, /*colocated=*/false));
+    auto l = table_info->LockForWrite();
+    auto& pb = l.mutable_data()->pb;
+    pb.set_name(table_name);
+    pb.set_namespace_id(namespace_id);
+    pb.mutable_schema()->set_pgschema_name(pg_schema_name);
+    pb.set_table_type(PGSQL_TABLE_TYPE);
+    l.Commit();
+
+    namespace_tables[namespace_id].push_back(table_info);
+    return table_info;
+  }
+
+  XClusterOutboundReplicationGroup CreateReplicationGroup() {
+    return XClusterOutboundReplicationGroup(kReplicationGroupId, {}, helper_functions);
+  }
+
+  xrepl::StreamId CreateXClusterStream(const TableId& table_id) {
+    auto stream_id = xrepl::StreamId::GenerateRandom();
+    xcluster_streams.insert(stream_id);
+    return stream_id;
+  }
+
+  std::unordered_map<NamespaceId, std::vector<TableInfoPtr>> namespace_tables;
+  std::unordered_map<NamespaceName, NamespaceId> namespace_ids;
+  std::unordered_set<xrepl::StreamId> xcluster_streams;
+
+  XClusterOutboundReplicationGroup::HelperFunctions helper_functions = {
+      .get_namespace_id_func =
+          [this](YQLDatabase db_type, const NamespaceName& namespace_name) {
+            return namespace_ids[namespace_name];
+          },
+      .get_tables_func =
+          [this](const NamespaceId& namespace_id) { return namespace_tables[namespace_id]; },
+      .bootstrap_tables_func =
+          [this](const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline)
+          -> Result<std::vector<xrepl::StreamId>> {
+        std::vector<xrepl::StreamId> stream_ids;
+        for (const auto& table_info : table_infos) {
+          stream_ids.emplace_back(CreateXClusterStream(table_info->id()));
+        }
+        return stream_ids;
+      },
+      .delete_cdc_stream_func = [this](
+                                    const DeleteCDCStreamRequestPB& req,
+                                    const LeaderEpoch& epoch) -> Result<DeleteCDCStreamResponsePB> {
+        DeleteCDCStreamResponsePB resp;
+        for (const auto& stream_id_str : req.stream_id()) {
+          auto stream_id = VERIFY_RESULT(xrepl::StreamId::FromString(stream_id_str));
+          SCHECK(xcluster_streams.contains(stream_id), InternalError, "Stream not found");
+          xcluster_streams.erase(stream_id);
+        }
+        return resp;
+      },
+      .upsert_to_sys_catalog_func =
+          [](const LeaderEpoch& epoch, XClusterOutboundReplicationGroupInfo* info) {
+            return Status::OK();
+          },
+      .delete_from_sys_catalog_func =
+          [](const LeaderEpoch& epoch, XClusterOutboundReplicationGroupInfo* info) {
+            return Status::OK();
+          },
+  };
+
+  void VerifyNamespaceCheckpointInfo(
+      const TableId& table_id1, const TableId& table_id2, const NamespaceCheckpointInfo& ns_info,
+      bool skip_schema_name_check = false) {
+    ASSERT_FALSE(ns_info.initial_bootstrap_required);
+    ASSERT_EQ(ns_info.table_infos.size(), 2);
+    std::set<TableId> table_ids;
+    for (const auto& table_info : ns_info.table_infos) {
+      if (table_info.table_name == kTableName1) {
+        ASSERT_EQ(table_info.table_id, table_id1);
+      } else if (table_info.table_name == kTableName2) {
+        ASSERT_EQ(table_info.table_id, table_id2);
+      } else {
+        FAIL() << "Unexpected table name: " << table_info.table_name;
+      }
+      if (skip_schema_name_check) {
+        // Make sure it is not empty.
+        ASSERT_FALSE(table_info.pg_schema_name.empty());
+      } else {
+        ASSERT_EQ(table_info.pg_schema_name, kPgSchemaName);
+      }
+      ASSERT_FALSE(table_info.stream_id.IsNil());
+      ASSERT_TRUE(xcluster_streams.contains(table_info.stream_id));
+
+      table_ids.insert(table_info.table_id);
+    }
+    ASSERT_TRUE(table_ids.contains(table_id1));
+    ASSERT_TRUE(table_ids.contains(table_id2));
+  }
+};
+
+TEST_F(XClusterOutboundReplicationGroupMockedTest, TestMultipleTable) {
+  CreateTable(kNamespaceId, kTableId1, kTableName1, kPgSchemaName);
+  CreateTable(kNamespaceId, kTableId2, kTableName2, kPgSchemaName2);
+  auto outbound_rg = CreateReplicationGroup();
+
+  auto namespace_id = ASSERT_RESULT(outbound_rg.AddNamespace(kEpoch, kNamespaceName, kDeadline));
+  ASSERT_EQ(namespace_id, kNamespaceId);
+
+  auto ns_info_opt = ASSERT_RESULT(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
+  ASSERT_TRUE(ns_info_opt.has_value());
+
+  // We should have 2 streams now.
+  ASSERT_EQ(xcluster_streams.size(), 2);
+
+  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(
+      kTableId1, kTableId2, *ns_info_opt, /*skip_schema_name_check=*/true));
+  for (const auto& table_info : ns_info_opt->table_infos) {
+    // Order is not deterministic so search with the table name.
+    if (table_info.table_name == kTableName1) {
+      ASSERT_EQ(table_info.pg_schema_name, kPgSchemaName);
+    } else {
+      ASSERT_EQ(table_info.pg_schema_name, kPgSchemaName2);
+    }
+  }
+
+  // Get the table info in a custom order.
+  ns_info_opt = ASSERT_RESULT(outbound_rg.GetNamespaceCheckpointInfo(
+      kNamespaceId, {{kTableName2, kPgSchemaName2}, {kTableName1, kPgSchemaName}}));
+  ASSERT_TRUE(ns_info_opt.has_value());
+
+  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(
+      kTableId1, kTableId2, *ns_info_opt, /*skip_schema_name_check=*/true));
+  ASSERT_EQ(ns_info_opt->table_infos[0].pg_schema_name, kPgSchemaName2);
+  ASSERT_EQ(ns_info_opt->table_infos[1].pg_schema_name, kPgSchemaName);
+  ASSERT_EQ(ns_info_opt->table_infos[0].table_name, kTableName2);
+  ASSERT_EQ(ns_info_opt->table_infos[1].table_name, kTableName1);
+
+  ASSERT_OK(outbound_rg.Delete(kEpoch));
+  ASSERT_FALSE(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
+
+  // We should have 0 streams now.
+  ASSERT_TRUE(xcluster_streams.empty());
+}
+
+TEST_F(XClusterOutboundReplicationGroupMockedTest, AddDeleteNamespaces) {
+  CreateTable(kNamespaceId, kTableId1, kTableName1, kPgSchemaName);
+  CreateTable(kNamespaceId, kTableId2, kTableName2, kPgSchemaName);
+
+  const NamespaceName namespace_name_2 = "db2";
+  const NamespaceId namespace_id_2 = "ns_id_2";
+  const TableId ns2_table_id_1 = "ns2_table_id_1", ns2_table_id_2 = "ns2_table_id_2";
+  CreateNamespace(namespace_name_2, namespace_id_2);
+  CreateTable(namespace_id_2, ns2_table_id_1, kTableName1, kPgSchemaName);
+  CreateTable(namespace_id_2, ns2_table_id_2, kTableName2, kPgSchemaName);
+
+  auto outbound_rg = CreateReplicationGroup();
+  auto out_namespace_id =
+      ASSERT_RESULT(outbound_rg.AddNamespaces(kEpoch, {kNamespaceName}, kDeadline));
+  ASSERT_EQ(out_namespace_id.size(), 1);
+  ASSERT_EQ(out_namespace_id[0], kNamespaceId);
+
+  // We should have 2 streams now.
+  ASSERT_EQ(xcluster_streams.size(), 2);
+  auto xcluster_streams_initial = xcluster_streams;
+
+  // Make sure invalid namespace id is handled correctly.
+  ASSERT_NOK(outbound_rg.GetNamespaceCheckpointInfo("BadId"));
+
+  // Make sure only the namespace that was added is returned.
+  ASSERT_NOK(outbound_rg.GetNamespaceCheckpointInfo(namespace_id_2));
+
+  auto ns1_info_opt = ASSERT_RESULT(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
+  ASSERT_TRUE(ns1_info_opt.has_value());
+  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(kTableId1, kTableId2, *ns1_info_opt));
+
+  // Add the second namespace.
+  auto out_namespace_id2 =
+      ASSERT_RESULT(outbound_rg.AddNamespace(kEpoch, namespace_name_2, kDeadline));
+  ASSERT_EQ(out_namespace_id2, namespace_id_2);
+
+  // We should have 4 streams now.
+  ASSERT_EQ(xcluster_streams.size(), 4);
+
+  // The info of the first namespace should not change.
+  auto ns1_info_dup = ASSERT_RESULT(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
+  ASSERT_TRUE(ns1_info_opt.has_value());
+  ASSERT_EQ(*ns1_info_dup, *ns1_info_opt);
+
+  // Validate the seconds namespace.
+  auto ns2_info_opt = ASSERT_RESULT(outbound_rg.GetNamespaceCheckpointInfo(namespace_id_2));
+  ASSERT_TRUE(ns2_info_opt.has_value());
+  ASSERT_NO_FATALS(VerifyNamespaceCheckpointInfo(ns2_table_id_1, ns2_table_id_2, *ns2_info_opt));
+
+  ASSERT_OK(outbound_rg.RemoveNamespace(kEpoch, kNamespaceId));
+  ASSERT_NOK(outbound_rg.GetNamespaceCheckpointInfo(kNamespaceId));
+
+  // We should only have only the streams from second namespace.
+  ASSERT_EQ(xcluster_streams.size(), 2);
+
+  // new_xcluster_streams and all_xcluster_streams should not overlap.
+  for (const auto& stream : xcluster_streams) {
+    ASSERT_FALSE(xcluster_streams_initial.contains(stream));
+  }
+
+  ASSERT_OK(outbound_rg.Delete(kEpoch));
+  ASSERT_NOK(outbound_rg.GetNamespaceCheckpointInfo(namespace_id_2));
+  ASSERT_TRUE(xcluster_streams.empty());
+}
+
+}  // namespace yb::master
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
index 8883f7d709..892242e321 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.cc
@@ -12,9 +12,7 @@
 //
 
 #include "yb/master/xcluster/xcluster_outbound_replication_group.h"
-#include "yb/cdc/cdc_service.proxy.h"
 #include "yb/master/catalog_entity_info.h"
-#include "yb/master/ts_descriptor.h"
 
 namespace yb::master {
 
@@ -29,38 +27,35 @@ struct TableSchemaNamePairHash {
   }
 };
 
-Result<SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB> BootstrapTables(
-    const NamespaceName& namespace_id, const std::vector<scoped_refptr<TableInfo>>& table_infos,
-    CoarseTimePoint deadline) {
-  SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB ns_info;
-  ns_info.set_state(SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB::CHECKPOINTING);
-
-  cdc::BootstrapProducerRequestPB bootstrap_req;
-  master::TSDescriptor* ts = nullptr;
-  for (const auto& table_info : table_infos) {
-    bootstrap_req.add_table_ids(table_info->id());
+}  // namespace
 
-    if (!ts) {
-      ts = VERIFY_RESULT(table_info->GetTablets().front()->GetLeader());
-    }
-  }
-  SCHECK(ts, IllegalState, "No valid tserver found to bootstrap from");
+XClusterOutboundReplicationGroup::XClusterOutboundReplicationGroup(
+    const xcluster::ReplicationGroupId& replication_group_id,
+    const SysXClusterOutboundReplicationGroupEntryPB& outbound_replication_group_pb,
+    HelperFunctions helper_functions)
+    : helper_functions_(std::move(helper_functions)) {
+  outbound_rg_info_ = std::make_unique<XClusterOutboundReplicationGroupInfo>(replication_group_id);
+  outbound_rg_info_->Load(outbound_replication_group_pb);
+}
 
-  std::shared_ptr<cdc::CDCServiceProxy> proxy;
-  RETURN_NOT_OK(ts->GetProxy(&proxy));
+Status XClusterOutboundReplicationGroup::Upsert(
+    XClusterOutboundReplicationGroupInfo::WriteLock& l, const LeaderEpoch& epoch) {
+  auto status = helper_functions_.upsert_to_sys_catalog_func(epoch, outbound_rg_info_.get());
+  l.CommitOrWarn(status, "updating xClusterOutboundReplicationGroup in sys-catalog");
+  return status;
+}
 
-  cdc::BootstrapProducerResponsePB bootstrap_resp;
-  rpc::RpcController bootstrap_rpc;
-  bootstrap_rpc.set_deadline(deadline);
+Result<SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB>
+XClusterOutboundReplicationGroup::BootstrapTables(
+    const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline) {
+  SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB ns_info;
+  ns_info.set_state(SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB::CHECKPOINTING);
 
-  // TODO(Hari): DB-9416 Make this async and atomic with upsert of xClusterOutboundReplicationGroup.
-  RETURN_NOT_OK(proxy->BootstrapProducer(bootstrap_req, &bootstrap_resp, &bootstrap_rpc));
-  if (bootstrap_resp.has_error()) {
-    RETURN_NOT_OK(StatusFromPB(bootstrap_resp.error().status()));
-  }
+  auto bootstrap_ids =
+      VERIFY_RESULT(helper_functions_.bootstrap_tables_func(table_infos, deadline));
 
   SCHECK_EQ(
-      table_infos.size(), bootstrap_resp.cdc_bootstrap_ids_size(), IllegalState,
+      table_infos.size(), bootstrap_ids.size(), IllegalState,
       "Number of tables to bootstrap and number of bootstrap ids do not match");
 
   bool initial_bootstrap_required = false;
@@ -69,7 +64,7 @@ Result<SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB> BootstrapTab
     // initial_bootstrap_required |= bootstrap_resp.bootstrap_required(i);
 
     SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB::TableInfoPB table_info;
-    table_info.set_stream_id(bootstrap_resp.cdc_bootstrap_ids(static_cast<int>(i)));
+    table_info.set_stream_id(bootstrap_ids[i].ToString());
     ns_info.mutable_table_infos()->insert({table_infos[i]->id(), std::move(table_info)});
   }
 
@@ -79,71 +74,12 @@ Result<SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB> BootstrapTab
   return ns_info;
 }
 
-// Should the table be part of xCluster replication?
-bool ShouldReplicateTable(const scoped_refptr<TableInfo>& table) {
-  if (table->GetTableType() != PGSQL_TABLE_TYPE || table->is_system()) {
-    // Limited to ysql databases.
-    // System tables are not replicated. DDLs statements will be replicated and executed on the
-    // target universe to handle catalog changes.
-    return false;
-  }
-
-  if (table->is_matview()) {
-    // Materialized views need not be replicated, since they are not modified. Every time the view
-    // is refreshed, new tablets are created. The same refresh can just run on the target universe.
-    return false;
-  }
-
-  if (table->IsColocatedUserTable()) {
-    // Only the colocated parent table needs to be replicated.
-    return false;
-  }
-
-  return true;
-}
-
-}  // namespace
-
-XClusterOutboundReplicationGroup::XClusterOutboundReplicationGroup(
-    const xcluster::ReplicationGroupId& replication_group_id,
-    const SysXClusterOutboundReplicationGroupEntryPB& outbound_replication_group_pb,
-    SysCatalogTable* sys_catalog,
-    std::function<Result<std::vector<scoped_refptr<TableInfo>>>(const NamespaceId&)>
-        get_tables_func,
-    std::function<Result<NamespaceId>(YQLDatabase db_type, const NamespaceName& namespace_name)>
-        get_namespace_id_func,
-    std::function<Result<DeleteCDCStreamResponsePB>(
-        const DeleteCDCStreamRequestPB&, const LeaderEpoch& epoch)>
-        delete_cdc_stream_func)
-    : sys_catalog_(sys_catalog),
-      get_tables_func_(std::move(get_tables_func)),
-      get_namespace_id_func_(std::move(get_namespace_id_func)),
-      delete_cdc_stream_func_(std::move(delete_cdc_stream_func)) {
-  outbound_rg_info_ = std::make_unique<XClusterOutboundReplicationGroupInfo>(replication_group_id);
-  outbound_rg_info_->Load(outbound_replication_group_pb);
-}
-
-Status XClusterOutboundReplicationGroup::Upsert(
-    XClusterOutboundReplicationGroupInfo::WriteLock& l, const LeaderEpoch& epoch) {
-  auto status = sys_catalog_->Upsert(epoch.leader_term, outbound_rg_info_.get());
-  l.CommitOrWarn(status, "updating xClusterOutboundReplicationGroup in sys-catalog");
-  return status;
-}
-
-Result<std::vector<scoped_refptr<TableInfo>>> XClusterOutboundReplicationGroup::GetTables(
-    const NamespaceId& namespace_id) const {
-  auto table_infos = VERIFY_RESULT(get_tables_func_(namespace_id));
-  EraseIf(
-      [](const scoped_refptr<TableInfo>& table) { return !ShouldReplicateTable(table); },
-      &table_infos);
-  return table_infos;
-}
-
 Result<NamespaceId> XClusterOutboundReplicationGroup::AddNamespaceInternal(
     const NamespaceName& namespace_name, CoarseTimePoint deadline,
     XClusterOutboundReplicationGroupInfo::WriteLock& l) {
   SCHECK(!namespace_name.empty(), InvalidArgument, "Namespace name cannot be empty");
-  auto namespace_id = VERIFY_RESULT(get_namespace_id_func_(YQL_DATABASE_PGSQL, namespace_name));
+  auto namespace_id =
+      VERIFY_RESULT(helper_functions_.get_namespace_id_func(YQL_DATABASE_PGSQL, namespace_name));
 
   auto& outbound_group_pb = l.mutable_data()->pb;
 
@@ -153,8 +89,8 @@ Result<NamespaceId> XClusterOutboundReplicationGroup::AddNamespaceInternal(
     return namespace_id;
   }
 
-  auto table_infos = VERIFY_RESULT(GetTables(namespace_id));
-  auto ns_checkpoint_info = VERIFY_RESULT(BootstrapTables(namespace_id, table_infos, deadline));
+  auto table_infos = VERIFY_RESULT(helper_functions_.get_tables_func(namespace_id));
+  auto ns_checkpoint_info = VERIFY_RESULT(BootstrapTables(table_infos, deadline));
   (*outbound_group_pb.mutable_namespace_infos())[namespace_id] = std::move(ns_checkpoint_info);
 
   return namespace_id;
@@ -208,7 +144,7 @@ Status XClusterOutboundReplicationGroup::DeleteNamespaceStreams(
 
   req.set_force_delete(true);
   req.set_ignore_errors(false);
-  auto resp = VERIFY_RESULT(delete_cdc_stream_func_(req, epoch));
+  auto resp = VERIFY_RESULT(helper_functions_.delete_cdc_stream_func(req, epoch));
   if (resp.has_error()) {
     return StatusFromPB(resp.error().status());
   }
@@ -237,7 +173,7 @@ Status XClusterOutboundReplicationGroup::Delete(const LeaderEpoch& epoch) {
   }
   outbound_group_pb.mutable_namespace_infos()->clear();
 
-  auto status = sys_catalog_->Delete(epoch.leader_term, outbound_rg_info_.get());
+  auto status = helper_functions_.delete_from_sys_catalog_func(epoch, outbound_rg_info_.get());
   l.CommitOrWarn(status, "updating xClusterOutboundReplicationGroup in sys-catalog");
 
   return status;
@@ -260,7 +196,7 @@ Result<std::optional<bool>> XClusterOutboundReplicationGroup::IsBootstrapRequire
   return namespace_info.initial_bootstrap_required();
 }
 
-Result<std::optional<XClusterOutboundReplicationGroup::NamespaceCheckpointInfo>>
+Result<std::optional<NamespaceCheckpointInfo>>
 XClusterOutboundReplicationGroup::GetNamespaceCheckpointInfo(
     const NamespaceId& namespace_id,
     const std::vector<std::pair<TableName, PgSchemaName>>& table_names) const {
@@ -280,7 +216,7 @@ XClusterOutboundReplicationGroup::GetNamespaceCheckpointInfo(
   NamespaceCheckpointInfo ns_info;
   ns_info.initial_bootstrap_required = namespace_info.initial_bootstrap_required();
 
-  auto all_tables = VERIFY_RESULT(GetTables(namespace_id));
+  auto all_tables = VERIFY_RESULT(helper_functions_.get_tables_func(namespace_id));
   std::vector<scoped_refptr<TableInfo>> table_infos;
 
   if (!table_names.empty()) {
diff --git a/src/yb/master/xcluster/xcluster_outbound_replication_group.h b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
index e63d5a7024..55fe102cad 100644
--- a/src/yb/master/xcluster/xcluster_outbound_replication_group.h
+++ b/src/yb/master/xcluster/xcluster_outbound_replication_group.h
@@ -13,6 +13,7 @@
 
 #pragma once
 
+#include "yb/master/xcluster/master_xcluster_types.h"
 #include "yb/master/xcluster/xcluster_catalog_entity.h"
 
 namespace yb {
@@ -20,17 +21,28 @@ namespace master {
 
 class XClusterOutboundReplicationGroup {
  public:
+  struct HelperFunctions {
+    const std::function<Result<NamespaceId>(YQLDatabase, const NamespaceName&)>
+        get_namespace_id_func;
+    const std::function<Result<std::vector<TableInfoPtr>>(const NamespaceId&)> get_tables_func;
+    const std::function<Result<std::vector<xrepl::StreamId>>(
+        const std::vector<TableInfoPtr>&, CoarseTimePoint)>
+        bootstrap_tables_func;
+    const std::function<Result<DeleteCDCStreamResponsePB>(
+        const DeleteCDCStreamRequestPB&, const LeaderEpoch&)>
+        delete_cdc_stream_func;
+
+    // SysCatalog functions.
+    const std::function<Status(const LeaderEpoch& epoch, XClusterOutboundReplicationGroupInfo*)>
+        upsert_to_sys_catalog_func;
+    const std::function<Status(const LeaderEpoch& epoch, XClusterOutboundReplicationGroupInfo*)>
+        delete_from_sys_catalog_func;
+  };
+
   explicit XClusterOutboundReplicationGroup(
       const xcluster::ReplicationGroupId& replication_group_id,
       const SysXClusterOutboundReplicationGroupEntryPB& outbound_replication_group_pb,
-      SysCatalogTable* sys_catalog,
-      std::function<Result<std::vector<scoped_refptr<TableInfo>>>(const NamespaceId&)>
-          get_tables_func,
-      std::function<Result<NamespaceId>(YQLDatabase db_type, const NamespaceName& namespace_name)>
-          get_namespace_id_func,
-      std::function<Result<DeleteCDCStreamResponsePB>(
-          const DeleteCDCStreamRequestPB&, const LeaderEpoch& epoch)>
-          delete_cdc_stream_func);
+      HelperFunctions helper_functions);
 
   const xcluster::ReplicationGroupId& Id() const { return outbound_rg_info_->ReplicationGroupId(); }
 
@@ -48,17 +60,6 @@ class XClusterOutboundReplicationGroup {
 
   Status Delete(const LeaderEpoch& epoch);
 
-  struct NamespaceCheckpointInfo {
-    bool initial_bootstrap_required = false;
-    struct TableInfo {
-      TableId table_id;
-      xrepl::StreamId stream_id;
-      TableName table_name;
-      PgSchemaName pg_schema_name;
-    };
-    std::vector<TableInfo> table_infos;
-  };
-
   // Returns std::nullopt if the namespace is not yet ready.
   Result<std::optional<bool>> IsBootstrapRequired(const NamespaceId& namespace_id) const;
 
@@ -70,9 +71,6 @@ class XClusterOutboundReplicationGroup {
       const std::vector<TableSchemaNamePair>& table_names = {}) const;
 
  private:
-  // Returns the user table infos for the given namespace.
-  Result<std::vector<scoped_refptr<TableInfo>>> GetTables(const NamespaceId& namespace_id) const;
-
   Result<NamespaceId> AddNamespaceInternal(
       const NamespaceName& namespace_name, CoarseTimePoint deadline,
       XClusterOutboundReplicationGroupInfo::WriteLock& l);
@@ -84,15 +82,12 @@ class XClusterOutboundReplicationGroup {
       const LeaderEpoch& epoch, const NamespaceId& namespace_id,
       const SysXClusterOutboundReplicationGroupEntryPB& pb);
 
-  std::unique_ptr<XClusterOutboundReplicationGroupInfo> outbound_rg_info_;
+  Result<SysXClusterOutboundReplicationGroupEntryPB::NamespaceInfoPB> BootstrapTables(
+      const std::vector<TableInfoPtr>& table_infos, CoarseTimePoint deadline);
 
-  SysCatalogTable* const sys_catalog_;
-  std::function<Result<std::vector<scoped_refptr<TableInfo>>>(const NamespaceId&)> get_tables_func_;
-  std::function<Result<NamespaceId>(YQLDatabase db_type, const NamespaceName& namespace_name)>
-      get_namespace_id_func_;
-  std::function<Result<DeleteCDCStreamResponsePB>(
-      const DeleteCDCStreamRequestPB&, const LeaderEpoch& epoch)>
-      delete_cdc_stream_func_;
+  HelperFunctions helper_functions_;
+
+  std::unique_ptr<XClusterOutboundReplicationGroupInfo> outbound_rg_info_;
 };
 
 }  // namespace master
